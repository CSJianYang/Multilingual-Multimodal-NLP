[
    {
        "title": "Count the Number of K-Free Subsets",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1944373,
                "content": [
                    {
                        "username": "feimi",
                        "content": "this is a hard problem."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this is a hard!!"
                    },
                    {
                        "username": "surajvg93",
                        "content": "Same as question 2597: [https://leetcode.com/problems/the-number-of-beautiful-subsets/](https://leetcode.com/problems/the-number-of-beautiful-subsets/)"
                    },
                    {
                        "username": "sJQpVnXqyHEg",
                        "content": "[2,2,2] is not an accepted test case, but accepted in 2597. "
                    }
                ]
            },
            {
                "id": 1929130,
                "content": [
                    {
                        "username": "feimi",
                        "content": "this is a hard problem."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this is a hard!!"
                    },
                    {
                        "username": "surajvg93",
                        "content": "Same as question 2597: [https://leetcode.com/problems/the-number-of-beautiful-subsets/](https://leetcode.com/problems/the-number-of-beautiful-subsets/)"
                    },
                    {
                        "username": "sJQpVnXqyHEg",
                        "content": "[2,2,2] is not an accepted test case, but accepted in 2597. "
                    }
                ]
            },
            {
                "id": 1990026,
                "content": [
                    {
                        "username": "feimi",
                        "content": "this is a hard problem."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this is a hard!!"
                    },
                    {
                        "username": "surajvg93",
                        "content": "Same as question 2597: [https://leetcode.com/problems/the-number-of-beautiful-subsets/](https://leetcode.com/problems/the-number-of-beautiful-subsets/)"
                    },
                    {
                        "username": "sJQpVnXqyHEg",
                        "content": "[2,2,2] is not an accepted test case, but accepted in 2597. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Generate Fibonacci Sequence",
        "question_content": "<p>Write a generator function that returns a generator object which yields the&nbsp;<strong>fibonacci sequence</strong>.</p>\n\n<p>The&nbsp;<strong>fibonacci sequence</strong>&nbsp;is defined by the relation <code>X<sub>n</sub>&nbsp;= X<sub>n-1</sub>&nbsp;+ X<sub>n-2</sub></code>.</p>\n\n<p>The first few numbers&nbsp;of the series are <code>0, 1, 1, 2, 3, 5, 8, 13</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> callCount = 5\n<strong>Output:</strong> [0,1,1,2,3]\n<strong>Explanation:</strong>\nconst gen = fibGenerator();\ngen.next().value; // 0\ngen.next().value; // 1\ngen.next().value; // 1\ngen.next().value; // 2\ngen.next().value; // 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> callCount = 0\n<strong>Output:</strong> []\n<strong>Explanation:</strong> gen.next() is never called so nothing is outputted\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= callCount &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3587908,
                "title": "easy-solution-2648-generate-fibonacci-sequence-level-up-your-js-skills-day-29",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. We can use a generator function to generate the Fibonacci sequence one number at a time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two variables, `current` and `next`, with values 0 and 1\\nrespectively. These variables represent the current Fibonacci number and the next Fibonacci number in the sequence.\\n2. Use a while loop to generate the Fibonacci sequence indefinitely.\\n3. Inside the loop, yield the value of `current` as the next value of the generator.\\n4. Update the values of `current` and `next` by swapping their values. Set `current` to the value of `next` and `next` to the sum of `current` and `next`.\\n5. Repeat steps 3 and 4 indefinitely to generate the Fibonacci sequence.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of generating the Fibonacci sequence using a generator function is $O(1)$ per iteration. This is because each Fibonacci number is generated on the fly as requested, without needing to generate the entire sequence in advance.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is $O(1)$ because we only need a constant amount of space to store the current and next Fibonacci numbers. The generator function does not require any additional space proportional to the size of the sequence.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n\\n    [current, next] = [next, current + next];\\n\\n    // The above line is equivalent to the following:\\n    // let temp = current;\\n    // current = next;\\n    // next = temp + next;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n## There are several ways to implement a Fibonacci generator in JavaScript. Here are a few alternative approaches:\\n- ## Implementation 1: Using a Closure\\n```JS []\\nconst fibGenerator = () => {\\n  let current = 0;\\n  let next = 1;\\n\\n  return () => {\\n    const result = current;\\n    [current, next] = [next, current + next];\\n    return result;\\n  };\\n};\\n\\nconst gen = fibGenerator();\\nconsole.log(gen()); // 0\\nconsole.log(gen()); // 1\\n\\n```\\n>In this approach, we use a closure to create a Fibonacci generator. The `fibGenerator` function returns another function that generates the Fibonacci numbers. The inner function keeps track of the `current` and `next` values using a closure. Each time the inner function is called, it calculates the next Fibonacci number, updates the values, and returns the current one.\\n\\n- ## Implementation 2: Using an Iterator\\n```JS []\\nconst fibGenerator = {\\n  [Symbol.iterator]: function*() {\\n    let current = 0;\\n    let next = 1;\\n\\n    while (true) {\\n      yield current;\\n      [current, next] = [next, current + next];\\n    }\\n  }\\n};\\n\\nconst gen = fibGenerator[Symbol.iterator]();\\nconsole.log(gen.next().value); // 0\\nconsole.log(gen.next().value); // 1\\n\\n```\\n>In this approach, we define `fibGenerator` as an object with a\\n`Symbol.iterator` method. The `Symbol.iterator` method is a generator\\nfunction that generates the Fibonacci sequence. We can then create an iterator by calling `fibGenerator[Symbol.iterator]()` and use it to retrieve the Fibonacci numbers.\\n\\n- ## Implementation 3: Using a Recursive Generator\\n``` JS []\\nfunction* fibGenerator(current = 0, next = 1) {\\n  yield current;\\n  yield* fibGenerator(next, current + next);\\n}\\n\\nconst gen = fibGenerator();\\nconsole.log(gen.next().value); // 0\\nconsole.log(gen.next().value); // 1\\n\\n```\\n>In this approach, we define the `fibGenerator` function as a recursive generator. It takes two parameters, `current` and `next`, representing the current and next Fibonacci numbers. It yields the current number and then delegates to itself with the updated values of `next` and `current + next`. This recursive generator generates the Fibonacci sequence indefinitely.\\n\\n- ## Implementation 4: Without using a generator function\\n``` JS []\\nconst fibGenerator = {\\n  current: 0,\\n  next: 1,\\n  nextNumber: function() {\\n    const result = this.current;\\n    [this.current, this.next] = [this.next, this.current + this.next];\\n    return result;\\n  }\\n};\\n\\nconsole.log(fibGenerator.nextNumber()); // 0\\nconsole.log(fibGenerator.nextNumber()); // 1\\n\\n```\\nIn this approach, we define `fibGenerator` as an object with properties `current` and `next` to store the current and next Fibonacci numbers, respectively. The `nextNumber` method calculates and returns the next Fibonacci number while updating the `current` and `next` properties accordingly.\\nTo generate Fibonacci numbers, you can simply call the `nextNumber` method of the `fibGenerator` object. Each call to `nextNumber` will return the next Fibonacci number in the sequence.\\n>Note: that this approach does not provide the infinite sequence of Fibonacci numbers like a generator function does. Instead, it generates the Fibonacci numbers one at a time upon each method call.\\n\\n\\n\\n# Important topic to Learn \\n\\n| Sr No. | Topic | Sr No. | Topic |\\n|-----|-----|-----|-----|\\n1.|Arrays , Array methods() |2.|Function programming *|\\n3.|Higher-order function|4.|Memoization|\\n5.|Currying|6.|Promises, async/await|\\n7.|Compare Objects|8.|Prototypes, inheritance|\\n9.|Generators, advanced iteration*|10.|----------------\\n>[ Note:- * marked is related to today\\'s problem ]\\n\\n<img src=\"https://media.giphy.com/media/Xd6WrGsyh1su7X0ZGF/giphy.gif\" width=\"40\">\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D \\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n\\n    [current, next] = [next, current + next];\\n\\n    // The above line is equivalent to the following:\\n    // let temp = current;\\n    // current = next;\\n    // next = temp + next;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```JS []\\nconst fibGenerator = () => {\\n  let current = 0;\\n  let next = 1;\\n\\n  return () => {\\n    const result = current;\\n    [current, next] = [next, current + next];\\n    return result;\\n  };\\n};\\n\\nconst gen = fibGenerator();\\nconsole.log(gen()); // 0\\nconsole.log(gen()); // 1\\n\\n```\n```JS []\\nconst fibGenerator = {\\n  [Symbol.iterator]: function*() {\\n    let current = 0;\\n    let next = 1;\\n\\n    while (true) {\\n      yield current;\\n      [current, next] = [next, current + next];\\n    }\\n  }\\n};\\n\\nconst gen = fibGenerator[Symbol.iterator]();\\nconsole.log(gen.next().value); // 0\\nconsole.log(gen.next().value); // 1\\n\\n```\n``` JS []\\nfunction* fibGenerator(current = 0, next = 1) {\\n  yield current;\\n  yield* fibGenerator(next, current + next);\\n}\\n\\nconst gen = fibGenerator();\\nconsole.log(gen.next().value); // 0\\nconsole.log(gen.next().value); // 1\\n\\n```\n``` JS []\\nconst fibGenerator = {\\n  current: 0,\\n  next: 1,\\n  nextNumber: function() {\\n    const result = this.current;\\n    [this.current, this.next] = [this.next, this.current + this.next];\\n    return result;\\n  }\\n};\\n\\nconsole.log(fibGenerator.nextNumber()); // 0\\nconsole.log(fibGenerator.nextNumber()); // 1\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439825,
                "title": "yield-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    // initialise first 2 sequence numbers\\n    // initialise a loop so that function can return values indefinitely when called\\n    // yield pauses fx execution and returns value, before continuing subsequent steps\\n    // fibonacci sequence is updated in steps after yield\\n        // note: \\n            // third term is the sum of first and second term\\n            // therefore: n term is sum of n-1 term + n-2 term\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    // initialise first 2 sequence numbers\\n    // initialise a loop so that function can return values indefinitely when called\\n    // yield pauses fx execution and returns value, before continuing subsequent steps\\n    // fibonacci sequence is updated in steps after yield\\n        // note: \\n            // third term is the sum of first and second term\\n            // therefore: n term is sum of n-1 term + n-2 term\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588028,
                "title": "mastering-generator-functions-learn-with-exciting-examples-beginner-friendly-js-ts",
                "content": "# Generator functions \\uD83D\\uDE80\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### Generator functions are a special type of function in JavaScript that can be paused and resumed during execution. \\nYes, you heard it right, these functions can be magically paused during execution and can be resumed later. \\uD83E\\uDE84\\nThey allow you to generate a sequence of values on-the-fly instead of computing and storing them all at once. Here\\'s a simple example to help illustrate the concept:\\n\\n```\\nfunction* countToThree() {\\n  yield 1;\\n  yield 2;\\n  yield 3;\\n}\\n\\nconst generator = countToThree(); // Creating a generator object\\n\\nconsole.log(generator.next().value); // 1\\nconsole.log(generator.next().value); // 2\\nconsole.log(generator.next().value); // 3\\n```\\n\\n- We can then use the `next()` method on the generator object to get the next value in the sequence.\\n- The `value` property of the returned object gives us the yielded value.\\n\\n# Real-life implementations of generator functions can be found in various scenarios, such as:\\n\\n- **Iterating over large or infinite data sets:** Generator functions can be used to iterate over data that is too large to fit in memory all at once. Instead of loading the entire dataset into memory, you can generate and process the data one piece at a time, saving memory resources.\\n- **Asynchronous programming:** Generators can be combined with asynchronous operations to simplify asynchronous code. By using yield with promises or async/await syntax, you can write asynchronous code that looks more like synchronous code, making it easier to understand and maintain.\\n- **Parsing and tokenization:** Generator functions can be used in parsing or tokenization tasks. They can generate a sequence of tokens or parsed elements as needed, allowing you to process large streams of data efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Define a generator function `fibGenerator`.\\n2. Initialize `current` to 0 and `next` to 1.\\n3. Use a loop to iterate `callCount` times.\\n    - Yield `next`.\\n    - Calculate the next Fibonacci number: `temp = current + next`, `current = next`, `next = temp`.\\n4. Return or yield any remaining Fibonacci numbers.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ (linear time) where `n` is the number of times the generator function is called.\\n\\n- Space complexity: $$O(1)$$ (constant space)\\n\\n<img src=\"https://assets.leetcode.com/users/images/b93dcc50-7e19-44d3-80ec-c41558d719ba_1684043630.2104852.png\" width=\"50%\">\\n\\n\\n# Code\\n``` javascript []\\nvar fibGenerator = function*() {\\n\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n    let temp = current + next;\\n    current = next;\\n    next = temp;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n\\n``` Typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n    // easier way to swap elements\\n    [current, next] = [next, current + next];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* countToThree() {\\n  yield 1;\\n  yield 2;\\n  yield 3;\\n}\\n\\nconst generator = countToThree(); // Creating a generator object\\n\\nconsole.log(generator.next().value); // 1\\nconsole.log(generator.next().value); // 2\\nconsole.log(generator.next().value); // 3\\n```\n``` javascript []\\nvar fibGenerator = function*() {\\n\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n    let temp = current + next;\\n    current = next;\\n    next = temp;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n``` Typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n    // easier way to swap elements\\n    [current, next] = [next, current + next];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439599,
                "title": "the-best",
                "content": "```js\\nconst fibGenerator = function*() {\\n    let [a, b] = [0, 1]\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b]\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst fibGenerator = function*() {\\n    let [a, b] = [0, 1]\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439913,
                "title": "javascript-detailed-explanation",
                "content": "Here, fibGenerator is a generator function that produces an infinite sequence of Fibonacci numbers. Each time you call fibGenerator().next().value, it will return the next number in the sequence.\\n\\nThe * symbol is used to denote that this function is a generator function. It allows the function to use the yield keyword to pause the function\\'s execution and return a value to the caller.\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var a=0, b=1\\n    yield a\\n    yield b\\n    while(true){\\n        var c= a+b\\n        yield c\\n        a=b\\n        b=c\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var a=0, b=1\\n    yield a\\n    yield b\\n    while(true){\\n        var c= a+b\\n        yield c\\n        a=b\\n        b=c\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587777,
                "title": "java-script-solution-for-generate-fibonacci-sequence-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the fibGenerator function is to generate the Fibonacci sequence using a generator.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt follows the approach of calculating the Fibonacci numbers iteratively by keeping track of the previous and current values. The function yields the Fibonacci numbers one by one as it is called\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the number of Fibonacci numbers to be generated. The loop runs for n iterations, and in each iteration, a constant amount of work is done to calculate the next Fibonacci number.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) because it only requires a constant amount of additional space to store the previous and current values.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let prev = 0;\\n  let curr = 1;\\n\\n  yield prev; // Yield the initial value 0\\n  yield curr; // Yield the initial value 1\\n\\n  for (let i = 2; i <= 50; i++) {\\n    const next = prev + curr;\\n    yield next; // Yield the next Fibonacci number\\n    prev = curr;\\n    curr = next;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let prev = 0;\\n  let curr = 1;\\n\\n  yield prev; // Yield the initial value 0\\n  yield curr; // Yield the initial value 1\\n\\n  for (let i = 2; i <= 50; i++) {\\n    const next = prev + curr;\\n    yield next; // Yield the next Fibonacci number\\n    prev = curr;\\n    curr = next;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453650,
                "title": "easy-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*(a = 0, b=1) {\\n    yield a;\\n    yield* fibGenerator(b, a+b);\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*(a = 0, b=1) {\\n    yield a;\\n    yield* fibGenerator(b, a+b);\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439492,
                "title": "typescript-solution",
                "content": "For simplicity\\'s sake, we hardcode the first two `yield` values for `fib(0)` and `fib(1)`, then after that we use a loop to generate Fibonacci numbers as usual. Space complexity is O(1), and time complexity is O(1) per `next()` call.\\n\\n```typescript\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    // fib(0) === 0\\n    yield 0;\\n    // fib(1) === 1\\n    yield 1;\\n    \\n    let a: number = 0;\\n    let b: number = 1;\\n    \\n    while (true) {\\n        const c: number = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    // fib(0) === 0\\n    yield 0;\\n    // fib(1) === 1\\n    yield 1;\\n    \\n    let a: number = 0;\\n    let b: number = 1;\\n    \\n    while (true) {\\n        const c: number = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587979,
                "title": "fibonacci-generator-yield-dp",
                "content": "We define a generator function that yields the Fibonacci sequence. \\n\\nIt initializes an array with the first two Fibonacci numbers, `0` and `1`, and yields them. \\n\\nInside an infinite loop, it calculates the next Fibonacci number by adding the previous two numbers from the array and yields it. The array is then updated with the new values, shifting them to the left. \\n\\nBy reusing the previously calculated numbers, we avoid redundant calculations and improves performance. When the generator is called, it generates Fibonacci numbers lazily on-demand, allowing for efficient memory usage and flexibility.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let fib = [0, 1];\\n\\n  yield fib[0];\\n  yield fib[1];\\n\\n  while (true) {\\n    let next = fib[0] + fib[1];\\n    yield next;\\n    fib[0] = fib[1];\\n    fib[1] = next;\\n  }\\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let fib = [0, 1];\\n\\n  yield fib[0];\\n  yield fib[1];\\n\\n  while (true) {\\n    let next = fib[0] + fib[1];\\n    yield next;\\n    fib[0] = fib[1];\\n    fib[1] = next;\\n  }\\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533474,
                "title": "very-simple-and-easy-solution-in-javascript-wow-super-one-thanks-myself",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1\\n    yield 0\\n    yield 1\\n    while(true) {\\n        [a,b] = [b, a + b]\\n        yield b\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1\\n    yield 0\\n    yield 1\\n    while(true) {\\n        [a,b] = [b, a + b]\\n        yield b\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446097,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var x=0,y=1\\n    yield x\\n    yield y\\n    while(true){\\n        var z=x+y\\n        yield z\\n        x=y\\n        y=z\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var x=0,y=1\\n    yield x\\n    yield y\\n    while(true){\\n        var z=x+y\\n        yield z\\n        x=y\\n        y=z\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587998,
                "title": "understand-generator-function-with-the-help-of-example",
                "content": "What is actually generators ?\\n\\nIn javascript generators are the functions which have special functionality, they can pause and resume during execution. (We define generator function with the help of special syntax , `function * generatorFunctionName() { }`)\\n\\nUnderstand with the help of example -\\n```\\nfunction* generatorFunction() {\\n  console.log(\\'Execution started\\');\\n  yield 1;\\n  console.log(\\'After first yield\\');\\n  yield 2;\\n  console.log(\\'After second yield\\');\\n  yield 3;\\n  console.log(\\'Execution completed\\');\\n}\\n\\nconst generator = generatorFunction(); // Creating an instance of the generator\\n\\nconsole.log(generator.next()); // Output: { value: 1, done: false }\\nconsole.log(generator.next()); // Output: { value: 2, done: false }\\nconsole.log(generator.next()); // Output: { value: 3, done: false }\\nconsole.log(generator.next()); // Output: { value: undefined, done: true }\\n```\\nWhen we call `generatorFunction()` it will not execute the function, instead of this it will return a generator object, which have `next` method, by calling next method we can resume the execution of generator.\\nWhen function see yield in function it will stop the execution and return the object which have to fields which store the yield value and done state of the function.\\n\\nWe can say we use next method to resume the execution of generator function and use yield keyword to pause the execution.\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    yield a;\\n    let b = 1;\\n    yield b;\\n    while(true){\\n        const fibNumber = a + b;\\n        a = b;\\n        b = fibNumber;\\n        yield fibNumber;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction* generatorFunction() {\\n  console.log(\\'Execution started\\');\\n  yield 1;\\n  console.log(\\'After first yield\\');\\n  yield 2;\\n  console.log(\\'After second yield\\');\\n  yield 3;\\n  console.log(\\'Execution completed\\');\\n}\\n\\nconst generator = generatorFunction(); // Creating an instance of the generator\\n\\nconsole.log(generator.next()); // Output: { value: 1, done: false }\\nconsole.log(generator.next()); // Output: { value: 2, done: false }\\nconsole.log(generator.next()); // Output: { value: 3, done: false }\\nconsole.log(generator.next()); // Output: { value: undefined, done: true }\\n```\n```\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    yield a;\\n    let b = 1;\\n    yield b;\\n    while(true){\\n        const fibNumber = a + b;\\n        a = b;\\n        b = fibNumber;\\n        yield fibNumber;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587957,
                "title": "easy-solutions",
                "content": "**Javascript Solution**\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0, prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n**Typescript Solution**\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n     let prev1:number = 0, prev2:number = 1;\\n\\n        while (true) {\\n          yield prev1;\\n          [prev1, prev2] = [prev2, prev1+prev2];\\n        }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0, prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n     let prev1:number = 0, prev2:number = 1;\\n\\n        while (true) {\\n          yield prev1;\\n          [prev1, prev2] = [prev2, prev1+prev2];\\n        }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587673,
                "title": "javascript-yield-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577700,
                "title": "full-simple-explanation-beginner-friendly-introduction",
                "content": "# Approach\\nGenerator functions (indicated by the ```*``` in ```function*()```) is a function that allows you to iterate throughout code in a function to return different values by calling the same function. While this can be done with regular functions, the conveinent thing with generator functions is they allow you to use the keyword ```yield```, which allows you to stop in the middle of the code and return a value, then when you come back to the function with another call, you pick up where you left off. We can do this using the ```.next().value``` method call, which generator functions automatically have.\\n1. Initialize the first two numbers in the Fibonacci sequence with ```a = 0``` and ```b = 1```, of which ```a``` will always be smaller than ```b```.\\n2. Yield value a and value b in succession. When you make the first ```.next().value``` call, it will run into ```yield a``` and return 0, and on the second call will pick off from the ```yield a``` line, run into the ```yield b``` line, and return 1.\\n3. Make a forever running while loop, so we can generate as many numbers in the sequence as we\\'d like. In this sequence, we set ```c``` to ```a + b```, and yield the value ```c```. After the ```yield c``` line, set ```a = b``` and ```b = c```, for the next iteration of calculating ```c```.\\n\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    yield a; // first call returns 0\\n    yield b; // second call returns 1\\n\\n    let c;\\n    while (true) { // third call and after enters this loop\\n        c = a + b; // calculate c for current call\\n        yield c; // return c\\n\\n        // when another call is made, set a and b to next iteration to calculate next c value\\n        a = b;\\n        b = c;\\n    }\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```*```\n```function*()```\n```yield```\n```.next().value```\n```a = 0```\n```b = 1```\n```a```\n```b```\n```.next().value```\n```yield a```\n```yield a```\n```yield b```\n```c```\n```a + b```\n```c```\n```yield c```\n```a = b```\n```b = c```\n```c```\n```\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    yield a; // first call returns 0\\n    yield b; // second call returns 1\\n\\n    let c;\\n    while (true) { // third call and after enters this loop\\n        c = a + b; // calculate c for current call\\n        yield c; // return c\\n\\n        // when another call is made, set a and b to next iteration to calculate next c value\\n        a = b;\\n        b = c;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3457399,
                "title": "my-fibgenerator",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let count = 0;\\n  let a = 0;\\n  let b = 1;\\n  \\n  while (true) {\\n    if (count === 0) {\\n      yield a;\\n      count++;\\n    } else if (count === 1) {\\n      yield b;\\n      count++;\\n    } else {\\n      yield a + b;\\n      const sum = a + b;\\n      a = b;\\n      b = sum;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let count = 0;\\n  let a = 0;\\n  let b = 1;\\n  \\n  while (true) {\\n    if (count === 0) {\\n      yield a;\\n      count++;\\n    } else if (count === 1) {\\n      yield b;\\n      count++;\\n    } else {\\n      yield a + b;\\n      const sum = a + b;\\n      a = b;\\n      b = sum;\\n    }\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3451942,
                "title": "one-line-two-variables-without-destructuring-assignment",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s like swapping two variables tricks.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n---\\n* You could find some other extraordinary solutions in my [profile](https://leetcode.com/almostmonday/) on the Solutions tab (I don\\'t post obvious or not interesting solutions at all.)\\n* If this was helpful, please upvote so that others can see this solution too.\\n---\\n\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442514,
                "title": "javascript-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a1=0, a2=1;\\n  let next;\\n  while(true){\\n      next = a1+a2;\\n      yield a1;\\n      a1 = a2;\\n      a2 = next;\\n  }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a1=0, a2=1;\\n  let next;\\n  while(true){\\n      next = a1+a2;\\n      yield a1;\\n      a1 = a2;\\n      a2 = next;\\n  }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588377,
                "title": "typescript-solution",
                "content": "```\\nfunction* fibGenerator(): Generator<number> {\\n    let a = 0, b = 1\\n    \\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a+b]\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number> {\\n    let a = 0, b = 1\\n    \\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a+b]\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565242,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let pre = -1, cur = 1;\\n\\n  while (true) {\\n    yield pre + cur;\\n    let temp = pre + cur\\n    pre = cur;\\n    cur = temp\\n  }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let pre = -1, cur = 1;\\n\\n  while (true) {\\n    yield pre + cur;\\n    let temp = pre + cur\\n    pre = cur;\\n    cur = temp\\n  }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536119,
                "title": "simple-js-solution-following-the-hints",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0\\n    yield 1\\n    let vals = [0, 1]\\n    while (true) {\\n        vals.push(vals[vals.length -1] + vals[vals.length -2])\\n        yield vals[vals.length - 1]\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0\\n    yield 1\\n    let vals = [0, 1]\\n    while (true) {\\n        vals.push(vals[vals.length -1] + vals[vals.length -2])\\n        yield vals[vals.length - 1]\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445298,
                "title": "simple-recursive-solution",
                "content": "```javascript\\nvar fibGenerator = function*(a=0,b=1) {\\nyield* [a,b];\\nyield* fibGenerator(a+b, a+2*b);\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```javascript\\nvar fibGenerator = function*(a=0,b=1) {\\nyield* [a,b];\\nyield* fibGenerator(a+b, a+2*b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085263,
                "title": "js-abc",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, c;\\n    while(true){\\n        yield a;\\n        c = a+b;\\n        a = b;\\n        b = c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, c;\\n    while(true){\\n        yield a;\\n        c = a+b;\\n        a = b;\\n        b = c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074485,
                "title": "simple-but-powerful-solution-beats-over-87-of-users-at-runtime-and-over-99-of-users-at-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbased on array records not variables and yield the current record array[i]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple array.push() method with loop statement \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntook me about 3 minutes to figure out which path i approach\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr=[];\\n    for(i=0;i<=100;i++){\\n        if(i<=1){\\n        arr.push(i);\\n        yield arr[i];\\n        }else{\\n        arr.push(arr[i-1]+arr[i-2]);\\n        yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr=[];\\n    for(i=0;i<=100;i++){\\n        if(i<=1){\\n        arr.push(i);\\n        yield arr[i];\\n        }else{\\n        arr.push(arr[i-1]+arr[i-2]);\\n        yield arr[i];\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070085,
                "title": "using-yield",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i=0, j=1;\\n    yield i;\\n    yield j;\\n    while(true){\\n        yield i+j;\\n        let temp = i;\\n        i = j;\\n        j = temp+j;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i=0, j=1;\\n    yield i;\\n    yield j;\\n    while(true){\\n        yield i+j;\\n        let temp = i;\\n        i = j;\\n        j = temp+j;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069990,
                "title": "easy-js-solution-yield",
                "content": "# Refernces\\n- [function* and yield](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)\\n- [Fibonacci sequence in JS](https://www.programiz.com/javascript/examples/fibonacci-series)\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let n1 = 0, n2 = 1, nextNum;\\n    while(true){\\n        yield n1\\n        nextNum = n1 + n2 \\n        n1 = n2\\n        n2 = nextNum\\n    }\\n};\\n\\n\\n```\\n# VOTE UP! PLS\\uD83E\\uDD7A\\n![Vote up.jpg](https://assets.leetcode.com/users/images/7f0308f7-724d-4bea-bd2e-713788159bd5_1695239026.7445886.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let n1 = 0, n2 = 1, nextNum;\\n    while(true){\\n        yield n1\\n        nextNum = n1 + n2 \\n        n1 = n2\\n        n2 = nextNum\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066203,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  yield 0;\\n  yield 1;\\n  let n1 = 0, n2 = 1;\\n    while(true)\\n    {\\n      let n = n1 + n2;\\n      n1 = n2;\\n      n2 = n;\\n      yield n;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  yield 0;\\n  yield 1;\\n  let n1 = 0, n2 = 1;\\n    while(true)\\n    {\\n      let n = n1 + n2;\\n      n1 = n2;\\n      n2 = n;\\n      yield n;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057548,
                "title": "easy-js-solution",
                "content": "# 2648. Generate Fibonacci Sequence\\n\\n## Code\\n```\\nvar fibGenerator = function*() {\\n    let f = [0, 1];\\n    while (true) {\\n        yield f[0];\\n        f = [f[1], f[0]+f[1]];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    let f = [0, 1];\\n    while (true) {\\n        yield f[0];\\n        f = [f[1], f[0]+f[1]];        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054460,
                "title": "js-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let current = 0\\n    let next = 1\\n\\n    while (true) {\\n        yield current\\n        let temp = current + next\\n        current = next\\n        next = temp\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let current = 0\\n    let next = 1\\n\\n    while (true) {\\n        yield current\\n        let temp = current + next\\n        current = next\\n        next = temp\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050558,
                "title": "simple-solution-with-array-loop-beats-94-93-of-javascrip",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\n\\n\\nvar fibGenerator = function* ()\\n{\\n    let arr = [];\\n    arr.push(0);\\n    for(let i = 1 ; i <= 50; i ++)\\n    {\\n        if(arr.length === 1) arr.push(i);\\n            arr.push(arr[i-1] + arr[i]);\\n    }\\n    let count = 0;\\n    while(true)\\n    {\\n        yield arr[count++];\\n    }\\n\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\n\\nvar fibGenerator = function* ()\\n{\\n    let arr = [];\\n    arr.push(0);\\n    for(let i = 1 ; i <= 50; i ++)\\n    {\\n        if(arr.length === 1) arr.push(i);\\n            arr.push(arr[i-1] + arr[i]);\\n    }\\n    let count = 0;\\n    while(true)\\n    {\\n        yield arr[count++];\\n    }\\n\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027214,
                "title": "simple-js-ts-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let firstNum = 0;\\n    let secondNum = 1;\\n    while (true) {\\n        yield firstNum;\\n        [firstNum, secondNum] = [secondNum, firstNum+secondNum];\\n    }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let firstNum = 0;\\n    let secondNum = 1;\\n    while (true) {\\n        yield firstNum;\\n        [firstNum, secondNum] = [secondNum, firstNum+secondNum];\\n    }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013156,
                "title": "javascript-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n    let prev = 0;\\n    let current = 1;\\n\\n    for (let i = 0; i < 50; i++) {\\n        yield prev;\\n        const next = prev + current;\\n        prev = current;\\n        current = next;\\n    }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n    let prev = 0;\\n    let current = 1;\\n\\n    for (let i = 0; i < 50; i++) {\\n        yield prev;\\n        const next = prev + current;\\n        prev = current;\\n        current = next;\\n    }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012623,
                "title": "fibonacci-sequence-generator-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 0, j = 1, k = 2;\\n    yield i;\\n    yield j;\\n    while (true) {\\n        k = i + j;\\n        yield k;\\n        i = j;\\n        j = k;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 0, j = 1, k = 2;\\n    yield i;\\n    yield j;\\n    while (true) {\\n        k = i + j;\\n        yield k;\\n        i = j;\\n        j = k;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011788,
                "title": "fibonacci-sequence-using-yield-keyword",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n   let fib=[0,1];\\n   yield fib[0];\\n   yield fib[1];\\n   while(1)\\n   {\\n        let next =fib[0]+fib[1];\\n        yield next;\\n        fib[0]=fib[1];\\n        fib[1]= next;\\n   }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n   let fib=[0,1];\\n   yield fib[0];\\n   yield fib[1];\\n   while(1)\\n   {\\n        let next =fib[0]+fib[1];\\n        yield next;\\n        fib[0]=fib[1];\\n        fib[1]= next;\\n   }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978836,
                "title": "easy-approach",
                "content": "\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a=0,b=1;\\n    while(1){\\n        yield a;\\n        [a,b] = [b,a+b]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a=0,b=1;\\n    while(1){\\n        yield a;\\n        [a,b] = [b,a+b]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977023,
                "title": "titan",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let fib = [0, 1];\\n\\n  yield fib[0];\\n  yield fib[1];\\n\\n  while (true) {\\n    let next = fib[0] + fib[1];\\n    yield next;\\n    fib[0] = fib[1];\\n    fib[1] = next;\\n  }    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let fib = [0, 1];\\n\\n  yield fib[0];\\n  yield fib[1];\\n\\n  while (true) {\\n    let next = fib[0] + fib[1];\\n    yield next;\\n    fib[0] = fib[1];\\n    fib[1] = next;\\n  }    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976322,
                "title": "2648-generate-fibonacci-sequence-using-yield-keyword",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */  \\n\\n\\nvar fibGenerator = function* (callCount) {\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n\\n    [current, next] = [next, current + next];\\n\\n  } \\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */  \\n\\n\\nvar fibGenerator = function* (callCount) {\\n  let current = 0; \\n  let next = 1;\\n\\n  while (true) {\\n    yield current; \\n\\n    [current, next] = [next, current + next];\\n\\n  } \\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969920,
                "title": "easy-solution",
                "content": "# Intuition\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [result,sum] = [0,1] //assign two variables for starting two numbers i.e 0,1\\n    while(true){\\n        yield result; // return the current result\\n        [result,sum]= [sum,result+sum] // then add the two preceeding to values to  get suceeding value\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [result,sum] = [0,1] //assign two variables for starting two numbers i.e 0,1\\n    while(true){\\n        yield result; // return the current result\\n        [result,sum]= [sum,result+sum] // then add the two preceeding to values to  get suceeding value\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962240,
                "title": "infinite-loop-solution",
                "content": "```\\n/**\\n * @return {Generator<number>}\\n */\\nconst fibGenerator = function*() {\\n    let prev = 0\\n    let curr = 1\\n\\n    while (true) {\\n        yield prev\\n        const next = prev + curr\\n        prev = curr\\n        curr = next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nconst fibGenerator = function*() {\\n    let prev = 0\\n    let curr = 1\\n\\n    while (true) {\\n        yield prev\\n        const next = prev + curr\\n        prev = curr\\n        curr = next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959435,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a=0\\n    let b=1\\n\\n    while(true){\\n        yield a\\n        let tmp=a\\n        a=b\\n        b+=tmp\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a=0\\n    let b=1\\n\\n    while(true){\\n        yield a\\n        let tmp=a\\n        a=b\\n        b+=tmp\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951927,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let count = 0;\\n  while (true) {\\n    const res = fib(count)\\n    count += 1;\\n    yield res\\n  }\\n};\\n\\nfunction fib(count) {\\n  if (count === 0) return 0;\\n  if (count === 1) return 1;\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 2; i <= count; i++) {\\n    let c = a + b;\\n    a = b;\\n    b = c;\\n  }\\n  return b;\\n}\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let count = 0;\\n  while (true) {\\n    const res = fib(count)\\n    count += 1;\\n    yield res\\n  }\\n};\\n\\nfunction fib(count) {\\n  if (count === 0) return 0;\\n  if (count === 1) return 1;\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 2; i <= count; i++) {\\n    let c = a + b;\\n    a = b;\\n    b = c;\\n  }\\n  return b;\\n}\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3939362,
                "title": "javascript-simple-solution-yield",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923198,
                "title": "typescript-simple-solution-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let prev = 0, curr = 1;\\n    while ( true ) {\\n        yield prev;\\n        curr = curr + prev;\\n        prev = curr - prev;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Math"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let prev = 0, curr = 1;\\n    while ( true ) {\\n        yield prev;\\n        curr = curr + prev;\\n        prev = curr - prev;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917108,
                "title": "easy-javascript-solution",
                "content": "> Vote Up If you Like it\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev=0\\n    let curr=1\\n    yield prev\\n    yield curr\\n    while(true){\\n        let next_val=prev+curr\\n        yield next_val\\n        prev=curr\\n        curr=next_val\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev=0\\n    let curr=1\\n    yield prev\\n    yield curr\\n    while(true){\\n        let next_val=prev+curr\\n        yield next_val\\n        prev=curr\\n        curr=next_val\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900801,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0;\\n    yield a;\\n    let b=1;\\n    yield b;\\n    while(true){\\n        var c=a+b;\\n        yield c;\\n        a=b;\\n        b=c;\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0;\\n    yield a;\\n    let b=1;\\n    yield b;\\n    while(true){\\n        var c=a+b;\\n        yield c;\\n        a=b;\\n        b=c;\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897782,
                "title": "fibonacci-sequence-generator-using-generator-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is intended to generate the Fibonacci sequence using a generator function. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The intuition behind the code is to use a generator to create an iterable sequence of Fibonacci numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a generator function named fibGenerator. Inside this function:\\n\\n- Two variables, a and b, are initialized to 0 and 1 respectively. These variables will keep track of the last two Fibonacci numbers.\\n\\n- The generator function starts by yielding the initial value a, which is 0.\\n\\n- The for loop iterates from 1 to 49 (50 iterations in total). In each iteration, the next Fibonacci number c is calculated as the sum of the previous two numbers a and b.\\n\\n- The current Fibonacci number a is yielded using the yield keyword.\\n\\n- The values of a and b are then updated to prepare for the next iteration.\\n\\n# Complexity\\n**- Time Complexity:**\\nThe time complexity of the generator function mainly depends on the number of iterations in the loop. Since the loop iterates 50 times, the time complexity of generating the first 50 Fibonacci numbers is O(50), which is essentially **O(1)** in terms of practical considerations.\\n\\n**- Space Complexity:** \\nThe space complexity is **O(1)** because the generator function only uses a constant amount of extra space for variables, regardless of the input size.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b =1;\\n\\n    for(let i =1 ; i<=50 ; i++){\\n        let c = a+b ;\\n        yield a;\\n\\n        a =b ;\\n        b =c;\\n\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b =1;\\n\\n    for(let i =1 ; i<=50 ; i++){\\n        let c = a+b ;\\n        yield a;\\n\\n        a =b ;\\n        b =c;\\n\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894968,
                "title": "easy-solution-javascript",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let num1 = 0, num2 = 1\\n    yield num1\\n    yield num2\\n    for(;;) {\\n      const next = num1 + num2\\n      yield next\\n      num1 = num2\\n      num2 = next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let num1 = 0, num2 = 1\\n    yield num1\\n    yield num2\\n    for(;;) {\\n      const next = num1 + num2\\n      yield next\\n      num1 = num2\\n      num2 = next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879002,
                "title": "efficient-fibonacci-generator-on-demand-fibonacci-number-calculation-using-javascript-generator-func",
                "content": "# Intuition\\nThe intuition behind this approach is to use a generator function to generate Fibonacci numbers on-demand. A generator function allows us to calculate and yield the Fibonacci numbers one by one without storing all of them in memory at once. This approach is memory-efficient and suitable for scenarios where we only need a limited number of Fibonacci numbers.\\n\\n# Approach\\nWe define the fibGenerator function as a generator function using the function* syntax in JavaScript.\\nWe initialize mylist with the first two Fibonacci numbers [0, 1].\\nWe use the yield keyword to yield the first two Fibonacci numbers (0 and 1) as base cases.\\nIn the for loop, we start calculating the next Fibonacci numbers using the previous two numbers in the mylist array.\\nWe continuously push the new Fibonacci numbers into the mylist array and yield the calculated Fibonacci number using yield num.\\nThe generator will keep generating Fibonacci numbers indefinitely.\\n# Complexity\\n- Time complexity:\\nTime complexity: O(1) for each next() call on the generator. Calculating each Fibonacci number takes constant time, so the time complexity of generating one Fibonacci number is constant.\\n\\n- Space complexity:\\nSpace complexity: O(n) where n is the number of Fibonacci numbers generated. The generator keeps an internal list mylist to store the generated Fibonacci numbers. The space complexity increases as more Fibonacci numbers are generated, but it grows linearly with the number of generated Fibonacci numbers.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let mylist = [0, 1];\\n\\n    \\n    yield mylist[0];\\n    yield mylist[1];\\n\\n    for (let i = 2; ; i++) {\\n        let num = mylist[i - 1] + mylist[i - 2];\\n        mylist.push(num);\\n        yield num;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let mylist = [0, 1];\\n\\n    \\n    yield mylist[0];\\n    yield mylist[1];\\n\\n    for (let i = 2; ; i++) {\\n        let num = mylist[i - 1] + mylist[i - 2];\\n        mylist.push(num);\\n        yield num;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3875457,
                "title": "2648-generate-fibonacci-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n     let firstTerm = 0;\\n    yield firstTerm;\\n    let secondTerm = 1;\\n    yield secondTerm;\\n    let nextTerm;\\n    while (true) {\\n        nextTerm = firstTerm + secondTerm;\\n        firstTerm = secondTerm;\\n        secondTerm = nextTerm;\\n        yield nextTerm;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n     let firstTerm = 0;\\n    yield firstTerm;\\n    let secondTerm = 1;\\n    yield secondTerm;\\n    let nextTerm;\\n    while (true) {\\n        nextTerm = firstTerm + secondTerm;\\n        firstTerm = secondTerm;\\n        secondTerm = nextTerm;\\n        yield nextTerm;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3868238,
                "title": "while-looppppppppp",
                "content": "# Intuition\\nwhat is fibonacci sequence ? \\uD83D\\uDE05\\n\\n# Approach\\nusing while loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\nlet firstOne = -1;\\nlet secondOne = 1;\\nlet start = 0;\\n    while(start<=50){\\n        let val = secondOne + firstOne;\\n         firstOne = secondOne;\\n        secondOne = val;\\n        yield val;\\n        start++\\n    }\\n};\\n\\n\\n const gen = fibGenerator();\\n  gen.next().value; // 0\\n  gen.next().value; // 1\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\nlet firstOne = -1;\\nlet secondOne = 1;\\nlet start = 0;\\n    while(start<=50){\\n        let val = secondOne + firstOne;\\n         firstOne = secondOne;\\n        secondOne = val;\\n        yield val;\\n        start++\\n    }\\n};\\n\\n\\n const gen = fibGenerator();\\n  gen.next().value; // 0\\n  gen.next().value; // 1\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846293,
                "title": "used-generator-function-for-fibonacci-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*(n) {\\n        let a = 0;\\n        let b = 1;\\n        let c = 0;\\n        yield a;\\n        yield b;\\n        while(true){\\n          c = a + b;\\n          yield c;\\n          a = b;\\n          b = c;\\n        }\\n};\\n\\n//here have kept while true. In gen function \\n- if we have yield more than one. whenever we call gen function it will not execute the previous if it\\'s already executed. Js remembers how many time yield or gen function have been called. \\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*(n) {\\n        let a = 0;\\n        let b = 1;\\n        let c = 0;\\n        yield a;\\n        yield b;\\n        while(true){\\n          c = a + b;\\n          yield c;\\n          a = b;\\n          b = c;\\n        }\\n};\\n\\n//here have kept while true. In gen function \\n- if we have yield more than one. whenever we call gen function it will not execute the previous if it\\'s already executed. Js remembers how many time yield or gen function have been called. \\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829253,
                "title": "simple-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    const last = [0, 1]\\n    yield 0\\n    yield 1\\n     for (let i = 2; i < 50; i++) {\\n         const curr = last[0] + last[1]\\n         last.push(curr)\\n         last.shift()\\n         yield curr\\n     }\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    const last = [0, 1]\\n    yield 0\\n    yield 1\\n     for (let i = 2; i < 50; i++) {\\n         const curr = last[0] + last[1]\\n         last.push(curr)\\n         last.shift()\\n         yield curr\\n     }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3807257,
                "title": "javascript-generator",
                "content": "Generator function by default will not yield on the first try that\\'s why i made it yield the previous value which will show first value on the second try and so on. while wraping the yield inside a while true loop so it can be useable everytime the generator function is called.\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [prev,curr] = [0,1]\\n    while(true){\\n        yield prev;\\n        [prev,curr] = [curr,prev+curr]  \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [prev,curr] = [0,1]\\n    while(true){\\n        yield prev;\\n        [prev,curr] = [curr,prev+curr]  \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806920,
                "title": "fibonacci-sequence-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let arr = [0,1];\\n\\n    for(let i = 2; i <=50; i++){\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n\\n    for(let val of arr){\\n        yield val;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let arr = [0,1];\\n\\n    for(let i = 2; i <=50; i++){\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n\\n    for(let val of arr){\\n        yield val;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3804225,
                "title": "beats-97-79-in-runtime-and-71-31-in-memory-using-simple-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    yield arr[0];\\n    yield arr[1];\\n    for (let i=2;i<51;i++){\\n           arr.push(arr[i-1]+arr[i-2])\\n            yield arr[i]\\n        }\\n \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    yield arr[0];\\n    yield arr[1];\\n    for (let i=2;i<51;i++){\\n           arr.push(arr[i-1]+arr[i-2])\\n            yield arr[i]\\n        }\\n \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761391,
                "title": "typescript-following-the-hints",
                "content": "# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0\\n    yield 1\\n    let a = 0\\n    let b = 1\\n    while(true) {\\n        yield a+b\\n        let tmp = b\\n        b = a+b\\n        a = tmp\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0\\n    yield 1\\n    let a = 0\\n    let b = 1\\n    while(true) {\\n        yield a+b\\n        let tmp = b\\n        b = a+b\\n        a = tmp\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760505,
                "title": "javascript-solution-using-closures",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI tried to think of way in which I can store prev and current value 0 and 1 and new value can be derived from prev and current and shifiting this two pointer \\n```prev = curr``` and ```curr = newValue```\\nSo I tried to implement it using closures.\\none trick was there for starting two calls I don\\'t to perform this operation so conditionally I returned 0 and 1 for first two calls then apply rest logic of fibonacci.\\n\\n# Complexity\\n- Time complexity: constant\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function() {\\n    let prev = 0;\\n    let curr = 1;\\n    let count = 0;\\n    return {\\n        next : function () {\\n            if(count < 2){\\n                return {\\n                    \"value\" : count++\\n                }\\n            }\\n            let ans = prev + curr;\\n            prev = curr;\\n            curr = ans;\\n            return {\\n                \"value\" : ans\\n            }\\n        }\\n    }\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Memoization"
                ],
                "code": "```prev = curr```\n```curr = newValue```\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function() {\\n    let prev = 0;\\n    let curr = 1;\\n    let count = 0;\\n    return {\\n        next : function () {\\n            if(count < 2){\\n                return {\\n                    \"value\" : count++\\n                }\\n            }\\n            let ans = prev + curr;\\n            prev = curr;\\n            curr = ans;\\n            return {\\n                \"value\" : ans\\n            }\\n        }\\n    }\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750194,
                "title": "simplest-javascript-solution-space-and-time-complexity-o-1",
                "content": "# Intuition\\nSwap and Yield!\\n\\n# Approach\\nInitialize two variables as current and next having values as 0, 1 respectively. It employs a generator function to yield Fibonacci numbers one by one without having to calculate all of them upfront. We are yielding the current value and then swapping current, next with next, current + next respectively.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let current = 0, next = 1;\\n    \\n  while(true){\\n    yield current;\\n    [current, next] = [next, current + next]\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let current = 0, next = 1;\\n    \\n  while(true){\\n    yield current;\\n    [current, next] = [next, current + next]\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749401,
                "title": "the-js-way",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let num1 = 0;\\n    let num2 = 1;\\n    \\n    yield num1;\\n    yield num2;\\n\\n    while(true) {\\n        const num3 = num1 + num2;\\n\\n        yield num3;\\n\\n        num1 = num2;\\n        num2 = num3;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let num1 = 0;\\n    let num2 = 1;\\n    \\n    yield num1;\\n    yield num2;\\n\\n    while(true) {\\n        const num3 = num1 + num2;\\n\\n        yield num3;\\n\\n        num1 = num2;\\n        num2 = num3;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726745,
                "title": "fibonacci-sequence-using-generator-function-by-switching-different-variables-in-a-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code implements a Fibonacci number generator using a generator function. The generator produces an infinite sequence of Fibonacci numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use a while loop to generate Fibonacci numbers indefinitely. The generator function maintains three variables: i, j, and k. It starts with i = 0, j = undefined, and k = undefined. Inside the loop, it follows the Fibonacci sequence logic to update the values of i, j, and k and yield the Fibonacci number i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(\\u221E) or simply as O(1), each Fibonacci number is generated in constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1).\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 0\\n    let j\\n    let k\\n    \\n    while(true){\\n        if (i == 0){\\n            yield i\\n            i = 1\\n            j = 0\\n        } else if(i == 1 && j == 0){\\n            yield i\\n            i = 1\\n            j = 1\\n        }\\n        yield i\\n        k = j\\n        j = i\\n        i = i + k\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n * 0,1,1,2,3,5,8,13,21,34\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 0\\n    let j\\n    let k\\n    \\n    while(true){\\n        if (i == 0){\\n            yield i\\n            i = 1\\n            j = 0\\n        } else if(i == 1 && j == 0){\\n            yield i\\n            i = 1\\n            j = 1\\n        }\\n        yield i\\n        k = j\\n        j = i\\n        i = i + k\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n * 0,1,1,2,3,5,8,13,21,34\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695997,
                "title": "yield-keyword-is-used-to-pause-and-resume-generator-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3688908,
                "title": "javascript-solution-for-beginner",
                "content": "# Code\\n```\\nvar fibGenerator = function*() {\\n  let current = 0; \\n  let next = 1;\\n  while (true) {\\n    yield current; \\n    [current, next] = [next, current + next];\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n  let current = 0; \\n  let next = 1;\\n  while (true) {\\n    yield current; \\n    [current, next] = [next, current + next];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657482,
                "title": "fibonacci-generator-in-js-95-pretty-standard-fare",
                "content": "# Intuition\\nI had heard JS had generator functions, but I\\'ve never found a need to use them, as I also heard they are pretty slow.  It was also my first time coming across function*.  I read up, and it seemed easy enough.\\n\\n# Approach\\nI wrote a version with 3 yield statements, but that was apparently too slow, so I had to take a look again.  I realised posNeg2 was what was always asked for, and I know for loops let you maintain local scope with a let variable, so that might speed it up.  Reorganizing things worked, but although it got 95% faster it could just as easily have 49%; it all varies cause of the testing servers.  It\\'s hard to be confident this would actually be performant unless I did further testing, but I checked mine against most at the top, and it\\'s pretty similar.\\n\\nThe actual submission results:\\nhttps://leetcode.com/problems/generate-fibonacci-sequence/submissions/974828184/\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let posNeg2 = 0\\n    let posNeg1 = 1\\n    for(let pos=0;true;){\\n        yield posNeg2;\\n        pos = posNeg1+posNeg2;\\n        posNeg2 = posNeg1;\\n        posNeg1 = pos;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let posNeg2 = 0\\n    let posNeg1 = 1\\n    for(let pos=0;true;){\\n        yield posNeg2;\\n        pos = posNeg1+posNeg2;\\n        posNeg2 = posNeg1;\\n        posNeg1 = pos;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657478,
                "title": "infinity-fibonanchi-you-can-understand-it-too-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n        let myArr = [0, 1], t=2;\\n\\n    yield myArr[0]\\n    yield myArr[1]\\n\\n    while (true) {\\n        myArr.push(myArr[t - 1] + myArr[t - 2]);\\n        yield myArr[myArr.length - 1];\\n        t++;\\n       \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n        let myArr = [0, 1], t=2;\\n\\n    yield myArr[0]\\n    yield myArr[1]\\n\\n    while (true) {\\n        myArr.push(myArr[t - 1] + myArr[t - 2]);\\n        yield myArr[myArr.length - 1];\\n        t++;\\n       \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640131,
                "title": "easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var current = 0;\\n  var next = 1;\\n\\n  while (true) {\\n    yield current;\\n    [current, next] = [next, current + next];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var current = 0;\\n  var next = 1;\\n\\n  while (true) {\\n    yield current;\\n    [current, next] = [next, current + next];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638034,
                "title": "js-solution-beats-56-in-memory",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while (true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while (true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3604751,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1 = 0;\\n    let prev2 = 1;\\n    while(true) {\\n        yield prev1;\\n        const temp = prev1;\\n        prev1 = prev2;\\n        prev2 += temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1 = 0;\\n    let prev2 = 1;\\n    while(true) {\\n        yield prev1;\\n        const temp = prev1;\\n        prev1 = prev2;\\n        prev2 += temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594484,
                "title": "easy-self-explainary-day-29",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let n1= 0, n2 = 1\\n\\n    while(true){\\n        yield n1;\\n        [n1,n2]= [n2, n1+n2]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let n1= 0, n2 = 1\\n\\n    while(true){\\n        yield n1;\\n        [n1,n2]= [n2, n1+n2]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593572,
                "title": "generator-function-concept-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem involves implementing a `Fibonacci` number generator using a generator function. The generator should yield Fibonacci numbers in sequence, starting from 0 and 1, and then generating subsequent Fibonacci numbers by summing the previous two numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a generator function `fibGenerator`.\\n2. Initialize two variables, `a` and `b`, to store the first two Fibonacci numbers: 0 and 1, respectively.\\n3. Use the `yield` keyword to yield the value of `a`, which is the first Fibonacci number and the value of `b`, which is the second Fibonacci number.\\n4. Run an infinite loop using `while(true)`. This loop will generate subsequent Fibonacci numbers indefinitely.\\n5. Inside the loop, calculate the next Fibonacci number by adding `a` and `b` and assign it to the variable `c`.\\n6. Update the values of `a` and `b` by shifting `b` to `a` and `c` to `b`, respectively. This prepares the variables for the next iteration.\\n7. Use the `yield` keyword to yield the value of `c`, which is the next Fibonacci number.\\n8. Since the loop is infinite, the generator function will keep yielding Fibonacci numbers as long as it is iterated.\\n\\n# Code\\n``` javascript []\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n``` typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` javascript []\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n``` typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a = 0, b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593432,
                "title": "day-29-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a = 0; yield a;\\n  let b = 1; yield b;\\n\\n  while (true) {\\n    let temp = b;\\n    b += a;\\n    a = temp;\\n    yield b;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a = 0; yield a;\\n  let b = 1; yield b;\\n\\n  while (true) {\\n    let temp = b;\\n    b += a;\\n    a = temp;\\n    yield b;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593301,
                "title": "simple-solution-typescript-while-loop",
                "content": "# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let first = 0;\\n    let second = 1;\\n    let value = 0;\\n    let count = 0;\\n    while(true){\\n        if(count <= 1){\\n            count++;\\n            yield value++;\\n        }\\n        else{\\n            value = first + second;\\n            first = second;\\n            second = value;\\n            yield value;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let first = 0;\\n    let second = 1;\\n    let value = 0;\\n    let count = 0;\\n    while(true){\\n        if(count <= 1){\\n            count++;\\n            yield value++;\\n        }\\n        else{\\n            value = first + second;\\n            first = second;\\n            second = value;\\n            yield value;\\n        }\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592810,
                "title": "generators-easiest-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0;\\n    let b=1;\\n\\n    while(true){\\n        yield a;\\n        [a,b]=[b,a+b];\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0;\\n    let b=1;\\n\\n    while(true){\\n        yield a;\\n        [a,b]=[b,a+b];\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592292,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let a = 0;\\n     yield a;\\n    let b = 1;\\n     yield b\\n     while(true) {\\n      let c = a+b;\\n      yield c;\\n      a=b;\\n      b=c;\\n     }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let a = 0;\\n     yield a;\\n    let b = 1;\\n     yield b\\n     while(true) {\\n      let c = a+b;\\n      yield c;\\n      a=b;\\n      b=c;\\n     }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591865,
                "title": "beginner-friendly-js-solution",
                "content": "> **DISCLAIMER: ** I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nWhile loop will be useful \\uD83E\\uDD14\\uD83D\\uDE00\\n\\n# Approach\\nAs Fibonacci series is defined by this relation `Xn = Xn-1 + Xn-2`\\nWe need three variables in total a,b & c.\\n\\nFibonacci series starts with 0 and 1, Hence assiging those values to a & b and then `c = a + b`\\n\\nneed to handle yielding of 0 and 1 separately rest of the series will taken care by our `while` loop\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/dbe33423-1b15-458a-8d91-e9af0f8079f1_1685774097.9031093.png)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let a = 0;\\n  let b = 1;\\n  let c = 0;\\n\\n  if (c === 0) {\\n    c = a + b;\\n    yield 0;\\n  }\\n  if (c === 1) {\\n    yield 1;\\n  }\\n\\n  while (true) {\\n    c = a + b;\\n    a = b;\\n    b = c;\\n    yield c;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let a = 0;\\n  let b = 1;\\n  let c = 0;\\n\\n  if (c === 0) {\\n    c = a + b;\\n    yield 0;\\n  }\\n  if (c === 1) {\\n    yield 1;\\n  }\\n\\n  while (true) {\\n    c = a + b;\\n    a = b;\\n    b = c;\\n    yield c;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591396,
                "title": "javascript-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [n1, n2] = [0, 1]\\n\\n    while (true) {\\n        yield n1;\\n        [n1, n2] = [n2, n1 + n2]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [n1, n2] = [0, 1]\\n\\n    while (true) {\\n        yield n1;\\n        [n1, n2] = [n2, n1 + n2]\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590738,
                "title": "javascript-faster-than-90",
                "content": "# Intuition\\nJust calculate the next value.\\n\\n# Approach\\nJust calculate the next value, use `yield` keyword to return the current value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let k0 = 0;\\n    let k1 = 1;\\n    let n = 0;\\n    while (true)\\n    {\\n        if (n == 0) yield k0;\\n        if (n == 1) yield k1;\\n        let next = k0 + k1;\\n        k0 = k1;\\n        k1 = next;\\n        n++;\\n        yield k1;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let k0 = 0;\\n    let k1 = 1;\\n    let n = 0;\\n    while (true)\\n    {\\n        if (n == 0) yield k0;\\n        if (n == 1) yield k1;\\n        let next = k0 + k1;\\n        k0 = k1;\\n        k1 = next;\\n        n++;\\n        yield k1;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590650,
                "title": "simple-but-only-for-the-first-50-numbers",
                "content": "# Intuition\\nThis is a very well known sequence, and it\\'s quite easy to generate 50 numbers.\\n\\n# Approach\\nHardcode the first 50 Fibonacci numbers, and use the `yield*` notation to turn this array into a generator.\\n\\n# Complexity\\n- Time complexity:\\nConstant time per call.\\n\\n- Space complexity:\\nConstant space, although it would take more space if you wanted to be able to call this more than 50 times.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield* [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074]\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield* [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074]\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590472,
                "title": "javascript-beginner-easy-solution",
                "content": "# Intuition\\nIn fibonacci the element is the sum of previous two elements\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a+b;\\n        a = b;\\n        b = c;\\n        yield b;\\n    } \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    yield a;\\n    yield b;\\n\\n    while(true) {\\n        let c = a+b;\\n        a = b;\\n        b = c;\\n        yield b;\\n    } \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590385,
                "title": "simple-solution-using-array-destructuring-assignment",
                "content": "Inside the function, it initializes a to 0 and b to 1, which are the first two numbers in the Fibonacci sequence. It then enters an infinite loop using while (true).\\nWithin each iteration of the loop, it yields the current value of a, effectively pausing the function and returning the value.\\n After that, it updates the values of a and b by swapping them, where a becomes the previous value of b, and b becomes the sum of the previous values of a and b.\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n   let a = 0, b = 1;\\n\\n  while (true) {\\n    yield a;\\n    [a, b] = [b, a + b];\\n\\n}\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n   let a = 0, b = 1;\\n\\n  while (true) {\\n    yield a;\\n    [a, b] = [b, a + b];\\n\\n}\\n};\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590365,
                "title": "day-29-javascript",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while(true) {\\n        yield prev1;\\n        const temp = prev1;\\n        prev1 = prev2;\\n        prev2 += temp;\\n    }\\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while(true) {\\n        yield prev1;\\n        const temp = prev1;\\n        prev1 = prev2;\\n        prev2 += temp;\\n    }\\n};\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590317,
                "title": "simple-fibonacci-generator",
                "content": "# Intuition\\nHelpful for understanding generators: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, temp;\\n    while(true){\\n        yield a;\\n        yield b;\\n        temp = b;\\n        a = a + b;\\n        b = a + temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, temp;\\n    while(true){\\n        yield a;\\n        yield b;\\n        temp = b;\\n        a = a + b;\\n        b = a + temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590287,
                "title": "easy-javascript-solution",
                "content": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let curr = 0;\\n    let next = 1;\\n    \\n    while(true){\\n        yield curr;\\n        [curr, next] = [next, curr + next];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let curr = 0;\\n    let next = 1;\\n    \\n    while(true){\\n        yield curr;\\n        [curr, next] = [next, curr + next];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589645,
                "title": "simple-solution-easy-to-understand-o-1-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let prev = 0;\\n    let current = 1;\\n    \\n    while(true) {\\n        const temp = prev + current;\\n        prev = current;\\n        current = temp;\\n        yield current;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let prev = 0;\\n    let current = 1;\\n    \\n    while(true) {\\n        const temp = prev + current;\\n        prev = current;\\n        current = temp;\\n        yield current;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589565,
                "title": "easy-solution-o-1",
                "content": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [a, b] = [0, 1];\\n    while(true){\\n        yield a;\\n        [a, b] = [b, a+b];\\n    };\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let [a, b] = [0, 1];\\n    while(true){\\n        yield a;\\n        [a, b] = [b, a+b];\\n    };\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589513,
                "title": "javascript-made-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a0 = 0;\\n    let a1 = 1;\\n    while(true){\\n        yield a0;\\n        let temp = a0;\\n        a0 = a1;\\n        a1 = temp + a1;\\n    };\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a0 = 0;\\n    let a1 = 1;\\n    while(true){\\n        yield a0;\\n        let temp = a0;\\n        a0 = a1;\\n        a1 = temp + a1;\\n    };\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589434,
                "title": "typescript-using-while-loop-and-yielding-runtime-100-memory-60",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let xn_2 = 0;\\n    let xn_1 = 1;\\n    yield xn_2;\\n    yield xn_1;\\n    while(true) {\\n        const sum = xn_1 + xn_2;\\n        yield sum;\\n        xn_2 = xn_1;\\n        xn_1 = sum;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```TypeScript\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let xn_2 = 0;\\n    let xn_1 = 1;\\n    yield xn_2;\\n    yield xn_1;\\n    while(true) {\\n        const sum = xn_1 + xn_2;\\n        yield sum;\\n        xn_2 = xn_1;\\n        xn_1 = sum;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589431,
                "title": "simple-javascript-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while(1)\\n    {\\n        yield a;\\n        let temp = a;\\n        a = b;\\n        b = temp + b;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while(1)\\n    {\\n        yield a;\\n        let temp = a;\\n        a = b;\\n        b = temp + b;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589233,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\nconst fibGenerator = (): Iterator<number> => {\\n    const lengthOfSequence: number = 50;\\n    const fibonacciSequence: number[] = Array(lengthOfSequence).fill(0);\\n    fibonacciSequence[1] = 1;\\n    for (let i = 2; i < fibonacciSequence.length; i++) {\\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\\n    }\\n    return fibonacciSequence[Symbol.iterator]();\\n};\\n```\\n``` javascript []\\nvar fibGenerator = function() {\\n    const lengthOfSequence = 50;\\n    const fibonacciSequence = Array(lengthOfSequence).fill(0);\\n    fibonacciSequence[1] = 1;\\n    for (let i = 2; i < fibonacciSequence.length; i++) {\\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\\n    }\\n    return fibonacciSequence[Symbol.iterator]();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\nconst fibGenerator = (): Iterator<number> => {\\n    const lengthOfSequence: number = 50;\\n    const fibonacciSequence: number[] = Array(lengthOfSequence).fill(0);\\n    fibonacciSequence[1] = 1;\\n    for (let i = 2; i < fibonacciSequence.length; i++) {\\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\\n    }\\n    return fibonacciSequence[Symbol.iterator]();\\n};\\n```\n``` javascript []\\nvar fibGenerator = function() {\\n    const lengthOfSequence = 50;\\n    const fibonacciSequence = Array(lengthOfSequence).fill(0);\\n    fibonacciSequence[1] = 1;\\n    for (let i = 2; i < fibonacciSequence.length; i++) {\\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\\n    }\\n    return fibonacciSequence[Symbol.iterator]();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589174,
                "title": "simple-fibonacci-generator-in-javascript-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust simple implementation of generator in JavaScript.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initially declare two variables - a and b. They will be yielded.\\n2. Each call of our generator will produce the next value in Fibonacci series. We did this by creating auxiliary next variable inside while loop.\\n\\n# Complexity\\n- Time complexity: O(1) because it involves a fixed number of mathematical operations. `For each call` of course.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant time - O(n). Only keeps track of two latest numbers - a,b \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    yield a;\\n    yield b;\\n\\n    while (true) {\\n        let next = a + b;\\n        yield next;\\n        a = b;\\n        b = next;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    yield a;\\n    yield b;\\n\\n    while (true) {\\n        let next = a + b;\\n        yield next;\\n        a = b;\\n        b = next;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589057,
                "title": "easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Generator Function:** \\n- It is defined like a normal function, but when it needs to generate a value, it does it with the *yield* keyword, (not the return keyword).\\n- The *yield* statement suspends the execution of function and sends back a value to the caller, but it retains the state to make the function to resume from where it is left off.\\n- On resuming, the function\\'s execution continues immediately after the last *yield* was executed. \\n\\n# Code\\n``` javaScript []\\nvar fibGenerator = function*() {\\n    var [a, b] = [0, 1];\\n\\n    while (!false){\\n        yield a;\\n        [a, b] = [b, a+b];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar fibGenerator = function*() {\\n    var [a, b] = [0, 1];\\n\\n    while (!false){\\n        yield a;\\n        [a, b] = [b, a+b];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588945,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 60 ms, faster than 43.81% of JavaScript online submissions for Generate Fibonacci Sequence.\\n# Memory Usage: 41.6 MB, less than 89.04% of JavaScript online submissions for Generate Fibonacci Sequence.\\n\\tvar fibGenerator = function*() {\\n\\n\\t\\tlet first = 0 , second = 1;\\n\\n\\t\\twhile(true){\\n\\n\\t\\t\\tyield first;\\n\\n\\t\\t\\tlet next_number = first + second;\\n\\n\\t\\t\\tfirst = second;\\n\\n\\t\\t\\tsecond = next_number;\\n\\t\\t}\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 55 ms, faster than 86.29% of TypeScript online submissions for Generate Fibonacci Sequence.\\n# Memory Usage: 42.9 MB, less than 67.49% of TypeScript online submissions for Generate Fibonacci Sequence.\\n\\tfunction* fibGenerator(): Generator<number, any, number> {\\n\\n\\t\\tlet first = 0 , second = 1;\\n\\n\\t\\twhile(true){\\n\\n\\t\\t\\tyield first;\\n\\n\\t\\t\\tlet next_number = first + second;\\n\\n\\t\\t\\tfirst = second;\\n\\n\\t\\t\\tsecond = next_number;\\n\\t\\t}\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 60 ms, faster than 43.81% of JavaScript online submissions for Generate Fibonacci Sequence.\\n# Memory Usage: 41.6 MB, less than 89.04% of JavaScript online submissions for Generate Fibonacci Sequence.\\n\\tvar fibGenerator = function*() {\\n\\n\\t\\tlet first = 0 , second = 1;\\n\\n\\t\\twhile(true){\\n\\n\\t\\t\\tyield first;\\n\\n\\t\\t\\tlet next_number = first + second;\\n\\n\\t\\t\\tfirst = second;\\n\\n\\t\\t\\tsecond = next_number;\\n\\t\\t}\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 55 ms, faster than 86.29% of TypeScript online submissions for Generate Fibonacci Sequence.\\n# Memory Usage: 42.9 MB, less than 67.49% of TypeScript online submissions for Generate Fibonacci Sequence.\\n\\tfunction* fibGenerator(): Generator<number, any, number> {\\n\\n\\t\\tlet first = 0 , second = 1;\\n\\n\\t\\twhile(true){\\n\\n\\t\\t\\tyield first;\\n\\n\\t\\t\\tlet next_number = first + second;\\n\\n\\t\\t\\tfirst = second;\\n\\n\\t\\t\\tsecond = next_number;\\n\\t\\t}\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3588800,
                "title": "js-generator-time-50ms-90-space-42mb-56",
                "content": "# Approach\\nWe\\'ll implement the typical fibonacci function, but with `yield` to make it a generator.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    // init\\n    let curr = 0;\\n    let next = 1;\\n\\n    // fibonacci sequence\\n    while(true) {\\n        yield curr;\\n        [curr, next] = [next, curr + next];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    // init\\n    let curr = 0;\\n    let next = 1;\\n\\n    // fibonacci sequence\\n    while(true) {\\n        yield curr;\\n        [curr, next] = [next, curr + next];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588633,
                "title": "chatgpt-code-snippet",
                "content": "**Generate Fibonacci Sequence**\\n\\n**Problem Statement:**\\n\\nWrite a generator function that returns a generator object which yields the Fibonacci sequence.\\n\\nThe Fibonacci sequence is defined by the relation Xn = Xn-1 + Xn-2. The first few numbers of the series are 0, 1, 1, 2, 3, 5, 8, 13.\\n\\n**Intuition:**\\n\\nTo generate the Fibonacci sequence, we can use a generator function in JavaScript. The generator function allows us to easily yield the Fibonacci numbers one by one, without the need to calculate and store the entire sequence in memory. By utilizing the generator function\\'s `yield` keyword, we can lazily generate and retrieve Fibonacci numbers on demand.\\n\\n**Approach:**\\n\\n1. Initialize two variables, `a` and `b`, with the initial values of 0 and 1 respectively.\\n2. Yield the initial value `a` (0) using the `yield` keyword.\\n3. Enter an infinite loop.\\n4. Inside the loop, yield the current Fibonacci number `b`.\\n5. Calculate the next Fibonacci number by adding `a` and `b`, and assign it to the variable `next`.\\n6. Update `a` to the value of `b` and `b` to the value of `next` for the next iteration.\\n\\n**Complexity Analysis:**\\n\\nTime complexity: The time complexity of generating each Fibonacci number is O(1) since it only involves simple addition. The total time complexity depends on the number of Fibonacci numbers requested.\\n\\nSpace complexity: The space complexity is O(1) since we are not storing the entire sequence in memory. The generator function generates Fibonacci numbers on the fly, so it requires constant space regardless of the number of Fibonacci numbers generated.\\n\\n**Code:**\\n\\n```javascript\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n  let a = 0;\\n  let b = 1;\\n\\n  yield a; // yield the initial value 0\\n\\n  while (true) {\\n    yield b; // yield the current Fibonacci number\\n\\n    const next = a + b;\\n    a = b;\\n    b = next;\\n  }\\n}\\n\\n// Example usage\\nconst gen = fibGenerator();\\nconst callCount = 5;\\nfor (let i = 0; i < callCount; i++) {\\n  const value = gen.next().value;\\n  console.log(value);\\n}\\n```\\n\\nIn this code, the `fibGenerator` function is defined as a generator function using the `function*` syntax. It initializes two variables `a` and `b` to keep track of the previous two Fibonacci numbers. It starts by yielding the initial value (`a`), and then enters an infinite loop. In each iteration, it yields the current Fibonacci number (`b`) and calculates the next Fibonacci number by updating the values of `a` and `b`. The example usage demonstrates how to use the generator function to generate and print the Fibonacci sequence with a specified `callCount`.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n  let a = 0;\\n  let b = 1;\\n\\n  yield a; // yield the initial value 0\\n\\n  while (true) {\\n    yield b; // yield the current Fibonacci number\\n\\n    const next = a + b;\\n    a = b;\\n    b = next;\\n  }\\n}\\n\\n// Example usage\\nconst gen = fibGenerator();\\nconst callCount = 5;\\nfor (let i = 0; i < callCount; i++) {\\n  const value = gen.next().value;\\n  console.log(value);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588625,
                "title": "javascript-fibonacci-sequence-generator-using-generator-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo generate the Fibonacci sequence, we can use a generator function that yields each Fibonacci number one by one. I start with the initial values of 0 and 1. Then, in an infinite loop, I calculate the next Fibonacci number by adding the previous two numbers. I yield each Fibonacci number and update the previous and current values accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define the generator function `fibGenerator` using the `function*` syntax.\\n2. Initialize the variables `prev` and `curr` with the values 0 and 1.\\n3. Yield the initial value of 0 using `yield prev`.\\n4. Check if `curr` is equal to 1 and yield it if true using `yield curr`.\\n5. Enter an infinite loop using `for (;;)`.\\n6. Calculate the next Fibonacci number by adding `prev` and `curr` and assign it to `next`.\\n7. Yield the value of `next` using `yield next`.\\n8. Update the values of `prev` and `curr` by assigning `curr` to `prev` and `next` to `curr`.\\n9. Outside the generator function, initialize the variable `callCount` to the desired number of Fibonacci numbers to generate.\\n10. Create a generator object `gen` by calling `fibGenerator()`.\\n11. Create an empty array `fibonacciSequence`.\\n12. Iterate `callCount` times using a `for` loop.\\n13. In each iteration, call `gen.next().value` to retrieve the next Fibonacci number and push it to the `fibonacciSequence` array.\\n14. Finally, log the `fibonacciSequence` array to the console.\\n\\n# Complexity\\n- Time complexity: O(n) where n is the `callCount` since I generate n Fibonacci numbes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) where n is the `callCount` since I store n Fibonacci numbers in the `fibonacciSequence` array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev = 0;\\n    let curr = 1;\\n\\n    yield prev;\\n    if (curr === 1) {\\n        yield curr;\\n    }\\n\\n    for (;;) {\\n        const next = prev + curr;\\n        yield next;\\n        prev = curr;\\n        curr = next;\\n    }\\n};\\n\\nconst callCount = 5;\\nconst gen = fibGenerator();\\n\\nconst fibonacciSequence = [];\\nfor (let i = 0; i < callCount; i++) {\\n    fibonacciSequence.push(gen.next().value);\\n}\\nconsole.log(fibonacciSequence);\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev = 0;\\n    let curr = 1;\\n\\n    yield prev;\\n    if (curr === 1) {\\n        yield curr;\\n    }\\n\\n    for (;;) {\\n        const next = prev + curr;\\n        yield next;\\n        prev = curr;\\n        curr = next;\\n    }\\n};\\n\\nconst callCount = 5;\\nconst gen = fibGenerator();\\n\\nconst fibonacciSequence = [];\\nfor (let i = 0; i < callCount; i++) {\\n    fibonacciSequence.push(gen.next().value);\\n}\\nconsole.log(fibonacciSequence);\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588573,
                "title": "easy-solution-2648-generate-fibonacci-sequence-javascript-day-29",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    n1=0\\n    n2=1\\n    while(true){\\n        yield n1;\\n        [n1,n2]=[n2,n1+n2];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    n1=0\\n    n2=1\\n    while(true){\\n        yield n1;\\n        [n1,n2]=[n2,n1+n2];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588249,
                "title": "day29-2-simple-and-easy-js-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\n\\nvar fibGenerator = function*() {\\n    let [a,b]=[0,1];\\n   while(true){\\n       yield a;\\n       [a,b]=[b,a+b];\\n   }\\n};\\n\\n```\\n\\n\\n```\\n\\nvar fibGenerator = function*() {\\n     let x = 0;\\n    let y = 1;\\n    yield x\\n    yield y;\\n    while(true){\\n        const ans = x+ y;\\n        yield ans;\\n        x=y;\\n        y=ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar fibGenerator = function*() {\\n    let [a,b]=[0,1];\\n   while(true){\\n       yield a;\\n       [a,b]=[b,a+b];\\n   }\\n};\\n\\n```\n```\\n\\nvar fibGenerator = function*() {\\n     let x = 0;\\n    let y = 1;\\n    yield x\\n    yield y;\\n    while(true){\\n        const ans = x+ y;\\n        yield ans;\\n        x=y;\\n        y=ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588146,
                "title": "javascript-a-typescript-detailed-explanation",
                "content": "* fibGenerator is a generator function that produces an infinite sequence of Fibonacci numbers. Each time you call fibGenerator().next().value, it will return the next number in the sequence.\\n\\n* The * symbol is used to denote that this function is a generator function. It allows the function to use the yield keyword to pause the function\\'s execution and return a value to the\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0\\n    let b = 1\\n\\n    yield a\\n    yield b\\n\\n    while(true){\\n        let c = a + b\\n        yield c\\n        a = b\\n        b = c\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\n\\n\\n---\\n\\n\\n---\\n\\n* For simplicity\\'s sake, we hardcode the first two yield values for fib(0) and fib(1), then after that we use a loop to generate Fibonacci numbers as usual. \\n\\n# code\\n\\n```typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    // fib(0) === 0\\n    yield 0;\\n    // fib(1) === 1\\n    yield 1;\\n    \\n    let a: number = 0;\\n    let b: number = 1;\\n    \\n    while (true) {\\n        const c: number = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0\\n    let b = 1\\n\\n    yield a\\n    yield b\\n\\n    while(true){\\n        let c = a + b\\n        yield c\\n        a = b\\n        b = c\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\n```typescript []\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    // fib(0) === 0\\n    yield 0;\\n    // fib(1) === 1\\n    yield 1;\\n    \\n    let a: number = 0;\\n    let b: number = 1;\\n    \\n    while (true) {\\n        const c: number = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588128,
                "title": "generate-fibonacci-sequence",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\n\\n\\nvar fibGenerator = function*() {\\n    let a = 0; // first number in the fibonacci sequence\\n    let b = 1; // second number in the fibonacci sequence\\n\\n    for (;;) {\\n        yield a; // yielding\\n        [a, b] = [b, a + b]; \\n    }\\n};\\n\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\n\\nvar fibGenerator = function*() {\\n    let a = 0; // first number in the fibonacci sequence\\n    let b = 1; // second number in the fibonacci sequence\\n\\n    for (;;) {\\n        yield a; // yielding\\n        [a, b] = [b, a + b]; \\n    }\\n};\\n\\n\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587949,
                "title": "easy-js-solution",
                "content": "var fibGenerator = function*() {\\n \\n  let prev = 0;\\n  let curr = 1;\\n  \\n  yield prev;\\n  yield curr;\\n  \\n  for (let i = 2; i <= 50; i++) {\\n    const next = prev + curr;\\n    yield next;\\n    prev = curr;\\n    curr = next;\\n  }\\n\\n   \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var fibGenerator = function*() {\\n \\n  let prev = 0;\\n  let curr = 1;\\n  \\n  yield prev;\\n  yield curr;\\n  \\n  for (let i = 2; i <= 50; i++) {\\n    const next = prev + curr;\\n    yield next;\\n    prev = curr;\\n    curr = next;\\n  }\\n\\n   \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3587914,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1=0;\\n    let prev2=1;\\n    while(true){\\n        yield prev1;\\n        [prev1 , prev2]=[prev2 , prev1+prev2];\\n    } \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let prev1=0;\\n    let prev2=1;\\n    while(true){\\n        yield prev1;\\n        [prev1 , prev2]=[prev2 , prev1+prev2];\\n    } \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587911,
                "title": "easy-javascript-solution",
                "content": "# Approach\\nCertainly! Here\\'s an approach to generating the Fibonacci sequence using a generator function:\\n\\n1. Define a generator function called `fibGenerator()`.\\n2. Inside the function, initialize two variables, `prev` and `curr`, to 0 and 1 respectively. These represent the previous and current numbers in the Fibonacci sequence.\\n3. Use the `yield` keyword to yield the initial value of `prev`.\\n4. Create an infinite loop using `while (true)`.\\n5. Inside the loop, yield the current value of `curr`.\\n6. Calculate the next Fibonacci number by adding `prev` and `curr` and store it in a variable called `next`.\\n7. Update `prev` to the current value of `curr`.\\n8. Update `curr` to the value of `next`.\\n9. Repeat steps 5-8 indefinitely, generating the Fibonacci sequence.\\n\\nTo use the generator function and retrieve the Fibonacci sequence, follow these steps:\\n\\n1. Create an empty array called `sequence` to store the Fibonacci sequence elements.\\n2. Create a generator object by calling `fibGenerator()`, and store it in a variable called `gen`.\\n3. Use a loop to call `gen.next().value` the desired number of times, and push each value to the `sequence` array.\\n4. Once the loop is complete, return the `sequence` array.\\n\\nThis approach allows you to generate the Fibonacci sequence dynamically by controlling the number of times you call `gen.next().value`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n    let prev = 0;\\n    let curr = 1;\\n\\n    yield prev;\\n\\n    while (true) {\\n      yield curr;\\n      const next = prev + curr;\\n      prev = curr;\\n      curr = next;\\n    }\\n}\\n\\n  function getFibonacciSequence(callCount) {\\n    const sequence = [];\\n    const gen = fibGenerator();\\n\\n    for (let i = 0; i < callCount; i++) {\\n      sequence.push(gen.next().value);\\n    }\\n\\n    return sequence;\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nfunction* fibGenerator() {\\n    let prev = 0;\\n    let curr = 1;\\n\\n    yield prev;\\n\\n    while (true) {\\n      yield curr;\\n      const next = prev + curr;\\n      prev = curr;\\n      curr = next;\\n    }\\n}\\n\\n  function getFibonacciSequence(callCount) {\\n    const sequence = [];\\n    const gen = fibGenerator();\\n\\n    for (let i = 0; i < callCount; i++) {\\n      sequence.push(gen.next().value);\\n    }\\n\\n    return sequence;\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587816,
                "title": "java-script-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    let prev1 = 0;\\n    let prev2 = 1;\\n\\n    while (true) {\\n      yield prev1;\\n      [prev1, prev2] = [prev2, prev1+prev2];\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587812,
                "title": "day-29-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b, a+b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n\\n    while (true){\\n        yield a;\\n        [a,b] = [b, a+b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587730,
                "title": "my-approach-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let f = 0;\\n    let s = 1;\\n    yield f;\\n    yield s;\\n    while(true){\\n        yield f+s;\\n        let temp = s;\\n        s = f+s;\\n        f = temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let f = 0;\\n    let s = 1;\\n    yield f;\\n    yield s;\\n    while(true){\\n        yield f+s;\\n        let temp = s;\\n        s = f+s;\\n        f = temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587715,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a = 0;\\n  let b = 1;\\n  let temp = [0,1]\\n\\n  yield a\\n  yield b\\n\\n  while(true){\\n    let n = temp.length\\n    let c = temp[n-2] + temp[n-1]\\n    temp.push(c)\\n    yield c\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let a = 0;\\n  let b = 1;\\n  let temp = [0,1]\\n\\n  yield a\\n  yield b\\n\\n  while(true){\\n    let n = temp.length\\n    let c = temp[n-2] + temp[n-1]\\n    temp.push(c)\\n    yield c\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587683,
                "title": "javascript-typescript-4-lines-time-space-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nconst fibGenerator = function*() {\\n    let i = 0, j = 1\\n    yield i\\n    yield j\\n    while (1) yield j = i + ( i = j )\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst fibGenerator = function*() {\\n    let i = 0, j = 1\\n    yield i\\n    yield j\\n    while (1) yield j = i + ( i = j )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587656,
                "title": "day-29-easy-solution-in-js",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    for(let a=0,b=1;true;b+=a,a=b-a)yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    for(let a=0,b=1;true;b+=a,a=b-a)yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587647,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    /*\\nIn JavaScript, the yield keyword is used in generator functions to pause and resume the execution of the function. It is part of the generator functionality introduced in ECMAScript 2015 (ES6).\\n    */\\n    let a = 0;\\n    let b = 1;\\n\\n    while(true){\\n        yield a;\\n        // [a,b] = [b,a+b]; using destructuring\\n        let temp = b;\\n        b = a+b;\\n        a = temp;\\n\\n        // console.log(a,b);\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    /*\\nIn JavaScript, the yield keyword is used in generator functions to pause and resume the execution of the function. It is part of the generator functionality introduced in ECMAScript 2015 (ES6).\\n    */\\n    let a = 0;\\n    let b = 1;\\n\\n    while(true){\\n        yield a;\\n        // [a,b] = [b,a+b]; using destructuring\\n        let temp = b;\\n        b = a+b;\\n        a = temp;\\n\\n        // console.log(a,b);\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587644,
                "title": "typescript-solution-using-shifted-array",
                "content": "\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n  const fib = [0, 1, 1];\\n  while (true) {\\n    yield fib.shift()!;\\n    fib.push(fib[0] + fib[1]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n  const fib = [0, 1, 1];\\n  while (true) {\\n    yield fib.shift()!;\\n    fib.push(fib[0] + fib[1]);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587605,
                "title": "js-simple-and-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let a=1,b=0,c=0;\\n    while(true){\\n      c=a+b;\\n      b=a;\\n      a=c;\\n      yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let a=1,b=0,c=0;\\n    while(true){\\n      c=a+b;\\n      b=a;\\n      a=c;\\n      yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587567,
                "title": "shortest-code",
                "content": "# Complexity\\n- Time complexity: O(1) for each `next` operation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0, b=1;\\n    while(true) {\\n        yield a;\\n        b += a;\\n        a = b-a;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a=0, b=1;\\n    while(true) {\\n        yield a;\\n        b += a;\\n        a = b-a;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587554,
                "title": "javascript-yield-2-state-dp",
                "content": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\nvar fibGenerator = function*() {\\n\\n    let last1 = 0\\n    let last2 = 1\\n\\n    yield 0\\n    yield 1\\n    \\n    while (true) {\\n        let res = last1 + last2\\n        last1 = last2\\n        last2 = res\\n        yield res\\n    }\\n\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\nvar fibGenerator = function*() {\\n\\n    let last1 = 0\\n    let last2 = 1\\n\\n    yield 0\\n    yield 1\\n    \\n    while (true) {\\n        let res = last1 + last2\\n        last1 = last2\\n        last2 = res\\n        yield res\\n    }\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3587542,
                "title": "day-29",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let x1 = 0, x2 = 1;\\n  while (true) {\\n    yield x1;\\n    [x1, x2] = [x2, x1 + x2];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n  let x1 = 0, x2 = 1;\\n  while (true) {\\n    yield x1;\\n    [x1, x2] = [x2, x1 + x2];\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583796,
                "title": "2648-generate-fibonacci-sequence",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    let temp = 0;\\n    while(true) {\\n        yield a;\\n        temp = a + b\\n        a = b;\\n        b = temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    let temp = 0;\\n    while(true) {\\n        yield a;\\n        temp = a + b\\n        a = b;\\n        b = temp;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575089,
                "title": "easy-js-solution-using-while-loop",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield x = 0; \\n    yield y = 1;\\n    while(true) {\\n        const next = x + y\\n        x = y\\n        y = next\\n        yield next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield x = 0; \\n    yield y = 1;\\n    while(true) {\\n        const next = x + y\\n        x = y\\n        y = next\\n        yield next\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557659,
                "title": "javascript-very-easy-solution-o-n-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let x = 0, y = 1;\\n    while(true) {\\n        yield x;\\n        yield y;\\n        x = x + y;\\n        y = x + y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let x = 0, y = 1;\\n    while(true) {\\n        yield x;\\n        yield y;\\n        x = x + y;\\n        y = x + y;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3553476,
                "title": "javascript-with-comments-begineer-friendly",
                "content": "# Intuition\\nIn JavaScript, yield is used to pause the execution of a function. When the function is invoked again, the execution continues from the last yield statement. A generator returns a generator object, which is an iterator. This object generates one value at a time and then pauses execution.\\n\\n# Code\\n```\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while(true) {\\n        yield a; // Gives value of a and pause the function\\n        [a, b] = [b, a+b]; // Get next value of Fibonacci Sequence\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while(true) {\\n        yield a; // Gives value of a and pause the function\\n        [a, b] = [b, a+b]; // Get next value of Fibonacci Sequence\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3551850,
                "title": "yield-simplest-solution-in-js",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    var a = 0;\\n    var b = 1;\\n\\n    while(true) {\\n        yield a;\\n        var temp = a;\\n        a = b;\\n        b = temp+b;\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n\\n    var a = 0;\\n    var b = 1;\\n\\n    while(true) {\\n        yield a;\\n        var temp = a;\\n        a = b;\\n        b = temp+b;\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526432,
                "title": "js-using-only-2-variables",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0\\n    let b = 1 \\n\\n    while(true) {\\n        if (b === 1) {\\n            yield a ? 1 : 0\\n        }\\n\\n        b = a + b;\\n        a = b - a;\\n        yield b \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0\\n    let b = 1 \\n\\n    while(true) {\\n        if (b === 1) {\\n            yield a ? 1 : 0\\n        }\\n\\n        b = a + b;\\n        a = b - a;\\n        yield b \\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519908,
                "title": "javascript-1line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\n    var fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n    var fibGenerator = function*() {\\n    for (let a = 0, b = 1; true; b += a, a = b - a) yield a;\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3513744,
                "title": "js-easy-solution",
                "content": "# Code\\n```\\n\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b]\\n    } \\n};\\n // Note : The yield operator is used to pause and resume a generator function.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Code\\n```\\n\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while (true){\\n        yield a;\\n        [a,b] = [b,a+b]\\n    } \\n};\\n // Note : The yield operator is used to pause and resume a generator function.",
                "codeTag": "Unknown"
            },
            {
                "id": 3508663,
                "title": "fibonacci-generator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let a = 0,\\n    b = 1,\\n    c\\n  yield a\\n  yield b\\n  while (true) {\\n    yield (c = a + b)\\n    a = b\\n    b = c\\n  }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n  let a = 0,\\n    b = 1,\\n    c\\n  yield a\\n  yield b\\n  while (true) {\\n    yield (c = a + b)\\n    a = b\\n    b = c\\n  }\\n}\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508497,
                "title": "javascript-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var i = 1, fb = [0, 1];\\n    yield 0;\\n    while (true) {\\n        yield fb[i++ % 2] = fb[i % 2] + fb[(i + 1) % 2];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var i = 1, fb = [0, 1];\\n    yield 0;\\n    while (true) {\\n        yield fb[i++ % 2] = fb[i % 2] + fb[(i + 1) % 2];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505665,
                "title": "simple-js-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, c = 0;\\n    yield a;\\n    yield b;\\n    while (true) {\\n        c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1, c = 0;\\n    yield a;\\n    yield b;\\n    while (true) {\\n        c = a + b;\\n        a = b;\\n        b = c;\\n        yield c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501454,
                "title": "yield",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let a = 0 ,b = 1;\\n    while(true){\\n        yield a + b;\\n        [a,b] = [b,a+b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    let a = 0 ,b = 1;\\n    while(true){\\n        yield a + b;\\n        [a,b] = [b,a+b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3498678,
                "title": "javascript-solution-s-per-easy-to-understand",
                "content": "```javascript\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0, b = 1;\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497333,
                "title": "easy-solution-with-for",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let a = 1;\\n    let b = 0;\\n\\n    for (let i = 3; ; i++) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield a;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let a = 1;\\n    let b = 0;\\n\\n    for (let i = 3; ; i++) {\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n        yield a;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496762,
                "title": "easy-to-understand-solution-using-yield",
                "content": "Please Upvote if it helps you!\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0;\\n    yield 1;\\n    \\n    let previous = 0;\\n    let current = 1;\\n    let next = 0;\\n\\n    while(true) {\\n        next = previous + current;\\n        previous = current;\\n        current = next;\\n        yield next;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0;\\n    yield 1;\\n    \\n    let previous = 0;\\n    let current = 1;\\n    let next = 0;\\n\\n    while(true) {\\n        next = previous + current;\\n        previous = current;\\n        current = next;\\n        yield next;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491744,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let x = 0;\\n    let y = 1;\\n    yield x;\\n    yield y;\\n    while(true){\\n        let z= x+y;\\n        yield z\\n        x=y\\n        y=z\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let x = 0;\\n    let y = 1;\\n    yield x;\\n    yield y;\\n    while(true){\\n        let z= x+y;\\n        yield z\\n        x=y\\n        y=z\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489863,
                "title": "js-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\n\\nvar fibGenerator = function*() {\\n    let x= 0;\\n    let y= 1;\\n\\n    while (true){\\n        yield x;\\n        let t = x;\\n        x = y;\\n        y = t + y;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\n\\nvar fibGenerator = function*() {\\n    let x= 0;\\n    let y= 1;\\n\\n    while (true){\\n        yield x;\\n        let t = x;\\n        x = y;\\n        y = t + y;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486235,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let first = 0;\\n    let second = 1;\\n\\n    yield first;\\n    yield second;\\n\\n    while(true){\\n\\n        let newNum = first + second;\\n        yield newNum;\\n\\n        first = second;\\n        second = newNum;\\n\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let first = 0;\\n    let second = 1;\\n\\n    yield first;\\n    yield second;\\n\\n    while(true){\\n\\n        let newNum = first + second;\\n        yield newNum;\\n\\n        first = second;\\n        second = newNum;\\n\\n    }\\n    \\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483755,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let x = 0, y = 1\\n    yield x\\n    yield y\\n    while (true) {\\n        let z = x + y\\n        yield z\\n        x = y\\n        y = z\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function* () {\\n    let x = 0, y = 1\\n    yield x\\n    yield y\\n    while (true) {\\n        let z = x + y\\n        yield z\\n        x = y\\n        y = z\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483091,
                "title": "typescript",
                "content": "# Intuition\\nMy first thoughts on solving this problem were to use a generator function to create an iterable object that yields the Fibonacci sequence one number at a time. This way, we can efficiently generate the sequence without calculating and storing all values at once.\\n\\n# Approach\\n1. Create a generator function `fibGenerator` that yields the Fibonacci sequence.\\n2. Initialize two variables `a` and `b` with the first two numbers of the Fibonacci sequence (0 and 1).\\n3. Use an infinite loop to continually generate the next numbers in the sequence.\\n4. In each iteration, yield the current value of `a`, then update the values of `a` and `b` to generate the next number in the sequence.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the number of calls to the generator\\'s `next` method. The generator only computes the next number in the sequence when requested, so the time complexity for each call to `next` is $$O(1)$$.\\n\\n- Space complexity: $$O(1)$$, as the generator only stores two numbers (`a` and `b`) at a time, regardless of the number of calls to the `next` method.\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a = 0;\\n    let b = 1;\\n    \\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let a = 0;\\n    let b = 1;\\n    \\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3483088,
                "title": "easiest-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var value1 = 0;\\n    var value2 = 1;\\n    \\n    while(true) {\\n        yield value1;\\n        value2 +=value1;\\n        value1 = value2-value1;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    var value1 = 0;\\n    var value2 = 1;\\n    \\n    while(true) {\\n        yield value1;\\n        value2 +=value1;\\n        value1 = value2-value1;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477378,
                "title": "array-based-3-liner",
                "content": "# Intuition\\nI choose an array as a datastructure to hold the results, as it provides fast access to adding and removing elements on it\\'s ends.\\n\\n# Approach\\nThe most non-trivial thing here was the meaning of generaror function. It was not obvious for me that on *yield* the current execution of *next()* is paused and *.value* available as an value next to *yield*. On subsequent *next()* calls, execution is started from the next line of previous *yield*.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    const fib = [0, 1];\\n    while (true) {\\n        fib.push(fib[0] + fib[1]);\\n        yield fib.shift();\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    const fib = [0, 1];\\n    while (true) {\\n        fib.push(fib[0] + fib[1]);\\n        yield fib.shift();\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466420,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while(true) {\\n        yield a;\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while(true) {\\n        yield a;\\n        let c = a + b;\\n        a = b;\\n        b = c;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462105,
                "title": "easy-solution-ts",
                "content": "\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield* generator();\\n};\\n\\nfunction* generator () {\\n    let f_0 = 0, f_1 = 1;\\n\\n    yield f_0;\\n    yield f_1;\\n\\n    while (true) {\\n        yield f_0 + f_1;\\n\\n        let temp = f_0;\\n        f_0 = f_1;\\n        f_1 = temp + f_1;\\n    }\\n}",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "\\n# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield* generator();\\n};\\n\\nfunction* generator () {\\n    let f_0 = 0, f_1 = 1;\\n\\n    yield f_0;\\n    yield f_1;\\n\\n    while (true) {\\n        yield f_0 + f_1;\\n\\n        let temp = f_0;\\n        f_0 = f_1;\\n        f_1 = temp + f_1;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3460679,
                "title": "accepted-javascript",
                "content": "```\\nvar fibGenerator = function*() {\\n\\n    var prev = 0;\\n    var cur = 1;\\n\\n    while (true) {\\n        yield prev;\\n        [prev, cur] = [cur, prev + cur];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n\\n    var prev = 0;\\n    var cur = 1;\\n\\n    while (true) {\\n        yield prev;\\n        [prev, cur] = [cur, prev + cur];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3460191,
                "title": "simple-ts-js-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    const list= [0,1];\\n    for(let i=0; i<list.length; i++){\\n        const value=list[list.length-1] + list[list.length-2];\\n        list.push(value)\\n        yield value\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    yield 0;\\n    yield 1;\\n    const list= [0,1];\\n    for(let i=0; i<list.length; i++){\\n        const value=list[list.length-1] + list[list.length-2];\\n        list.push(value)\\n        yield value\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459691,
                "title": "easy-to-understand-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    let i = 0;\\n    let k = 0;\\n    let m = 1;\\n    while (true) {\\n        yield arr[i];\\n        arr.push(arr[k]+arr[m]);\\n        k++;\\n        m++;\\n        i++;\\n    }\\n};\\n\\n\\n/**\\nThis is more efficient \\nlet [prev, curr] = [0, 1];\\n  while (true) {\\n    yield prev;\\n    [prev, curr] = [curr, prev + curr];\\n  }\\n*/\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    let i = 0;\\n    let k = 0;\\n    let m = 1;\\n    while (true) {\\n        yield arr[i];\\n        arr.push(arr[k]+arr[m]);\\n        k++;\\n        m++;\\n        i++;\\n    }\\n};\\n\\n\\n/**\\nThis is more efficient \\nlet [prev, curr] = [0, 1];\\n  while (true) {\\n    yield prev;\\n    [prev, curr] = [curr, prev + curr];\\n  }\\n*/\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459677,
                "title": "easy-to-understand-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    let i = 0;\\n    let k = 0;\\n    let m = 1;\\n    while (true) {\\n        yield arr[i];\\n        arr.push(arr[k]+arr[m]);\\n        k++;\\n        m++;\\n        i++;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let arr = [0,1];\\n    let i = 0;\\n    let k = 0;\\n    let m = 1;\\n    while (true) {\\n        yield arr[i];\\n        arr.push(arr[k]+arr[m]);\\n        k++;\\n        m++;\\n        i++;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3456343,
                "title": "simple-and-easy-solution-typescript-js",
                "content": "# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let prev_num = 0;\\n    let curr_num = 1;\\n    yield prev_num; // first next\\n    yield curr_num; // second next\\n\\n    // inifinite loop\\n    // next seconds, many nexts\\n    while (true){\\n        const temp_num = curr_num;\\n        curr_num += prev_num;\\n        prev_num = temp_num;\\n        yield curr_num;\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let prev_num = 0;\\n    let curr_num = 1;\\n    yield prev_num; // first next\\n    yield curr_num; // second next\\n\\n    // inifinite loop\\n    // next seconds, many nexts\\n    while (true){\\n        const temp_num = curr_num;\\n        curr_num += prev_num;\\n        prev_num = temp_num;\\n        yield curr_num;\\n    }\\n\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453841,
                "title": "100-short-typesrcipt-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 2;\\n    let mem = {0: 0, 1: 1};\\n    yield mem[0];\\n    yield mem[1];\\n    while(true) {\\n        mem[i] = mem[i-1] + mem[i-2];\\n        yield mem[i];\\n        i++;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let i = 2;\\n    let mem = {0: 0, 1: 1};\\n    yield mem[0];\\n    yield mem[1];\\n    while(true) {\\n        mem[i] = mem[i-1] + mem[i-2];\\n        yield mem[i];\\n        i++;\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453657,
                "title": "2648-generate-fibonacci-sequence-javascript-accepted",
                "content": "\\n When a function is marked as a generator using the  function* syntax, it can use the yield keyword to produce a value that can be retrieved by the caller. \\n\\nThe generator function will pause its execution at the yield statement and return the value specified in the statement to the caller. The generator function can then be resumed by calling the next() method on the generator object.\\n\\n\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\nlet prev = 0;\\nlet curr = 1;\\nyield prev;\\nyield curr;\\nwhile(true) {\\n  let val = prev + curr;\\n  yield val;\\n  prev = curr;\\n  curr = val;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```\\nif u want any explanation ,please comment below , **HAPPY to HELP YOU!!**\\nif u Like\\uD83E\\uDD70 Please **UPVOTE** !!\\nThank You \\nHappy Coding!\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\nlet prev = 0;\\nlet curr = 1;\\nyield prev;\\nyield curr;\\nwhile(true) {\\n  let val = prev + curr;\\n  yield val;\\n  prev = curr;\\n  curr = val;\\n  }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453528,
                "title": "ts-lazy-tabulation-approach-98-time-50ms-80-space-42-7mb",
                "content": "Ah, good old Fibonacci, the father of Dynamic Programming in the mind of many students. Also, a Tuscan like Leonardo da Vinci, Niccol\\xF2 Macchiavelli... and me \\uD83D\\uDE06!\\n\\nBut enough with the trivia bit; assuming we all encountered before, let\\'s go straight to the point, by initially declaring:\\n* `i`, our pointer, initially set to `0`;\\n* `fibs`, our collections of Fibonacci numbers.\\n\\nOur main loop will forever (`while (true)`, since we know the number of calls will never overflow):\\n* check if `i` is now pointing outside the current boundaries of `fibs` (ie: `i == fibs.length`) and in case append an element given by the sum of the last two to it;\\n* `yield` `fibs[i]`;\\n* increase `i` by `1`.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ (for each call)\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```ts\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let i = 0, fibs = [0, 1];\\n    while (true) {\\n        if (i == fibs.length) fibs.push(fibs[i - 1] + fibs[i - 2]);\\n        yield fibs[i++];\\n    }\\n};\\n```\\n\\nCan we do better? Well, since we do not need to store the whole sequence, but just the last two values, definitely so!\\n\\nWe will just declare `a` and `b` initially set to be `0` and `1` respectively, `return` `i` for the first `2` iterations and then `return` `b` computed as the sum of the previous two values, updating `a` to take the previous `b` value a we go.\\n\\nSo, for example:\\n\\n```ts\\ni = 0, a = 0, b = 1 => i // which is 0 - initial run\\ni = 1, a = 0, b = 1 => i // which is 1 - second run\\ni = 2, a = 1, b = 1 => b // which is 1 - third run\\ni = 2, a = 1, b = 2 => b // which is 2 - fourth run\\ni = 2, a = 2, b = 3 => b // which is 3 - fifth run\\ni = 2, a = 3, b = 5 => b // which is 5 - sixth run\\ni = 2, a = 5, b = 8 => b // which is 5 - seventh run\\n...\\n```\\n\\nNotice we do not even waste computation updating `i` once it reaches the threshold of `2`, just computing the next Fibonacci number in a lazy way.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ (for each call)\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let i = 0, [a, b] = [0, 1];\\n    while (true) {\\n        if (i >= 2) [b, a] = [a + b, b]; \\n        yield i < 2 ? i++ : b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```ts\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let i = 0, fibs = [0, 1];\\n    while (true) {\\n        if (i == fibs.length) fibs.push(fibs[i - 1] + fibs[i - 2]);\\n        yield fibs[i++];\\n    }\\n};\\n```\n```ts\\ni = 0, a = 0, b = 1 => i // which is 0 - initial run\\ni = 1, a = 0, b = 1 => i // which is 1 - second run\\ni = 2, a = 1, b = 1 => b // which is 1 - third run\\ni = 2, a = 1, b = 2 => b // which is 2 - fourth run\\ni = 2, a = 2, b = 3 => b // which is 3 - fifth run\\ni = 2, a = 3, b = 5 => b // which is 5 - sixth run\\ni = 2, a = 5, b = 8 => b // which is 5 - seventh run\\n...\\n```\n```ts\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    let i = 0, [a, b] = [0, 1];\\n    while (true) {\\n        if (i >= 2) [b, a] = [a + b, b]; \\n        yield i < 2 ? i++ : b;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453085,
                "title": "using-while-loop-and-yield-keyword",
                "content": "# Code\\n```\\nconst fibGenerator = function*() {\\n    let [a,b] = [0,1];\\n    while(1){\\n        yield a;\\n        [a,b] = [b, a+b];\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst fibGenerator = function*() {\\n    let [a,b] = [0,1];\\n    while(1){\\n        yield a;\\n        [a,b] = [b, a+b];\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453009,
                "title": "javascript-ez-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {Generator<number>}\\n */\\nvar fibGenerator = function*() {\\n    let a = 0;\\n    let b = 1;\\n    while (true) {\\n        yield a;\\n        [a, b] = [b, a + b];\\n    }\\n};\\n\\n/**\\n * const gen = fibGenerator();\\n * gen.next().value; // 0\\n * gen.next().value; // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453002,
                "title": "javascript-beat-92-in-space-beat-88-in-time",
                "content": "# CODE \\n```\\nvar fibGenerator = function*() {\\n    let x = 0;\\n    let y = 1;\\n    yield x;\\n    yield y;\\n    \\n    while (true) {\\n        let temp = x + y;\\n        yield temp;\\n        x = y;\\n        y = temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n    let x = 0;\\n    let y = 1;\\n    yield x;\\n    yield y;\\n    \\n    while (true) {\\n        let temp = x + y;\\n        yield temp;\\n        x = y;\\n        y = temp;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3451145,
                "title": "js-code-with-c-solution-too",
                "content": "\\n```\\nvar fibGenerator = function*() {\\n     for(fib=[-1,1]; ;yield (fib=[fib[1],fib[0]+fib[1]])[1]);       \\n};\\n```\\n\\nThe C++ solution for the same:\\n\\nstruct FibGenerator {\\n    int f[2] = {-1, 1};\\n    int operator() () {\\n        int temp = f[0];\\n        f[0] = f[1];\\n        f[1] += temp;\\n        return f[1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nvar fibGenerator = function*() {\\n     for(fib=[-1,1]; ;yield (fib=[fib[1],fib[0]+fib[1]])[1]);       \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450170,
                "title": "answer-use-yield",
                "content": "# Code\\n```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0;\\n    yield 1;\\n    \\n    let a = 0, b = 1;\\n    \\n    while (1) {\\n        const c = a + b;\\n        [a, b] = [b, c];\\n        \\n        yield c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction* fibGenerator(): Generator<number, any, number> {\\n    yield 0;\\n    yield 1;\\n    \\n    let a = 0, b = 1;\\n    \\n    while (1) {\\n        const c = a + b;\\n        [a, b] = [b, c];\\n        \\n        yield c;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1914243,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1873110,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1914475,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1913831,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1913817,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1886056,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            },
            {
                "id": 1870304,
                "content": [
                    {
                        "username": "Selithrarion",
                        "content": "hmm i needed to add `;` (semicolon) after `yield a` \\uD83D\\uDE2F"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you\\'re looking for one line solution without destructuring assignment, it\\'s [here](https://leetcode.com/problems/generate-fibonacci-sequence/solutions/3451942/one-line-two-variables-without-destructuring-assignment/)."
                    },
                    {
                        "username": "I_AM_JD",
                        "content": "Why there is a need to add semi-colon  `;` after yield a"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Cool to know that yield and generators exist in JS too, brings back Python memories "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day29 : Done Solving Today\\'s Question \\uD83D\\uDE01\\n\\n\\nTip : You can use yield keyword in generator functions "
                    },
                    {
                        "username": "ildarum21",
                        "content": "My solution works in the browser, bit doesn\\'t work on leetcode. Returned nulls. Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s hard for anyone to help without seeing your code."
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Why I can\\'t create solution from my code? Can someone explain?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "To creat a solution you need to submit your code, when you then go to solutions and click on add solution it should automatically grab your last submission. It\\'s hard to say why it didn\\'t work for you without knowing what you did exactly."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Fish in a Grid",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D matrix <code>grid</code> of size <code>m x n</code>, where <code>(r, c)</code> represents:</p>\n\n<ul>\n\t<li>A <strong>land</strong> cell if <code>grid[r][c] = 0</code>, or</li>\n\t<li>A <strong>water</strong> cell containing <code>grid[r][c]</code> fish, if <code>grid[r][c] &gt; 0</code>.</li>\n</ul>\n\n<p>A fisher can start at any <strong>water</strong> cell <code>(r, c)</code> and can do the following operations any number of times:</p>\n\n<ul>\n\t<li>Catch all the fish at cell <code>(r, c)</code>, or</li>\n\t<li>Move to any adjacent <strong>water</strong> cell.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum</strong> number of fish the fisher can catch if he chooses his starting cell optimally, or </em><code>0</code> if no water cell exists.</p>\n\n<p>An <strong>adjacent</strong> cell of the cell <code>(r, c)</code>, is one of the cells <code>(r, c + 1)</code>, <code>(r, c - 1)</code>, <code>(r + 1, c)</code> or <code>(r - 1, c)</code> if it exists.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example.png\" style=\"width: 241px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The fisher can start at cell <code>(1,3)</code> and collect 3 fish, then move to cell <code>(2,3)</code>&nbsp;and collect 4 fish.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example2.png\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The fisher can start at cells (0,0) or (3,3) and collect a single fish. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3466724,
                "title": "explained-dfs-with-node-sum-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\nTrick is to keep traversing the grid from (0,0) with dfs & adding the values of each dfs traverse.\\nKeep adding all non-zero value traversed is the total no of fish possible on that connected cells.\\nSo keep taking the maximum of each dfs run and return it as the answer.\\n\\nNote : Set the node value to 0 once we traversed a node, to avoid retraversing the same node again.\\n\\n# Code \\n\\n```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1,0}, {0,1}, {-1, 0}, {0,-1}};\\n\\n    int dfs(vector<vector<int>>& grid, int r, int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0) return 0;\\n        int res = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto d: dir)  res += dfs(grid, r+d[0], c+d[1]);\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1,0}, {0,1}, {-1, 0}, {0,-1}};\\n\\n    int dfs(vector<vector<int>>& grid, int r, int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0) return 0;\\n        int res = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto d: dir)  res += dfs(grid, r+d[0], c+d[1]);\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466649,
                "title": "day-394-dfs-vs-bfs-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tWe are given a 2D matrix grid representing land cells and water cells containing fish.\\n##### \\u2022\\tWe need to find the maximum number of fish that can be caught by a fisher starting from any water cell.\\n##### \\u2022\\tWe can start by iterating over all water cells in the grid and using a depth-first search (DFS) to explore all adjacent water cells and calculate the maximum number of fish that can be caught starting from that cell.\\n##### \\u2022\\tIn the DFS, we start with the current water cell and explore all adjacent water cells using a 2D array  dr that contains the four possible directions. For each adjacent water cell, we calculate the total number of fish that can be caught starting from the current cell and add it to the maximum number of fish caught so far. We also remove each water cell from the map as we visit it to avoid visiting the same cell twice.\\n##### \\u2022\\tWe keep track of the maximum number of fish caught so far and return it as the answer.\\n##### \\u2022\\tSince we explore each water cell in the grid only once and perform constant time operations for each cell, the time complexity of this solution is O(n), where n is the total number of cells in the grid.\\n##### \\u2022\\tWe can also optimize the solution by using memoization to avoid recomputing the maximum number of fish caught starting from a water cell that has already been visited.\\n\\n\\n\\n# Code\\n```java []\\npublic int findFish(int[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int maxFish = 0; // variable to store the maximum number of fish caught\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                maxFish = Math.max(maxFish, dfs(i, j, grid, n, m)); // update the maximum number of fish caught\\n            }\\n        }\\n    }\\n    return maxFish; // return the maximum number of fish caught\\n}\\n\\n// array to store the four possible directions\\nprivate final int[] dr = {0, 1, 0, -1, 0};\\n\\n// function to perform DFS and count the number of fish caught\\nint dfs(int i, int j, int[][] grid, int n, int m) {\\n    int fish = grid[i][j]; // count the number of fish caught in the current cell\\n    grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n        int nr = i + dr[k], nc = j + dr[k + 1]; // calculate the coordinates of the adjacent cell\\n        if(nr < n && nr >= 0 && nc < m && nc >= 0 && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n            fish += dfs(nr, nc, grid, n, m); // count the number of fish caught in the adjacent cell\\n        }\\n    }\\n    return fish; // return the total number of fish caught\\n}\\n```\\n```c++ []\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) {\\n                ans = max(ans, dfs(i, j, grid, n, m));\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nint dfs(int i, int j, vector<vector<int>>& grid, int n, int m) {\\n    int f = grid[i][j];\\n    grid[i][j] = 0;\\n    int dr[] = {0, 1, 0, -1, 0};\\n    for(int k = 0; k < 4; k++) {\\n        int nr = i + dr[k];\\n        int nc = j + dr[k + 1];\\n        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n            f += dfs(nr, nc, grid, n, m);\\n        }\\n    }\\n    return f;\\n}\\n```\\n```python []\\ndef findMaxFish(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    m = len(grid[0])\\n    ans = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if grid[i][j] > 0:\\n                ans = max(ans, self.dfs(i, j, grid, n, m))\\n    return ans\\n\\ndef dfs(self, i: int, j: int, grid: List[List[int]], n: int, m: int) -> int:\\n    f = grid[i][j]\\n    grid[i][j] = 0\\n    dr = [0, 1, 0, -1, 0]\\n    for k in range(4):\\n        nr = i + dr[k]\\n        nc = j + dr[k + 1]\\n        if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n            f += self.dfs(nr, nc, grid, n, m)\\n    return f\\n```\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n# BFS \\n\\nWe start by iterating over all water cells in the grid and checking if they contain fish. If a water cell contains fish, we add it to a queue and start the BFS. We also set the value of the current water cell to 0 to mark it as visited.\\n\\nIn the BFS, we explore all adjacent water cells using two arrays  dr and  dc that contain the four possible directions. For each adjacent water cell, we add the number of fish it contains to the total number of fish caught so far and mark it as visited by setting its value to 0. We also add it to the queue to explore its adjacent water cells in the next iteration.\\n\\nAfter the BFS is complete, we update the maximum number of fish caught so far and continue iterating over the remaining water cells.\\n\\nSince we explore each water cell in the grid only once and perform constant time operations for each cell, the time complexity of this solution is O(n), where n is the total number of cells in the grid.\\n```java []\\nint findMaxFish[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int ans = 0; // variable to store the maximum number of fish caught\\n    int[] dr = {0, 1, 0, -1}; // array to store the four possible directions\\n    int[] dc = {1, 0, -1, 0};\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                Queue<int[]> q = new LinkedList<>(); // create a queue to perform BFS\\n                q.offer(new int[]{i, j}); // add the current cell to the queue\\n                int f = grid[i][j]; // count the number of fish caught in the current cell\\n                grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n                while(!q.isEmpty()) { // while there are cells in the queue\\n                    int[] curr = q.poll(); // remove the first cell from the queue\\n                    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n                        int nr = curr[0] + dr[k]; // calculate the coordinates of the adjacent cell\\n                        int nc = curr[1] + dc[k];\\n                        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n                            f += grid[nr][nc]; // count the number of fish caught in the adjacent cell\\n                            grid[nr][nc] = 0; // mark the adjacent cell as visited by setting its value to 0\\n                            q.offer(new int[]{nr, nc}); // add the adjacent cell to the queue\\n                        }\\n                    }\\n                }\\n                ans = Math.max(ans, f); // update the maximum number of fish caught so far\\n            }\\n        }\\n    }\\n    return ans; // return the maximum number of fish caught\\n}\\n```\\n```c++ []\\nclass Solutionpublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<int> dr = {0, 1, 0, -1};\\n        vector<int> dc = {1, 0, -1, 0};\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int f = grid[i][j];\\n                    grid[i][j] = 0;\\n                    while(!q.empty()) {\\n                        auto curr = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            int nr = curr.first + dr[k];\\n                            int nc = curr.second + dc[k];\\n                            if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n                                f += grid[nr][nc];\\n                                grid[nr][nc] = 0;\\n                                q.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans, f);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        ans = 0\\n        dr = [0, 1, 0, -1]\\n        dc = [1, 0, -1, 0]\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] > 0:\\n                    q = deque()\\n                    q.append((i, j))\\n                    f = grid[i][j]\\n                    grid[i][j] = 0\\n                    while q:\\n                        curr = q.popleft()\\n                        for k in range(4):\\n                            nr = curr[0] + dr[k]\\n                            nc = curr[1] + dc[k]\\n                            if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n                                f += grid[nr][nc]\\n                                grid[nr][nc] = 0\\n                                q.append((nr, nc))\\n                    ans = max(ans, f)\\n        return ans\\n```\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nhttps://leetcode.com/problems/maximum-number-of-fish-in-a-grid/solutions/3466649/day-394-100-0ms-python-java-c-explained-approach/\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```java []\\npublic int findFish(int[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int maxFish = 0; // variable to store the maximum number of fish caught\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                maxFish = Math.max(maxFish, dfs(i, j, grid, n, m)); // update the maximum number of fish caught\\n            }\\n        }\\n    }\\n    return maxFish; // return the maximum number of fish caught\\n}\\n\\n// array to store the four possible directions\\nprivate final int[] dr = {0, 1, 0, -1, 0};\\n\\n// function to perform DFS and count the number of fish caught\\nint dfs(int i, int j, int[][] grid, int n, int m) {\\n    int fish = grid[i][j]; // count the number of fish caught in the current cell\\n    grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n        int nr = i + dr[k], nc = j + dr[k + 1]; // calculate the coordinates of the adjacent cell\\n        if(nr < n && nr >= 0 && nc < m && nc >= 0 && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n            fish += dfs(nr, nc, grid, n, m); // count the number of fish caught in the adjacent cell\\n        }\\n    }\\n    return fish; // return the total number of fish caught\\n}\\n```\n```c++ []\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    int ans = 0;\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) {\\n                ans = max(ans, dfs(i, j, grid, n, m));\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nint dfs(int i, int j, vector<vector<int>>& grid, int n, int m) {\\n    int f = grid[i][j];\\n    grid[i][j] = 0;\\n    int dr[] = {0, 1, 0, -1, 0};\\n    for(int k = 0; k < 4; k++) {\\n        int nr = i + dr[k];\\n        int nc = j + dr[k + 1];\\n        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n            f += dfs(nr, nc, grid, n, m);\\n        }\\n    }\\n    return f;\\n}\\n```\n```python []\\ndef findMaxFish(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    m = len(grid[0])\\n    ans = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if grid[i][j] > 0:\\n                ans = max(ans, self.dfs(i, j, grid, n, m))\\n    return ans\\n\\ndef dfs(self, i: int, j: int, grid: List[List[int]], n: int, m: int) -> int:\\n    f = grid[i][j]\\n    grid[i][j] = 0\\n    dr = [0, 1, 0, -1, 0]\\n    for k in range(4):\\n        nr = i + dr[k]\\n        nc = j + dr[k + 1]\\n        if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n            f += self.dfs(nr, nc, grid, n, m)\\n    return f\\n```\n```java []\\nint findMaxFish[][] grid) {\\n    int n = grid.length;\\n    int m = grid[0].length;\\n    int ans = 0; // variable to store the maximum number of fish caught\\n    int[] dr = {0, 1, 0, -1}; // array to store the four possible directions\\n    int[] dc = {1, 0, -1, 0};\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < m; j++) {\\n            if(grid[i][j] > 0) { // if the current cell contains fish\\n                Queue<int[]> q = new LinkedList<>(); // create a queue to perform BFS\\n                q.offer(new int[]{i, j}); // add the current cell to the queue\\n                int f = grid[i][j]; // count the number of fish caught in the current cell\\n                grid[i][j] = 0; // mark the current cell as visited by setting its value to 0\\n                while(!q.isEmpty()) { // while there are cells in the queue\\n                    int[] curr = q.poll(); // remove the first cell from the queue\\n                    for(int k = 0; k < 4; k++) { // iterate over the four possible directions\\n                        int nr = curr[0] + dr[k]; // calculate the coordinates of the adjacent cell\\n                        int nc = curr[1] + dc[k];\\n                        if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) { // if the adjacent cell contains fish and is within the grid\\n                            f += grid[nr][nc]; // count the number of fish caught in the adjacent cell\\n                            grid[nr][nc] = 0; // mark the adjacent cell as visited by setting its value to 0\\n                            q.offer(new int[]{nr, nc}); // add the adjacent cell to the queue\\n                        }\\n                    }\\n                }\\n                ans = Math.max(ans, f); // update the maximum number of fish caught so far\\n            }\\n        }\\n    }\\n    return ans; // return the maximum number of fish caught\\n}\\n```\n```c++ []\\nclass Solutionpublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        vector<int> dr = {0, 1, 0, -1};\\n        vector<int> dc = {1, 0, -1, 0};\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int f = grid[i][j];\\n                    grid[i][j] = 0;\\n                    while(!q.empty()) {\\n                        auto curr = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            int nr = curr.first + dr[k];\\n                            int nc = curr.second + dc[k];\\n                            if(nr >= 0 && nr < n && nc >= 0 && nc < m && grid[nr][nc] > 0) {\\n                                f += grid[nr][nc];\\n                                grid[nr][nc] = 0;\\n                                q.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans, f);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        ans = 0\\n        dr = [0, 1, 0, -1]\\n        dc = [1, 0, -1, 0]\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] > 0:\\n                    q = deque()\\n                    q.append((i, j))\\n                    f = grid[i][j]\\n                    grid[i][j] = 0\\n                    while q:\\n                        curr = q.popleft()\\n                        for k in range(4):\\n                            nr = curr[0] + dr[k]\\n                            nc = curr[1] + dc[k]\\n                            if nr >= 0 and nr < n and nc >= 0 and nc < m and grid[nr][nc] > 0:\\n                                f += grid[nr][nc]\\n                                grid[nr][nc] = 0\\n                                q.append((nr, nc))\\n                    ans = max(ans, f)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466627,
                "title": "695-max-area-of-island",
                "content": "This is similar to [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/).\\n\\nFor each \"island\" of water, it does not matter where fisherman starts. We just need to mark a visited cell by setting it to zero.\\n\\n```cpp    \\nint dfs(int r, int c, vector<vector<int>>& g) {\\n    if (min(r, c) < 0 || r == g.size() || c == g[r].size() || g[r][c] == 0)\\n        return 0;\\n    return exchange(g[r][c], 0) + dfs(r + 1, c, g) + dfs(r, c + 1, g) + dfs(r - 1, c, g) + dfs(r, c - 1, g);\\n}\\nint findMaxFish(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (int r = 0; r < g.size(); ++r)\\n        for (int c = 0; c < g[r].size(); ++c)\\n            res = max(res, dfs(r, c, g));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint dfs(int r, int c, vector<vector<int>>& g) {\\n    if (min(r, c) < 0 || r == g.size() || c == g[r].size() || g[r][c] == 0)\\n        return 0;\\n    return exchange(g[r][c], 0) + dfs(r + 1, c, g) + dfs(r, c + 1, g) + dfs(r - 1, c, g) + dfs(r, c - 1, g);\\n}\\nint findMaxFish(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (int r = 0; r < g.size(); ++r)\\n        for (int c = 0; c < g[r].size(); ++c)\\n            res = max(res, dfs(r, c, g));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466637,
                "title": "explained-c-java-dfs-bfs-beginner-friendly-code",
                "content": "**DFS Approach**\\n\\n```\\n1. Define a helper function dfs that takes the grid, the row index r, and the column index c as arguments. The function returns the total number of fish caught starting from the cell (r, c).\\n2. In the dfs function, check if the current cell is out of bounds or a land cell. If so, return 0 (base case).\\n3. Otherwise, catch the fish at the current cell by storing its value in a variable fishCaught.\\n4. Mark the current cell as caught by setting its value to 0 in the grid.\\n5. Define an array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n6. For each possible movement in moves, calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n7. Recursively call the dfs function with the new cell coordinates, and add the result to fishCaught.\\n8. Return fishCaught.\\n9. In the findMaxFish function, initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n10. Iterate over every cell in the grid.\\n11. For each water cell (i.e., cells with a positive value), start a DFS search using the dfs function to find the maximum number of fish that can be caught starting from this cell.\\n12. Update maxFish to the maximum value between maxFish and the number of fish caught starting from the current water cell.\\n13. Return maxFish.\\n```\\n\\n**C++ Code For DFS Approach**\\n```\\nint dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**Java Code For DFS Approach**\\n```\\npublic int dfs(int[][] grid, int r, int c) {\\n    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int[] move : moves) {\\n        int newR = r + move[0];\\n        int newC = c + move[1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**BFS Approach:**\\n```\\n1. Initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n2. Get the size of the grid m x n.\\n3. Define a 2D array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n4. Iterate over every cell in the grid.\\n5. For each water cell (i.e., cells with a positive value), start a BFS search to find the maximum number of fish that can be caught starting from this cell.\\n6. Initialize a queue and add the current water cell coordinates to the queue.\\n7. Initialize a variable fishCaught to 0 to keep track of the number of fish caught starting from the current water cell.\\n8. While the queue is not empty, do the following:\\n\\ta. Dequeue the front element of the queue, representing the current water cell coordinates.\\n\\tb. If the current cell contains fish (i.e., has a positive value), catch the fish and add its value to fishCaught. Set the     cell value to 0 to mark it as caught.\\n\\tc. Iterate over every possible movement in the moves array.\\n\\td. Calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n\\te. If the new cell is within the bounds of the grid and is a water cell (i.e., has a positive value), add its coordinates     to the queue.\\n9. Update maxFish to the maximum value between maxFish and fishCaught.\\n10. Return maxFish.\\n```\\n\\n**C++ Code For BFS Approach**\\n```\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible moves\\n    \\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] > 0) { // Start at a water cell\\n                queue<pair<int, int>> q;\\n                q.push({i, j});\\n                int fishCaught = 0;\\n                while (!q.empty()) {\\n                    int r = q.front().first;\\n                    int c = q.front().second;\\n                    q.pop();\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (auto& move : moves) { // Iterate over possible moves\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR][newC] > 0) {\\n                            q.push({newR, newC}); // Add new water cell to queue\\n                        }\\n                    }\\n                }\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    \\n    return maxFish;\\n}\\n```\\n\\n**Java Code For BFS Approach**\\n\\n```\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start BFS search from water cell\\n                int fishCaught = 0;\\n                Queue<int[]> queue = new LinkedList<>(); // Queue for BFS\\n                queue.offer(new int[]{i, j}); // Enqueue current cell\\n                while (!queue.isEmpty()) {\\n                    int[] curr = queue.poll(); // Dequeue first cell\\n                    int r = curr[0];\\n                    int c = curr[1];\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (int[] move : moves) {\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[0].length && grid[newR][newC] > 0) {\\n                            queue.offer(new int[]{newR, newC}); // Enqueue adjacent water cell\\n                        }\\n                    }\\n                }\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\\n\\n**PLEASE DO UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n1. Define a helper function dfs that takes the grid, the row index r, and the column index c as arguments. The function returns the total number of fish caught starting from the cell (r, c).\\n2. In the dfs function, check if the current cell is out of bounds or a land cell. If so, return 0 (base case).\\n3. Otherwise, catch the fish at the current cell by storing its value in a variable fishCaught.\\n4. Mark the current cell as caught by setting its value to 0 in the grid.\\n5. Define an array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n6. For each possible movement in moves, calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n7. Recursively call the dfs function with the new cell coordinates, and add the result to fishCaught.\\n8. Return fishCaught.\\n9. In the findMaxFish function, initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n10. Iterate over every cell in the grid.\\n11. For each water cell (i.e., cells with a positive value), start a DFS search using the dfs function to find the maximum number of fish that can be caught starting from this cell.\\n12. Update maxFish to the maximum value between maxFish and the number of fish caught starting from the current water cell.\\n13. Return maxFish.\\n```\n```\\nint dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\n```\\npublic int dfs(int[][] grid, int r, int c) {\\n    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int[] move : moves) {\\n        int newR = r + move[0];\\n        int newC = c + move[1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```\n```\\n1. Initialize a variable maxFish to 0 to keep track of the maximum number of fish caught by the fisherman.\\n2. Get the size of the grid m x n.\\n3. Define a 2D array moves that contains the possible movements of the fisherman. Each movement is defined as an array of two integers, representing the change in row and column indices, respectively.\\n4. Iterate over every cell in the grid.\\n5. For each water cell (i.e., cells with a positive value), start a BFS search to find the maximum number of fish that can be caught starting from this cell.\\n6. Initialize a queue and add the current water cell coordinates to the queue.\\n7. Initialize a variable fishCaught to 0 to keep track of the number of fish caught starting from the current water cell.\\n8. While the queue is not empty, do the following:\\n\\ta. Dequeue the front element of the queue, representing the current water cell coordinates.\\n\\tb. If the current cell contains fish (i.e., has a positive value), catch the fish and add its value to fishCaught. Set the     cell value to 0 to mark it as caught.\\n\\tc. Iterate over every possible movement in the moves array.\\n\\td. Calculate the new cell coordinates by adding the movement to the current cell coordinates.\\n\\te. If the new cell is within the bounds of the grid and is a water cell (i.e., has a positive value), add its coordinates     to the queue.\\n9. Update maxFish to the maximum value between maxFish and fishCaught.\\n10. Return maxFish.\\n```\n```\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    \\n    vector<vector<int>> moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible moves\\n    \\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] > 0) { // Start at a water cell\\n                queue<pair<int, int>> q;\\n                q.push({i, j});\\n                int fishCaught = 0;\\n                while (!q.empty()) {\\n                    int r = q.front().first;\\n                    int c = q.front().second;\\n                    q.pop();\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (auto& move : moves) { // Iterate over possible moves\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR][newC] > 0) {\\n                            q.push({newR, newC}); // Add new water cell to queue\\n                        }\\n                    }\\n                }\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    \\n    return maxFish;\\n}\\n```\n```\\npublic int findMaxFish(int[][] grid) {\\n    int maxFish = 0;\\n    int[][] moves = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < grid.length; i++) {\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] > 0) { // Start BFS search from water cell\\n                int fishCaught = 0;\\n                Queue<int[]> queue = new LinkedList<>(); // Queue for BFS\\n                queue.offer(new int[]{i, j}); // Enqueue current cell\\n                while (!queue.isEmpty()) {\\n                    int[] curr = queue.poll(); // Dequeue first cell\\n                    int r = curr[0];\\n                    int c = curr[1];\\n                    if (grid[r][c] > 0) { // Catch fish at current cell\\n                        fishCaught += grid[r][c];\\n                        grid[r][c] = 0; // Mark cell as caught\\n                    }\\n                    for (int[] move : moves) {\\n                        int newR = r + move[0];\\n                        int newC = c + move[1];\\n                        if (newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[0].length && grid[newR][newC] > 0) {\\n                            queue.offer(new int[]{newR, newC}); // Enqueue adjacent water cell\\n                        }\\n                    }\\n                }\\n                maxFish = Math.max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466794,
                "title": "easy-peasy-dfs",
                "content": "```\\nclass Solution {\\n    \\n    private int solve(int i, int j, int m, int n, int[][] grid, boolean[][] vis){\\n       // return if wrong position\\n\\t   if(i < 0 || j < 0 || i == m || j == n || vis[i][j] || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// mark visited\\n        vis[i][j] = true;\\n\\t\\t\\n        // call 4 directions\\n        int total = grid[i][j];\\n        total += solve(i+1, j, m, n, grid, vis);\\n        total += solve(i, j+1, m, n, grid, vis);\\n        total += solve(i, j-1, m, n, grid, vis);\\n        total += solve(i-1, j, m, n, grid, vis);\\n        return total;\\n    }    \\n\\t\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int max = 0;\\n        boolean[][] vis = new boolean[m][n];\\n\\t\\t\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    max = Math.max(max, solve(i, j, m, n, grid, vis));\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/60965b38-0d54-43b0-bf48-49629fbf0e73_1682785742.352511.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int solve(int i, int j, int m, int n, int[][] grid, boolean[][] vis){\\n       // return if wrong position\\n\\t   if(i < 0 || j < 0 || i == m || j == n || vis[i][j] || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// mark visited\\n        vis[i][j] = true;\\n\\t\\t\\n        // call 4 directions\\n        int total = grid[i][j];\\n        total += solve(i+1, j, m, n, grid, vis);\\n        total += solve(i, j+1, m, n, grid, vis);\\n        total += solve(i, j-1, m, n, grid, vis);\\n        total += solve(i-1, j, m, n, grid, vis);\\n        return total;\\n    }    \\n\\t\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int max = 0;\\n        boolean[][] vis = new boolean[m][n];\\n\\t\\t\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    max = Math.max(max, solve(i, j, m, n, grid, vis));\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466685,
                "title": "c-dfs-bfs-union-find-maximum-of-water-components",
                "content": "# Intuition\\nWe can traverse only one complete component of water cells and catch all the fishes in it. Do a DFS/BFS traversal on every water component and count total number of fishes in that component. Take maximum of all possible water components.\\n\\n# Recursive DFS\\n```\\nclass Solution {\\nprivate:\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        if (r == -1 || r == grid.size() || c == -1 || c == grid[0].size() || !grid[r][c] || visited[r][c]) {\\n            return 0;\\n        }\\n        visited[r][c] = true;\\n        return grid[r][c] +\\n            countFishes(grid, visited, r, c + 1) +\\n            countFishes(grid, visited, r, c - 1) +\\n            countFishes(grid, visited, r + 1, c) +\\n            countFishes(grid, visited, r - 1, c);\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Iterative DFS\\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        stack<pair<int, int>> s;\\n        s.push({r, c});\\n        visited[r][c] = true;\\n        while (!s.empty()) {\\n            r = s.top().first, c = s.top().second; s.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    s.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Iterative BFS\\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        queue<pair<int, int>> q;\\n        q.push({r, c});\\n        visited[r][c] = true;\\n        while (!q.empty()) {\\n            r = q.front().first, c = q.front().second; q.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    q.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Union Find\\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent, compSize, fishes;\\n\\npublic:\\n    UnionFind(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), mn = m * n;\\n        parent.resize(mn);\\n        compSize.resize(mn, 1);\\n        fishes.resize(mn);\\n        iota(parent.begin(), parent.end(), 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                fishes[n * i + j] = grid[i][j];\\n            }\\n        }\\n    }\\n\\n    int getParent(int x) {\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                swap(parx, pary);\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n            fishes[parx] += fishes[pary];\\n        }\\n    }\\n\\n    int getFishes(int x) {\\n        return fishes[getParent(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector<int> dr{0, 0, 1, -1}, dc{1, -1, 0, 0};\\n        UnionFind dsu(grid);\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c]) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int r1 = r + dr[k], c1 = c + dc[k];\\n                        if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1]) {\\n                            dsu.unionSet(n * r + c, n * r1 + c1);\\n                        }\\n                    }\\n                    result = max(result, dsu.getFishes(n * r + c));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        if (r == -1 || r == grid.size() || c == -1 || c == grid[0].size() || !grid[r][c] || visited[r][c]) {\\n            return 0;\\n        }\\n        visited[r][c] = true;\\n        return grid[r][c] +\\n            countFishes(grid, visited, r, c + 1) +\\n            countFishes(grid, visited, r, c - 1) +\\n            countFishes(grid, visited, r + 1, c) +\\n            countFishes(grid, visited, r - 1, c);\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        stack<pair<int, int>> s;\\n        s.push({r, c});\\n        visited[r][c] = true;\\n        while (!s.empty()) {\\n            r = s.top().first, c = s.top().second; s.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    s.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> dr, dc;\\n\\n    int countFishes(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        int m = grid.size(), n = grid[0].size(), count = 0;\\n        queue<pair<int, int>> q;\\n        q.push({r, c});\\n        visited[r][c] = true;\\n        while (!q.empty()) {\\n            r = q.front().first, c = q.front().second; q.pop();\\n            count += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int r1 = r + dr[i], c1 = c + dc[i];\\n                if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1] && !visited[r1][c1]) {\\n                    q.push({r1, c1});\\n                    visited[r1][c1] = true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        dr = vector<int>{0, 0, 1, -1};\\n        dc = vector<int>{1, -1, 0, 0};\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector visited(m, vector<bool>(n));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] && !visited[i][j]) {\\n                    result = max(result, countFishes(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent, compSize, fishes;\\n\\npublic:\\n    UnionFind(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), mn = m * n;\\n        parent.resize(mn);\\n        compSize.resize(mn, 1);\\n        fishes.resize(mn);\\n        iota(parent.begin(), parent.end(), 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                fishes[n * i + j] = grid[i][j];\\n            }\\n        }\\n    }\\n\\n    int getParent(int x) {\\n        if (x == parent[x]) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                swap(parx, pary);\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n            fishes[parx] += fishes[pary];\\n        }\\n    }\\n\\n    int getFishes(int x) {\\n        return fishes[getParent(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), result = 0;\\n        vector<int> dr{0, 0, 1, -1}, dc{1, -1, 0, 0};\\n        UnionFind dsu(grid);\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c]) {\\n                    for (int k = 0; k < 4; k++) {\\n                        int r1 = r + dr[k], c1 = c + dc[k];\\n                        if (0 <= r1 && r1 < m && 0 <= c1 && c1 < n && grid[r1][c1]) {\\n                            dsu.unionSet(n * r + c, n * r1 + c1);\\n                        }\\n                    }\\n                    result = max(result, dsu.getFishes(n * r + c));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466626,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466670,
                "title": "easy-to-understand-simple-dfs",
                "content": "#Given : We can start at any water cell \\n#So why not do the same\\n#For a given water cell, collect all the fishes from the cells which are **\\u2018connected\\u2019 [directly/indirectly]** from that cell\\n#So **get the count of fishes for each connected component, and then take the maximum**\\n\\n![image](https://assets.leetcode.com/users/images/3c92b14c-6fce-4335-9244-561701786f6b_1682784101.8203545.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>rowDir = {-1, 1, 0, 0}; //top, bottom, left, right\\n    vector<int>colDir = {0, 0, -1, 1};\\n    int dfs(vector<vector<int>>&grid, int row, int col)\\n    {\\n        if (row < 0 || col < 0 || row == grid.size() || col == grid[0].size()) return 0;\\n        if (grid[row][col] == 0) return 0;\\n       \\n        int sum = grid[row][col]; //include fish count of current cell\\n        grid[row][col] = 0; //mark curr cell as visited [make it a water cell]\\n        for (int dirIdx = 0; dirIdx < 4; dirIdx++)\\n        {\\n            int newRow = row + rowDir[dirIdx];\\n            int newCol = col + colDir[dirIdx];\\n            sum += dfs(grid, newRow, newCol); //add fish count of all connected cells to sum\\n        }\\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int maxCount = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0) continue; //if it is a water cell \\n                \\n                int collectedCount = dfs(grid, i, j);\\n                maxCount = max(maxCount, collectedCount);\\n            }\\n        }\\n        return maxCount;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>rowDir = {-1, 1, 0, 0}; //top, bottom, left, right\\n    vector<int>colDir = {0, 0, -1, 1};\\n    int dfs(vector<vector<int>>&grid, int row, int col)\\n    {\\n        if (row < 0 || col < 0 || row == grid.size() || col == grid[0].size()) return 0;\\n        if (grid[row][col] == 0) return 0;\\n       \\n        int sum = grid[row][col]; //include fish count of current cell\\n        grid[row][col] = 0; //mark curr cell as visited [make it a water cell]\\n        for (int dirIdx = 0; dirIdx < 4; dirIdx++)\\n        {\\n            int newRow = row + rowDir[dirIdx];\\n            int newCol = col + colDir[dirIdx];\\n            sum += dfs(grid, newRow, newCol); //add fish count of all connected cells to sum\\n        }\\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int maxCount = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0) continue; //if it is a water cell \\n                \\n                int collectedCount = dfs(grid, i, j);\\n                maxCount = max(maxCount, collectedCount);\\n            }\\n        }\\n        return maxCount;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467962,
                "title": "python-3-8-lines-dfs-t-m-92-68",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def dfs(r,c):\\n\\n            if (r,c) not in unseen:return 0\\n            unseen.remove((r,c))\\n            return grid[r][c] + dfs(r+1,c)+dfs(r,c+1)+dfs(r-1,c)+dfs(r,c-1)\\n            \\n        m, n, ans = len(grid), len(grid[0]), 0\\n        unseen = {(i,j) for i,j in product(range(m),range(n))\\n                                                if grid[i][j]}\\n        while unseen: ans = max(ans,dfs(*min(unseen)))\\n\\n        return ans \\n```\\n[https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/submissions/975947247/](http://)\\n\\n\\n\\nI\\'m surely wrong, but I think that time complexity might be--worstcase-- *O*(*MN*^2), and space complexity might be *O*(*MN*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def dfs(r,c):\\n\\n            if (r,c) not in unseen:return 0\\n            unseen.remove((r,c))\\n            return grid[r][c] + dfs(r+1,c)+dfs(r,c+1)+dfs(r-1,c)+dfs(r,c-1)\\n            \\n        m, n, ans = len(grid), len(grid[0]), 0\\n        unseen = {(i,j) for i,j in product(range(m),range(n))\\n                                                if grid[i][j]}\\n        while unseen: ans = max(ans,dfs(*min(unseen)))\\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467188,
                "title": "bfs-c-easy-solution",
                "content": "# Approach\\nSimple BFS approach.\\nEnter in a cell when grid[r][c]!=0 and search in neighbours cell using bfs whenever leaving that particular cell add this to our fish variable and put it equal to 0 that is grid[r][c]=0.\\n\\n# Complexity\\n- Time complexity:\\n  O(n*m)\\n\\n- Space complexity:\\n  O(min(n,m))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> v={0,-1,0,1,0};\\n        int ans=0,mx=0;\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    queue<pair<int,int>> q;\\n                    q.push({i,j});\\n                    ans+=grid[i][j];\\n                    grid[i][j]=0;\\n                    while(!q.empty())\\n                    {\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int r1=q.front().first+v[k];\\n                            int c1=q.front().second+v[k+1];\\n                            if(r1>=0 && r1<n && c1>=0 && c1<m && grid[r1][c1]!=0)\\n                            {\\n                                ans+=grid[r1][c1];\\n                                q.push({r1,c1});\\n                                grid[r1][c1]=0;\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n                 mx=max(mx,ans);\\n            }\\n         }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int> v={0,-1,0,1,0};\\n        int ans=0,mx=0;\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    queue<pair<int,int>> q;\\n                    q.push({i,j});\\n                    ans+=grid[i][j];\\n                    grid[i][j]=0;\\n                    while(!q.empty())\\n                    {\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int r1=q.front().first+v[k];\\n                            int c1=q.front().second+v[k+1];\\n                            if(r1>=0 && r1<n && c1>=0 && c1<m && grid[r1][c1]!=0)\\n                            {\\n                                ans+=grid[r1][c1];\\n                                q.push({r1,c1});\\n                                grid[r1][c1]=0;\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n                 mx=max(mx,ans);\\n            }\\n         }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467122,
                "title": "java-bfs-code-with-explanation",
                "content": "# ********** Please upvote if it is helpful **********\\n\\n# Explanation\\n- Given that we have to choose optimal cell i.e grid[r][c] > 0 { water cell } in order to find the maximum fishes we can get.\\n- Traverse the given grid and apply **BFS** on grid[r][c] > 0\\n- We have to calculate the maximum fishes using bfs function.\\n- # BFS function explanation\\n- First of all add the cell into a queue and mark the cell as visited.\\n- Since you are on the cell which have water that consists of fishes so add grid[r][c] to your collection of fishes.\\n- Now check all adjacent sides of current cell whose value should not be \\'0\\' i.e it should be a water cell since if grid[r][c] = 0 it is land and you cant caught fish from land. \\n- If it is water cell then it consists of fishes so, add grid[r][c] it to your collection of fishes.\\n- Now add the adjacent cell to queue if not visited yet.\\n- Lastly **BFS** function returns the number of fishes that you are collected from present cell.\\n-  And each time the max fishes that are collected from each cell{grid[r][c] > 0} calculated in main function.\\n\\n# Complexity\\n- Time complexity: O(N + M) \\n- Space Complexity : O(N)\\n\\n# Code\\n```\\nclass Solution {\\n     int[] x = {-1,0,1,0};\\n     int[] y = {0,1,0,-1};\\n     class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first,int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n   \\n   \\n   \\n    public int bfs(int i,int j,boolean[][] vis,int[][] grid) {\\n       \\n        int sum = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        vis[i][j] = true;\\n        sum += grid[i][j];\\n        while(!q.isEmpty()) {\\n            Pair p = q.poll();\\n            int first = p.first;\\n            int second = p.second;\\n            \\n           \\n            \\n            for(int k = 0;k<4;k++) {\\n                \\n                int ind1 = x[k] + first;\\n                int ind2 = y[k] + second;\\n              \\n                if(ind1 >=0 && ind2 >=0 && ind1 < grid.length && ind2 < grid[0].length && !vis[ind1][ind2] ){\\n                    \\n                    \\n                     if(grid[ind1][ind2] > 0) {\\n                       \\n                          sum += grid[ind1][ind2];\\n                          q.add(new Pair(ind1,ind2));\\n                          vis[ind1][ind2] = true;\\n                     }\\n                   \\n                     \\n                }\\n                \\n            }\\n           \\n        }\\n        return sum;\\n    }\\n\\n     public int findMaxFish(int[][] grid) {\\n      int ans= 0;\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i<grid.length;i++) {\\n            for(int j = 0;j<grid[i].length;j++) {\\n                if(!vis[i][j] && grid[i][j] != 0) {\\n                    ans = Math.max(ans,bfs(i,j,vis,grid));\\n                    \\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n     int[] x = {-1,0,1,0};\\n     int[] y = {0,1,0,-1};\\n     class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first,int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n   \\n   \\n   \\n    public int bfs(int i,int j,boolean[][] vis,int[][] grid) {\\n       \\n        int sum = 0;\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        vis[i][j] = true;\\n        sum += grid[i][j];\\n        while(!q.isEmpty()) {\\n            Pair p = q.poll();\\n            int first = p.first;\\n            int second = p.second;\\n            \\n           \\n            \\n            for(int k = 0;k<4;k++) {\\n                \\n                int ind1 = x[k] + first;\\n                int ind2 = y[k] + second;\\n              \\n                if(ind1 >=0 && ind2 >=0 && ind1 < grid.length && ind2 < grid[0].length && !vis[ind1][ind2] ){\\n                    \\n                    \\n                     if(grid[ind1][ind2] > 0) {\\n                       \\n                          sum += grid[ind1][ind2];\\n                          q.add(new Pair(ind1,ind2));\\n                          vis[ind1][ind2] = true;\\n                     }\\n                   \\n                     \\n                }\\n                \\n            }\\n           \\n        }\\n        return sum;\\n    }\\n\\n     public int findMaxFish(int[][] grid) {\\n      int ans= 0;\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i<grid.length;i++) {\\n            for(int j = 0;j<grid[i].length;j++) {\\n                if(!vis[i][j] && grid[i][j] != 0) {\\n                    ans = Math.max(ans,bfs(i,j,vis,grid));\\n                    \\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466750,
                "title": "c-best-solution-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFS\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        visited[r][c] = true;\\n        int  cnt = grid[r][c], n = grid.size(), m = grid[0].size();\\n        \\n        if(c+1<m && grid[r][c+1] && !visited[r][c+1])   {\\n            cnt += solve(grid, visited, r, c+1);\\n        }\\n        \\n        if(c-1>=0 && grid[r][c-1] && !visited[r][c-1])  {\\n            cnt += solve(grid, visited, r, c-1);\\n        }\\n            \\n        if(r+1<n && grid[r+1][c] && !visited[r+1][c])   {\\n            cnt += solve(grid, visited, r+1, c);\\n        }\\n            \\n        if(r-1>=0 && grid[r-1][c] && !visited[r-1][c])  {\\n            cnt += solve(grid, visited, r-1, c);\\n        }\\n            \\n        return cnt;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi = 0, n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        \\n        for(int i=0; i<n; i++)  for(int j=0; j<m; j++) \\n                // if it is water cell and not visited the call the dfs function to calculate the total fish and compare with the maximum\\n                if(grid[i][j] && !visited[i][j])   {\\n                    int x = solve(grid, visited, i,  j);\\n                    maxi = max(maxi, x);\\n                }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>& grid, vector<vector<bool>>& visited, int r, int c) {\\n        visited[r][c] = true;\\n        int  cnt = grid[r][c], n = grid.size(), m = grid[0].size();\\n        \\n        if(c+1<m && grid[r][c+1] && !visited[r][c+1])   {\\n            cnt += solve(grid, visited, r, c+1);\\n        }\\n        \\n        if(c-1>=0 && grid[r][c-1] && !visited[r][c-1])  {\\n            cnt += solve(grid, visited, r, c-1);\\n        }\\n            \\n        if(r+1<n && grid[r+1][c] && !visited[r+1][c])   {\\n            cnt += solve(grid, visited, r+1, c);\\n        }\\n            \\n        if(r-1>=0 && grid[r-1][c] && !visited[r-1][c])  {\\n            cnt += solve(grid, visited, r-1, c);\\n        }\\n            \\n        return cnt;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi = 0, n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        \\n        for(int i=0; i<n; i++)  for(int j=0; j<m; j++) \\n                // if it is water cell and not visited the call the dfs function to calculate the total fish and compare with the maximum\\n                if(grid[i][j] && !visited[i][j])   {\\n                    int x = solve(grid, visited, i,  j);\\n                    maxi = max(maxi, x);\\n                }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949641,
                "title": "best-o-m-n-solution",
                "content": "# Approach\\nBFS Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int traversal(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int m = grid.size(), n = grid[0].size();\\n        int fish = 0;\\n        queue <pair<int, int>> q;\\n        q.push({i, j});\\n        vis[i][j] = 1;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            fish += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + drow[i];\\n                int nc = c + dcol[i];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n\\n                    && grid[nr][nc] > 0 && !vis[nr][nc]) {\\n                       q.push({nr, nc});\\n                       vis[nr][nc] = 1;\\n                   }\\n            }\\n        }\\n        return fish;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        int maxFish = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = traversal(i, j, grid, vis);\\n                    maxFish = max (maxFish, fish);\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int traversal(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int m = grid.size(), n = grid[0].size();\\n        int fish = 0;\\n        queue <pair<int, int>> q;\\n        q.push({i, j});\\n        vis[i][j] = 1;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            fish += grid[r][c];\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + drow[i];\\n                int nc = c + dcol[i];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n\\n                    && grid[nr][nc] > 0 && !vis[nr][nc]) {\\n                       q.push({nr, nc});\\n                       vis[nr][nc] = 1;\\n                   }\\n            }\\n        }\\n        return fish;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        int maxFish = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = traversal(i, j, grid, vis);\\n                    maxFish = max (maxFish, fish);\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492192,
                "title": "c-dfs",
                "content": "# Approach\\nAPPLE DFS\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &m,int &n,vector<vector<int>> &g,int &k){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j]==0)return;\\n        k += g[i][j];\\n        g[i][j]  = 0;\\n        solve(i+1,j,m,n,g,k);\\n        solve(i,j+1,m,n,g,k);\\n        solve(i-1,j,m,n,g,k);\\n        solve(i,j-1,m,n,g,k);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]){\\n                    k = 0;\\n                    solve(i,j,m,n,grid,k);\\n                    cout<<k<<\" \";\\n                    ans = max(ans,k);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &m,int &n,vector<vector<int>> &g,int &k){\\n        if(i<0||j<0||i>=m||j>=n||g[i][j]==0)return;\\n        k += g[i][j];\\n        g[i][j]  = 0;\\n        solve(i+1,j,m,n,g,k);\\n        solve(i,j+1,m,n,g,k);\\n        solve(i-1,j,m,n,g,k);\\n        solve(i,j-1,m,n,g,k);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,m=grid.size(),n=grid[0].size(),k;\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid[i][j]){\\n                    k = 0;\\n                    solve(i,j,m,n,grid,k);\\n                    cout<<k<<\" \";\\n                    ans = max(ans,k);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468865,
                "title": "easy-solution-java-dfs",
                "content": "# Intuition\\nTo find the maximum fish a fisherman can obtain. The zero represent the land and the numbers represent the number of available fish.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the maximum variable as global\\n- Create a boolean matrix called visited to keep track on the visited grid.\\n- Create a function dfs, it helps to move to adjacent cells in deep and stop if the grid is already visted or the land is reached.\\n- Increase the max for eachs recursive call.\\n- Update the maximum vairalbe for each dfs call from the findMaxFish() function.\\n> Upvote\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int max;\\n    public int findMaxFish(int[][] grid) {\\n        int rlen = grid.length;\\n        int clen = grid[0].length;\\n        int answer = 0;\\n        boolean visited[][] = new boolean[rlen][clen];\\n        for(int i=0;i<rlen;i++){\\n            for(int j=0;j<clen;j++){\\n                if(grid[i][j]!=0 && !visited[i][j]){\\n                    max = 0;\\n                    dfs(grid, rlen, clen,visited, i, j);\\n                    answer = Math.max(max, answer );\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public void dfs(int[][] grid, int rlen, int clen, boolean[][] visited, int i, int j){\\n        if(i<0||i>=rlen||j<0||j>=clen||visited[i][j]||grid[i][j] == 0){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        max +=grid[i][j];\\n        dfs(grid, rlen, clen, visited, i+1, j);\\n        dfs(grid, rlen, clen, visited, i-1, j);\\n        dfs(grid, rlen, clen, visited, i, j+1);\\n        dfs(grid, rlen, clen, visited, i, j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int max;\\n    public int findMaxFish(int[][] grid) {\\n        int rlen = grid.length;\\n        int clen = grid[0].length;\\n        int answer = 0;\\n        boolean visited[][] = new boolean[rlen][clen];\\n        for(int i=0;i<rlen;i++){\\n            for(int j=0;j<clen;j++){\\n                if(grid[i][j]!=0 && !visited[i][j]){\\n                    max = 0;\\n                    dfs(grid, rlen, clen,visited, i, j);\\n                    answer = Math.max(max, answer );\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public void dfs(int[][] grid, int rlen, int clen, boolean[][] visited, int i, int j){\\n        if(i<0||i>=rlen||j<0||j>=clen||visited[i][j]||grid[i][j] == 0){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        max +=grid[i][j];\\n        dfs(grid, rlen, clen, visited, i+1, j);\\n        dfs(grid, rlen, clen, visited, i-1, j);\\n        dfs(grid, rlen, clen, visited, i, j+1);\\n        dfs(grid, rlen, clen, visited, i, j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466636,
                "title": "simple-java-bfs",
                "content": "```\\nclass pair{\\n    int x;int y;\\n    pair(int x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int max=0;\\n      //  System.out.print(bfs(0,1,grid,m,n)+\" \");\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                 //   System.out.print(bfs(i,j,grid,m,n)+\" \");\\n                    \\n                    max=Math.max(max,bfs(i,j,grid,m,n));\\n                }\\n            }\\n        }\\n        return max;\\n       \\n    }\\n    public int bfs(int i,int j,int grid[][],int m,int n){\\n        Queue<pair> q=new LinkedList<>();\\n        q.add(new pair(i,j));\\n         int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n      //  int max=0;\\n        int sum=grid[i][j];\\n        grid[i][j]=0;\\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int x=it.x;\\n            int y=it.y;\\n          //  System.out.print(x+\" \"+y);\\n            for(int p=0;p<4;p++){\\n                int newx=x+dx[p];\\n                int newy=y+dy[p];\\n                if(newx<0 || newy<0 || newx>=m || newy>=n || grid[newx][newy]==0)continue;\\n                q.add(new pair(newx,newy));\\n               \\n                sum+=grid[newx][newy];\\n                 grid[newx][newy]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass pair{\\n    int x;int y;\\n    pair(int x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int max=0;\\n      //  System.out.print(bfs(0,1,grid,m,n)+\" \");\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                 //   System.out.print(bfs(i,j,grid,m,n)+\" \");\\n                    \\n                    max=Math.max(max,bfs(i,j,grid,m,n));\\n                }\\n            }\\n        }\\n        return max;\\n       \\n    }\\n    public int bfs(int i,int j,int grid[][],int m,int n){\\n        Queue<pair> q=new LinkedList<>();\\n        q.add(new pair(i,j));\\n         int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n      //  int max=0;\\n        int sum=grid[i][j];\\n        grid[i][j]=0;\\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int x=it.x;\\n            int y=it.y;\\n          //  System.out.print(x+\" \"+y);\\n            for(int p=0;p<4;p++){\\n                int newx=x+dx[p];\\n                int newy=y+dy[p];\\n                if(newx<0 || newy<0 || newx>=m || newy>=n || grid[newx][newy]==0)continue;\\n                q.add(new pair(newx,newy));\\n               \\n                sum+=grid[newx][newy];\\n                 grid[newx][newy]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673143,
                "title": "easy-approach-c-depth-first-search-maximum-number-of-fishes-in-a-grid",
                "content": "# Approach\\nDepth first Search.\\n- Converted each traversed path to land cell so that a separate `visited` array is not required.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n\\n    bool isValid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int dfs(vector<vector<int>>& grid, int row, int col){\\n        int n = grid.size(), m = grid[0].size();\\n        if(!isValid(row, col, n, m) || grid[row][col] == 0) return 0;\\n        int direc[5] = {0, 1, 0, -1, 0};\\n        int res = grid[row][col];\\n        grid[row][col] = 0;\\n        for(int k=0; k<4; k++) { \\n            res += dfs(grid, row+direc[k], col+direc[k+1]);\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n\\n    bool isValid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int dfs(vector<vector<int>>& grid, int row, int col){\\n        int n = grid.size(), m = grid[0].size();\\n        if(!isValid(row, col, n, m) || grid[row][col] == 0) return 0;\\n        int direc[5] = {0, 1, 0, -1, 0};\\n        int res = grid[row][col];\\n        grid[row][col] = 0;\\n        for(int k=0; k<4; k++) { \\n            res += dfs(grid, row+direc[k], col+direc[k+1]);\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i< grid.size(); ++i){\\n            for(int j =0; j < grid[0].size(); ++j){\\n                ans = max(ans, dfs(grid, i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468041,
                "title": "fully-explained-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n\\t\\t// Loop over the Entire Grid\\n        for(int i=0;i< grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n\\t\\t\\t    // only call the dfs call when we encounter a value>0, then find the number of connected land and calculate value and compare it with the previous max\\n                if(grid[i][j]>0){\\n                    max= Math.max(max, dfs(grid, i, j));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int[][] grid, int i, int j){\\n\\t\\t// if we gets out of bound or its a 0 i.e. water then return 0\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0) return 0;\\n\\t\\t// if not then mark the grid value to 0 to make sure we do not come back to the same piece of land and cause infinite recursion i.e. stack over flow\\n        int val = grid[i][j];\\n        grid[i][j]=0;\\n\\t\\t// now just go to all 4 direction get the respective counts and add it all together and return it\\n        return val+ dfs(grid, i-1, j)+ dfs(grid, i+1, j)+ dfs(grid, i, j-1)+ dfs(grid, i, j+1);\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n\\t\\t// Loop over the Entire Grid\\n        for(int i=0;i< grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n\\t\\t\\t    // only call the dfs call when we encounter a value>0, then find the number of connected land and calculate value and compare it with the previous max\\n                if(grid[i][j]>0){\\n                    max= Math.max(max, dfs(grid, i, j));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int[][] grid, int i, int j){\\n\\t\\t// if we gets out of bound or its a 0 i.e. water then return 0\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0) return 0;\\n\\t\\t// if not then mark the grid value to 0 to make sure we do not come back to the same piece of land and cause infinite recursion i.e. stack over flow\\n        int val = grid[i][j];\\n        grid[i][j]=0;\\n\\t\\t// now just go to all 4 direction get the respective counts and add it all together and return it\\n        return val+ dfs(grid, i-1, j)+ dfs(grid, i+1, j)+ dfs(grid, i, j-1)+ dfs(grid, i, j+1);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467257,
                "title": "c-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467120,
                "title": "python-3-easy-solution",
                "content": "The function then defines an inner function called **dfs** that performs a depth-first search on the grid starting from a given position (i,j) and returns the sum of fish in the connected region.\\n\\nThe dfs function first checks if the **current** position is **outside the bounds** of the grid or if the position corresponds to a cell with value **0 or -1** (0 - water, -1 - visited). If any of these conditions is true, the function returns 0 (**no fish here**).\\nOtherwise, the function retrieves the number of fish fish in the current cell, sets the cell value to -1 (*to mark it as visited*), and recursively calls itself on the four adjacent cells (up, left, down, and right), accumulating the fish counts in a variable temp.\\n\\n```\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        N, M = len(grid), len(grid[0])\\n        \\n        def dfs(i, j, temp):\\n            if i < 0 or j < 0 or i >= N or j >= M or grid[i][j] in [0, -1]:\\n                return 0\\n            \\n            fish = grid[i][j]\\n            grid[i][j] = -1  # visited\\n            temp += (fish + dfs(i-1, j, temp) + dfs(i, j-1, temp) + dfs(i+1, j, temp) + dfs(i, j+1, temp))\\n\\n            return temp \\n        \\n        maxi = 0\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] > 0:\\n                    maxi = max(maxi, dfs(i, j, 0))\\n                \\n        return maxi\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        N, M = len(grid), len(grid[0])\\n        \\n        def dfs(i, j, temp):\\n            if i < 0 or j < 0 or i >= N or j >= M or grid[i][j] in [0, -1]:\\n                return 0\\n            \\n            fish = grid[i][j]\\n            grid[i][j] = -1  # visited\\n            temp += (fish + dfs(i-1, j, temp) + dfs(i, j-1, temp) + dfs(i+1, j, temp) + dfs(i, j+1, temp))\\n\\n            return temp \\n        \\n        maxi = 0\\n        for i in range(N):\\n            for j in range(M):\\n                if grid[i][j] > 0:\\n                    maxi = max(maxi, dfs(i, j, 0))\\n                \\n        return maxi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466759,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\npublic class Solution {\\n    int max = 0, cur = 0;\\n    public int findMaxFish(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 0) continue;\\n                pass(grid, i, j);\\n                cur = 0;\\n            }\\n        }\\n        return max;\\n    }\\n    void pass(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0)    return;\\n        cur += grid[i][j];\\n        grid[i][j] = 0;\\n        max = Math.max(max,cur);\\n        pass(grid, i+1, j);\\n        pass(grid, i-1, j);\\n        pass(grid, i, j+1);\\n        pass(grid, i, j-1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\npublic class Solution {\\n    int max = 0, cur = 0;\\n    public int findMaxFish(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 0) continue;\\n                pass(grid, i, j);\\n                cur = 0;\\n            }\\n        }\\n        return max;\\n    }\\n    void pass(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0)    return;\\n        cur += grid[i][j];\\n        grid[i][j] = 0;\\n        max = Math.max(max,cur);\\n        pass(grid, i+1, j);\\n        pass(grid, i-1, j);\\n        pass(grid, i, j+1);\\n        pass(grid, i, j-1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466660,
                "title": "easy-to-understand-clean-solution-dfs-python-java",
                "content": "**T.C : O(n^2)**\\n\\n**Python**\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fishes = 0\\n\\n        def catchFish(r, c):\\n            nonlocal fish\\n            if 0 <= r < m and 0 <= c < n and grid[r][c] > 0:\\n                fish += grid[r][c]\\n                grid[r][c] = 0  # mark cell as visited\\n                catchFish(r+1, c)\\n                catchFish(r-1, c)\\n                catchFish(r, c+1)\\n                catchFish(r, c-1)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] > 0:\\n                    fish = 0\\n                    catchFish(r, c)\\n                    fishes = max(fishes, fish)\\n\\n        return fishes\\n```\\n\\n**Java**\\n\\n```\\npublic class Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int fishes = 0;\\n\\n        // Helper function to catch fish recursively\\n        // Updates the \\'fishes\\' variable as it catches fish\\n        void catchFish(int r, int c) {\\n            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] > 0) {\\n                fishes += grid[r][c];\\n                grid[r][c] = 0; // mark cell as visited\\n                catchFish(r+1, c);\\n                catchFish(r-1, c);\\n                catchFish(r, c+1);\\n                catchFish(r, c-1);\\n            }\\n        }\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] > 0) {\\n                    int fish = 0;\\n                    catchFish(r, c);\\n                    fishes = Math.max(fishes, fish);\\n                }\\n            }\\n        }\\n\\n        return fishes;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fishes = 0\\n\\n        def catchFish(r, c):\\n            nonlocal fish\\n            if 0 <= r < m and 0 <= c < n and grid[r][c] > 0:\\n                fish += grid[r][c]\\n                grid[r][c] = 0  # mark cell as visited\\n                catchFish(r+1, c)\\n                catchFish(r-1, c)\\n                catchFish(r, c+1)\\n                catchFish(r, c-1)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] > 0:\\n                    fish = 0\\n                    catchFish(r, c)\\n                    fishes = max(fishes, fish)\\n\\n        return fishes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511854,
                "title": "dfs-approach-easy-to-understand-standard-method-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a standard traversal problem where we will traverse each component, find the sum of fishes on each component and find out the maximum of all the sums.\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    void dfs(vvi& grid, int i,int j, int& sum){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i>=m || i<0 || j<0 || j>=n){\\n            return;\\n        }\\n        if(grid[i][j]!=0 && grid[i][j]!=-1){\\n            sum += grid[i][j];\\n            grid[i][j]=-1;\\n            dfs(grid,i+1,j,sum);\\n            dfs(grid,i,j+1,sum);\\n            dfs(grid,i-1,j,sum);\\n            dfs(grid,i,j-1,sum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = INT_MIN;\\n        int sum=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                    dfs(grid,i,j,sum);\\n                    ans = max(ans,sum);\\n                    sum=0;\\n                }\\n            }\\n        }\\n    \\n        return ans==INT_MIN?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    void dfs(vvi& grid, int i,int j, int& sum){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i>=m || i<0 || j<0 || j>=n){\\n            return;\\n        }\\n        if(grid[i][j]!=0 && grid[i][j]!=-1){\\n            sum += grid[i][j];\\n            grid[i][j]=-1;\\n            dfs(grid,i+1,j,sum);\\n            dfs(grid,i,j+1,sum);\\n            dfs(grid,i-1,j,sum);\\n            dfs(grid,i,j-1,sum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = INT_MIN;\\n        int sum=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0){\\n                    dfs(grid,i,j,sum);\\n                    ans = max(ans,sum);\\n                    sum=0;\\n                }\\n            }\\n        }\\n    \\n        return ans==INT_MIN?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497476,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- BFS traversal on the Connected Components. Just a variation of LC #200[Number Of Islands]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code uses a breadth-first search (BFS) approach to traverse the water cells in the given grid and calculate the maximum number of fish that can be caught.\\n\\n- For each water cell in the grid, the BFS is applied to find out  all the connected water cells and count the total number of fish in those cells.\\n\\n- The maximum fish count obtained from all the BFS traversals is then returned as the result.\\n\\n# Complexity\\nTime complexity:  O(m * n(m + n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- where m and n are the number of rows and columns in the input grid. In the worst case, we may have to traverse all the water cells in the grid, and each BFS traversal takes O(m + n) time.\\n\\nSpace complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- since we are using a 2D visited matrix to keep track of the visited water cells. In the worst case, all the water cells may need to be visited, requiring a visited matrix of size mn. Additionally, the queue used in BFS will hold a maximum of O(m*n) water cell positions at any point in time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxFishes = INT_MIN;\\n\\n    void bfs(int row, int col, vector <vector<int>> &grid, vector <vector<int>> &vis, int dx[], int dy[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vis[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n\\n        int fishes = 0;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n\\n            //adding the count of the number of fishes in the current cell\\n            fishes += grid[x][y];\\n            q.pop();\\n\\n            //finding out the current cell neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nRow = x + dx[i];\\n                int nCol = y + dy[i];\\n                \\n                //check for the validity of neighbouring row & col\\n                if(nRow >= 0 && nRow < n && nCol >= 0 && nCol < m && grid[nRow][nCol] > 0 && !vis[nRow][nCol])\\n                {\\n                    vis[nRow][nCol] = 1;\\n                    q.push({nRow, nCol});\\n                }\\n            }\\n        }\\n\\n        maxFishes = max(maxFishes, fishes);\\n        return;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        //no of rows\\n        int n = grid.size();\\n        \\n        //no of cols\\n        int m = grid[0].size();\\n        \\n        //create the visited matrix to keep track of the water cell\\n        vector <vector <int>> vis(n, vector <int> (m, 0));\\n        \\n        //can move only in 4-directions\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};    \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0 && !vis[i][j])\\n                    bfs(i, j, grid, vis, dx, dy);\\n            }\\n        }\\n        \\n        return maxFishes == INT_MIN ? 0 : maxFishes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxFishes = INT_MIN;\\n\\n    void bfs(int row, int col, vector <vector<int>> &grid, vector <vector<int>> &vis, int dx[], int dy[])\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vis[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n\\n        int fishes = 0;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n\\n            //adding the count of the number of fishes in the current cell\\n            fishes += grid[x][y];\\n            q.pop();\\n\\n            //finding out the current cell neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nRow = x + dx[i];\\n                int nCol = y + dy[i];\\n                \\n                //check for the validity of neighbouring row & col\\n                if(nRow >= 0 && nRow < n && nCol >= 0 && nCol < m && grid[nRow][nCol] > 0 && !vis[nRow][nCol])\\n                {\\n                    vis[nRow][nCol] = 1;\\n                    q.push({nRow, nCol});\\n                }\\n            }\\n        }\\n\\n        maxFishes = max(maxFishes, fishes);\\n        return;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        //no of rows\\n        int n = grid.size();\\n        \\n        //no of cols\\n        int m = grid[0].size();\\n        \\n        //create the visited matrix to keep track of the water cell\\n        vector <vector <int>> vis(n, vector <int> (m, 0));\\n        \\n        //can move only in 4-directions\\n        int dx[] = {0, 0, 1, -1};\\n        int dy[] = {1, -1, 0, 0};    \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0 && !vis[i][j])\\n                    bfs(i, j, grid, vis, dx, dy);\\n            }\\n        }\\n        \\n        return maxFishes == INT_MIN ? 0 : maxFishes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470839,
                "title": "c-dfs-similar-to-number-of-islands",
                "content": "# Intuition\\nSimple DFS involves calculating the sum of different islands and taking the maximum one.\\nSimilar to Number of Islands problem (https://leetcode.com/problems/number-of-islands/).\\n# Approach\\nDepth First Search\\n\\n## Don\\'t forget to upvote and give a like \\uD83D\\uDE43\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0};\\n    void dfs(int x,int y,vector<vector<int>>& grid,int* ans){\\n        for(int next = 0;next<4;next++){\\n            int x1 = x + dx[next];\\n            int y1 = y + dy[next];\\n            if(x1>=0 and y1>=0 and y1<grid[0].size() and x1<grid.size() and grid[x1][y1]!=0){\\n                *ans += grid[x1][y1];\\n                grid[x1][y1] = 0;\\n                dfs(x1,y1,grid,ans);\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n  = grid[0].size();\\n        //vector<vector<int>> vis(m,vector<int>(m,0));\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(grid[i][j] != 0){\\n                    int count = grid[i][j];\\n                    grid[i][j] = 0;\\n                    dfs(i,j,grid,&count);\\n                    ans = max(ans,count);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### I hope the solution is clear; use the comment section regarding any doubt.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,0,-1,1};\\n    int dy[4] = {1,-1,0,0};\\n    void dfs(int x,int y,vector<vector<int>>& grid,int* ans){\\n        for(int next = 0;next<4;next++){\\n            int x1 = x + dx[next];\\n            int y1 = y + dy[next];\\n            if(x1>=0 and y1>=0 and y1<grid[0].size() and x1<grid.size() and grid[x1][y1]!=0){\\n                *ans += grid[x1][y1];\\n                grid[x1][y1] = 0;\\n                dfs(x1,y1,grid,ans);\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n  = grid[0].size();\\n        //vector<vector<int>> vis(m,vector<int>(m,0));\\n        int ans = 0;\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(grid[i][j] != 0){\\n                    int count = grid[i][j];\\n                    grid[i][j] = 0;\\n                    dfs(i,j,grid,&count);\\n                    ans = max(ans,count);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467138,
                "title": "c-simple-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    void f(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>> &vis)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        vis[i][j]=1;\\n        int s=0;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            s+=grid[x][y];\\n            q.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=m or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==0)\\n                    continue;\\n                q.push({newx,newy});\\n                vis[newx][newy]=1;\\n            }\\n        }\\n        maxi=max(maxi,s);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0 and !vis[i][j])\\n                {\\n                    f(i,j,m,n,grid,vis);\\n                }\\n            }\\n        }\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    void f(int i,int j,int m,int n,vector<vector<int>> &grid,vector<vector<int>> &vis)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        vis[i][j]=1;\\n        int s=0;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            s+=grid[x][y];\\n            q.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=m or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==0)\\n                    continue;\\n                q.push({newx,newy});\\n                vis[newx][newy]=1;\\n            }\\n        }\\n        maxi=max(maxi,s);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0 and !vis[i][j])\\n                {\\n                    f(i,j,m,n,grid,vis);\\n                }\\n            }\\n        }\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467125,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS 2D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, cnt, vis[11][11];\\n    \\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and grids[x][y]) return true;\\n        else return false;\\n    }\\n    \\n    void dfs(int x, int y) {\\n        if(valid(x, y)) {\\n            vis[x][y] = 1;\\n            cnt += grids[x][y];\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        grids = grid;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(!vis[i][j] and grid[i][j]) {\\n                    cnt = 0;\\n                    dfs(i, j);\\n                    ans = max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> grids;\\n    int n, m, cnt, vis[11][11];\\n    \\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and grids[x][y]) return true;\\n        else return false;\\n    }\\n    \\n    void dfs(int x, int y) {\\n        if(valid(x, y)) {\\n            vis[x][y] = 1;\\n            cnt += grids[x][y];\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        grids = grid;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(!vis[i][j] and grid[i][j]) {\\n                    cnt = 0;\\n                    dfs(i, j);\\n                    ans = max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466879,
                "title": "dfs-most-simple-solution-c",
                "content": "\\n````\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &a,int &b,int &sum,int &ans,vector<vector<int>> &g){\\n        ans = max(ans,sum);\\n        if(i<0||j<0||i>=a||j>=b||g[i][j]==0){\\n            return;\\n        }\\n        sum += g[i][j];\\n        g[i][j] = 0;\\n        solve(i+1,j,a,b,sum,ans,g);\\n        solve(i,j+1,a,b,sum,ans,g);\\n        solve(i-1,j,a,b,sum,ans,g);\\n        solve(i,j-1,a,b,sum,ans,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,a = grid.size(),b = grid[0].size();\\n        int sum = 0;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]){\\n                    sum = 0;\\n                    solve(i,j,a,b,sum,ans,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(int i,int j,int &a,int &b,int &sum,int &ans,vector<vector<int>> &g){\\n        ans = max(ans,sum);\\n        if(i<0||j<0||i>=a||j>=b||g[i][j]==0){\\n            return;\\n        }\\n        sum += g[i][j];\\n        g[i][j] = 0;\\n        solve(i+1,j,a,b,sum,ans,g);\\n        solve(i,j+1,a,b,sum,ans,g);\\n        solve(i-1,j,a,b,sum,ans,g);\\n        solve(i,j-1,a,b,sum,ans,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int i,j,a = grid.size(),b = grid[0].size();\\n        int sum = 0;\\n        for(i = 0; i < a; i++){\\n            for(j = 0; j < b; j++){\\n                if(grid[i][j]){\\n                    sum = 0;\\n                    solve(i,j,a,b,sum,ans,grid);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466830,
                "title": "intuitive-javascript-solution-using-dfs",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS\\n\\n# Complexity\\n- Time complexity: O(M * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M * N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max_fishes = 0;\\n    let ROW = grid.length;\\n    let COL = grid[0].length;\\n    \\n    // returns the sum of fishes possible\\n    const DFS = (r, c, visit) => {\\n        \\n        // base cases returns 0; \\n        if( r < 0 || r >= ROW ||\\n            c < 0 || c >= COL || \\n            visit.has(`${r}_${c}`) ||\\n            grid[r][c] == 0 \\n          ){\\n            return 0;\\n        }\\n        \\n        // set visted\\n        visit.add(`${r}_${c}`);\\n        \\n        let sum = grid[r][c]; // add current value to sum\\n        \\n        // check the surrounding nodes\\n        sum += DFS(r, c + 1, visit);\\n        sum += DFS(r, c - 1, visit);\\n        sum += DFS(r + 1, c, visit);\\n        sum += DFS(r - 1, c, visit);\\n        \\n        return sum;\\n    }\\n    \\n    let set = new Set(); // to record all visted nodes\\n    \\n    // go through each cell\\n    for(let r = 0; r < ROW; r++){\\n       for(let c = 0; c < COL; c++){\\n            // if the cell is water\\n           if(grid[r][c] != 0){ \\n               let res = DFS(r, c, set);\\n\\n               //compare the result from DFS to main global variable \\n               max_fishes = Math.max(res, max_fishes);\\n           }\\n       }\\n    }\\n    \\n    return max_fishes; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max_fishes = 0;\\n    let ROW = grid.length;\\n    let COL = grid[0].length;\\n    \\n    // returns the sum of fishes possible\\n    const DFS = (r, c, visit) => {\\n        \\n        // base cases returns 0; \\n        if( r < 0 || r >= ROW ||\\n            c < 0 || c >= COL || \\n            visit.has(`${r}_${c}`) ||\\n            grid[r][c] == 0 \\n          ){\\n            return 0;\\n        }\\n        \\n        // set visted\\n        visit.add(`${r}_${c}`);\\n        \\n        let sum = grid[r][c]; // add current value to sum\\n        \\n        // check the surrounding nodes\\n        sum += DFS(r, c + 1, visit);\\n        sum += DFS(r, c - 1, visit);\\n        sum += DFS(r + 1, c, visit);\\n        sum += DFS(r - 1, c, visit);\\n        \\n        return sum;\\n    }\\n    \\n    let set = new Set(); // to record all visted nodes\\n    \\n    // go through each cell\\n    for(let r = 0; r < ROW; r++){\\n       for(let c = 0; c < COL; c++){\\n            // if the cell is water\\n           if(grid[r][c] != 0){ \\n               let res = DFS(r, c, set);\\n\\n               //compare the result from DFS to main global variable \\n               max_fishes = Math.max(res, max_fishes);\\n           }\\n       }\\n    }\\n    \\n    return max_fishes; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466744,
                "title": "simple-bfs-solution-connected-components-c",
                "content": "\\n# Approach\\nSame as island problem connected component. Using BFS traverse all the components and return the maximum sum of the the components.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   /*  dfs(int row,int col,vector<vector<int>>&vis,cnt){\\n        vis[row][col]=1;\\n        cnt+=grid[row][col];\\n        \\n    }*/\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int cnt = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\nvector<vector<int>>vis;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] > 0)\\n                {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int fish = grid[i][j];\\n                    grid[i][j] = 0;\\n\\n                    while (!q.empty())\\n                    {\\n                        int row = q.front().first;\\n                        int col = q.front().second;\\n                        q.pop();\\n\\n                        if (row > 0 && grid[row - 1][col] > 0)\\n                        {\\n                            fish += grid[row - 1][col];\\n                            q.push({row - 1, col});\\n                            grid[row - 1][col] = 0;\\n                        }\\n                        if (row < m - 1 && grid[row + 1][col] > 0)\\n                        {\\n                            fish += grid[row + 1][col];\\n                            q.push({row + 1, col});\\n                            grid[row + 1][col] = 0;\\n                        }\\n                        if (col > 0 && grid[row][col - 1] > 0)\\n                        {\\n                            fish += grid[row][col - 1];\\n                            q.push({row, col - 1});\\n                            grid[row][col - 1] = 0;\\n                        }\\n                        if (col < n - 1 && grid[row][col + 1] > 0)\\n                        {\\n                            fish += grid[row][col + 1];\\n                            q.push({row, col + 1});\\n                            grid[row][col + 1] = 0;\\n                        }\\n                    }\\n\\n                    cnt = max(cnt, fish);\\n                              grid[i][j] = fish;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   /*  dfs(int row,int col,vector<vector<int>>&vis,cnt){\\n        vis[row][col]=1;\\n        cnt+=grid[row][col];\\n        \\n    }*/\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int cnt = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\nvector<vector<int>>vis;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] > 0)\\n                {\\n                    queue<pair<int, int>> q;\\n                    q.push({i, j});\\n                    int fish = grid[i][j];\\n                    grid[i][j] = 0;\\n\\n                    while (!q.empty())\\n                    {\\n                        int row = q.front().first;\\n                        int col = q.front().second;\\n                        q.pop();\\n\\n                        if (row > 0 && grid[row - 1][col] > 0)\\n                        {\\n                            fish += grid[row - 1][col];\\n                            q.push({row - 1, col});\\n                            grid[row - 1][col] = 0;\\n                        }\\n                        if (row < m - 1 && grid[row + 1][col] > 0)\\n                        {\\n                            fish += grid[row + 1][col];\\n                            q.push({row + 1, col});\\n                            grid[row + 1][col] = 0;\\n                        }\\n                        if (col > 0 && grid[row][col - 1] > 0)\\n                        {\\n                            fish += grid[row][col - 1];\\n                            q.push({row, col - 1});\\n                            grid[row][col - 1] = 0;\\n                        }\\n                        if (col < n - 1 && grid[row][col + 1] > 0)\\n                        {\\n                            fish += grid[row][col + 1];\\n                            q.push({row, col + 1});\\n                            grid[row][col + 1] = 0;\\n                        }\\n                    }\\n\\n                    cnt = max(cnt, fish);\\n                              grid[i][j] = fish;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466663,
                "title": "concise-dfs-c",
                "content": "```\\nclass Solution {\\n    vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, int n, int m) {\\n        vis[i][j] = 1;\\n        int cnt = grid[i][j];\\n        \\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] > 0 && !vis[x][y]) {\\n                cnt += dfs(x, y, grid, vis, n, m);\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    ans = max(ans, dfs(i, j, grid, vis, n, m));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, int n, int m) {\\n        vis[i][j] = 1;\\n        int cnt = grid[i][j];\\n        \\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] > 0 && !vis[x][y]) {\\n                cnt += dfs(x, y, grid, vis, n, m);\\n            }\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    ans = max(ans, dfs(i, j, grid, vis, n, m));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003882,
                "title": "easy-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool check(int row, int col, int n, int m)\\n    {\\n        if (row >= 0 && row < n && col >= 0 && col < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(vector<vector<int>> &grid, int row, int col, vector<vector<bool>> &visited)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if (!check(row, col, n, m) || grid[row][col] == 0 || visited[row][col])\\n        {\\n            return 0;\\n        }\\n        \\n        visited[row][col] = true;\\n        int curr_fish = grid[row][col];\\n        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newR = row + dir[i][0];\\n            int newC = col + dir[i][1];\\n            curr_fish += dfs(grid, newR, newC, visited);\\n        }\\n        \\n        return curr_fish;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>> &grid)\\n    {\\n        int max_fish = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0)\\n                {\\n                    vector<vector<bool>> visited(n, vector<bool>(m, false));\\n                    int curr_fish_now = dfs(grid, i, j, visited);\\n                    max_fish = max(curr_fish_now, max_fish);\\n                }\\n            }\\n        }\\n        \\n        return max_fish;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool check(int row, int col, int n, int m)\\n    {\\n        if (row >= 0 && row < n && col >= 0 && col < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int dfs(vector<vector<int>> &grid, int row, int col, vector<vector<bool>> &visited)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if (!check(row, col, n, m) || grid[row][col] == 0 || visited[row][col])\\n        {\\n            return 0;\\n        }\\n        \\n        visited[row][col] = true;\\n        int curr_fish = grid[row][col];\\n        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            int newR = row + dir[i][0];\\n            int newC = col + dir[i][1];\\n            curr_fish += dfs(grid, newR, newC, visited);\\n        }\\n        \\n        return curr_fish;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>> &grid)\\n    {\\n        int max_fish = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] > 0)\\n                {\\n                    vector<vector<bool>> visited(n, vector<bool>(m, false));\\n                    int curr_fish_now = dfs(grid, i, j, visited);\\n                    max_fish = max(curr_fish_now, max_fish);\\n                }\\n            }\\n        }\\n        \\n        return max_fish;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843214,
                "title": "easy-dfs-beats-70-java",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$ , stack space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0}, new Integer[]{-1, 0}, new Integer[]{0, 1}, new Integer[]{0, -1}\\n    );\\n\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) maxFish = Math.max(maxFish, dfs(i, j, grid));\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid) {\\n        if (notValid(i, j, grid) || grid[i][j] == 0) return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            fish += dfs(x, y, grid);\\n        }\\n        return fish;\\n    }\\n\\n    private boolean notValid(int i, int j, int[][] grid) {\\n        return i < 0 || i >= grid.length || j < 0 || j >= grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{1, 0}, new Integer[]{-1, 0}, new Integer[]{0, 1}, new Integer[]{0, -1}\\n    );\\n\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) maxFish = Math.max(maxFish, dfs(i, j, grid));\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int dfs(int i, int j, int[][] grid) {\\n        if (notValid(i, j, grid) || grid[i][j] == 0) return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            fish += dfs(x, y, grid);\\n        }\\n        return fish;\\n    }\\n\\n    private boolean notValid(int i, int j, int[][] grid) {\\n        return i < 0 || i >= grid.length || j < 0 || j >= grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670649,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    int fish = 0;\\n                    cout<<i<<\" \"<<j<<endl;\\n                    bfs(i,j,fish,vis,grid);\\n                    ans = max(fish,ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void bfs(int i, int j,int &fish, vector<vector<int>>& vis,vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int drows[] = {-1,0,1,0};\\n        int dcols[] = {0,1,0,-1};\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        \\n        vis[i][j] = 1;\\n        fish += grid[i][j];\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int nrow = row + drows[k];\\n                int ncol = col + dcols[k];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && !vis[nrow][ncol] && grid[nrow][ncol] > 0 ){\\n                    q.push({nrow,ncol});\\n                    vis[nrow][ncol] = 1;\\n                    fish += grid[nrow][ncol];\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int ans = 0;\\n        \\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && grid[i][j] > 0){\\n                    int fish = 0;\\n                    cout<<i<<\" \"<<j<<endl;\\n                    bfs(i,j,fish,vis,grid);\\n                    ans = max(fish,ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void bfs(int i, int j,int &fish, vector<vector<int>>& vis,vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int drows[] = {-1,0,1,0};\\n        int dcols[] = {0,1,0,-1};\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        \\n        vis[i][j] = 1;\\n        fish += grid[i][j];\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int nrow = row + drows[k];\\n                int ncol = col + dcols[k];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && !vis[nrow][ncol] && grid[nrow][ncol] > 0 ){\\n                    q.push({nrow,ncol});\\n                    vis[nrow][ncol] = 1;\\n                    fish += grid[nrow][ncol];\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3666202,
                "title": "java-dfs-boolean-array-of-visited-cells",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < visited.length; i++) for (int j = 0; j < visited[i].length; j++) if (grid[i][j] == 0) visited[i][j] = true;\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (visited[i][j]) continue;\\n                int fish = dfs(i, j, grid, visited, directions);\\n                max = Math.max(fish, max);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited, int[][] directions) {\\n        if (!cellExists(r, c, grid)) return 0;\\n\\n        if (visited[r][c]) return 0;\\n        visited[r][c] = true;\\n        int sum = grid[r][c];\\n        for (int[] dir : directions) {\\n            sum += dfs(r + dir[0], c + dir[1], grid, visited, directions);\\n        }\\n        return sum;\\n    }\\n\\n    private boolean cellExists(int r, int c, int[][] grid) {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < visited.length; i++) for (int j = 0; j < visited[i].length; j++) if (grid[i][j] == 0) visited[i][j] = true;\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                if (visited[i][j]) continue;\\n                int fish = dfs(i, j, grid, visited, directions);\\n                max = Math.max(fish, max);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited, int[][] directions) {\\n        if (!cellExists(r, c, grid)) return 0;\\n\\n        if (visited[r][c]) return 0;\\n        visited[r][c] = true;\\n        int sum = grid[r][c];\\n        for (int[] dir : directions) {\\n            sum += dfs(r + dir[0], c + dir[1], grid, visited, directions);\\n        }\\n        return sum;\\n    }\\n\\n    private boolean cellExists(int r, int c, int[][] grid) {\\n        return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617423,
                "title": "java-simple-dfs-algorithm-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dir[][]={{0,1},{0,-1},{1,0},{-1,0}};\\n    public int explore(int a[][],int i,int j,boolean vis[][]){\\n        if(i<0||j<0||i>=a.length||j>=a[0].length||a[i][j]==0||vis[i][j]){\\n            return 0;\\n        }\\n        vis[i][j] = true;\\n        int sum = 0 ;\\n    for(int t=0;t<dir.length;t++){\\n      sum+=  explore(a,i+dir[t][0],j+dir[t][1],vis);\\n    }\\n\\n    return sum+a[i][j];\\n\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    int val = explore(grid,  i,  j,vis);\\n                    if(max<val)max = val;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int dir[][]={{0,1},{0,-1},{1,0},{-1,0}};\\n    public int explore(int a[][],int i,int j,boolean vis[][]){\\n        if(i<0||j<0||i>=a.length||j>=a[0].length||a[i][j]==0||vis[i][j]){\\n            return 0;\\n        }\\n        vis[i][j] = true;\\n        int sum = 0 ;\\n    for(int t=0;t<dir.length;t++){\\n      sum+=  explore(a,i+dir[t][0],j+dir[t][1],vis);\\n    }\\n\\n    return sum+a[i][j];\\n\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    int val = explore(grid,  i,  j,vis);\\n                    if(max<val)max = val;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551393,
                "title": "bfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    void bfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>grid,int delrow[],int delcol[],int &sum) \\n    {\\n        vis[row][col]=1;   \\n        //int sum=0;\\n        queue<pair<int,int>>q; \\n        q.push({row,col});  \\n         sum+=grid[row][col];\\n        int n=grid.size(),m=grid[0].size(); \\n        while(!q.empty()) \\n        {\\n            int row=q.front().first; \\n            int col=q.front().second; \\n            q.pop();  \\n           \\n                   for(int i=0;i<4;i++){\\n                    int nrow=delrow[i]+row;\\n                    int ncol=delcol[i]+col; \\n                    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]!=0 && !vis[nrow][ncol]) \\n                    {\\n                        vis[nrow][ncol]=1; \\n                        sum+=grid[nrow][ncol]; \\n                        q.push({nrow,ncol});\\n                    }\\n                \\n            }\\n        } \\n     // return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) { \\n        if(grid.size()==1 && grid[0][0]==0 && grid[0].size()==1) \\n        return 0;\\n        int n=grid.size(),m=grid[0].size(); \\n        vector<vector<int>>vis(n,vector<int>(m,0)); \\n        int maxi=0,sum=0; \\n        int delrow[]={-1,0,1,0}; \\n         int delcol[]={0,1,0,-1};\\n        for(int row=0;row<n;row++) \\n        {\\n            for(int col=0;col<m;col++) \\n            {  \\n                if(!vis[row][col] && grid[row][col]!=0) \\n                {\\n                  bfs(row,col,vis,grid,delrow,delcol,sum);\\n                  maxi=max(sum,maxi); \\n                  sum=0;\\n                }\\n\\n            }\\n        }  \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    void bfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>grid,int delrow[],int delcol[],int &sum) \\n    {\\n        vis[row][col]=1;   \\n        //int sum=0;\\n        queue<pair<int,int>>q; \\n        q.push({row,col});  \\n         sum+=grid[row][col];\\n        int n=grid.size(),m=grid[0].size(); \\n        while(!q.empty()) \\n        {\\n            int row=q.front().first; \\n            int col=q.front().second; \\n            q.pop();  \\n           \\n                   for(int i=0;i<4;i++){\\n                    int nrow=delrow[i]+row;\\n                    int ncol=delcol[i]+col; \\n                    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]!=0 && !vis[nrow][ncol]) \\n                    {\\n                        vis[nrow][ncol]=1; \\n                        sum+=grid[nrow][ncol]; \\n                        q.push({nrow,ncol});\\n                    }\\n                \\n            }\\n        } \\n     // return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) { \\n        if(grid.size()==1 && grid[0][0]==0 && grid[0].size()==1) \\n        return 0;\\n        int n=grid.size(),m=grid[0].size(); \\n        vector<vector<int>>vis(n,vector<int>(m,0)); \\n        int maxi=0,sum=0; \\n        int delrow[]={-1,0,1,0}; \\n         int delcol[]={0,1,0,-1};\\n        for(int row=0;row<n;row++) \\n        {\\n            for(int col=0;col<m;col++) \\n            {  \\n                if(!vis[row][col] && grid[row][col]!=0) \\n                {\\n                  bfs(row,col,vis,grid,delrow,delcol,sum);\\n                  maxi=max(sum,maxi); \\n                  sum=0;\\n                }\\n\\n            }\\n        }  \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544967,
                "title": "dfs-c-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dim = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int dfs(vector<vector<int>>& grid,int r,int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0)\\n            return 0;\\n        int ans = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto a : dim){\\n            ans += dfs(grid,r + a[0],c + a[1]);\\n        }\\n        return ans;   \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i = 0;i < r;i++){\\n            for(int j = 0;j < c;j++){\\n                ans = max(ans,dfs(grid,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dim = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int dfs(vector<vector<int>>& grid,int r,int c){\\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size() || grid[r][c] == 0)\\n            return 0;\\n        int ans = grid[r][c];\\n        grid[r][c] = 0;\\n        for(auto a : dim){\\n            ans += dfs(grid,r + a[0],c + a[1]);\\n        }\\n        return ans;   \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        for(int i = 0;i < r;i++){\\n            for(int j = 0;j < c;j++){\\n                ans = max(ans,dfs(grid,i,j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516055,
                "title": "2658-maximum-number-of-fish-in-a-grid-java",
                "content": "```\\nclass Solution {\\n    public int dfs(int [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==0)\\n            return 0;\\n        int res=grid[i][j];\\n        grid[i][j]=0;\\n        res+=dfs(grid,i+1,j);\\n        res+=dfs(grid,i,j+1);\\n        res+=dfs(grid,i-1,j);\\n        res+=dfs(grid,i,j-1);\\n        return res;\\n    }\\n    \\n    public int findMaxFish(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length;i++)\\n        { \\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                  ans=Math.max(ans,dfs(grid,i,j));  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int dfs(int [][] grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==0)\\n            return 0;\\n        int res=grid[i][j];\\n        grid[i][j]=0;\\n        res+=dfs(grid,i+1,j);\\n        res+=dfs(grid,i,j+1);\\n        res+=dfs(grid,i-1,j);\\n        res+=dfs(grid,i,j-1);\\n        return res;\\n    }\\n    \\n    public int findMaxFish(int[][] grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.length;i++)\\n        { \\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                  ans=Math.max(ans,dfs(grid,i,j));  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488243,
                "title": "c-bfs-dfs-both-approaches",
                "content": "## DFS\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& csum){\\n        if (vis[i][j] || grid[i][j]==0)return;\\n        vis[i][j]=1;\\n        csum+= grid[i][j];\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,1,-1};\\n        for (int it=0; it<4; it++){\\n            int nr= dx[it]+i;\\n            int nc= dy[it]+j;\\n            if (nr>=0 && nc>=0 && nr<grid.size() && nc<grid[0].size())dfs(grid,vis,nr,nc,csum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int csum=0;\\n                    dfs(grid,vis,i,j,csum);\\n                    ans= max(ans,csum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## BFS\\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& curr){\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        curr+= grid[i][j];\\n        vis[i][j]=1;\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,-1,1};\\n        while (!q.empty()){\\n            int x= q.front().first;\\n            int y= q.front().second;\\n            q.pop();\\n            for (int it=0; it<4; it++){\\n                int nr= x+dx[it];\\n                int nc= y+dy[it];\\n                if (nc>=0 && nc<grid[0].size() && nr>=0 && nr<grid.size() && !vis[nr][nc] && grid[nr][nc]>0){\\n                    q.push({nr,nc});\\n                    curr+= grid[nr][nc];\\n                    vis[nr][nc]=1;\\n                }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int curr=0;\\n                    bfs(grid,vis,i,j,curr);\\n                    ans= max(ans,curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& csum){\\n        if (vis[i][j] || grid[i][j]==0)return;\\n        vis[i][j]=1;\\n        csum+= grid[i][j];\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,1,-1};\\n        for (int it=0; it<4; it++){\\n            int nr= dx[it]+i;\\n            int nc= dy[it]+j;\\n            if (nr>=0 && nc>=0 && nr<grid.size() && nc<grid[0].size())dfs(grid,vis,nr,nc,csum);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int csum=0;\\n                    dfs(grid,vis,i,j,csum);\\n                    ans= max(ans,csum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int& curr){\\n        queue<pair<int,int>> q;\\n        q.push({i,j});\\n        curr+= grid[i][j];\\n        vis[i][j]=1;\\n        int dx[]= {1,-1,0,0};\\n        int dy[]= {0,0,-1,1};\\n        while (!q.empty()){\\n            int x= q.front().first;\\n            int y= q.front().second;\\n            q.pop();\\n            for (int it=0; it<4; it++){\\n                int nr= x+dx[it];\\n                int nc= y+dy[it];\\n                if (nc>=0 && nc<grid[0].size() && nr>=0 && nr<grid.size() && !vis[nr][nc] && grid[nr][nc]>0){\\n                    q.push({nr,nc});\\n                    curr+= grid[nr][nc];\\n                    vis[nr][nc]=1;\\n                }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for (int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    int curr=0;\\n                    bfs(grid,vis,i,j,curr);\\n                    ans= max(ans,curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485575,
                "title": "god-level-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dirx{1,-1,0,0};\\n    vector<int> diry{0,0,1,-1};\\n    int solve(int x,int y,vector<vector<int>>& grid,vector<vector<bool>>& vis,int n,int m){\\n        \\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        vis[x][y]=true;\\n        int sum=0;\\n        \\n        while(!q.empty()){\\n            auto curr=q.front();\\n            int xx=curr.first;\\n            int yy=curr.second;\\n            sum+=grid[xx][yy];\\n            q.pop();\\n            \\n            for(int i=0;i<4;i++){\\n                int nx=xx+dirx[i];\\n                int ny=yy+diry[i];\\n                \\n                if(ny<0 || ny==m || nx<0 || nx==n || grid[nx][ny]==0 || vis[nx][ny]) continue;\\n                \\n                q.push({nx,ny});\\n                vis[nx][ny]=true;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int res=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 && !vis[i][j]){\\n                    int ans=solve(i,j,grid,vis,n,m);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dirx{1,-1,0,0};\\n    vector<int> diry{0,0,1,-1};\\n    int solve(int x,int y,vector<vector<int>>& grid,vector<vector<bool>>& vis,int n,int m){\\n        \\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        vis[x][y]=true;\\n        int sum=0;\\n        \\n        while(!q.empty()){\\n            auto curr=q.front();\\n            int xx=curr.first;\\n            int yy=curr.second;\\n            sum+=grid[xx][yy];\\n            q.pop();\\n            \\n            for(int i=0;i<4;i++){\\n                int nx=xx+dirx[i];\\n                int ny=yy+diry[i];\\n                \\n                if(ny<0 || ny==m || nx<0 || nx==n || grid[nx][ny]==0 || vis[nx][ny]) continue;\\n                \\n                q.push({nx,ny});\\n                vis[nx][ny]=true;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int res=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 && !vis[i][j]){\\n                    int ans=solve(i,j,grid,vis,n,m);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481241,
                "title": "c-bfs-graphs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(4*n*m)$$\\n\\n- Space complexity:$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int i, int j, int n, int m){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(!grid[i][j]){\\n                    v[i][j]=1;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j]){\\n                    v[i][j]=1;\\n                    int cnt=0;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        cnt+=grid[x][y];\\n                        q.pop();\\n                        int r[4]={-1, 1, 0, 0};\\n                        int c[4]={0, 0, 1, -1};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(valid(row, col, v.size(), v[0].size()) && !v[row][col]){\\n                                v[row][col]=1;\\n                                q.push({row, col});\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int i, int j, int n, int m){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(!grid[i][j]){\\n                    v[i][j]=1;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j]){\\n                    v[i][j]=1;\\n                    int cnt=0;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        cnt+=grid[x][y];\\n                        q.pop();\\n                        int r[4]={-1, 1, 0, 0};\\n                        int c[4]={0, 0, 1, -1};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(valid(row, col, v.size(), v[0].size()) && !v[row][col]){\\n                                v[row][col]=1;\\n                                q.push({row, col});\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans, cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471545,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple DFS with node sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We simply traverse whole grid and check if current cell is having value greater than 0 or not. \\n- If it has value greater than 0 we call a DFS function which provides us the sum of current node along with it\\'s adjacent cells in the grid (Four Directionally).\\n- It goes without saying that in our DFS function we must keep an eye upon whether the function call for the current indexes in the grid is out of grid boundaries or not.\\n- Along with this we also need to maintain the visited array inorder to avoid duplicate function calls.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. -->\\n$$O(m*n)$$\\nwhere m is number of rows and n is number of columns in the grid. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\nwhere m is number of rows and n is number of columns in the grid.\\n# Code\\nThe below code is self explanatory.\\n```\\nclass Solution {\\npublic:\\n    // Function to check out of boundary condition\\n    bool isSafe(int i,int j,int m, int n){\\n        if (i<0 or i>=m or j<0 or j>=n) return false;\\n        return true;\\n    }\\n    int solve(vector<vector<int>> &g, int i , int j, int m, int n, int &tmp, vector<vector<int>> &vis){\\n        // Check out of Boundary condition\\n        if (!isSafe(i,j,m,n)) return 0;\\n        if (g[i][j]==0) return 0;\\n        // If current cell is already visited return 0.\\n        if (vis[i][j]==1) return 0;\\n\\n        // mark current node as visited\\n        vis[i][j]=1;\\n        \\n        // add the value of current node\\n        tmp+= g[i][j];\\n        \\n        // call DFS for adjancent cells\\n        solve(g,i+1,j,m,n,tmp,vis);\\n        solve(g,i-1,j,m,n,tmp,vis);\\n        solve(g,i,j-1,m,n,tmp,vis);\\n        solve(g,i,j+1,m,n,tmp,vis);\\n        \\n        return tmp;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int ans=0, res=0;\\n        int m=g.size(), n=g[0].size();\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++){\\n                if (g[i][j]>0) \\n                {   int tmp=0;\\n                    ans=solve(g, i ,j ,m,n, tmp, vis);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to check out of boundary condition\\n    bool isSafe(int i,int j,int m, int n){\\n        if (i<0 or i>=m or j<0 or j>=n) return false;\\n        return true;\\n    }\\n    int solve(vector<vector<int>> &g, int i , int j, int m, int n, int &tmp, vector<vector<int>> &vis){\\n        // Check out of Boundary condition\\n        if (!isSafe(i,j,m,n)) return 0;\\n        if (g[i][j]==0) return 0;\\n        // If current cell is already visited return 0.\\n        if (vis[i][j]==1) return 0;\\n\\n        // mark current node as visited\\n        vis[i][j]=1;\\n        \\n        // add the value of current node\\n        tmp+= g[i][j];\\n        \\n        // call DFS for adjancent cells\\n        solve(g,i+1,j,m,n,tmp,vis);\\n        solve(g,i-1,j,m,n,tmp,vis);\\n        solve(g,i,j-1,m,n,tmp,vis);\\n        solve(g,i,j+1,m,n,tmp,vis);\\n        \\n        return tmp;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int ans=0, res=0;\\n        int m=g.size(), n=g[0].size();\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++){\\n                if (g[i][j]>0) \\n                {   int tmp=0;\\n                    ans=solve(g, i ,j ,m,n, tmp, vis);\\n                    res=max(res,ans);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468895,
                "title": "bfs-java-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        int visit[][]=new int[n][m];\\n        int delRow[]={0,0,-1,1};\\n        int delCol[]={1,-1,0,0};\\n        \\n        int ans[]={0};\\n        int max=0;\\n  \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visit[i][j]==0 && grid[i][j]!=0){\\n\\n                    bfs(i,j,grid,visit,ans,delRow,delCol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        \\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        int visit[][]=new int[n][m];\\n        int delRow[]={0,0,-1,1};\\n        int delCol[]={1,-1,0,0};\\n        \\n        int ans[]={0};\\n        int max=0;\\n  \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visit[i][j]==0 && grid[i][j]!=0){\\n\\n                    bfs(i,j,grid,visit,ans,delRow,delCol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468240,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/cea41f0c-e7be-4699-951b-5a0c9d475d8f_1682827066.2703393.png)\\n```\\n#define MAX(a,b) (a) > (b) ? (a) : (b)\\n\\nconst int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\nvoid dfs(int** grid, int r, int c, int rSize, int cSize, int* cnt) {\\n    if (r < 0 || r >= rSize || c < 0 || c >= cSize || grid[r][c] == 0) return;\\n    (*cnt) += grid[r][c];\\n    grid[r][c] = 0;\\n    for (int i = 0; i < 4; i++) {\\n        dfs(grid, r+dir[i][0], c+dir[i][1], rSize, cSize, cnt);\\n    }\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize) {\\n    int ans = 0, cnt = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] != 0) {\\n                dfs(grid, i, j, gridSize, gridColSize[i], &cnt);\\n                ans = MAX(ans, cnt);\\n                cnt = 0;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX(a,b) (a) > (b) ? (a) : (b)\\n\\nconst int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n\\nvoid dfs(int** grid, int r, int c, int rSize, int cSize, int* cnt) {\\n    if (r < 0 || r >= rSize || c < 0 || c >= cSize || grid[r][c] == 0) return;\\n    (*cnt) += grid[r][c];\\n    grid[r][c] = 0;\\n    for (int i = 0; i < 4; i++) {\\n        dfs(grid, r+dir[i][0], c+dir[i][1], rSize, cSize, cnt);\\n    }\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize) {\\n    int ans = 0, cnt = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] != 0) {\\n                dfs(grid, i, j, gridSize, gridColSize[i], &cnt);\\n                ans = MAX(ans, cnt);\\n                cnt = 0;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467612,
                "title": "easiest-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int vis[][]=new int [n][m];\\n        int delrow[]={0,0,-1,1};\\n        int delcol[]={1,-1,0,0};\\n        int ans[]={0};\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && grid[i][j]!=0){\\n                    bfs(i,j,grid,vis,ans,delrow,delcol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int vis[][]=new int [n][m];\\n        int delrow[]={0,0,-1,1};\\n        int delcol[]={1,-1,0,0};\\n        int ans[]={0};\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && grid[i][j]!=0){\\n                    bfs(i,j,grid,vis,ans,delrow,delcol);\\n                    max=Math.max(max,ans[0]);\\n                    ans[0]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    public void bfs(int i,int j,int[][] grid,int visit[][],int ans[],int delRow[],int delCol[]){\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(i,j));\\n        visit[i][j]=1;\\n        \\n        while(!q.isEmpty()){\\n            int row=q.peek().first;\\n            int col=q.peek().second;\\n            q.poll();\\n            ans[0]+=grid[row][col];\\n            for(int k=0;k<4;k++){\\n                int nrow=row+delRow[k];\\n                int ncol=col+delCol[k];\\n                \\n                \\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0 && visit[nrow][ncol]==0 && grid[nrow][ncol]!=0){\\n                    q.add(new Pair(nrow,ncol));\\n                    visit[nrow][ncol]=1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467563,
                "title": "java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxFish = 0;\\n        boolean [][]vis = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) { \\n                    maxFish = Math.max(maxFish, dfs(i, j,grid));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n      \\n       \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i<0 || i >= m || j < 0 || j >= n || grid[i][j] == 0){\\n            return 0;\\n        }\\n        int fish = grid[i][j]; \\n        grid[i][j] = 0;\\n        fish += dfs(i-1, j, grid);\\n        fish += dfs(i, j+1, grid);\\n        fish += dfs(i+1, j, grid);\\n        fish += dfs(i, j-1, grid);\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int maxFish = 0;\\n        boolean [][]vis = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 0) { \\n                    maxFish = Math.max(maxFish, dfs(i, j,grid));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int i, int j, int[][] grid) {\\n      \\n       \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i<0 || i >= m || j < 0 || j >= n || grid[i][j] == 0){\\n            return 0;\\n        }\\n        int fish = grid[i][j]; \\n        grid[i][j] = 0;\\n        fish += dfs(i-1, j, grid);\\n        fish += dfs(i, j+1, grid);\\n        fish += dfs(i+1, j, grid);\\n        fish += dfs(i, j-1, grid);\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467557,
                "title": "easy-to-understand-simple-and-easy-code-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int f(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis,int drow[],int dcol[]){\\n        vis[row][col]=1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         int x = 0 ;\\n         for(int i = 0 ; i < 4 ;i ++){\\n             int nrow = row + drow[i];\\n             int ncol = col + dcol[i];\\n             if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && grid[nrow][ncol] != 0 && !vis[nrow][ncol] ){\\n             x = x + grid[nrow][ncol] + f(nrow,ncol,grid,vis,drow,dcol);\\n             }\\n         }\\n         return x;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int drow[] = {0,-1,0,1};\\n        int dcol[] = {-1,0,1,0};\\n        int maxi = 0 ;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0 ;j < m ; j++){\\n                if(grid[i][j] > 0 ){\\n                int x = grid[i][j];\\n              int maxi1 = x + f(i,j,grid,vis,drow,dcol);\\n              maxi = max(maxi , maxi1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int f(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis,int drow[],int dcol[]){\\n        vis[row][col]=1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         int x = 0 ;\\n         for(int i = 0 ; i < 4 ;i ++){\\n             int nrow = row + drow[i];\\n             int ncol = col + dcol[i];\\n             if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && grid[nrow][ncol] != 0 && !vis[nrow][ncol] ){\\n             x = x + grid[nrow][ncol] + f(nrow,ncol,grid,vis,drow,dcol);\\n             }\\n         }\\n         return x;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int drow[] = {0,-1,0,1};\\n        int dcol[] = {-1,0,1,0};\\n        int maxi = 0 ;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0 ;j < m ; j++){\\n                if(grid[i][j] > 0 ){\\n                int x = grid[i][j];\\n              int maxi1 = x + f(i,j,grid,vis,drow,dcol);\\n              maxi = max(maxi , maxi1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467495,
                "title": "easy-dfs-soln-max-area-of-island",
                "content": "# Intuition\\nThis is similar to [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //x = exchange(a, b) --> x gets assigned with a & a is assiigned with b \\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\\n            return 0;\\n        }\\n        if(grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        return exchange(grid[i][j], 0) + f(i - 1, j, grid) + f(i, j - 1, grid) + f(i + 1, j, grid) + f(i, j + 1, grid);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    maxi = max(maxi, f(i, j, grid));\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //x = exchange(a, b) --> x gets assigned with a & a is assiigned with b \\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) {\\n            return 0;\\n        }\\n        if(grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        return exchange(grid[i][j], 0) + f(i - 1, j, grid) + f(i, j - 1, grid) + f(i + 1, j, grid) + f(i, j + 1, grid);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0) {\\n                    maxi = max(maxi, f(i, j, grid));\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467447,
                "title": "run-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = size(grid),m = size(grid[0]), fish = 0, t = 0;\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        auto isvalid = [&](int i,int j){return i>=0 && i<n && j>=0 && j<m;};\\n        vector<pair<int,int>> moves{{0,1},{0,-1},{1,0},{-1,0}};\\n        function<void(int,int)> dfs = [&](int i,int j){\\n            t += grid[i][j];\\n            vis[i][j] = true;\\n            for(auto&[u,v]: moves){\\n                int x = i + u, y = j + v;\\n                if(isvalid(x,y) && grid[x][y] && !vis[x][y])\\n                    dfs(x,y);\\n            }\\n        };\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] && !vis[i][j]){\\n                    t = 0;\\n                    dfs(i,j);\\n                    fish = max(fish,t);\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = size(grid),m = size(grid[0]), fish = 0, t = 0;\\n        vector<vector<bool>> vis(n,vector<bool>(m));\\n        auto isvalid = [&](int i,int j){return i>=0 && i<n && j>=0 && j<m;};\\n        vector<pair<int,int>> moves{{0,1},{0,-1},{1,0},{-1,0}};\\n        function<void(int,int)> dfs = [&](int i,int j){\\n            t += grid[i][j];\\n            vis[i][j] = true;\\n            for(auto&[u,v]: moves){\\n                int x = i + u, y = j + v;\\n                if(isvalid(x,y) && grid[x][y] && !vis[x][y])\\n                    dfs(x,y);\\n            }\\n        };\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] && !vis[i][j]){\\n                    t = 0;\\n                    dfs(i,j);\\n                    fish = max(fish,t);\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467349,
                "title": "dfs-c-solution-with-detailed-explanation",
                "content": "\\n# Approach\\nSo, basically this question can be solved using both BFS and DFS. I have solved this using DFS/recursion.\\nFirstly, I have declared a visited matrix with all indices marked -1.\\nNow, its given in question that if grid[i][j]=0 its land otherwise its number of fishes. \\nSo, for 1st recursion call value of grid[i][j] should be >0. In the reursion function first marked the vis[i][j]=0.\\nNow, we have 4 ways(as mentioned in question) in which we can move, so declared two arrays dr and dc with all 4 conditions/ways. We will traverse through grid with conditions.\\nIn this way this will mark all the visited indices as 0 and if the grid is not valid it won\\'t adding the number of fishes to c and return the value of c to main function. So in main function the value is compared with a max variable and the maximum is returened.\\nThank You and hope u understand my solution.\\nOpen for quries.\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int c=0;\\n    void rec(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n        vis[i][j]=0;\\n        \\n        int dr[4]={-1, 0, 1, 0};\\n        int dc[4]={0, -1, 0, 1};\\n        \\n        for(int k=0; k<4; k++){\\n            int nr= dr[k]+i;\\n            int nc= dc[k]+j;\\n            \\n            if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]>0 && vis[nr][nc]==-1){\\n                c+=grid[nr][nc];\\n                rec(nr, nc, n, m, grid, vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                 c=0;\\n                if(grid[i][j]>0 && vis[i][j]==-1){\\n                    c+=grid[i][j];\\n                    rec(i, j, n, m, grid, vis);\\n                    maxi= max(maxi, c);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c=0;\\n    void rec(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n        vis[i][j]=0;\\n        \\n        int dr[4]={-1, 0, 1, 0};\\n        int dc[4]={0, -1, 0, 1};\\n        \\n        for(int k=0; k<4; k++){\\n            int nr= dr[k]+i;\\n            int nc= dc[k]+j;\\n            \\n            if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]>0 && vis[nr][nc]==-1){\\n                c+=grid[nr][nc];\\n                rec(nr, nc, n, m, grid, vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                 c=0;\\n                if(grid[i][j]>0 && vis[i][j]==-1){\\n                    c+=grid[i][j];\\n                    rec(i, j, n, m, grid, vis);\\n                    maxi= max(maxi, c);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467310,
                "title": "easy-explanation-beginner-friendly",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint fun(int row, int col, vector<vector<int>> &vec)\\n\\t\\t{\\n\\t\\t\\tint n = vec.size();\\n\\t\\t\\tint m = vec[0].size();\\n\\t\\t\\tint score = vec[row][col];\\n\\t\\t\\tvec[row][col] = 0;\\n\\n\\t\\t\\tint rt[] = {0, -1, 0, 1};\\n\\t\\t\\tint ct[] = {-1, 0, 1, 0};\\n\\n\\n\\t\\t\\tfor(int i = 0; i < 4; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint r = row + rt[i];\\n\\t\\t\\t\\tint c = col + ct[i];\\n\\n\\t\\t\\t\\tif(r >= 0 && r < n && c >= 0 && c < m && vec[r][c] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscore = score + fun(r, c, vec);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn score;\\n\\t\\t}\\n\\n\\n\\n\\t\\tint findMaxFish(vector<vector<int>>& grid) \\n\\t\\t{\\n\\t\\t\\tint score = 0;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tint m = grid[0].size();\\n\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j = 0; j < m; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvector<vector<int>> vec = grid;\\n\\t\\t\\t\\t\\tif(grid[i][j] != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tscore = max(score, fun(i, j, vec));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn score;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint fun(int row, int col, vector<vector<int>> &vec)\\n\\t\\t{\\n\\t\\t\\tint n = vec.size();\\n\\t\\t\\tint m = vec[0].size();\\n\\t\\t\\tint score = vec[row][col];\\n\\t\\t\\tvec[row][col] = 0;\\n\\n\\t\\t\\tint rt[] = {0, -1, 0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 3467296,
                "title": "python-bfs-easy-explained",
                "content": "# Intuition\\nIt is same as a standard bfs count problem just the few optimisations are:\\nadding all zeroes to visited as we dont want to vist them (fisherman cant go there)\\nif u already visited another cell while traversing from current cell no need to visit that cell again as it will carry the same value.\\nreturn the max fish caught from a particular cell.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        visited = {(i, j) for i in range(ROWS) for j in range(COLS) if grid[i][j] <= 0}\\n\\n        def catch_fish(i, j):\\n            q = deque()\\n            fish = grid[i][j]\\n            visited.add((i, j))\\n            q.append((i, j))\\n            while q:\\n                curr_row, curr_col = q.popleft()\\n                for dr, dc in directions:\\n                    r, c = curr_row + dr, curr_col + dc\\n                    if (r, c) not in visited and 0 <= r < ROWS and 0 <= c < COLS and grid[r][c] > 0:\\n                        fish += grid[r][c]\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n            return fish\\n\\n        max_fish = 0\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if (i, j) not in visited and grid[i][j] > 0:\\n                    fish_count = catch_fish(i, j)\\n                    max_fish = max(max_fish, fish_count)\\n        return max_fish\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        visited = {(i, j) for i in range(ROWS) for j in range(COLS) if grid[i][j] <= 0}\\n\\n        def catch_fish(i, j):\\n            q = deque()\\n            fish = grid[i][j]\\n            visited.add((i, j))\\n            q.append((i, j))\\n            while q:\\n                curr_row, curr_col = q.popleft()\\n                for dr, dc in directions:\\n                    r, c = curr_row + dr, curr_col + dc\\n                    if (r, c) not in visited and 0 <= r < ROWS and 0 <= c < COLS and grid[r][c] > 0:\\n                        fish += grid[r][c]\\n                        visited.add((r, c))\\n                        q.append((r, c))\\n            return fish\\n\\n        max_fish = 0\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if (i, j) not in visited and grid[i][j] > 0:\\n                    fish_count = catch_fish(i, j)\\n                    max_fish = max(max_fish, fish_count)\\n        return max_fish\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467276,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0 int btts(int i,int j,vector<vector<int>>& grid){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 queue<pair<int,int>>que;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<vector<int>>vis(n,vector<int>(m,0));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[i][j] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({i,j});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int drow[] = {-1,0,1,0,-1};\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int maxi = INT_MIN;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(!que.empty()){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int row = que.front().first;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int col = que.front().second;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.pop();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum+= grid[row][col];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<4;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int nrow = row+drow[i];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ncol = col+drow[i+1];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol] != 0 && !vis[nrow][ncol]){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({nrow,ncol});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[nrow][ncol] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return sum;\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0 int findMaxFish(vector<vector<int>>& grid) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ans = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<n;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int j=0;j<m;j++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(grid[i][j] > 0){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 ans = max(ans,btts(i,j,grid));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return ans;\\n\\xA0\\xA0\\xA0 }\\n};\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0 int btts(int i,int j,vector<vector<int>>& grid){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 queue<pair<int,int>>que;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vector<vector<int>>vis(n,vector<int>(m,0));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[i][j] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({i,j});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int drow[] = {-1,0,1,0,-1};\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int maxi = INT_MIN;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(!que.empty()){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int row = que.front().first;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int col = que.front().second;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.pop();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum+= grid[row][col];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<4;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int nrow = row+drow[i];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ncol = col+drow[i+1];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol] != 0 && !vis[nrow][ncol]){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 que.push({nrow,ncol});\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 vis[nrow][ncol] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return sum;\\n\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0 int findMaxFish(vector<vector<int>>& grid) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int ans = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = grid.size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int m = grid[0].size();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int i=0;i<n;i++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for(int j=0;j<m;j++){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if(grid[i][j] > 0){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 ans = max(ans,btts(i,j,grid));\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return ans;\\n\\xA0\\xA0\\xA0 }\\n};\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467210,
                "title": "simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j] == 0 || grid[i][j] == -1) return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=-1;\\n        ans+= f(i+1,j, grid)+ f(i-1,j,grid)+ f(i, j-1,grid)+ f(i,j+1, grid);\\n        return ans;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                ans= max(ans, f(i, j, grid));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int f(int i, int j, vector<vector<int>>& grid) {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j] == 0 || grid[i][j] == -1) return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=-1;\\n        ans+= f(i+1,j, grid)+ f(i-1,j,grid)+ f(i, j-1,grid)+ f(i,j+1, grid);\\n        return ans;\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) {\\n                ans= max(ans, f(i, j, grid));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467048,
                "title": "simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee the fish in cell take these and search for neighbour cell and take maximum whenever leaving the grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEnter in a cell where grid[row][col]!=-1\\nand search in neighbours cell using bfs whenever leaving that particular cell add this to our fish variable and  put it equal to zero i.e grid[row][col]=0\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int dx[4]={1,-1,0,0};\\n     int dy[4]={0,0,1,-1};\\n     int find(int i,int j,vector<vector<int>>& grid,int m,int n)\\n     {\\n         int fish=0;\\n         queue<pair<int,int>> q;\\n         q.push({i,j});\\n         while(!q.empty())\\n         {\\n             int x=q.front().first;\\n             int y=q.front().second;\\n             q.pop();\\n             fish+=grid[x][y];\\n             grid[x][y]=0;\\n             for(int k=0;k<4;k++)\\n             {\\n                 if(x+dx[k] >=0 && x+dx[k] <m && y+dy[k]>=0 && y+dy[k]<n && grid[x+dx[k]][y+dy[k]]!=0)\\n                 {\\n                     q.push({x+dx[k],y+dy[k]});\\n                 }\\n             }\\n             \\n         }\\n         return fish;\\n     }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int fish=find(i,j,grid,m,n);\\n                    ans=max(ans,fish);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int dx[4]={1,-1,0,0};\\n     int dy[4]={0,0,1,-1};\\n     int find(int i,int j,vector<vector<int>>& grid,int m,int n)\\n     {\\n         int fish=0;\\n         queue<pair<int,int>> q;\\n         q.push({i,j});\\n         while(!q.empty())\\n         {\\n             int x=q.front().first;\\n             int y=q.front().second;\\n             q.pop();\\n             fish+=grid[x][y];\\n             grid[x][y]=0;\\n             for(int k=0;k<4;k++)\\n             {\\n                 if(x+dx[k] >=0 && x+dx[k] <m && y+dy[k]>=0 && y+dy[k]<n && grid[x+dx[k]][y+dy[k]]!=0)\\n                 {\\n                     q.push({x+dx[k],y+dy[k]});\\n                 }\\n             }\\n             \\n         }\\n         return fish;\\n     }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(),n=grid[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int fish=find(i,j,grid,m,n);\\n                    ans=max(ans,fish);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466944,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i,j):\\n            visited.add((i, j))\\n           \\n            self.fish += grid[i][j]\\n            for r,c in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                new_r = r + i\\n                new_c = c + j\\n                if 0 <= new_r < m and 0 <= new_c < n and (new_r, new_c) not in visited and grid[new_r][new_c] != 0:\\n                    dfs(new_r, new_c)\\n                \\n            \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n        self.fish = 0\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in visited:\\n                    self.fish = 0\\n                    dfs(i,j)\\n                    ans = max(self.fish, ans)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i,j):\\n            visited.add((i, j))\\n           \\n            self.fish += grid[i][j]\\n            for r,c in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                new_r = r + i\\n                new_c = c + j\\n                if 0 <= new_r < m and 0 <= new_c < n and (new_r, new_c) not in visited and grid[new_r][new_c] != 0:\\n                    dfs(new_r, new_c)\\n                \\n            \\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        ans = 0\\n        self.fish = 0\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in visited:\\n                    self.fish = 0\\n                    dfs(i,j)\\n                    ans = max(self.fish, ans)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466898,
                "title": "easy-dfs-solution-o-n-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn find_max_fish(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n\\n        for i in 0..grid.len() {\\n            for j in 0..grid[0].len() {\\n                if grid[i][j] > 0 {\\n                    ans = ans.max(dfs(&mut grid, i, j));\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\nfn dfs(grid: &mut Vec<Vec<i32>>, i: usize, j: usize) -> i32 {\\n    if i >= grid.len() || j >= grid[0].len() || grid[i][j] == 0 { return 0 };\\n    let val = grid[i][j];\\n    grid[i][j] = 0;\\n\\n    dfs(grid, i + 1, j) +\\n    dfs(grid, i - 1, j) +\\n    dfs(grid, i, j + 1) +\\n    dfs(grid, i, j - 1) + val\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_max_fish(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut ans = 0;\\n\\n        for i in 0..grid.len() {\\n            for j in 0..grid[0].len() {\\n                if grid[i][j] > 0 {\\n                    ans = ans.max(dfs(&mut grid, i, j));\\n                }\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n\\nfn dfs(grid: &mut Vec<Vec<i32>>, i: usize, j: usize) -> i32 {\\n    if i >= grid.len() || j >= grid[0].len() || grid[i][j] == 0 { return 0 };\\n    let val = grid[i][j];\\n    grid[i][j] = 0;\\n\\n    dfs(grid, i + 1, j) +\\n    dfs(grid, i - 1, j) +\\n    dfs(grid, i, j + 1) +\\n    dfs(grid, i, j - 1) + val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466870,
                "title": "c-dfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& g, vector<vector<bool>>& vis){\\n      if(min(r, c) < 0 or r >= g.size() or c >= g[0].size() or vis[r][c] or g[r][c] == 0) return 0;\\n      vis[r][c] = true;\\n      int x = dfs(r + 1, c, g, vis);\\n      int y = dfs(r, c + 1, g, vis);\\n      int z = dfs(r - 1, c, g, vis);\\n      int w = dfs(r, c - 1, g, vis);\\n      return g[r][c] + x + y + z + w;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n      int ans = 0, m = g.size(), n = g[0].size();\\n      vector<vector<bool>> vis(m, vector<bool>(n, false));\\n      for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n          if(g[i][j] > 0 and !vis[i][j]) \\n            ans = max(ans, dfs(i, j, g, vis));\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& g, vector<vector<bool>>& vis){\\n      if(min(r, c) < 0 or r >= g.size() or c >= g[0].size() or vis[r][c] or g[r][c] == 0) return 0;\\n      vis[r][c] = true;\\n      int x = dfs(r + 1, c, g, vis);\\n      int y = dfs(r, c + 1, g, vis);\\n      int z = dfs(r - 1, c, g, vis);\\n      int w = dfs(r, c - 1, g, vis);\\n      return g[r][c] + x + y + z + w;\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n      int ans = 0, m = g.size(), n = g[0].size();\\n      vector<vector<bool>> vis(m, vector<bool>(n, false));\\n      for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n          if(g[i][j] > 0 and !vis[i][j]) \\n            ans = max(ans, dfs(i, j, g, vis));\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466805,
                "title": "why-not-dp",
                "content": "Can\\'t we use dp in this problem (wasted 1 hour)?\\uD83E\\uDD14\\n\\nwhy we can not apply dp here anyone please.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Can\\'t we use dp in this problem (wasted 1 hour)?\\uD83E\\uDD14\\n\\nwhy we can not apply dp here anyone please.",
                "codeTag": "Unknown"
            },
            {
                "id": 3466773,
                "title": "dfs-brute-force-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(mn4^(mn))\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n const int dx[4] = {1, 0, -1, 0};\\n const int dy[4] = {0, 1, 0, -1};\\n\\n int dfs(vector<vector<int>>& grid, int x, int y) {\\n    int ans1 = 0;\\n    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] <= 0) {\\n        return ans1;\\n    }\\n    ans1 += grid[x][y]; \\n    grid[x][y] = -grid[x][y]; \\n    for (int i = 0; i < 4; i++) { \\n        int nx = x + dx[i], ny = y + dy[i];\\n        ans1 += dfs(grid, nx, ny);\\n    }\\n    return ans1;\\n}\\n int findMaxFish(vector<vector<int>>& grid) {\\n    int ans = 0;\\n    for (int x = 0; x < grid.size(); x++) {\\n        for (int y = 0; y < grid[0].size(); y++) {\\n            if (grid[x][y] > 0) {\\n                ans = max(ans, dfs(grid, x, y));\\n            }\\n        }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n const int dx[4] = {1, 0, -1, 0};\\n const int dy[4] = {0, 1, 0, -1};\\n\\n int dfs(vector<vector<int>>& grid, int x, int y) {\\n    int ans1 = 0;\\n    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] <= 0) {\\n        return ans1;\\n    }\\n    ans1 += grid[x][y]; \\n    grid[x][y] = -grid[x][y]; \\n    for (int i = 0; i < 4; i++) { \\n        int nx = x + dx[i], ny = y + dy[i];\\n        ans1 += dfs(grid, nx, ny);\\n    }\\n    return ans1;\\n}\\n int findMaxFish(vector<vector<int>>& grid) {\\n    int ans = 0;\\n    for (int x = 0; x < grid.size(); x++) {\\n        for (int y = 0; y < grid[0].size(); y++) {\\n            if (grid[x][y] > 0) {\\n                ans = max(ans, dfs(grid, x, y));\\n            }\\n        }\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466739,
                "title": "easy-clean-best-c-code-dfs",
                "content": "# Code\\n## PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int maxi=0,ans=0;\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    vector<int> dx={1,-1,0,0};\\n    vector<int> dy={0,0,1,-1};\\n    void DFS(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k],y=j+dy[k];\\n            if(isValid(x,y,m,n) && grid[x][y])\\n                DFS(grid,x,y,m,n);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    DFS(grid,i,j,m,n);\\n                    maxi=max(maxi,ans);\\n                    ans=0;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi=0,ans=0;\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    vector<int> dx={1,-1,0,0};\\n    vector<int> dy={0,0,1,-1};\\n    void DFS(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k],y=j+dy[k];\\n            if(isValid(x,y,m,n) && grid[x][y])\\n                DFS(grid,x,y,m,n);\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    DFS(grid,i,j,m,n);\\n                    maxi=max(maxi,ans);\\n                    ans=0;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466712,
                "title": "dart-recursive-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    int result = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n      for (int j = 0; j < grid[i].length; j++) {\\n        if (grid[i][j] != 0) {\\n          final tempResult = traverseRecurr(grid, i, j);\\n          result = tempResult > result ? tempResult : result;\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n   int traverseRecurr(List<List<int>> grid, i, j) {\\n    if (\\n       i < grid.length \\n    && i >= 0 \\n    && j < grid[i].length \\n    && j >= 0\\n    ) {\\n      if (grid[i][j] == 0) {\\n        return 0;\\n      }\\n      int result = grid[i][j];\\n      grid[i][j] = 0;\\n      result += traverseRecurr(grid, i - 1, j);\\n      result += traverseRecurr(grid, i + 1, j);\\n      result += traverseRecurr(grid, i, j + 1);\\n      result += traverseRecurr(grid, i, j - 1);\\n      return result;\\n    } else {\\n      return 0;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    int result = 0;\\n    for (int i = 0; i < grid.length; i++) {\\n      for (int j = 0; j < grid[i].length; j++) {\\n        if (grid[i][j] != 0) {\\n          final tempResult = traverseRecurr(grid, i, j);\\n          result = tempResult > result ? tempResult : result;\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n   int traverseRecurr(List<List<int>> grid, i, j) {\\n    if (\\n       i < grid.length \\n    && i >= 0 \\n    && j < grid[i].length \\n    && j >= 0\\n    ) {\\n      if (grid[i][j] == 0) {\\n        return 0;\\n      }\\n      int result = grid[i][j];\\n      grid[i][j] = 0;\\n      result += traverseRecurr(grid, i - 1, j);\\n      result += traverseRecurr(grid, i + 1, j);\\n      result += traverseRecurr(grid, i, j + 1);\\n      result += traverseRecurr(grid, i, j - 1);\\n      return result;\\n    } else {\\n      return 0;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466700,
                "title": "python-bfs",
                "content": "```python\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def bfs(y, x):\\n            q = deque([(y, x)])\\n            v = set([(y, x)])\\n            m = 0\\n            \\n            while q:\\n                y, x = q.popleft()\\n                m += grid[y][x]\\n\\n                for y, x in ((y, x + 1), (y, x - 1), (y + 1, x), (y - 1, x)):\\n                    if not (0 <= y < h and 0 <= x < w):\\n                        continue\\n                    if grid[y][x] == 0:\\n                        continue\\n                    if (y, x) in v:\\n                        continue\\n                    v.add((y, x))\\n                    q.append((y, x))\\n\\n            return m\\n\\n        m, h, w = 0, len(grid), len(grid[0])\\n\\n        for y in range(h):\\n            for x in range(w):\\n                if grid[y][x] > 0:\\n                    m = max(m, bfs(y, x))\\n\\n        return m\\n```\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        def bfs(y, x):\\n            q = deque([(y, x)])\\n            v = set([(y, x)])\\n            m = 0\\n            \\n            while q:\\n                y, x = q.popleft()\\n                m += grid[y][x]\\n\\n                for y, x in ((y, x + 1), (y, x - 1), (y + 1, x), (y - 1, x)):\\n                    if not (0 <= y < h and 0 <= x < w):\\n                        continue\\n                    if grid[y][x] == 0:\\n                        continue\\n                    if (y, x) in v:\\n                        continue\\n                    v.add((y, x))\\n                    q.append((y, x))\\n\\n            return m\\n\\n        m, h, w = 0, len(grid), len(grid[0])\\n\\n        for y in range(h):\\n            for x in range(w):\\n                if grid[y][x] > 0:\\n                    m = max(m, bfs(y, x))\\n\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466687,
                "title": "maximize-sum-of-islands",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y, vector<vector<int>>& grid)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(x>=0 && x<m && y>=0 && y<n) return true;\\n        return false;\\n    }\\n    \\n    int bfs(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& vis)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        int sum=grid[x][y];\\n        vis[x][y]=1;\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            \\n            int i=p.first;\\n            int j=p.second;\\n                if(isvalid(i+1,j,grid) && grid[i+1][j]!=0 && vis[i+1][j]==0)\\n                {\\n                    vis[i+1][j]=1;\\n                    sum+=grid[i+1][j];\\n                    q.push({i+1,j});\\n                }\\n                if(isvalid(i-1,j,grid) && grid[i-1][j]!=0 && vis[i-1][j]==0)\\n                {\\n                    vis[i-1][j]=1;\\n                    sum+=grid[i-1][j];\\n                    q.push({i-1,j});\\n                }\\n                if(isvalid(i,j+1,grid) && grid[i][j+1]!=0 && vis[i][j+1]==0)\\n                {\\n                    vis[i][j+1]=1;\\n                    sum+=grid[i][j+1];\\n                    q.push({i,j+1});\\n                }\\n                if(isvalid(i,j-1,grid) && grid[i][j-1]!=0 && vis[i][j-1]==0)\\n                {\\n                    vis[i][j-1]=1;\\n                    sum+=grid[i][j-1];\\n                    q.push({i,j-1});\\n                }\\n            //vis[i][j]=1;\\n        }\\n        return sum;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !vis[i][j])\\n                {\\n                    ans=max(ans,bfs(i,j,grid,vis));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y, vector<vector<int>>& grid)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(x>=0 && x<m && y>=0 && y<n) return true;\\n        return false;\\n    }\\n    \\n    int bfs(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& vis)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({x,y});\\n        int sum=grid[x][y];\\n        vis[x][y]=1;\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            \\n            int i=p.first;\\n            int j=p.second;\\n                if(isvalid(i+1,j,grid) && grid[i+1][j]!=0 && vis[i+1][j]==0)\\n                {\\n                    vis[i+1][j]=1;\\n                    sum+=grid[i+1][j];\\n                    q.push({i+1,j});\\n                }\\n                if(isvalid(i-1,j,grid) && grid[i-1][j]!=0 && vis[i-1][j]==0)\\n                {\\n                    vis[i-1][j]=1;\\n                    sum+=grid[i-1][j];\\n                    q.push({i-1,j});\\n                }\\n                if(isvalid(i,j+1,grid) && grid[i][j+1]!=0 && vis[i][j+1]==0)\\n                {\\n                    vis[i][j+1]=1;\\n                    sum+=grid[i][j+1];\\n                    q.push({i,j+1});\\n                }\\n                if(isvalid(i,j-1,grid) && grid[i][j-1]!=0 && vis[i][j-1]==0)\\n                {\\n                    vis[i][j-1]=1;\\n                    sum+=grid[i][j-1];\\n                    q.push({i,j-1});\\n                }\\n            //vis[i][j]=1;\\n        }\\n        return sum;\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>vis(grid.size(),vector<int>(grid[0].size(),0));\\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !vis[i][j])\\n                {\\n                    ans=max(ans,bfs(i,j,grid,vis));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466672,
                "title": "easiest-solution-ever",
                "content": "```\\nvoid solve(int i, int j, vector<vector<int>>& g, int &ans, vector<vector<bool>>& vis)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size())\\n            return;\\n        \\n        if(vis[i][j] || (g[i][j]==0))\\n            return;\\n        \\n        vis[i][j] = true;\\n        ans += g[i][j];\\n        \\n        solve(i+1, j, g, ans, vis);\\n        solve(i, j+1, g, ans, vis);\\n        solve(i-1, j, g, ans, vis);\\n        solve(i, j-1, g, ans, vis);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int r = g.size(), c = g[0].size();\\n        int mx = 0;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(g[i][j]==0)\\n                    continue;\\n                \\n                if(vis[i][j]==true)\\n                    continue;\\n                \\n                int ans = 0;\\n                solve(i, j, g, ans, vis);\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid solve(int i, int j, vector<vector<int>>& g, int &ans, vector<vector<bool>>& vis)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size())\\n            return;\\n        \\n        if(vis[i][j] || (g[i][j]==0))\\n            return;\\n        \\n        vis[i][j] = true;\\n        ans += g[i][j];\\n        \\n        solve(i+1, j, g, ans, vis);\\n        solve(i, j+1, g, ans, vis);\\n        solve(i-1, j, g, ans, vis);\\n        solve(i, j-1, g, ans, vis);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        int r = g.size(), c = g[0].size();\\n        int mx = 0;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(g[i][j]==0)\\n                    continue;\\n                \\n                if(vis[i][j]==true)\\n                    continue;\\n                \\n                int ans = 0;\\n                solve(i, j, g, ans, vis);\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466647,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    void dfs(vector<vector<int>> &grid,int i,int j,int &temp,vector<vector<int>>&vis){\\n        if(i<0||i>=n||j<0||j>=m) return;\\n        vis[i][j] = 1;\\n        temp += grid[i][j];\\n        int a[] = {1,0,-1,0};\\n        int b[] = {0,1,0,-1};\\n        for(int x=0;x<4;x++){\\n            if(i+a[x]>=0 && i+a[x]<n && j+b[x]>=0 && j+b[x]<m && !vis[i+a[x]][j+b[x]] && grid[i+a[x]][j+b[x]]){\\n                dfs(grid,i+a[x],j+b[x],temp,vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    int temp=0;\\n                    dfs(grid,i,j,temp,vis);\\n                    if(ans<temp) ans = temp;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    void dfs(vector<vector<int>> &grid,int i,int j,int &temp,vector<vector<int>>&vis){\\n        if(i<0||i>=n||j<0||j>=m) return;\\n        vis[i][j] = 1;\\n        temp += grid[i][j];\\n        int a[] = {1,0,-1,0};\\n        int b[] = {0,1,0,-1};\\n        for(int x=0;x<4;x++){\\n            if(i+a[x]>=0 && i+a[x]<n && j+b[x]>=0 && j+b[x]<m && !vis[i+a[x]][j+b[x]] && grid[i+a[x]][j+b[x]]){\\n                dfs(grid,i+a[x],j+b[x],temp,vis);\\n            }\\n        }\\n    }\\n    \\n    int findMaxFish(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    int temp=0;\\n                    dfs(grid,i,j,temp,vis);\\n                    if(ans<temp) ans = temp;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097424,
                "title": "easy-c-solution-dfs",
                "content": "\\n```\\n#define max(a, b) (a > b ? a : b)\\n\\nvoid helper (int i, int j, int m, int n, int *sum, int *ans, int** grid) {\\n    *ans = max (*ans, *sum);\\n\\n    if (i < 0 || j < 0 || i >= m || j >= n || !grid[i][j])\\n        return;\\n\\n    *sum += grid[i][j];\\n    grid[i][j] = 0;\\n\\n    if (i + 1 < m) helper (i + 1, j, m, n, sum, ans, grid);\\n    if (i - 1 >= 0) helper (i - 1, j, m, n, sum, ans, grid);\\n    if (j + 1 < n) helper (i, j + 1, m, n, sum, ans, grid);\\n    if (j - 1 >= 0) helper (i, j - 1, m, n, sum, ans, grid);\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1 && *gridColSize == 1)\\n        return grid[0][0];\\n        \\n    int m = gridSize, n = *gridColSize, i, j, sum = 0, ans = 0;\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++){\\n            if (grid[i][j]) {\\n                sum = 0;\\n                helper(i, j, m, n, &sum, &ans, grid);\\n            }\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define max(a, b) (a > b ? a : b)\\n\\nvoid helper (int i, int j, int m, int n, int *sum, int *ans, int** grid) {\\n    *ans = max (*ans, *sum);\\n\\n    if (i < 0 || j < 0 || i >= m || j >= n || !grid[i][j])\\n        return;\\n\\n    *sum += grid[i][j];\\n    grid[i][j] = 0;\\n\\n    if (i + 1 < m) helper (i + 1, j, m, n, sum, ans, grid);\\n    if (i - 1 >= 0) helper (i - 1, j, m, n, sum, ans, grid);\\n    if (j + 1 < n) helper (i, j + 1, m, n, sum, ans, grid);\\n    if (j - 1 >= 0) helper (i, j - 1, m, n, sum, ans, grid);\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    if (gridSize == 1 && *gridColSize == 1)\\n        return grid[0][0];\\n        \\n    int m = gridSize, n = *gridColSize, i, j, sum = 0, ans = 0;\\n\\n    for (i = 0; i < m; i++) {\\n        for (j = 0; j < n; j++){\\n            if (grid[i][j]) {\\n                sum = 0;\\n                helper(i, j, m, n, &sum, &ans, grid);\\n            }\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097360,
                "title": "simple-bfs-solution-easy-to-understand",
                "content": "# Intuition\\n\\nIn solving the question we just use the simple bfs algo.\\nRead the code you will understand it.\\n\\n# Approach\\nwe make queue which keep the a pair of elements first the value of the grid value and other values are the row and column respectively.\\nThen check that if  nrow and ncol are not going outside the grid and not visited and the grid is having a fish.\\nthen finding the max. from the possible value.\\nand at last return it maximum value.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maxi=0;\\n    void bfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis, int delrow[],int delcol[],int &sum){\\n        \\n        vis[row][col]=1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({grid[row][col],{row,col}});\\n        while(!q.empty()){\\n            int n=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            sum+=n;\\n            for(int i=0; i<4; i++){\\n            int nrow=x+delrow[i];\\n            int ncol=y+delcol[i];\\n     if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol]>0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                q.push({grid[nrow][ncol],{nrow,ncol}});\\n            }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int delrow[]={-1,0,1,0};\\n        int delcol[]={0,-1,0,1};\\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n\\n                if(grid[i][j]>0 && vis[i][j]==0){\\n                    int sum=0;\\n                    bfs(i,j,grid,vis,delrow,delcol,sum);\\n\\n                    maxi=max(maxi,sum);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxi=0;\\n    void bfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& vis, int delrow[],int delcol[],int &sum){\\n        \\n        vis[row][col]=1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({grid[row][col],{row,col}});\\n        while(!q.empty()){\\n            int n=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            sum+=n;\\n            for(int i=0; i<4; i++){\\n            int nrow=x+delrow[i];\\n            int ncol=y+delcol[i];\\n     if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[nrow][ncol]>0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                q.push({grid[nrow][ncol],{nrow,ncol}});\\n            }\\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        \\n        int delrow[]={-1,0,1,0};\\n        int delcol[]={0,-1,0,1};\\n        vector<vector<int>> vis(grid.size(),vector<int>(grid[0].size(),0));\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n\\n                if(grid[i][j]>0 && vis[i][j]==0){\\n                    int sum=0;\\n                    bfs(i,j,grid,vis,delrow,delcol,sum);\\n\\n                    maxi=max(maxi,sum);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090243,
                "title": "c-easy-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int nrow = row + prerow[i];\\n            int ncol = col + precol[i];\\n            if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && visited[nrow][ncol] == 0 && grid[nrow][ncol] > 0)\\n            {\\n                res += dfs(grid, visited, nrow, ncol);\\n            }\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector <int>> visited(grid.size(), vector <int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, dfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int nrow = row + prerow[i];\\n            int ncol = col + precol[i];\\n            if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && visited[nrow][ncol] == 0 && grid[nrow][ncol] > 0)\\n            {\\n                res += dfs(grid, visited, nrow, ncol);\\n            }\\n        }\\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector <int>> visited(grid.size(), vector <int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, dfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090209,
                "title": "c-easy-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n\\n        while(q.empty() == false)\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + prerow[i];\\n                int ncol = col + precol[i];\\n\\n                if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && grid[nrow][ncol] > 0 && visited[nrow][ncol] == 0){\\n                    q.push({nrow, ncol});\\n                    res += grid[nrow][ncol];\\n                    visited[nrow][ncol] = 1;\\n                }\\n            }\\n        }\\n         \\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, bfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector <vector<int>> &grid, vector<vector<int>> &visited, int row, int col)\\n    {\\n        visited[row][col] = 1;\\n        queue <pair<int, int>> q;\\n        q.push({row, col});\\n        int prerow[] = {-1, 0, 1, 0};\\n        int precol[] = {0, -1, 0, 1};\\n        int res = grid[row][col];\\n\\n        while(q.empty() == false)\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + prerow[i];\\n                int ncol = col + precol[i];\\n\\n                if(nrow >= 0 && nrow < grid.size() && ncol >= 0 && ncol < grid[0].size() && grid[nrow][ncol] > 0 && visited[nrow][ncol] == 0){\\n                    q.push({nrow, ncol});\\n                    res += grid[nrow][ncol];\\n                    visited[nrow][ncol] = 1;\\n                }\\n            }\\n        }\\n         \\n        return res;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector <vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        int res = 0;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(!visited[i][j] && grid[i][j] > 0)\\n                {\\n                    res = max(res, bfs(grid, visited, i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084103,
                "title": "python-easy-dfs-connected-components",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def helper(self, grid,i,j):\\n        s=grid[i][j]\\n        grid[i][j]=0\\n        x=[1,0,0,-1]\\n        y=[0,1,-1,0]\\n        for k in range(4):\\n            q=i+x[k]\\n            w=j+y[k]\\n            if q>=0 and w>=0 and q<=len(grid)-1 and  w<=len(grid[0])-1 and grid[q][w]!=0:\\n                s+=self.helper(grid,q,w)\\n        return s\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ma=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]>0:\\n                    ma=max(ma,self.helper(grid,i,j))\\n        return ma\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self, grid,i,j):\\n        s=grid[i][j]\\n        grid[i][j]=0\\n        x=[1,0,0,-1]\\n        y=[0,1,-1,0]\\n        for k in range(4):\\n            q=i+x[k]\\n            w=j+y[k]\\n            if q>=0 and w>=0 and q<=len(grid)-1 and  w<=len(grid[0])-1 and grid[q][w]!=0:\\n                s+=self.helper(grid,q,w)\\n        return s\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ma=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]>0:\\n                    ma=max(ma,self.helper(grid,i,j))\\n        return ma\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083953,
                "title": "java-standard-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStandard DFS, Visited Array\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n^2)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        int currMax=0;\\n        int[] curr=new int[1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && !(grid[i][j]==0)){\\n                    curr[0]=0;\\n                    dfs(i,j,grid,vis,curr);\\n                    currMax=Math.max(currMax,curr[0]);\\n                }\\n            }\\n        }\\n        return currMax;\\n    }\\n    private void dfs(int i, int j, int[][] grid,boolean[][] vis, int[] curr){\\n        int m = grid.length, n = grid[0].length;\\n        if(i<0 || j<0 || i>m-1 || j>n-1 || grid[i][j]==0 || vis[i][j]) return;\\n        vis[i][j]=true;\\n        curr[0]+=grid[i][j];\\n        dfs(i+1,j,grid,vis,curr);\\n        dfs(i-1,j,grid,vis,curr);\\n        dfs(i,j+1,grid,vis,curr);\\n        dfs(i,j-1,grid,vis,curr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        int currMax=0;\\n        int[] curr=new int[1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!vis[i][j] && !(grid[i][j]==0)){\\n                    curr[0]=0;\\n                    dfs(i,j,grid,vis,curr);\\n                    currMax=Math.max(currMax,curr[0]);\\n                }\\n            }\\n        }\\n        return currMax;\\n    }\\n    private void dfs(int i, int j, int[][] grid,boolean[][] vis, int[] curr){\\n        int m = grid.length, n = grid[0].length;\\n        if(i<0 || j<0 || i>m-1 || j>n-1 || grid[i][j]==0 || vis[i][j]) return;\\n        vis[i][j]=true;\\n        curr[0]+=grid[i][j];\\n        dfs(i+1,j,grid,vis,curr);\\n        dfs(i-1,j,grid,vis,curr);\\n        dfs(i,j+1,grid,vis,curr);\\n        dfs(i,j-1,grid,vis,curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077158,
                "title": "simple-dfs-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        ans=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        vis=set()\\n        def dfs(r,c):\\n            if r<0 or c<0 or r==m or c==n or (r,c) in vis or grid[r][c]==0: return 0\\n            vis.add((r,c))\\n            return grid[r][c]+dfs(r-1,c)+dfs(r,c-1)+dfs(r+1,c)+dfs(r,c+1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans=max(ans,dfs(i,j))     \\n\\n        return ans        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        ans=0\\n        m=len(grid)\\n        n=len(grid[0])\\n        vis=set()\\n        def dfs(r,c):\\n            if r<0 or c<0 or r==m or c==n or (r,c) in vis or grid[r][c]==0: return 0\\n            vis.add((r,c))\\n            return grid[r][c]+dfs(r-1,c)+dfs(r,c-1)+dfs(r+1,c)+dfs(r,c+1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                ans=max(ans,dfs(i,j))     \\n\\n        return ans        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072146,
                "title": "dfs",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # directions for moving up, down, left, right\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        \\n        # DFS function\\n        def dfs(i, j, visited):\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or (i, j) in visited:\\n                return 0\\n            visited.add((i, j))\\n            fish = grid[i][j]\\n            for dx, dy in directions:\\n                fish += dfs(i + dx, j + dy, visited)\\n            return fish\\n        \\n        max_fish = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:  # if it\\'s a water cell\\n                    max_fish = max(max_fish, dfs(i, j, set()))\\n        \\n        return max_fish\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # directions for moving up, down, left, right\\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        \\n        # DFS function\\n        def dfs(i, j, visited):\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0 or (i, j) in visited:\\n                return 0\\n            visited.add((i, j))\\n            fish = grid[i][j]\\n            for dx, dy in directions:\\n                fish += dfs(i + dx, j + dy, visited)\\n            return fish\\n        \\n        max_fish = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:  # if it\\'s a water cell\\n                    max_fish = max(max_fish, dfs(i, j, set()))\\n        \\n        return max_fish\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062067,
                "title": "java-simple-dfs",
                "content": "class Solution {\\n\\n    int dirs1[]=new int[]{-1,0,1,0};\\n    int dirs2[]=new int[]{0,1,0,-1};\\n    \\n    int max = 0;\\n    int mn =0;\\n    int nn=0;\\n    \\n    public int dfs(int i,int j,int[][] grid,boolean vis[][]){\\n        if(i<0 || j<0 || i>= mn || j>= nn || vis[i][j] || grid[i][j]==0){\\n            return 0;\\n        }\\n        \\n        vis[i][j]=true;\\n        int neighborSum = 0;\\n        for(int k=0;k<4;k++){\\n            int r = i + dirs1[k];\\n            int c = j + dirs2[k];\\n            neighborSum += dfs(r,c,grid,vis);\\n        }\\n        return grid[i][j] + neighborSum;\\n        \\n    }\\n    public int findMaxFish(int[][] grid) {\\n        mn= grid.length;\\n        nn=grid[0].length;\\n        \\n        \\n        for(int i=0;i<mn;i++){\\n            for(int j=0;j<nn;j++){\\n                if(grid[i][j]!=0){\\n                    int size = dfs(i,j,grid,new boolean[mn][nn]);\\n                    max = Math.max(size,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int dirs1[]=new int[]{-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 4059104,
                "title": "dfs-implementation-both-in-c-and-java",
                "content": "# Code\\n```java []\\nclass Solution {\\n    void solve(int r, int c, int[][] grid, int[][] vis, int[] sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\\n        sum[0] += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 && ny >= 0 && nx < n && ny < m && vis[nx][ny] == 0 && grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int maxi = 0;\\n        int[][] vis = new int[n][m];\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && vis[i][j] == 0) {\\n                    int[] sum = new int[1];\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = Math.max(maxi, sum[0]);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    void solve(int r, int c, vector<vector<int>> &grid, vector<vector<int>> &vis, int &sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        sum += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int maxi = 0;\\n        vector<vector<int>> vis(n, vector<int> (m));\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 and !vis[i][j]) {\\n                    int sum = 0;\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = max(maxi, sum);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    void solve(int r, int c, int[][] grid, int[][] vis, int[] sum, int n, int m) {\\n        vis[r][c] = 1;\\n        int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\\n        sum[0] += grid[r][c];\\n\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 && ny >= 0 && nx < n && ny < m && vis[nx][ny] == 0 && grid[nx][ny] > 0)\\n                solve(nx, ny, grid, vis, sum, n, m);\\n        }\\n    }\\n\\n    int findMaxFish(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int maxi = 0;\\n        int[][] vis = new int[n][m];\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && vis[i][j] == 0) {\\n                    int[] sum = new int[1];\\n                    solve(i, j, grid, vis, sum, n, m);\\n                    maxi = Math.max(maxi, sum[0]);  \\n                }             \\n            }\\n        }        \\n\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051736,
                "title": "template-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        simple dfs should suffice\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        self.max_fish = 0\\n\\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1, j), (i,j-1), (i,j+1)]\\n        \\n        def dfs(i, j, dfs_visited):\\n            self.count+=grid[i][j]\\n            dfs_visited.add((i,j))\\n            self.max_fish = max(self.max_fish, self.count)\\n            for nei in get_neis(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] != 0 and (x, y) not in dfs_visited:\\n                    dfs(x, y, dfs_visited)\\n\\n        self.visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in self.visited:\\n                    dfs_visited = set()\\n                    self.count = 0\\n                    dfs(i, j, dfs_visited)\\n                    self.visited = self.visited.union(dfs_visited)\\n\\n        return self.max_fish\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        simple dfs should suffice\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        self.max_fish = 0\\n\\n        def is_valid(i, j):\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1, j), (i,j-1), (i,j+1)]\\n        \\n        def dfs(i, j, dfs_visited):\\n            self.count+=grid[i][j]\\n            dfs_visited.add((i,j))\\n            self.max_fish = max(self.max_fish, self.count)\\n            for nei in get_neis(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] != 0 and (x, y) not in dfs_visited:\\n                    dfs(x, y, dfs_visited)\\n\\n        self.visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and (i,j) not in self.visited:\\n                    dfs_visited = set()\\n                    self.count = 0\\n                    dfs(i, j, dfs_visited)\\n                    self.visited = self.visited.union(dfs_visited)\\n\\n        return self.max_fish\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041516,
                "title": "c-bfs-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int i,int j,int n,int m){\\n      return i>-1 && i<n && j>-1 && j<m;\\n    }\\n    void Bfs(int i,int j,int &count,vector<vector<int>>& grid){\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      int row[4]={-1,1,0,0};\\n      int col[4]={0,0,-1,1};\\n      queue<pair<int,int>>q;\\n      q.push({i,j});\\n      while(!q.empty()){\\n        i=q.front().first;\\n        j=q.front().second;\\n        q.pop();\\n        for(int k=0;k<4;k++){\\n          if(valid(i+row[k],j+col[k],n,m) && grid[i+row[k]][j+col[k]]>0){\\n            q.push({i+row[k],j+col[k]});\\n            count+=grid[i+row[k]][j+col[k]];\\n            grid[i+row[k]][j+col[k]]=0;\\n          }\\n        }\\n      }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          int count=0;\\n           if(grid[i][j]>0){\\n              count+=grid[i][j];\\n              grid[i][j]=0;\\n              Bfs(i,j,count,grid);\\n              ans=max(ans,count);\\n\\n           }\\n        }\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int i,int j,int n,int m){\\n      return i>-1 && i<n && j>-1 && j<m;\\n    }\\n    void Bfs(int i,int j,int &count,vector<vector<int>>& grid){\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      int row[4]={-1,1,0,0};\\n      int col[4]={0,0,-1,1};\\n      queue<pair<int,int>>q;\\n      q.push({i,j});\\n      while(!q.empty()){\\n        i=q.front().first;\\n        j=q.front().second;\\n        q.pop();\\n        for(int k=0;k<4;k++){\\n          if(valid(i+row[k],j+col[k],n,m) && grid[i+row[k]][j+col[k]]>0){\\n            q.push({i+row[k],j+col[k]});\\n            count+=grid[i+row[k]][j+col[k]];\\n            grid[i+row[k]][j+col[k]]=0;\\n          }\\n        }\\n      }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n=grid.size();\\n      int m=grid[0].size();\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          int count=0;\\n           if(grid[i][j]>0){\\n              count+=grid[i][j];\\n              grid[i][j]=0;\\n              Bfs(i,j,count,grid);\\n              ans=max(ans,count);\\n\\n           }\\n        }\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023609,
                "title": "c-easy-dfs-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid){\\n        // base case that makes the curr cell invalid, if visited, or if it \\n        //is land cell we return 0 (no fish caught);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(row<0 || row>=m || col<0 || col>=n || vis[row][col] || \\n        grid[row][col]==0)\\n        return 0;\\n\\n        //otherwise we mark it as visited and proceed\\n        vis[row][col] = 1;\\n        \\n        int res = 0;\\n        for(int i=0;i<4;i++){\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            res +=dfs(nrow,ncol,vis,grid);\\n        } \\n\\n        return res + grid[row][col];\\n    }\\npublic:\\n    vector<int> delrow{-1,0,1,0};\\n    vector<int> delcol{0,1,0,-1};\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m,vector<int>(n,0)); //visited vector\\n\\n        //a fisherman can start at any water cell therefore we call dfs for \\n        //every water body and find sum of all cells and maximize it\\n        int maxi = -1e9;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if it is an unvisited water body\\n                if(grid[i][j]>0 && !vis[i][j]){\\n                    int val = dfs(i,j,vis,grid);\\n                    cout<<val<<endl;\\n                    maxi = max(maxi,val);\\n                }\\n            }\\n        }\\n        return max(maxi,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid){\\n        // base case that makes the curr cell invalid, if visited, or if it \\n        //is land cell we return 0 (no fish caught);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(row<0 || row>=m || col<0 || col>=n || vis[row][col] || \\n        grid[row][col]==0)\\n        return 0;\\n\\n        //otherwise we mark it as visited and proceed\\n        vis[row][col] = 1;\\n        \\n        int res = 0;\\n        for(int i=0;i<4;i++){\\n            int nrow = row + delrow[i];\\n            int ncol = col + delcol[i];\\n\\n            res +=dfs(nrow,ncol,vis,grid);\\n        } \\n\\n        return res + grid[row][col];\\n    }\\npublic:\\n    vector<int> delrow{-1,0,1,0};\\n    vector<int> delcol{0,1,0,-1};\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m,vector<int>(n,0)); //visited vector\\n\\n        //a fisherman can start at any water cell therefore we call dfs for \\n        //every water body and find sum of all cells and maximize it\\n        int maxi = -1e9;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if it is an unvisited water body\\n                if(grid[i][j]>0 && !vis[i][j]){\\n                    int val = dfs(i,j,vis,grid);\\n                    cout<<val<<endl;\\n                    maxi = max(maxi,val);\\n                }\\n            }\\n        }\\n        return max(maxi,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4004210,
                "title": "c-solution-by-floodfill-algorithm",
                "content": "# Intuition\\nUse floodfill algorithm\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int iCount = 0;\\n    void floodfill(vector<vector<int>>& grid, int i, int j)\\n    {\\n        iCount+=grid[i][j];\\n        grid[i][j] = 0;\\n        if(i-1>=0 && grid[i-1][j] >0) floodfill(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] >0) floodfill(grid, i+1, j);\\n        if(j-1>=0 && grid[i][j-1] >0) floodfill(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] >0) floodfill(grid, i, j+1);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int iMaxCount = 0;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] != 0)\\n                {\\n                    iCount = 0;\\n                    floodfill(grid, i, j);\\n                    if(iCount > iMaxCount) iMaxCount = iCount;\\n\\n                }\\n            }\\n        }\\n\\n        return iMaxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int iCount = 0;\\n    void floodfill(vector<vector<int>>& grid, int i, int j)\\n    {\\n        iCount+=grid[i][j];\\n        grid[i][j] = 0;\\n        if(i-1>=0 && grid[i-1][j] >0) floodfill(grid, i-1, j);\\n        if(i+1 < m && grid[i+1][j] >0) floodfill(grid, i+1, j);\\n        if(j-1>=0 && grid[i][j-1] >0) floodfill(grid, i, j-1);\\n        if(j+1 < n && grid[i][j+1] >0) floodfill(grid, i, j+1);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int iMaxCount = 0;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] != 0)\\n                {\\n                    iCount = 0;\\n                    floodfill(grid, i, j);\\n                    if(iCount > iMaxCount) iMaxCount = iCount;\\n\\n                }\\n            }\\n        }\\n\\n        return iMaxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999782,
                "title": "a-c-solution",
                "content": "\\n# Code\\n```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit) {\\n    if(row < 0 || row >= rLimit || col < 0 || col >= cLimit || !grid[row][col]) return 0;\\n    int ret = grid[row][col];\\n    grid[row][col] = 0;\\n\\n    ret += traverse(grid, row + 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row - 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row, col + 1, rLimit, cLimit);\\n    ret += traverse(grid, row, col - 1, rLimit, cLimit);\\n\\n    return ret;\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    int tmp = 0;\\n    int max = 0;\\n\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j]) {\\n                tmp = traverse(grid, i, j, gridSize, *gridColSize);\\n                max = (tmp > max)? tmp : max;\\n            }\\n        }\\n    }\\n    return max;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint traverse(int** grid, int row, int col, int rLimit, int cLimit) {\\n    if(row < 0 || row >= rLimit || col < 0 || col >= cLimit || !grid[row][col]) return 0;\\n    int ret = grid[row][col];\\n    grid[row][col] = 0;\\n\\n    ret += traverse(grid, row + 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row - 1, col, rLimit, cLimit);\\n    ret += traverse(grid, row, col + 1, rLimit, cLimit);\\n    ret += traverse(grid, row, col - 1, rLimit, cLimit);\\n\\n    return ret;\\n}\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n    int tmp = 0;\\n    int max = 0;\\n\\n    for(int i = 0; i < gridSize; i++) {\\n        for(int j = 0; j < *gridColSize; j++) {\\n            if(grid[i][j]) {\\n                tmp = traverse(grid, i, j, gridSize, *gridColSize);\\n                max = (tmp > max)? tmp : max;\\n            }\\n        }\\n    }\\n    return max;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994399,
                "title": "3-liner-dfs-performance-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(m$$ x $$n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int dfs(int[][] grid, int i, int j) {\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[i].length || grid[i][j] < 1) return 0;\\n        grid[i][j] -= 20;\\n        return 20 + grid[i][j] + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) if(grid[i][j] > 0) max = Math.max(max, dfs(grid, i, j));\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    int dfs(int[][] grid, int i, int j) {\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[i].length || grid[i][j] < 1) return 0;\\n        grid[i][j] -= 20;\\n        return 20 + grid[i][j] + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, max = 0;\\n        for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) if(grid[i][j] > 0) max = Math.max(max, dfs(grid, i, j));\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984753,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    var max = -1;\\n    var curMax = 0;\\n    final rows = grid.length;\\n    final cols = grid[0].length;\\n\\n    int dfs(int i, int j) {\\n        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        final curValue = grid[i][j];\\n        grid[i][j] = 0;\\n        return curValue + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\\n    }\\n\\n    for (int i = 0; i < rows; i++) {\\n        for (int j = 0; j < cols; j++) {\\n            if (grid[i][j] != 0) {\\n                curMax = dfs(i, j);\\n            }\\n            if (curMax > max) {\\n                max = curMax;\\n            }\\n        }\\n    }\\n\\n    return max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int findMaxFish(List<List<int>> grid) {\\n    var max = -1;\\n    var curMax = 0;\\n    final rows = grid.length;\\n    final cols = grid[0].length;\\n\\n    int dfs(int i, int j) {\\n        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        final curValue = grid[i][j];\\n        grid[i][j] = 0;\\n        return curValue + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1);\\n    }\\n\\n    for (int i = 0; i < rows; i++) {\\n        for (int j = 0; j < cols; j++) {\\n            if (grid[i][j] != 0) {\\n                curMax = dfs(i, j);\\n            }\\n            if (curMax > max) {\\n                max = curMax;\\n            }\\n        }\\n    }\\n\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982530,
                "title": "java-100",
                "content": "# Approach\\nWhen we find a water cell, we recurse through it and its water cell neighbors. For each cell, we accumulate the value and then set it to 0 so that it will not be counted again. We store and return the max value.\\n\\n# Complexity\\n- Time complexity : O(m*n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    int [][] g;\\n\\n    public int findMaxFish(int[][] grid)\\n    {\\n        g = grid;\\n        int max = 0;\\n\\n        for(int i=0, l=grid.length, b=grid[0].length; i<l; i++)\\n            for(int j=0; j<b; j++)\\n                if(g[i][j]!=0)\\n                    max = Math.max(max,get(i,j));\\n\\n        return max;\\n    }\\n\\n    private int get(int x, int y)\\n    {\\n        if(x<0 || x>=g.length || y<0 || y>=g[0].length || g[x][y]==0)\\n            return 0;\\n        \\n        int c = g[x][y];\\n        g[x][y] = 0;\\n        \\n        return c + get(x+1,y) + get(x,y+1) + get(x-1,y) + get(x,y-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\n    int [][] g;\\n\\n    public int findMaxFish(int[][] grid)\\n    {\\n        g = grid;\\n        int max = 0;\\n\\n        for(int i=0, l=grid.length, b=grid[0].length; i<l; i++)\\n            for(int j=0; j<b; j++)\\n                if(g[i][j]!=0)\\n                    max = Math.max(max,get(i,j));\\n\\n        return max;\\n    }\\n\\n    private int get(int x, int y)\\n    {\\n        if(x<0 || x>=g.length || y<0 || y>=g[0].length || g[x][y]==0)\\n            return 0;\\n        \\n        int c = g[x][y];\\n        g[x][y] = 0;\\n        \\n        return c + get(x+1,y) + get(x,y+1) + get(x-1,y) + get(x,y-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981408,
                "title": "very-easy-dfs-to-beat-92-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res=0\\n        def dfs(i,j):\\n            if grid[i][j]==0:\\n                return 0\\n            temp=grid[i][j]\\n            grid[i][j]=0\\n\\n            next_move=[(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n            for next_row, next_col in next_move:\\n                if next_row >=0 and next_row <len(grid) and next_col>=0 and next_col < len(grid[0])\\\\\\n                and grid[next_row][next_col] !=0:\\n                    temp+=dfs(next_row, next_col)\\n                else:\\n                    continue\\n            return temp\\n\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]!=0:\\n                    res=max(res, dfs(i,j))\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res=0\\n        def dfs(i,j):\\n            if grid[i][j]==0:\\n                return 0\\n            temp=grid[i][j]\\n            grid[i][j]=0\\n\\n            next_move=[(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n            for next_row, next_col in next_move:\\n                if next_row >=0 and next_row <len(grid) and next_col>=0 and next_col < len(grid[0])\\\\\\n                and grid[next_row][next_col] !=0:\\n                    temp+=dfs(next_row, next_col)\\n                else:\\n                    continue\\n            return temp\\n\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]!=0:\\n                    res=max(res, dfs(i,j))\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976375,
                "title": "using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i, j):\\n\\n            if i<0 or j<0 or i>m-1 or j>n-1 or grid[i][j] == 0:\\n                return 0\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n            return val + dfs(i-1,j) + dfs(i,j-1) + dfs(i,j+1) + dfs(i+1,j)\\n\\n        m, n = len(grid),len(grid[0])\\n        s = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    s = max(s, dfs(i,j))\\n                    print(\"S is \",s)\\n        return s\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(i, j):\\n\\n            if i<0 or j<0 or i>m-1 or j>n-1 or grid[i][j] == 0:\\n                return 0\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n            return val + dfs(i-1,j) + dfs(i,j-1) + dfs(i,j+1) + dfs(i+1,j)\\n\\n        m, n = len(grid),len(grid[0])\\n        s = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    s = max(s, dfs(i,j))\\n                    print(\"S is \",s)\\n        return s\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971940,
                "title": "similar-to-max-area-of-island-bfs-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    private:\\nvoid bfs(int row,int col, vector<vector<int>>&vis,vector<vector<int>>& grid,int &a)\\n{\\n    vis[row][col]=1;\\n    queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int r=q.front().first;\\n        int c=q.front().second;\\n        q.pop();\\n        for(int delrow=-1;delrow<=1;delrow++)\\n        {\\n            for(int delcol=-1;delcol<=1;delcol++)\\n            {\\n                if(abs(delrow)!=abs(delcol))\\n                {\\n                    int nrow=r+delrow;\\n                    int ncol=c+delcol;\\n                    if(nrow>=0&&nrow<grid.size()&&ncol>=0&&ncol<grid[0].size()&&!vis[nrow][ncol]&&grid[nrow][ncol]>0)\\n                    {\\n                        a+=grid[nrow][ncol];\\n                        vis[nrow][ncol]=1;\\n                        q.push({nrow,ncol});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j]&&grid[i][j]!=0)\\n                {\\n                    int a=grid[i][j];\\n                    bfs(i,j,vis,grid,a);\\n                    count=max(a,count);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    private:\\nvoid bfs(int row,int col, vector<vector<int>>&vis,vector<vector<int>>& grid,int &a)\\n{\\n    vis[row][col]=1;\\n    queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int r=q.front().first;\\n        int c=q.front().second;\\n        q.pop();\\n        for(int delrow=-1;delrow<=1;delrow++)\\n        {\\n            for(int delcol=-1;delcol<=1;delcol++)\\n            {\\n                if(abs(delrow)!=abs(delcol))\\n                {\\n                    int nrow=r+delrow;\\n                    int ncol=c+delcol;\\n                    if(nrow>=0&&nrow<grid.size()&&ncol>=0&&ncol<grid[0].size()&&!vis[nrow][ncol]&&grid[nrow][ncol]>0)\\n                    {\\n                        a+=grid[nrow][ncol];\\n                        vis[nrow][ncol]=1;\\n                        q.push({nrow,ncol});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j]&&grid[i][j]!=0)\\n                {\\n                    int a=grid[i][j];\\n                    bfs(i,j,vis,grid,a);\\n                    count=max(a,count);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970807,
                "title": "cpp-easy-implementation-fast-and-clean-code",
                "content": "\\n# Complexity\\n- Time complexity:``O( M * N )``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        q.push({i,j});\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        vector<int> r={1,0,-1,0};\\n        vector<int> c={0,1,0,-1};\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int row=x+r[k];\\n                int col=y+c[k];\\n                if(row>=0 && row<m && col>=0 && col<n && grid[row][col]!=0){\\n                    ans+=grid[row][col];\\n                    grid[row][col]=0;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n= grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0){\\n                    int temp=bfs(grid,i,j,m,n);\\n                    ans=max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>& grid,int i,int j,int m,int n){\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        q.push({i,j});\\n        ans+=grid[i][j];\\n        grid[i][j]=0;\\n        vector<int> r={1,0,-1,0};\\n        vector<int> c={0,1,0,-1};\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int row=x+r[k];\\n                int col=y+c[k];\\n                if(row>=0 && row<m && col>=0 && col<n && grid[row][col]!=0){\\n                    ans+=grid[row][col];\\n                    grid[row][col]=0;\\n                    q.push({row,col});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n= grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]!=0){\\n                    int temp=bfs(grid,i,j,m,n);\\n                    ans=max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969630,
                "title": "jave-dfs-easy-and-straightforward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nClassic DFS solution\\n\\nMain function:\\n- traverse through all grids\\n- update ```maxFish``` when some grids returns a larger number from dfs search\\n\\nIn DFS function:\\n- check conditions: visited? upper lower bounds? water or land? etc\\n- evaluate grid if condition is fulfilled, then mark as visited = true;\\n- update the returned value (fish in this case)\\n- evaluate adjacent grids, check if there\\'s a possible move. Do this recursively to check all possible moves.\\n- move to adj grids and update returning value (fish)\\n- If back tracking is necessary, mark as false;\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n- Because we have $$N^2$$ for main function (iterates m*n times), and N (iterates m*n times) for helper dfs function\\n- So, the time complexity is $$O(m^2*n^2)$$. If m and n are roughly equal (i.e., the grid is close to square), then the time complexity could be described as $$O(N^4)$$ where N is the side length of the grid.  \\n\\n- Space complexity: $$O(m*n)$$\\n- The grid itself occupies $$O(m\\xD7n)$$ space, but we don\\'t count this since it\\'s given as input. The visited array occupies $$O(m\\xD7n)$$ space. The recursive DFS can potentially go as deep as m\\xD7n in the worst case, so the call stack could occupy $$O(m\\xD7n)$$ space. \\n- Combining the above, the total space complexity is $$O(m\\xD7n)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int [][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int findMaxFish(int[][] grid) { \\n        // DFS to find spot with maxfish && maxFish > 0\\n        int m = grid.length, n = grid[0].length; // m >= 1; n <= 10;\\n        int maxFish = 0;\\n        int fish = 0;\\n        // use two for-loops to traverse through all grids\\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++){\\n                fish = dfs(i,j,grid,new boolean [m][n]); // don\\'t use visited[i][j] here because \\n                maxFish = Math.max(fish,maxFish); //update if newly collected fish is more\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited){\\n        int m = grid.length, n = grid[0].length;\\n        //check all conditions: visited ? water? reach bound m? n?\\n        if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] || grid[r][c] <= 0) {\\n            return 0;\\n        }\\n        // update visited\\n        visited[r][c] = true;\\n\\n        //if passed, update new fish num\\n        int fish = grid[r][c];\\n        grid[r][c] = 0; // set land mark to 0 to avoid double counting\\n\\n        // keep updating fish if adj routes are possible\\n        for(int[] dir : directions){\\n            int adjrow = r + dir[0];\\n            int adjcol = c + dir[1];\\n            fish += dfs(adjrow,adjcol,grid,visited);\\n        }\\n        \\n        //update if backtrack\\n        visited[r][c] = false;\\n\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```maxFish```\n```\\nclass Solution {\\n    \\n    int [][] directions = {{0,1},{1,0},{0,-1},{-1,0}};\\n\\n    public int findMaxFish(int[][] grid) { \\n        // DFS to find spot with maxfish && maxFish > 0\\n        int m = grid.length, n = grid[0].length; // m >= 1; n <= 10;\\n        int maxFish = 0;\\n        int fish = 0;\\n        // use two for-loops to traverse through all grids\\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++){\\n                fish = dfs(i,j,grid,new boolean [m][n]); // don\\'t use visited[i][j] here because \\n                maxFish = Math.max(fish,maxFish); //update if newly collected fish is more\\n            }\\n        }\\n        return maxFish;\\n    }\\n    private int dfs(int r, int c, int[][] grid, boolean[][] visited){\\n        int m = grid.length, n = grid[0].length;\\n        //check all conditions: visited ? water? reach bound m? n?\\n        if (r < 0 || r >= m || c < 0 || c >= n || visited[r][c] || grid[r][c] <= 0) {\\n            return 0;\\n        }\\n        // update visited\\n        visited[r][c] = true;\\n\\n        //if passed, update new fish num\\n        int fish = grid[r][c];\\n        grid[r][c] = 0; // set land mark to 0 to avoid double counting\\n\\n        // keep updating fish if adj routes are possible\\n        for(int[] dir : directions){\\n            int adjrow = r + dir[0];\\n            int adjcol = c + dir[1];\\n            fish += dfs(adjrow,adjcol,grid,visited);\\n        }\\n        \\n        //update if backtrack\\n        visited[r][c] = false;\\n\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963099,
                "title": "golang-dfs-solution",
                "content": "# Code\\n```go\\nfunc findMaxFish(grid [][]int) int {\\n\\tmf := 0\\n\\tfor i := range grid {\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tfish := dfs(grid, i, j)\\n\\t\\t\\tif fish > mf {\\n\\t\\t\\t\\tmf = fish\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mf\\n}\\n\\nfunc dfs(grid [][]int, i, j int) int {\\n\\tif i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) {\\n\\t\\treturn 0\\n\\t}\\n\\tif grid[i][j] == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tfish := grid[i][j]\\n\\tgrid[i][j] = 0\\n\\tfish += dfs(grid, i-1, j)\\n\\tfish += dfs(grid, i+1, j)\\n\\tfish += dfs(grid, i, j-1)\\n\\tfish += dfs(grid, i, j+1)\\n\\treturn fish\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc findMaxFish(grid [][]int) int {\\n\\tmf := 0\\n\\tfor i := range grid {\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tfish := dfs(grid, i, j)\\n\\t\\t\\tif fish > mf {\\n\\t\\t\\t\\tmf = fish\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mf\\n}\\n\\nfunc dfs(grid [][]int, i, j int) int {\\n\\tif i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) {\\n\\t\\treturn 0\\n\\t}\\n\\tif grid[i][j] == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tfish := grid[i][j]\\n\\tgrid[i][j] = 0\\n\\tfish += dfs(grid, i-1, j)\\n\\tfish += dfs(grid, i+1, j)\\n\\tfish += dfs(grid, i, j-1)\\n\\tfish += dfs(grid, i, j+1)\\n\\treturn fish\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957420,
                "title": "c-u-c-t-nh-s-l-ng-c-c-th-c-u-nhi-u-nh-t-theo-4-h-ng",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\t\\tpublic static int[] dx = { 1, -1, 0, 0 };\\n\\t\\tpublic static int[] dy = { 0, 0, 1, -1 }; \\n\\t\\tpublic static int MAXFISH = 0;\\n\\n    public int findMaxFish(int[][] matrix) {\\n        \\tint rows = matrix.length;\\n\\t\\t\\t\\t\\tint col = matrix[0].length;\\n\\t\\t\\t\\t\\tint maxFish = 0;\\n\\t\\t\\t\\t\\tboolean[][] visited = new boolean[rows][col];\\n\\n\\t\\t\\t\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\t\\t\\t\\tif (matrix[i][j] > 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint fishByCell = bfs(i, j, matrix, matrix[i][j], visited);\\n\\t\\t\\t\\t\\t\\t\\t\\tmaxFish = Math.max(maxFish, fishByCell);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn maxFish;\\n    }\\n\\n public static int bfs(int x, int y, int[][] matrix, int fish, boolean[][] visited) {\\n\\t\\tint rows = matrix.length;\\n\\t\\tint col = matrix[0].length;\\n\\t\\tint maxFish = fish;\\n\\t\\tvisited[x][y] = true;\\n\\t\\tQueue<Cellss> queue = new LinkedList<Cellss>();\\n\\t\\tqueue.add(new Cellss(x, y));\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tCellss curenCell = queue.poll();\\n\\t\\t\\tint cureentX = curenCell.x;\\n\\t\\t\\tint cureentY = curenCell.y;\\n\\t\\t\\tfor (int i = 0; i < 4; i++) { \\n\\t\\t\\t\\tint nextX = cureentX + dx[i];\\n\\t\\t\\t\\tint nextY = cureentY + dy[i]; \\n\\t\\t\\t\\tif (nextX < rows && nextX >= 0 && nextY < col && nextY >= 0\\n\\t\\t\\t\\t\\t\\t&& matrix[nextX][nextY] > 0 && !visited[nextX][nextY]) {\\n\\t\\t\\t\\t\\tmaxFish = maxFish + matrix[nextX][nextY];\\n\\n\\t\\t\\t\\t\\tqueue.add(new Cellss(nextX, nextY));\\n\\t\\t\\t\\t\\tvisited[nextX][nextY] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxFish;\\n\\t}\\n}\\n\\n\\nclass Cellss {\\n\\tint x;\\n\\tint y;\\n\\n\\tpublic Cellss(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t\\tpublic static int[] dx = { 1, -1, 0, 0 };\\n\\t\\tpublic static int[] dy = { 0, 0, 1, -1 }; \\n\\t\\tpublic static int MAXFISH = 0;\\n\\n    public int findMaxFish(int[][] matrix) {\\n        \\tint rows = matrix.length;\\n\\t\\t\\t\\t\\tint col = matrix[0].length;\\n\\t\\t\\t\\t\\tint maxFish = 0;\\n\\t\\t\\t\\t\\tboolean[][] visited = new boolean[rows][col];\\n\\n\\t\\t\\t\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\t\\t\\t\\tif (matrix[i][j] > 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\tint fishByCell = bfs(i, j, matrix, matrix[i][j], visited);\\n\\t\\t\\t\\t\\t\\t\\t\\tmaxFish = Math.max(maxFish, fishByCell);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn maxFish;\\n    }\\n\\n public static int bfs(int x, int y, int[][] matrix, int fish, boolean[][] visited) {\\n\\t\\tint rows = matrix.length;\\n\\t\\tint col = matrix[0].length;\\n\\t\\tint maxFish = fish;\\n\\t\\tvisited[x][y] = true;\\n\\t\\tQueue<Cellss> queue = new LinkedList<Cellss>();\\n\\t\\tqueue.add(new Cellss(x, y));\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tCellss curenCell = queue.poll();\\n\\t\\t\\tint cureentX = curenCell.x;\\n\\t\\t\\tint cureentY = curenCell.y;\\n\\t\\t\\tfor (int i = 0; i < 4; i++) { \\n\\t\\t\\t\\tint nextX = cureentX + dx[i];\\n\\t\\t\\t\\tint nextY = cureentY + dy[i]; \\n\\t\\t\\t\\tif (nextX < rows && nextX >= 0 && nextY < col && nextY >= 0\\n\\t\\t\\t\\t\\t\\t&& matrix[nextX][nextY] > 0 && !visited[nextX][nextY]) {\\n\\t\\t\\t\\t\\tmaxFish = maxFish + matrix[nextX][nextY];\\n\\n\\t\\t\\t\\t\\tqueue.add(new Cellss(nextX, nextY));\\n\\t\\t\\t\\t\\tvisited[nextX][nextY] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxFish;\\n\\t}\\n}\\n\\n\\nclass Cellss {\\n\\tint x;\\n\\tint y;\\n\\n\\tpublic Cellss(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929438,
                "title": "c-simple-dfs-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    int m;\\n    int n;\\n    void dfs(vector<vector<int>>&grid, int x, int y, int&curr)\\n    {\\n        curr+=grid[x][y];\\n        grid[x][y]=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int nx = x+dir[k][0];\\n            int ny = y+dir[k][1];\\n            if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0)\\n            {\\n                dfs(grid, nx, ny, curr);\\n            }\\n        }\\n        return ;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    int curr = 0;\\n                    dfs(grid, i, j, curr);\\n                    ans=max(ans, curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    int m;\\n    int n;\\n    void dfs(vector<vector<int>>&grid, int x, int y, int&curr)\\n    {\\n        curr+=grid[x][y];\\n        grid[x][y]=0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int nx = x+dir[k][0];\\n            int ny = y+dir[k][1];\\n            if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]>0)\\n            {\\n                dfs(grid, nx, ny, curr);\\n            }\\n        }\\n        return ;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid)\\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    int curr = 0;\\n                    dfs(grid, i, j, curr);\\n                    ans=max(ans, curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924427,
                "title": "simplest-depth-first-search-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->Check each cell\\n->if the cell has non-zero value\\n->run iterative function to collect all connected non-zero value\\n->as each cell changes to zero\\n->compare with other cell values to save the maximum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getfish(self,grid,i,j):\\n        if grid[i][j]==0: return 0\\n        fish=grid[i][j]\\n        grid[i][j]=0\\n\\n        if i+1<len(grid):fish+=self.getfish(grid,i+1,j)\\n        if i-1>=0:fish+=self.getfish(grid,i-1,j)\\n        if j+1<len(grid[0]):fish+=self.getfish(grid,i,j+1)\\n        if j-1>=0:fish+=self.getfish(grid,i,j-1)\\n  \\n        return fish\\n\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        out = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]>0:\\n                    out = max(out,self.getfish(grid,i,j))\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getfish(self,grid,i,j):\\n        if grid[i][j]==0: return 0\\n        fish=grid[i][j]\\n        grid[i][j]=0\\n\\n        if i+1<len(grid):fish+=self.getfish(grid,i+1,j)\\n        if i-1>=0:fish+=self.getfish(grid,i-1,j)\\n        if j+1<len(grid[0]):fish+=self.getfish(grid,i,j+1)\\n        if j-1>=0:fish+=self.getfish(grid,i,j-1)\\n  \\n        return fish\\n\\n\\n\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        out = 0\\n        n = len(grid)\\n        m = len(grid[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]>0:\\n                    out = max(out,self.getfish(grid,i,j))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922330,
                "title": "easy-cpp-solution-beats-98-of-online-submission",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nint delrow[4]={-1,0,1,0};\\nint delcol[4]={0,1,0,-1};\\nvoid dfs(vector<vector<int>>& g,int i,int j,int& cnt){\\ncnt=cnt+g[i][j];\\n//vis[i][j]=1;\\nint n=g.size();\\nint m=g[0].size();\\ng[i][j]=0;\\nfor(int k=0;k<4;k++){\\n    int nrow=i+delrow[k];\\n    int ncol=j+delcol[k];\\n    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && g[nrow][ncol]!=0){\\n        dfs(g,nrow,ncol,cnt);\\n    }\\n}\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\nfor(int i=0;i<n;i++){\\n    for(int j=0;j<m;j++){\\nif(grid[i][j]!=0){\\n    int cnt=0;\\n   // vector<vector<int>> vis(n,vector<int>(m,0));\\ndfs(grid,i,j,cnt);\\nmaxi=max(maxi,cnt);\\n}\\n    }\\n}\\nreturn maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint delrow[4]={-1,0,1,0};\\nint delcol[4]={0,1,0,-1};\\nvoid dfs(vector<vector<int>>& g,int i,int j,int& cnt){\\ncnt=cnt+g[i][j];\\n//vis[i][j]=1;\\nint n=g.size();\\nint m=g[0].size();\\ng[i][j]=0;\\nfor(int k=0;k<4;k++){\\n    int nrow=i+delrow[k];\\n    int ncol=j+delcol[k];\\n    if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && g[nrow][ncol]!=0){\\n        dfs(g,nrow,ncol,cnt);\\n    }\\n}\\n}\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\nfor(int i=0;i<n;i++){\\n    for(int j=0;j<m;j++){\\nif(grid[i][j]!=0){\\n    int cnt=0;\\n   // vector<vector<int>> vis(n,vector<int>(m,0));\\ndfs(grid,i,j,cnt);\\nmaxi=max(maxi,cnt);\\n}\\n    }\\n}\\nreturn maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917556,
                "title": "clean-bfs-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c]>0:\\n                    queue = [(r,c)]\\n                    count = 0\\n                    while queue:\\n                        row,col = queue.pop()\\n                        if grid[row][col]==0:continue\\n                        count+=grid[row][col]\\n                        grid[row][col] = 0\\n                        for m_r,m_c in directions:\\n                            new_r,new_c = row+m_r,col+m_c\\n                            if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] !=0:\\n                                queue.append((new_r, new_c))\\n                    ans = max(ans,count)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c]>0:\\n                    queue = [(r,c)]\\n                    count = 0\\n                    while queue:\\n                        row,col = queue.pop()\\n                        if grid[row][col]==0:continue\\n                        count+=grid[row][col]\\n                        grid[row][col] = 0\\n                        for m_r,m_c in directions:\\n                            new_r,new_c = row+m_r,col+m_c\\n                            if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] !=0:\\n                                queue.append((new_r, new_c))\\n                    ans = max(ans,count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916100,
                "title": "easy-python-solution-by-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n        m,n = len(grid), len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        curfishes = [0]\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] > 0:\\n                    curfishes[0] += grid[i][j]\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n        maxFishes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 0 and grid[i][j] > 0:\\n                    curfishes[0] = 0\\n                    dfs(i,j)\\n                    maxFishes = max(maxFishes, curfishes[0])\\n        return maxFishes\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMaxFish(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        # dfs\\uFF0C\\u8FD4\\u56DE\\u6700\\u5927\\u503C\\n        m,n = len(grid), len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        curfishes = [0]\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] > 0:\\n                    curfishes[0] += grid[i][j]\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n        maxFishes = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if visited[i][j] == 0 and grid[i][j] > 0:\\n                    curfishes[0] = 0\\n                    dfs(i,j)\\n                    maxFishes = max(maxFishes, curfishes[0])\\n        return maxFishes\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915836,
                "title": "easy-intuitive-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != 0) {\\n                    int maxFish = dfs(grid, i, j);\\n                    max = Math.max(max, maxFish);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int dfs(int[][] grid, int r, int c) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) {\\n            return 0;\\n        }\\n       \\n        int curr = grid[r][c];\\n        grid[r][c] = 0;\\n        int u = dfs(grid, r - 1, c);  // Up\\n        int d = dfs(grid, r + 1, c);  // Down\\n        int ri = dfs(grid, r, c + 1); // Right\\n        int l = dfs(grid, r, c - 1);  // Left\\n        return curr + l + ri + u + d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] != 0) {\\n                    int maxFish = dfs(grid, i, j);\\n                    max = Math.max(max, maxFish);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int dfs(int[][] grid, int r, int c) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == 0) {\\n            return 0;\\n        }\\n       \\n        int curr = grid[r][c];\\n        grid[r][c] = 0;\\n        int u = dfs(grid, r - 1, c);  // Up\\n        int d = dfs(grid, r + 1, c);  // Down\\n        int ri = dfs(grid, r, c + 1); // Right\\n        int l = dfs(grid, r, c - 1);  // Left\\n        return curr + l + ri + u + d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908818,
                "title": "javascript-dfs-o-n-2",
                "content": "```\\nvar findMaxFish = function(grid) {\\n  const dydx = [[0,1],[0,-1],[1,0],[-1,0]];\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n  const set = new Set();\\n  let max = 0;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (grid[i][j] > 0) max = Math.max(grid[i][j] + dfs(i,j), max);\\n    }\\n  }\\n  return max;\\n\\n  function dfs(i, j) {\\n    const key = `${i}:${j}`;\\n    if (set.has(key) || notValid(i, j)) return 0;\\n    set.add(key);\\n\\n    let sum = 0;\\n    for (const [dy, dx] of dydx) {\\n      const [x, y] = [dx + i, dy + j];\\n      if (notValid(x,y) || set.has(`${x}:${y}`)) continue;\\n      sum += grid[x][y] + dfs(x,y,set);\\n    }\\n    return sum;\\n  }\\n\\n  function notValid (i, j) {\\n    return (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === 0); \\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMaxFish = function(grid) {\\n  const dydx = [[0,1],[0,-1],[1,0],[-1,0]];\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n  const set = new Set();\\n  let max = 0;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (grid[i][j] > 0) max = Math.max(grid[i][j] + dfs(i,j), max);\\n    }\\n  }\\n  return max;\\n\\n  function dfs(i, j) {\\n    const key = `${i}:${j}`;\\n    if (set.has(key) || notValid(i, j)) return 0;\\n    set.add(key);\\n\\n    let sum = 0;\\n    for (const [dy, dx] of dydx) {\\n      const [x, y] = [dx + i, dy + j];\\n      if (notValid(x,y) || set.has(`${x}:${y}`)) continue;\\n      sum += grid[x][y] + dfs(x,y,set);\\n    }\\n    return sum;\\n  }\\n\\n  function notValid (i, j) {\\n    return (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === 0); \\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905885,
                "title": "cpp-easy-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCall a BFS from each water cell we encounter and then find the max from all the function calls.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCall a BFS from each water cell we encounter and then find the max from all the function calls.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<pair<int,int>>vct={{0,1},{0,-1},{1,0},{-1,0}};\\nint bfs(int row,int col,vector<vector<int>>& grid)\\n{\\n    int res=0;\\n     std::vector<std::vector<bool>>track(grid.size(),std::vector<bool>(grid[0].size(),false));\\n     track[row][col]=true;\\n    std::queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int newrow=q.front().first;\\n        int newcol=q.front().second;\\n        res+=grid[q.front().first][q.front().second];\\n        q.pop();\\n        for(int i=0;i<vct.size();i++)\\n        {\\n            if((newrow+vct[i].first)>=0 && (newrow+vct[i].first)<grid.size() && (newcol+vct[i].second)>=0 && (newcol+vct[i].second)<grid[0].size() && grid[newrow+vct[i].first][newcol+vct[i].second]>0 && track[newrow+vct[i].first][newcol+vct[i].second]==false)\\n            {\\n                track[newrow+vct[i].first][newcol+vct[i].second]=true;\\n                q.push({newrow+vct[i].first,newcol+vct[i].second});\\n            }\\n        }\\n    }\\n    return res;\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                   \\n                    int subans=bfs(i,j,grid);\\n                    ans=max(ans,subans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<pair<int,int>>vct={{0,1},{0,-1},{1,0},{-1,0}};\\nint bfs(int row,int col,vector<vector<int>>& grid)\\n{\\n    int res=0;\\n     std::vector<std::vector<bool>>track(grid.size(),std::vector<bool>(grid[0].size(),false));\\n     track[row][col]=true;\\n    std::queue<pair<int,int>>q;\\n    q.push({row,col});\\n    while(!q.empty())\\n    {\\n        int newrow=q.front().first;\\n        int newcol=q.front().second;\\n        res+=grid[q.front().first][q.front().second];\\n        q.pop();\\n        for(int i=0;i<vct.size();i++)\\n        {\\n            if((newrow+vct[i].first)>=0 && (newrow+vct[i].first)<grid.size() && (newcol+vct[i].second)>=0 && (newcol+vct[i].second)<grid[0].size() && grid[newrow+vct[i].first][newcol+vct[i].second]>0 && track[newrow+vct[i].first][newcol+vct[i].second]==false)\\n            {\\n                track[newrow+vct[i].first][newcol+vct[i].second]=true;\\n                q.push({newrow+vct[i].first,newcol+vct[i].second});\\n            }\\n        }\\n    }\\n    return res;\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                   \\n                    int subans=bfs(i,j,grid);\\n                    ans=max(ans,subans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896630,
                "title": "c-clean-code-too-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:long long int a=0,s=0;\\n    void t(int i,int j,vector<vector<int>>& g)\\n    {\\n         if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]==0) return;\\n         s+=g[i][j];\\n         g[i][j]=0;\\n\\n         t(i+1,j,g);\\n         t(i-1,j,g);\\n         t(i,j+1,g);\\n         t(i,j-1,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        for(int i=0;i<g.size();i++)\\n         for(int j=0;j<g[0].size();j++)\\n          if(g[i][j]>0)\\n            {t(i,j,g);\\n            a=max(a,s);\\n            s=0;\\n            }\\n\\n       return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:long long int a=0,s=0;\\n    void t(int i,int j,vector<vector<int>>& g)\\n    {\\n         if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]==0) return;\\n         s+=g[i][j];\\n         g[i][j]=0;\\n\\n         t(i+1,j,g);\\n         t(i-1,j,g);\\n         t(i,j+1,g);\\n         t(i,j-1,g);\\n    }\\n    int findMaxFish(vector<vector<int>>& g) {\\n        for(int i=0;i<g.size();i++)\\n         for(int j=0;j<g[0].size();j++)\\n          if(g[i][j]>0)\\n            {t(i,j,g);\\n            a=max(a,s);\\n            s=0;\\n            }\\n\\n       return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868878,
                "title": "dfs-c",
                "content": "# Intuition\\nDo a DFS a find the maximum count\\n\\n# Complexity\\n- Time complexity:\\nO{m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        bool[,] visited = new bool[m,n];\\n        int maxFishes = 0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !visited[i,j])\\n                {\\n                    maxFishes = Math.Max(maxFishes,DFS(grid,i,j,visited));\\n                }\\n            }\\n        }\\n        return maxFishes;\\n    }\\n\\n    private int DFS(int[][] grid,int i,int j, bool[,] visited)\\n    {\\n\\n        int[] c = new int[]{1,0,-1,0};\\n        int[] r = new int[]{0,-1,0,1};\\n        int sum = grid[i][j];\\n        visited[i,j] = true;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int row = i+r[k];\\n            int col = j+c[k];\\n            if(isAllowed(row,col,grid.Length,grid[0].Length) && !visited[row,col] && grid[row][col]!=0)\\n            {\\n                sum = sum + DFS(grid,row,col,visited);\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private bool isAllowed(int i,int j,int m,int n)\\n    {\\n        if(i>=0 && i< m && j>=0 && j<n)\\n            return true;\\n\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n\\n        bool[,] visited = new bool[m,n];\\n        int maxFishes = 0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0 && !visited[i,j])\\n                {\\n                    maxFishes = Math.Max(maxFishes,DFS(grid,i,j,visited));\\n                }\\n            }\\n        }\\n        return maxFishes;\\n    }\\n\\n    private int DFS(int[][] grid,int i,int j, bool[,] visited)\\n    {\\n\\n        int[] c = new int[]{1,0,-1,0};\\n        int[] r = new int[]{0,-1,0,1};\\n        int sum = grid[i][j];\\n        visited[i,j] = true;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int row = i+r[k];\\n            int col = j+c[k];\\n            if(isAllowed(row,col,grid.Length,grid[0].Length) && !visited[row,col] && grid[row][col]!=0)\\n            {\\n                sum = sum + DFS(grid,row,col,visited);\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private bool isAllowed(int i,int j,int m,int n)\\n    {\\n        if(i>=0 && i< m && j>=0 && j<n)\\n            return true;\\n\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863959,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        maxx = 0\\n\\n        def helper(x,y):\\n            if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]) or not grid[x][y]:\\n                return 0\\n            \\n            current = grid[x][y]\\n            grid[x][y] = 0\\n\\n            return current + helper(x-1,y) + helper(x+1,y) + helper(x,y-1) + helper(x,y+1)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    maxx = max(helper(i,j), maxx)\\n        \\n        return maxx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        maxx = 0\\n\\n        def helper(x,y):\\n            if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]) or not grid[x][y]:\\n                return 0\\n            \\n            current = grid[x][y]\\n            grid[x][y] = 0\\n\\n            return current + helper(x-1,y) + helper(x+1,y) + helper(x,y-1) + helper(x,y+1)\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    maxx = max(helper(i,j), maxx)\\n        \\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849817,
                "title": "python-3-with-dfs",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        n, m = len(grid), len(grid[0])\\n\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m:\\n                return 0\\n            \\n            if grid[i][j] == 0:\\n                return 0\\n\\n            fish, grid[i][j] = grid[i][j], 0\\n\\n            fish += dfs(i + 1, j)\\n            fish += dfs(i - 1, j)\\n            fish += dfs(i, j + 1)\\n            fish += dfs(i, j - 1)\\n            return fish\\n\\n            \\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\n        n, m = len(grid), len(grid[0])\\n\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m:\\n                return 0\\n            \\n            if grid[i][j] == 0:\\n                return 0\\n\\n            fish, grid[i][j] = grid[i][j], 0\\n\\n            fish += dfs(i + 1, j)\\n            fish += dfs(i - 1, j)\\n            fish += dfs(i, j + 1)\\n            fish += dfs(i, j - 1)\\n            return fish\\n\\n            \\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n\\n        return ans\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848447,
                "title": "beats-100-java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->DFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int dfs(int[][] grid, int r, int c){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0)\\n        return 0;\\n        int x = grid[r][c];\\n        grid[r][c] = 0;\\n\\n        return x+dfs(grid,r-1,c)+dfs(grid,r+1,c)+dfs(grid,r,c-1)+dfs(grid,r,c+1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int fish = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] != 0){\\n                    fish = Math.max(fish,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(int[][] grid, int r, int c){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(r<0||c<0||r>=m||c>=n||grid[r][c]==0)\\n        return 0;\\n        int x = grid[r][c];\\n        grid[r][c] = 0;\\n\\n        return x+dfs(grid,r-1,c)+dfs(grid,r+1,c)+dfs(grid,r,c-1)+dfs(grid,r,c+1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int fish = 0;\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] != 0){\\n                    fish = Math.max(fish,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848212,
                "title": "python-dfs-beats-98-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to calculate total number of fishes from each group of fishes\\n\\nSo, apply dfs in each group and mark it as visited to avoid going to it again\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nCall dfs at every point mark the elements visited in visited array. Recursively call for all its adjacent nodes and return the total \\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```class Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        visited = [[False for i in range(n)] for j in range(m)]\\n\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            visited[i][j] = True\\n            res = grid[i][j]\\n\\n            dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n            for x, y in dir:\\n                if isSafe(i+x, j+y) and grid[i + x][j + y] != 0 and visited[i + x][j + y] == False:\\n                    res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and visited[i][j] == False:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n```\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\nSpace Optimized (marking value to 0 on grid after visiting it)\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) (Not including recursion stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            \\n            if not isSafe(i, j) or grid[i][j] == 0:\\n                return 0\\n\\n            res = grid[i][j]\\n            grid[i][j] = 0\\n\\n\\n            for x, y in dir:\\n                res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        visited = [[False for i in range(n)] for j in range(m)]\\n\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            visited[i][j] = True\\n            res = grid[i][j]\\n\\n            dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n            for x, y in dir:\\n                if isSafe(i+x, j+y) and grid[i + x][j + y] != 0 and visited[i + x][j + y] == False:\\n                    res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0 and visited[i][j] == False:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def isSafe(i, j):\\n            if i >= 0 and j >= 0 and i < m and j < n:\\n                return True\\n            return False\\n\\n        def dfs(i, j):\\n            \\n            if not isSafe(i, j) or grid[i][j] == 0:\\n                return 0\\n\\n            res = grid[i][j]\\n            grid[i][j] = 0\\n\\n\\n            for x, y in dir:\\n                res = res +  dfs(i + x, j + y)\\n            \\n            return res\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 0:\\n                    ans = max(ans, dfs(i, j))\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839217,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 ){\\n                    max=Math.max(max,helper(grid,i,j,n,m));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    public int helper(int[][] grid,int i,int j,int n,int m){\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(grid[i][j]==0)return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=0;\\n        return ans+helper(grid,i+1,j,n,m)+helper(grid,i,j-1,n,m)+helper(grid,i-1,j,n,m)+helper(grid,i,j+1,n,m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0 ){\\n                    max=Math.max(max,helper(grid,i,j,n,m));\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    public int helper(int[][] grid,int i,int j,int n,int m){\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(grid[i][j]==0)return 0;\\n        int ans=grid[i][j];\\n        grid[i][j]=0;\\n        return ans+helper(grid,i+1,j,n,m)+helper(grid,i,j-1,n,m)+helper(grid,i-1,j,n,m)+helper(grid,i,j+1,n,m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832115,
                "title": "c-simple-beginner-friendly-solution-ll-bfs-dfs-union-find",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int mx=0,i=0,j=0,p=0,m=grid.size(),n=grid[0].size(),f=0,r=0,c=0,s=0,a=0,k=0;\\n        queue<int>q;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]>0)\\n                {\\n                    a=0;\\n                    q.push(i*n+j);\\n                    while(q.size()>0)\\n                    {\\n                        s=q.size();\\n                        for(k=0;k<s;k++)\\n                        {\\n                            f=q.front();\\n                            r=f/n,c=f%n;\\n                            if(grid[r][c]>0)\\n                            {\\n                                a+=grid[r][c];\\n                                grid[r][c]=0;\\n                                if(r>0) q.push(f-n);\\n                                if(r<m-1) q.push(f+n);\\n                                if(c>0) q.push(f-1);\\n                                if(c<n-1) q.push(f+1);\\n                            }\\n                            q.pop();\\n                        }\\n                    }\\n                    mx=max(a,mx);\\n                }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int mx=0,i=0,j=0,p=0,m=grid.size(),n=grid[0].size(),f=0,r=0,c=0,s=0,a=0,k=0;\\n        queue<int>q;\\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(grid[i][j]>0)\\n                {\\n                    a=0;\\n                    q.push(i*n+j);\\n                    while(q.size()>0)\\n                    {\\n                        s=q.size();\\n                        for(k=0;k<s;k++)\\n                        {\\n                            f=q.front();\\n                            r=f/n,c=f%n;\\n                            if(grid[r][c]>0)\\n                            {\\n                                a+=grid[r][c];\\n                                grid[r][c]=0;\\n                                if(r>0) q.push(f-n);\\n                                if(r<m-1) q.push(f+n);\\n                                if(c>0) q.push(f-1);\\n                                if(c<n-1) q.push(f+1);\\n                            }\\n                            q.pop();\\n                        }\\n                    }\\n                    mx=max(a,mx);\\n                }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827389,
                "title": "bfs-from-land",
                "content": "# Intuition\\n\\nWe can do DFS from each land, but BFS seems interesting here.\\n\\n# Approach\\n\\nCollect all land first. And do BFS for each land. Collecting profit.\\n\\n# Complexity\\n- Time complexity:\\n`O(rows * cols)`\\n\\n- Space complexity:\\n`O(rows * cols)`\\n\\n# Code\\n```\\ntype Pair struct {r, c int}\\n\\nfunc findMaxFish(grid [][]int) int {\\n    // collect all land points\\n    rows, cols := len(grid), len(grid[0])\\n\\n    landArr := []Pair{}\\n\\n    for r := 0; r < rows; r++ {\\n        for c := 0; c < cols; c++ {\\n            // land\\n            if grid[r][c] != 0 {\\n                landArr = append(landArr, Pair{r, c})\\n            }\\n        }\\n    }\\n\\n    profit := 0\\n\\n    if len(landArr) == 0 {\\n       return profit \\n    }\\n\\n    checkNei := func(r, c int, visited [][]bool) bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols && grid[r][c] > 0 && !visited[r][c]\\n    }\\n\\n    for _, land := range landArr {\\n\\n        newProfit := 0\\n        // start \\n        q := []Pair{land}\\n\\n        visited := make([][]bool, rows)\\n\\n        for r := 0; r < rows; r++ {\\n            visited[r] = make([]bool, cols)\\n        }\\n\\n        for len(q) > 0 {\\n            cur := q[0]\\n            q = q[1:]\\n\\n            if visited[cur.r][cur.c] {continue}\\n\\n            newProfit += grid[cur.r][cur.c]\\n            \\n            visited[cur.r][cur.c] = true\\n\\n            if checkNei(cur.r + 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r + 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r - 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r - 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r, cur.c + 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c + 1})\\n            }\\n\\n            if checkNei(cur.r, cur.c - 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c - 1})\\n            }\\n        }\\n\\n        if newProfit > profit {\\n            profit = newProfit\\n        }\\n    }\\n\\n    return profit\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Pair struct {r, c int}\\n\\nfunc findMaxFish(grid [][]int) int {\\n    // collect all land points\\n    rows, cols := len(grid), len(grid[0])\\n\\n    landArr := []Pair{}\\n\\n    for r := 0; r < rows; r++ {\\n        for c := 0; c < cols; c++ {\\n            // land\\n            if grid[r][c] != 0 {\\n                landArr = append(landArr, Pair{r, c})\\n            }\\n        }\\n    }\\n\\n    profit := 0\\n\\n    if len(landArr) == 0 {\\n       return profit \\n    }\\n\\n    checkNei := func(r, c int, visited [][]bool) bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols && grid[r][c] > 0 && !visited[r][c]\\n    }\\n\\n    for _, land := range landArr {\\n\\n        newProfit := 0\\n        // start \\n        q := []Pair{land}\\n\\n        visited := make([][]bool, rows)\\n\\n        for r := 0; r < rows; r++ {\\n            visited[r] = make([]bool, cols)\\n        }\\n\\n        for len(q) > 0 {\\n            cur := q[0]\\n            q = q[1:]\\n\\n            if visited[cur.r][cur.c] {continue}\\n\\n            newProfit += grid[cur.r][cur.c]\\n            \\n            visited[cur.r][cur.c] = true\\n\\n            if checkNei(cur.r + 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r + 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r - 1, cur.c, visited) {\\n                q = append(q, Pair{cur.r - 1, cur.c})\\n            }\\n\\n            if checkNei(cur.r, cur.c + 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c + 1})\\n            }\\n\\n            if checkNei(cur.r, cur.c - 1, visited) {\\n                q = append(q, Pair{cur.r, cur.c - 1})\\n            }\\n        }\\n\\n        if newProfit > profit {\\n            profit = newProfit\\n        }\\n    }\\n\\n    return profit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3824188,
                "title": "easy-dfs-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int count;\\n    public int findMaxFish(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n      \\n       int ans=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               count=0;\\n               if(mat[i][j]!=0){\\n                   dfs( mat,i,j);\\n                   ans=Math.max(count,ans);\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n\\n\\n    public void dfs(int[][] mat,int i,int j){\\n        if(i<0||j<0||i>=mat.length||j>=mat[0].length||mat[i][j]==0)return;\\n        count+=mat[i][j];\\n        mat[i][j]=0;\\n        dfs(mat,i+1,j);\\n        dfs(mat,i-1,j);\\n        dfs(mat,i,j+1);\\n        dfs(mat,i,j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int findMaxFish(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n      \\n       int ans=0;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               count=0;\\n               if(mat[i][j]!=0){\\n                   dfs( mat,i,j);\\n                   ans=Math.max(count,ans);\\n               }\\n           }\\n       }\\n       return ans;\\n    }\\n\\n\\n    public void dfs(int[][] mat,int i,int j){\\n        if(i<0||j<0||i>=mat.length||j>=mat[0].length||mat[i][j]==0)return;\\n        count+=mat[i][j];\\n        mat[i][j]=0;\\n        dfs(mat,i+1,j);\\n        dfs(mat,i-1,j);\\n        dfs(mat,i,j+1);\\n        dfs(mat,i,j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817700,
                "title": "dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n       boolean [][] visited = new boolean[m][n];\\n       int ans = 0;\\n       for(int i = 0;i<m ; i++){\\n           for(int j = 0; j<n; j++){\\n               if(grid[i][j]!= 0 && !visited[i][j])\\n               ans = Math.max(ans,dfs(grid,visited,i,j,m,n));\\n           }\\n       }\\n       return ans;\\n    }\\n    public int dfs(int[][] grid, boolean [][] visited,int i,int j,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>= n || grid[i][j]== 0|| visited[i][j])\\n        return 0;\\n        visited[i][j] = true;\\n        int fish = grid[i][j];\\n        return fish + dfs(grid,visited,i+1,j,m,n) +\\n                dfs(grid,visited,i,j+1,m,n) +\\n                dfs(grid,visited,i-1,j,m,n) +\\n                dfs(grid,visited,i,j-1,m,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n       boolean [][] visited = new boolean[m][n];\\n       int ans = 0;\\n       for(int i = 0;i<m ; i++){\\n           for(int j = 0; j<n; j++){\\n               if(grid[i][j]!= 0 && !visited[i][j])\\n               ans = Math.max(ans,dfs(grid,visited,i,j,m,n));\\n           }\\n       }\\n       return ans;\\n    }\\n    public int dfs(int[][] grid, boolean [][] visited,int i,int j,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>= n || grid[i][j]== 0|| visited[i][j])\\n        return 0;\\n        visited[i][j] = true;\\n        int fish = grid[i][j];\\n        return fish + dfs(grid,visited,i+1,j,m,n) +\\n                dfs(grid,visited,i,j+1,m,n) +\\n                dfs(grid,visited,i-1,j,m,n) +\\n                dfs(grid,visited,i,j-1,m,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812217,
                "title": "python-solution-dfs-explained",
                "content": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\t    # visited keeps track of all the cells visited\\n        visited = set()\\n\\t\\t\\n\\t\\t#initialize rows and columns variables\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        # DFS function\\n        def backtrack(i, j):\\n\\t\\t    # Check if out of bounds\\n            if i < 0 or j < 0 or i == rows or j == cols:\\n                return 0\\n            else:\\n\\t\\t\\t    # If land the fish caught will be 0\\n                if grid[i][j] == 0:\\n                    return 0\\n\\t\\t\\t\\t# If already visited don\\'t take the path\\n                if (i, j) in visited:\\n                    return 0\\n                \\n\\t\\t\\t\\t# Add the cell to visited\\n                visited.add((i, j))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Find out the total number of fish that can be caught by performing DFS recursively\\n                return grid[i][j] + backtrack(i, j + 1) + backtrack(i, j - 1) + backtrack(i+1, j) + backtrack(i-1,j)\\n            \\n            \\n        res = 0\\n            \\n        \\n\\t\\t# Iterate over every cell of the grid\\n        for i in range(rows):\\n            for j in range(cols):\\n\\t\\t\\t   # If the grid is not land and it has been not visited so far, perform DFS on it and get the total sum as current value\\n                if (i, j) not in visited and grid[i][j] != 0:\\n                    current_value = backtrack(i, j)\\n\\t\\t\\t\\t\\t# If this path gives best result update the result variable\\n                    res = max(current_value, res)\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n\\t    # visited keeps track of all the cells visited\\n        visited = set()\\n\\t\\t\\n\\t\\t#initialize rows and columns variables\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        # DFS function\\n        def backtrack(i, j):\\n\\t\\t    # Check if out of bounds\\n            if i < 0 or j < 0 or i == rows or j == cols:\\n                return 0\\n            else:\\n\\t\\t\\t    # If land the fish caught will be 0\\n                if grid[i][j] == 0:\\n                    return 0\\n\\t\\t\\t\\t# If already visited don\\'t take the path\\n                if (i, j) in visited:\\n                    return 0\\n                \\n\\t\\t\\t\\t# Add the cell to visited\\n                visited.add((i, j))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Find out the total number of fish that can be caught by performing DFS recursively\\n                return grid[i][j] + backtrack(i, j + 1) + backtrack(i, j - 1) + backtrack(i+1, j) + backtrack(i-1,j)\\n            \\n            \\n        res = 0\\n            \\n        \\n\\t\\t# Iterate over every cell of the grid\\n        for i in range(rows):\\n            for j in range(cols):\\n\\t\\t\\t   # If the grid is not land and it has been not visited so far, perform DFS on it and get the total sum as current value\\n                if (i, j) not in visited and grid[i][j] != 0:\\n                    current_value = backtrack(i, j)\\n\\t\\t\\t\\t\\t# If this path gives best result update the result variable\\n                    res = max(current_value, res)\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800687,
                "title": "simplest-solution-dfs-brute-force",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$stack->O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(int r,int c,vector<vector<int>>&grid,int &sum)\\n   {   int n=grid.size(),m=grid[0].size();\\n       \\n       sum +=grid[r][c];\\n       grid[r][c]=0;\\n\\n       if(r+1<n and grid[r+1][c]!=0)\\n       {\\n         dfs(r+1,c,grid,sum);\\n       }\\n       if(c+1<m and grid[r][c+1] !=0)\\n       {\\n           dfs(r,c+1,grid,sum);\\n       }\\n       if(r-1>=0 and grid[r-1][c] !=0)\\n       {\\n           dfs(r-1,c,grid,sum);\\n       }\\n\\n       if(c-1>=0 and grid[r][c-1] !=0)\\n       {\\n          dfs(r,c-1,grid,sum);\\n       }        \\n   }\\n\\n\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int fish=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]>0){\\n                    int sum=0;\\n                    dfs(i,j,grid,sum);\\n                    fish=max(fish,sum);\\n                }\\n            }\\n        }\\n    return fish;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(int r,int c,vector<vector<int>>&grid,int &sum)\\n   {   int n=grid.size(),m=grid[0].size();\\n       \\n       sum +=grid[r][c];\\n       grid[r][c]=0;\\n\\n       if(r+1<n and grid[r+1][c]!=0)\\n       {\\n         dfs(r+1,c,grid,sum);\\n       }\\n       if(c+1<m and grid[r][c+1] !=0)\\n       {\\n           dfs(r,c+1,grid,sum);\\n       }\\n       if(r-1>=0 and grid[r-1][c] !=0)\\n       {\\n           dfs(r-1,c,grid,sum);\\n       }\\n\\n       if(c-1>=0 and grid[r][c-1] !=0)\\n       {\\n          dfs(r,c-1,grid,sum);\\n       }        \\n   }\\n\\n\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int fish=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j]>0){\\n                    int sum=0;\\n                    dfs(i,j,grid,sum);\\n                    fish=max(fish,sum);\\n                }\\n            }\\n        }\\n    return fish;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797461,
                "title": "union-find-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int r,c;\\n    vector<int>parents;\\n\\n    bool isValid(int x, int y, vector<vector<int>>&grid){\\n        if((x>=0 && x<r) && (y>=0 && y<c) && grid[x][y])\\n            return true;\\n        return false;\\n    }\\n\\n    int getAbsoluteParent(int n){\\n        if(n!=parents[n])\\n            parents[n] = getAbsoluteParent(parents[n]);\\n        \\n        return parents[n];\\n    }\\n\\n    void unify(int x, int y){\\n        int px = getAbsoluteParent(x);\\n        int py = getAbsoluteParent(y);\\n\\n        if(px!=py)\\n            parents[px] = py;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        vector<pair<int,int>>dirs{{-1,0},{1,0},{0,-1},{0,1}};\\n        vector<int>totalFishes(r*c,0);\\n        parents = vector<int>(r*c);\\n        \\n        for(int i=0;i<r*c;i++)\\n            parents[i] = i;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(!grid[i][j])\\n                    continue;\\n\\n                for(int k=0;k<4;k++){\\n                    int ni = i + dirs[k].first;\\n                    int nj = j + dirs[k].second;\\n                    if(isValid(ni,nj,grid)){\\n                        unify(ni*c+nj,i*c+j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n\\n                if(grid[i][j]){\\n                    int cur_parent = getAbsoluteParent(i*c+j);\\n                    totalFishes[cur_parent] += grid[i][j];\\n                    ans = max(ans,totalFishes[cur_parent]);\\n                }\\n                    \\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int r,c;\\n    vector<int>parents;\\n\\n    bool isValid(int x, int y, vector<vector<int>>&grid){\\n        if((x>=0 && x<r) && (y>=0 && y<c) && grid[x][y])\\n            return true;\\n        return false;\\n    }\\n\\n    int getAbsoluteParent(int n){\\n        if(n!=parents[n])\\n            parents[n] = getAbsoluteParent(parents[n]);\\n        \\n        return parents[n];\\n    }\\n\\n    void unify(int x, int y){\\n        int px = getAbsoluteParent(x);\\n        int py = getAbsoluteParent(y);\\n\\n        if(px!=py)\\n            parents[px] = py;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        vector<pair<int,int>>dirs{{-1,0},{1,0},{0,-1},{0,1}};\\n        vector<int>totalFishes(r*c,0);\\n        parents = vector<int>(r*c);\\n        \\n        for(int i=0;i<r*c;i++)\\n            parents[i] = i;\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(!grid[i][j])\\n                    continue;\\n\\n                for(int k=0;k<4;k++){\\n                    int ni = i + dirs[k].first;\\n                    int nj = j + dirs[k].second;\\n                    if(isValid(ni,nj,grid)){\\n                        unify(ni*c+nj,i*c+j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n\\n                if(grid[i][j]){\\n                    int cur_parent = getAbsoluteParent(i*c+j);\\n                    totalFishes[cur_parent] += grid[i][j];\\n                    ans = max(ans,totalFishes[cur_parent]);\\n                }\\n                    \\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780050,
                "title": "100-faster-c-solution-using-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int m , n ;\\n    void dfs( int i , int j , vector<vector<int>>&grid , int &fish )\\n    {\\n        if( i < 0 or j < 0 or i >= m or j >= n ) return ;\\n        \\n        if(grid[i][j]==0) return ;\\n        fish += grid[i][j] ;\\n        grid[i][j] = 0 ;\\n        \\n        dfs( i , j + 1 , grid , fish ) ;\\n        dfs( i , j - 1 , grid , fish ) ;\\n        dfs( i + 1 , j , grid , fish ) ;\\n        dfs( i - 1 , j , grid , fish ) ;\\n        \\n        \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        int ans = 0 ;\\n        for( int i = 0 ; i < m ; i++ )\\n        {\\n            for( int j = 0 ; j < n ; j++ )\\n            {\\n                if(grid[i][j] != 0 )\\n                {\\n                    int temp = 0 ;\\n                    dfs( i , j , grid , temp ) ;\\n                    ans = max( ans , temp ) ;\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m , n ;\\n    void dfs( int i , int j , vector<vector<int>>&grid , int &fish )\\n    {\\n        if( i < 0 or j < 0 or i >= m or j >= n ) return ;\\n        \\n        if(grid[i][j]==0) return ;\\n        fish += grid[i][j] ;\\n        grid[i][j] = 0 ;\\n        \\n        dfs( i , j + 1 , grid , fish ) ;\\n        dfs( i , j - 1 , grid , fish ) ;\\n        dfs( i + 1 , j , grid , fish ) ;\\n        dfs( i - 1 , j , grid , fish ) ;\\n        \\n        \\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        int ans = 0 ;\\n        for( int i = 0 ; i < m ; i++ )\\n        {\\n            for( int j = 0 ; j < n ; j++ )\\n            {\\n                if(grid[i][j] != 0 )\\n                {\\n                    int temp = 0 ;\\n                    dfs( i , j , grid , temp ) ;\\n                    ans = max( ans , temp ) ;\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770309,
                "title": "c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] > 0)\\n                    maxFish = max(maxFish, dfs(grid, i, j));\\n        return maxFish;\\n    }\\nprivate:\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() ||\\n            j < 0 || j >= grid[0].size() ||\\n            grid[i][j] == 0)\\n            return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += dfs(grid, i + 1, j);\\n        fish += dfs(grid, i - 1, j);\\n        fish += dfs(grid, i, j + 1);\\n        fish += dfs(grid, i, j - 1);\\n        return fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxFish = 0;\\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] > 0)\\n                    maxFish = max(maxFish, dfs(grid, i, j));\\n        return maxFish;\\n    }\\nprivate:\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() ||\\n            j < 0 || j >= grid[0].size() ||\\n            grid[i][j] == 0)\\n            return 0;\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += dfs(grid, i + 1, j);\\n        fish += dfs(grid, i - 1, j);\\n        fish += dfs(grid, i, j + 1);\\n        fish += dfs(grid, i, j - 1);\\n        return fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764213,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max = 0;\\n\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 0) continue;\\n\\n            max = Math.max(max, dfs(grid, i, j));\\n        }\\n    }\\n\\n    return max;\\n};\\n\\nconst dfs = function(grid, r, c) {\\n    if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return 0;\\n    if(grid[r][c] === 0) return 0;\\n\\n    let fish = grid[r][c];\\n    grid[r][c] = 0;\\n\\n    return fish + dfs(grid, r - 1, c) + dfs(grid, r, c - 1) + dfs(grid, r + 1, c) + dfs(grid, r, c + 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar findMaxFish = function(grid) {\\n    let max = 0;\\n\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 0) continue;\\n\\n            max = Math.max(max, dfs(grid, i, j));\\n        }\\n    }\\n\\n    return max;\\n};\\n\\nconst dfs = function(grid, r, c) {\\n    if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return 0;\\n    if(grid[r][c] === 0) return 0;\\n\\n    let fish = grid[r][c];\\n    grid[r][c] = 0;\\n\\n    return fish + dfs(grid, r - 1, c) + dfs(grid, r, c - 1) + dfs(grid, r + 1, c) + dfs(grid, r, c + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760200,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum = 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(grid[i][j] != 0) {\\n                    int res[] = new int[1];\\n                    catchFish(grid, i, j, res);\\n                    sum = Math.max(sum, res[0]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    private void catchFish(int[][] grid, int i, int j, int[] res) {\\n        if( i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return;\\n        }\\n\\n        res[0] += grid[i][j];\\n        grid[i][j] = 0;\\n        catchFish(grid, i, j + 1, res);\\n        catchFish(grid, i, j - 1, res);\\n        catchFish(grid, i + 1, j, res);\\n        catchFish(grid, i - 1, j, res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum = 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(grid[i][j] != 0) {\\n                    int res[] = new int[1];\\n                    catchFish(grid, i, j, res);\\n                    sum = Math.max(sum, res[0]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    private void catchFish(int[][] grid, int i, int j, int[] res) {\\n        if( i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) {\\n            return;\\n        }\\n\\n        res[0] += grid[i][j];\\n        grid[i][j] = 0;\\n        catchFish(grid, i, j + 1, res);\\n        catchFish(grid, i, j - 1, res);\\n        catchFish(grid, i + 1, j, res);\\n        catchFish(grid, i - 1, j, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748345,
                "title": "python-c-numislands-variant-dfs",
                "content": "\\n```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        m, n = len(grid), len(grid[0])\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n:\\n                return 0\\n            if grid[i][j] == 0:\\n                return 0\\n\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n\\n            return val + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, dfs(i, j))\\n        \\n        return res\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        int res = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res = max(res, dfs(grid, i, j));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size()) {\\n            return 0; \\n        }\\n\\n        if (grid[i][j] == 0) {\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        return val + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1)+ dfs(grid, i, j - 1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        m, n = len(grid), len(grid[0])\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n:\\n                return 0\\n            if grid[i][j] == 0:\\n                return 0\\n\\n            val = grid[i][j]\\n            grid[i][j] = 0\\n\\n            return val + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                res = max(res, dfs(i, j))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738696,
                "title": "typescript-solution-easy-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nfunction findMaxFish(grid: number[][]): number {\\n    const rows: number = grid.length;\\n    const columns: number = grid[0].length;\\n    let maxResult: number = 0;\\n    let visited: boolean[][] = grid.map(row=> row.map(column=>false));\\n    \\n    function dfs(row: number, column: number): number {\\n        if (row < 0 || row >= rows || column < 0 || column >= columns)\\n            return 0;\\n        if (visited[row][column])\\n            return 0;\\n        \\n        visited[row][column] = true;\\n        if (grid[row][column] == 0)\\n            return 0;\\n\\n        let result: number = grid[row][column];\\n        result += dfs(row-1, column);\\n        result += dfs(row+1, column);\\n        result += dfs(row, column-1);\\n        result += dfs(row, column+1);\\n        return result;\\n    }\\n\\n    for(let i=0; i<rows; i++) {\\n        for(let j=0; j<columns; j++) {\\n            if(grid[i][j] == 0)\\n                continue;\\n            const count: number = dfs(i, j);\\n            maxResult = Math.max(maxResult, count);\\n        }\\n    }\\n    return maxResult;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findMaxFish(grid: number[][]): number {\\n    const rows: number = grid.length;\\n    const columns: number = grid[0].length;\\n    let maxResult: number = 0;\\n    let visited: boolean[][] = grid.map(row=> row.map(column=>false));\\n    \\n    function dfs(row: number, column: number): number {\\n        if (row < 0 || row >= rows || column < 0 || column >= columns)\\n            return 0;\\n        if (visited[row][column])\\n            return 0;\\n        \\n        visited[row][column] = true;\\n        if (grid[row][column] == 0)\\n            return 0;\\n\\n        let result: number = grid[row][column];\\n        result += dfs(row-1, column);\\n        result += dfs(row+1, column);\\n        result += dfs(row, column-1);\\n        result += dfs(row, column+1);\\n        return result;\\n    }\\n\\n    for(let i=0; i<rows; i++) {\\n        for(let j=0; j<columns; j++) {\\n            if(grid[i][j] == 0)\\n                continue;\\n            const count: number = dfs(i, j);\\n            maxResult = Math.max(maxResult, count);\\n        }\\n    }\\n    return maxResult;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731123,
                "title": "easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731122,
                "title": "easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& vis, int &fish) {\\n        int n = grid.size(), m = grid[0].size(); \\n        vis[row][col] = 1;\\n        fish += grid[row][col];\\n        int r_dir[4] = {-1, 0, 1, 0};\\n        int c_dir[4] = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++) {\\n            int r = row + r_dir[i];\\n            int c = col + c_dir[i];\\n            if(r >= 0 && r < n && c >= 0 && c < m && grid[r][c] && !vis[r][c]) {\\n                dfs(r, c, grid, vis, fish);\\n            }\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int max_fish = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] > 0 && !vis[i][j]) {\\n                    int fish = 0;\\n                    dfs(i, j, grid, vis, fish);\\n                    max_fish = max(max_fish, fish);\\n                }\\n            }\\n        }\\n        return max_fish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720607,
                "title": "98-beat-simple-dfs-bfs-solution",
                "content": "# DFS Code:\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, vector<pair<int,int>>& dir){\\n        int currFish = grid[x][y];\\n        grid[x][y] = 0;\\n        \\n        for(auto& d: dir){\\n            int nx = x + d.first;\\n            int ny = y + d.second;\\n\\n            if(nx >= 0 && ny >= 0 && nx < grid.size() && ny < grid[0].size() && grid[nx][ny] != 0){\\n                currFish += dfs(grid, nx, ny, dir);\\n            }\\n        }\\n        \\n        return currFish;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] != 0){\\n                    int currFish = dfs(grid, i, j, dir);\\n                    ans = max(ans, currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# BFS Code:\\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]!=0){\\n                    q.push({i,j});\\n                    int currFish = 0;\\n                    while(!q.empty()){\\n                        int x = q.front().first;\\n                        int y = q.front().second;\\n                        q.pop();\\n                        currFish += grid[x][y];\\n                        grid[x][y] = 0;\\n\\n                        for(auto& d: dir){\\n                            int nx = x + d.first;\\n                            int ny = y + d.second;\\n\\n                            if(nx>=0 && ny>=0 && nx<grid.size() && ny<grid[0].size() && grid[nx][ny]!=0){\\n                                q.push({nx,ny});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans,currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int x, int y, vector<pair<int,int>>& dir){\\n        int currFish = grid[x][y];\\n        grid[x][y] = 0;\\n        \\n        for(auto& d: dir){\\n            int nx = x + d.first;\\n            int ny = y + d.second;\\n\\n            if(nx >= 0 && ny >= 0 && nx < grid.size() && ny < grid[0].size() && grid[nx][ny] != 0){\\n                currFish += dfs(grid, nx, ny, dir);\\n            }\\n        }\\n        \\n        return currFish;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] != 0){\\n                    int currFish = dfs(grid, i, j, dir);\\n                    ans = max(ans, currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        vector<pair<int,int>> dir{{0,1},{1,0},{-1,0},{0,-1}};\\n        int ans = 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]!=0){\\n                    q.push({i,j});\\n                    int currFish = 0;\\n                    while(!q.empty()){\\n                        int x = q.front().first;\\n                        int y = q.front().second;\\n                        q.pop();\\n                        currFish += grid[x][y];\\n                        grid[x][y] = 0;\\n\\n                        for(auto& d: dir){\\n                            int nx = x + d.first;\\n                            int ny = y + d.second;\\n\\n                            if(nx>=0 && ny>=0 && nx<grid.size() && ny<grid[0].size() && grid[nx][ny]!=0){\\n                                q.push({nx,ny});\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans,currFish);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708698,
                "title": "easy-to-understand-optimised-dfs-without-making-any-visited-array-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$ \\nWorst case if we had to traverse the whole grid\\n\\n- Space complexity:\\n$$O(n*m)$$ \\nSince we will be accessing the grid so that too counts otherwise constant space\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int i, int j, int &count, vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==0){\\n            return;\\n        }\\n        count+=grid[i][j];\\n        grid[i][j]=0;\\n        dfs(i+1, j, count, grid);\\n        dfs(i, j+1, count, grid);\\n        dfs(i, j-1, count, grid);\\n        dfs(i-1, j, count, grid);\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count=0;\\n                    dfs(i, j, count, grid);\\n                    maxi=max(maxi, count);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, int &count, vector<vector<int>>& grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]==0){\\n            return;\\n        }\\n        count+=grid[i][j];\\n        grid[i][j]=0;\\n        dfs(i+1, j, count, grid);\\n        dfs(i, j+1, count, grid);\\n        dfs(i, j-1, count, grid);\\n        dfs(i-1, j, count, grid);\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxi=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count=0;\\n                    dfs(i, j, count, grid);\\n                    maxi=max(maxi, count);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696630,
                "title": "python-8-line-and-cpp-exchange-function",
                "content": "\\n```\\nIf you don\\'t want to make the values > 0 to 0.\\n```\\n\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        grid[r][c] *= -1;\\n        return abs(grid[r][c]) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), sum = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    sum = max(sum, dfs(grid,r,c));\\n        return sum;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] < 1:\\n                return 0\\n            grid[r][c] *= -1\\n            return abs(grid[r][c]) + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\\n```\\nIf you want to make the values > 0 to 0 so badly.\\n\\nexchange in C++ 14 in utility header file.\\n\\nint a = 1, b = 2;         | Here exchange changing the value of a to b\\nint ans = exchange(a,b);  | and returning the old value of a.\\ncout << a << \" \" << b << \" \" << ans;\\n\\n        Output:\\n\\n2 2 1\\n   \\n```\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        return exchange(grid[r][c], 0) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    ans = max(ans, dfs(grid,r,c));\\n        return ans;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] == 0:\\n                return 0\\n            grid[r][c], temp = 0, grid[r][c]\\n            return temp + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\\n\\n```\\nTime  complexity : O(mn)\\nSpace complexity : O(mn)\\n```\\n### If the post was helpful, an upvote will be appreciated.",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nIf you don\\'t want to make the values > 0 to 0.\\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        grid[r][c] *= -1;\\n        return abs(grid[r][c]) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), sum = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    sum = max(sum, dfs(grid,r,c));\\n        return sum;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] < 1:\\n                return 0\\n            grid[r][c] *= -1\\n            return abs(grid[r][c]) + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\n```\\nIf you want to make the values > 0 to 0 so badly.\\n\\nexchange in C++ 14 in utility header file.\\n\\nint a = 1, b = 2;         | Here exchange changing the value of a to b\\nint ans = exchange(a,b);  | and returning the old value of a.\\ncout << a << \" \" << b << \" \" << ans;\\n\\n        Output:\\n\\n2 2 1\\n   \\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || grid[r][c] < 1)\\n            return 0;\\n        return exchange(grid[r][c], 0) + dfs(grid,r,c-1) + dfs(grid,r-1,c) + dfs(grid,r,c+1) + dfs(grid,r+1,c);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for(int r=0; r<row; r++)\\n            for(int c=0; c<col; c++)\\n                if(grid[r][c]>0)\\n                    ans = max(ans, dfs(grid,r,c));\\n        return ans;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def findMaxFish(self, grid: List[List[int]]) -> int:\\n        def dfs(r:int, c:int) -> int:\\n            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c] == 0:\\n                return 0\\n            grid[r][c], temp = 0, grid[r][c]\\n            return temp + sum((dfs(r,c-1),dfs(r-1,c),dfs(r,c+1),dfs(r+1,c)))\\n        \\n        return max( (dfs(r,c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c]>0), default = 0 )\\n```\n```\\nTime  complexity : O(mn)\\nSpace complexity : O(mn)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3689962,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int m, n, mx;\\n    vector<int> dx{0, 0, 1, -1};\\n    vector<int> dy{1, -1, 0, 0};\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        m = grid.size(), n = grid[0].size(), mx = 0;\\n        for(int i = 0; i < m; i++)  \\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j])\\n                    mx = max(mx, helper(grid, i, j));\\n\\n        return mx;\\n    }\\n\\n    int helper(vector<vector<int>> &grid, int i, int j)\\n    {\\n        int tmp = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        for(int k = 0; k < dx.size(); k++)\\n        {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y])\\n                tmp += helper(grid, x, y);\\n        }\\n\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int m, n, mx;\\n    vector<int> dx{0, 0, 1, -1};\\n    vector<int> dy{1, -1, 0, 0};\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        m = grid.size(), n = grid[0].size(), mx = 0;\\n        for(int i = 0; i < m; i++)  \\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j])\\n                    mx = max(mx, helper(grid, i, j));\\n\\n        return mx;\\n    }\\n\\n    int helper(vector<vector<int>> &grid, int i, int j)\\n    {\\n        int tmp = grid[i][j];\\n        grid[i][j] = 0;\\n\\n        for(int k = 0; k < dx.size(); k++)\\n        {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y])\\n                tmp += helper(grid, x, y);\\n        }\\n\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680690,
                "title": "standard-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int r, int c, int &count){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==0) return ;\\n        count+= grid[r][c];\\n        grid[r][c]=0;\\n        dfs(grid, r-1, c, count);\\n        dfs(grid, r+1, c, count);\\n        dfs(grid, r, c-1, count);\\n        dfs(grid, r, c+1, count);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n  =grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count = 0;\\n                    dfs(grid, i, j, count);\\n                    // grid[i][j] = 0;\\n                    ans = max(ans, count);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid, int r, int c, int &count){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size() || grid[r][c]==0) return ;\\n        count+= grid[r][c];\\n        grid[r][c]=0;\\n        dfs(grid, r-1, c, count);\\n        dfs(grid, r+1, c, count);\\n        dfs(grid, r, c-1, count);\\n        dfs(grid, r, c+1, count);\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n  =grid.size();\\n        int m = grid[0].size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]>0){\\n                    int count = 0;\\n                    dfs(grid, i, j, count);\\n                    // grid[i][j] = 0;\\n                    ans = max(ans, count);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677888,
                "title": "done-with-dfs-easy-solution-c",
                "content": "# Approach\\n* First traverse the matrix by 2 for loops and check if any element of matrix is not zero then call dfs function in which we are calculating sum of connected elements.....\\n* Then we make an isvalid function in which we checked that whether the index where we traverse is valid or within the bound or not....\\n* if yes then return true else false.....\\n* Then in dfs function we add elements in sum variable if connected and make that element 0 so that we can\\'t traverse it again and then call dfs recursively if element connected or valid....\\n* conditions in dfs are:-\\n    1. first we check for row+1 and col\\n    2. second we check for row-1 and col\\n    3. third we check for row and col+1\\n    4. last we check for row and col-1\\n* in last we return sum in dfs function.....\\n* at last in findMaxFish function we take the maximum value of sum among all and return the same.........\\n\\n---\\n\\n\\n- [Time complexity: $$O(MN)$$]()\\n\\n---\\n\\n\\n- [Space complexity:$$ O(1)$$]()\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]!=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>& grid, int i, int j, int &sum)\\n    {\\n        sum+=grid[i][j];\\n        grid[i][j]=0;\\n        if(isvalid(grid, i+1, j))\\n        {\\n            dfs(grid, i+1, j, sum);\\n        }\\n        if(isvalid(grid, i-1, j))\\n        {\\n            dfs(grid, i-1, j, sum);\\n        }\\n        if(isvalid(grid, i, j+1))\\n        {\\n            dfs(grid, i, j+1, sum);\\n        }\\n        if(isvalid(grid, i, j-1))\\n        {\\n            dfs(grid, i, j-1, sum);\\n        }\\n        return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio;\\n        cin.tie(0);\\n        int m=0;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                int sum=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    int x = dfs(grid, i, j, sum);\\n                    m = max(m, x);\\n                }\\n            }\\n        }\\n        return m;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<vector<int>>& grid, int r, int c)\\n    {\\n        if(r>=0 && c>=0 && r<grid.size() && c<grid[0].size() && grid[r][c]!=0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>& grid, int i, int j, int &sum)\\n    {\\n        sum+=grid[i][j];\\n        grid[i][j]=0;\\n        if(isvalid(grid, i+1, j))\\n        {\\n            dfs(grid, i+1, j, sum);\\n        }\\n        if(isvalid(grid, i-1, j))\\n        {\\n            dfs(grid, i-1, j, sum);\\n        }\\n        if(isvalid(grid, i, j+1))\\n        {\\n            dfs(grid, i, j+1, sum);\\n        }\\n        if(isvalid(grid, i, j-1))\\n        {\\n            dfs(grid, i, j-1, sum);\\n        }\\n        return sum;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio;\\n        cin.tie(0);\\n        int m=0;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {\\n                int sum=0;\\n                if(grid[i][j]!=0)\\n                {\\n                    int x = dfs(grid, i, j, sum);\\n                    m = max(m, x);\\n                }\\n            }\\n        }\\n        return m;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677816,
                "title": "faster-c-dfs-easy-solution",
                "content": "# *Complexity*\\n- *Time & Space Complexity :*\\n```\\nO(mn)\\n```\\n# Code\\n```\\nclass Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col)\\n    {\\n        if(row >= 0 && col >= 0 && row < grid.size() && col < grid[0].size() && grid[row][col] != 0 && visit[row][col] == false)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    void dfs_func(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col, int &temp)\\n    {\\n        if(!isValid(grid, visit, row, col))\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            visit[row][col] = true;\\n            temp += grid[row][col];\\n            if(isValid(grid, visit, row+1, col))\\n            {\\n                dfs_func(grid, visit, row+1, col, temp);\\n            }\\n            if(isValid(grid, visit, row-1, col))\\n            {\\n                dfs_func(grid, visit, row-1, col, temp);\\n            }\\n            if(isValid(grid, visit, row, col+1))\\n            {\\n                dfs_func(grid, visit, row, col+1, temp);\\n            }\\n            if(isValid(grid, visit, row, col-1))\\n            {\\n                dfs_func(grid, visit, row, col-1, temp);\\n            }\\n            return;\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int temp = 0, count = 0;\\n        vector<vector<bool>> visit(grid.size(), vector<bool> (grid[0].size(), false));\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] > 0 && visit[i][j] == false)\\n                {\\n                    temp = 0;\\n                    dfs_func(grid, visit, i, j, temp);\\n                    count = max(temp, count);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***DO UPVOTE!*** \\uD83D\\uDE03\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nO(mn)\\n```\n```\\nclass Solution\\n{\\nprivate:\\n    bool isValid(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col)\\n    {\\n        if(row >= 0 && col >= 0 && row < grid.size() && col < grid[0].size() && grid[row][col] != 0 && visit[row][col] == false)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    void dfs_func(vector<vector<int>> &grid, vector<vector<bool>> &visit, int row, int col, int &temp)\\n    {\\n        if(!isValid(grid, visit, row, col))\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            visit[row][col] = true;\\n            temp += grid[row][col];\\n            if(isValid(grid, visit, row+1, col))\\n            {\\n                dfs_func(grid, visit, row+1, col, temp);\\n            }\\n            if(isValid(grid, visit, row-1, col))\\n            {\\n                dfs_func(grid, visit, row-1, col, temp);\\n            }\\n            if(isValid(grid, visit, row, col+1))\\n            {\\n                dfs_func(grid, visit, row, col+1, temp);\\n            }\\n            if(isValid(grid, visit, row, col-1))\\n            {\\n                dfs_func(grid, visit, row, col-1, temp);\\n            }\\n            return;\\n        }\\n    }\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int temp = 0, count = 0;\\n        vector<vector<bool>> visit(grid.size(), vector<bool> (grid[0].size(), false));\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] > 0 && visit[i][j] == false)\\n                {\\n                    temp = 0;\\n                    dfs_func(grid, visit, i, j, temp);\\n                    count = max(temp, count);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669574,
                "title": "simple-bfs-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void bfs(int i,int j,int &fishCaught,vector<vector<bool>>& visited,vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n\\n        int newRows[]={-1,0,1,0};\\n        int newCols[]={0,1,0,-1};\\n        q.push({i,j});\\n        visited[i][j]=true;\\n\\n        // bfs to go in 4 direction \\n        while(!q.empty()){\\n\\n            int row = q.front().first;\\n            int col= q.front().second;\\n            q.pop();\\n            // Catching fish \\uD83D\\uDC1F\\uD83D\\uDC20\\uD83E\\uDD88\\uD83D\\uDC21\\n            fishCaught=fishCaught+grid[row][col];\\n\\n            for(int i=0;i<4;i++){\\n                int nRow = newRows[i] + row;\\n                int nCol = newCols[i] + col;\\n\\n                if(nRow>=0 && nRow<grid.size() && nCol>=0 && nCol<grid[0].size() && !visited[nRow][nCol] && grid[nRow][nCol]){\\n                    q.push({nRow,nCol});\\n                    visited[nRow][nCol]=true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int maxFish=0;\\n        int fishCaught=0;\\n        vector<vector<bool>> visited(rows,vector<bool>(cols,false));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                // check if there are any fishes \\n                // if not visited go fishing\\n                if(!visited[i][j] && grid[i][j]>0){\\n\\n                    bfs(i,j,fishCaught,visited,grid);\\n                    // to find max fishes a fisherman can catch\\n                    maxFish=max(fishCaught,maxFish);\\n                    fishCaught=0;\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void bfs(int i,int j,int &fishCaught,vector<vector<bool>>& visited,vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n\\n        int newRows[]={-1,0,1,0};\\n        int newCols[]={0,1,0,-1};\\n        q.push({i,j});\\n        visited[i][j]=true;\\n\\n        // bfs to go in 4 direction \\n        while(!q.empty()){\\n\\n            int row = q.front().first;\\n            int col= q.front().second;\\n            q.pop();\\n            // Catching fish \\uD83D\\uDC1F\\uD83D\\uDC20\\uD83E\\uDD88\\uD83D\\uDC21\\n            fishCaught=fishCaught+grid[row][col];\\n\\n            for(int i=0;i<4;i++){\\n                int nRow = newRows[i] + row;\\n                int nCol = newCols[i] + col;\\n\\n                if(nRow>=0 && nRow<grid.size() && nCol>=0 && nCol<grid[0].size() && !visited[nRow][nCol] && grid[nRow][nCol]){\\n                    q.push({nRow,nCol});\\n                    visited[nRow][nCol]=true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int maxFish=0;\\n        int fishCaught=0;\\n        vector<vector<bool>> visited(rows,vector<bool>(cols,false));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                // check if there are any fishes \\n                // if not visited go fishing\\n                if(!visited[i][j] && grid[i][j]>0){\\n\\n                    bfs(i,j,fishCaught,visited,grid);\\n                    // to find max fishes a fisherman can catch\\n                    maxFish=max(fishCaught,maxFish);\\n                    fishCaught=0;\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668537,
                "title": "unionfind",
                "content": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        UnionFind dsu = new UnionFind(grid);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                \\n                for (int[] dir : dirs) {\\n                    int x = i + dir[0], y = j + dir[1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)\\n                        continue;\\n                    dsu.union(i, j, x, y);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m * n; i++) \\n            if (dsu.id[i] == i) ans = Math.max(ans, dsu.sum[i]);\\n\\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] id, sum, rank;\\n    int m, n;\\n\\n    public UnionFind(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        id = new int[m*n];\\n        sum = new int[m*n];\\n        rank = new int[m*n];\\n        for (int i = 0; i < m*n; i++) {\\n            id[i] = i; \\n            rank[i] = 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) \\n                sum[i * n + j] = grid[i][j];\\n        }\\n    }\\n\\n    public int find(int x) {\\n        int root = x;\\n        while (id[root] != root)\\n            root = id[root];\\n\\n        return root;\\n    }\\n\\n    public void union(int i, int j, int x, int y) {\\n        int rootX = find(i * n + j), rootY = find(x * n + y);\\n        if (rootX == rootY) return;\\n\\n        if (rank[rootX] >= rank[rootY]) {\\n            rank[rootX] += rank[rootY];\\n            rank[rootY] = 0;\\n            id[rootY] = rootX;\\n            sum[rootX] += sum[rootY];\\n        } else {\\n            rank[rootY] += rank[rootX];\\n            rank[rootX] = 0;\\n            id[rootX] = rootY;\\n            sum[rootY] += sum[rootX];\\n        }\\n \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        UnionFind dsu = new UnionFind(grid);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) continue;\\n                \\n                for (int[] dir : dirs) {\\n                    int x = i + dir[0], y = j + dir[1];\\n                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0)\\n                        continue;\\n                    dsu.union(i, j, x, y);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < m * n; i++) \\n            if (dsu.id[i] == i) ans = Math.max(ans, dsu.sum[i]);\\n\\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] id, sum, rank;\\n    int m, n;\\n\\n    public UnionFind(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        id = new int[m*n];\\n        sum = new int[m*n];\\n        rank = new int[m*n];\\n        for (int i = 0; i < m*n; i++) {\\n            id[i] = i; \\n            rank[i] = 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) \\n                sum[i * n + j] = grid[i][j];\\n        }\\n    }\\n\\n    public int find(int x) {\\n        int root = x;\\n        while (id[root] != root)\\n            root = id[root];\\n\\n        return root;\\n    }\\n\\n    public void union(int i, int j, int x, int y) {\\n        int rootX = find(i * n + j), rootY = find(x * n + y);\\n        if (rootX == rootY) return;\\n\\n        if (rank[rootX] >= rank[rootY]) {\\n            rank[rootX] += rank[rootY];\\n            rank[rootY] = 0;\\n            id[rootY] = rootX;\\n            sum[rootX] += sum[rootY];\\n        } else {\\n            rank[rootY] += rank[rootX];\\n            rank[rootX] = 0;\\n            id[rootX] = rootY;\\n            sum[rootY] += sum[rootX];\\n        }\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667002,
                "title": "c-easy-solution",
                "content": "##### Solution 1: Depth First Search\\n```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        for(int row = 0; row < grid.GetLength(0); row++) {\\n            for(int col = 0; col < grid[row].Length; col++) {\\n                if(grid[row][col] != 0)\\n                    max_fish = Math.Max(max_fish, DFS(grid, row, col));\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int DFS(int[][] grid, int row, int col) {\\n        if(row < 0 || col < 0 || row >= grid.GetLength(0) || col >= grid[row].Length || grid[row][col] == 0)\\n            return 0;\\n\\n        var fish = grid[row][col];\\n        grid[row][col] = 0;\\n\\n        fish += DFS(grid, row + 1, col);\\n        fish += DFS(grid, row - 1, col);\\n        fish += DFS(grid, row, col + 1);\\n        fish += DFS(grid, row, col - 1);\\n\\n        return fish;\\n    }\\n}\\n```\\n\\n##### Solution 2: Union Find\\n```\\n\\npublic class Solution {\\n    int[] rank;\\n    int[] parent;\\n    \\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        var rowCount = grid.GetLength(0);\\n        var columnCount = grid[0].Length;\\n\\n        rank = new int[rowCount * columnCount];\\n        parent = new int[rowCount * columnCount];\\n        \\n        for(int row =  0; row < rowCount; row++) {\\n            for(int col = 0; col < columnCount; col++) {\\n                var idx = row * columnCount + col;\\n                parent[idx] = idx;\\n                rank[idx] = grid[row][col];\\n                max_fish = Math.Max(max_fish, rank[idx]);\\n            }\\n        }\\n\\n        for (int row = 0; row < rowCount; row++) {\\n            for (int col = 0; col < columnCount; col++) {\\n                if (grid[row][col] != 0) {\\n                    var idx = row * columnCount + col;\\n                    if(row < rowCount - 1 && grid[row + 1][col] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, (row + 1) * columnCount + col));\\n\\n                    if(col < columnCount - 1 && grid[row][col + 1] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, row * columnCount + (col + 1)));\\n                }\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int FindParent(int node) {\\n        if (parent[node] == node)\\n            return parent[node];\\n\\n        parent[node] = FindParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    private int Union(int node1, int node2) {\\n        var parent1 = FindParent(node1);\\n        var parent2 = FindParent(node2);\\n\\n        if(parent1 != parent2) {\\n            if (parent1 < parent2) {\\n                rank[parent1] += rank[parent2];\\n                parent[parent2] = parent1;\\n                return rank[parent1];\\n            }\\n            else {\\n                rank[parent2] += rank[parent1];\\n                parent[parent1] = parent2;\\n                return rank[parent2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        for(int row = 0; row < grid.GetLength(0); row++) {\\n            for(int col = 0; col < grid[row].Length; col++) {\\n                if(grid[row][col] != 0)\\n                    max_fish = Math.Max(max_fish, DFS(grid, row, col));\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int DFS(int[][] grid, int row, int col) {\\n        if(row < 0 || col < 0 || row >= grid.GetLength(0) || col >= grid[row].Length || grid[row][col] == 0)\\n            return 0;\\n\\n        var fish = grid[row][col];\\n        grid[row][col] = 0;\\n\\n        fish += DFS(grid, row + 1, col);\\n        fish += DFS(grid, row - 1, col);\\n        fish += DFS(grid, row, col + 1);\\n        fish += DFS(grid, row, col - 1);\\n\\n        return fish;\\n    }\\n}\\n```\n```\\n\\npublic class Solution {\\n    int[] rank;\\n    int[] parent;\\n    \\n    public int FindMaxFish(int[][] grid) {\\n        var max_fish = 0;\\n        var rowCount = grid.GetLength(0);\\n        var columnCount = grid[0].Length;\\n\\n        rank = new int[rowCount * columnCount];\\n        parent = new int[rowCount * columnCount];\\n        \\n        for(int row =  0; row < rowCount; row++) {\\n            for(int col = 0; col < columnCount; col++) {\\n                var idx = row * columnCount + col;\\n                parent[idx] = idx;\\n                rank[idx] = grid[row][col];\\n                max_fish = Math.Max(max_fish, rank[idx]);\\n            }\\n        }\\n\\n        for (int row = 0; row < rowCount; row++) {\\n            for (int col = 0; col < columnCount; col++) {\\n                if (grid[row][col] != 0) {\\n                    var idx = row * columnCount + col;\\n                    if(row < rowCount - 1 && grid[row + 1][col] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, (row + 1) * columnCount + col));\\n\\n                    if(col < columnCount - 1 && grid[row][col + 1] != 0)\\n                        max_fish = Math.Max(max_fish, Union(idx, row * columnCount + (col + 1)));\\n                }\\n            }\\n        }\\n\\n        return max_fish;\\n    }\\n\\n    private int FindParent(int node) {\\n        if (parent[node] == node)\\n            return parent[node];\\n\\n        parent[node] = FindParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    private int Union(int node1, int node2) {\\n        var parent1 = FindParent(node1);\\n        var parent2 = FindParent(node2);\\n\\n        if(parent1 != parent2) {\\n            if (parent1 < parent2) {\\n                rank[parent1] += rank[parent2];\\n                parent[parent2] = parent1;\\n                return rank[parent1];\\n            }\\n            else {\\n                rank[parent2] += rank[parent1];\\n                parent[parent1] = parent2;\\n                return rank[parent2];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665865,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void dfs(vector<vector<int>> &grid,int x,int y,int *curr)\\n    {\\n        if(x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y]==0)\\n        {\\n            return;\\n        }\\n\\n        *curr+=grid[x][y];\\n        grid[x][y]=0;\\n\\n        dfs(grid,x+1,y,curr);\\n        dfs(grid,x-1,y,curr);\\n        dfs(grid,x,y+1,curr);\\n        dfs(grid,x,y-1,curr);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int ans;\\n        ans=0;\\n\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int curr=0;\\n                    dfs(grid,i,j,&curr);\\n                    ans=max(ans,curr);\\n                }\\n            }\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void dfs(vector<vector<int>> &grid,int x,int y,int *curr)\\n    {\\n        if(x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y]==0)\\n        {\\n            return;\\n        }\\n\\n        *curr+=grid[x][y];\\n        grid[x][y]=0;\\n\\n        dfs(grid,x+1,y,curr);\\n        dfs(grid,x-1,y,curr);\\n        dfs(grid,x,y+1,curr);\\n        dfs(grid,x,y-1,curr);\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int ans;\\n        ans=0;\\n\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    int curr=0;\\n                    dfs(grid,i,j,&curr);\\n                    ans=max(ans,curr);\\n                }\\n            }\\n        }    \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663430,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int r , int c , vector<vector<int>>& grid , vector<vector<int>>& vis , vector<int> delRow , vector<int> delCol , int m , int n , int& sum){\\n        sum += grid[r][c];\\n        vis[r][c] = 1;\\n\\n        for (int i=0 ; i<4 ; i++){\\n            int nr = r + delRow[i];\\n            int nc = c + delCol[i];\\n\\n            if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc] && grid[nr][nc]>0){\\n                dfs(nr , nc , grid, vis , delRow , delCol , m , n , sum);\\n            }\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=-1e9;\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vector<int> delRow = {-1 , 0 , 1 , 0};\\n        vector<int> delCol = {0 , 1 , 0 , -1};\\n\\n        for (int i=0 ; i<m ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                int sum = 0;\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    dfs(i , j , grid , vis , delRow , delCol , m , n , sum);\\n                    maxi = max(maxi , sum);\\n                }\\n            }\\n        }\\n        if (maxi < 0)\\n            return 0;\\n            \\n        return maxi;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int r , int c , vector<vector<int>>& grid , vector<vector<int>>& vis , vector<int> delRow , vector<int> delCol , int m , int n , int& sum){\\n        sum += grid[r][c];\\n        vis[r][c] = 1;\\n\\n        for (int i=0 ; i<4 ; i++){\\n            int nr = r + delRow[i];\\n            int nc = c + delCol[i];\\n\\n            if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc] && grid[nr][nc]>0){\\n                dfs(nr , nc , grid, vis , delRow , delCol , m , n , sum);\\n            }\\n        }\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=-1e9;\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vector<int> delRow = {-1 , 0 , 1 , 0};\\n        vector<int> delCol = {0 , 1 , 0 , -1};\\n\\n        for (int i=0 ; i<m ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                int sum = 0;\\n                if (!vis[i][j] && grid[i][j]>0){\\n                    dfs(i , j , grid , vis , delRow , delCol , m , n , sum);\\n                    maxi = max(maxi , sum);\\n                }\\n            }\\n        }\\n        if (maxi < 0)\\n            return 0;\\n            \\n        return maxi;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662617,
                "title": "recusion-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n   recursion approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  static int sum;\\n    public static void util(int grid[][],int row,int col){\\n\\n        if(row<0 ||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]==0){\\n            return ;\\n        }\\n        sum+=grid[row][col];\\n        grid[row][col]=0;\\n       //checking fishes all four direction of grid\\n        util(grid,row+1,col);\\n        util(grid,row-1,col);\\n        util(grid,row,col+1);\\n        util(grid,row,col-1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int  max=0;\\n       \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    this.sum=0;\\n                    util(grid,i,j);\\n                    max=Math.max(max,this.sum);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  static int sum;\\n    public static void util(int grid[][],int row,int col){\\n\\n        if(row<0 ||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]==0){\\n            return ;\\n        }\\n        sum+=grid[row][col];\\n        grid[row][col]=0;\\n       //checking fishes all four direction of grid\\n        util(grid,row+1,col);\\n        util(grid,row-1,col);\\n        util(grid,row,col+1);\\n        util(grid,row,col-1);\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int  max=0;\\n       \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0){\\n                    this.sum=0;\\n                    util(grid,i,j);\\n                    max=Math.max(max,this.sum);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661397,
                "title": "bfs-dfs-both-java-code",
                "content": "class pair{\\n    int first;\\n    int second;\\n    pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] vis=new int[n][m];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0){\\n                    max=Math.max(bfs(i,j,grid,vis),max);\\n                }\\n            }\\n        }\\n        if(max>=0){\\n             return max;\\n        }\\n        return 0;\\n    }\\n    // public int dfs(int i,int j,int[][] grid,int[][] vis){\\n    //     if(i>=0 && j>=0 && i<grid.length && j<grid[0].length && grid[i][j]!=0 && vis[i][j]==0){\\n    //         vis[i][j]=1;\\n    //         return grid[i][j]+dfs(i+1,j,grid,vis)+dfs(i,j+1,grid,vis)+dfs(i-1,j,grid,vis)+dfs(i,j-1,grid,vis);\\n    //     }\\n    //     return 0;\\n    //     }\\n    public int bfs(int i,int j,int[][] grid,int[][]vis){\\n        vis[i][j]=1;\\n        Queue<pair> q=new LinkedList<>();\\n        int sum=grid[i][j];\\n        q.add(new pair(i,j));\\n        int dir[]={0,-1,0,1,0};\\n        while(!q.isEmpty()){\\n            int x=q.peek().first;\\n            int y=q.peek().second;\\n            q.remove();\\n            for(int k=0;k<4;k++){\\n                int nrow=x+dir[k];\\n                int ncol=y+dir[k+1];\\n            if(nrow>=0 && ncol>=0 && nrow<grid.length && ncol<grid[0].length && grid[nrow][ncol]!=0 && vis[nrow][ncol]==0){\\n                vis[nrow][ncol]=1;\\n                sum+=grid[nrow][ncol];\\n                q.add(new pair(nrow,ncol));\\n            }\\n            }\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] vis=new int[n][m];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]!=0){\\n                    max=Math.max(bfs(i,j,grid,vis),max);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3660334,
                "title": "simulated-c-dsu-dfs",
                "content": "\\n# Complexity\\n- Time complexity: $$O(m*n * m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n + m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<bool>>&visited, vector<vector<int>>&grid)\\n    {\\n        int ans=grid[i][j];\\n        visited[i][j]=true;\\n        if(i+1<grid.size() && !visited[i+1][j] && grid[i+1][j]!=0) ans = ans + dfs(i+1,j,visited,grid);\\n        if(j+1<grid[0].size() && !visited[i][j+1] && grid[i][j+1]!=0) ans = ans + dfs(i,j+1,visited,grid);\\n        if(i-1>=0 && !visited[i-1][j] && grid[i-1][j]!=0) ans = ans + dfs(i-1,j,visited,grid);\\n        if(j-1>=0 && !visited[i][j-1] && grid[i][j-1]!=0) ans = ans + dfs(i,j-1,visited,grid);\\n        return ans;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        int ans=0;\\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!=0)\\n                {\\n                    ans=max(ans,dfs(i,j,visited,grid));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(m*n *)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n )$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findparent(int node, vector<pair<int,int>>&parent)\\n    {\\n        if(node==parent[node].first) return node;\\n        return parent[node].first=findparent(parent[node].first,parent);\\n    }\\n    void Union(int u, int v, vector<pair<int,int>>&parent, vector<int>&rank)\\n    {\\n        int pu = findparent(u,parent);\\n        int pv = findparent(v, parent);\\n        if(pu==pv) return;\\n        else if(rank[pu]<rank[pv]) \\n        {\\n            parent[pu].first = pv;\\n            parent[pv].second +=parent[pu].second;\\n        }\\n        else if(rank[pv]<rank[pu]) \\n        {\\n            parent[pv].first =pu;\\n            parent[pu].second +=parent[pv].second;\\n        }\\n        else\\n        {\\n            parent[pv].first=pu;\\n            parent[pu].second +=parent[pv].second;\\n            rank[pu]++;\\n        }\\n    }\\n    bool isvalid(int i, int j, int m, int n)\\n    {\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n         std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<pair<int,int>>parent(m*n);\\n        vector<int>rank(m*n,0);\\n        for(int i =0;i<(m*n);i++)\\n        {\\n            int a = i/n;\\n            int b = i%n;\\n            parent[i]={i,grid[a][b]};\\n        }\\n        for(int a=0;a<(m*n);a++)\\n        {\\n            int i  = a/n;\\n            int j = a%n;\\n            if(grid[i][j]!=0)\\n            {\\n                if(isvalid(i+1,j,m,n) && grid[i+1][j]!=0)\\n                {\\n                    int b = (i+1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i-1,j,m,n) && grid[i-1][j]!=0)\\n                {\\n                    int b = (i-1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j+1,m,n) && grid[i][j+1]!=0)\\n                {\\n                    int b = (i)*n+(j+1);\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j-1,m,n) && grid[i][j-1]!=0)\\n                {\\n                    int b = (i)*n+(j-1);\\n                    Union(a,b,parent, rank);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i =0;i<parent.size();i++)\\n        {\\n            ans=max(ans,parent[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<bool>>&visited, vector<vector<int>>&grid)\\n    {\\n        int ans=grid[i][j];\\n        visited[i][j]=true;\\n        if(i+1<grid.size() && !visited[i+1][j] && grid[i+1][j]!=0) ans = ans + dfs(i+1,j,visited,grid);\\n        if(j+1<grid[0].size() && !visited[i][j+1] && grid[i][j+1]!=0) ans = ans + dfs(i,j+1,visited,grid);\\n        if(i-1>=0 && !visited[i-1][j] && grid[i-1][j]!=0) ans = ans + dfs(i-1,j,visited,grid);\\n        if(j-1>=0 && !visited[i][j-1] && grid[i][j-1]!=0) ans = ans + dfs(i,j-1,visited,grid);\\n        return ans;\\n\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        int ans=0;\\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!=0)\\n                {\\n                    ans=max(ans,dfs(i,j,visited,grid));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findparent(int node, vector<pair<int,int>>&parent)\\n    {\\n        if(node==parent[node].first) return node;\\n        return parent[node].first=findparent(parent[node].first,parent);\\n    }\\n    void Union(int u, int v, vector<pair<int,int>>&parent, vector<int>&rank)\\n    {\\n        int pu = findparent(u,parent);\\n        int pv = findparent(v, parent);\\n        if(pu==pv) return;\\n        else if(rank[pu]<rank[pv]) \\n        {\\n            parent[pu].first = pv;\\n            parent[pv].second +=parent[pu].second;\\n        }\\n        else if(rank[pv]<rank[pu]) \\n        {\\n            parent[pv].first =pu;\\n            parent[pu].second +=parent[pv].second;\\n        }\\n        else\\n        {\\n            parent[pv].first=pu;\\n            parent[pu].second +=parent[pv].second;\\n            rank[pu]++;\\n        }\\n    }\\n    bool isvalid(int i, int j, int m, int n)\\n    {\\n        if(i>=0 && i<m && j>=0 && j<n) return true;\\n        return false;\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) \\n    {\\n         std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<pair<int,int>>parent(m*n);\\n        vector<int>rank(m*n,0);\\n        for(int i =0;i<(m*n);i++)\\n        {\\n            int a = i/n;\\n            int b = i%n;\\n            parent[i]={i,grid[a][b]};\\n        }\\n        for(int a=0;a<(m*n);a++)\\n        {\\n            int i  = a/n;\\n            int j = a%n;\\n            if(grid[i][j]!=0)\\n            {\\n                if(isvalid(i+1,j,m,n) && grid[i+1][j]!=0)\\n                {\\n                    int b = (i+1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i-1,j,m,n) && grid[i-1][j]!=0)\\n                {\\n                    int b = (i-1)*n+j;\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j+1,m,n) && grid[i][j+1]!=0)\\n                {\\n                    int b = (i)*n+(j+1);\\n                    Union(a,b,parent, rank);\\n                }\\n                if(isvalid(i,j-1,m,n) && grid[i][j-1]!=0)\\n                {\\n                    int b = (i)*n+(j-1);\\n                    Union(a,b,parent, rank);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i =0;i<parent.size();i++)\\n        {\\n            ans=max(ans,parent[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3657185,
                "title": "c-easy-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int bfs(int row,int col,vector<vector<int>>&grid,vector<vector<int>>&visited)\\n    {\\n        int count =0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n        int del_row[]= {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        while(!q.empty())\\n        {\\n\\n            int ro = q.front().first;\\n            int cl = q.front().second;\\n\\n            \\n            count +=grid[ro][cl];\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n\\n                int ne_row = ro+del_row[i];\\n                int ne_col = cl+del_col[i];\\n                if(ne_row<m && ne_row>=0 && ne_col <n && ne_col>=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]!=0)\\n                {\\n                    \\n                    visited[ne_row][ne_col]=1;\\n                    q.push({ne_row,ne_col});\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int>fishes;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!= 0)\\n                {\\n\\n                    fishes.push_back(bfs(i,j,grid,visited));\\n                }\\n            }\\n        }\\n\\n        \\n        if(fishes.size()>0)\\n        {\\n            int max_fish=fishes[0];\\n            for(int i=0;i<fishes.size();i++)\\n            {\\n                if(fishes[i]>max_fish)\\n                {\\n                    max_fish= fishes[i];\\n                }\\n            }\\n            return max_fish;\\n        }\\n        return 0;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int bfs(int row,int col,vector<vector<int>>&grid,vector<vector<int>>&visited)\\n    {\\n        int count =0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n        int del_row[]= {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        while(!q.empty())\\n        {\\n\\n            int ro = q.front().first;\\n            int cl = q.front().second;\\n\\n            \\n            count +=grid[ro][cl];\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n\\n                int ne_row = ro+del_row[i];\\n                int ne_col = cl+del_col[i];\\n                if(ne_row<m && ne_row>=0 && ne_col <n && ne_col>=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]!=0)\\n                {\\n                    \\n                    visited[ne_row][ne_col]=1;\\n                    q.push({ne_row,ne_col});\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int>fishes;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j]!= 0)\\n                {\\n\\n                    fishes.push_back(bfs(i,j,grid,visited));\\n                }\\n            }\\n        }\\n\\n        \\n        if(fishes.size()>0)\\n        {\\n            int max_fish=fishes[0];\\n            for(int i=0;i<fishes.size();i++)\\n            {\\n                if(fishes[i]>max_fish)\\n                {\\n                    max_fish= fishes[i];\\n                }\\n            }\\n            return max_fish;\\n        }\\n        return 0;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649008,
                "title": "maximum-number-of-fish-in-a-grid-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int r, int c) {\\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] == 0) {\\n        return 0; // Base case: out of bounds or land cell\\n    }\\n    int fishCaught = grid[r][c]; // Catch fish at current cell\\n    grid[r][c] = 0; // Mark cell as caught\\n    int moves[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; // Possible movements\\n    for (int i = 0; i < 4; i++) {\\n        int newR = r + moves[i][0];\\n        int newC = c + moves[i][1];\\n        fishCaught += dfs(grid, newR, newC); // Recursively search adjacent cells\\n    }\\n    return fishCaught;\\n}\\n\\nint findMaxFish(vector<vector<int>>& grid) {\\n    int maxFish = 0;\\n    for (int i = 0; i < grid.size(); i++) {\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            if (grid[i][j] > 0) { // Start DFS search from water cell\\n                int fishCaught = dfs(grid, i, j);\\n                maxFish = max(maxFish, fishCaught);\\n            }\\n        }\\n    }\\n    return maxFish;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644249,
                "title": "dfs-approach-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is similar to \"Max Area of Island\" question with oneline variation.\\nhttps://leetcode.com/problems/max-area-of-island/\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// it will store the answer.\\nint ans=0;\\nvoid dfs(int row,int col,int&fish,vector<vector<int>>&visited,vector<vector<int>>&grid)\\n    {\\n\\n        // variation.\\n        fish+= grid[row][col];\\n\\n        visited[row][col]=1;\\n       \\n\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n\\n            if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && !visited[nrow][ncol] &&grid[nrow][ncol])\\n            {               \\n                dfs(nrow,ncol,fish,visited,grid);            \\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j])\\n                {\\n                    int fish=0;\\n                    dfs(i,j,fish,visited,grid);\\n\\n                    // store the max answer.\\n                    ans = max(ans,fish);\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// it will store the answer.\\nint ans=0;\\nvoid dfs(int row,int col,int&fish,vector<vector<int>>&visited,vector<vector<int>>&grid)\\n    {\\n\\n        // variation.\\n        fish+= grid[row][col];\\n\\n        visited[row][col]=1;\\n       \\n\\n        int drow[] = {-1,0,1,0};\\n        int dcol[] = {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n\\n            if(nrow>=0 && ncol>=0 && nrow<grid.size() && ncol<grid[0].size() && !visited[nrow][ncol] &&grid[nrow][ncol])\\n            {               \\n                dfs(nrow,ncol,fish,visited,grid);            \\n            }\\n        }\\n    }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j] && grid[i][j])\\n                {\\n                    int fish=0;\\n                    dfs(i,j,fish,visited,grid);\\n\\n                    // store the max answer.\\n                    ans = max(ans,fish);\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636773,
                "title": "golang-dfs-simple",
                "content": "# Code\\n```\\nfunc findMaxFish(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var res int\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if grid[i][j] != 0 {\\n        res = max(res, dfs(grid, i, j))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc dfs(grid [][]int, row, col int) int {\\n  res := grid[row][col]\\n  grid[row][col] = 0\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {0, 1}, {1, 0}}\\n  for _, dir := range directions {\\n    x, y := row + dir[0], col + dir[1]\\n    if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] > 0 {\\n      res += dfs(grid, x, y)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc findMaxFish(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var res int\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      if grid[i][j] != 0 {\\n        res = max(res, dfs(grid, i, j))\\n      }\\n    }\\n  }\\n  return res\\n}\\n\\nfunc dfs(grid [][]int, row, col int) int {\\n  res := grid[row][col]\\n  grid[row][col] = 0\\n  directions := [4][2]int{{-1, 0}, {0, -1}, {0, 1}, {1, 0}}\\n  for _, dir := range directions {\\n    x, y := row + dir[0], col + dir[1]\\n    if x >= 0 && x < len(grid) && y >= 0 && y < len(grid[x]) && grid[x][y] > 0 {\\n      res += dfs(grid, x, y)\\n    }\\n  }\\n  return res\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3636025,
                "title": "c-dfs-graph-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &count){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]==0)\\n    return ;\\n    visited[i][j] = 1;\\n    count += grid[i][j];\\n    \\n    dfs(grid, visited, i+1, j, count);\\n    dfs(grid, visited, i-1, j, count);\\n    dfs(grid, visited, i, j+1, count);\\n    dfs(grid, visited, i, j-1, count);\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        vector<vector<int>> visited(n, vector<int> (m, 0));\\n\\n        for(int i=0 ;i<n ;i++){\\n            for(int j=0 ;j<m ;j++){\\n        \\n                int count = 0;\\n                if(!visited[i][j] && grid[i][j]>0)\\n                dfs(grid, visited, i, j, count);\\n                ans = max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &count){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]==0)\\n    return ;\\n    visited[i][j] = 1;\\n    count += grid[i][j];\\n    \\n    dfs(grid, visited, i+1, j, count);\\n    dfs(grid, visited, i-1, j, count);\\n    dfs(grid, visited, i, j+1, count);\\n    dfs(grid, visited, i, j-1, count);\\n}\\n    int findMaxFish(vector<vector<int>>& grid) {\\n\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        vector<vector<int>> visited(n, vector<int> (m, 0));\\n\\n        for(int i=0 ;i<n ;i++){\\n            for(int j=0 ;j<m ;j++){\\n        \\n                int count = 0;\\n                if(!visited[i][j] && grid[i][j]>0)\\n                dfs(grid, visited, i, j, count);\\n                ans = max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635164,
                "title": "java-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int sum;\\n    public int findMaxFish(int[][] grid) {\\n        sum = 0;\\n        int max = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                dfs(grid,i,j);\\n                max = Math.max(max,sum);\\n                sum=0;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j){\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){\\n            return;\\n        }\\n         sum = sum + grid[i][j];\\n         grid[i][j]=0;\\n         dfs(grid,i+1,j);\\n         dfs(grid,i-1,j);\\n         dfs(grid,i,j+1);\\n         dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int sum;\\n    public int findMaxFish(int[][] grid) {\\n        sum = 0;\\n        int max = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                dfs(grid,i,j);\\n                max = Math.max(max,sum);\\n                sum=0;\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j){\\n        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){\\n            return;\\n        }\\n         sum = sum + grid[i][j];\\n         grid[i][j]=0;\\n         dfs(grid,i+1,j);\\n         dfs(grid,i-1,j);\\n         dfs(grid,i,j+1);\\n         dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620887,
                "title": "easy-dfs-solution-beats-100-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private int dfs(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n\\n        grid[i][j] = 0;\\n\\n        val += dfs(grid, i+1, j);\\n        val += dfs(grid, i, j+1);\\n        val += dfs(grid, i-1, j);\\n        val += dfs(grid, i, j-1);\\n\\n        return val;\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0){\\n                    ans = Math.max(ans,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int dfs(int[][] grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0){\\n            return 0;\\n        }\\n\\n        int val = grid[i][j];\\n\\n        grid[i][j] = 0;\\n\\n        val += dfs(grid, i+1, j);\\n        val += dfs(grid, i, j+1);\\n        val += dfs(grid, i-1, j);\\n        val += dfs(grid, i, j-1);\\n\\n        return val;\\n    }\\n\\n    public int findMaxFish(int[][] grid) {\\n        int ans = 0;\\n\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0){\\n                    ans = Math.max(ans,dfs(grid,i,j));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620603,
                "title": "java-dfs-solution-using-striver-concept-visited-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int sum;\\n    public void dfs(int grid[][],int row,int col,int vis[][]){\\n        sum+=grid[row][col];\\n        vis[row][col]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int r=row+drow[i];\\n            int c=col+dcol[i];\\n\\n            if(r>=0&&r<grid.length&&c>=0&&c<grid[0].length&&grid[r][c]!=0&&vis[r][c]==0){\\n                dfs(grid,r,c,vis);\\n            }\\n        }\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int vis[][]=new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0 && vis[i][j]==0){\\n                   sum=0;  \\n                  dfs(grid,i,j,vis);\\n                  max=Math.max(sum,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int sum;\\n    public void dfs(int grid[][],int row,int col,int vis[][]){\\n        sum+=grid[row][col];\\n        vis[row][col]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int r=row+drow[i];\\n            int c=col+dcol[i];\\n\\n            if(r>=0&&r<grid.length&&c>=0&&c<grid[0].length&&grid[r][c]!=0&&vis[r][c]==0){\\n                dfs(grid,r,c,vis);\\n            }\\n        }\\n    }\\n    public int findMaxFish(int[][] grid) {\\n        int max=0;\\n        int vis[][]=new int[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]!=0 && vis[i][j]==0){\\n                   sum=0;  \\n                  dfs(grid,i,j,vis);\\n                  max=Math.max(sum,max);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620196,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\ntypedef struct\\n{\\n    int **grid;\\n    int x;\\n    int y;\\n    int **visited;\\n}stGrid;\\n\\nvoid recrusion(stGrid *field,int cur_x, int cur_y, int *cur_greb, int *maxFish)\\n{\\n    if((cur_x < 0 || cur_x >= field->x) || (cur_y < 0 || cur_y >= field->y) || \\n                field->grid[cur_y][cur_x] == 0 || field->visited[cur_y][cur_x])\\n    {\\n        *maxFish = (*cur_greb>*maxFish)?(*cur_greb):(*maxFish);\\n    }\\n    else\\n    {\\n        if(field->visited[cur_y][cur_x] != 1)\\n        {\\n            *cur_greb += field->grid[cur_y][cur_x];\\n        }\\n        field->visited[cur_y][cur_x] = 1;\\n        recrusion(field,cur_x + 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y - 1, cur_greb, maxFish);\\n        recrusion(field,cur_x - 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y + 1, cur_greb, maxFish);\\n    }\\n}\\n\\n\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n\\n    stGrid field;\\n    field.grid = grid;\\n    field.y = gridSize;\\n    field.x = *gridColSize;\\n    field.visited = (int**)calloc(field.y, sizeof(int*)); \\n    for(int i = 0; i < field.y; i++)\\n    {\\n        field.visited[i] = (int*)calloc(field.x, sizeof(int));\\n    }\\n\\n    int maxFish = 0;\\n    int temp_Fish = 0;\\n    for(int row = 0; row < field.y ; row++)\\n    {\\n        for(int col = 0; col < field.x; col++)\\n        {\\n            recrusion(&field, col, row, &temp_Fish, &maxFish);\\n            temp_Fish = 0;\\n        }\\n    }\\n\\n    return maxFish;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\ntypedef struct\\n{\\n    int **grid;\\n    int x;\\n    int y;\\n    int **visited;\\n}stGrid;\\n\\nvoid recrusion(stGrid *field,int cur_x, int cur_y, int *cur_greb, int *maxFish)\\n{\\n    if((cur_x < 0 || cur_x >= field->x) || (cur_y < 0 || cur_y >= field->y) || \\n                field->grid[cur_y][cur_x] == 0 || field->visited[cur_y][cur_x])\\n    {\\n        *maxFish = (*cur_greb>*maxFish)?(*cur_greb):(*maxFish);\\n    }\\n    else\\n    {\\n        if(field->visited[cur_y][cur_x] != 1)\\n        {\\n            *cur_greb += field->grid[cur_y][cur_x];\\n        }\\n        field->visited[cur_y][cur_x] = 1;\\n        recrusion(field,cur_x + 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y - 1, cur_greb, maxFish);\\n        recrusion(field,cur_x - 1, cur_y, cur_greb, maxFish);\\n        recrusion(field,cur_x, cur_y + 1, cur_greb, maxFish);\\n    }\\n}\\n\\n\\n\\nint findMaxFish(int** grid, int gridSize, int* gridColSize){\\n\\n    stGrid field;\\n    field.grid = grid;\\n    field.y = gridSize;\\n    field.x = *gridColSize;\\n    field.visited = (int**)calloc(field.y, sizeof(int*)); \\n    for(int i = 0; i < field.y; i++)\\n    {\\n        field.visited[i] = (int*)calloc(field.x, sizeof(int));\\n    }\\n\\n    int maxFish = 0;\\n    int temp_Fish = 0;\\n    for(int row = 0; row < field.y ; row++)\\n    {\\n        for(int col = 0; col < field.x; col++)\\n        {\\n            recrusion(&field, col, row, &temp_Fish, &maxFish);\\n            temp_Fish = 0;\\n        }\\n    }\\n\\n    return maxFish;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3618242,
                "title": "java-5ms-99-dfs-and-clean-code",
                "content": "# Approach: DFS\\n1. For i =0..n, j = 0..m, if current cell is water, jump on it and try catching the max nr of fish. Keep track of max number of fish\\n2. Catching fish: recursive function that takes, grid, i, j and returns the max number of fish\\n    - if i,j outside the bounds or current cell is land, return 0\\n    - else add current cell to a return answer, set current cell to 0 and try fishing in the 4 directions, adding their values to return answer.\\n    - return the answer for this function call.  \\n3. Method #2 will traverse all linked water calls, catch their fish and marking the cells with 0.\\n4. #1 will then ignore these already fished cells.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) {\\n                    maxFish = Math.max(maxFish, catchFish(grid, i, j));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int catchFish(int[][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += catchFish(grid, i-1, j) + catchFish(grid, i, j+1) + catchFish(grid, i+1, j) + catchFish(grid, i, j-1);\\n        return fish;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int maxFish = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) {\\n                    maxFish = Math.max(maxFish, catchFish(grid, i, j));\\n                }\\n            }\\n        }\\n        return maxFish;\\n    }\\n\\n    private int catchFish(int[][] grid, int i, int j) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\\n            return 0;\\n        }\\n        int fish = grid[i][j];\\n        grid[i][j] = 0;\\n        fish += catchFish(grid, i-1, j) + catchFish(grid, i, j+1) + catchFish(grid, i+1, j) + catchFish(grid, i, j-1);\\n        return fish;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607455,
                "title": "simple-dfs-c",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dfs(vector<vector<int>>& grid,int i,int j,vector<vector<int>> &vis){\\n   if(vis[i][j]==1 || grid[i][j]<=0)return 0;\\n   int ans=grid[i][j];\\n   vis[i][j]=1;\\n   if(i>0)ans+=dfs(grid,i-1,j,vis);\\n   if(j>0)ans+=dfs(grid,i,j-1,vis);\\n   if(i<grid.size()-1)ans+=dfs(grid,i+1,j,vis);\\n   if(j<grid[0].size()-1)ans+=dfs(grid,i,j+1,vis);\\n   return ans;\\n   }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=0;\\n        for(int i=0;i<grid.size();i++){\\n            vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n            for(int j=0;j<grid[0].size();j++){\\n            if(grid[i][j]>0 ){\\n            maxi=max(maxi,dfs(grid,i,j,vis));\\n           // cout<<maxi<<\" \"<<i<<\" \"<<j<<\"\\\\n\";\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dfs(vector<vector<int>>& grid,int i,int j,vector<vector<int>> &vis){\\n   if(vis[i][j]==1 || grid[i][j]<=0)return 0;\\n   int ans=grid[i][j];\\n   vis[i][j]=1;\\n   if(i>0)ans+=dfs(grid,i-1,j,vis);\\n   if(j>0)ans+=dfs(grid,i,j-1,vis);\\n   if(i<grid.size()-1)ans+=dfs(grid,i+1,j,vis);\\n   if(j<grid[0].size()-1)ans+=dfs(grid,i,j+1,vis);\\n   return ans;\\n   }\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int maxi=0;\\n        for(int i=0;i<grid.size();i++){\\n            vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n            for(int j=0;j<grid[0].size();j++){\\n            if(grid[i][j]>0 ){\\n            maxi=max(maxi,dfs(grid,i,j,vis));\\n           // cout<<maxi<<\" \"<<i<<\" \"<<j<<\"\\\\n\";\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3602081,
                "title": "most-intuitive-c-solution-dfs",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int di[4] = {1, -1, 0, 0}, dj[4] = {0, 0, 1, -1};\\n    \\n    bool ok(int i, int j, vector<vector<int>>& grid) {\\n        return i >= 0 && i < grid.size() &&\\n               j >= 0 && j < grid[0].size() &&\\n               grid[i][j] != 0;\\n    }\\n\\n    int dfs(int i, int j, vector<vector<int>>& grid) {\\n        int res = grid[i][j];\\n        grid[i][j] = 0;\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + di[k];\\n            int c = j + dj[k];\\n            if (ok(r, c, grid)) res += dfs(r, c, grid);\\n        }\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int cnt = dfs(i, j, grid);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int di[4] = {1, -1, 0, 0}, dj[4] = {0, 0, 1, -1};\\n    \\n    bool ok(int i, int j, vector<vector<int>>& grid) {\\n        return i >= 0 && i < grid.size() &&\\n               j >= 0 && j < grid[0].size() &&\\n               grid[i][j] != 0;\\n    }\\n\\n    int dfs(int i, int j, vector<vector<int>>& grid) {\\n        int res = grid[i][j];\\n        grid[i][j] = 0;\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + di[k];\\n            int c = j + dj[k];\\n            if (ok(r, c, grid)) res += dfs(r, c, grid);\\n        }\\n        return res;\\n    }\\n\\n    int findMaxFish(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) continue;\\n                int cnt = dfs(i, j, grid);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593140,
                "title": "java-solution-simple-dfs-99-fast",
                "content": "# Approach\\n**DFS** through every non-zero cell, and add up all the numbers found on the way. Also, mark all the cells as 0, so they won\\'t be parsed again.\\nEvery DFS dive will get back a number, that will be the maximum number of fishes caught starting from current cell, as well as from any cell that was visited.No need to do it again from every cell.\\nBiggest number returned among all dfs dives will be the answer.\\n\\n# Complexity\\nLet rows and columns be denoted by ```row```, ```col```\\n- Time complexity:\\nAt worst case parsing of every cell in the grid:$$O(row*col)$$\\n**Total: $$O(row * col)$$**\\n\\n- Space complexity:\\nExcluding input: **$$O(1)$$**\\nIncluding input: **$$O(row * col)$$**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int row = grid.length,col = grid[0].length;\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j] == 0) continue;\\n                int count = dfs(grid,i,j,row,col);\\n                max = Math.max(max,count);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    int dfs(int[][] arr,int i,int j,int row,int col){\\n        if(i<0 || j<0 || i>=row || j>=col) return 0;\\n        if(arr[i][j] == 0) return 0;\\n        int count = arr[i][j];\\n        arr[i][j] = 0;\\n\\n        count+=dfs(arr,i+1,j,row,col);\\n        count+=dfs(arr,i,j+1,row,col);\\n        count+=dfs(arr,i-1,j,row,col);\\n        count+=dfs(arr,i,j-1,row,col);\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```row```\n```col```\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int max = 0;\\n        int row = grid.length,col = grid[0].length;\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j] == 0) continue;\\n                int count = dfs(grid,i,j,row,col);\\n                max = Math.max(max,count);\\n            }\\n        }\\n        return max;\\n    }\\n\\n    int dfs(int[][] arr,int i,int j,int row,int col){\\n        if(i<0 || j<0 || i>=row || j>=col) return 0;\\n        if(arr[i][j] == 0) return 0;\\n        int count = arr[i][j];\\n        arr[i][j] = 0;\\n\\n        count+=dfs(arr,i+1,j,row,col);\\n        count+=dfs(arr,i,j+1,row,col);\\n        count+=dfs(arr,i-1,j,row,col);\\n        count+=dfs(arr,i,j-1,row,col);\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1877160,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877329,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1878212,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877308,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877396,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877159,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877341,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1921099,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1894798,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877371,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877160,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877329,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1878212,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877308,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877396,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877159,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877341,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1921099,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1894798,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            },
            {
                "id": 1877371,
                "content": [
                    {
                        "username": "15o1",
                        "content": "This should be a medium problem"
                    },
                    {
                        "username": "jameshsw",
                        "content": "The problem could use a clearer description, such as 'Return the maximum number of fish the fisher can catch \"in all the connected water cells\" if he chooses his starting cell optimally'"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes this is important point to be noted."
                    },
                    {
                        "username": "adis176",
                        "content": "The question is really quite ambiguous. It needs to be defined properly. \\nThis test-case can help: \\n[[4, 5, 5], [0, 10, 0]] -> its correct answer will be 24.\\nHope this helps to clarify the problem."
                    },
                    {
                        "username": "ips2105",
                        "content": "Thought once you collect the fishes from a cell, you can\\'t come back. . The question should clarify this :("
                    },
                    {
                        "username": "adis176",
                        "content": "Actually you can. It is not DFS (traversal from start point to any one end, it is the complete traversal of all possible points from your chosen starting point. \\nThis question was in the biweekly contest 103, and initially I failed at the test-case [[4, 5, 5], [0, 10, 0]] -> Its correct answer was 24. \\nThough I agree that the question is quite ambiguous."
                    },
                    {
                        "username": "rishiagarwal-lc",
                        "content": "WTH! it must be ranked above hard, leetcode should ban such problem setters:)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s pretty much this problem, but with variable numbers instead of only 1\\'s: https://leetcode.com/problems/max-area-of-island/\\nI don\\'t see why the difficulty would be different. good BFS problem though."
                    },
                    {
                        "username": "amitbansal13",
                        "content": "There are medium classified problems much much harder than this. This is definitely wrongly classified."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "poorly described statement"
                    },
                    {
                        "username": "gadmo",
                        "content": "that should be easy level just saying, literally 2 minutes start to working submission , cant get more straight forward dfs than this ."
                    },
                    {
                        "username": "Mohamed_1",
                        "content": "why this code wrong at this case ! \n[[6,1,10]]  \n`\n\n    def findMaxFish(self, grid: List[List[int]]) -> int:\n        n , m = len(grid) , len(grid[0])\n        directions = [(1 , 0) ,(-1 , 0) ,(0 , 1) ,(0 , -1)]\n\n        def dfs(i , j):\n            if( i < 0 or i == n or \n               j < 0 or j == m or\n               grid[i][j] == 0): return 0\n\n            fish = grid[i][j]\n            print(fish)\n            grid[i][j] = 0\n            for x,y in directions:\n                self.res+=dfs(i+x , y+j)\n            return fish\n\n\n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    self.res = grid[i][j]\n                    dfs(i , j)\n                    mx = max(mx , self.res )\n        return mx\n`\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current DFS function doesn\\'t look for the optimal path. Instead, it traverses the grid in the order of the directions list, without considering which move would yield the most fish.\\n\\nA key part of this problem is that the fisher can choose the order of his moves optimally, meaning he doesn\\'t just go to the first non-zero cell he finds, but instead he should always move to the adjacent cell with the most fish.\\n\\nIn order to fix the function, you should change the DFS so that it always moves to the adjacent cell with the most fish. To do this, you should add a step to find the max fish in all adjacent cells, and only then call the DFS function recursively.\\n"
                    },
                    {
                        "username": "wataru",
                        "content": "In the dfs you return |fish| but you need to return sum of |fish| and the sum of recursive results."
                    }
                ]
            }
        ]
    },
    {
        "title": "Make Costs of Paths Equal in a Binary Tree",
        "question_content": "<p>You are given an integer <code>n</code> representing the number of nodes in a <strong>perfect binary tree</strong> consisting of nodes numbered from <code>1</code> to <code>n</code>. The root of the tree is node <code>1</code> and each node <code>i</code> in the tree has two children where the left child is the node <code>2 * i</code> and the right child is <code>2 * i + 1</code>.</p>\n\n<p>Each node in the tree also has a <strong>cost</strong> represented by a given <strong>0-indexed</strong> integer array <code>cost</code> of size <code>n</code> where <code>cost[i]</code> is the cost of node <code>i + 1</code>. You are allowed to <strong>increment</strong> the cost of <strong>any</strong> node by <code>1</code> <strong>any</strong> number of times.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of increments you need to make the cost of paths from the root to each <strong>leaf</strong> node equal</em>.</p>\n\n<p><strong>Note</strong>:</p>\n\n<ul>\n\t<li>A <strong>perfect binary tree </strong>is a tree where each node, except the leaf nodes, has exactly 2 children.</li>\n\t<li>The <strong>cost of a path</strong> is the sum of costs of nodes in the path.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png\" />\n<pre>\n<strong>Input:</strong> n = 7, cost = [1,5,2,2,3,3,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png\" style=\"width: 205px; height: 151px;\" />\n<pre>\n<strong>Input:</strong> n = 3, cost = [5,3,3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The two paths already have equal total costs, so no increments are needed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n + 1</code> is a power of <code>2</code></li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3494844,
                "title": "c-java-python3-short-dfs",
                "content": "\\n\\n# Intuition\\nWe can move level by level from the the leaves and make sure that the adjacent nodes have equal cost. First make the cost of adjacent leaves equal. Then move one level up. Make sure that the cost of the two children are equal and so on. If they are not equal just increment the node with the lower cost to make it equal to the other node.\\n\\n# Approach\\nUse `(2 * i + 1)` instead of `2 * i` for child node because `2 * i` will go into infinite loop when you run `dfs(0)`\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(h)\\n\\n# Code\\n**Python3**:\\n```\\ndef minIncrements(self, n, cost):\\n    self.res = 0\\n    def dfs(i):\\n        if i >= len(cost): return 0\\n        a, b = dfs(2 * i + 1), dfs(2 * i + 2)\\n        self.res += abs(a - b)\\n        return cost[i] + max(a, b)\\n    dfs(0)\\n    return self.res\\n```\\n\\n**C++**:\\n```\\nint minIncrements(int n, vector<int>& cost) {\\n    int res = 0;\\n    function<int(int)> dfs = [&](int i) {\\n        if (i >= cost.size()) return 0;\\n        int a = dfs(2 * i + 1), b = dfs(2 * i + 2);\\n        res += abs(a - b);\\n        return cost[i] + max(a, b);\\n    };\\n    dfs(0);\\n    return res;\\n}\\n```\\n\\n**Java**:\\n```\\nint res = 0;\\npublic int minIncrements(int n, int[] cost) {\\n    dfs(0, cost);\\n    return res;\\n}\\nprivate int dfs(int i, int[] cost) {\\n    if (i >= cost.length) return 0;\\n    int a = dfs(2 * i + 1, cost), b = dfs(2 * i + 2, cost);\\n    res += Math.abs(a - b);\\n    return cost[i] + Math.max(a, b);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef minIncrements(self, n, cost):\\n    self.res = 0\\n    def dfs(i):\\n        if i >= len(cost): return 0\\n        a, b = dfs(2 * i + 1), dfs(2 * i + 2)\\n        self.res += abs(a - b)\\n        return cost[i] + max(a, b)\\n    dfs(0)\\n    return self.res\\n```\n```\\nint minIncrements(int n, vector<int>& cost) {\\n    int res = 0;\\n    function<int(int)> dfs = [&](int i) {\\n        if (i >= cost.size()) return 0;\\n        int a = dfs(2 * i + 1), b = dfs(2 * i + 2);\\n        res += abs(a - b);\\n        return cost[i] + max(a, b);\\n    };\\n    dfs(0);\\n    return res;\\n}\\n```\n```\\nint res = 0;\\npublic int minIncrements(int n, int[] cost) {\\n    dfs(0, cost);\\n    return res;\\n}\\nprivate int dfs(int i, int[] cost) {\\n    if (i >= cost.length) return 0;\\n    int a = dfs(2 * i + 1, cost), b = dfs(2 * i + 2, cost);\\n    res += Math.abs(a - b);\\n    return cost[i] + Math.max(a, b);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3494915,
                "title": "java-c-python-bottom-up-and-follow-up",
                "content": "# Solution: Bottom Up\\nBottom up iterate the whole tree.\\nFor each node `i`, compare its two children `left` and `right`.\\nThe smaller child needs to catch up the bigger child,\\nso we increment `res += abs(A[left] - A[right])`,\\nthen we update `A[i] += max(A[left], A[right]`,\\nand `A[i]` present minimum cost from node `i` to any leaf.\\n\\nWe continue iterate the whole tree and finally return result `res`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n\\nActually space `O(n)`,\\nsince needs to save result for each node,\\nI overwrite the input in the solutions.\\nDFS recursion requires only `O(logn)` space.\\n<br>\\n\\n**Java**\\n```java\\n    public int minIncrements(int n, int[] A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += Math.abs(A[l] - A[r]);\\n            A[i] += Math.max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minIncrements(int n, vector<int>& A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += abs(A[l] - A[r]);\\n            A[i] += max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minIncrements(self, n: int, A: List[int]) -> int:\\n        res = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            l, r = i * 2 + 1, i * 2 + 2\\n            res += abs(A[l] - A[r])\\n            A[i] += max(A[l], A[r])\\n        return res\\n```\\n<br>\\n\\n\\n# **Follow up**\\nYou are allowed to both **increment** or **decrement**\\nthe cost of any node by 1 any number of times.\\nWhat the result now?\\n\\nIn the previous,\\nwe only record the lower bound path value of each node,\\nnow it will be a range.\\nIf left path cost is 5,\\nand path cost is 10,\\nthen we can make them equal in `[5, 10]`.\\n\\nIf left path cost is in range `[2,4]`,\\nand path cost is in range `[10, 15]`,\\nthen we can make them equal in range `[4, 10]`,\\nextra steps is `10 - 4 = 6`\\n\\n\\nIf left path cost is `[2, 10]`,\\nand path cost is `[4, 15]`,\\nthen we can make them equal in `[4, 10]`,\\nno extra steps.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minIncrements(int n, int[] A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += Math.abs(A[l] - A[r]);\\n            A[i] += Math.max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minIncrements(int n, vector<int>& A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += abs(A[l] - A[r]);\\n            A[i] += max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minIncrements(self, n: int, A: List[int]) -> int:\\n        res = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            l, r = i * 2 + 1, i * 2 + 2\\n            res += abs(A[l] - A[r])\\n            A[i] += max(A[l], A[r])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3495321,
                "title": "clearly-illustrated-dfs-proof-of-correctness",
                "content": "Many solutions show the right way to do it but do not prove that it is correct, and do not explain why this is the optimal way. Let\\'s do it!\\n\\n# Intuition\\n\\nWe want our binary tree to verify the equal path property (the cost to go from root to any leaf has to be the same). I will call a binary tree which verifies this property **balanced**.\\nThe key logic is the following:\\n\\n**The optimal strategy is to ensure every subtree is balanced**\\n\\nWhy is this true? Well, let\\u2019s imagine that there is a subtree rooted at a node `subroot` which is unbalanced. That is to say it can reach a certain `leaf1` for `lowcost`, and another `leaf2` for a different `highcost`.\\nWell, in that case, its parent node will reach `leaf1` for `lowcost+cost[subroot]` and `leaf2` for `highcost+cost[subroot]`, which are different costs. We see that the unbalanced property is recursive: if any subtree is unbalanced, it will \\u201Ccontaminate\\u201D the parent.\\n\\n![illustration cost path tree.png](https://assets.leetcode.com/users/images/56b9ad51-e064-459f-a063-513c10ce5d02_1683437244.2906523.png)\\n\\n\\n\\nTherefore, if we want to balance `root`, it is necessary to balance *every subroot* on its way. It is easy to verify that this is also a sufficient condition. **So this is the optimal way to do it, because it is in fact kinda the only way to do it!** (root is balanced *if and only if* all of the subtrees are balanced). We just need to balance every subtree in the least number of operations\\n\\nThat begs for a recursive approach! If we ensure starting from every leaf, that every subtree is balanced, then it\\u2019s easy to make the optimal corrections to balance the parent too!\\n\\n\\n# Approach\\nLet\\u2019s do a recursive dfs. \\n\\nWe position ourselves at a specific node `subroot` and will treat it as the root of a subtree. We assume that all of its subtrees are already balanced (we traverse in a post-order fashion and the subtree is taken care of earlier in the recursion). Then its left child reaches all leaves for `leftcost`, and the right child for `rightcost`. So we just need to make those costs equal to balance `subroot`! All we need is a correction according to the difference between those two (`correction+=abs(leftcost-rightcost)`).\\n\\nWe then return the total cost of this `subroot` which is simply `max(leftcost,rightcost)+cost[subroot]`. The maximum is taken here because we can only increment, so that means that we increase the lowest cost of the two children until it is equal to the other, and we are left with the max.\\n\\nAnd that\\u2019s it! If this helped you understand the proof of correctness and visualize it, do leave an upvote, it is always encouraging!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(logn) for the stack call\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        correction=0\\n        def dfs(node):\\n            nonlocal correction\\n            if node>=len(cost):\\n                return 0\\n            #the indexing is a bit annoying, but I like to think about it this way:\\n            #we have to treat it as being 1-indexed to get the child (so we use 2*(node+1) rather than 2*node)\\n            #we then convert it back to 0-indexed for the array (so 2*(node+1)-1)\\n            #I explain the indexing in more details in the comment section\\n            lcost=dfs(2*(node+1)-1)\\n            rcost=dfs(2*(node+1))\\n            correction+=abs(rcost-lcost)\\n            return max(lcost,rcost)+cost[node]\\n        \\n        dfs(0)\\n        return correction\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        correction=0\\n        def dfs(node):\\n            nonlocal correction\\n            if node>=len(cost):\\n                return 0\\n            #the indexing is a bit annoying, but I like to think about it this way:\\n            #we have to treat it as being 1-indexed to get the child (so we use 2*(node+1) rather than 2*node)\\n            #we then convert it back to 0-indexed for the array (so 2*(node+1)-1)\\n            #I explain the indexing in more details in the comment section\\n            lcost=dfs(2*(node+1)-1)\\n            rcost=dfs(2*(node+1))\\n            correction+=abs(rcost-lcost)\\n            return max(lcost,rcost)+cost[node]\\n        \\n        dfs(0)\\n        return correction\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494857,
                "title": "explained-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\n\\nTrick here is to have equal path cast at each node for its child nodes.\\n\\n1. First traverse to the leaf node and then return the sum of path cost from the leaf towards root.\\n2. While returning from the leaf node, we will equal the path sum to the max value\\n   - to do so, add the diff in paths of two child to the ans\\n   - take the max and return it to its parent node\\n   \\nNote : As there is no actual tree built here, we will use max value of root as <= n for the base condition to return.  \\n\\n\\nTime complexity O(N) & space complexity O(H), where H is height of the tree\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dfs(int root, vector<int>& cost, int n){\\n        if(root > n ) return 0;\\n        int t1 = dfs(root*2, cost, n);\\n        int t2 = dfs(root*2+1, cost, n);\\n        ans += abs(t1 - t2);\\n        return cost[root-1] + max(t1, t2);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dfs(int root, vector<int>& cost, int n){\\n        if(root > n ) return 0;\\n        int t1 = dfs(root*2, cost, n);\\n        int t2 = dfs(root*2+1, cost, n);\\n        ans += abs(t1 - t2);\\n        return cost[root-1] + max(t1, t2);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494855,
                "title": "cpp-java-python-simple-dfs-one-pass",
                "content": "### Intuition\\nJust make left and right subtree cost equal.\\n\\n### TIme Complexity : `O(n)`\\n\\n### C++\\n```\\nclass Solution {\\npublic:\\n    int dfs(int n,vector<int> &cost,int i,int &ans) {\\n        if(i > n) return 0;\\n        int leftCost = dfs(n,cost,2 * i,ans);\\n        int rightCost = dfs(n,cost,2 * i + 1,ans);\\n        ans += abs(leftCost - rightCost);\\n        return max(leftCost,rightCost) + cost[i - 1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        dfs(n,cost,1,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n### Java\\n\\n```\\nclass Solution {\\n    int ans = 0;\\n    int dfs(int n,int[] cost,int i) {\\n        if(i > n) return 0;\\n        int leftCost = dfs(n,cost,2 * i);\\n        int rightCost = dfs(n,cost,2 * i + 1);\\n        ans += Math.abs(leftCost - rightCost);\\n        return Math.max(leftCost,rightCost) + cost[i - 1];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(n,cost,1);\\n        return ans;\\n    }\\n}\\n```\\n\\n### Python\\n\\n```\\nans = 0\\ndef dfs(n, cost, i):\\n    global ans\\n    if(i > n):\\n        return 0\\n    leftCost = dfs(n,cost,2 * i);\\n    rightCost = dfs(n,cost,2 * i + 1);\\n    ans += abs(leftCost - rightCost);\\n    return max(leftCost,rightCost) + cost[i - 1];\\n    \\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        global ans\\n        ans = 0\\n        dfs(n,cost,1)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int n,vector<int> &cost,int i,int &ans) {\\n        if(i > n) return 0;\\n        int leftCost = dfs(n,cost,2 * i,ans);\\n        int rightCost = dfs(n,cost,2 * i + 1,ans);\\n        ans += abs(leftCost - rightCost);\\n        return max(leftCost,rightCost) + cost[i - 1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        dfs(n,cost,1,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int ans = 0;\\n    int dfs(int n,int[] cost,int i) {\\n        if(i > n) return 0;\\n        int leftCost = dfs(n,cost,2 * i);\\n        int rightCost = dfs(n,cost,2 * i + 1);\\n        ans += Math.abs(leftCost - rightCost);\\n        return Math.max(leftCost,rightCost) + cost[i - 1];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(n,cost,1);\\n        return ans;\\n    }\\n}\\n```\n```\\nans = 0\\ndef dfs(n, cost, i):\\n    global ans\\n    if(i > n):\\n        return 0\\n    leftCost = dfs(n,cost,2 * i);\\n    rightCost = dfs(n,cost,2 * i + 1);\\n    ans += abs(leftCost - rightCost);\\n    return max(leftCost,rightCost) + cost[i - 1];\\n    \\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        global ans\\n        ans = 0\\n        dfs(n,cost,1)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495289,
                "title": "c-very-well-commented-easy-to-understand-solution",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use post-order dfs to calculate difference of left and right path cost at a node. Then return the current path to parent.\\n\\nMinimum operations we need are abs(right-left) because we want to make lower path equal to the larger path by incrementing the lower path sum.\\n\\nThen, the left and right path should be equal to each other, \\ni.e. $$max(left, right)$$, and\\nCurrent path becomes $$cost[node] + max(left, right)$$\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log2(n))$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // To store the answer\\n    int ans=0;\\n    \\n    // A post-order dfs to calculate difference of every left and right path cost\\n    int dfs(int node, int n,vector<int>& cost){\\n\\n        // if this node doesn\\'t exist(if it is greater that n) then return 0\\n        if(node>n)return 0;\\n        int left=0,right=0;\\n\\n        // the left path cost\\n        left=dfs(2*node,n,cost);\\n        //the right path cost\\n        right=dfs((node*2)+1,n,cost);\\n\\n        // we store the difference needed to make the left and right path equal\\n        ans+= abs(right-left);\\n\\n        // return the current path\\n        return cost[node-1] + max(left,right);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1,n,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // To store the answer\\n    int ans=0;\\n    \\n    // A post-order dfs to calculate difference of every left and right path cost\\n    int dfs(int node, int n,vector<int>& cost){\\n\\n        // if this node doesn\\'t exist(if it is greater that n) then return 0\\n        if(node>n)return 0;\\n        int left=0,right=0;\\n\\n        // the left path cost\\n        left=dfs(2*node,n,cost);\\n        //the right path cost\\n        right=dfs((node*2)+1,n,cost);\\n\\n        // we store the difference needed to make the left and right path equal\\n        ans+= abs(right-left);\\n\\n        // return the current path\\n        return cost[node-1] + max(left,right);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1,n,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495360,
                "title": "simple-solution-without-dfs-simple-loop-very-short",
                "content": "# Intuition\\nWe shouldn\\'t add 1 on 2 siblings since it\\'s better to add 1 to the parent.\\n\\n# Approach\\nFrom leaf to root, for each pair of siblings (x, y), keep the larger value as the result. And the we need to add the difference to the smaller value to make (x, y) the same. And add the same value to the parent since the parent is the \"new leaf\".\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {        \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n      int r = 0;\\n      for (int i = n - 1; i; i -= 2) {\\n         r += abs(cost[i] - cost[i - 1]);\\n         cost[(i - 1) >> 1] += max(cost[i], cost[i - 1]);\\n       }\\n       return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {        \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n      int r = 0;\\n      for (int i = n - 1; i; i -= 2) {\\n         r += abs(cost[i] - cost[i - 1]);\\n         cost[(i - 1) >> 1] += max(cost[i], cost[i - 1]);\\n       }\\n       return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495060,
                "title": "find-the-maximum-sum-from-root-to-leaf",
                "content": "# Intuition\\nGo from root to leaf, find the maxium sum. And then go back from leaf to root.\\n\\n# Approach\\nIf a 2 siblings needs to add values x and y, then move min(x, y) to the parent.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    void cal(const vector<int> &cost, int now, int s, vector<int> &v) {\\n        if (now > cost.size()) {\\n            return;\\n        }\\n        s += cost[now - 1];\\n        if (now + now >= cost.size()) {\\n            v[now] = s;\\n            return;\\n        }\\n        cal(cost, now << 1, s, v);\\n        cal(cost, (now << 1) | 1, s, v);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> v(n + 1);\\n        cal(cost, 1, 0, v);\\n        const int m = *max_element(v.begin(), v.end());\\n        long long r = 0;\\n        for (int i = (n + 1) >> 1; i <= n; ++i) {\\n            v[i] = m - v[i];\\n            r += v[i];\\n        }\\n        for (int from = (n + 1) >> 1; from > 1; from >>= 1) {\\n            for (int i = from, to = from << 1; i < to; i += 2) {\\n                r -= (v[i >> 1] = min(v[i], v[i + 1]));\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void cal(const vector<int> &cost, int now, int s, vector<int> &v) {\\n        if (now > cost.size()) {\\n            return;\\n        }\\n        s += cost[now - 1];\\n        if (now + now >= cost.size()) {\\n            v[now] = s;\\n            return;\\n        }\\n        cal(cost, now << 1, s, v);\\n        cal(cost, (now << 1) | 1, s, v);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> v(n + 1);\\n        cal(cost, 1, 0, v);\\n        const int m = *max_element(v.begin(), v.end());\\n        long long r = 0;\\n        for (int i = (n + 1) >> 1; i <= n; ++i) {\\n            v[i] = m - v[i];\\n            r += v[i];\\n        }\\n        for (int from = (n + 1) >> 1; from > 1; from >>= 1) {\\n            for (int i = from, to = from << 1; i < to; i += 2) {\\n                r -= (v[i >> 1] = min(v[i], v[i + 1]));\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495265,
                "title": "beginner-friendly-and-very-simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a particular node its children should have equal path sum.\\nSo we will calculate path sum of both childs and make them equal. And we will perform this operation for all nodes. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will traverse using dfs from starting node and calculate path sum of childs. Our dfs(node) will return path sum. After finding path sum of childs difference of both paths will be added to our final answer and then we return path sum till parent node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) -> Traversing complete tree using dfs.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log(n)) -> Stack size during recursion call\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(int i,vector<int>&cost)\\n    {\\n        if(i>cost.size())\\n            return 0;\\n        int x=dfs(2*i,cost);\\n        int y=dfs(2*i+1,cost);\\n        ans+=abs(x-y);\\n        return max(x,y)+cost[i-1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int x=dfs(1,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(int i,vector<int>&cost)\\n    {\\n        if(i>cost.size())\\n            return 0;\\n        int x=dfs(2*i,cost);\\n        int y=dfs(2*i+1,cost);\\n        ans+=abs(x-y);\\n        return max(x,y)+cost[i-1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int x=dfs(1,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494956,
                "title": "hand-written-with-observation-and-diagram-dry-run",
                "content": "** Please Upvote if you liked the solution**\\n![image.png](https://assets.leetcode.com/users/images/7c0bcab3-56dd-4cab-a512-4957e5dc6181_1683435348.005485.png)\\n![image.png](https://assets.leetcode.com/users/images/5aa93401-b7eb-4d69-816a-d97e263394ae_1683432142.6954012.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/dcd17658-2fd7-4b4a-9244-487870a78a84_1683432164.5087936.png)\\n![image.png](https://assets.leetcode.com/users/images/a4164879-06c2-4879-a5c9-df091864f6c8_1683432178.6084197.png)\\n![image.png](https://assets.leetcode.com/users/images/09f98284-7afa-43a5-9db5-29cbb1b12fb1_1683432187.3257892.png)\\n![image.png](https://assets.leetcode.com/users/images/bda67c11-0700-4ab5-981f-152db677a35c_1683432206.899085.png)\\n![image.png](https://assets.leetcode.com/users/images/7af80caa-2c45-49c9-86f4-319527d8c17d_1683432217.3027983.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findLeaves(int n) {\\n    vector<int> leaves;\\n    for (int i = n/2 + 1; i <= n; i++) {\\n        leaves.push_back(i);\\n    }\\n    return leaves;\\n}\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int>leaves=findLeaves(n);\\n        queue<int>q;\\n        map<int,int>mp;\\n        for(auto child:leaves){\\n            mp[child]=0;\\n            q.push(child);\\n        }\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int curr=q.front();\\n                if(curr==1)\\n                    return ans;\\n                q.pop();\\n                int parent;\\n                if(curr&1){\\n                    parent=(curr-1)/2;\\n                }else {\\n                    parent=curr/2;\\n                }\\n                if(parent>0 && mp.count(parent)==0){\\n                    mp[parent]=mp[curr]+cost[curr-1];\\n            \\n                    q.push(parent);\\n                }else{\\n                    ans+=abs(mp[parent]-(mp[curr]+cost[curr-1]));\\n                    mp[parent]=max(mp[parent],mp[curr]+cost[curr-1]);\\n\\n                }\\n       \\n                \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Please Upvote if you liked the solution **",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findLeaves(int n) {\\n    vector<int> leaves;\\n    for (int i = n/2 + 1; i <= n; i++) {\\n        leaves.push_back(i);\\n    }\\n    return leaves;\\n}\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int>leaves=findLeaves(n);\\n        queue<int>q;\\n        map<int,int>mp;\\n        for(auto child:leaves){\\n            mp[child]=0;\\n            q.push(child);\\n        }\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int curr=q.front();\\n                if(curr==1)\\n                    return ans;\\n                q.pop();\\n                int parent;\\n                if(curr&1){\\n                    parent=(curr-1)/2;\\n                }else {\\n                    parent=curr/2;\\n                }\\n                if(parent>0 && mp.count(parent)==0){\\n                    mp[parent]=mp[curr]+cost[curr-1];\\n            \\n                    q.push(parent);\\n                }else{\\n                    ans+=abs(mp[parent]-(mp[curr]+cost[curr-1]));\\n                    mp[parent]=max(mp[parent],mp[curr]+cost[curr-1]);\\n\\n                }\\n       \\n                \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494848,
                "title": "one-pass",
                "content": "We tack the maximum the path sum, and for each non-leaf node, we \"pick up the slack\".\\n\\nThe top-down solution is easier to comprehend; once you get it - it should be easy to code the bottom-up approach.\\n\\n## Top-Down\\n\\n**C++**\\n```cpp\\narray<int, 2> path_sum(int i, int n, vector<int>& cost) {\\n    if (i * 2 >= n)\\n        return {0, cost[i - 1]};\\n    auto l = path_sum(i * 2, n, cost), r = path_sum(i * 2 + 1, n, cost);\\n    return {l[0] + r[0] + abs(l[1] - r[1]), cost[i - 1] + max(l[1], r[1])};\\n}     \\nint minIncrements(int n, vector<int>& cost) {\\n    return path_sum(1, n, cost)[0];\\n}\\n```\\n\\n## Bottom-Up\\n```cpp\\nint minIncrements(int n, vector<int>& cost) {\\n    int res = 0;\\n    for (int i = n - 2; i > 0; i -= 2) {\\n        res += abs(cost[i] - cost[i + 1]);\\n        cost[i / 2] += max(cost[i], cost[i + 1]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\narray<int, 2> path_sum(int i, int n, vector<int>& cost) {\\n    if (i * 2 >= n)\\n        return {0, cost[i - 1]};\\n    auto l = path_sum(i * 2, n, cost), r = path_sum(i * 2 + 1, n, cost);\\n    return {l[0] + r[0] + abs(l[1] - r[1]), cost[i - 1] + max(l[1], r[1])};\\n}     \\nint minIncrements(int n, vector<int>& cost) {\\n    return path_sum(1, n, cost)[0];\\n}\\n```\n```cpp\\nint minIncrements(int n, vector<int>& cost) {\\n    int res = 0;\\n    for (int i = n - 2; i > 0; i -= 2) {\\n        res += abs(cost[i] - cost[i + 1]);\\n        cost[i / 2] += max(cost[i], cost[i + 1]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495055,
                "title": "c-no-dfs",
                "content": "# Intuition\\nNote the binary tree is complete, we just need to ensure the most bottom node is equals and carry over the cost to higher level until we reach the root.\\n\\n# Approach\\nSince we can only increment, we need to ensure lowest level is equals before moving up. Carry the max of left-right nodes to its parent node. On the parent node, calculate cost to make same level equals and carry it up to its parent. Do it until you reach the root.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans {};\\n        for(int i = cost.size()-1; i > 0; --i) {\\n//start on left-node since we know the binary tree is complete\\n            --i; \\n//cost to make left node and right node equals\\n            ans += abs(cost[i]-cost[i+1]);\\n//the cost of path to leaf node can be recomputed as cost to parent node + max of parent\\'s child\\n            cost[i/2] += max(cost[i],cost[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans {};\\n        for(int i = cost.size()-1; i > 0; --i) {\\n//start on left-node since we know the binary tree is complete\\n            --i; \\n//cost to make left node and right node equals\\n            ans += abs(cost[i]-cost[i+1]);\\n//the cost of path to leaf node can be recomputed as cost to parent node + max of parent\\'s child\\n            cost[i/2] += max(cost[i],cost[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494925,
                "title": "simple-post-order-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int post(int nd,vector<int>&cost,int n){\\n      if(nd>n)return 0;\\n        int left=post(2*nd,cost,n);\\n        int right=post(2*nd+1,cost,n);\\n        if(left!=right)ans+=abs(left-right);\\n        return cost[nd-1]+max(left,right);\\n    \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        post(1,cost,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int post(int nd,vector<int>&cost,int n){\\n      if(nd>n)return 0;\\n        int left=post(2*nd,cost,n);\\n        int right=post(2*nd+1,cost,n);\\n        if(left!=right)ans+=abs(left-right);\\n        return cost[nd-1]+max(left,right);\\n    \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        post(1,cost,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513119,
                "title": "java-dfs-clean-code-10-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int ans = 0;\\n\\n  private int dfs(int n, int[] cost, int i) {\\n    if (i > n) return 0;\\n\\n    var l = dfs(n, cost, 2*i);\\n    var r = dfs(n, cost, 2*i + 1);\\n    ans += Math.abs(l - r);\\n\\n    return cost[i-1] + Math.max(l, r);\\n  }\\n\\n  public int minIncrements(int n, int[] cost) {\\n    dfs(n, cost, 1);\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  int ans = 0;\\n\\n  private int dfs(int n, int[] cost, int i) {\\n    if (i > n) return 0;\\n\\n    var l = dfs(n, cost, 2*i);\\n    var r = dfs(n, cost, 2*i + 1);\\n    ans += Math.abs(l - r);\\n\\n    return cost[i-1] + Math.max(l, r);\\n  }\\n\\n  public int minIncrements(int n, int[] cost) {\\n    dfs(n, cost, 1);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501702,
                "title": "python-3-7-lines-iterative-bottom-up-t-m-1269-ms-25-5-mb",
                "content": "A couple of notes:\\n1. The iteration covers only the parents, so we can prune the leaves from the iteration.\\n2. We add `1` each to `2i` and `2i+1` because `cost` is zero-indexed and the tree is one-indexed.\\n\\n\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n\\n        ans = 0\\n        n//=2                                               # <-- 1)\\n\\n        for i in reversed(range(n)):\\n        \\n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\\n\\n            ans+= mx - mn\\n            cost[i]+= mx\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/submissions/946746736/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n\\n        ans = 0\\n        n//=2                                               # <-- 1)\\n\\n        for i in reversed(range(n)):\\n        \\n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\\n\\n            ans+= mx - mn\\n            cost[i]+= mx\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495143,
                "title": "c-backtracking",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Base Condition is if current node is leaf we returns its cost.\\n2. we perform dfs.\\n3. while backtracking we add difference in cost arrived from both child and add max of both to current cost and returns.\\n4. final asnswer is `ans` where we stored differences sum which returned at `i=0`.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$ //Recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int minIncrements(int& n, vector<int>& cost,int i=0) {\\n        if(2*i+1>=n) return i==0?ans:cost[i];\\n        int x = minIncrements(n,cost,2*i+1);\\n        int y = minIncrements(n,cost,2*i+2);\\n        ans+=abs(x-y);\\n        return i==0?ans:max(x,y)+cost[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int minIncrements(int& n, vector<int>& cost,int i=0) {\\n        if(2*i+1>=n) return i==0?ans:cost[i];\\n        int x = minIncrements(n,cost,2*i+1);\\n        int y = minIncrements(n,cost,2*i+2);\\n        ans+=abs(x-y);\\n        return i==0?ans:max(x,y)+cost[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494892,
                "title": "6-lines-c-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int sum = 0;\\n        vector<int> path = cost;\\n        for(int i = cost.size()-1; i > 0; i = i -2){\\n            int minM = min(cost[i], cost[i-1]);\\n            int maxM = max(cost[i],cost[i-1]);\\n            sum += maxM - minM;\\n            cost[(i-1)/2] += maxM;\\n            \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int sum = 0;\\n        vector<int> path = cost;\\n        for(int i = cost.size()-1; i > 0; i = i -2){\\n            int minM = min(cost[i], cost[i-1]);\\n            int maxM = max(cost[i],cost[i-1]);\\n            sum += maxM - minM;\\n            cost[(i-1)/2] += maxM;\\n            \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786336,
                "title": "5-line-cpp-solution-with-explanation-optimal-space-and-time-array-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe start from the leaf nodes and then move upwards. Also note that a perfect binary tree is given.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe add the difference of the two sibling nodes(with the same parent) into our answer and add the value of their maximum to the parent node\\'s node value.\\nSince we have a perfect binary tree we can use simple array operations for the desired result.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n-1; i>=1; i = i-2){\\n            ans+= abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n-1; i>=1; i = i-2){\\n            ans+= abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502359,
                "title": "2-lines-code",
                "content": "# Intuition\\nThink Bottom UP.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int moves = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            moves += abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return moves;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int moves = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return moves;\\n    }\\n}\\n```\\n```JavaScript []\\nvar minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int moves = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            moves += abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return moves;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int moves = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return moves;\\n    }\\n}\\n```\n```JavaScript []\\nvar minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499189,
                "title": "beats-100-solution-easy-dfs-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(vector<int>& cost,int ind,int n)\\n    {\\n        if(ind>n) return 0;\\n        int l=dfs(cost , 2*ind ,n);\\n        int r=dfs(cost , (2*ind )+1 ,n);\\n        ans+=abs(l-r);\\n        return cost[ind-1]+max(l,r);\\n        \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        dfs(cost,1,n);\\n        return ans;\\n    }\\n};\\n```\\n![7dr99c.jpg](https://assets.leetcode.com/users/images/167fd5e0-7ff6-4c96-91a8-bc52eaee94f8_1683524540.0145473.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs(vector<int>& cost,int ind,int n)\\n    {\\n        if(ind>n) return 0;\\n        int l=dfs(cost , 2*ind ,n);\\n        int r=dfs(cost , (2*ind )+1 ,n);\\n        ans+=abs(l-r);\\n        return cost[ind-1]+max(l,r);\\n        \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        dfs(cost,1,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3496277,
                "title": "short-dfs-straight-forward-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans;\\n    public int minIncrements(int n, int[] cost) {\\n        ans=0;\\n        rec(n, cost, 0);\\n        return ans;\\n    }\\n    int rec(int n, int[] cost, int i){\\n        if(i>=n)return 0;\\n        int left=rec(n, cost, i*2+1);\\n        int right=rec(n, cost, i*2+2);\\n        ans+=Math.abs(left-right);\\n        return Math.max(left,right)+cost[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int minIncrements(int n, int[] cost) {\\n        ans=0;\\n        rec(n, cost, 0);\\n        return ans;\\n    }\\n    int rec(int n, int[] cost, int i){\\n        if(i>=n)return 0;\\n        int left=rec(n, cost, i*2+1);\\n        int right=rec(n, cost, i*2+2);\\n        ans+=Math.abs(left-right);\\n        return Math.max(left,right)+cost[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496157,
                "title": "medium",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nCOMMING SOON\\n\\n# Complexity\\n- Time complexity:O(LOG N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\npublic int minIncrements(int n, int[] cost) {\\n    int res =0;\\n    for(int i=n / 2 - 1;i>=0;--i){\\n        int l =  i * 2 + 1,r=  i *  2 + 2;\\n        res+=Math.abs(cost[l]-cost[r]);\\n        cost[i]+=Math.max(cost[l],cost[r]);\\n    }return res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```JAVA []\\npublic int minIncrements(int n, int[] cost) {\\n    int res =0;\\n    for(int i=n / 2 - 1;i>=0;--i){\\n        int l =  i * 2 + 1,r=  i *  2 + 2;\\n        res+=Math.abs(cost[l]-cost[r]);\\n        cost[i]+=Math.max(cost[l],cost[r]);\\n    }return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638632,
                "title": "fully-expalined-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n**We need to calculate the height of each subtree from Bottom to top \\nand keep track of difference**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.  **The func function takes four parameters: cost, which is a vector of integers representing the cost at each node of the binary tree; l, which represents the current level or index of the node being processed; n, the total number of nodes in the tree; and ans, a reference to an integer that keeps track of the total cost increments**.\\n\\n2. **The first conditional statement if (2 * l > n || 2 * l + 1 > n) checks if the current node is a leaf node. If the left child (2 * l) or the right child (2 * l + 1) exceeds the total number of nodes n, it means that the current node is a leaf node, and the function returns the cost at that leaf node cost[l-1].**\\n\\n3. **If the current node is not a leaf node, the function proceeds to the following steps:**\\n\\n4. **It recursively calls func for the left child of the current node with 2 * l as the new index and stores the result in the left variable.**\\n\\n5. **Similarly, it recursively calls func for the right child of the current node with    2 * l + 1 as the new index and stores the result in the right variable.**\\n\\n6. **The difference between the left and right values is added to the ans variable to keep track of the total cost increments.**\\n\\n7. **The function returns the sum of the cost at the current node   cost[l-1] and the maximum value between left and right.**\\n\\n8. **The result variable in main function basicall print the maximum distance b/w leaf node and root node**\\n\\n```\\n return cost[l-1]+max(left,right);\\n```\\n**This statement basically gives the maximum distance b/w root to leaf among all paths**\\n\\n ```\\nif(2*l>n||2*l+1>n) return cost[l-1];\\n\\n```\\n**The ```if condition``` checks if the ```current node is a leaf node. ```It does this by comparing whether the index of the ```left child (2 * l) or the index of the right child (2 * l + 1) exceeds the total number of nodes n```. If either child\\'s index is greater than n, it means the current node is a leaf node. In that case, the function returns the cost at that leaf node (cost[l - 1]).**\\n\\n\\n\\n\\n```\\n        int left=func(cost,2*l,n,ans);\\n        int right=func(cost,2*l+1,n,ans);\\n       \\n```\\n\\n**left calculate the distance of left leaf in ever subtree and right subtree is calculated by right variable**\\n\\n``` ans+=abs(left-right); ```\\n **This satement keep track the changes we need to made to make the paths equal**\\n\\n\\n        \\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**RECURSIVE APPROACH**\\n```\\nclass Solution {\\npublic:\\n    int func(vector<int>&cost,int l,int n,int &ans)\\n    {\\n        if(2*l>n||2*l+1>n) return cost[l-1];\\n\\n        int left=func(cost,2*l,n,ans);\\n        int right=func(cost,2*l+1,n,ans);\\n        ans+=abs(left-right);\\n        return cost[l-1]+max(left,right);\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n     int ans=0;\\n     int level=1;//level\\n     int result=func(cost,level, n,ans);\\n\\n\\n     cout<<result<<\" \";\\n     return ans;\\n}\\n};\\n```\\n**ITERATIVE APPROACH**\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n\\n         n=n/2;\\n         int ans=0;\\n    for(int i=n; i>0; i--)\\n    {\\n        int l=2*i-1;//left\\n        int r=2*i; //right\\n        ans+=abs(cost[l]-cost[r]);//updating the difference \\n        cost[i-1]+=max(cost[l],cost[r]);//updatin the max subtree cost\\n    }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n return cost[l-1]+max(left,right);\\n```\n```\\nif(2*l>n||2*l+1>n) return cost[l-1];\\n\\n```\n```if condition```\n```current node is a leaf node. ```\n```left child (2 * l) or the index of the right child (2 * l + 1) exceeds the total number of nodes n```\n```\\n        int left=func(cost,2*l,n,ans);\\n        int right=func(cost,2*l+1,n,ans);\\n       \\n```\n``` ans+=abs(left-right); ```\n```\\nclass Solution {\\npublic:\\n    int func(vector<int>&cost,int l,int n,int &ans)\\n    {\\n        if(2*l>n||2*l+1>n) return cost[l-1];\\n\\n        int left=func(cost,2*l,n,ans);\\n        int right=func(cost,2*l+1,n,ans);\\n        ans+=abs(left-right);\\n        return cost[l-1]+max(left,right);\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n     int ans=0;\\n     int level=1;//level\\n     int result=func(cost,level, n,ans);\\n\\n\\n     cout<<result<<\" \";\\n     return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n\\n         n=n/2;\\n         int ans=0;\\n    for(int i=n; i>0; i--)\\n    {\\n        int l=2*i-1;//left\\n        int r=2*i; //right\\n        ans+=abs(cost[l]-cost[r]);//updating the difference \\n        cost[i-1]+=max(cost[l],cost[r]);//updatin the max subtree cost\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3577222,
                "title": "python-iterative-not-recursive-short-and-concise",
                "content": "# Intuition\\nIf only 3 nodes,\\n```\\n    1\\n   / \\\\\\n  2   3\\n```\\nto make cost equal, we add 1 to 2\\n\\nIf 7 nodes,\\n```\\n            1\\n           / \\\\\\n          2   3\\n         / \\\\ / \\\\\\n        4  5 6  7\\n```\\nwe add 1 to 4, to make 1->2->4 and 1->2->5 have equal cost.\\nwe add 1 to 6, to make 1->3->6 and 1->3->7 have equal cost.\\nTo make 1->2->5 and 1->3->7 have equal cost, we need to add 3 to 2 (3+7-(2+5))\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        for i in range(len(cost)-1, 1, -2): # from leaf to root\\n            res += abs(cost[i] - cost[i-1]) # make two nodes with same parent equal\\n            cost[(i-1)//2] += max(cost[i], cost[i-1]) # add the cost to the parent\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    1\\n   / \\\\\\n  2   3\\n```\n```\\n            1\\n           / \\\\\\n          2   3\\n         / \\\\ / \\\\\\n        4  5 6  7\\n```\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        for i in range(len(cost)-1, 1, -2): # from leaf to root\\n            res += abs(cost[i] - cost[i-1]) # make two nodes with same parent equal\\n            cost[(i-1)//2] += max(cost[i], cost[i-1]) # add the cost to the parent\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575840,
                "title": "c-no-dfs-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint minIncrements(int n, vector<int> &cost)\\n{\\n    int ans = 0;\\n    for (int i = n / 2 - 1; i >= 0; i--)\\n    {\\n        int left = i * 2 + 1;\\n        int right = i * 2 + 2;\\n\\n        ans += abs(cost[left] - cost[right]);\\n\\n        cost[i] += max(cost[left], cost[right]);\\n\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minIncrements(int n, vector<int> &cost)\\n{\\n    int ans = 0;\\n    for (int i = n / 2 - 1; i >= 0; i--)\\n    {\\n        int left = i * 2 + 1;\\n        int right = i * 2 + 2;\\n\\n        ans += abs(cost[left] - cost[right]);\\n\\n        cost[i] += max(cost[left], cost[right]);\\n\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568199,
                "title": "2673-make-costs-of-paths-equal-in-a-binary-tree-java",
                "content": "```\\nclass Solution {\\n    int ans=0;\\n    public int solve(int [] cost,int n,int ind)\\n    {\\n        if(ind>=n)\\n            return 0;\\n        int left=solve(cost,n,2*ind+1);\\n        int right=solve(cost,n,2*ind+2);\\n        ans+=Math.abs(left-right);\\n        return cost[ind]+Math.max(left,right);\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        solve(cost,n,0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int solve(int [] cost,int n,int ind)\\n    {\\n        if(ind>=n)\\n            return 0;\\n        int left=solve(cost,n,2*ind+1);\\n        int right=solve(cost,n,2*ind+2);\\n        ans+=Math.abs(left-right);\\n        return cost[ind]+Math.max(left,right);\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        solve(cost,n,0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543167,
                "title": "simple-bfs-solution-with-time-complexity-o-n-no-recursion",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n``` golang []\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\n\\nfunc min(a, b int) int {\\n    if a > b {\\n        return b\\n    }\\n\\n    return a\\n}\\n\\n\\nfunc minIncrements(n int, cost []int) int {\\n    var ans int\\n    var sums []int = make([]int, n / 2)\\n\\n    for i := n - 1; i > 1; i -= 2 {\\n        left_sum, right_sum := cost[i - 1], cost[i]\\n\\n        if i < len(sums) {\\n            left_sum += sums[i - 1]\\n            right_sum += sums[i]\\n        }\\n        \\n        sums[i / 2 - 1] = max(left_sum, right_sum)\\n        ans += sums[i / 2 - 1] - min(left_sum, right_sum)\\n    }\\n\\n    return ans\\n}\\n\\n```\\n``` python []\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        sums = [0] * (n // 2)\\n\\n        for i in range(n - 1, 1, -2):\\n            left_sum, right_sum = cost[i - 1], cost[i]\\n            if i < len(sums):\\n                left_sum += sums[i - 1]\\n                right_sum += sums[i]\\n\\n            sums[i // 2 - 1] = max(left_sum, right_sum)\\n            ans += sums[i // 2 - 1] - min(left_sum, right_sum)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "``` golang []\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\n\\nfunc min(a, b int) int {\\n    if a > b {\\n        return b\\n    }\\n\\n    return a\\n}\\n\\n\\nfunc minIncrements(n int, cost []int) int {\\n    var ans int\\n    var sums []int = make([]int, n / 2)\\n\\n    for i := n - 1; i > 1; i -= 2 {\\n        left_sum, right_sum := cost[i - 1], cost[i]\\n\\n        if i < len(sums) {\\n            left_sum += sums[i - 1]\\n            right_sum += sums[i]\\n        }\\n        \\n        sums[i / 2 - 1] = max(left_sum, right_sum)\\n        ans += sums[i / 2 - 1] - min(left_sum, right_sum)\\n    }\\n\\n    return ans\\n}\\n\\n```\n``` python []\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        sums = [0] * (n // 2)\\n\\n        for i in range(n - 1, 1, -2):\\n            left_sum, right_sum = cost[i - 1], cost[i]\\n            if i < len(sums):\\n                left_sum += sums[i - 1]\\n                right_sum += sums[i]\\n\\n            sums[i // 2 - 1] = max(left_sum, right_sum)\\n            ans += sums[i // 2 - 1] - min(left_sum, right_sum)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529561,
                "title": "java-simple-dfs",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee comments\\n# Complexity\\nT O(N)\\nS O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n\\n    // get the max cost of a path of sub tree root at i;\\n    public int dfs(int i, int[] cost) {\\n        if (i > cost.length) return 0;\\n        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);\\n        // you need keep two child tree has the same cost of path.\\n        // best way to tune the root of lower cost path, increase the\\n        // lower root, by Math.abs(left - right);\\n        res += Math.abs(left - right);\\n        return cost[i - 1] + Math.max(left, right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n\\n    // get the max cost of a path of sub tree root at i;\\n    public int dfs(int i, int[] cost) {\\n        if (i > cost.length) return 0;\\n        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);\\n        // you need keep two child tree has the same cost of path.\\n        // best way to tune the root of lower cost path, increase the\\n        // lower root, by Math.abs(left - right);\\n        res += Math.abs(left - right);\\n        return cost[i - 1] + Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511150,
                "title": "dfs-and-bfs",
                "content": "# Intuition\\nWe need to find how much value for each node we can increment while moving from root to leaf such that on reaching each leaf we will get same sum.\\n\\n# Approach\\nFor a given node the minimum value we can increment will be minimum of (sum from root to given node - max value of sum from left child to any leaf, sum from root to given node - max value of sum from right child to any of it leaft). We will add this value to given node and to the ans(which count minimum increment to make all value from root to leaf equal).\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int s,vector<int>&cost,vector<int>&maxSum){\\n        if(s>(int)cost.size()) return ;\\n        dfs(2*s,cost,maxSum);\\n        dfs(2*s+1,cost,maxSum);\\n        maxSum[s]=cost[s-1]+max(maxSum[2*s],maxSum[(2*s)+1]);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int>maxSum(4*n,0);\\n        dfs(1,cost,maxSum);\\n        queue<pair<int,int>>q;\\n        q.push({1,cost[0]});\\n        int total=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            int numEle=n;\\n            int sum=0;\\n            int mx=INT_MIN;\\n            while(n--){\\n                int front=q.front().first;\\n                int s=q.front().second;\\n                q.pop();\\n                int val=min(maxSum[1] - (s+maxSum[2*front]), maxSum[1] - (s+maxSum[2*front + 1]));   // maxSum[1] will contain max sum from root to any leaf\\n                total+=val;\\n                s+=val;\\n                if((2*front)<=(int)cost.size()) q.push({2*front,s+cost[2*front-1]});\\n                if(2*front+1<=(int)cost.size()) q.push({2*front+1,s+cost[2*front]});\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```\\n\\n# Follow Up\\nFrom this approach we can also print how much value added to each node.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int s,vector<int>&cost,vector<int>&maxSum){\\n        if(s>(int)cost.size()) return ;\\n        dfs(2*s,cost,maxSum);\\n        dfs(2*s+1,cost,maxSum);\\n        maxSum[s]=cost[s-1]+max(maxSum[2*s],maxSum[(2*s)+1]);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int>maxSum(4*n,0);\\n        dfs(1,cost,maxSum);\\n        queue<pair<int,int>>q;\\n        q.push({1,cost[0]});\\n        int total=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            int numEle=n;\\n            int sum=0;\\n            int mx=INT_MIN;\\n            while(n--){\\n                int front=q.front().first;\\n                int s=q.front().second;\\n                q.pop();\\n                int val=min(maxSum[1] - (s+maxSum[2*front]), maxSum[1] - (s+maxSum[2*front + 1]));   // maxSum[1] will contain max sum from root to any leaf\\n                total+=val;\\n                s+=val;\\n                if((2*front)<=(int)cost.size()) q.push({2*front,s+cost[2*front-1]});\\n                if(2*front+1<=(int)cost.size()) q.push({2*front+1,s+cost[2*front]});\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502665,
                "title": "python-from-the-last-level-to-root-explained",
                "content": "Since we are dealing with the prefect binary tree, each node except the nodes on the last level has two children.\\n\\nLet\\'s considering the two children from the same parent. We have two pathes from the two children and the  difference between the two pathes is the difference of the children nodes because they share the same previous path from root. \\n\\nTherefore, to make the two pathes equal, we just need to check the value of the two children nodes. If they are not the same, we increase the one with the samller value. For the two pathes, the minimum number to inrease is difference between the two children.\\n\\nAfter the increase, the path cost to their parent would be the parent value + the max value of the two children. We can add this cost to the parent node. Next step, we apply the same method to the parent nodes level. Once we get to the root node, we can find out the minimum increases we need to make all the pathes equal.\\n\\nSee the code below:\\n\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        idx, ans = n - 1, 0\\n        while idx >= 2:\\n            parent_idx = idx // 2 - 1\\n            child_cost = cost[idx]\\n            if cost[idx] != cost[idx - 1]:\\n                child_cost = max(cost[idx], cost[idx - 1])\\n                ans += abs(cost[idx] - cost[idx - 1])\\n            cost[parent_idx] += child_cost\\n            idx -= 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        idx, ans = n - 1, 0\\n        while idx >= 2:\\n            parent_idx = idx // 2 - 1\\n            child_cost = cost[idx]\\n            if cost[idx] != cost[idx - 1]:\\n                child_cost = max(cost[idx], cost[idx - 1])\\n                ans += abs(cost[idx] - cost[idx - 1])\\n            cost[parent_idx] += child_cost\\n            idx -= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497934,
                "title": "java-easy-to-understand-dfs",
                "content": "Description:\\nThe task is to find the minimum number of increment operations required to make all the paths in a given binary tree with given cost values equal. This can be achieved by first calculating the maximum path sum in the binary tree and then finding the minimum number of operations required to make each path equal to the maximum path sum.\\nIntution:\\nWe can always make all paths equal by incrementing those leaf nodes where path sum is less than the maximum.\\nIn order to calculate the minimum operations we wil first do all the operations at last. Now at an arbitrary level which is non-root and non-leaf level we will do the minimum of operations done by it left and right child and decrease our total operations by same as we our doing operations on a common node. we will return number of operations done at this level to upperlevels.\\n```\\nclass Solution {\\n    int myN,max;\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        myN = n;\\n        max =  helper(0,cost);\\n        helper2(0,0,cost);\\n        return ans;\\n    }\\n\\t//to calculate maximum path sum.\\n    int helper(int i,int[] cost){\\n        if(i>=myN) return 0;\\n        int left = helper(2*i+1,cost);\\n        int right = helper(2*i+2,cost);\\n        return cost[i]+Math.max(left,right);\\n    }\\n\\t//to calculate minimum operations\\n    int helper2(int i,int sum,int[] cost){\\n        if(i>=myN){\\n\\t\\t\\t//update answer with operations needed\\n            ans+=(max-sum);\\n            return max-sum;\\n        }\\n\\t\\t//get operations done by lower leverls.\\n        int left = helper2(2*i+1,sum+cost[i],cost);\\n        int right = helper2(2*i+2,sum+cost[i],cost);\\n        \\n\\t\\t//reduce ans by min left,right\\n        ans-=(Math.min(left,right));\\n        return Math.min(left,right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int myN,max;\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        myN = n;\\n        max =  helper(0,cost);\\n        helper2(0,0,cost);\\n        return ans;\\n    }\\n\\t//to calculate maximum path sum.\\n    int helper(int i,int[] cost){\\n        if(i>=myN) return 0;\\n        int left = helper(2*i+1,cost);\\n        int right = helper(2*i+2,cost);\\n        return cost[i]+Math.max(left,right);\\n    }\\n\\t//to calculate minimum operations\\n    int helper2(int i,int sum,int[] cost){\\n        if(i>=myN){\\n\\t\\t\\t//update answer with operations needed\\n            ans+=(max-sum);\\n            return max-sum;\\n        }\\n\\t\\t//get operations done by lower leverls.\\n        int left = helper2(2*i+1,sum+cost[i],cost);\\n        int right = helper2(2*i+2,sum+cost[i],cost);\\n        \\n\\t\\t//reduce ans by min left,right\\n        ans-=(Math.min(left,right));\\n        return Math.min(left,right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496927,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            left, right = i * 2 + 1, i * 2 + 2\\n            ans += abs(cost[left] - cost[right])\\n            cost[i] += max(cost[left], cost[right])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            left, right = i * 2 + 1, i * 2 + 2\\n            ans += abs(cost[left] - cost[right])\\n            cost[i] += max(cost[left], cost[right])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496903,
                "title": "c-intuitive-solution-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int max_sum = INT_MIN;\\n\\n    int dfs1(vector<int>& cost, int root, int n) {\\n        if (2 * root > n) {\\n            return cost[root - 1];\\n        }\\n        int left = dfs1(cost, 2 * root, n);\\n        int right = dfs1(cost, 2 * root + 1, n);\\n        return max(left, right) + cost[root - 1];\\n    }\\n\\n    int dfs(vector<int>& cost, int root, int curr_sum, int max_sum, int n) {\\n        if (2 * root > n) {\\n            return max_sum - curr_sum - cost[root - 1];\\n        }\\n        int left = dfs(cost, 2 * root, curr_sum + cost[root - 1], max_sum, n);\\n        int right = dfs(cost, 2 * root + 1, curr_sum + cost[root - 1], max_sum, n);\\n        ans += abs(left - right);\\n        return min(left, right);\\n    }\\n\\n    int minIncrements(int n,vector<int>& nums) {\\n \\n        max_sum = dfs1(nums, 1, n);\\n        dfs(nums, 1, 0, max_sum, n);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int max_sum = INT_MIN;\\n\\n    int dfs1(vector<int>& cost, int root, int n) {\\n        if (2 * root > n) {\\n            return cost[root - 1];\\n        }\\n        int left = dfs1(cost, 2 * root, n);\\n        int right = dfs1(cost, 2 * root + 1, n);\\n        return max(left, right) + cost[root - 1];\\n    }\\n\\n    int dfs(vector<int>& cost, int root, int curr_sum, int max_sum, int n) {\\n        if (2 * root > n) {\\n            return max_sum - curr_sum - cost[root - 1];\\n        }\\n        int left = dfs(cost, 2 * root, curr_sum + cost[root - 1], max_sum, n);\\n        int right = dfs(cost, 2 * root + 1, curr_sum + cost[root - 1], max_sum, n);\\n        ans += abs(left - right);\\n        return min(left, right);\\n    }\\n\\n    int minIncrements(int n,vector<int>& nums) {\\n \\n        max_sum = dfs1(nums, 1, n);\\n        dfs(nums, 1, 0, max_sum, n);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495921,
                "title": "simple-java-solution-in-o-n-time-complexity-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Iterate from the nth node to the root node and compute the cost of path from the leaf node to the current node.\\n- As the tree is a complete binary tree, there will always be pair of left and right child nodes except for the root node.\\n- If the current node is leaf node, make the max of left and right node cost as the cost of path from bottom for both the nodes.\\n- The difference between the costs of 2 nodes give the number of increments required.\\n- If the nodes are not leaf nodes, calculate the number of increments required to make the cost of paths from bottom equal for the both nodes. \\n- In above step, increments might be needed for one of the 2 nodes, so that cost or path from leaf node becomes equal for both the nodes. \\n`cost[left-1] + cb[2*left] + k = cost[right-1] + cb[2*right]`\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for additional array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] cb = new int[n]; // cost from bottom\\n        int i = n;\\n        int res = 0;\\n        while(i>1){\\n            int r = i--;\\n            int l = i--;\\n            // if these are leaf nodes\\n            if(2*r > n){\\n                int max = Math.max(cost[l-1],cost[r-1]);\\n                cb[l-1] = max;\\n                cb[r-1] = max;\\n                res += Math.abs(cost[l-1]-cost[r-1]);\\n                continue;\\n            }\\n\\n            if(cost[l-1] + cb[2*l] <= cost[r-1] + cb[2*r]){\\n                int k = cost[r-1] + cb[2*r] - cb[2*l] - cost[l-1];\\n                // k is added to l\\n                res += k;\\n                cb[l-1] = cost[r-1] + cb[2*r];\\n                cb[r-1] = cost[r-1] + cb[2*r];\\n            }else{\\n                int k = cost[l-1] + cb[2*l] - cost[r-1] - cb[2*r];\\n                res += k;\\n                cb[l-1] = cost[l-1] + cb[2*l];\\n                cb[r-1] = cost[l-1] + cb[2*l];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] cb = new int[n]; // cost from bottom\\n        int i = n;\\n        int res = 0;\\n        while(i>1){\\n            int r = i--;\\n            int l = i--;\\n            // if these are leaf nodes\\n            if(2*r > n){\\n                int max = Math.max(cost[l-1],cost[r-1]);\\n                cb[l-1] = max;\\n                cb[r-1] = max;\\n                res += Math.abs(cost[l-1]-cost[r-1]);\\n                continue;\\n            }\\n\\n            if(cost[l-1] + cb[2*l] <= cost[r-1] + cb[2*r]){\\n                int k = cost[r-1] + cb[2*r] - cb[2*l] - cost[l-1];\\n                // k is added to l\\n                res += k;\\n                cb[l-1] = cost[r-1] + cb[2*r];\\n                cb[r-1] = cost[r-1] + cb[2*r];\\n            }else{\\n                int k = cost[l-1] + cb[2*l] - cost[r-1] - cb[2*r];\\n                res += k;\\n                cb[l-1] = cost[l-1] + cb[2*l];\\n                cb[r-1] = cost[l-1] + cb[2*l];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495843,
                "title": "different-approach-similar-to-merge-sort-o-nlog-n-c",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to think of divide and conquer algorithm.\\ni.e. lets say we have a array arr, which contains every path cost from root to leaf.\\narr = {10,4,12,15};\\nHere the common node for whole array is node 1.\\nthe common node for {10,4} is 2.\\nthe common node for {12,15} is 3.\\nthe common node for {10} is 4.\\nthe common node for {4} is 5.\\nthe common node for {12} is 6.\\nthe common node for {15} is 7.\\n\\nyou can scale this to some bigger perfect binary trees also.\\nto change both {10,4} values simultaneously we can change the value of their common node (here the common node is 2).\\n\\n<!-- # Approach\\nDescribe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*log(N))$$ Here N is the number of leaf nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // this array contains every cost of path from root to leaf\\n    vector<int> ans;\\n    \\n    void rec(vector<int> &cost,int n,int node,int val){\\n        if(node*2>n){\\n            // pushing the cost of path from root to leaf (node)\\n            ans.push_back(val+cost[node-1]);\\n            return;\\n        }\\n        \\n        rec(cost,n,2*node,val+cost[node-1]);\\n        rec(cost,n,2*node+1,val+cost[node-1]);\\n    }\\n    \\n    int cnt = 0; // this is our answer to the question\\n    int mx = -1; // this is the final value of every path\\n    \\n    //// this function is just like merge sort /////////////////\\n    void half(vector<int> &arr,int l,int r,int add){\\n        if(l>=r)\\n            return;\\n        int mid = (l+r)>>1;\\n        \\n        ////////////////// calculating maximum /////////////////\\n        int b = -1;\\n        for(int i=l;i<=mid;i++){\\n            b = max(b,arr[i]+add);\\n        }\\n        /// why doing max(b,arr[i]+add)\\n        /// arr[i] + add. here add variable tell us the total\\n        /// value that we have added to the parent or ancestor\\n        /// that came befor our current node. so if we have\\n        /// increase our ancestor by value add then we must also\\n        /// increase its childrens the the same value add.\\n        ////////////////////////////////////////////////////////\\n        \\n        cnt+=(mx-b); // how much to increase in this segment l - mid\\n        half(arr,l,mid,add+(mx-b));\\n        /// add+(mx-b). here mx-b tell us how much we need to increase\\n        /// the common node to make the value of the max to become \\n        /// mx i.e. the final equal value\\n        ////////////////////////////////////////////////////////\\n\\n        ///////////////// calculating maximum //////////////////\\n        b = -1;\\n        for(int i = mid+1;i<=r;i++){\\n            b = max(b,arr[i]+add);\\n        }\\n        ////////////////////////////////////////////////////////\\n\\n        cnt+=(mx-b); // how much to increase in this segment mid+1 - r\\n        half(arr,mid+1,r,add+(mx-b));\\n    }\\n    \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        rec(cost,n,1,0);\\n        /// calculating the final common value /////\\n        for(auto it:ans){\\n            mx = max(mx,it);\\n        }\\n        half(ans,0,ans.size()-1,0);  \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Depth-First Search",
                    "Merge Sort",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    // this array contains every cost of path from root to leaf\\n    vector<int> ans;\\n    \\n    void rec(vector<int> &cost,int n,int node,int val){\\n        if(node*2>n){\\n            // pushing the cost of path from root to leaf (node)\\n            ans.push_back(val+cost[node-1]);\\n            return;\\n        }\\n        \\n        rec(cost,n,2*node,val+cost[node-1]);\\n        rec(cost,n,2*node+1,val+cost[node-1]);\\n    }\\n    \\n    int cnt = 0; // this is our answer to the question\\n    int mx = -1; // this is the final value of every path\\n    \\n    //// this function is just like merge sort /////////////////\\n    void half(vector<int> &arr,int l,int r,int add){\\n        if(l>=r)\\n            return;\\n        int mid = (l+r)>>1;\\n        \\n        ////////////////// calculating maximum /////////////////\\n        int b = -1;\\n        for(int i=l;i<=mid;i++){\\n            b = max(b,arr[i]+add);\\n        }\\n        /// why doing max(b,arr[i]+add)\\n        /// arr[i] + add. here add variable tell us the total\\n        /// value that we have added to the parent or ancestor\\n        /// that came befor our current node. so if we have\\n        /// increase our ancestor by value add then we must also\\n        /// increase its childrens the the same value add.\\n        ////////////////////////////////////////////////////////\\n        \\n        cnt+=(mx-b); // how much to increase in this segment l - mid\\n        half(arr,l,mid,add+(mx-b));\\n        /// add+(mx-b). here mx-b tell us how much we need to increase\\n        /// the common node to make the value of the max to become \\n        /// mx i.e. the final equal value\\n        ////////////////////////////////////////////////////////\\n\\n        ///////////////// calculating maximum //////////////////\\n        b = -1;\\n        for(int i = mid+1;i<=r;i++){\\n            b = max(b,arr[i]+add);\\n        }\\n        ////////////////////////////////////////////////////////\\n\\n        cnt+=(mx-b); // how much to increase in this segment mid+1 - r\\n        half(arr,mid+1,r,add+(mx-b));\\n    }\\n    \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        rec(cost,n,1,0);\\n        /// calculating the final common value /////\\n        for(auto it:ans){\\n            mx = max(mx,it);\\n        }\\n        half(ans,0,ans.size()-1,0);  \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495594,
                "title": "simple-dfs-illstrated-c-6line",
                "content": "# Intuition\\nWe want our binary tree to verify the equal path property (the cost to go from root to any leaf has to be the same). I will call a binary tree which verifies this property balanced.\\nThe key logic is the following:\\n\\nThe optimal strategy is to ensure every subtree is balanced\\n\\nWhy is this true? Well, let\\u2019s imagine that there is a subtree rooted at a node subroot which is unbalanced. That is to say it can reach a certain leaf1 for lowcost, and another leaf2 for a different highcost.\\nWell, in that case, its parent node will reach leaf1 for lowcost+cost[subroot] and leaf2 for highcost+cost[subroot], which are different costs. We see that the unbalanced property is recursive: if any subtree is unbalanced, it will \\u201Ccontaminate\\u201D the parent.\\n![56b9ad51-e064-459f-a063-513c10ce5d02_1683437244.2906523.png](https://assets.leetcode.com/users/images/0a60aa6d-095d-4480-a3e0-804d77d7f2f8_1683439721.0159767.png)\\n\\n\\nTherefore, if we want to balance root, it is necessary to balance every subroot on its way. It is easy to verify that this is also a sufficient condition. So this is the optimal way to do it, because it is in fact the only way to do it! (root is balanced if and only if all of the subtrees are balanced)\\n\\nThat begs for a recursive approach! If we ensure starting from every leaf, that every subtree is balanced, then it\\u2019s easy to make the right corrections to balance the parent too!\\n\\n\\nApproach\\nLet\\u2019s do a recursive dfs.\\n\\nWe position ourselves at a specific node subroot and will treat it as the root of a subtree. We assume that all of its subtrees are already balanced (done earlier in the recursion). Then its left child reaches all leaves for leftcost, and the right child for rightcost. We just need to make a correction according to the difference between those two (correction+=abs(leftcost-rightcost)) to balance the subroot.\\n\\nWe then return the total cost of this subroot which is simply max(leftcost,rightcost)+cost[subroot]. The maximum is taken here because we can only increment, so that means after we balance a subtree, its cost to leaf will be set to the largest of the initial values.\\n\\nAnd that\\u2019s it! If this helped you understand the proof of correctness and visualize it, do leave an upvote, it is always encouraging!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs (int node ,vector<int>&cost)\\n    {    \\n        if(node>cost.size())return 0;\\n        int left=0 ,right=0;\\n        left= dfs(2*node,cost);\\n        right=dfs(2*node+1,cost);\\n        ans+=abs(left-right);\\n        return cost[node-1]+max(left,right);\\n    }\\n    int minIncrements(int N, vector<int>& cost)\\n    {\\n        dfs(1,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dfs (int node ,vector<int>&cost)\\n    {    \\n        if(node>cost.size())return 0;\\n        int left=0 ,right=0;\\n        left= dfs(2*node,cost);\\n        right=dfs(2*node+1,cost);\\n        ans+=abs(left-right);\\n        return cost[node-1]+max(left,right);\\n    }\\n    int minIncrements(int N, vector<int>& cost)\\n    {\\n        dfs(1,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495490,
                "title": "c-simple-implementation",
                "content": "**Algorithm:**\\n\\nThe variables used in the solution are:\\n* n -> the size of the binary tree array\\n* cost -> a vector of size n containing the costs of each node in the binary tree\\n* v -> a vector to store the sum of costs for each leaf node\\n* ans -> the minimum number of increments\\n\\nThe solution first constructs an array v of size (N + 1) / 2, where N is the size of the binary tree array. For each leaf node in the binary tree, the solution calculates the sum of costs along the path from the leaf node to the root node and appends it to the array v.\\n\\nThe algorithm then performs a loop until the size of v becomes 1. In each iteration, it creates a new empty vector v1 to store the maximum value of adjacent elements from the previous iteration. It then loops over the elements of v and performs the following operations:\\n\\n* Compute the absolute difference between the adjacent elements.\\n* Increment the answer by the absolute difference.\\n* Compute the maximum value of the adjacent elements.\\n* Append the maximum value to the vector v1.\\n\\nFinally, the algorithm returns the value of the answer variable.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> v;\\n        int ans = 0;\\n        for(int i = 0;i<n;i++){\\n            int child = 2 * (i + 1);\\n            if(child > n){\\n                int par = (i + 1) / 2;\\n                int sum = 0;\\n                int x = i + 1;\\n                while(x){\\n                    sum += cost[x - 1];\\n                    x /= 2;\\n                }\\n                v.push_back(sum);\\n            }\\n        }\\n        while(v.size() > 1){\\n            vector<int> v1;\\n            for(int i = 0;i<v.size();i+=2){\\n                int a = v[i] , b = v[i+1];\\n                int diff = abs(b - a);\\n                ans += diff;\\n                int mx = max(a, b);\\n                v1.push_back(mx);\\n            }\\n            v = v1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> v;\\n        int ans = 0;\\n        for(int i = 0;i<n;i++){\\n            int child = 2 * (i + 1);\\n            if(child > n){\\n                int par = (i + 1) / 2;\\n                int sum = 0;\\n                int x = i + 1;\\n                while(x){\\n                    sum += cost[x - 1];\\n                    x /= 2;\\n                }\\n                v.push_back(sum);\\n            }\\n        }\\n        while(v.size() > 1){\\n            vector<int> v1;\\n            for(int i = 0;i<v.size();i+=2){\\n                int a = v[i] , b = v[i+1];\\n                int diff = abs(b - a);\\n                ans += diff;\\n                int mx = max(a, b);\\n                v1.push_back(mx);\\n            }\\n            v = v1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495268,
                "title": "python-5-lines-o-n-beats-100",
                "content": "# Intuition\\n**The main insight is that two sibling leaves must have the same cost, if the path from root to them is to be the same, since they share the path to their direct parent.**\\nSo we start equalizing costs at the leaf level and go up, level by level, by adding the leaf costs to the parents (has same effect as removing the leaves, and we now deal with a smaller problem).\\n\\n# Approach\\nSince this is a full binary tree, it has `2^k-1` nodes distributed in `k` levels. Levels start, bottom to top, at `2^(k-1)`, `2^(k-2)` ... `2^1`, `2^0`. In the code `p` is the start node for the level being considered. On each level we look at pair of nodes (nodes `i` and `i+1`), equalize their values (increase the smaller to the larger value), update current value of the result by the difference, and update cost of their parent (node `i//2`).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        p = (n+1)//2 # start of leaves level\\n        while p > 1:\\n            i = p\\n            while i < 2*p:\\n                res += abs(cost[i-1]-cost[i]) # equalize the children nodes\\n                cost[i//2 - 1] += max(cost[i-1], cost[i]) # add cost of chidren to parent\\n                i += 2 # move to next pair of left/right nodes\\n            p //= 2 # go one level up\\n        return res        \\n```\\n\\nOnce you understand the code above, take a look at this more **concise version (5 lines)** of the same code:\\n\\n```\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        for i in reversed(range(2,n,2)):\\n            res += abs(cost[i-1]-cost[i])\\n            cost[i//2 - 1] += max(cost[i-1], cost[i])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        p = (n+1)//2 # start of leaves level\\n        while p > 1:\\n            i = p\\n            while i < 2*p:\\n                res += abs(cost[i-1]-cost[i]) # equalize the children nodes\\n                cost[i//2 - 1] += max(cost[i-1], cost[i]) # add cost of chidren to parent\\n                i += 2 # move to next pair of left/right nodes\\n            p //= 2 # go one level up\\n        return res        \\n```\n```\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        res = 0\\n        for i in reversed(range(2,n,2)):\\n            res += abs(cost[i-1]-cost[i])\\n            cost[i//2 - 1] += max(cost[i-1], cost[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495243,
                "title": "python-iterative-solution-o-n",
                "content": "# Intuition and Approach\\n* we have to find the minimum no. of increment operations.\\n* we will go for divide and conquer approach in which we will first find the no. of operations in left and right tree.\\n* simaltaneously we will store the cost from root to leaf at the root.\\n* Trick: two children tree must have the same cost from root to leaf.\\n* * if they had diff then make them same by increasing the smaller one with the diff. and cost of parent tree=max of both + cost of parent node.\\n* * ans+=max(lc,rc)-min(lc,rc); parent+=max(lc,rc);\\n* at the end return the sum of total oprations\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans=0\\n        for i in range(n-1,-1,-1):\\n            if((2*i)+2>=n):continue\\n            else:\\n                l=cost[(2*i)+1]\\n                r=cost[(2*i)+2]\\n                ans+=(max(l,r)-min(l,r))\\n                cost[i]+=max(l,r)\\n                # print(i,cost[i],ans)\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans=0\\n        for i in range(n-1,-1,-1):\\n            if((2*i)+2>=n):continue\\n            else:\\n                l=cost[(2*i)+1]\\n                r=cost[(2*i)+2]\\n                ans+=(max(l,r)-min(l,r))\\n                cost[i]+=max(l,r)\\n                # print(i,cost[i],ans)\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495176,
                "title": "c-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\npublic class Solution \\n{\\n    int result;\\n    public int MinIncrements(int n, int[] cost) \\n    {\\n        result = 0;\\n        DFS(1, n, cost);\\n        return result;\\n    }\\n\\n    private int DFS(int curr, int n, int[] cost)\\n    {\\n        if (curr > n / 2)\\n            return cost[curr - 1];\\n        int left = DFS(2 * curr, n, cost);\\n        int right = DFS(2 * curr + 1, n, cost);\\n        result += Math.Abs(right - left);\\n        return Math.Max(left, right) + cost[curr - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    int result;\\n    public int MinIncrements(int n, int[] cost) \\n    {\\n        result = 0;\\n        DFS(1, n, cost);\\n        return result;\\n    }\\n\\n    private int DFS(int curr, int n, int[] cost)\\n    {\\n        if (curr > n / 2)\\n            return cost[curr - 1];\\n        int left = DFS(2 * curr, n, cost);\\n        int right = DFS(2 * curr + 1, n, cost);\\n        result += Math.Abs(right - left);\\n        return Math.Max(left, right) + cost[curr - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495152,
                "title": "rust-python-no-recursion-optimized-linear-solution-with-constant-additional-memory",
                "content": "# Intuition\\n\\nSolution in Rust is highly optimized which uses constant additional space and reuses original array. I leave nonoptimized python solution submitted by me during the contest as it shows the intuition and how I got to this solution.\\n\\nIn general the idea is:\\n\\n 1. find the cost of every path. This is `bfs` in python and just one look (first one) in rust (costs will be last `(n + 1) / 2` elements).\\n 2. then find the maximum costs of the paths. In Python this is last block in return statement in bfs. In rust, second loop\\n 3. Then traverse back to find which node will you increase values. While loop in python, and last for loop in rust\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn min_increments(mut n: i32, mut cost: Vec<i32>) -> i32 {\\n    for i in 1 .. cost.len() {\\n      cost[i] += cost[(i - 1) / 2];\\n    }\\n\\n    let mut max = 0;\\n    for i in cost.len() / 2 .. cost.len() {\\n      max = max.max(cost[i]);\\n    }\\n\\n    for i in cost.len() / 2 .. cost.len() {\\n      cost[i] = max - cost[i];\\n    }\\n\\n    let mut res = 0;\\n    for i in (1 .. cost.len() / 2 + 1).rev() {\\n      let min = cost[2 * i].min(cost[2 * i - 1]);\\n      res += cost[2 * i] + cost[2 * i - 1] - 2 * min;\\n      cost[i - 1] = min;\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n\\n  def __init__(self):\\n    self.res = 0\\n\\n  def bfs(self, cost):\\n    frontier = [(1, cost[0])]\\n    while True:\\n      new_frontier = []\\n      for i, c in frontier:\\n        if i * 2 < len(cost):\\n          new_frontier.append((i * 2, c + cost[i * 2 - 1]))\\n          new_frontier.append((i * 2 + 1, c + cost[i * 2]))\\n\\n      if not new_frontier:\\n        r = [c for _, c in frontier]\\n        max_val = max(r)\\n        return [max_val - v for v in r]\\n\\n      frontier = new_frontier\\n\\n  def cmd(self, diff):\\n    tmp = []\\n    for i in range(len(diff) // 2):\\n      v1, v2 = diff[i * 2], diff[i * 2 + 1]\\n      m = min(v1, v2)\\n      tmp.append(m)\\n      self.res += v1 - m + v2 - m\\n\\n    return tmp\\n\\n  def minIncrements(self, n: int, cost: List[int]) -> int:\\n    self.res = 0\\n    diff = self.bfs(cost)\\n    while len(diff) > 1:\\n      diff = self.cmd(diff)\\n\\n    return self.res\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn min_increments(mut n: i32, mut cost: Vec<i32>) -> i32 {\\n    for i in 1 .. cost.len() {\\n      cost[i] += cost[(i - 1) / 2];\\n    }\\n\\n    let mut max = 0;\\n    for i in cost.len() / 2 .. cost.len() {\\n      max = max.max(cost[i]);\\n    }\\n\\n    for i in cost.len() / 2 .. cost.len() {\\n      cost[i] = max - cost[i];\\n    }\\n\\n    let mut res = 0;\\n    for i in (1 .. cost.len() / 2 + 1).rev() {\\n      let min = cost[2 * i].min(cost[2 * i - 1]);\\n      res += cost[2 * i] + cost[2 * i - 1] - 2 * min;\\n      cost[i - 1] = min;\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n\\n  def __init__(self):\\n    self.res = 0\\n\\n  def bfs(self, cost):\\n    frontier = [(1, cost[0])]\\n    while True:\\n      new_frontier = []\\n      for i, c in frontier:\\n        if i * 2 < len(cost):\\n          new_frontier.append((i * 2, c + cost[i * 2 - 1]))\\n          new_frontier.append((i * 2 + 1, c + cost[i * 2]))\\n\\n      if not new_frontier:\\n        r = [c for _, c in frontier]\\n        max_val = max(r)\\n        return [max_val - v for v in r]\\n\\n      frontier = new_frontier\\n\\n  def cmd(self, diff):\\n    tmp = []\\n    for i in range(len(diff) // 2):\\n      v1, v2 = diff[i * 2], diff[i * 2 + 1]\\n      m = min(v1, v2)\\n      tmp.append(m)\\n      self.res += v1 - m + v2 - m\\n\\n    return tmp\\n\\n  def minIncrements(self, n: int, cost: List[int]) -> int:\\n    self.res = 0\\n    diff = self.bfs(cost)\\n    while len(diff) > 1:\\n      diff = self.cmd(diff)\\n\\n    return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495144,
                "title": "python-easy-solution-using-dfs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        def dfs(at):\\n            nonlocal ans\\n            left = 2*at+1\\n            right = left+1\\n            if left >= n: return cost[at]\\n            \\n            left_val = dfs(left)\\n            right_val = dfs(right)\\n            \\n            ans += abs(left_val-right_val)\\n            # cost[left] = cost[right] = max(cost[left], cost[right])\\n            return max(left_val, right_val) + cost[at]\\n        \\n        dfs(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        def dfs(at):\\n            nonlocal ans\\n            left = 2*at+1\\n            right = left+1\\n            if left >= n: return cost[at]\\n            \\n            left_val = dfs(left)\\n            right_val = dfs(right)\\n            \\n            ans += abs(left_val-right_val)\\n            # cost[left] = cost[right] = max(cost[left], cost[right])\\n            return max(left_val, right_val) + cost[at]\\n        \\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494981,
                "title": "easy-java-code-find-diff-in-cost-at-each-level",
                "content": "# Code\\n```\\nclass Solution {\\n    int result = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        getCost(1, n, cost);\\n        return result;\\n    }\\n    \\n    private long getCost(int index, int n, int[] cost){\\n        if(index * 2 <= n){\\n            long leftCost = getCost(index * 2, n, cost);\\n            long rightCost = getCost(index * 2 + 1, n, cost);\\n            \\n            result = result + (int) Math.abs(leftCost - rightCost);\\n            return (cost[index - 1] + (Math.max(leftCost, rightCost)));\\n        }\\n        else{\\n            return cost[index - 1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        getCost(1, n, cost);\\n        return result;\\n    }\\n    \\n    private long getCost(int index, int n, int[] cost){\\n        if(index * 2 <= n){\\n            long leftCost = getCost(index * 2, n, cost);\\n            long rightCost = getCost(index * 2 + 1, n, cost);\\n            \\n            result = result + (int) Math.abs(leftCost - rightCost);\\n            return (cost[index - 1] + (Math.max(leftCost, rightCost)));\\n        }\\n        else{\\n            return cost[index - 1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494934,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinIncrements(int n, int[] cost)\\n    {\\n        var result = 0;\\n        var sum = new int[n];\\n\\n        for (var i = n - 1; i >= 0; i--)\\n        {\\n            sum[i] = cost[i];\\n\\n            if (i * 2 + 1 < n)\\n                sum[i] += Math.Max(sum[i * 2 + 1], sum[i * 2 + 2]);\\n        }\\n\\n        for (var i = 0; i < n; i++)\\n            if (i * 2 + 1 < n)\\n                result += Math.Abs(sum[i * 2 + 1] - sum[i * 2 + 2]);\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinIncrements(int n, int[] cost)\\n    {\\n        var result = 0;\\n        var sum = new int[n];\\n\\n        for (var i = n - 1; i >= 0; i--)\\n        {\\n            sum[i] = cost[i];\\n\\n            if (i * 2 + 1 < n)\\n                sum[i] += Math.Max(sum[i * 2 + 1], sum[i * 2 + 2]);\\n        }\\n\\n        for (var i = 0; i < n; i++)\\n            if (i * 2 + 1 < n)\\n                result += Math.Abs(sum[i * 2 + 1] - sum[i * 2 + 2]);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494849,
                "title": "c-dfs-sum-of-children-minus-minimum-o-n",
                "content": "\\n\\nThe idea is that you can DFS the binary tree and calculate the cost to make every path equal to the most expensive one. For every node, you can subtract the minimum of its children from the answer as you could have incremented that node instead and saved some moves.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    typedef array<int, 2> ai;\\n    ai dfs(int pos, int target, vector<int>& sum){\\n        if(pos*2 >= cost.size()) return {target-sum[pos-1],target-sum[pos-1]};\\n        int ans = 0;\\n        auto a1 = dfs(pos*2, target, sum);\\n        auto a2 = dfs(pos*2+1, target, sum);\\n        int mn = min(a1[1], a2[1]);\\n        ans += a1[0] + a2[0];\\n        ans -= mn;\\n        return {ans, mn};\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> sum(cost.size(), 0);\\n        queue<ai> q;\\n        q.push({1, 0});\\n        while(!q.empty()){ // precomputed sums array, can also do it in the dfs if you want to\\n            auto [id, d] = q.front();\\n            q.pop();\\n            if(id > n) continue;\\n            d += cost[id-1];\\n            sum[id-1] = d;\\n            q.push({id*2, d});\\n            q.push({id*2+1, d});\\n        }\\n        int target = *max_element(sum.begin(), sum.end());\\n        return dfs(1, cost, target, sum)[0];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    typedef array<int, 2> ai;\\n    ai dfs(int pos, int target, vector<int>& sum){\\n        if(pos*2 >= cost.size()) return {target-sum[pos-1],target-sum[pos-1]}",
                "codeTag": "Java"
            },
            {
                "id": 3494838,
                "title": "javascript-dfs",
                "content": "**Solution: DFS**\\n\\n**Key point: For each node, the sum of the all children paths must be equal since they share the same root path.**\\nSince we can only increase node values, we must make all path sums equal to the maximum path sum. \\nIncrease the child node with the smaller path sum to become equal to the larger path sum.\\nThen, return the maximum out of the left and right path sums.\\n\\n`n = number of nodes`, `h = height of tree`\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(h)`\\n```\\nvar minIncrements = function(n, cost) {\\n  let ans = 0;\\n  dfs(1);\\n  return ans;\\n  \\n  function dfs(i) { \\n    if (i * 2 > n) return cost[i - 1]; // leaf node\\n    let leftSum = dfs(2 * i), rightSum = dfs(2 * i + 1);\\n    ans += Math.max(leftSum, rightSum) - Math.min(leftSum, rightSum);\\n    return cost[i - 1] + Math.max(leftSum, rightSum);\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minIncrements = function(n, cost) {\\n  let ans = 0;\\n  dfs(1);\\n  return ans;\\n  \\n  function dfs(i) { \\n    if (i * 2 > n) return cost[i - 1]; // leaf node\\n    let leftSum = dfs(2 * i), rightSum = dfs(2 * i + 1);\\n    ans += Math.max(leftSum, rightSum) - Math.min(leftSum, rightSum);\\n    return cost[i - 1] + Math.max(leftSum, rightSum);\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087420,
                "title": "c-dfs-simple-code-intuition-and-approach-explained-simple-to-understand",
                "content": "# Intuition\\nIn this question we move in the array assuming it to be the tree.\\nfor 1 indexed room 2*i is left and 2*i+1 is right.\\nbut here we are taking it to be 0 indexed so we did 2*i as left and 2*i+1 as right.\\n\\n# Approach\\nWe find the maximum cost root to leaf path because we can only increase the cost of any path so the minimum we can do to make the cost of each path equal to the maximum.\\n\\nso as to have minimum number of increments, we need to increase the cost of the nodes as upper as possible because it will benefit all the lower path costs hence lesser number of increments will be needed to make cost of all the paths equal.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(2 * N) ~= O(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int node, int n, vector<int>&cost){\\n        if(node>=n)return 0;\\n        return cost[node]+max(func(2*node+1,n,cost), func(2*node+2,n,cost));\\n    }\\n\\n    int ans(int node,int currcost, int maxcost, int n, vector<int>&cost, int&already){\\n        if(node>=n)return abs(maxcost-currcost);\\n        int left = ans(node*2+1,cost[node]+currcost,maxcost,n,cost,already);\\n        int right = ans(node*2+2,cost[node]+currcost,maxcost,n,cost,already);\\n        already+=(abs(left-right));\\n        return min(left,right);\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        int maxcost = func(0,n,cost);\\n        int already = 0;\\n        int finalans = ans(0,0, maxcost,n,cost, already);\\n        return already+finalans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int node, int n, vector<int>&cost){\\n        if(node>=n)return 0;\\n        return cost[node]+max(func(2*node+1,n,cost), func(2*node+2,n,cost));\\n    }\\n\\n    int ans(int node,int currcost, int maxcost, int n, vector<int>&cost, int&already){\\n        if(node>=n)return abs(maxcost-currcost);\\n        int left = ans(node*2+1,cost[node]+currcost,maxcost,n,cost,already);\\n        int right = ans(node*2+2,cost[node]+currcost,maxcost,n,cost,already);\\n        already+=(abs(left-right));\\n        return min(left,right);\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        int maxcost = func(0,n,cost);\\n        int already = 0;\\n        int finalans = ans(0,0, maxcost,n,cost, already);\\n        return already+finalans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053382,
                "title": "ruby-o-n",
                "content": "```ruby\\n# @param {Integer} n\\n# @param {Integer[]} cost\\n# @return {Integer}\\ndef min_increments(n, cost)\\n  res = 0\\n  for node in (2...n).step(2).to_a.reverse\\n    res += (cost[node-1] - cost[node]).abs\\n    cost[node/2 - 1] += [cost[node-1], cost[node]].max\\n  end\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer} n\\n# @param {Integer[]} cost\\n# @return {Integer}\\ndef min_increments(n, cost)\\n  res = 0\\n  for node in (2...n).step(2).to_a.reverse\\n    res += (cost[node-1] - cost[node]).abs\\n    cost[node/2 - 1] += [cost[node-1], cost[node]].max\\n  end\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4043362,
                "title": "ok",
                "content": "```\\nint minIncrements(int n, vector<int>& c)\\n{\\n\\tint out{};\\n\\tfor(int i{n-1}; i; i-=2)\\n\\t{\\n\\t\\tauto [m, M] = minmax(c[i-1], c[i]);\\n\\t\\tc[(i-1)/2] += M; \\n\\t\\tout += M-m;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minIncrements(int n, vector<int>& c)\\n{\\n\\tint out{};\\n\\tfor(int i{n-1}; i; i-=2)\\n\\t{\\n\\t\\tauto [m, M] = minmax(c[i-1], c[i]);\\n\\t\\tc[(i-1)/2] += M; \\n\\t\\tout += M-m;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022550,
                "title": "c-from-leaves-node-just-check-diff-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0,t = n;\\n        vector<int> a;\\n        t /= 2;\\n        while(t>0){\\n            for(int i=0;i<t;i+=2){\\n                a.push_back(max(cost[i+t],cost[i+1+t]));\\n                ans += abs(cost[i+t]-cost[i+t+1]);\\n            }\\n            t /= 2;\\n            for(int i=0;i<=t;++i){\\n                cost[i+t] += a[i];\\n            }\\n            a.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0,t = n;\\n        vector<int> a;\\n        t /= 2;\\n        while(t>0){\\n            for(int i=0;i<t;i+=2){\\n                a.push_back(max(cost[i+t],cost[i+1+t]));\\n                ans += abs(cost[i+t]-cost[i+t+1]);\\n            }\\n            t /= 2;\\n            for(int i=0;i<=t;++i){\\n                cost[i+t] += a[i];\\n            }\\n            a.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002452,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    int dfs(int i, vector<int>& cost) {\\n        if (i >= cost.size()) return 0;\\n        \\n        int dis = 0;\\n        int left = cost[i] + dfs(2 * i+1, cost);\\n        int right = cost[i] + dfs(2 * i + 2, cost);\\n        \\n        dis = max(left, right);\\n        ans += (abs(left - right));\\n        return dis;\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(0, cost);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    int dfs(int i, vector<int>& cost) {\\n        if (i >= cost.size()) return 0;\\n        \\n        int dis = 0;\\n        int left = cost[i] + dfs(2 * i+1, cost);\\n        int right = cost[i] + dfs(2 * i + 2, cost);\\n        \\n        dis = max(left, right);\\n        ans += (abs(left - right));\\n        return dis;\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(0, cost);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930726,
                "title": "caution-the-index",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # we must balanced the subpath first \\n        # by the time we move up to a node, its decendents paths are already balanced locally\\n        # we start from the node n//2-1, and iterative backwards to 1.\\n\\n        res=0\\n        # the last non-leaf node is n//2 , but in the 0-indexed cost array is n//2-1\\n        for i in range(n//2-1,-1,-1):\\n            left=2*(i+1)-1\\n            right=2*(i+1)+1-1\\n            res+=abs(cost[left]-cost[right])\\n            cost[i]+=max(cost[left],cost[right])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # we must balanced the subpath first \\n        # by the time we move up to a node, its decendents paths are already balanced locally\\n        # we start from the node n//2-1, and iterative backwards to 1.\\n\\n        res=0\\n        # the last non-leaf node is n//2 , but in the 0-indexed cost array is n//2-1\\n        for i in range(n//2-1,-1,-1):\\n            left=2*(i+1)-1\\n            right=2*(i+1)+1-1\\n            res+=abs(cost[left]-cost[right])\\n            cost[i]+=max(cost[left],cost[right])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921730,
                "title": "c-python-bottom-up-solution-with-explanation",
                "content": "### bottom up\\n![image](https://assets.leetcode.com/users/images/d1fbd5ea-74b1-417c-812e-fae90b4dff85_1692265913.6029902.png)\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            ans += abs(cost[2 * i + 1] - cost[2 * i + 2])\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2])\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for (int i = n / 2 - 1; i >= 0; i -= 1) {\\n            ans += abs(cost[2*i+1] - cost[2*i+2]);\\n            cost[i] += max(cost[2*i+1], cost[2*i+2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        ans = 0\\n        for i in range(n // 2 - 1, -1, -1):\\n            ans += abs(cost[2 * i + 1] - cost[2 * i + 2])\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2])\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for (int i = n / 2 - 1; i >= 0; i -= 1) {\\n            ans += abs(cost[2*i+1] - cost[2*i+2]);\\n            cost[i] += max(cost[2*i+1], cost[2*i+2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920257,
                "title": "python3-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nrecursive \\ndist: distance from root to leaf\\noutput: cost \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        dist, output = self.helper(0, n, cost)\\n\\n        return output\\n\\n    def helper(self, p, n, cost):\\n        # p: node number of root\\n        if p < n:\\n\\n            l_dist, l_output = self.helper(2*p + 1, n, cost)\\n            r_dist, r_output = self.helper(2*p + 2, n, cost)\\n            \\n            dist = cost[p] + max(l_dist, r_dist)\\n            output = l_output + r_output + abs(l_dist - r_dist)\\n            \\n            return dist, output \\n        \\n        return 0, 0 \\n            \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        dist, output = self.helper(0, n, cost)\\n\\n        return output\\n\\n    def helper(self, p, n, cost):\\n        # p: node number of root\\n        if p < n:\\n\\n            l_dist, l_output = self.helper(2*p + 1, n, cost)\\n            r_dist, r_output = self.helper(2*p + 2, n, cost)\\n            \\n            dist = cost[p] + max(l_dist, r_dist)\\n            output = l_output + r_output + abs(l_dist - r_dist)\\n            \\n            return dist, output \\n        \\n        return 0, 0 \\n            \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888499,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\nis solved by traversing in revese from last parent node to root node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int res = 0, maxOfC;\\n        for (int i = ((n - 1) / 2) - 1; i >= 0 ; i--)\\n        {\\n            maxOfC = max(cost[2 * i + 1], cost[2 * i + 2]);\\n            res += (maxOfC -  min(cost[2 * i + 1], cost[2 * i + 2]));\\n            cost[i] = cost[i] + maxOfC;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int res = 0, maxOfC;\\n        for (int i = ((n - 1) / 2) - 1; i >= 0 ; i--)\\n        {\\n            maxOfC = max(cost[2 * i + 1], cost[2 * i + 2]);\\n            res += (maxOfC -  min(cost[2 * i + 1], cost[2 * i + 2]));\\n            cost[i] = cost[i] + maxOfC;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875928,
                "title": "java-postorder",
                "content": "# Intuition\\nPostOrder traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int sum=0;\\n    public int minIncrements(int n, int[] cost) {\\n        solve(n,cost,1);\\n        return sum;\\n    }\\n\\n    int solve(int n,int[]cost,int index){\\n\\n        if(index>cost.length){\\n            return 0;\\n        }\\n\\n        int left=solve(n,cost,2*index);\\n        int right=solve(n,cost,2*index+1);\\n\\n        if(left!=right){\\n            sum=sum+(int)Math.abs(left-right);\\n        }\\n        return cost[index-1]+Math.max(left,right);\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int minIncrements(int n, int[] cost) {\\n        solve(n,cost,1);\\n        return sum;\\n    }\\n\\n    int solve(int n,int[]cost,int index){\\n\\n        if(index>cost.length){\\n            return 0;\\n        }\\n\\n        int left=solve(n,cost,2*index);\\n        int right=solve(n,cost,2*index+1);\\n\\n        if(left!=right){\\n            sum=sum+(int)Math.abs(left-right);\\n        }\\n        return cost[index-1]+Math.max(left,right);\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865298,
                "title": "one-pass-detailed-explanation-and-comments",
                "content": "# Intuition\\nKey points:\\n1. You can only **increment**\\n2. For the two child nodes belonging to the same parent, they need to have equal values after the increment(so that the path from root to them can be the same)\\n\\n# Approach\\nBased on the intuitions, we can start from each pair of the child nodes from the same parent, two scenarios:\\n1. `child1.val` = `child2.val`, do nothing\\n2. `child1.val` != `child2.val`, the lesser value child needs to be incremented, it needs to increase by `abs(child1.val - child2.val)`. We also add the resulting value after the increment to the parent to keep track of totol path cost.\\n\\nNow, since the tree is a perfect tree (all nodes has 2 child except the leafs), we don\\'t need to actually build the tree. We can just link index to track parent and child: if a node\\'s index is i, its left child\\'s index is `2*i + 1`, right child\\'s index is `2*i + 2`. It is also easy to find a parent\\'s index given the child\\'s index.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ since you can use the input list directly, otherwise $$O(N)$$ if you don\\'t want to modify inputs\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minIncrements(self, n, cost):\\n        \"\"\"\\n        :type n: int\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(len(cost)-1, 0, -2): # go backward from the last node pair, notice step = 2\\n            a, b = cost[i], cost[i-1] \\n            diff = abs(a-b) # the increment we need to do for this pair\\n            res += diff\\n            par = i / 2 - 1 # index of the parent\\n            cost[par] += max(a, b) # increment parent to keep track of path cost\\n        return res\\n\\n         \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minIncrements(self, n, cost):\\n        \"\"\"\\n        :type n: int\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(len(cost)-1, 0, -2): # go backward from the last node pair, notice step = 2\\n            a, b = cost[i], cost[i-1] \\n            diff = abs(a-b) # the increment we need to do for this pair\\n            res += diff\\n            par = i / 2 - 1 # index of the parent\\n            cost[par] += max(a, b) # increment parent to keep track of path cost\\n        return res\\n\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857904,
                "title": "easy-c-code-without-recursion",
                "content": "# Intuition\\nThe given code aims to find the minimum number of increments needed to make each element of the input vector cost strictly greater than the previous element. It does this by iteratively merging adjacent elements and updating their values to meet the requirement.\\n\\n# Approach\\nThe given code uses a greedy approach to find the minimum number of increments required to make each element in the cost vector strictly greater than its previous element. The idea is to iteratively merge adjacent elements in the vector, updating their values in a way that maintains the increasing order.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>& cost,int& ans){\\n        if(cost.size()==0) return 0;\\n        for(int i=n-1;i>0;i-=2){\\n            ans+=abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        return solve(n, cost, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>& cost,int& ans){\\n        if(cost.size()==0) return 0;\\n        for(int i=n-1;i>0;i-=2){\\n            ans+=abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        return solve(n, cost, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857883,
                "title": "simple-c-code-without-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>& cost,int& ans){\\n        if(cost.size()==0) return 0;\\n        for(int i=n-1;i>0;i-=2){\\n            ans+=abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        return solve(n, cost, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, vector<int>& cost,int& ans){\\n        if(cost.size()==0) return 0;\\n        for(int i=n-1;i>0;i-=2){\\n            ans+=abs(cost[i]-cost[i-1]);\\n            cost[(i-1)/2]+=max(cost[i],cost[i-1]);\\n        }\\n        return ans;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        return solve(n, cost, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853584,
                "title": "beats-99-simple-recusion-tree-traversal-c",
                "content": "# Intuition\\nwhen ever a tree problem comes try to think about the recursion on left subtree and right subtree.\\n\\n# Approach\\nuse recursion and find path lenght of left subtree and right subtree and then use a simple logic at every node while comming back from recursion.\\nlogic : at every node the modification will be the difference in the path lenght of left subtree and right subtree.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int rec(int ind,vector<int> &cost){\\n        if(ind>=cost.size()){\\n            return 0;\\n        }\\n        else{\\n            int lsum=rec(2*ind+1,cost);\\n            int rsum=rec(2*ind+2,cost);\\n            ans+=(abs(lsum-rsum));\\n            return max(lsum,rsum)+cost[ind];\\n        }\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int val=rec(0,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int rec(int ind,vector<int> &cost){\\n        if(ind>=cost.size()){\\n            return 0;\\n        }\\n        else{\\n            int lsum=rec(2*ind+1,cost);\\n            int rsum=rec(2*ind+2,cost);\\n            ans+=(abs(lsum-rsum));\\n            return max(lsum,rsum)+cost[ind];\\n        }\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int val=rec(0,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824130,
                "title": "beats-99-92-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(int i,int &ans,int n,vector<int>&cost){\\n        if(i>n) return 0;\\n\\n        int l=solve(2*i,ans,n,cost);\\n        int r=solve(2*i+1,ans,n,cost);\\n\\n        ans+=abs(l-r);\\n        int x= max(l,r)+cost[i-1];\\n        return x;\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        solve(1,ans,n,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int i,int &ans,int n,vector<int>&cost){\\n        if(i>n) return 0;\\n\\n        int l=solve(2*i,ans,n,cost);\\n        int r=solve(2*i+1,ans,n,cost);\\n\\n        ans+=abs(l-r);\\n        int x= max(l,r)+cost[i-1];\\n        return x;\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        solve(1,ans,n,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795873,
                "title": "get-the-right-intution",
                "content": "# Intuition\\nAt every node you need that right sum and left sum should be equal.For this you increase the left or right node if sum is unequal.And this increase = diff between rightsum and leftsum.\\n\\n# Approach\\nRun a post order type traversal i.e first get left sum then right sum\\nNext compare both sum \\ndiff of these sum is what u need to inrcease\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int post(int nd,vector<int>&cost,int n){\\n      if(nd>n)return 0;\\n        int left=post(2*nd,cost,n);\\n        int right=post(2*nd+1,cost,n);\\n        if(left!=right)ans+=abs(left-right);\\n        return cost[nd-1]+max(left,right);\\n    \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n     post(1,cost,n);\\n     return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int post(int nd,vector<int>&cost,int n){\\n      if(nd>n)return 0;\\n        int left=post(2*nd,cost,n);\\n        int right=post(2*nd+1,cost,n);\\n        if(left!=right)ans+=abs(left-right);\\n        return cost[nd-1]+max(left,right);\\n    \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n     post(1,cost,n);\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788666,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) - Recursion stack not considered\\n\\n# Code\\n```\\npublic class Solution {\\n    int max_sum, min_increment;\\n    public int MinIncrements(int n, int[] cost) {\\n        max_sum = 0;\\n        min_increment = 0;\\n\\n        CalculateRootToLeafMax(cost, 0, 0, 0);\\n        MinIncrementsUntil(cost, 0, 0, 0);\\n\\n        return min_increment;\\n    }\\n\\n    private int MinIncrementsUntil(int[] cost, int level, int idx, int sum) {\\n        if(idx >= cost.Length)\\n            return max_sum - sum;\\n\\n        var child = idx << 1;\\n        var currSum = sum + cost[idx];\\n\\n        var left = MinIncrementsUntil(cost, 1 + level, child + 1, currSum);\\n        var right = MinIncrementsUntil(cost, 1 + level, child + 2, currSum);\\n\\n        var temp = Math.Min(left, right);\\n\\n        min_increment = min_increment + (left - temp) + (right - temp);\\n\\n        return temp;\\n    }\\n\\n    private void CalculateRootToLeafMax(int[] cost, int level, int idx, int sum) {\\n        if(idx >= cost.Length) {\\n            max_sum = Math.Max(max_sum, sum);\\n            return;\\n        }\\n\\n        var child = idx << 1;\\n        var currSum = sum + cost[idx];\\n\\n        CalculateRootToLeafMax(cost, 1 + level, child + 1, currSum);\\n        CalculateRootToLeafMax(cost, 1 + level, child + 2, currSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    int max_sum, min_increment;\\n    public int MinIncrements(int n, int[] cost) {\\n        max_sum = 0;\\n        min_increment = 0;\\n\\n        CalculateRootToLeafMax(cost, 0, 0, 0);\\n        MinIncrementsUntil(cost, 0, 0, 0);\\n\\n        return min_increment;\\n    }\\n\\n    private int MinIncrementsUntil(int[] cost, int level, int idx, int sum) {\\n        if(idx >= cost.Length)\\n            return max_sum - sum;\\n\\n        var child = idx << 1;\\n        var currSum = sum + cost[idx];\\n\\n        var left = MinIncrementsUntil(cost, 1 + level, child + 1, currSum);\\n        var right = MinIncrementsUntil(cost, 1 + level, child + 2, currSum);\\n\\n        var temp = Math.Min(left, right);\\n\\n        min_increment = min_increment + (left - temp) + (right - temp);\\n\\n        return temp;\\n    }\\n\\n    private void CalculateRootToLeafMax(int[] cost, int level, int idx, int sum) {\\n        if(idx >= cost.Length) {\\n            max_sum = Math.Max(max_sum, sum);\\n            return;\\n        }\\n\\n        var child = idx << 1;\\n        var currSum = sum + cost[idx];\\n\\n        CalculateRootToLeafMax(cost, 1 + level, child + 1, currSum);\\n        CalculateRootToLeafMax(cost, 1 + level, child + 2, currSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785392,
                "title": "c-dfs-binary-tree",
                "content": "# Code 1\\n```\\nclass Solution {\\n    int calculateTotalIncrement(int idx, int &n, int &ans, vector<int> &cost) {\\n        if (idx >= n) {\\n            return 0;\\n        } \\n\\n        int left = calculateTotalIncrement(2 * idx + 1, n, ans, cost);\\n        int right = calculateTotalIncrement(2 * idx + 2, n, ans, cost);\\n\\n        ans += abs(left - right);\\n\\n        return max(left, right) + cost[idx];\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        calculateTotalIncrement(0, n, ans, cost);\\n        \\n        return ans;\\n    }\\n};\\n```\\n# Code 2\\n```\\nclass Node {\\npublic:\\n    int val;\\n    int weight;\\n    Node *left;\\n    Node *right;\\n\\n    Node(int val, int weight) {\\n        this->val = val;\\n        this->weight = weight;\\n        this->left = nullptr;\\n        this->right = nullptr;\\n    }\\n};\\n\\nclass Solution {\\n    int calculateTotalIncrement(Node * root, int &ans) {\\n        if (!root) {\\n            return 0;\\n        }\\n        \\n        int left = calculateTotalIncrement(root->left, ans);\\n        int right = calculateTotalIncrement(root->right, ans);\\n        \\n        ans += (abs(left - right));\\n        \\n        return max(left, right) + root->weight;\\n    }\\n\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<Node *> nodes(n);\\n\\n        for (int idx = 0; idx < n; idx++) {\\n            Node *node = new Node(idx + 1, cost[idx]);\\n            nodes[idx] = node;\\n        }\\n\\n        int idx = 0;\\n\\n        while ((2 * idx + 1) < n - 1) {\\n            Node *node = nodes[idx];\\n\\n            node->left = nodes[2 * idx + 1];\\n            node->right = nodes[2 * idx + 2];\\n            \\n            idx++;\\n        }\\n        \\n        int ans = 0;\\n        calculateTotalIncrement(nodes[0], ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int calculateTotalIncrement(int idx, int &n, int &ans, vector<int> &cost) {\\n        if (idx >= n) {\\n            return 0;\\n        } \\n\\n        int left = calculateTotalIncrement(2 * idx + 1, n, ans, cost);\\n        int right = calculateTotalIncrement(2 * idx + 2, n, ans, cost);\\n\\n        ans += abs(left - right);\\n\\n        return max(left, right) + cost[idx];\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        calculateTotalIncrement(0, n, ans, cost);\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Node {\\npublic:\\n    int val;\\n    int weight;\\n    Node *left;\\n    Node *right;\\n\\n    Node(int val, int weight) {\\n        this->val = val;\\n        this->weight = weight;\\n        this->left = nullptr;\\n        this->right = nullptr;\\n    }\\n};\\n\\nclass Solution {\\n    int calculateTotalIncrement(Node * root, int &ans) {\\n        if (!root) {\\n            return 0;\\n        }\\n        \\n        int left = calculateTotalIncrement(root->left, ans);\\n        int right = calculateTotalIncrement(root->right, ans);\\n        \\n        ans += (abs(left - right));\\n        \\n        return max(left, right) + root->weight;\\n    }\\n\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<Node *> nodes(n);\\n\\n        for (int idx = 0; idx < n; idx++) {\\n            Node *node = new Node(idx + 1, cost[idx]);\\n            nodes[idx] = node;\\n        }\\n\\n        int idx = 0;\\n\\n        while ((2 * idx + 1) < n - 1) {\\n            Node *node = nodes[idx];\\n\\n            node->left = nodes[2 * idx + 1];\\n            node->right = nodes[2 * idx + 2];\\n            \\n            idx++;\\n        }\\n        \\n        int ans = 0;\\n        calculateTotalIncrement(nodes[0], ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782247,
                "title": "100-runtime-beat-recursive-way-to-solve-it",
                "content": "# Code\\n```\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\n\\nvoid balance(int root,int* cost,int costSize,int* totalCost){\\n    int left = 2 * root + 1;\\n    int right = 2 * root + 2;\\n    if(right * 2 + 1 > costSize){\\n        *totalCost += abs(cost[left]-cost[right]);\\n        cost[root] += max(cost[left],cost[right]);\\n    }\\n    else{\\n        balance(left,cost,costSize,totalCost);\\n        balance(right,cost,costSize,totalCost);\\n        *totalCost += abs(cost[left]-cost[right]);\\n        cost[root] += max(cost[left],cost[right]);\\n    }\\n}\\n\\nint minIncrements(int n, int* cost, int costSize){\\n    int result = 0;\\n    balance(0,cost,costSize,&result);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\n\\nvoid balance(int root,int* cost,int costSize,int* totalCost){\\n    int left = 2 * root + 1;\\n    int right = 2 * root + 2;\\n    if(right * 2 + 1 > costSize){\\n        *totalCost += abs(cost[left]-cost[right]);\\n        cost[root] += max(cost[left],cost[right]);\\n    }\\n    else{\\n        balance(left,cost,costSize,totalCost);\\n        balance(right,cost,costSize,totalCost);\\n        *totalCost += abs(cost[left]-cost[right]);\\n        cost[root] += max(cost[left],cost[right]);\\n    }\\n}\\n\\nint minIncrements(int n, int* cost, int costSize){\\n    int result = 0;\\n    balance(0,cost,costSize,&result);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722268,
                "title": "easiest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int  res = 0 ;\\n    static int ans( int i ,  int n , int[] cost   )\\n    {\\n        if( i>n  ) {\\n            return 0 ;\\n        }\\n\\n        int left = ans( 2*i , n , cost  );\\n        int right = ans( 2*i+1 , n , cost  );\\n        res += Math.abs( left - right );\\n        return cost[i-1] + Math.max( left , right );\\n\\n    }\\n\\n\\n    public int minIncrements(int n, int[] cost) {\\n        res = 0 ;\\n    ans( 1 , cost.length , cost );\\n      return res ;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int  res = 0 ;\\n    static int ans( int i ,  int n , int[] cost   )\\n    {\\n        if( i>n  ) {\\n            return 0 ;\\n        }\\n\\n        int left = ans( 2*i , n , cost  );\\n        int right = ans( 2*i+1 , n , cost  );\\n        res += Math.abs( left - right );\\n        return cost[i-1] + Math.max( left , right );\\n\\n    }\\n\\n\\n    public int minIncrements(int n, int[] cost) {\\n        res = 0 ;\\n    ans( 1 , cost.length , cost );\\n      return res ;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719705,
                "title": "o-n-solution-single-pass-self-explainatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int totalcost = 0;\\n        for(int i=n;i>=2;)\\n        {\\n            int node1 = i;\\n            int node2 = i-1;\\n            int parent = node1/2;\\n            totalcost+=abs(cost[node1-1]-cost[node2-1]);\\n            cost[parent-1] = cost[parent-1]+max(cost[node1-1],cost[node2-1]);\\n            i = i-2; \\n        }\\n        return totalcost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int totalcost = 0;\\n        for(int i=n;i>=2;)\\n        {\\n            int node1 = i;\\n            int node2 = i-1;\\n            int parent = node1/2;\\n            totalcost+=abs(cost[node1-1]-cost[node2-1]);\\n            cost[parent-1] = cost[parent-1]+max(cost[node1-1],cost[node2-1]);\\n            i = i-2; \\n        }\\n        return totalcost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716216,
                "title": "o-n-linear-simple-solution-bottomup",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis is an idea based on recursion but we do use bottom up approach. The idea here is to solve for subtrees and update the variable **ans** After solving for subtree we update its cost (By solving i mean we have calculated the no of operations to make all path sums in that subtree equal) and update it so that we do not need to calculate the path sum again and again. This has to be done from lower nodes to upper nodes.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe are given an array representing a tree.\\nWe do not solve for leaf nodes since the path sum to leaf from that node is its value only.\\n\\n- For each non-leaf node, we get the leaf-path-sum from its left node and right node.\\n- We calculate the diff and this would the operations required to make them equal\\n``` \\nans += abs(rightCost - leftCost)\\n\\n```\\n- update the child with less sum to become equal to its sibling.\\n- Update the sum of the node to either **curr + leftCost** or **curr + rightCost** since both would be equal.\\n- \\n# Complexity\\n- Time complexity: $$O(n)$$  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans =0 ;\\n        for(int i=(n/2 - 1) ;i>=0;i--) {\\n            int index = i+1;\\n            int leftCost = cost[2*index-1] ;\\n            int rightCost = cost[2*index];\\n            if(leftCost < rightCost) {\\n                ans += rightCost - leftCost;\\n                cost[2*index-1] = rightCost;\\n            }\\n            else if(leftCost > rightCost) {\\n                ans += leftCost - rightCost;\\n                cost[2*index] = leftCost;\\n            }\\n            cost[index-1] += cost[2*index];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "``` \\nans += abs(rightCost - leftCost)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans =0 ;\\n        for(int i=(n/2 - 1) ;i>=0;i--) {\\n            int index = i+1;\\n            int leftCost = cost[2*index-1] ;\\n            int rightCost = cost[2*index];\\n            if(leftCost < rightCost) {\\n                ans += rightCost - leftCost;\\n                cost[2*index-1] = rightCost;\\n            }\\n            else if(leftCost > rightCost) {\\n                ans += leftCost - rightCost;\\n                cost[2*index] = leftCost;\\n            }\\n            cost[index-1] += cost[2*index];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706262,
                "title": "python-post-order-traversal",
                "content": "```python\\nfrom functools import cache\\n\\n\\nclass Solution:\\n\\n    def minIncrements(self, n: int, cost: list[int]) -> int:\\n        @cache\\n        def post_order(i: int) -> tuple[int, int]:\\n            \"\"\"\\n            :param i: node id\\n            :return: total changes up to node \"i\", path sum from leaf to node \"i\"\\n            \"\"\"\\n            if i >= n:\\n                return 0, 0\\n            else:\\n                (l_inc, l_path_sum), (r_inc, r_path_sum) = post_order(2 * i + 1), post_order(2 * i + 2)\\n\\n                inc = l_inc + abs(l_path_sum - r_path_sum) + r_inc\\n                path_sum = cost[i] + max(l_path_sum, r_path_sum)\\n\\n                return inc, path_sum\\n\\n        return post_order(0)[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nfrom functools import cache\\n\\n\\nclass Solution:\\n\\n    def minIncrements(self, n: int, cost: list[int]) -> int:\\n        @cache\\n        def post_order(i: int) -> tuple[int, int]:\\n            \"\"\"\\n            :param i: node id\\n            :return: total changes up to node \"i\", path sum from leaf to node \"i\"\\n            \"\"\"\\n            if i >= n:\\n                return 0, 0\\n            else:\\n                (l_inc, l_path_sum), (r_inc, r_path_sum) = post_order(2 * i + 1), post_order(2 * i + 2)\\n\\n                inc = l_inc + abs(l_path_sum - r_path_sum) + r_inc\\n                path_sum = cost[i] + max(l_path_sum, r_path_sum)\\n\\n                return inc, path_sum\\n\\n        return post_order(0)[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702597,
                "title": "simple-approach-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBasically I update the cost[index] with total cost is used for traversing from that index node to the leaf node.\\n\\n--> I started the index from n-1 and try compare both value i.e (i and i-1) add the absolute difference in my ans variable.\\n\\n--> In leaf node only compare then iterate to (i-2),update the cost[index];\\n\\n--> In other nodes I take their child node value and add in parent node then compare do the same thing as do in leaf node,and at last update the cost[index].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void fun(int & ans,int i,int n,vector<int>& cost){\\n        if(i == 0){\\n            //ans = ans + abs(cost[2*i] - cost[2*i + 1]);\\n            return;\\n        }\\n        else{\\n            if(2* i > n && 2*i + 1 > n){ // for leaf node\\n                if(cost[i] >= cost[i-1]){\\n                    ans = ans + cost[i] - cost[i-1];\\n                    //cout<<ans<<\"leaf \";\\n                }\\n                else{\\n                    ans = ans + cost[i-1] - cost[i];\\n                    //cout<<ans<<\"leaf \";\\n                }\\n\\n                int x = max(cost[i],cost[i-1]);\\n\\n                cost[i] = x;\\n                cost[i-1] = x;\\n\\n                fun(ans,i-2,n,cost);\\n            }\\n            else if(2*i < n && 2*i + 1 < n ){\\n                int right = cost[2*i + 1] + cost[i];\\n\\n                int left = cost[2*(i-1) + 1] + cost[i-1];\\n\\n                //cout<<right<<\" \"<<left<<\"\\\\n\";\\n\\n                cost[i] = right;\\n\\n                cost[i-1] = left;\\n\\n                if(cost[i] >= cost[i-1]){\\n                    ans = ans + cost[i] - cost[i-1];\\n                    //cout<<ans<<\" \";\\n                }\\n                else{\\n                    ans = ans + cost[i-1] - cost[i];\\n                    //cout<<ans<<\" \";\\n                }\\n\\n                \\n                int x = max(cost[i],cost[i-1]);\\n\\n                cost[i] = x;\\n                cost[i-1] = x;\\n\\n                fun(ans,i-2,n,cost);\\n            }\\n        }\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        \\n        int ans =0;\\n\\n        int i = n-1;\\n\\n        fun(ans,i,n,cost);\\n\\n        for(int i=0;i<n;i++){\\n            cout<<cost[i]<<\" \";\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void fun(int & ans,int i,int n,vector<int>& cost){\\n        if(i == 0){\\n            //ans = ans + abs(cost[2*i] - cost[2*i + 1]);\\n            return;\\n        }\\n        else{\\n            if(2* i > n && 2*i + 1 > n){ // for leaf node\\n                if(cost[i] >= cost[i-1]){\\n                    ans = ans + cost[i] - cost[i-1];\\n                    //cout<<ans<<\"leaf \";\\n                }\\n                else{\\n                    ans = ans + cost[i-1] - cost[i];\\n                    //cout<<ans<<\"leaf \";\\n                }\\n\\n                int x = max(cost[i],cost[i-1]);\\n\\n                cost[i] = x;\\n                cost[i-1] = x;\\n\\n                fun(ans,i-2,n,cost);\\n            }\\n            else if(2*i < n && 2*i + 1 < n ){\\n                int right = cost[2*i + 1] + cost[i];\\n\\n                int left = cost[2*(i-1) + 1] + cost[i-1];\\n\\n                //cout<<right<<\" \"<<left<<\"\\\\n\";\\n\\n                cost[i] = right;\\n\\n                cost[i-1] = left;\\n\\n                if(cost[i] >= cost[i-1]){\\n                    ans = ans + cost[i] - cost[i-1];\\n                    //cout<<ans<<\" \";\\n                }\\n                else{\\n                    ans = ans + cost[i-1] - cost[i];\\n                    //cout<<ans<<\" \";\\n                }\\n\\n                \\n                int x = max(cost[i],cost[i-1]);\\n\\n                cost[i] = x;\\n                cost[i-1] = x;\\n\\n                fun(ans,i-2,n,cost);\\n            }\\n        }\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        \\n        int ans =0;\\n\\n        int i = n-1;\\n\\n        fun(ans,i,n,cost);\\n\\n        for(int i=0;i<n;i++){\\n            cout<<cost[i]<<\" \";\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3689607,
                "title": "c-start-from-bottom-up",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0,leftChildCost=0,rightChildCost=0;\\n        \\n        for (int i=n/2 -1;i>=0;i--){\\n            leftChildCost = cost[i*2+1];\\n            rightChildCost = cost[i*2+2];\\n            ans += abs(leftChildCost-rightChildCost);\\n            cost[i] += max(leftChildCost,rightChildCost);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0,leftChildCost=0,rightChildCost=0;\\n        \\n        for (int i=n/2 -1;i>=0;i--){\\n            leftChildCost = cost[i*2+1];\\n            rightChildCost = cost[i*2+2];\\n            ans += abs(leftChildCost-rightChildCost);\\n            cost[i] += max(leftChildCost,rightChildCost);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674969,
                "title": "easiest-implementation-best-idea-greedy-and-unique-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int min_cost=0;\\n        for(int i=n-1;i>0;i-=2)\\n        {\\n            int left=cost[i], right=cost[i-1], par=(i-1)/2;\\n            if(left>right)\\n            {\\n                min_cost+=left-right;\\n                right=left;\\n            }\\n            else\\n            {\\n                min_cost+=right-left;\\n                left=right;\\n            }\\n            cost[par]=cost[par]+left;\\n        }\\n        return min_cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int min_cost=0;\\n        for(int i=n-1;i>0;i-=2)\\n        {\\n            int left=cost[i], right=cost[i-1], par=(i-1)/2;\\n            if(left>right)\\n            {\\n                min_cost+=left-right;\\n                right=left;\\n            }\\n            else\\n            {\\n                min_cost+=right-left;\\n                left=right;\\n            }\\n            cost[par]=cost[par]+left;\\n        }\\n        return min_cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674775,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Build the solution from the leaves upwards\\n- Relies on this invariant of `dfs`: add the correct number of increments for the current subtree to `res` and return its total cost\\n- Thus, when the algorithm comes back to the root, the left and right subtrees have already been solved and what\\'s left is to compare their heights and add the number of increments to make up their difference\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$ O(n) $$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$ O(h) $$, where $$ h $$ is height\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int res;\\n\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return res;\\n    }\\n\\n    int dfs(int root, vector<int>& cost, int n) {\\n        if (root > n) {\\n            return 0;\\n        }\\n\\n        int leftLen = dfs(root * 2, cost, n);\\n        int rightLen = dfs(root * 2 + 1, cost, n);\\n        res += abs(leftLen - rightLen);\\n        return cost[root - 1] + max(leftLen, rightLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int res;\\n\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return res;\\n    }\\n\\n    int dfs(int root, vector<int>& cost, int n) {\\n        if (root > n) {\\n            return 0;\\n        }\\n\\n        int leftLen = dfs(root * 2, cost, n);\\n        int rightLen = dfs(root * 2 + 1, cost, n);\\n        res += abs(leftLen - rightLen);\\n        return cost[root - 1] + max(leftLen, rightLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670271,
                "title": "95-beats-iterative-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        for(int i=n/2-1;i>=0;i--){\\n            int left=2*i+1;\\n            int right=2*i+2;\\n            ans+=abs(cost[left]-cost[right]);\\n            cost[i]+=max(cost[left],cost[right]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        for(int i=n/2-1;i>=0;i--){\\n            int left=2*i+1;\\n            int right=2*i+2;\\n            ans+=abs(cost[left]-cost[right]);\\n            cost[i]+=max(cost[left],cost[right]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649252,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int sum,int &ans,vector<int>&dp,vector<int>&cost,int n){\\n        if(i>=n)return;\\n        int inc=sum-dp[i];\\n        ans+=inc;\\n     solve(2*i+1,sum-inc-cost[i],ans,dp,cost,n);\\n     solve(2*i+2,sum-inc-cost[i],ans,dp,cost,n);\\n    }\\n    int minIncrements(int n, vector<int>&cost) {\\n        vector<int>dp(n);\\n        int p=log2(n);\\n        for(int i=n-1;i>(n-1-(1<<p));i--)dp[i]=cost[i];\\n        int i=n-1;\\n        while(i>0){\\n                dp[(i-1)/2]=max(dp[i],dp[i-1])+cost[(i-1)/2];\\n                i-=2;\\n        }\\n        int ans=0;\\n        solve(0,dp[0],ans,dp,cost,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int sum,int &ans,vector<int>&dp,vector<int>&cost,int n){\\n        if(i>=n)return;\\n        int inc=sum-dp[i];\\n        ans+=inc;\\n     solve(2*i+1,sum-inc-cost[i],ans,dp,cost,n);\\n     solve(2*i+2,sum-inc-cost[i],ans,dp,cost,n);\\n    }\\n    int minIncrements(int n, vector<int>&cost) {\\n        vector<int>dp(n);\\n        int p=log2(n);\\n        for(int i=n-1;i>(n-1-(1<<p));i--)dp[i]=cost[i];\\n        int i=n-1;\\n        while(i>0){\\n                dp[(i-1)/2]=max(dp[i],dp[i-1])+cost[(i-1)/2];\\n                i-=2;\\n        }\\n        int ans=0;\\n        solve(0,dp[0],ans,dp,cost,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649144,
                "title": "java-solution-using-recursion",
                "content": "# Intuition\\nTo solve this problem, you can use a recursive approach. The intuition is to calculate the cost for each path from the root to a leaf node, and then find the minimum number of increments needed to make all the paths have equal costs.\\n\\n# Approach\\nWhile calcultaing the maxLength recursively, maintain two array leftSum and rightSum. The leftSum and rightSum will contain the max length to current node. On the next recursion, just keep on sending remainingSum which is maxLength - cost[i] to each child node. If both leftSum(i) and rightSum(i) are less than remainingSum then we know that we can increase the cost[i] by remainingSum-max(leftSum[i], rightSum[i]).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int maxLength;\\n    int []leftSum;\\n    int []rightSum;\\n    int ans;\\n    public int getMaxLength(int[] cost, int i) {\\n        if(i>=cost.length) {\\n            return 0;\\n        }\\n        if(cost.length<=((2*i) + 1) || cost.length<=((2*i) + 2)) {\\n            leftSum[i] = cost[i];\\n            rightSum[i] = cost[i];\\n            return cost[i];\\n        }\\n        leftSum[i] = getMaxLength(cost, 2*i+1) + cost[i];\\n        rightSum[i] = getMaxLength(cost, 2*i+2) + cost[i];\\n\\n        return Math.max(leftSum[i], rightSum[i]);\\n\\n    }\\n    public void traverse1(int[] cost, int remainingSum, int i) {\\n        if(i>=cost.length) {\\n            return;\\n        }\\n        if(cost.length<=((2*i) + 1) || cost.length<=((2*i) + 2)) {\\n            ans = ans + (remainingSum-leftSum[i]);\\n            return;\\n        }\\n        int inc = 0;\\n        if(leftSum[i]<remainingSum && rightSum[i]<remainingSum) {\\n            inc = remainingSum - Math.max(leftSum[i], rightSum[i]);\\n            leftSum[i] +=inc;\\n            rightSum[i] +=inc;\\n            cost[i]+=inc;\\n            ans+=inc;\\n        } else {\\n            inc = 0;\\n        }\\n        traverse1(cost, remainingSum-cost[i], 2*i+1);\\n        traverse1(cost, remainingSum-cost[i], 2*i+2);\\n\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        \\n        leftSum = new int[n];\\n        rightSum = new int[n];\\n        maxLength = getMaxLength(cost, 0);\\n        traverse1(cost, maxLength, 0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxLength;\\n    int []leftSum;\\n    int []rightSum;\\n    int ans;\\n    public int getMaxLength(int[] cost, int i) {\\n        if(i>=cost.length) {\\n            return 0;\\n        }\\n        if(cost.length<=((2*i) + 1) || cost.length<=((2*i) + 2)) {\\n            leftSum[i] = cost[i];\\n            rightSum[i] = cost[i];\\n            return cost[i];\\n        }\\n        leftSum[i] = getMaxLength(cost, 2*i+1) + cost[i];\\n        rightSum[i] = getMaxLength(cost, 2*i+2) + cost[i];\\n\\n        return Math.max(leftSum[i], rightSum[i]);\\n\\n    }\\n    public void traverse1(int[] cost, int remainingSum, int i) {\\n        if(i>=cost.length) {\\n            return;\\n        }\\n        if(cost.length<=((2*i) + 1) || cost.length<=((2*i) + 2)) {\\n            ans = ans + (remainingSum-leftSum[i]);\\n            return;\\n        }\\n        int inc = 0;\\n        if(leftSum[i]<remainingSum && rightSum[i]<remainingSum) {\\n            inc = remainingSum - Math.max(leftSum[i], rightSum[i]);\\n            leftSum[i] +=inc;\\n            rightSum[i] +=inc;\\n            cost[i]+=inc;\\n            ans+=inc;\\n        } else {\\n            inc = 0;\\n        }\\n        traverse1(cost, remainingSum-cost[i], 2*i+1);\\n        traverse1(cost, remainingSum-cost[i], 2*i+2);\\n\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        \\n        leftSum = new int[n];\\n        rightSum = new int[n];\\n        maxLength = getMaxLength(cost, 0);\\n        traverse1(cost, maxLength, 0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636709,
                "title": "easy-greedy-approach",
                "content": "# Intuition\\nJust greedy\\n# Approach\\ntraverse from back of the array and change the cost array whenever there is mismatch in children of a node(add diff of cost of child to parent) ,and take the sum of differnce in cost of children.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(2*(i+1)<=n && 2*(i+1)+1<=n)\\n            {\\n                ans+=abs(cost[2*i+1]-cost[2*i+2]);\\n                cost[i]+=max(cost[2*i+1],cost[2*i+2]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(2*(i+1)<=n && 2*(i+1)+1<=n)\\n            {\\n                ans+=abs(cost[2*i+1]-cost[2*i+2]);\\n                cost[i]+=max(cost[2*i+1],cost[2*i+2]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627719,
                "title": "bottom-up-python-beats-96",
                "content": "# Intuition\\nBottum up, at each level, we do\\n1. add the difference of the cost between 2 siblings to the result\\n2. add the max cost of the 2 to their parent\\n\\n# Complexity\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        r = 0\\n        n -= 1\\n        while n > 0:\\n            rv = cost[n]\\n            n -= 1\\n            lv = cost[n]\\n            r += abs(lv - rv)\\n            n -= 1\\n            parent = n // 2\\n            cost[parent] += max(lv, rv)\\n        return r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        r = 0\\n        n -= 1\\n        while n > 0:\\n            rv = cost[n]\\n            n -= 1\\n            lv = cost[n]\\n            r += abs(lv - rv)\\n            n -= 1\\n            parent = n // 2\\n            cost[parent] += max(lv, rv)\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592965,
                "title": "java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif you see carefully ,for every subtree the cost of parent node will be shared equally to left  tree portion and right tree portion.so we just need to balance the cost of left subtree and right subtree.so we calculate the difference of left subtree and right subtree cost ,that many times we perfom increment operation on the shortage side.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int increments;\\n    private int back(int[]cost,int root){\\n         if(root>cost.length)return 0;\\n         int left=2*root; //calculate left and right subtree cost\\n         int right=left+1; \\n         \\n         int lsum=back(cost,left);\\n         int rsum=back(cost,right);\\n         increments+=Math.abs(lsum-rsum);//adding the  number of operations required to equalize the cost of both subtrees \\n         return cost[root-1]+Math.max(lsum,rsum);  \\n\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n      increments=0;\\n      back(cost,1);\\n      return increments;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int increments;\\n    private int back(int[]cost,int root){\\n         if(root>cost.length)return 0;\\n         int left=2*root; //calculate left and right subtree cost\\n         int right=left+1; \\n         \\n         int lsum=back(cost,left);\\n         int rsum=back(cost,right);\\n         increments+=Math.abs(lsum-rsum);//adding the  number of operations required to equalize the cost of both subtrees \\n         return cost[root-1]+Math.max(lsum,rsum);  \\n\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n      increments=0;\\n      back(cost,1);\\n      return increments;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564029,
                "title": "beats-100-2-line-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the absolute difference between the costs of the left child (2 * i + 1) and the right child (2 * i + 2) of each node at index i. Add this difference to the moves variable to keep track of the total increments needed.\\n\\nUpdate the cost of the current node (at index i) by adding the maximum cost between its left and right child. This ensures that the cost of the current node becomes equal to the maximum cost among its children.\\n\\nRepeat the above steps for the parent nodes up to the root.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minIncrements = function(n, cost) {\\n    let moves = 0;\\n    for(let i = (n + 1) / 2 - 2; i >= 0; i--) {\\n        moves += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n    }\\n    return moves;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563771,
                "title": "4-liner-c-lazy-propagation",
                "content": "\\n# Complexity\\n- Time complexity:\\n***O(n)***\\n\\n- Space complexity: \\n***O(1)***\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n-1; i >= 2 ; i-=2) {\\n            ans += (max(cost[i], cost[i-1]) - min(cost[i], cost[i-1]));\\n            cost[(i-1)/2] += max(cost[i], cost[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n-1; i >= 2 ; i-=2) {\\n            ans += (max(cost[i], cost[i-1]) - min(cost[i], cost[i-1]));\\n            cost[(i-1)/2] += max(cost[i], cost[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562583,
                "title": "easy-to-understand-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    \\n    int solve(int i, int n, vector<int> &cost){\\n        if(i==n) return cost[n-1];\\n        if(2*i>=n) return cost[i-1];\\n        \\n        int left=0;\\n        left = solve(2*i,n,cost);\\n        int rt=0;\\n        rt = solve(2*i+1,n,cost);\\n        int diff = abs(left-rt);\\n        cnt+=diff;\\n        return max(left,rt) + cost[i-1];\\n    }\\n    \\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        int i=1;\\n        int val = solve(1,n,cost);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    \\n    int solve(int i, int n, vector<int> &cost){\\n        if(i==n) return cost[n-1];\\n        if(2*i>=n) return cost[i-1];\\n        \\n        int left=0;\\n        left = solve(2*i,n,cost);\\n        int rt=0;\\n        rt = solve(2*i+1,n,cost);\\n        int diff = abs(left-rt);\\n        cnt+=diff;\\n        return max(left,rt) + cost[i-1];\\n    }\\n    \\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        int i=1;\\n        int val = solve(1,n,cost);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558676,
                "title": "o-1-space-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        int i=(n-1)/2;\\n        while(i>=1){\\n            ans+=abs(cost[2*i-1]-cost[2*i+1-1]);\\n            cost[i-1]=cost[i-1]+max(cost[2*i-1],cost[2*i+1-1]);\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0;\\n        int i=(n-1)/2;\\n        while(i>=1){\\n            ans+=abs(cost[2*i-1]-cost[2*i+1-1]);\\n            cost[i-1]=cost[i-1]+max(cost[2*i-1],cost[2*i+1-1]);\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553714,
                "title": "c-240-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, const vector<int>& cost)\\n    {\\n        int count=0;\\n\\n        function<int(int)> func = [&](int pos)\\n        {\\n            int left  = 0;\\n            int right = 0;\\n            int tmp = pos * 2 + 1;\\n\\n            if(tmp < cost.size())\\n            {\\n                left  = func(tmp);\\n                right = func(tmp + 1);\\n                count += abs(left - right);\\n            }\\n\\n            return max(left, right) + cost[pos];\\n        };\\n\\n        func(0);\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, const vector<int>& cost)\\n    {\\n        int count=0;\\n\\n        function<int(int)> func = [&](int pos)\\n        {\\n            int left  = 0;\\n            int right = 0;\\n            int tmp = pos * 2 + 1;\\n\\n            if(tmp < cost.size())\\n            {\\n                left  = func(tmp);\\n                right = func(tmp + 1);\\n                count += abs(left - right);\\n            }\\n\\n            return max(left, right) + cost[pos];\\n        };\\n\\n        func(0);\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543320,
                "title": "java-3-liner-constant-space-and-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs every path leading upto root must be the same cost, two children must have the same cost. As we can only increment, we\\'ve to increment the cost of the node with lesser cost. We do this bottoms up and update cost of each node to cost of path to any leaf node from that node (they\\'ll all be equal as we\\'re adjusting costs).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the tree is a perfect binary tree, it\\'s size will be always be one less than a power of 2. As we can track increments as we update costs, we can just modify the cost array and don\\'t need extra space. We start from the layer above the leaf nodes as leaf nodes cost adjustment really need not be recorded.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int res = 0;\\n    \\n        for (int i = (n - 2) / 2; i >= 0; i--) {\\n            cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n            res += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int res = 0;\\n    \\n        for (int i = (n - 2) / 2; i >= 0; i--) {\\n            cost[i] += Math.max(cost[2 * i + 1], cost[2 * i + 2]);\\n            res += Math.abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532176,
                "title": "optimizing-cost-equality-in-perfect-binary-trees-using-dfs-and-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn a perfect binary tree, the objective is to equalise the costs of all pathways leading from the root to each leaf node. We can reduce the total number of increments necessary by raising the costs of a few specific nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo navigate the ideal binary tree, we can utilise a depth-first search (DFS). We determine the absolute difference between each node\\'s left and right child node sums at each node. This difference is added to the final outcome. Along with the cost of the current node, we also return the highest sum between the left and right child nodes. We discover the ideal increments for each subtree in this way.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumIncrements = 0;\\n\\n    // Depth-first search function\\n    int dfs(int index, vector<int>& cost) {\\n        // Base case: If index exceeds the size of the cost vector, return 0\\n        if (index > cost.size()) {\\n            return 0;\\n        }\\n\\n        // Recursive calls for left and right child nodes\\n        int leftSum = dfs(2 * index, cost);\\n        int rightSum = dfs(2 * index + 1, cost);\\n\\n        // Calculate the absolute difference between left and right child sums\\n        int difference = abs(leftSum - rightSum);\\n\\n        // Accumulate the absolute difference to the overall result\\n        minimumIncrements += difference;\\n\\n        // Return the maximum sum between the left and right child nodes, plus the current cost\\n        return max(leftSum, rightSum) + cost[index - 1];\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        // Start the depth-first search from the root node (index 1)\\n        int sum = dfs(1, cost);\\n\\n        // Return the accumulated minimum increments\\n        return minimumIncrements;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumIncrements = 0;\\n\\n    // Depth-first search function\\n    int dfs(int index, vector<int>& cost) {\\n        // Base case: If index exceeds the size of the cost vector, return 0\\n        if (index > cost.size()) {\\n            return 0;\\n        }\\n\\n        // Recursive calls for left and right child nodes\\n        int leftSum = dfs(2 * index, cost);\\n        int rightSum = dfs(2 * index + 1, cost);\\n\\n        // Calculate the absolute difference between left and right child sums\\n        int difference = abs(leftSum - rightSum);\\n\\n        // Accumulate the absolute difference to the overall result\\n        minimumIncrements += difference;\\n\\n        // Return the maximum sum between the left and right child nodes, plus the current cost\\n        return max(leftSum, rightSum) + cost[index - 1];\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        // Start the depth-first search from the root node (index 1)\\n        int sum = dfs(1, cost);\\n\\n        // Return the accumulated minimum increments\\n        return minimumIncrements;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530180,
                "title": "java-c-python-fast-and-short-solution-explained",
                "content": "# TL;DR\\n\\n\\n```java []\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int increments = 0;\\n        for (int i = (n - 3) / 2; i >= 0; i--) {\\n            cost[i] += Math.max(cost[i * 2 + 1], cost[i * 2 + 2]);\\n            increments += Math.abs(cost[i * 2 + 1] - cost[i * 2 + 2]);\\n        }\\n        return increments;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int increments = 0;\\n        for (int i = (n - 3) / 2; i >= 0; i--) {\\n            cost[i] += max(cost[i * 2 + 1], cost[i * 2 + 2]);\\n            increments += abs(cost[i * 2 + 1] - cost[i * 2 + 2]);\\n        }\\n        return increments;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        increments = 0\\n        for i in range((n - 3) // 2, -1, -1):\\n            cost[i] += max(cost[i * 2 + 1], cost[i * 2 + 2])\\n            increments += abs(cost[i * 2 + 1] - cost[i * 2 + 2])\\n        return increments\\n```\\n---\\n#### \\u26A0\\uFE0F Don\\'t forget to upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n\\n# Approach\\n\\n1. **Iterate over the array in reverse order**: We start from the last parent node which is at index `(n - 3) / 2` and move towards the root. The `-3` is to avoid the leaf nodes as they do not have children.\\n\\n2. **Increase the cost of the parent node**: For each node, we increment its cost by the maximum cost of its children. This ensures that the path through this node to a leaf node has the same cost as the path through its sibling to a leaf node. \\n\\n3. **Calculate the increments**: We calculate the difference in costs of the two children of the node and add it to a counter. This represents the minimum number of increments we have made to make the costs of the paths from the root to each leaf node equal.\\n\\n4. **Return the increments**: After iterating over all nodes, we return the counter.\\n\\n# Complexity Analysis\\n\\n- **Time Complexity**: The time complexity is $$O(n)$$, where $$n$$ is the number of nodes. This is because we\\'re iterating over the list of nodes once.\\n\\n- **Space Complexity**: The space complexity is $$O(1)$$, as we only use a few variables to store the intermediate and final results.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int increments = 0;\\n        for (int i = (n - 3) / 2; i >= 0; i--) {\\n            cost[i] += Math.max(cost[i * 2 + 1], cost[i * 2 + 2]);\\n            increments += Math.abs(cost[i * 2 + 1] - cost[i * 2 + 2]);\\n        }\\n        return increments;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int increments = 0;\\n        for (int i = (n - 3) / 2; i >= 0; i--) {\\n            cost[i] += max(cost[i * 2 + 1], cost[i * 2 + 2]);\\n            increments += abs(cost[i * 2 + 1] - cost[i * 2 + 2]);\\n        }\\n        return increments;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        increments = 0\\n        for i in range((n - 3) // 2, -1, -1):\\n            cost[i] += max(cost[i * 2 + 1], cost[i * 2 + 2])\\n            increments += abs(cost[i * 2 + 1] - cost[i * 2 + 2])\\n        return increments\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530034,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReplace node values with max in its leaf values and than add the absolute of difference in its sum values in the result integer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n        public int minIncrements(int n, int[] A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += Math.abs(A[l] - A[r]);\\n            A[i] += Math.max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int minIncrements(int n, int[] A) {\\n        int res = 0;\\n        for (int i = n / 2 - 1; i >= 0; --i) {\\n            int l = i * 2 + 1, r = i * 2 + 2;\\n            res += Math.abs(A[l] - A[r]);\\n            A[i] += Math.max(A[l], A[r]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526828,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    int n;\\n    int [] cost;\\n    int increaments;\\n    public int minIncrements(int n, int[] cost) {\\n        this.n=n;\\n        this.cost=cost;\\n        increaments =0;\\n        if (n==3) return  Math.abs(cost[1]-cost[2]);\\n        equalize(1);\\n        return increaments;\\n    }\\n\\n    public int equalize(int head){\\n        if (head*4>n){\\n            increaments += Math.abs(cost[head*2-1]-cost[head*2+1-1]);\\n            return Math.max(cost[head*2-1],cost[head*2+1-1]);\\n        }\\n        int leftPath = equalize(head*2) + cost[head*2-1];\\n        int rightPath = equalize(head*2+1)+ cost[head*2+1-1];\\n        increaments += Math.abs(leftPath-rightPath);\\n        return Math.max(leftPath,rightPath);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int n;\\n    int [] cost;\\n    int increaments;\\n    public int minIncrements(int n, int[] cost) {\\n        this.n=n;\\n        this.cost=cost;\\n        increaments =0;\\n        if (n==3) return  Math.abs(cost[1]-cost[2]);\\n        equalize(1);\\n        return increaments;\\n    }\\n\\n    public int equalize(int head){\\n        if (head*4>n){\\n            increaments += Math.abs(cost[head*2-1]-cost[head*2+1-1]);\\n            return Math.max(cost[head*2-1],cost[head*2+1-1]);\\n        }\\n        int leftPath = equalize(head*2) + cost[head*2-1];\\n        int rightPath = equalize(head*2+1)+ cost[head*2+1-1];\\n        increaments += Math.abs(leftPath-rightPath);\\n        return Math.max(leftPath,rightPath);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524043,
                "title": "c-solution-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int helper(int n,vector<int> &cost,int i)\\n    {\\n        if(i>=n)\\n        {\\n            return 0;\\n        }\\n        int left=helper(n,cost,2*i+1);\\n        int right=helper(n,cost,2*i+2);\\n        ans+=abs(right-left);\\n        return max(right,left)+cost[i];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n         helper(n,cost,0);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int helper(int n,vector<int> &cost,int i)\\n    {\\n        if(i>=n)\\n        {\\n            return 0;\\n        }\\n        int left=helper(n,cost,2*i+1);\\n        int right=helper(n,cost,2*i+2);\\n        ans+=abs(right-left);\\n        return max(right,left)+cost[i];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n         helper(n,cost,0);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517911,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def minIncrements(n: Int, cost: Array[Int]): Int = \\n        (n / 2 - 1 to 0 by -1).foldLeft(0)((acc, i) =>{\\n            val l = i * 2 + 1\\n            var r = i * 2 + 2\\n            cost(i) += cost(l) max cost(r)\\n            acc + Math.abs(cost(l) - cost(r))\\n        })\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minIncrements(n: Int, cost: Array[Int]): Int = \\n        (n / 2 - 1 to 0 by -1).foldLeft(0)((acc, i) =>{\\n            val l = i * 2 + 1\\n            var r = i * 2 + 2\\n            cost(i) += cost(l) max cost(r)\\n            acc + Math.abs(cost(l) - cost(r))\\n        })\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3516322,
                "title": "greedy-solution-c",
                "content": "# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& costs) {\\n        int ans=0;\\n        for(int i=costs.size()-1; i>=1; i-=2){\\n            int d= max(costs[i],costs[i-1]);\\n            ans+=abs(costs[i]-costs[i-1]);\\n            costs[(i-1)/2]+=d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& costs) {\\n        int ans=0;\\n        for(int i=costs.size()-1; i>=1; i-=2){\\n            int d= max(costs[i],costs[i-1]);\\n            ans+=abs(costs[i]-costs[i-1]);\\n            costs[(i-1)/2]+=d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514495,
                "title": "c-intuitive-breadth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `int lastLvlCnt = (n + 1) / 2;` Used to count nodes from each level\\n- `int[] minCosts = new int[n];` Tree with min increased cost\\n- `public int GetMaxCost(int[] costs, int i) {...}` Find the max cost from tree paths\\n- `public void SetCostsWithLeafSum(int[] costs, int[] minCosts, int i, int pathSum, int maxCost) {...}` Set the `minCosts` arr and leaf = leaf + how much required cost in this path to be equal to max path cost\\n- `while (lastLvlCnt != 1) {... for (int curIdx = idx; curIdx < curN - 1; curIdx += 2) {...}...}` Iterate level by level in the tree from the leaf(bottom-up). And to minimize added cost for each path: left, right, we can remove common added cost from both of them, and add to parent node.\\n- `for (int i = 0; i < costs.Length; i++) {\\n            res += minCosts[i] - costs[i];\\n        }` Finally compare initial nodes with `minCosts` and add difference to `result`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$, n = nodes size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n) +  O(h)$$, n = nodes size, h - nodes height\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinIncrements(int n, int[] costs) {\\n        int lastLvlCnt = (n + 1) / 2;\\n        int[] minCosts = new int[n];\\n        int res = 0;\\n\\n        int maxCost = GetMaxCost(costs, 0);\\n        SetCostsWithLeafSum(costs, minCosts, 0, 0, maxCost);\\n      \\n        int idx = n - lastLvlCnt;\\n        while (lastLvlCnt != 1) {\\n            int curN = idx + lastLvlCnt;\\n\\n            for (int curIdx = idx; curIdx < curN - 1; curIdx += 2) {\\n                int addedLeft = minCosts[curIdx] - costs[curIdx];\\n                int addedRight = minCosts[curIdx + 1] - costs[curIdx + 1];\\n                int minAdded = Math.Min(addedLeft, addedRight);\\n\\n                minCosts[curIdx / 2] += minAdded;\\n                minCosts[curIdx] -= minAdded;\\n                minCosts[curIdx + 1] -= minAdded;\\n            }\\n\\n            lastLvlCnt /= 2;\\n            idx -= lastLvlCnt;\\n        }\\n\\n        for (int i = 0; i < costs.Length; i++) {\\n            res += minCosts[i] - costs[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetMaxCost(int[] costs, int i) {\\n        if (i >= costs.Length) return 0;\\n\\n        int leftCost = GetMaxCost(costs, (i + 1) * 2 - 1);\\n        int rightCost = GetMaxCost(costs, (i + 1) * 2 + 1 - 1);\\n\\n        return costs[i] + Math.Max(leftCost, rightCost);\\n    }\\n\\n    public void SetCostsWithLeafSum(int[] costs, int[] minCosts, int i, int pathSum, int maxCost) {\\n        minCosts[i] = costs[i];\\n\\n        if ((i + 1) * 2 >= costs.Length) {\\n            minCosts[i] += maxCost - (pathSum + costs[i]);\\n            return;\\n        }\\n\\n        SetCostsWithLeafSum(costs, minCosts, (i + 1) * 2 - 1, pathSum + costs[i], maxCost);\\n        SetCostsWithLeafSum(costs, minCosts, (i + 1) * 2 + 1 - 1, pathSum + costs[i], maxCost);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinIncrements(int n, int[] costs) {\\n        int lastLvlCnt = (n + 1) / 2;\\n        int[] minCosts = new int[n];\\n        int res = 0;\\n\\n        int maxCost = GetMaxCost(costs, 0);\\n        SetCostsWithLeafSum(costs, minCosts, 0, 0, maxCost);\\n      \\n        int idx = n - lastLvlCnt;\\n        while (lastLvlCnt != 1) {\\n            int curN = idx + lastLvlCnt;\\n\\n            for (int curIdx = idx; curIdx < curN - 1; curIdx += 2) {\\n                int addedLeft = minCosts[curIdx] - costs[curIdx];\\n                int addedRight = minCosts[curIdx + 1] - costs[curIdx + 1];\\n                int minAdded = Math.Min(addedLeft, addedRight);\\n\\n                minCosts[curIdx / 2] += minAdded;\\n                minCosts[curIdx] -= minAdded;\\n                minCosts[curIdx + 1] -= minAdded;\\n            }\\n\\n            lastLvlCnt /= 2;\\n            idx -= lastLvlCnt;\\n        }\\n\\n        for (int i = 0; i < costs.Length; i++) {\\n            res += minCosts[i] - costs[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetMaxCost(int[] costs, int i) {\\n        if (i >= costs.Length) return 0;\\n\\n        int leftCost = GetMaxCost(costs, (i + 1) * 2 - 1);\\n        int rightCost = GetMaxCost(costs, (i + 1) * 2 + 1 - 1);\\n\\n        return costs[i] + Math.Max(leftCost, rightCost);\\n    }\\n\\n    public void SetCostsWithLeafSum(int[] costs, int[] minCosts, int i, int pathSum, int maxCost) {\\n        minCosts[i] = costs[i];\\n\\n        if ((i + 1) * 2 >= costs.Length) {\\n            minCosts[i] += maxCost - (pathSum + costs[i]);\\n            return;\\n        }\\n\\n        SetCostsWithLeafSum(costs, minCosts, (i + 1) * 2 - 1, pathSum + costs[i], maxCost);\\n        SetCostsWithLeafSum(costs, minCosts, (i + 1) * 2 + 1 - 1, pathSum + costs[i], maxCost);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513696,
                "title": "c-recursion-based-solution-simple-and-easy-to-understand",
                "content": "# Intuition\\n Use simple recursion, main logic is that for two leaves with same parent length of path uptil those two leaves will be same therefore values of two leaves should be equal. To make them equal just make them equal to max of both. Now recursively do this for each level \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int final_cost = 0;\\n    int recurs(int n, vector<int>& cost,int i)\\n    {\\n        if(2*i>n)\\n            return cost[i-1];\\n        \\n        int left = recurs(n,cost,2*i);\\n        int right = recurs(n,cost,2*i+1);\\n\\n        // cout<<i<<\" \"<<left<<\" \"<<right<<endl;\\n\\n        int m = max(left,right);\\n        final_cost += m-left+m-right;\\n        return m+cost[i-1];       \\n    }\\n  \\n    int minIncrements(int n, vector<int>& cost) {\\n        final_cost = 0;\\n        recurs(n,cost,1);\\n        return final_cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int final_cost = 0;\\n    int recurs(int n, vector<int>& cost,int i)\\n    {\\n        if(2*i>n)\\n            return cost[i-1];\\n        \\n        int left = recurs(n,cost,2*i);\\n        int right = recurs(n,cost,2*i+1);\\n\\n        // cout<<i<<\" \"<<left<<\" \"<<right<<endl;\\n\\n        int m = max(left,right);\\n        final_cost += m-left+m-right;\\n        return m+cost[i-1];       \\n    }\\n  \\n    int minIncrements(int n, vector<int>& cost) {\\n        final_cost = 0;\\n        recurs(n,cost,1);\\n        return final_cost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3513367,
                "title": "easy-dfs-solution-with-tc-sc",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(h)$$ , height of tree = logn\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int solve(int node,vector<int> &cost,int n,int &ans){\\n        int child1 = 2*node + 1;\\n        int child2 = 2*node + 2;\\n        \\n        if(child1 >= n && child2 >= n){\\n            //Leaf\\n            return cost[node];\\n        }\\n        \\n        int left_cost_needed = 0, right_cost_needed = 0;\\n        \\n        left_cost_needed = solve(child1,cost,n,ans);\\n        \\n        right_cost_needed = solve(child2,cost,n,ans);\\n        \\n        ans = ans + abs(left_cost_needed-right_cost_needed);\\n\\n        //Updated Cost For Tree from node till ALL leafs\\n        return cost[node] + max(left_cost_needed,right_cost_needed);\\n             \\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n       //Perfect Tree => Two Childs OR Zero\\n        int ans = 0;\\n      \\n        solve(0,cost,n,ans);\\n    \\n        return ans;\\n          \\n    }\\n  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int solve(int node,vector<int> &cost,int n,int &ans){\\n        int child1 = 2*node + 1;\\n        int child2 = 2*node + 2;\\n        \\n        if(child1 >= n && child2 >= n){\\n            //Leaf\\n            return cost[node];\\n        }\\n        \\n        int left_cost_needed = 0, right_cost_needed = 0;\\n        \\n        left_cost_needed = solve(child1,cost,n,ans);\\n        \\n        right_cost_needed = solve(child2,cost,n,ans);\\n        \\n        ans = ans + abs(left_cost_needed-right_cost_needed);\\n\\n        //Updated Cost For Tree from node till ALL leafs\\n        return cost[node] + max(left_cost_needed,right_cost_needed);\\n             \\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n       //Perfect Tree => Two Childs OR Zero\\n        int ans = 0;\\n      \\n        solve(0,cost,n,ans);\\n    \\n        return ans;\\n          \\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512718,
                "title": "simple-dfs-recursion-python-3",
                "content": "# Intuition\\nI had a hard time solving this question but what u can really do is run a simple recursion/dfs.\\nThe main logic of the question is we have to find the min no of increment we need to make.\\n\\nSo for every sibling nodes we always have to make them equal thus add their diff to total will give us min no inc to make.\\n**why left = 2 * node => because we are given the left will have 2 * node and right will have 2 * node + 1**\\n\\nif any time our node >= n+1 we moved out of boundary thus return 0\\n\\n`why max(left, right) => suppose left has cost of 2 and right has cost of 3. We already added 1 in total making left = right so what cost we need to send to parent to make it max cost? The max value of its child i.e max(left, right)\\n`\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # if they have same parent -> make parent increment\\n        # else -> indivdual increment\\n        total = 0\\n        def dfs(node):\\n            nonlocal total\\n            if node >= n + 1:\\n                return 0\\n            \\n            left = dfs(2*node)\\n            right = dfs(2*node + 1)\\n            total += abs(left - right)\\n            return max(left, right) + cost[node-1]\\n        dfs(1)\\n        return total\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # if they have same parent -> make parent increment\\n        # else -> indivdual increment\\n        total = 0\\n        def dfs(node):\\n            nonlocal total\\n            if node >= n + 1:\\n                return 0\\n            \\n            left = dfs(2*node)\\n            right = dfs(2*node + 1)\\n            total += abs(left - right)\\n            return max(left, right) + cost[node-1]\\n        dfs(1)\\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511367,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int len = cost.size();\\n        for (int i = 0; i < len; i++) {\\n            if (2 * i + 1 < len) {\\n                cost[2 * i + 1] += cost[i];\\n            }\\n            if (2 * i + 2 < len) {\\n                cost[2 * i + 2] += cost[i];\\n            }\\n        }\\n        int mxValue = *max_element(cost.begin(), cost.end());\\n        vector<int> mx(len);\\n        for (int i = len - 1; i > len / 2 - 1; i--) {\\n            mx[i] = cost[i];\\n        }\\n        for (int i = len / 2 - 1; i >= 0; i--) {\\n           mx[i] = max(mx[2 * i + 1], mx[2 * i + 2]);\\n        }\\n        vector<int> down(len);\\n        int sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            int curValue = mx[i] + down[i];\\n            if (curValue < mxValue) {\\n                int diff = mxValue - curValue;\\n                sol += diff;\\n                down[i] += diff;\\n            }\\n            if (2  * i + 1 < len) {\\n                down[2 * i + 1] = down[i];\\n            }\\n            if (2 * i + 2 < len) {\\n                down[2 * i + 2] = down[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int len = cost.size();\\n        for (int i = 0; i < len; i++) {\\n            if (2 * i + 1 < len) {\\n                cost[2 * i + 1] += cost[i];\\n            }\\n            if (2 * i + 2 < len) {\\n                cost[2 * i + 2] += cost[i];\\n            }\\n        }\\n        int mxValue = *max_element(cost.begin(), cost.end());\\n        vector<int> mx(len);\\n        for (int i = len - 1; i > len / 2 - 1; i--) {\\n            mx[i] = cost[i];\\n        }\\n        for (int i = len / 2 - 1; i >= 0; i--) {\\n           mx[i] = max(mx[2 * i + 1], mx[2 * i + 2]);\\n        }\\n        vector<int> down(len);\\n        int sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            int curValue = mx[i] + down[i];\\n            if (curValue < mxValue) {\\n                int diff = mxValue - curValue;\\n                sol += diff;\\n                down[i] += diff;\\n            }\\n            if (2  * i + 1 < len) {\\n                down[2 * i + 1] = down[i];\\n            }\\n            if (2 * i + 2 < len) {\\n                down[2 * i + 2] = down[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511031,
                "title": "lazy-propagation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a complete binary tree, which means every node will have two children, and you can just iterate them from buttom to first. And the data is relatively small, we can propagate the largest value to it\\'s parent node by dividing current index by 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLinear iteration. I have no idea why I did not come up with this in contest. This problem wastes me an hour.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ we will only iterate the array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ no extra space required\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # strategy a, balance each layer\\n        totalcost=0\\n        for i in range(n-1,0,-2):\\n            print(\\'cost of balancing node {} is {}\\'.format(i, max(cost[i],cost[i-1])-min(cost[i],cost[i-1])))\\n            totalcost+=max(cost[i],cost[i-1])-min(cost[i],cost[i-1])\\n            cost[i//2-1]+=max(cost[i],cost[i-1])\\n        return totalcost\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # strategy a, balance each layer\\n        totalcost=0\\n        for i in range(n-1,0,-2):\\n            print(\\'cost of balancing node {} is {}\\'.format(i, max(cost[i],cost[i-1])-min(cost[i],cost[i-1])))\\n            totalcost+=max(cost[i],cost[i-1])-min(cost[i],cost[i-1])\\n            cost[i//2-1]+=max(cost[i],cost[i-1])\\n        return totalcost\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510867,
                "title": "simple-o-n-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n/2-1; i >= 0; i--){\\n            int left = 2*i + 1;\\n            int right = 2*i + 2;\\n            ans += abs(cost[left] - cost[right]);\\n            cost[i] += max(cost[left], cost[right]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n/2-1; i >= 0; i--){\\n            int left = 2*i + 1;\\n            int right = 2*i + 2;\\n            ans += abs(cost[left] - cost[right]);\\n            cost[i] += max(cost[left], cost[right]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509622,
                "title": "c-basic-dfs-postorder-one-pass-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we could only increment, we should not modify the largest path.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the post-order traversal approach, it becomes easy to find the sum path of the left and right subtrees. Based on this idea, we can try to equalize the cost of the left and right subtrees. To achieve this, we can calculate the absolute difference between the costs of the left and right subtrees using the expression ***abs(left - right)***. This value represents the minimum number of operations required to balance the two subtrees. Then return ***current cost + max(left, right)*** since we have balance the two sub-tree.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTraversed all the nodes once\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nStack of recursive\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int minIncrements(int n, vector<int>& cost) {\\n        DFS(1,cost);\\n        return res;\\n    }\\n\\n\\n    int DFS(int node, vector<int>& cost){\\n        //basecase\\n        int n = cost.size();\\n        if(node>n){\\n            return 0;\\n        }\\n        \\n        int currCost = cost[node-1];\\n\\n        int left = DFS(node*2, cost);\\n        int right = DFS(node*2+1, cost);\\n\\n        res+= abs(left-right);\\n\\n        return currCost + max(left, right);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int minIncrements(int n, vector<int>& cost) {\\n        DFS(1,cost);\\n        return res;\\n    }\\n\\n\\n    int DFS(int node, vector<int>& cost){\\n        //basecase\\n        int n = cost.size();\\n        if(node>n){\\n            return 0;\\n        }\\n        \\n        int currCost = cost[node-1];\\n\\n        int left = DFS(node*2, cost);\\n        int right = DFS(node*2+1, cost);\\n\\n        res+= abs(left-right);\\n\\n        return currCost + max(left, right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509051,
                "title": "c-dfs-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int minIncrement = 0;\\n        maxPath(1, n, cost, minIncrement);\\n        return minIncrement;\\n    }\\n\\n    int maxPath(int i, int n, const vector<int>& cost, int& minIncrement){\\n        if(i>n) return 0;\\n        int l = maxPath(i*2, n, cost, minIncrement), r = maxPath(i*2+1, n, cost, minIncrement);\\n        minIncrement += max(l, r) - min(l, r);\\n        return max(l, r) + cost[i-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int minIncrement = 0;\\n        maxPath(1, n, cost, minIncrement);\\n        return minIncrement;\\n    }\\n\\n    int maxPath(int i, int n, const vector<int>& cost, int& minIncrement){\\n        if(i>n) return 0;\\n        int l = maxPath(i*2, n, cost, minIncrement), r = maxPath(i*2+1, n, cost, minIncrement);\\n        minIncrement += max(l, r) - min(l, r);\\n        return max(l, r) + cost[i-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508709,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fn(vector<int> &cost,int i,int &ct)\\n    {\\n        if(i-1<cost.size())\\n        {\\n            int a = fn(cost,2*i,ct);\\n            int b = fn(cost,2*i+1,ct);\\n            ct+=max(a,b) - min(a,b);\\n            return max(a,b)+cost[i-1];\\n        }\\n        else return 0;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int i  =1;\\n        int ct = 0;\\n         fn(cost,i,ct);\\n         return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fn(vector<int> &cost,int i,int &ct)\\n    {\\n        if(i-1<cost.size())\\n        {\\n            int a = fn(cost,2*i,ct);\\n            int b = fn(cost,2*i+1,ct);\\n            ct+=max(a,b) - min(a,b);\\n            return max(a,b)+cost[i-1];\\n        }\\n        else return 0;\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int i  =1;\\n        int ct = 0;\\n         fn(cost,i,ct);\\n         return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508689,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        \\n        var cost = cost\\n        var len = 0\\n        var res = 0\\n\\n        func find(_ m: Int = 1, _ c: Int = 0) {\\n            let leaf = 2 * m > n\\n            let nc = c + cost[m - 1]\\n\\n            if leaf {\\n                len = max(len, nc)\\n            }\\n            else {\\n                find(m * 2, nc)\\n                find(m * 2 + 1, nc)\\n            }\\n        }\\n\\n        func adjust(_ m: Int = 1, _ c: Int = 0) -> [Int] {\\n            let leaf = 2 * m > n\\n            let nc = c + cost[m - 1]\\n\\n            if leaf {\\n                return [nc, nc]\\n            }\\n            else {\\n                let r1 = adjust(m * 2, nc)\\n                let r2 = adjust(m * 2 + 1, nc)\\n                let r = [min(r1[0], r2[0]), max(r1[1], r2[1])]\\n                res += r[1] - r[0]\\n                return [r[1], r[1]]\\n            }\\n        }\\n\\n        find()\\n        adjust()\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        \\n        var cost = cost\\n        var len = 0\\n        var res = 0\\n\\n        func find(_ m: Int = 1, _ c: Int = 0) {\\n            let leaf = 2 * m > n\\n            let nc = c + cost[m - 1]\\n\\n            if leaf {\\n                len = max(len, nc)\\n            }\\n            else {\\n                find(m * 2, nc)\\n                find(m * 2 + 1, nc)\\n            }\\n        }\\n\\n        func adjust(_ m: Int = 1, _ c: Int = 0) -> [Int] {\\n            let leaf = 2 * m > n\\n            let nc = c + cost[m - 1]\\n\\n            if leaf {\\n                return [nc, nc]\\n            }\\n            else {\\n                let r1 = adjust(m * 2, nc)\\n                let r2 = adjust(m * 2 + 1, nc)\\n                let r = [min(r1[0], r2[0]), max(r1[1], r2[1])]\\n                res += r[1] - r[0]\\n                return [r[1], r[1]]\\n            }\\n        }\\n\\n        find()\\n        adjust()\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507600,
                "title": "python-2-approaches-post-order-traversal-iterate-over-parents",
                "content": "From description (and not only): you can traverse backward parents from `(N // 2 - 1) .. 0`.\\nThis way you have access to `left` and `right` children\\'s values.\\nAll you have to do in the problem is to find numbers of increases to align `parent.left_child_sum + parent.val` and `parent.right_child_sum + parent.val`\\n\\nE.g.\\n```\\n  1\\n / \\\\\\n2   3\\n```\\n`parent = 1`\\nin order to get the same paths sum you need to align parent\\'s left and right sums.\\nIn this case the path `1 - 2` should become `1 - 3` and `1 - 3` wlll not be changes as there is no way to decrease numbers. Thus the only way is to align right to left child.\\nSo we end up with `max(left, right) - min(left, right)` which is the same as `abs(left - right)` - number of increases needed to align `left` and `right` children to the same path sum .\\n`parent.val + abs(min - max)` is the path sum from the parent to a leaf.\\nReturn the new `sum` to the next `parent` and repeat.\\n\\n**Post-order traversal**\\n```\\nclass Solution:\\n    def minIncrements(self, N: int, cost: List[int]) -> int:\\n        def dfs(pos):\\n            nonlocal count\\n            if pos >= N:\\n                return 0\\n            left_sum = dfs(2 * pos + 1)\\n            right_sum = dfs(2 * pos + 2)\\n            \\n            count += abs(left_sum - right_sum)\\n            return cost[pos] + max(left_sum, right_sum)\\n        \\n        count = 0        \\n        dfs(0)\\n        return count\\n```\\n\\nIterate backward over parents as we know the parents location:\\n`left_child = parent * 2 + 1`\\n`right_child = parent * 2 + 2`\\n`parent =  left/right_child // 2`\\n```\\nclass Solution:\\n    def minIncrements(self, N: int, cost: List[int]) -> int:\\n        count = 0\\n        for i in reversed(range(N // 2)):\\n            count += abs(cost[2 * i + 1] - cost[2 * i + 2])\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2])\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n  1\\n / \\\\\\n2   3\\n```\n```\\nclass Solution:\\n    def minIncrements(self, N: int, cost: List[int]) -> int:\\n        def dfs(pos):\\n            nonlocal count\\n            if pos >= N:\\n                return 0\\n            left_sum = dfs(2 * pos + 1)\\n            right_sum = dfs(2 * pos + 2)\\n            \\n            count += abs(left_sum - right_sum)\\n            return cost[pos] + max(left_sum, right_sum)\\n        \\n        count = 0        \\n        dfs(0)\\n        return count\\n```\n```\\nclass Solution:\\n    def minIncrements(self, N: int, cost: List[int]) -> int:\\n        count = 0\\n        for i in reversed(range(N // 2)):\\n            count += abs(cost[2 * i + 1] - cost[2 * i + 2])\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2])\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506797,
                "title": "python-bfs",
                "content": "# Intuition\\nWe need to determine the maximum path to the leaf. \\nOnce we find the maximum, we can calculate the sum of the maximum values of the child nodes from the leaf to the root. \\n\\nNext, starting from the root again, we compare the value with the maximum. Why? Because modifying from the root allows us to minimize the cost. \\nFor example, if both children should add two (2*2), performing the modification on the parent node only costs 2.\\n\\nIf the value is equal to the maximum, it means we cannot modify this node. One of its child paths has already reached the maximum. In this case, we need to explore its children to see if any nodes should be modified. \\n\\nIf the value is less than the maximum, we can add it to the value (maximum leaf value minus the current value). After making this addition, it is crucial to record the add-on value for the child. The child\\'s value should be updated by adding the addon value to its sum.\\n\\n\\n# Approach\\nTo avoid dealing with the index offset and cost, I introduce a dummy value to the cost array.\\n(This dummy value helps to shift the index correctly when calculating the right node: 0 * 2 won\\'t be the correct index, so we push a value to shift it.)\\n\\nUtilizing the properties of a perfect binary tree,\\n2 * i represents the left node\\n2 * i + 1 represents the right node\\n\\nStep 1:\\nWe start by summing the values from the root, eventually obtaining the maximum leaf sum.\\n\\nStep 2:\\nNext, we traverse from the leaf to the node, choosing the maximum sum between the left and right nodes, and updating their parent accordingly.\\n\\nStep 3:\\nAfter completing the above steps, we perform a breadth-first search (BFS) traversal starting from the root.\\nWe calculate the value to be added by subtracting the node value from the maximum leaf value (e.g., if the maximum path value is 9 and we encounter a node value of 8, we modify it to 9 by calculating the difference: 9 - 8 = 1).\\nFollowing this modification, we propagate the difference (1) to its child nodes. All child paths should have the difference added to their parent value.\\nFinally, we re-evaluate the value of the node.\\n\\n```\\n  origin\\n    1\\n  3    4      \\n 4 1  4 3\\n\\nstep1:  perform sum from root to leaf\\n    1\\n  4    5       \\n 8 5  9 8\\n\\nstep2: update max sum max(left val, right val) from leaf to root\\n    9\\n  8    9       \\n 8 5  9 8\\n\\nstep3: traverse from root to leaft, modify each value\\n                    9\\n       8 to 9                  9\\n  carry=9-8=1              carry=9-9=0\\n8+1(9)       5+1=6          9      8+0 = 8\\nadd carry  after add carry         still need 1\\n           still need 9-6=3\\n\\nso the anwser would be \\n8 to 9  = 1\\n6 to 9  = 3\\n8 to 9  = 1\\n1+3+1 = 5\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        cost = [0]+cost\\n        maxLeaf = 0\\n        for i in range(1, len(cost)//2):\\n            cost[i*2]+=cost[i]\\n            cost[i*2+1]+=cost[i]\\n            maxLeaf = max(maxLeaf, cost[i*2], cost[i*2+1])\\n        for i in range(len(cost)-1, 1, -1):\\n            cost[i//2] = max(cost[i//2], cost[i])\\n        ans = 0\\n        q = deque([[1,0]])\\n        while q:\\n            idx, carry = q.popleft()\\n            diff = maxLeaf-cost[idx]-carry\\n            if diff>0:\\n                ans+=diff\\n                carry+=diff\\n            if 2*idx+1<len(cost):\\n                q.append([2*idx, carry])\\n                q.append([2*idx+1, carry])\\n            \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n  origin\\n    1\\n  3    4      \\n 4 1  4 3\\n\\nstep1:  perform sum from root to leaf\\n    1\\n  4    5       \\n 8 5  9 8\\n\\nstep2: update max sum max(left val, right val) from leaf to root\\n    9\\n  8    9       \\n 8 5  9 8\\n\\nstep3: traverse from root to leaft, modify each value\\n                    9\\n       8 to 9                  9\\n  carry=9-8=1              carry=9-9=0\\n8+1(9)       5+1=6          9      8+0 = 8\\nadd carry  after add carry         still need 1\\n           still need 9-6=3\\n\\nso the anwser would be \\n8 to 9  = 1\\n6 to 9  = 3\\n8 to 9  = 1\\n1+3+1 = 5\\n```\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        cost = [0]+cost\\n        maxLeaf = 0\\n        for i in range(1, len(cost)//2):\\n            cost[i*2]+=cost[i]\\n            cost[i*2+1]+=cost[i]\\n            maxLeaf = max(maxLeaf, cost[i*2], cost[i*2+1])\\n        for i in range(len(cost)-1, 1, -1):\\n            cost[i//2] = max(cost[i//2], cost[i])\\n        ans = 0\\n        q = deque([[1,0]])\\n        while q:\\n            idx, carry = q.popleft()\\n            diff = maxLeaf-cost[idx]-carry\\n            if diff>0:\\n                ans+=diff\\n                carry+=diff\\n            if 2*idx+1<len(cost):\\n                q.append([2*idx, carry])\\n                q.append([2*idx+1, carry])\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506549,
                "title": "c-postorder-traversal",
                "content": "\\n```\\nclass Solution \\n{\\n    int ans = 0;\\npublic:\\n    int minIncrements(int n, vector<int>& cost) \\n    {\\n        dfs(n, 1, cost);\\n\\n        return ans;\\n    }\\n\\n    int dfs(int n, int i, const vector<int>& cost)\\n    {\\n        if (i > n)\\n        {\\n            return 0;\\n        }\\n\\n        int lsum = dfs(n, 2 * i, cost);\\n        int rsum = dfs(n, 2 * i + 1, cost);\\n\\n        ans += abs(lsum - rsum);\\n\\n        return max(lsum, rsum) + cost[i - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    int ans = 0;\\npublic:\\n    int minIncrements(int n, vector<int>& cost) \\n    {\\n        dfs(n, 1, cost);\\n\\n        return ans;\\n    }\\n\\n    int dfs(int n, int i, const vector<int>& cost)\\n    {\\n        if (i > n)\\n        {\\n            return 0;\\n        }\\n\\n        int lsum = dfs(n, 2 * i, cost);\\n        int rsum = dfs(n, 2 * i + 1, cost);\\n\\n        ans += abs(lsum - rsum);\\n\\n        return max(lsum, rsum) + cost[i - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505321,
                "title": "easy-simple-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- At each node I will calculate the difference between left and right\\n- add that difference in my answer and pass the max(left,right)+root\\n- as both left and right is equal form that node after perfoming the increment operation form that node to its child node.\\n- recurively this will be computed for all the nodes from bottom to top\\n- and ultimately I will return the answer.\\n- Look at Code.\\n# Complexity\\n- Time complexity:\\n    - $$O(N)$$\\n\\n- Space complexity:\\n    - $$O(Log(N))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int minIncrements(int n, vector<int>& cost) \\n    {\\n        f(cost,1,n);\\n        return ans;\\n    }\\n    int f(vector<int>&cost,int i,int n)\\n    {\\n        if (i>n)\\n        {\\n            return 0;\\n        }\\n        int priceLeft=f(cost,2*i,n);\\n        int priceRight=f(cost,2*i+1,n);\\n        ans+=abs(priceLeft-priceRight);\\n        return max(priceLeft,priceRight)+cost[i-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int minIncrements(int n, vector<int>& cost) \\n    {\\n        f(cost,1,n);\\n        return ans;\\n    }\\n    int f(vector<int>&cost,int i,int n)\\n    {\\n        if (i>n)\\n        {\\n            return 0;\\n        }\\n        int priceLeft=f(cost,2*i,n);\\n        int priceRight=f(cost,2*i+1,n);\\n        ans+=abs(priceLeft-priceRight);\\n        return max(priceLeft,priceRight)+cost[i-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505299,
                "title": "java-dfs-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUpdate the subtree to larger one, return the maxPath value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(lgn)\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(0, cost);\\n        return res;\\n    }\\n    \\n    public int dfs(int current, int[] cost){\\n        if(current >= cost.length) return 0;\\n        int left = dfs(2 * current + 1, cost);\\n        int right = dfs(2 * current + 2, cost);\\n        res += Math.abs(left - right);\\n        return Math.max(left, right) + cost[current];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(0, cost);\\n        return res;\\n    }\\n    \\n    public int dfs(int current, int[] cost){\\n        if(current >= cost.length) return 0;\\n        int left = dfs(2 * current + 1, cost);\\n        int right = dfs(2 * current + 2, cost);\\n        res += Math.abs(left - right);\\n        return Math.max(left, right) + cost[current];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504740,
                "title": "easy-dfs-and-greedy-approach",
                "content": "# Intuition\\n<we try increment the element which are top on tree>\\n\\n# Approach\\n<find max path from that element to leaf element and add path length from 1 to that element, if it is smaller than max possible path length from 1 to leaf then increment that by that number so that it get equal to the max path length from 1 to leaf >\\n\\n# Complexity\\n- Time complexity:\\n<O(n)>\\n\\n- Space complexity:\\n<O(n)>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    vector<long long>dp;\\n    int ans;\\n    long long  dfs1(int i,vector<int>&cost)\\n    {\\n        if(i>m)return 0;\\n        dp[i-1]=max(dfs1(2*i,cost),dfs1(2*i+1,cost));\\n        return dp[i-1]+cost[i-1];\\n    }\\n    \\n    void dfs(int x,long long  prev,vector<int>&cost,int i)\\n    {\\n        if(i>m)return ;\\n        long long  total=cost[i-1]+dp[i-1]+prev;\\n        long long  incre=x-total;\\n        ans+=(int)incre;\\n        cost[i-1]+=(int)incre;\\n        dfs(x,prev+cost[i-1],cost,2*i);\\n         dfs(x,prev+cost[i-1],cost,2*i+1);\\n        return ;\\n    }\\n        \\n    int minIncrements(int n, vector<int>& cost) {\\n        m=n;\\n        dp.clear();\\n        dp=vector<long long>(n+1);\\n        vector<int>prevcost=cost;\\n        ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=(long long)cost[i];\\n        }\\n        int x=(int)dfs1(1,cost);\\n        \\n         dfs(x,0,cost,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    vector<long long>dp;\\n    int ans;\\n    long long  dfs1(int i,vector<int>&cost)\\n    {\\n        if(i>m)return 0;\\n        dp[i-1]=max(dfs1(2*i,cost),dfs1(2*i+1,cost));\\n        return dp[i-1]+cost[i-1];\\n    }\\n    \\n    void dfs(int x,long long  prev,vector<int>&cost,int i)\\n    {\\n        if(i>m)return ;\\n        long long  total=cost[i-1]+dp[i-1]+prev;\\n        long long  incre=x-total;\\n        ans+=(int)incre;\\n        cost[i-1]+=(int)incre;\\n        dfs(x,prev+cost[i-1],cost,2*i);\\n         dfs(x,prev+cost[i-1],cost,2*i+1);\\n        return ;\\n    }\\n        \\n    int minIncrements(int n, vector<int>& cost) {\\n        m=n;\\n        dp.clear();\\n        dp=vector<long long>(n+1);\\n        vector<int>prevcost=cost;\\n        ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=(long long)cost[i];\\n        }\\n        int x=(int)dfs1(1,cost);\\n        \\n         dfs(x,0,cost,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504494,
                "title": "shortest-logical-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        total = 0\\n        \\n        for i in range(n-1,0,-2):\\n            \\n            k = max(cost[i], cost[i-1])\\n            total += k - min(cost[i], cost[i-1])\\n            cost[(i-2) // 2] += k\\n        \\n        return total\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        total = 0\\n        \\n        for i in range(n-1,0,-2):\\n            \\n            k = max(cost[i], cost[i-1])\\n            total += k - min(cost[i], cost[i-1])\\n            cost[(i-2) // 2] += k\\n        \\n        return total\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504332,
                "title": "most-intutive-in-terms-of-arrays-indexing-in-terms-of-trees",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to make all the level of tree same cost ,so to maintain same cost I used recursion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nlog N (as it was a balanced Tree)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nLogN \\n\\n# Code\\n```\\nclass Solution {\\n  int ans=0;\\n\\n    public int minIncrements(int n, int[] cost) {\\n\\n        calculate(0,cost,n);\\n        return ans;\\n    }\\n\\n    int calculate(int i,int[] cost,int N)\\n    {\\n      if(i>N-1) \\n      {\\n        return 0;\\n      }\\n\\n      int left=calculate(2*i+1,cost,N); // left part index 2*i+1\\n      int right=calculate(2*i+2,cost,N);//right part index 2*i+2\\n\\n      ans=ans+Math.abs(left-right);\\n      return Math.max(left,right)+cost[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n  int ans=0;\\n\\n    public int minIncrements(int n, int[] cost) {\\n\\n        calculate(0,cost,n);\\n        return ans;\\n    }\\n\\n    int calculate(int i,int[] cost,int N)\\n    {\\n      if(i>N-1) \\n      {\\n        return 0;\\n      }\\n\\n      int left=calculate(2*i+1,cost,N); // left part index 2*i+1\\n      int right=calculate(2*i+2,cost,N);//right part index 2*i+2\\n\\n      ans=ans+Math.abs(left-right);\\n      return Math.max(left,right)+cost[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504226,
                "title": "python-100-time-complexity-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![binaryytreeedrawio-4.png](https://assets.leetcode.com/users/images/1f5888ef-05f7-42c2-bf18-1b401fd39059_1683623878.54071.png)\\n\\n0) **For every 2 nodes, bottom layer nodes value must be equal**.\\nIn example 1, that mean Node 4 = Node 5, Node 6 = Nodes 7. \\n(Need not to Node 4 = Node 5 = Node 6 = Node 7)\\n\\n1) Create the 0 array \"addition\" with the length of the bottom layer initially.\\n\\n2)  For every 2 nodes:\\n    a)  **Add the absolute difference to integer parameter \"output\"**.\\n    b)  **Append the maximum value to \"addition\"**.\\n\\n3)  After go through the bottom layer, Now:\\n    Node 4 = Node 5 = 3\\n    Node 6 = Node 7 = 3\\n\\n4)  In the second lowest layer, \\n    We compare Node 2 + (max(Node 4, Node 5)) & Node 3 + (max(Node 6, Node 7)), which have been marked at the \"addition\". \\n\\n5)  Repeat Step 2: Add the absolute difference and append the maximum.\\n\\n6)  Loop the process until reach the top of binary tree.\\n\\n7)  Need not to pop the value in the addition array. We can just **apply \"shift\" parameter to select the value we wanted**. The runtime will reduce from 2500ms to 1200ms.\\n\\n# Stdout (For Reference)\\n\\n(\\'addition_arr\\', [0, 0, 0, 0], \\'target_node_value\\', 1, 3, \\'output\\', 0, \\'checking_arr\\', [1, 3, 3, 2])\\n(\\'addition_arr\\', [0, 0, 0, 0, 3], \\'target_node_value\\', 3, 2, \\'output\\', 2, \\'checking_arr\\', [1, 3, 3, 2])\\n(\\'addition_arr\\', [0, 0, 0, 0, 3, 3], \\'target_node_value\\', 2, 5, \\'output\\', 3, \\'checking_arr\\', [2, 5])\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minIncrements(self, n, cost):\\n        base = n + 1\\n        output = 0\\n        addition = [0] * (base/2)\\n        shift = 0\\n\\n        while base > 2:\\n            arr = cost[base-2:base/2-2:-1]\\n            for i in range(base/4):\\n                a = arr[i*2+1] + addition[shift+1]\\n                b = arr[i*2] + addition[shift+0]\\n                output += abs(a - b)\\n                addition.append(max(a, b))\\n                shift += 2\\n            base /= 2\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minIncrements(self, n, cost):\\n        base = n + 1\\n        output = 0\\n        addition = [0] * (base/2)\\n        shift = 0\\n\\n        while base > 2:\\n            arr = cost[base-2:base/2-2:-1]\\n            for i in range(base/4):\\n                a = arr[i*2+1] + addition[shift+1]\\n                b = arr[i*2] + addition[shift+0]\\n                output += abs(a - b)\\n                addition.append(max(a, b))\\n                shift += 2\\n            base /= 2\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503399,
                "title": "java-dfs-and-dp-combination-way",
                "content": "First of all, there must be a maximum cost path exist in the tree, then each other path should get the final addition equal to the max cost path. We get that max and record max path of every tree root node.\\n\\nHow do we get max cost of every root node? We iterate from the back n to 1, if the root node is a leaf, that max cost is the cost[i] itself, if the root node has children, max cost of the root node is Math.max(leftchild, rightchild) + cost[i].\\n\\nSecondly, If we want to get the minimum addition, we should add the most from the root node.\\n```\\npublic int minIncrements(int n, int[] cost) {\\n\\tint[] dp = new int[n+1];\\n\\t//first we record max cost path of each tree root node\\n\\tfor(int i=n; i>=1; i--){\\n\\t\\tif(2*i+1 <= n){\\n\\t\\t\\tdp[i] = Math.max(dp[i*2], dp[i*2+1]) + cost[i-1];\\n\\t\\t}else{\\n\\t\\t\\tdp[i] = cost[i-1];\\n\\t\\t}\\n\\t}\\n\\tint[] res = new int[1];\\n\\tint max = dp[1];\\n\\tdsf(1, max, n, cost, dp, res);\\n\\t\\n\\treturn res[0];\\n}\\nvoid dsf(int root, int max, int n, int[] cost, int[] dp, int[] res){\\n\\tif(root > n) return;\\n\\t\\n\\tint diff = max - dp[root];\\n\\tint newmax = 0;\\n\\tif(diff == 0){\\n\\t\\tnewmax = max - cost[root-1];\\n\\t}else{\\n\\t\\tnewmax = max - (diff + cost[root-1]);\\n\\t\\tres[0] += diff;\\n\\t}\\n\\t\\n\\tint left = root * 2;\\n\\tdsf(left, newmax, n, cost, dp, res);\\n\\tint right = root * 2 + 1;\\n\\tdsf(right, newmax, n, cost, dp, res);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int minIncrements(int n, int[] cost) {\\n\\tint[] dp = new int[n+1];\\n\\t//first we record max cost path of each tree root node\\n\\tfor(int i=n; i>=1; i--){\\n\\t\\tif(2*i+1 <= n){\\n\\t\\t\\tdp[i] = Math.max(dp[i*2], dp[i*2+1]) + cost[i-1];\\n\\t\\t}else{\\n\\t\\t\\tdp[i] = cost[i-1];\\n\\t\\t}\\n\\t}\\n\\tint[] res = new int[1];\\n\\tint max = dp[1];\\n\\tdsf(1, max, n, cost, dp, res);\\n\\t\\n\\treturn res[0];\\n}\\nvoid dsf(int root, int max, int n, int[] cost, int[] dp, int[] res){\\n\\tif(root > n) return;\\n\\t\\n\\tint diff = max - dp[root];\\n\\tint newmax = 0;\\n\\tif(diff == 0){\\n\\t\\tnewmax = max - cost[root-1];\\n\\t}else{\\n\\t\\tnewmax = max - (diff + cost[root-1]);\\n\\t\\tres[0] += diff;\\n\\t}\\n\\t\\n\\tint left = root * 2;\\n\\tdsf(left, newmax, n, cost, dp, res);\\n\\tint right = root * 2 + 1;\\n\\tdsf(right, newmax, n, cost, dp, res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503255,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        Dfs(1,n,cost);\\n        return ans;\\n    }\\n    private int Dfs(int node,int n,int[] cost){\\n        if(node>n) return 0;\\n        int left=Dfs(node*2,n,cost);\\n        int right=Dfs(node*2+1,n,cost);\\n        ans+=Math.abs(left-right);\\n        return Math.max(left,right)+cost[node-1];\\n    }\\n}//upvote if helpful...\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int minIncrements(int n, int[] cost) {\\n        Dfs(1,n,cost);\\n        return ans;\\n    }\\n    private int Dfs(int node,int n,int[] cost){\\n        if(node>n) return 0;\\n        int left=Dfs(node*2,n,cost);\\n        int right=Dfs(node*2+1,n,cost);\\n        ans+=Math.abs(left-right);\\n        return Math.max(left,right)+cost[node-1];\\n    }\\n}//upvote if helpful...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503023,
                "title": "very-simple-solution-c-dfs-very-well-commented",
                "content": "![image](https://assets.leetcode.com/users/images/df55920d-5f03-423d-9292-2e023319f514_1683603201.4346242.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int incrementsNeeded;\\n    int dfs(int root, vector<int>&cost, int n){\\n        if(root > n) return 0;\\n        int left_sum = dfs(root*2,cost,n);\\n        int right_sum = dfs(root*2+1,cost,n);\\n        // now we can only increment , so the lesser of the above two sums, will be incremented to the greater of above two sums\\n        incrementsNeeded += abs(left_sum - right_sum);\\n        \\n        // Now in example 1 of this question, we would be incrementing node 3(val = 2) , \\n        // because both of its child nodes are having value 3,\\n        // here now, left_sum = 5 + max(2,3) = 8, right_sum = 2 + max(1,3) = 5 || incrementsNeeded are 3, as (abs(8-5) = 3), increment, 2 to         //5\\n        return cost[root-1] + max(left_sum,right_sum);\\n        \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        incrementsNeeded = 0;\\n        int w = dfs(1,cost,n);\\n        return incrementsNeeded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int incrementsNeeded;\\n    int dfs(int root, vector<int>&cost, int n){\\n        if(root > n) return 0;\\n        int left_sum = dfs(root*2,cost,n);\\n        int right_sum = dfs(root*2+1,cost,n);\\n        // now we can only increment , so the lesser of the above two sums, will be incremented to the greater of above two sums\\n        incrementsNeeded += abs(left_sum - right_sum);\\n        \\n        // Now in example 1 of this question, we would be incrementing node 3(val = 2) , \\n        // because both of its child nodes are having value 3,\\n        // here now, left_sum = 5 + max(2,3) = 8, right_sum = 2 + max(1,3) = 5 || incrementsNeeded are 3, as (abs(8-5) = 3), increment, 2 to         //5\\n        return cost[root-1] + max(left_sum,right_sum);\\n        \\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        incrementsNeeded = 0;\\n        int w = dfs(1,cost,n);\\n        return incrementsNeeded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502556,
                "title": "java-different-approach-dfs-binary-search",
                "content": "```\\nclass Solution {\\n    \\n    \\n    int max [] ;\\n    \\n    public int minIncrements(int n, int[] cost) {\\n    \\n        max = new int[n];\\n        \\n        dfs(0,n,cost);\\n        \\n        int low  = 1; int high = 1000000;\\n        \\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            \\n            \\n            int mid = ( low +  high )/2;\\n            \\n            int res = dfs2(0,mid,cost);\\n            \\n            if( res == -1) {\\n                \\n                low  = mid + 1;\\n            }\\n            else {\\n                \\n                \\n                ans = res;\\n                \\n                high = mid - 1;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int dfs( int node , int n , int cost[]){\\n        \\n        if( node >= n ) return 0;\\n        \\n        int left = dfs(2*node+1,n,cost);\\n        \\n        int right = dfs(2*node+2,n,cost);\\n        \\n        max[node] = Math.max(left,right) + cost[node];\\n        \\n        return Math.max(left,right) + cost[node];\\n        \\n    }\\n    \\n    \\n    int dfs2(int node , int value,int cost[]){\\n        \\n        if( node >= cost.length ) return 0;\\n        \\n         int temp = value - max[node];\\n        \\n          if( temp < 0 )  return -1;\\n        \\n          int left = dfs2(2*node+1,value - cost[node] - temp , cost);\\n            \\n            if( left == -1 ) return -1;\\n        \\n          int right  =dfs2(2*node+2,value-cost[node]-temp,cost);\\n          \\n        if(right == -1) return -1;\\n        \\n        return left + right + temp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    int max [] ;\\n    \\n    public int minIncrements(int n, int[] cost) {\\n    \\n        max = new int[n];\\n        \\n        dfs(0,n,cost);\\n        \\n        int low  = 1; int high = 1000000;\\n        \\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            \\n            \\n            int mid = ( low +  high )/2;\\n            \\n            int res = dfs2(0,mid,cost);\\n            \\n            if( res == -1) {\\n                \\n                low  = mid + 1;\\n            }\\n            else {\\n                \\n                \\n                ans = res;\\n                \\n                high = mid - 1;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int dfs( int node , int n , int cost[]){\\n        \\n        if( node >= n ) return 0;\\n        \\n        int left = dfs(2*node+1,n,cost);\\n        \\n        int right = dfs(2*node+2,n,cost);\\n        \\n        max[node] = Math.max(left,right) + cost[node];\\n        \\n        return Math.max(left,right) + cost[node];\\n        \\n    }\\n    \\n    \\n    int dfs2(int node , int value,int cost[]){\\n        \\n        if( node >= cost.length ) return 0;\\n        \\n         int temp = value - max[node];\\n        \\n          if( temp < 0 )  return -1;\\n        \\n          int left = dfs2(2*node+1,value - cost[node] - temp , cost);\\n            \\n            if( left == -1 ) return -1;\\n        \\n          int right  =dfs2(2*node+2,value-cost[node]-temp,cost);\\n          \\n        if(right == -1) return -1;\\n        \\n        return left + right + temp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502350,
                "title": "c-java-dfs-solution",
                "content": "## Explanation\\nConsider a perfect binary tree with 3 nodes.\\n\\n                           1\\n                          / \\\\\\n                         2   3\\n\\nHere, to make both the root to leaf paths equal, we add `1 (3 - 2)` to `2`. So we perform 1 operation and the path cost becomes `4 (1 + 3)`.\\n\\nIf this is a subtree of a perfect binary tree, then we would increment `result` by 1 and return the path cost `4` to the calling function. \\n\\n                              1\\n                            /   \\\\\\n                           5     2\\n                          / \\\\   / \\\\\\n                         2   3 3   1\\n\\nHere, the node `5` in the left subtree of root node `1` would get the path cost from left subtree and right subtree as `2` and `3` respectively. Hence after the result being incremented by `1`, `8` would be returned to the root node as its left subtree\\'s path costs.\\n\\nIn the same way as mentioned above, the root node would get the right subtree\\'s path cost as `5` with result being updated to `3`. Then, the difference `3 (8 - 5)` would be added to the node `2`, to make both path costs equal and `9` would be returned to the main calling function.\\n\\nThis approach can be implemented by both DFS and BFS.\\n \\n\\n## Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    \\n    int res = 0, n;\\n    \\n    int dfs(int ind, vector<int> &cost){\\n        if(ind > size(cost)) return 0;\\n        int left = dfs(2 * ind, cost), right = dfs(2 * ind + 1, cost);\\n        res += abs(left - right);\\n        return cost[ind - 1] + max(left, right);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.List;\\n\\nclass Solution {\\n    int res = 0, n;\\n\\n    int dfs(int ind, int[] cost) {\\n        if (ind > cost.size()) return 0;\\n        int left = dfs(2 * ind, cost), right = dfs(2 * ind + 1, cost);\\n        res += Math.abs(left - right);\\n        return cost[ind - 1] + Math.max(left, right);\\n    }\\n\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n}\\n\\n```\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    \\n    int res = 0, n;\\n    \\n    int dfs(int ind, vector<int> &cost){\\n        if(ind > size(cost)) return 0;\\n        int left = dfs(2 * ind, cost), right = dfs(2 * ind + 1, cost);\\n        res += abs(left - right);\\n        return cost[ind - 1] + max(left, right);\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n};\\n```\n```Java []\\nimport java.util.List;\\n\\nclass Solution {\\n    int res = 0, n;\\n\\n    int dfs(int ind, int[] cost) {\\n        if (ind > cost.size()) return 0;\\n        int left = dfs(2 * ind, cost), right = dfs(2 * ind + 1, cost);\\n        res += Math.abs(left - right);\\n        return cost[ind - 1] + Math.max(left, right);\\n    }\\n\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502341,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        (0..<(n+1)/2-1).reversed().reduce(into: (0,cost)) {let l=$1*2+1;let c=$0.1[l...l+1].sorted();$0.0+=c[1]-c[0];$0.1[$1]+=c[1]}.0}\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        (0 ..< (n+1)/2-1)\\n\\t\\t\\t.reversed() // need to reverse order to equalize children before parent.\\n\\t\\t\\t.reduce(into: (\\n\\t\\t\\t\\t\\tresult: 0,\\n\\t\\t\\t\\t\\tarr: cost\\n\\t\\t\\t)) { data, i in \\n\\t\\t\\t\\tlet c = i*2+1\\n\\t\\t\\t\\tlet children = data.arr[c...c+1].sorted()\\n\\t\\t\\t\\tdata.result += children[1] - children[0]\\n\\t\\t\\t\\tdata.arr[i] += children[1]\\n\\t\\t\\t}\\n\\t\\t\\t.result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        (0..<(n+1)/2-1).reversed().reduce(into: (0,cost)) {let l=$1*2+1;let c=$0.1[l...l+1].sorted();$0.0+=c[1]-c[0];$0.1[$1]+=c[1]}.0}\\n}\\n```\n```\\nclass Solution {\\n    func minIncrements(_ n: Int, _ cost: [Int]) -> Int {\\n        (0 ..< (n+1)/2-1)\\n\\t\\t\\t.reversed() // need to reverse order to equalize children before parent.\\n\\t\\t\\t.reduce(into: (\\n\\t\\t\\t\\t\\tresult: 0,\\n\\t\\t\\t\\t\\tarr: cost\\n\\t\\t\\t)) { data, i in \\n\\t\\t\\t\\tlet c = i*2+1\\n\\t\\t\\t\\tlet children = data.arr[c...c+1].sorted()\\n\\t\\t\\t\\tdata.result += children[1] - children[0]\\n\\t\\t\\t\\tdata.arr[i] += children[1]\\n\\t\\t\\t}\\n\\t\\t\\t.result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501775,
                "title": "c-iterative-bottom-up-and-recursive-dfs",
                "content": "# Code\\n```\\n// Iterative (Bottom Up)\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            ans += abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Recursive (DFS)\\nclass Solution {\\n    int dfs(int i, int &ans, vector<int>& cost) {\\n        if(i >= cost.size()) return 0;\\n        int l = dfs(2 * i + 1, ans, cost);\\n        int r = dfs(2 * i + 2, ans, cost);\\n        ans += abs(l - r);\\n        return cost[i] + max(l, r);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        dfs(0, ans, cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Iterative (Bottom Up)\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        for(int i = n / 2 - 1; i >= 0; i--) {\\n            ans += abs(cost[2 * i + 1] - cost[2 * i + 2]);\\n            cost[i] += max(cost[2 * i + 1], cost[2 * i + 2]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Recursive (DFS)\\nclass Solution {\\n    int dfs(int i, int &ans, vector<int>& cost) {\\n        if(i >= cost.size()) return 0;\\n        int l = dfs(2 * i + 1, ans, cost);\\n        int r = dfs(2 * i + 2, ans, cost);\\n        ans += abs(l - r);\\n        return cost[i] + max(l, r);\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        dfs(0, ans, cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500126,
                "title": "python3-walk-from-leaf-to-root",
                "content": "# Intuition\\nAny path sum from root to a leaf will involve all the nodes who are ancestors of that leaf. The max cost path will be the path with maximum sum to a leaf. Now, the difference of two path\\'sum will be because of node\\'s cost along those paths.\\nWe start from leaf and look towards  their parent, at this point from that parent\\'s perspective the child with minimum cost need to be incremented to have same cost path value to each child. Since we have incremented one of two child\\'s cost , the total cost for this parent will increase. so we will increment the parent\\'s cost.  Now this parent will look towards it\\'s parent and calculate the current path value with this new parent. Keep doing this untill we reach to the root. Keep running sum of all values incremented for a low cost child along the path. This value will be the final answer.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # Start form  leave\\n        child = n\\n        diff = 0\\n        while child != 1 :\\n            parent = (child -1)//2\\n            other_child = 2 * parent\\n            diff += abs(cost[child-1] - cost[other_child-1])\\n            cost[parent-1] += max(cost[child-1],cost[other_child-1])\\n            child = other_child - 1\\n     \\n        return diff\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        # Start form  leave\\n        child = n\\n        diff = 0\\n        while child != 1 :\\n            parent = (child -1)//2\\n            other_child = 2 * parent\\n            diff += abs(cost[child-1] - cost[other_child-1])\\n            cost[parent-1] += max(cost[child-1],cost[other_child-1])\\n            child = other_child - 1\\n     \\n        return diff\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499592,
                "title": "tc-o-n-c-sc-o-1-bottom-up",
                "content": "# Approach\\nTraverse the cost array in reverse direction (i.e. traverse the tree in a bottom up manner) from the last non-leaf node(that\\'s why : s/2 -1). Calculate the absolute difference of both the children of the current node and add it to the res, and also add the max(left child cost, right child cost) to the current node cost.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int res = 0;\\n        int s = cost.size();\\n        for(int i = s/2 - 1; i >= 0; i--){\\n            int l = 2 * i + 1;\\n            int r = 2 * i + 2;\\n            if(l>=0 && r>=0){ \\n                res += abs(cost[l] - cost[r]);\\n                cost[i] += max(cost[l], cost[r]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int res = 0;\\n        int s = cost.size();\\n        for(int i = s/2 - 1; i >= 0; i--){\\n            int l = 2 * i + 1;\\n            int r = 2 * i + 2;\\n            if(l>=0 && r>=0){ \\n                res += abs(cost[l] - cost[r]);\\n                cost[i] += max(cost[l], cost[r]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499399,
                "title": "python-easy-to-read-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\nApply DFS and try to make path cost equal from bottom to up.\\nWhen diff is applied save it in ans variable. return cost of the path.\\nIf left or right any path have imbalance, increase respective cost.\\n\\'\\'\\'\\nclass Solution:\\n    def dfs(self, root, cost, n):\\n        if root > n:\\n            return 0\\n        left = self.dfs(root*2, cost, n)\\n        right = self.dfs(1 + root*2, cost, n)\\n        if left < right:\\n            diff = right - left\\n            left_index = root*2-1\\n            cost[left_index] += diff\\n            self.ans += diff\\n        elif right < left:\\n            diff = left - right\\n            right_index = root*2 + 1 -1\\n            cost[right_index] += diff\\n            self.ans += diff\\n        return cost[root-1] + max(left, right)\\n\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        self.ans = 0\\n        self.dfs(1, cost, n)\\n        return self.ans\\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n\\'\\'\\'\\nApply DFS and try to make path cost equal from bottom to up.\\nWhen diff is applied save it in ans variable. return cost of the path.\\nIf left or right any path have imbalance, increase respective cost.\\n\\'\\'\\'\\nclass Solution:\\n    def dfs(self, root, cost, n):\\n        if root > n:\\n            return 0\\n        left = self.dfs(root*2, cost, n)\\n        right = self.dfs(1 + root*2, cost, n)\\n        if left < right:\\n            diff = right - left\\n            left_index = root*2-1\\n            cost[left_index] += diff\\n            self.ans += diff\\n        elif right < left:\\n            diff = left - right\\n            right_index = root*2 + 1 -1\\n            cost[right_index] += diff\\n            self.ans += diff\\n        return cost[root-1] + max(left, right)\\n\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        self.ans = 0\\n        self.dfs(1, cost, n)\\n        return self.ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499209,
                "title": "java-ez-2-understand",
                "content": "```\\nclass Solution {\\n    int ans;\\n    public int minIncrements(int n, int[] cost) {\\n        ans=0;\\n        int max=findMax(cost,0);//first find the path which has max path length\\n        helper(max,cost,0,0);\\n        return ans;\\n    }\\n    int helper(int max,int cost[],int root,int sum){\\n        int n=cost.length,diff=0,min=0;\\n        if(2*root+1>=n)\\n            return max-sum-cost[root];//leaf node case just return the diff btween path sum and max\\n        else{\\n            sum+=cost[root];\\n            int left=helper(max,cost,2*root+1,sum);\\n            int right=helper(max,cost,2*root+2,sum);\\n            min=Math.min(left,right);\\n            diff=Math.abs(left-right);//the diff can be adjusted in the same level\\n            //minimum of both can be sent to upper level to minimise the total cost.\\n        }\\n        ans+=diff;//adjust the difference on the same level\\n        return min;//send the min to the upper level\\n    }\\n    int findMax(int cost[],int root){\\n        //fxn to find the max path length\\n        int n=cost.length;\\n        if(root>=n)\\n            return 0;\\n        return cost[root]+Math.max(findMax(cost,2*root+1),findMax(cost,2*root+2));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int minIncrements(int n, int[] cost) {\\n        ans=0;\\n        int max=findMax(cost,0);//first find the path which has max path length\\n        helper(max,cost,0,0);\\n        return ans;\\n    }\\n    int helper(int max,int cost[],int root,int sum){\\n        int n=cost.length,diff=0,min=0;\\n        if(2*root+1>=n)\\n            return max-sum-cost[root];//leaf node case just return the diff btween path sum and max\\n        else{\\n            sum+=cost[root];\\n            int left=helper(max,cost,2*root+1,sum);\\n            int right=helper(max,cost,2*root+2,sum);\\n            min=Math.min(left,right);\\n            diff=Math.abs(left-right);//the diff can be adjusted in the same level\\n            //minimum of both can be sent to upper level to minimise the total cost.\\n        }\\n        ans+=diff;//adjust the difference on the same level\\n        return min;//send the min to the upper level\\n    }\\n    int findMax(int cost[],int root){\\n        //fxn to find the max path length\\n        int n=cost.length;\\n        if(root>=n)\\n            return 0;\\n        return cost[root]+Math.max(findMax(cost,2*root+1),findMax(cost,2*root+2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499045,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    map<int,vector<int>> mp;\\n    int ans=0;\\n    void dfs(int n, vector<int>& cost,int v)\\n    {\\n        for(auto it:mp[v])\\n        {\\n          dfs(n,cost,it);\\n        }  \\n        if(2*v<n)\\n        { \\n            int a=cost[2*v-1];\\n            int b=cost[2*v];\\n            // cout<<a<<\" \"<<b<<\" \"<<v<<\" \"<<abs(a-b)<<\"\\\\n\";   \\n            cost[v-1]+=max(a,b);\\n        \\n              ans+=abs(a-b);\\n        }\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(2*i<n)\\n            {\\n                mp[i].push_back(2*i);\\n                mp[i].push_back(2*i+1);\\n            }\\n        }\\n        dfs(n,cost,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    map<int,vector<int>> mp;\\n    int ans=0;\\n    void dfs(int n, vector<int>& cost,int v)\\n    {\\n        for(auto it:mp[v])\\n        {\\n          dfs(n,cost,it);\\n        }  \\n        if(2*v<n)\\n        { \\n            int a=cost[2*v-1];\\n            int b=cost[2*v];\\n            // cout<<a<<\" \"<<b<<\" \"<<v<<\" \"<<abs(a-b)<<\"\\\\n\";   \\n            cost[v-1]+=max(a,b);\\n        \\n              ans+=abs(a-b);\\n        }\\n    }\\n    \\n    int minIncrements(int n, vector<int>& cost) {\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(2*i<n)\\n            {\\n                mp[i].push_back(2*i);\\n                mp[i].push_back(2*i+1);\\n            }\\n        }\\n        dfs(n,cost,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3498946,
                "title": "java-dfs-small-code",
                "content": "class Solution {\\n    \\n    int ans = 0;\\n    \\n    int dfs(int s, int n, int[] cost) {\\n        if(s > n) {\\n            return 0;\\n        }\\n        \\n        int left = dfs(2*s, n, cost);\\n        int right = dfs(2*s+1, n, cost);\\n        \\n        ans += Math.abs(left - right);\\n        return cost[s-1] + Math.max(left, right); \\n    }\\n    \\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, n, cost);\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n    int ans = 0;\\n    \\n    int dfs(int s, int n, int[] cost) {\\n        if(s > n) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3498585,
                "title": "pyhton3-o-n-two-pass-dfs",
                "content": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        cost.insert(0, 0)\\n        maxsub = [0] * (n + 1)\\n        def maxpath(v):\\n            if v > n: return 0\\n            maxsub[v] = max(maxpath(2 * v), maxpath(2 * v + 1))\\n            return maxsub[v] + cost[v]\\n        mp, ans = maxpath(1), 0\\n        def minadd(v, p):\\n            if v > n: return\\n            nonlocal mp, ans\\n            ans += mp - p - cost[v] - maxsub[v]\\n            p = mp - maxsub[v]\\n            minadd(2 * v, p)\\n            minadd(2 * v + 1, p)\\n        minadd(1, 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        cost.insert(0, 0)\\n        maxsub = [0] * (n + 1)\\n        def maxpath(v):\\n            if v > n: return 0\\n            maxsub[v] = max(maxpath(2 * v), maxpath(2 * v + 1))\\n            return maxsub[v] + cost[v]\\n        mp, ans = maxpath(1), 0\\n        def minadd(v, p):\\n            if v > n: return\\n            nonlocal mp, ans\\n            ans += mp - p - cost[v] - maxsub[v]\\n            p = mp - maxsub[v]\\n            minadd(2 * v, p)\\n            minadd(2 * v + 1, p)\\n        minadd(1, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498299,
                "title": "scala-simple-recursion-dfs",
                "content": "# Approach\\nWe can write a recursive function that uses the left and right subtrees of a node to evaluate the answer for that node\\'s subtree. Since we use two values for each subtree, Scala\\'s pattern matching comes in handy.\\n\\n# Code\\n```\\nobject Solution {\\n  def minIncrements(n: Int, cost: Array[Int]): Int = {\\n    def dfs(i: Int): (Int, Int) = {\\n      if (2 * i <= n) {\\n        val ((lCost, lValue), (rCost, rValue)) = (dfs(2 * i), dfs(2 * i + 1))\\n        (lCost + rCost + (lValue - rValue).abs, cost(i - 1) + lValue.max(rValue))\\n      } else (0, cost(i - 1))\\n    }\\n    dfs(1)._1\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def minIncrements(n: Int, cost: Array[Int]): Int = {\\n    def dfs(i: Int): (Int, Int) = {\\n      if (2 * i <= n) {\\n        val ((lCost, lValue), (rCost, rValue)) = (dfs(2 * i), dfs(2 * i + 1))\\n        (lCost + rCost + (lValue - rValue).abs, cost(i - 1) + lValue.max(rValue))\\n      } else (0, cost(i - 1))\\n    }\\n    dfs(1)._1\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3498277,
                "title": "python-dfs-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        self.res = 0\\n        def dfs(v):\\n            if v > n:\\n                return 0\\n            left = dfs(2*v)\\n            right = dfs(2*v+1)\\n            self.res += abs(left - right)\\n            return max(left, right) + cost[v-1]\\n        dfs(1)\\n        return self.res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        self.res = 0\\n        def dfs(v):\\n            if v > n:\\n                return 0\\n            left = dfs(2*v)\\n            right = dfs(2*v+1)\\n            self.res += abs(left - right)\\n            return max(left, right) + cost[v-1]\\n        dfs(1)\\n        return self.res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498125,
                "title": "bottom-up-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet each parent decide whether left child or right child needs to be adjusted and by how much and then return that information to it\\'s own parent.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a tree using n and the cost array\\n2. Use dfs to get the cost at each node and the increments that node made to it\\'s child nodes.\\n3. Base case is leaf node which returns current path cost + it\\'s cost as the cost till that node and 0 as the increments.\\n4. At every no-leaf node, find the adjustment required in either left child or right child. Return the adjusted cost, increments made by it\\'s left child + increments made by it\\'s right child + increments made by itself.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass TreeNode:\\n    def __init__(self, idx, cost):\\n        self.id = idx\\n        self.cost = cost\\n        self.left = None\\n        self.right = None\\n\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        startroot = TreeNode(1, cost[0])\\n        \\n        def createTree(root, rootId):\\n            if 2 * rootId >= n+1 or (2 * rootId) + 1 >= n+1: \\n                return TreeNode(rootId, cost[rootId-1])\\n            \\n            leftChildId, rightChildId = 2 * rootId, (2 * rootId) + 1\\n            leftChild = TreeNode(leftChildId, cost[leftChildId-1])\\n            rightChild = TreeNode(rightChildId, cost[rightChildId-1])\\n            \\n            root.left = createTree(leftChild, leftChildId)\\n            root.right = createTree(rightChild, rightChildId)\\n            \\n            return root\\n        \\n        treeRoot = createTree(startroot, 1)\\n        \\n        def helper(root, currCost):\\n            if not root.left and not root.right:\\n                return currCost + root.cost, 0\\n            \\n            leftCost, leftIncrements = helper(root.left, currCost + root.cost)\\n            rightCost, rightIncrements = helper(root.right, currCost + root.cost)\\n            \\n            greaterCost = max(leftCost, rightCost)\\n            currIncrements = (2 * greaterCost) - (leftCost + rightCost)\\n            \\n            return greaterCost, leftIncrements + rightIncrements + currIncrements\\n        \\n        finalCost, ans = helper(treeRoot, 0)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TreeNode:\\n    def __init__(self, idx, cost):\\n        self.id = idx\\n        self.cost = cost\\n        self.left = None\\n        self.right = None\\n\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        startroot = TreeNode(1, cost[0])\\n        \\n        def createTree(root, rootId):\\n            if 2 * rootId >= n+1 or (2 * rootId) + 1 >= n+1: \\n                return TreeNode(rootId, cost[rootId-1])\\n            \\n            leftChildId, rightChildId = 2 * rootId, (2 * rootId) + 1\\n            leftChild = TreeNode(leftChildId, cost[leftChildId-1])\\n            rightChild = TreeNode(rightChildId, cost[rightChildId-1])\\n            \\n            root.left = createTree(leftChild, leftChildId)\\n            root.right = createTree(rightChild, rightChildId)\\n            \\n            return root\\n        \\n        treeRoot = createTree(startroot, 1)\\n        \\n        def helper(root, currCost):\\n            if not root.left and not root.right:\\n                return currCost + root.cost, 0\\n            \\n            leftCost, leftIncrements = helper(root.left, currCost + root.cost)\\n            rightCost, rightIncrements = helper(root.right, currCost + root.cost)\\n            \\n            greaterCost = max(leftCost, rightCost)\\n            currIncrements = (2 * greaterCost) - (leftCost + rightCost)\\n            \\n            return greaterCost, leftIncrements + rightIncrements + currIncrements\\n        \\n        finalCost, ans = helper(treeRoot, 0)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497939,
                "title": "kotlin-o-n",
                "content": "# Approach\\n\\n\\nSince we know it\\'s a perfect tree, we know that the last non-leaf node is at index `n / 2 - 1`.\\n\\n\\nTraverse the tree array from that index above down to index 0. For each index `i` in our loop, find it\\'s children leaf at indicies  `2 * i + 1` and `2 * i + 2`, take the difference between their values, add the (**absolute**) difference to our result (since the difference between them is amount of increments we made), and update the current value at `i` with the largest child value to sum the path sum.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun minIncrements(n: Int, cost: IntArray): Int {\\n        val last = n / 2 - 1\\n\\n\\n        var res = 0\\n        for (i in last downTo 0) {\\n            var abs = cost[2 * i + 1] - cost[2 * i + 2]\\n            if (abs < 0) abs *= -1\\n            cost[i] += maxOf(cost[2 * i + 1], cost[2 * i + 2])\\n            res += abs\\n        }\\n\\n\\n        return res\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minIncrements(n: Int, cost: IntArray): Int {\\n        val last = n / 2 - 1\\n\\n\\n        var res = 0\\n        for (i in last downTo 0) {\\n            var abs = cost[2 * i + 1] - cost[2 * i + 2]\\n            if (abs < 0) abs *= -1\\n            cost[i] += maxOf(cost[2 * i + 1], cost[2 * i + 2])\\n            res += abs\\n        }\\n\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497937,
                "title": "c-simple-and-short-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int start = n/2, end = n-1, ans = 0;\\n        while(start > 0) {\\n            for(int i=start;i<end;i+=2) {\\n                ans += 2*max(cost[i],cost[i+1]) - (cost[i]+cost[i+1]);\\n                cost[i/2] += max(cost[i],cost[i+1]);\\n            }\\n            end = start-1;\\n            start/=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int start = n/2, end = n-1, ans = 0;\\n        while(start > 0) {\\n            for(int i=start;i<end;i+=2) {\\n                ans += 2*max(cost[i],cost[i+1]) - (cost[i]+cost[i+1]);\\n                cost[i/2] += max(cost[i],cost[i+1]);\\n            }\\n            end = start-1;\\n            start/=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497932,
                "title": "one-pass-iterative-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        int len = cost.size();\\n        for(int i = len / 2;i >= 0;i--){\\n            if(2 * i + 2 >= len||2 * i + 1 >= len) continue;\\n            cost[i] += max(cost[2 * i + 2],cost[2 * i + 1]);\\n            ans += abs(cost[2 * i + 2] - cost[2 * i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans = 0;\\n        int len = cost.size();\\n        for(int i = len / 2;i >= 0;i--){\\n            if(2 * i + 2 >= len||2 * i + 1 >= len) continue;\\n            cost[i] += max(cost[2 * i + 2],cost[2 * i + 1]);\\n            ans += abs(cost[2 * i + 2] - cost[2 * i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497529,
                "title": "java-bottom-up-approach",
                "content": "#     class Solution {\\n    public int minIncrements(int n, int[] cost) {\\n         int ans=0;\\n         for(int i=n/2;i<n;i+=2)\\n         {\\n             if(cost[i]!=cost[i+1])\\n             {\\n                 int temp=Math.max(cost[i],cost[i+1]);\\n                 ans+=temp-cost[i];\\n                 ans+=temp-cost[i+1];\\n                 cost[i]=temp;\\n                 cost[i+1]=temp;\\n             }   \\n         }\\n         // System.out.println(ans);\\n         n=n/2;\\n         while(n/2>0)\\n         {\\n             for(int i=n/2;i<n;i+=2)\\n             {\\n                 int temp=Math.max(cost[i]+cost[2*i+1],cost[i+1]+cost[2*(i+1)+1]);\\n                 ans+=temp-(cost[i]+cost[2*i+1]);\\n                 ans+=temp-(cost[i+1]+cost[2*(i+1)+1]);\\n                 cost[i]=temp;\\n                 cost[i+1]=temp;\\n                 //System.out.println(cost[i]+\" \"+cost[i+1]);\\n             }\\n             n=n/2;\\n         }\\n         return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minIncrements(int n, int[] cost) {\\n         int ans=0;\\n         for(int i=n/2;i<n;i+=2)\\n         {\\n             if(cost[i]!=cost[i+1])\\n             {\\n                 int temp=Math.max(cost[i],cost[i+1]);\\n                 ans+=temp-cost[i];\\n                 ans+=temp-cost[i+1];\\n                 cost[i]=temp;\\n                 cost[i+1]=temp;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3497397,
                "title": "java-dfs",
                "content": "\\n# class Solution {\\n    public int dfs(int child,int[] cost,int n,int[] ans)\\n    {\\n        if(child*2+1 >=n || child*2+2>=n)//leaf nodes\\n        {\\n            return cost[child];\\n        }\\n        int l=dfs(child*2+1,cost,n,ans);\\n        int r=dfs(child*2+2,cost,n,ans);\\n        \\n        ans[0]+=Math.abs(l-r);\\n        cost[child]+=Math.max(l,r);\\n        return cost[child];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        int[] ans=new int[1];\\n        dfs(0,cost,n,ans);\\n        return ans[0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int dfs(int child,int[] cost,int n,int[] ans)\\n    {\\n        if(child*2+1 >=n || child*2+2>=n)//leaf nodes\\n        {\\n            return cost[child];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3497313,
                "title": "java-dfs-simple",
                "content": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] incre = new int[1];\\n        find(0, cost, incre, n);\\n        return incre[0];\\n    }\\n\\n    public int find(int i, int[] cost, int[] incre, int n) {\\n        if (i >= n) return 0;\\n        int leftCost = find((2 * i) + 1, cost, incre, n);\\n        int rightCost = find((2 * i) + 2, cost, incre, n);\\n        incre[0] += Math.abs(leftCost - rightCost);\\n        return cost[i] + Math.max(leftCost, rightCost);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int[] incre = new int[1];\\n        find(0, cost, incre, n);\\n        return incre[0];\\n    }\\n\\n    public int find(int i, int[] cost, int[] incre, int n) {\\n        if (i >= n) return 0;\\n        int leftCost = find((2 * i) + 1, cost, incre, n);\\n        int rightCost = find((2 * i) + 2, cost, incre, n);\\n        incre[0] += Math.abs(leftCost - rightCost);\\n        return cost[i] + Math.max(leftCost, rightCost);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497253,
                "title": "using-dfs-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int isPowerOfTwo(int n){\\n        if (n == 0)\\n            return -1;\\n        int x=ceil(log2(n));\\n        int y=floor(log2(n));\\n\\n        if(x==y) return x;\\n        else return -1;\\n    }\\n    int inOrder(int root,int h,vector<int>&cost,int &ans){\\n        if(h==0){\\n            return 0;\\n        }\\n\\n        int leftCost=inOrder(2*root,h-1,cost,ans);\\n        int rootCost=cost[root-1];\\n        int rightCost=inOrder(2*root+1,h-1,cost,ans);\\n\\n        if(leftCost!=rightCost){\\n            ans+=abs(leftCost-rightCost);\\n        }\\n\\n        return max(leftCost,rightCost)+rootCost;\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n\\n        int height= isPowerOfTwo(n+1);\\n\\n        int ans=0;\\n        inOrder(1,height,cost,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int isPowerOfTwo(int n){\\n        if (n == 0)\\n            return -1;\\n        int x=ceil(log2(n));\\n        int y=floor(log2(n));\\n\\n        if(x==y) return x;\\n        else return -1;\\n    }\\n    int inOrder(int root,int h,vector<int>&cost,int &ans){\\n        if(h==0){\\n            return 0;\\n        }\\n\\n        int leftCost=inOrder(2*root,h-1,cost,ans);\\n        int rootCost=cost[root-1];\\n        int rightCost=inOrder(2*root+1,h-1,cost,ans);\\n\\n        if(leftCost!=rightCost){\\n            ans+=abs(leftCost-rightCost);\\n        }\\n\\n        return max(leftCost,rightCost)+rootCost;\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n\\n        int height= isPowerOfTwo(n+1);\\n\\n        int ans=0;\\n        inOrder(1,height,cost,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497223,
                "title": "commented-explaination-why-post-order-and-finding-from-leaf-to-root",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:logn\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans= 0 ;\\nint dfs(int r , vector<int>& cost, int n ){\\n    if(r>n)return 0;\\n    int l = dfs(2*r, cost, n);\\n    int right = dfs(2*r+1, cost, n);\\n    ans +=abs(right-l);\\n    return cost[r-1]+max(l, right);//why we doing cost[r-1]-> cost is 0 based indexing so \\n}\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return ans;\\n    }\\n};\\n//simply make root to leaf PATH is equal in order to make this will just think like strtign from leaf as to get max odf left and right in order to incerse only the value which will result add to root this make the balanced value path to root \\n//why? not taking root to leaft why tking postorder coz we cant decrease \\n\\n\\n//tc is O(N) \\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans= 0 ;\\nint dfs(int r , vector<int>& cost, int n ){\\n    if(r>n)return 0;\\n    int l = dfs(2*r, cost, n);\\n    int right = dfs(2*r+1, cost, n);\\n    ans +=abs(right-l);\\n    return cost[r-1]+max(l, right);//why we doing cost[r-1]-> cost is 0 based indexing so \\n}\\n    int minIncrements(int n, vector<int>& cost) {\\n        dfs(1, cost, n);\\n        return ans;\\n    }\\n};\\n//simply make root to leaf PATH is equal in order to make this will just think like strtign from leaf as to get max odf left and right in order to incerse only the value which will result add to root this make the balanced value path to root \\n//why? not taking root to leaft why tking postorder coz we cant decrease \\n\\n\\n//tc is O(N) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496998,
                "title": "python-3-dfs-needs-optimization",
                "content": "```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        # get maximum path sum\\n        def dfs(i):\\n            if 2 * i > n:\\n                return cost[i-1]\\n            return cost[i-1] + max(dfs(2*i), dfs(2*i+1))\\n\\n        max_v = dfs(1)\\n        \\n        \\n        # calculate the path sum for each leaf node \\n        leaf_sum = {}\\n        def dfs2(i, v):\\n            if 2 * i > n:\\n                leaf_sum[i] = cost[i-1] + v\\n                return\\n            dfs2(2*i, v+cost[i-1])\\n            dfs2(2*i+1, v+cost[i-1])\\n        \\n        \\n        dfs2(1, 0)\\n        \\n        # up propagate the max leaf path sum to its parent, which means the minimum cost to travel to the leaf\\n        node_max = defaultdict(int)\\n        for i in range((n + 1) // 2, n+1):\\n            j = i\\n            while j > 0:\\n                node_max[j] = max(node_max[j], leaf_sum[i])\\n                j //= 2\\n        \\n        # for each node, calculate the increments needed to reach the leaf node and accumulate the increments\\n        self.ans = 0\\n        def dfs3(i, v):\\n            if i > n:\\n                return\\n            diff = max_v - (node_max[i] + v)\\n            self.ans += diff\\n            dfs3(2*i, v+diff)\\n            dfs3(2*i+1, v+diff)\\n            \\n        dfs3(1, 0)\\n        \\n        return self.ans",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n        \\n        # get maximum path sum\\n        def dfs(i):\\n            if 2 * i > n:\\n                return cost[i-1]\\n            return cost[i-1] + max(dfs(2*i), dfs(2*i+1))\\n\\n        max_v = dfs(1)\\n        \\n        \\n        # calculate the path sum for each leaf node \\n        leaf_sum = {}",
                "codeTag": "Java"
            },
            {
                "id": 3496964,
                "title": "java-easy-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to compare left and right leafs for node and increment the ans by thier difference.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse recursion for each leaf and on the way back compare left and right leafs sum with and increment ans by the difference.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O[N] -> we just traverse all nodes.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    2*O[N] -> we use extra space to save the sum and out stack consumes O[n] during recursion\\n\\n# Code\\n```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        ans = 0;\\n        int[] sum = new int[n];\\n        recursion(cost, sum, 1);\\n        return ans;\\n    }\\n\\n    int ans = 0;\\n\\n    int recursion(int[] cost,int[] sum, int index){\\n        if(index > cost.length) return 0;\\n        int l = recursion(cost, sum, 2*index);\\n        int r = recursion(cost, sum, 2*index+1);\\n        ans += Math.abs(l-r);\\n        \\n        sum[index-1] = Math.max(l, r)+cost[index-1];\\n        \\n        return sum[index-1];\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        ans = 0;\\n        int[] sum = new int[n];\\n        recursion(cost, sum, 1);\\n        return ans;\\n    }\\n\\n    int ans = 0;\\n\\n    int recursion(int[] cost,int[] sum, int index){\\n        if(index > cost.length) return 0;\\n        int l = recursion(cost, sum, 2*index);\\n        int r = recursion(cost, sum, 2*index+1);\\n        ans += Math.abs(l-r);\\n        \\n        sum[index-1] = Math.max(l, r)+cost[index-1];\\n        \\n        return sum[index-1];\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496876,
                "title": "c-children-to-parent",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int inc = 0;\\n        for(int r = n-1, l = r-1; r; r -= 2, l -= 2) {\\n            inc += abs(cost[l] - cost[r]);\\n            cost[(l-1)/2] += max(cost[l], cost[r]);\\n        }\\n        return inc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int inc = 0;\\n        for(int r = n-1, l = r-1; r; r -= 2, l -= 2) {\\n            inc += abs(cost[l] - cost[r]);\\n            cost[(l-1)/2] += max(cost[l], cost[r]);\\n        }\\n        return inc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496703,
                "title": "c-dfs-easy-solution",
                "content": "# Intuition\\nUpdate the costs from leaf nodes to root.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dfs(int x,vector<vector<int>>& adj,vector<int>& cost)\\n    {\\n        if(adj[x].size()==0)\\n        return cost[x-1];\\n        int l = dfs(adj[x][0],adj,cost);\\n        int r = dfs(adj[x][1],adj,cost);\\n        if(abs(l-r)>0)\\n        ans+=max(l,r)-min(l,r);\\n        return cost[x-1]+max(l,r);\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(2*i<=n && 2*i+1<=n)\\n            {\\n                adj[i].push_back(2*i);\\n                adj[i].push_back(2*(i)+1);\\n            }\\n        }\\n        ans = 0;\\n        dfs(1,adj,cost);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dfs(int x,vector<vector<int>>& adj,vector<int>& cost)\\n    {\\n        if(adj[x].size()==0)\\n        return cost[x-1];\\n        int l = dfs(adj[x][0],adj,cost);\\n        int r = dfs(adj[x][1],adj,cost);\\n        if(abs(l-r)>0)\\n        ans+=max(l,r)-min(l,r);\\n        return cost[x-1]+max(l,r);\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(2*i<=n && 2*i+1<=n)\\n            {\\n                adj[i].push_back(2*i);\\n                adj[i].push_back(2*(i)+1);\\n            }\\n        }\\n        ans = 0;\\n        dfs(1,adj,cost);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496587,
                "title": "sum-of-a-binary-tree-c",
                "content": "```\\nclass Solution {\\n    int sum(int i,vector<int>&cost,int &cnt,int n)\\n    {\\n        if(i>n)\\n            return 0;\\n        int left=sum(2*i,cost,cnt,n);\\n        int right=sum(2*i+1,cost,cnt,n);\\n        cnt+=abs(left-right);\\n        return max(left,right)+cost[i-1];\\n    }\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int cnt=0;\\n        sum(1,cost,cnt,n);\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n    int sum(int i,vector<int>&cost,int &cnt,int n)\\n    {\\n        if(i>n)\\n            return 0;\\n        int left=sum(2*i,cost,cnt,n);\\n        int right=sum(2*i+1,cost,cnt,n);\\n        cnt+=abs(left-right);\\n        return max(left,right)+cost[i-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3496465,
                "title": "dfs",
                "content": "# Code\\n```\\nuse std::cmp;\\nimpl Solution {\\n    pub fn min_increments(n: i32, cost: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        Self::dfs(0, &cost, &mut result);\\n\\n        result\\n    }\\n\\n    fn dfs(index: usize, cost: &Vec<i32>, result: &mut i32) -> i32 {\\n        if index >= cost.len() {\\n            return 0\\n        }\\n\\n        let node_left = Self::dfs((index + 1) * 2 - 1, cost, result);\\n        let node_right = Self::dfs((index + 1) * 2, cost, result);\\n\\n        *result += (node_left - node_right).abs();\\n\\n        return cost[index] + cmp::max(node_left, node_right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```\\nuse std::cmp;\\nimpl Solution {\\n    pub fn min_increments(n: i32, cost: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        Self::dfs(0, &cost, &mut result);\\n\\n        result\\n    }\\n\\n    fn dfs(index: usize, cost: &Vec<i32>, result: &mut i32) -> i32 {\\n        if index >= cost.len() {\\n            return 0\\n        }\\n\\n        let node_left = Self::dfs((index + 1) * 2 - 1, cost, result);\\n        let node_right = Self::dfs((index + 1) * 2, cost, result);\\n\\n        *result += (node_left - node_right).abs();\\n\\n        return cost[index] + cmp::max(node_left, node_right)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496440,
                "title": "most-optimized-solution-in-c-with-proper-explanation",
                "content": "# Intuition\\nThe intuition behind the given code is to use segment tree data structure to efficiently compute the minimum number of increments needed to make the cost of paths from the root to each leaf node equal.\\n\\n# Approach\\nThe approach uses two helper functions and one main function:\\n\\n- The ```\\'helper_st\\'``` function recursively constructs the segment tree for the given binary tree using the segment tree array ```\\'st\\'```. For each node of the binary tree, it computes the sum of its cost and the cost of its parent node and stores it at the corresponding index in the segment tree array. It then recursively calls itself for the left and right child nodes of the current node.\\n- The ```\\'helper_ans\\'``` function recursively traverses the segment tree and updates the cost of nodes in the segment tree if needed to make the cost of all leaf nodes equal. It returns the minimum number of increments required to update the segment tree to achieve the desired condition.\\n- The ```\\'minIncrements\\'``` function initializes the segment tree by calling the ```\\'helper_st\\'``` function and then calls the ```\\'helper_ans\\'``` function to get the minimum number of increments needed to make the cost of paths from the root to each leaf node equal.\\n\\nTo explain the approach in detail, we first construct a segment tree for the given binary tree using the ```\\'helper_st\\'``` function. We initialize the root of the segment tree (index 0) to have a value of 0. For each node in the binary tree, we compute the sum of its cost and the cost of its parent node and store it at the corresponding index in the segment tree. We do this recursively for each left and right child node of the current node until we reach the leaf nodes of the binary tree.\\n\\nNext, we compute the maximum value of the segment tree for all leaf nodes and all nodes below them using a range query. We do this by traversing the right half of the segment tree (indices n/2 to n-1), which corresponds to the leaf nodes of the original binary tree. We find the maximum value among all nodes in this range and store it in the variable ```\\'maxi\\'```.\\n\\nWe then call the ```\\'helper_ans\\'``` function with the right half of the segment tree as the input range. This function recursively traverses the segment tree and updates the cost of nodes if needed to make the cost of all leaf nodes equal. It starts by checking if the given input range is valid, i.e., if the left index is less than or equal to the right index. If not, it returns 0. Otherwise, it finds the maximum value among all nodes in the given input range and subtracts it from ```\\'maxi\\'``` to get the number of increments needed to update all nodes in this range to have the same cost as the leaf nodes. It then updates the cost of each node in the input range to be equal to ```\\'maxi\\'```. Finally, it recursively calls itself for the left and right half of the input range and adds the returned values to the current answer.\\n\\nThe main function ```\\'minIncrements\\'``` initializes the segment tree by calling the \\'helper_st\\' function and then calls the ```\\'helper_ans\\'``` function with the right half of the segment tree as the input range to get the minimum number of increments needed to make the cost of paths from the root to each leaf node equal.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(nlogn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper_st(int p, int v, int n, vector<int>& cost, vector<int>& st) {\\n        if (p >= n) return;\\n        st[p] = v + cost[p];\\n        int temp = st[p];\\n        helper_st(2 * p + 1, temp, n, cost, st);\\n        helper_st(2 * p + 2, temp, n, cost, st);\\n    }\\n\\n    int helper_ans(int l, int r, int n, vector<int>& st, int maxi) {\\n        if (l > r) \\n            return 0;\\n\\n        int currMax = *max_element(st.begin() + l, st.begin() + r + 1);\\n        int ans = maxi - currMax;\\n\\n        for (int i = l; i <= r; i++) \\n            st[i] += maxi - currMax;\\n        \\n\\n        if (l != r) {\\n            int m = (l + r) / 2;\\n            ans = ans + helper_ans(l, m, n, st, maxi);\\n            ans = ans + helper_ans(m + 1, r, n, st, maxi);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> st(n, 0);\\n        helper_st(0, 0, n, cost, st);\\n        int temp = n / 2;\\n        int temp2 = n - 1;\\n\\n        int maxi = *max_element(st.begin() + temp, st.end());\\n\\n        int ans = helper_ans(temp, temp2, n, st, maxi);\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\'helper_st\\'```\n```\\'st\\'```\n```\\'helper_ans\\'```\n```\\'minIncrements\\'```\n```\\'helper_st\\'```\n```\\'helper_ans\\'```\n```\\'helper_st\\'```\n```\\'maxi\\'```\n```\\'helper_ans\\'```\n```\\'maxi\\'```\n```\\'maxi\\'```\n```\\'minIncrements\\'```\n```\\'helper_ans\\'```\n```\\nclass Solution {\\npublic:\\n    void helper_st(int p, int v, int n, vector<int>& cost, vector<int>& st) {\\n        if (p >= n) return;\\n        st[p] = v + cost[p];\\n        int temp = st[p];\\n        helper_st(2 * p + 1, temp, n, cost, st);\\n        helper_st(2 * p + 2, temp, n, cost, st);\\n    }\\n\\n    int helper_ans(int l, int r, int n, vector<int>& st, int maxi) {\\n        if (l > r) \\n            return 0;\\n\\n        int currMax = *max_element(st.begin() + l, st.begin() + r + 1);\\n        int ans = maxi - currMax;\\n\\n        for (int i = l; i <= r; i++) \\n            st[i] += maxi - currMax;\\n        \\n\\n        if (l != r) {\\n            int m = (l + r) / 2;\\n            ans = ans + helper_ans(l, m, n, st, maxi);\\n            ans = ans + helper_ans(m + 1, r, n, st, maxi);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int minIncrements(int n, vector<int>& cost) {\\n        vector<int> st(n, 0);\\n        helper_st(0, 0, n, cost, st);\\n        int temp = n / 2;\\n        int temp2 = n - 1;\\n\\n        int maxi = *max_element(st.begin() + temp, st.end());\\n\\n        int ans = helper_ans(temp, temp2, n, st, maxi);\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496348,
                "title": "easy-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust follow simple instruction and make dfs call.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor max create another dfs call.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind,vector<int>& cost,int n,int c,int &ans){\\n     \\n        if(2*ind>n or 2*ind+1>n){return c-cost[ind-1];}\\n\\n    int l=dfs(2*ind,cost,n,c-cost[ind-1],ans);\\n    int r=dfs(2*ind+1,cost,n,c-cost[ind-1],ans);\\n   int x= min(l,r);\\n    ans+=l+r-2*x;\\n    return x;\\n\\n    }\\n    int dfs2(int ind,vector<int>& cost,int n){\\n         if(2*ind>n or 2*ind+1>n){return cost[ind-1];}\\n\\n    int l=dfs2(2*ind,cost,n);\\n    int r=dfs2(2*ind+1,cost,n);\\n   int x= max(l,r);\\n    return x+cost[ind-1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0, c=dfs2(1,cost,n);\\n       dfs(1,cost,n,c,ans);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int ind,vector<int>& cost,int n,int c,int &ans){\\n     \\n        if(2*ind>n or 2*ind+1>n){return c-cost[ind-1];}\\n\\n    int l=dfs(2*ind,cost,n,c-cost[ind-1],ans);\\n    int r=dfs(2*ind+1,cost,n,c-cost[ind-1],ans);\\n   int x= min(l,r);\\n    ans+=l+r-2*x;\\n    return x;\\n\\n    }\\n    int dfs2(int ind,vector<int>& cost,int n){\\n         if(2*ind>n or 2*ind+1>n){return cost[ind-1];}\\n\\n    int l=dfs2(2*ind,cost,n);\\n    int r=dfs2(2*ind+1,cost,n);\\n   int x= max(l,r);\\n    return x+cost[ind-1];\\n    }\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ans=0, c=dfs2(1,cost,n);\\n       dfs(1,cost,n,c,ans);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496269,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    private void calculateStep(int p,int v,int n,int[] cost,int[] st) {\\n        if (p>=n) {\\n            return;\\n        }\\n        st[p]=v+cost[p];\\n        calculateStep(2*p+1,st[p],n,cost,st);\\n        calculateStep(2*p+2,st[p],n,cost,st);\\n    }\\n\\n    private int calculateAns(int l, int r, int n, int[] st, int max) {\\n        if (l>r) {\\n            return 0;\\n        }\\n        int cmax = Integer.MIN_VALUE;\\n        for (int i=l; i<=r; i++) {\\n            cmax = Math.max(cmax, st[i]);\\n        }\\n        int res=max-cmax;\\n\\n        for (int i = l; i <= r; i++) {\\n            st[i]+=max-cmax;\\n        }\\n\\n        if (l != r) {\\n            int m = (l+r)/2;\\n            res +=calculateAns(l,m,n,st,max);\\n            res +=calculateAns(m+1,r,n,st,max);\\n        }\\n\\n        return res;\\n    }\\n\\n    public int minIncrements(int n, int[] cost) {\\n        int[] st = new int[n];\\n        calculateStep(0, 0, n, cost, st);\\n\\n        int maxInd = n/2;\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int i = maxInd; i<n; i++) {\\n            maxVal = Math.max(maxVal, st[i]);\\n        }\\n        int res=calculateAns(maxInd, n - 1, n, st, maxVal);\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    private void calculateStep(int p,int v,int n,int[] cost,int[] st) {\\n        if (p>=n) {\\n            return;\\n        }\\n        st[p]=v+cost[p];\\n        calculateStep(2*p+1,st[p],n,cost,st);\\n        calculateStep(2*p+2,st[p],n,cost,st);\\n    }\\n\\n    private int calculateAns(int l, int r, int n, int[] st, int max) {\\n        if (l>r) {\\n            return 0;\\n        }\\n        int cmax = Integer.MIN_VALUE;\\n        for (int i=l; i<=r; i++) {\\n            cmax = Math.max(cmax, st[i]);\\n        }\\n        int res=max-cmax;\\n\\n        for (int i = l; i <= r; i++) {\\n            st[i]+=max-cmax;\\n        }\\n\\n        if (l != r) {\\n            int m = (l+r)/2;\\n            res +=calculateAns(l,m,n,st,max);\\n            res +=calculateAns(m+1,r,n,st,max);\\n        }\\n\\n        return res;\\n    }\\n\\n    public int minIncrements(int n, int[] cost) {\\n        int[] st = new int[n];\\n        calculateStep(0, 0, n, cost, st);\\n\\n        int maxInd = n/2;\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int i = maxInd; i<n; i++) {\\n            maxVal = Math.max(maxVal, st[i]);\\n        }\\n        int res=calculateAns(maxInd, n - 1, n, st, maxVal);\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496158,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinIncrements(int n, int[] cost)\\n    {\\n        int res = 0;\\n        Search(ref res, 0, cost);\\n        return res;\\n    }\\n\\n    private int Search(ref int res, int i, int[] cost)\\n    {\\n        if (i >= cost.Length) return 0;\\n        int a = Search(ref res, 2 * i + 1, cost), b = Search(ref res, 2 * i + 2, cost);\\n        res += Math.Abs(a - b);\\n        return cost[i] + Math.Max(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinIncrements(int n, int[] cost)\\n    {\\n        int res = 0;\\n        Search(ref res, 0, cost);\\n        return res;\\n    }\\n\\n    private int Search(ref int res, int i, int[] cost)\\n    {\\n        if (i >= cost.Length) return 0;\\n        int a = Search(ref res, 2 * i + 1, cost), b = Search(ref res, 2 * i + 2, cost);\\n        res += Math.Abs(a - b);\\n        return cost[i] + Math.Max(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496098,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ret = 0 ;\\n        for(int i = n-1; i >= 2; i -= 2){\\n            int M = max(cost[i], cost[i-1]) ;\\n            ret += abs(cost[i] - cost[i-1]) ;\\n            int root = (i-1) / 2 ;\\n            cost[root] += M ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minIncrements(int n, vector<int>& cost) {\\n        int ret = 0 ;\\n        for(int i = n-1; i >= 2; i -= 2){\\n            int M = max(cost[i], cost[i-1]) ;\\n            ret += abs(cost[i] - cost[i-1]) ;\\n            int root = (i-1) / 2 ;\\n            cost[root] += M ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495908,
                "title": "javascript-2673-make-costs-of-paths-equal-in-a-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minIncrements = function (n, c) {\\n    let tot = 0;\\n    function dfs(i) {\\n        if (2 * i < n) {\\n            dfs(2 * i); // left child\\n            dfs(2 * i + 1);\\n            tot += Math.abs(c[2 * i - 1] - c[2 * i]); // diff of chldren\\n            c[i - 1] += Math.max(c[2 * i - 1], c[2 * i]); // add max of chldren to parent cost\\n        } else {\\n            return c[i - 1]; // send parent cost\\n        }\\n    }\\n    dfs(1); // start from root\\n    return tot;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minIncrements = function (n, c) {\\n    let tot = 0;\\n    function dfs(i) {\\n        if (2 * i < n) {\\n            dfs(2 * i); // left child\\n            dfs(2 * i + 1);\\n            tot += Math.abs(c[2 * i - 1] - c[2 * i]); // diff of chldren\\n            c[i - 1] += Math.max(c[2 * i - 1], c[2 * i]); // add max of chldren to parent cost\\n        } else {\\n            return c[i - 1]; // send parent cost\\n        }\\n    }\\n    dfs(1); // start from root\\n    return tot;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495884,
                "title": "java-easy-to-understand-dfs-solution",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    private int dfs(int n, int[] cost){\\n        if(n >= cost.length){\\n            return 0;\\n        }\\n        int left = dfs(2 * n + 1, cost);\\n        int right = dfs(2 * n + 2, cost);\\n        res += Math.abs(left - right);\\n        return Math.max(left, right) + cost[n];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        res = 0;\\n        dfs(0, cost);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    private int dfs(int n, int[] cost){\\n        if(n >= cost.length){\\n            return 0;\\n        }\\n        int left = dfs(2 * n + 1, cost);\\n        int right = dfs(2 * n + 2, cost);\\n        res += Math.abs(left - right);\\n        return Math.max(left, right) + cost[n];\\n    }\\n    public int minIncrements(int n, int[] cost) {\\n        res = 0;\\n        dfs(0, cost);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1885433,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1888071,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1890713,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1886858,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1886011,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1885389,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            },
            {
                "id": 1885554,
                "content": [
                    {
                        "username": "note_08",
                        "content": "I was thinking of making each level of tree  all node  value equal  using bfs  storing the level and then  counting the operation why is this approach wrong?"
                    },
                    {
                        "username": "aditya_42",
                        "content": "so let us say you have a node with value 2, it has children 3,4 \nNow 3 has children 5,5 and \n4 has children 4,4 \nThis makes the tree\n   ----      2\n    -- 3    4\n    5 5     4 4\nSo now you can see even with different leaf values the total cost in both sub trees is same (from root to leaf) "
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Because if you set the same cost on each level, it will affect the left and right tree\\nbtw i tried this approach too)"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Why I\\'m getting wrong output in this test case can anyone explain ??\\nInput\\nn =\\n15\\ncost =\\n[764,1460,2664,764,2725,4556,5305,8829,5064,5929,7660,6321,4830,7055,3761]\\nOutput\\n14195\\nExpected\\n15735\\n\\n\\n\\n\\nclass Solution {\\n    public int minIncrements(int n, int[] cost) {\\n        int N=n;\\n        int ans=Math.abs(cost[1]-cost[2]);\\n\\n        for(int i=1;i<N/2;i++)\\n        {\\n            ans+= Math.abs(cost[i*2+1]-cost[i*2+2]);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk_games",
                        "content": "Because: \\n---- 2\\n-- 3 4\\n5 5 4 4\\n[valid answer]\\n\\nNot the same as:\\n---- 2\\n-- 4 4\\n5 5 5 5\\n[not valid, not the smallest]"
                    },
                    {
                        "username": "sk_games",
                        "content": "For everybody who didn't get  (like myself) why simply aligning all items in the layer is not acceptable answer: \n\nBecause:\n---- 2\n-- 3 4\n5 5 4 4\n[valid answer, from root to leaf all equal]\n\nNot the same as:\n---- 2\n-- 4 4\n5 5 5 5\n[not valid, not the smallest]\n\nCredits to [@Aditya](/aditya_42)"
                    },
                    {
                        "username": "himanshuu173",
                        "content": "Can anyone explain y my code is wrng???\\nint minIncrements(int n, vector<int>& cost) {\\n        int cst=0;\\n        int i=0,c1=0,c2=0;\\n        while(i<n and c1<n and c2<n){\\n            c1=2*i+1,c2=2*i+2;\\n            if(cost[c1]==cost[c2] and c1<n and c2<n)i++;\\n            else if(cost[c1]!=cost[c2] and c1<n and c1<n){\\n                cst+=max(cost[c1],cost[c2])-min(cost[c1],cost[c2]);\\n                i++;\\n            }\\n            //else if(c1>=n or c2>=n) break;\\n        }\\n        return cst;\\n    }"
                    },
                    {
                        "username": "aman1320",
                        "content": "Why they have to asked the Binary Tree question without giving the binary tree ? :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think it's good practice to mix it up and force you to use different formats. The array representation of binary trees is not something leetcode made up, it's just one of the ways to represent them. In some languages, it might be a lot more efficient to store them like that than designing a class with pointers.\n\nDon't get too used to \"the usual leetcode format\" or you're gonna be taken by surprise in a different context"
                    },
                    {
                        "username": "aman1320",
                        "content": "[@Michael_V](/Michael_V) where did i wrote binary searcg tree?"
                    },
                    {
                        "username": "Michael_V",
                        "content": "It is a binary tree. Don't confuse it with BST (binary search tree)."
                    },
                    {
                        "username": "dynamo214",
                        "content": "Can someone help, Why I am getting TLE on Q4 DFS\n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@anya509](/anya509) yes"
                    },
                    {
                        "username": "anya509",
                        "content": "Trying passing variables by reference whenever you can for all function calls - here you can send cost array by reference."
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "[@dynamo214](/dynamo214) oh sure, I have not seen `&`) Have a nice day)"
                    },
                    {
                        "username": "dynamo214",
                        "content": "[@sergei-durkin](/sergei-durkin) Thanks for taking a look, I have found the issue.\nIn C++, in each pass it creates a new cost array which is time consuming, if we pass cost array by ref then it works like a charm\nso change\n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int> cost)` \nto \n`int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost)` \n```\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int res = 0, pathSum = 0;\n        dfs(0, pathSum, res, n, cost);\n        return res;\n    }\n    int dfs(int node, int pathSum, int& res, int lastNode, vector<int>& cost) {\n        if(node*2+2 < lastNode) {\n            int leftSum = dfs(node*2+1, pathSum+cost[node], res, lastNode, cost);\n            int rightSum = dfs(node*2+2, pathSum+cost[node], res, lastNode, cost);\n            res += abs(leftSum - rightSum);\n            return cost[node] + max(leftSum, rightSum);\n        }\n        return cost[node];\n    }\n};\n```"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Hi bro your code works fine with golang\\n```go\\nfunc minIncrements(n int, cost []int) int {\\n    res := 0\\n    dfs(0, 0, &res, n, cost)\\n    \\n    return res\\n}\\n\\nfunc dfs(i, sum int, res *int, n int, cost []int)int{\\n    if i*2+2 < n{\\n        left := dfs(i*2+1, sum+cost[i], res, n, cost)\\n        right := dfs(i*2+2, sum+cost[i], res, n, cost)\\n\\n        (*res) += abs(left-right)\\n        return cost[i]+max(left,right)\\n    }\\n    return cost[i]\\n}\\n\\nfunc abs(x int)int{\\n    if x < 0{\\n        return -x\\n    }\\n    return x\\n}\\n\\nfunc max(x,y int)int{\\n    if x > y{\\n        return x\\n    }\\n    return y\\n}\\n```"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If you would like a clear justification of the dfs logic, along with illustrations and detailed explanations, I posted a solution  \\n[here](https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/solutions/3495321/clear-simple-dfs-illustrated/)!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Neighboring Bitwise XOR",
        "question_content": "<p>A <strong>0-indexed</strong> array <code>derived</code> with length <code>n</code> is derived by computing the <strong>bitwise XOR</strong>&nbsp;(&oplus;) of adjacent values in a <strong>binary array</strong> <code>original</code> of length <code>n</code>.</p>\n\n<p>Specifically, for each index <code>i</code> in the range <code>[0, n - 1]</code>:</p>\n\n<ul>\n\t<li>If <code>i = n - 1</code>, then <code>derived[i] = original[i] &oplus; original[0]</code>.</li>\n\t<li>Otherwise, <code>derived[i] = original[i] &oplus; original[i + 1]</code>.</li>\n</ul>\n\n<p>Given an array <code>derived</code>, your task is to determine whether there exists a <strong>valid binary array</strong> <code>original</code> that could have formed <code>derived</code>.</p>\n\n<p>Return <em><strong>true</strong> if such an array exists or <strong>false</strong> otherwise.</em></p>\n\n<ul>\n\t<li>A binary array is an array containing only <strong>0&#39;s</strong> and <strong>1&#39;s</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> derived = [1,1,0]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] &oplus; original[1] = 0 &oplus; 1 = 1 \nderived[1] = original[1] &oplus; original[2] = 1 &oplus; 0 = 1\nderived[2] = original[2] &oplus; original[0] = 0 &oplus; 0 = 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> derived = [1,1]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> A valid original array that gives derived is [0,1].\nderived[0] = original[0] &oplus; original[1] = 1\nderived[1] = original[1] &oplus; original[0] = 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> derived = [1,0]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no valid original array that gives derived.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == derived.length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li>The values in <code>derived</code>&nbsp;are either <strong>0&#39;s</strong> or <strong>1&#39;s</strong></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3522095,
                "title": "java-c-python-sum-is-even",
                "content": "# **Explanation**\\norginal: `A[0], A[1], .... A[n-1]`\\nderived: `A[0]^A[1], A[1]^A[2] .... A[n-1]^A[0]`\\n\\n`xor(derived) = (A[0]^A[1])^(A[1]^A[2])^ .... ^(A[n-1]^A[0]) = 0`\\n\\nThe necessary and suffisant condition for `derived` to have an `original` is\\n`xor(derived) == 0`\\n\\nWhend `original` and `derived` is binary sequence,\\nthis equals to `sum(derived) % 2 == 0`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n\\n**Java**\\n```java\\n    public boolean doesValidArrayExist(int[] A) {\\n        return Arrays.stream(A).sum() % 2 == 0;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    bool doesValidArrayExist(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0) % 2 == 0;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def doesValidArrayExist(self, A: List[int]) -> bool:\\n        return sum(A) % 2 == 0\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean doesValidArrayExist(int[] A) {\\n        return Arrays.stream(A).sum() % 2 == 0;\\n    }\\n```\n```cpp\\n    bool doesValidArrayExist(vector<int>& A) {\\n        return accumulate(A.begin(), A.end(), 0) % 2 == 0;\\n    }\\n```\n```py\\n    def doesValidArrayExist(self, A: List[int]) -> bool:\\n        return sum(A) % 2 == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3522096,
                "title": "illustrated-step-by-step-simulation",
                "content": "We will discuss a solution that has the additional advantage of explicitly reconstructing the potential original array.\\nThere are other ways of solving the problem that do not achieve this, You can check the last section of this post for links to other nice solutions which show you how to do just that.\\n\\n# The inverse operation:\\nThe key insight here is that the reverse operation for XOR is.. XOR\\n\\nIt means that $(x \\\\oplus a) \\\\oplus a = x$ (because $a \\\\oplus a = 0$). Basically, you can cancel the operation \\u201C$\\\\oplus a$\\u201D by applying it a second time.\\nThis will prove very useful indeed to reverse the derived array into the original one!\\n\\n# Let\\'s draw an example \\n\\nLet\\u2019s visualize the situation. We have the knowledge of a derived array `d=[0,1,0,0,1,0]` that is constructed from an potential (unknown) original array `o` as such:\\n![step0.png](https://assets.leetcode.com/users/images/27bfa739-8849-44e4-9371-c41bd0babccc_1684037089.1706958.png)\\n\\nWe want to deduce the original array `o` from the derived one and see if it is valid. Well, having determined the reverse operation is sure gonna be useful for that! But we need a starting point\\u2026 \\n**Let\\u2019s first assume that the first element in the original array was 0**. Then we can compute the next element by using the reverse operation $\\\\oplus 0$, that is to say `o[1]=d[0]^0`. \\nHave a look:\\n![step1.png](https://assets.leetcode.com/users/images/634d5b31-5874-41f7-bef4-5ea6a1876a67_1684037140.3522964.png)\\n\\nThat\\u2019s great because we can just repeat that procedure with the newly obtained element:\\n![step2.png](https://assets.leetcode.com/users/images/ceda5252-3195-4763-b252-7203e2fcb906_1684037171.1177502.png)\\n\\n\\nYou get the drill! At each step, we can reconstruct the original array further using knowledge of the previous elements and our reverse operation! The whole procedure is shown below:\\n\\nstep3:\\n![step3.png](https://assets.leetcode.com/users/images/ef9291b8-b1fa-45aa-b51e-9951bb569124_1684037237.0331168.png)\\n\\nstep4:\\n![step4.png](https://assets.leetcode.com/users/images/b683451f-e341-4b98-9bde-1ce30f055525_1684037245.0338237.png)\\n\\nstep5:\\n![step5.png](https://assets.leetcode.com/users/images/310b523f-3453-4208-891e-c526ec159927_1684037251.8169003.png)\\n\\n\\n\\n\\nEventually, we are able to reconstruct the whole array. In our case, we got `o=[0,0,1,1,1,0]`.\\nNow how do we know if it is valid? Well, we didn\\u2019t yet use the last value of our derived array to reconstruct the orginal one (check again the graphical  steps above if you don\\'t believe me!). That is our validity condition!  \\n\\nWe check if the last element of the original array XOR the first gives us the result in the last square indeed `o[0]^o[-1]==d[-1]`. \\nIf yes, the array is valid (it is valid in our case). **If not, try again assuming that the first value was 1!**\\nAnd that\\u2019s all, we covered every case! If we can\\'t find a valid original array starting with either 0 or 1, it means there\\'s no possible original array\\n\\nDo feel free to upvote if that helped you visualize and understand what is going on!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1). We don\\'t need to explicitly reconstruct the original array (which would be O(n) space), because at each step we only use the value at the previous index, so a single variable is enough to hold it\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        #we try 0 and 1 as potential first elements\\n        for first in [0,1]:\\n            original=first\\n            for result in derived[:-1]:\\n                #we apply the reverse operation as shown in the pictures\\n                original=original^result\\n            #finally, we check if the validity condtion is true\\n            if original^first==derived[-1]:\\n                return True\\n        return False\\n        \\n```\\n\\n# Other great solutions:\\nYou can find a [different thought process explained here](https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3521867/full-thought-process-one-line-solution/) or [more formally proven here](https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3521882/c-java-python-explanation-with-formal-proof-one-liner-time-o-n/).\\nThose solutions are great because they are more \"parcimonious\". They do not reconstruct the original array (which the problem doesn\\'t require), so it leads to shorter solutions.\\nThey rely on the idea that if the array has been derived from an original array, then the whole XOR aggregation must be zero: $d[0] \\\\oplus d[1] \\\\oplus ... \\\\oplus d[n] == 0$.\\nIf you have followed this solution, can you see why? Take another look at the images if you need it or just check out the links ;)\\nLee has an [even slightly craftier version](https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3522095/java-c-python-sum-is-even/) \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        #we try 0 and 1 as potential first elements\\n        for first in [0,1]:\\n            original=first\\n            for result in derived[:-1]:\\n                #we apply the reverse operation as shown in the pictures\\n                original=original^result\\n            #finally, we check if the validity condtion is true\\n            if original^first==derived[-1]:\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521882,
                "title": "c-java-python-explanation-with-formal-proof-one-liner-time-o-n",
                "content": "# Intuition\\n`derived` array is given as\\n```\\n[a[0] ^ a[1],\\n a[1] ^ a[2],\\n a[2] ^ a[3],\\n .\\n .\\n .\\n a[n - 2] ^ a[n - 1]\\n a[n - 1] ^ a[0]]\\n```\\nTake Bitwise-XOR of `derived` array.\\nSince `x ^ x = 0` and `x ^ 0 = x`.\\nUse these properties to cancel out `a[1], a[2], ..., a[n - 1]`.\\n\\n![image.png](https://assets.leetcode.com/users/images/be63ea49-544b-415a-96c7-4a7052270812_1684167829.023799.png)\\n\\nWe will be left with `a[0] ^ a[0] = 0`.\\n\\nSo Bitwise-XOR of derived array should be `0` for `original` to exist.\\n\\n**Proof of why this is a necessary condition**\\nIf Bitwise-XOR comes `1` then it means there is some `a[i]` which didn\\'t find it\\'s another `a[i]` to cancel each other, meaning `a[i] != a[i]` which is a contradiction. So, for any possible `original` array, `derived` array\\'s Bitwise-XOR will always be `0`. If it is not, that means `original` does not exists.\\n\\n**Proof of why this is a sufficient condition**\\nCredits to [@Andimeo](/Andimeo) for pointing this out. I will also try to generate `original` array from `derived`.\\n\\n> I will be using this identity which says:\\nIf `x ^ y = z`, then `y ^ z = x` and `x ^ z = y`.\\nProof: `y ^ z = y ^ (x ^ y) = x`\\nMeans we can shuffle `x`, `y`, and `z` any way we want.\\n\\nWe have to make `[a[0], a[1], a[2], ..., a[n - 1]]`\\nLet\\'s assume `a[0] = a[0]`. ~(Haha, really?)~ I mean just let\\'s say we don\\'t bother calculating `a[0]`.\\nAlso, we are given `[d[0], d[1], d[2], ..., d[n - 1]]`\\n\\n- If `d[0] = a[0] ^ a[1]` then `a[1] = a[0] ^ d[0]`.\\n- If `d[1] = a[1] ^ a[2]` then `a[2] = a[1] ^ d[1] = a[0] ^ d[0] ^ d[1]`.\\n- If `d[2] = a[2] ^ a[3]` then `a[3] = a[2] ^ d[2] = a[0] ^ d[0] ^ d[1] ^ d[2]`\\n.\\n.\\n.\\n- `a[n - 1] = a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]`\\n\\nThe `original` array will be:\\n```\\n[a[0],\\n a[0] ^ d[0],\\n a[0] ^ d[0] ^ d[1],\\n a[0] ^ d[0] ^ d[1] ^ d[2],\\n .\\n .\\n .\\n a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]]\\n```\\n\\nNow, we know `d[n - 1] = a[n - 1] ^ a[0]`. Put the value of `a[n - 1]` from above:\\n```\\nd[n - 1] = (a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]) ^ a[0]\\n         =         d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]\\n\\nd[n - 1] ^ 0 = d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]\\nd[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2] ^ d[n - 1] = 0\\n```\\nHence proved.\\n\\n> Notice how `a[0]` gets cancelled out in equation of `d[n - 1]`? Means value of `a[0]` does not matter. Therefore, for a valid `derived` array, there will be 2 `original` arrays, one with `a[0] = 0` and another with `a[0] = 1`. Also, both of them will be 1\\'s complement of each other.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xr = 0;\\n        for (int x: derived) {\\n            xr = xr ^ x;\\n        }\\n        return xr == 0;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return not reduce(operator.xor, derived)\\n```\\n\\n# Complexity\\n- Time Complexity: $$O(n)$$\\n- Space Complexity: $$O(1)$$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n[a[0] ^ a[1],\\n a[1] ^ a[2],\\n a[2] ^ a[3],\\n .\\n .\\n .\\n a[n - 2] ^ a[n - 1]\\n a[n - 1] ^ a[0]]\\n```\n```\\n[a[0],\\n a[0] ^ d[0],\\n a[0] ^ d[0] ^ d[1],\\n a[0] ^ d[0] ^ d[1] ^ d[2],\\n .\\n .\\n .\\n a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]]\\n```\n```\\nd[n - 1] = (a[0] ^ d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]) ^ a[0]\\n         =         d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]\\n\\nd[n - 1] ^ 0 = d[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2]\\nd[0] ^ d[1] ^ d[2] ^ ... ^ d[n - 2] ^ d[n - 1] = 0\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xr = 0;\\n        for (int x: derived) {\\n            xr = xr ^ x;\\n        }\\n        return xr == 0;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return not reduce(operator.xor, derived)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521867,
                "title": "full-thought-process-one-line-solution",
                "content": "# Properties About XOR\\n\\nThe operator XOR has the following property:\\n\\n```\\nA xor A = 0\\n```\\n\\nalso,\\n\\n```\\nA xor A xor B xor B = 0\\n```\\n\\nThe order of which we place `A` or `B` does not matter. This means:\\n\\n```\\nA xor B xor B xor A = 0\\n```\\n\\nWe can reason about this because, when we have the same value in the xor formula even number of times, their bits \"cancel\" each other out and gives us 0. And, for any number `x`,  `x xor 0` will just give us `x`.\\n\\n# Derived Array and Original Array\\n\\nIn the derived array, since `derived[0] = original[0] xor original[1]`, `derived[1] = original[1] xor original[2]`, ..., `derived[n] = original[n] xor original[0]`, we notice that for a valid derived array, when we `xor` all elements in the derived array, we must obtain 0.\\n\\nSuppose that we have an original array `[A B C D]`. The derived array, by definition, will be `[A xor B, B xor C, C xor D, D xor A]`. When we `xor` all elements in the derived array, we are calculating `A xor B` xor `B xor C` xor `C xor D` xor `D xor A`. We can see that every member of the original array appeared twice in the xor formula.\\n\\nNow, please take time to convince yourself that\\n(1) For all original arrays, xor(derived) **must** be equal to 0; and\\n(2) For all derived arrays, if xor(derived) != 0, then the derived array **must not** be valid.\\n\\n# Algorithm\\n\\n```python3\\ndef doesValidArrayExist(self, derived: List[int]) -> bool:\\n    return reduce(operator.xor, derived) == 0\\n```\\n\\n`reduce(operator.xor, derived)` finds the `xor(derived)` as mentioned above.\\n\\n**Please give an upvote** if this post helps you understand the thought process behind my solution. Thanks for your help for more content to come!\\n\\n**Other Great Solutions**\\nSome of my learnings too:\\n1. I noticed that we haven\\'t fully utilized the \"binary array\" condition. @lee215 gives an awesome solution on utilizing the sum of the array: https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3522095/java-c-python-sum-is-even\\n2. If you\\'d like a visualization, @cartesPerforees drew a great diagram: https://leetcode.com/problems/neighboring-bitwise-xor/solutions/3522096/illustrated-step-by-step-solution\\n\\nI hope this really helps your LeetCode journey! Please keep going.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nA xor A = 0\\n```\n```\\nA xor A xor B xor B = 0\\n```\n```\\nA xor B xor B xor A = 0\\n```\n```python3\\ndef doesValidArrayExist(self, derived: List[int]) -> bool:\\n    return reduce(operator.xor, derived) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3522054,
                "title": "xor-of-all-java-python-c-simple-approach",
                "content": "# Intuition\\nXor of all the elements should be zero.\\n\\n# Approach\\nlet\\'s us take original = [a,b,c,d,e]\\n        \\nthen derived = [a ^ b, b ^ c, c ^ d, d ^ e, e ^ a] \\n        \\nIf we perform XOR operation of all the elements of derived array then result should be zero beacause\\n        \\na ^ b ^ b ^ c ^ c ^ d ^ d ^ e ^ e ^ a = 0 \\n        \\nHence if it results in zero then we can form the original array. \\n\\n**Solution (Java):**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    boolean doesValidArrayExist(int[] derived) {\\n        int total = 0;\\n        for(int i = 0; i < derived.length; i++)\\n            total = total ^ derived[i];\\n        return total == 0;\\n    }\\n};\\n```\\n\\n\\n**Solution (C++):**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    boolean doesValidArrayExist(vector<int>& derived) {\\n        int total = 0;\\n        for(int &a: derived)\\n            total = total ^ a;\\n        return total == 0;\\n    }\\n};\\n```\\n\\n\\n**Solution (Python):**\\n\\n```\\ntotal = 0 \\nfor i in derived:\\n    total = total ^ i\\n            \\nreturn total == 0\\n```\\n\\n**One liner (python):**\\n\\n```\\nreturn reduce(operator.xor, derived) == 0\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    boolean doesValidArrayExist(int[] derived) {\\n        int total = 0;\\n        for(int i = 0; i < derived.length; i++)\\n            total = total ^ derived[i];\\n        return total == 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    boolean doesValidArrayExist(vector<int>& derived) {\\n        int total = 0;\\n        for(int &a: derived)\\n            total = total ^ a;\\n        return total == 0;\\n    }\\n};\\n```\n```\\ntotal = 0 \\nfor i in derived:\\n    total = total ^ i\\n            \\nreturn total == 0\\n```\n```\\nreturn reduce(operator.xor, derived) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521940,
                "title": "explained-simple",
                "content": "<b>Up vote if you like the solution</b>\\n\\n# Approach \\n1. Assume the 0th index value is 0 ( as status ).\\n2. Then keep traking the status variable by following ( basically toggle the value of status):\\n   - when the dervied is 1 & status is 0 then change it to 1.\\n   - when the derived is 1 & status is 1 then change it to 0.\\n3. At the end of the traverse, then final reault of status should be same as the inital ( that is 0)\\n       if that is the case then return true other wise return false.\\n    \\n    \\n# Code\\n\\n```\\nbool doesValidArrayExist(vector<int>& derived) {\\n    int status = 0;\\n    for(auto n: derived) status = (status + n)%2;\\n    return (status == 0);\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool doesValidArrayExist(vector<int>& derived) {\\n    int status = 0;\\n    for(auto n: derived) status = (status + n)%2;\\n    return (status == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521942,
                "title": "one-liner",
                "content": "I originally solved by restoring the array, assuming we start either from `0` or `1`.\\n\\nThen, I realized that we can simplify the check - we can always build the array if we have an even number of `1`.\\n\\n## One-Liner\\n**C++**\\n```cpp\\nbool doesValidArrayExist(vector<int>& derived) { \\n    return accumulate(begin(derived), end(derived), 0, bit_xor<>()) == 0;\\n}\\n```\\n\\n## Original Solution\\n**C++**\\n```cpp\\nbool check(vector<int>& derived, int i, int start, int cur) {\\n    if (i + 1 == derived.size())\\n        return start ^ cur == derived[i];\\n    return check(derived, i + 1, start, cur ^ derived[i]);\\n}\\nbool doesValidArrayExist(vector<int>& derived) {\\n    return check(derived, 0, 0, 0) || check(derived, 0, 1, 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool doesValidArrayExist(vector<int>& derived) { \\n    return accumulate(begin(derived), end(derived), 0, bit_xor<>()) == 0;\\n}\\n```\n```cpp\\nbool check(vector<int>& derived, int i, int start, int cur) {\\n    if (i + 1 == derived.size())\\n        return start ^ cur == derived[i];\\n    return check(derived, i + 1, start, cur ^ derived[i]);\\n}\\nbool doesValidArrayExist(vector<int>& derived) {\\n    return check(derived, 0, 0, 0) || check(derived, 0, 1, 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522147,
                "title": "fast-and-simple-o-n-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto x:d)\\n            m^=x;\\n        if(m==0)return 1;\\n        else return 0;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto x:d)\\n            m^=x;\\n        if(m==0)return 1;\\n        else return 0;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522838,
                "title": "just-count-how-many-ones-java-simple-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEvery time you met 1, you have to make sure the next neigbor from original different than this prev neigbor from original.\\nEvery time you met 0, you have to make sure the next neigbor from original SAME with this prev neigbor from original.\\nThe last neig will be the first original number. That means you have to change even times to come back, that is even times of 1.\\n\\nSo keep it simple, you just need count how many 1s. True if Even Counts of ONEs.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int cnt = 0;\\n        for (int n : derived) if (n == 1) cnt++;\\n        return cnt % 2 == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int cnt = 0;\\n        for (int n : derived) if (n == 1) cnt++;\\n        return cnt % 2 == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521955,
                "title": "cpp-count-1-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int xr = 0;\\n        for(int x : v) xr ^= x;\\n        return xr == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int xr = 0;\\n        for(int x : v) xr ^= x;\\n        return xr == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532393,
                "title": "python-3-1-line-w-proof-t-m-84-82",
                "content": "This problem is much more a mathematics problem than a coding problem. The solution is`true` if the count of ones in`derived` is even and`false`otherwise. Here\\'s the proof:\\n\\nThe`xor`operator has these identities:\\n```\\n(1)         a xor 0 =  a                (0 is the xor-identity element)\\n(2)         a xor 1 = ~a                (xor with 1 flips the other digit)\\n(3)         a xor a = 0                 (a is its own xor-inverse)\\n(4) (a xor b) xor c = a xor (b xor c)   (xor is associative)\\n\\n```\\nUsing (3) and (4)), one can assert that the constraint`derived[i] = original[i] \\u2295 original[i+1]`implies that\\n```\\n(*)            original[i+1] = original[i] \\u2295 derived[i].\\n(**)             original[0] = original[n-1] \\u2295 derived[n-1].\\n```\\nWe can use (*) to iteratively construct`original` from derived.\\n\\nSuppose that`derived = [1,0,1,0,0]`and we arbitrally assign`original[0] = 1`. Then:\\n ```\\n                                                   derived = [1, 0,1,0,0]\\n                                                  original = [1, _,_,_,_]\\n\\n    original[1] = original[0] \\u2295 derived[0] = 1 \\u2295 1 = 0       [1,0, 1,0,0] \\n                                                             [1,0, _,_,_]\\n\\n    original[2] = original[1] \\u2295 derived[1] = 0 \\u2295 0 = 0       [1,0,1, 0,0]\\n                                                             [1,0,0, _,_]\\n     \\n    original[3] = original[2] \\u2295 derived[2] = 1 \\u2295 1 = 1       [1,0,1,0, 0]\\n                                                             [1,0,0,1, _]\\n\\n    original[4] = original[3] \\u2295 derived[3] = 0 \\u2295 0 = 1       [1,0,1,0,0 ]\\n                                                             [1,0,0,1,1 ]\\n```\\nThus`original = [1,0,0,0,1]`is a possible solution: It remains to check (**):\\n\\n```\\n    original[0] = 1 =? original[4] \\u2295 derived[4] =? 0 \\u2295 0 = 1.\\n```\\nThus,`original = [1,0,0,1,0]` is a valid solution. \\n\\nNote that by (1), `derived[i] = 0` causes `original[i+1]` to be the same as `original[i]` and that by (2), `derived[i] = 1` causes `original[i+1]` to be the flip of `original[i]`. It\\'s not diffcult to see that (**) is true if and only if the number of flips is even, or equivalently *the count of ones in `derived` is an even integer.*\\n\\nIt\\'s worth asking what happens if we had arbitrally assigned`original[0] = 0` instead of one. (Hint: there\\'s either exactly zero or exactly two solutions for any given `derived`).\\n\\nThe code:\\n\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        return  sum(derived)%2^1\\n```\\n[https://leetcode.com/problems/neighboring-bitwise-xor/submissions/951729349/](http://)\\n\\nPython 3   ||   1 line,  w/ proof   ||   T/M: 84% / 82%\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n(1)         a xor 0 =  a                (0 is the xor-identity element)\\n(2)         a xor 1 = ~a                (xor with 1 flips the other digit)\\n(3)         a xor a = 0                 (a is its own xor-inverse)\\n(4) (a xor b) xor c = a xor (b xor c)   (xor is associative)\\n\\n```\n```\\n(*)            original[i+1] = original[i] \\u2295 derived[i].\\n(**)             original[0] = original[n-1] \\u2295 derived[n-1].\\n```\n```\\n                                                   derived = [1, 0,1,0,0]\\n                                                  original = [1, _,_,_,_]\\n\\n    original[1] = original[0] \\u2295 derived[0] = 1 \\u2295 1 = 0       [1,0, 1,0,0] \\n                                                             [1,0, _,_,_]\\n\\n    original[2] = original[1] \\u2295 derived[1] = 0 \\u2295 0 = 0       [1,0,1, 0,0]\\n                                                             [1,0,0, _,_]\\n     \\n    original[3] = original[2] \\u2295 derived[2] = 1 \\u2295 1 = 1       [1,0,1,0, 0]\\n                                                             [1,0,0,1, _]\\n\\n    original[4] = original[3] \\u2295 derived[3] = 0 \\u2295 0 = 1       [1,0,1,0,0 ]\\n                                                             [1,0,0,1,1 ]\\n```\n```\\n    original[0] = 1 =? original[4] \\u2295 derived[4] =? 0 \\u2295 0 = 1.\\n```\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        return  sum(derived)%2^1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522565,
                "title": "c-no-of-1-s-odd-or-even-easy-to-uderstand",
                "content": "get no of 1\\'s is odd or even.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int x = 0;\\n        for(auto &i: v)x ^= i;\\n        return (x==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int x = 0;\\n        for(auto &i: v)x ^= i;\\n        return (x==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522031,
                "title": "easy-and-fast-solution-o-n-time-o-1-space",
                "content": "# Approach\\nwe just need to try it but remember that 0 ^ 1 is same as 1 ^ 0 so it doesn\\'t matter how we start because we need to know if it\\'s true or false so it\\'s like easy 1d dp like fib problem\\n\\n# Code\\n```\\nvar doesValidArrayExist = function(derived) {\\n    let n = derived.length;\\n    let original = 1\\n    for(let i = 1; i < n; i++){\\n        original = original ^ derived[i - 1];\\n    }\\n    return 1 ^ original == derived[n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar doesValidArrayExist = function(derived) {\\n    let n = derived.length;\\n    let original = 1\\n    for(let i = 1; i < n; i++){\\n        original = original ^ derived[i - 1];\\n    }\\n    return 1 ^ original == derived[n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521965,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522108,
                "title": "pen-paper-explaination-easy-c-code",
                "content": "### DO UPVOTE If you find it useful !\\n![image.png](https://assets.leetcode.com/users/images/d5e0ef66-cb2a-4872-a1fe-146495608ef5_1684037490.8005672.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int n=d.size();\\n        bool chk=d[0];\\n        for(int i=1 ; i<n; i++){\\n            chk=chk^(d[i]);\\n        }\\n        return !chk;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int n=d.size();\\n        bool chk=d[0];\\n        for(int i=1 ; i<n; i++){\\n            chk=chk^(d[i]);\\n        }\\n        return !chk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522094,
                "title": "c-pure-implementation-easy-to-understand",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int> ori;\\n        int n= derived.size();\\n        ori.push_back(1);\\n        for (int i=0; i<n-1; i++){\\n            int el= ori[i];\\n            if (derived[i]==0){\\n                ori.push_back(el);\\n            }\\n            else{\\n                ori.push_back(!el);\\n            }\\n        }\\n        if (derived[n-1]==0){\\n            return (ori[0]==ori[n-1]);\\n        }\\n        return (ori[0]!=ori[n-1]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Brainteaser",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int> ori;\\n        int n= derived.size();\\n        ori.push_back(1);\\n        for (int i=0; i<n-1; i++){\\n            int el= ori[i];\\n            if (derived[i]==0){\\n                ori.push_back(el);\\n            }\\n            else{\\n                ori.push_back(!el);\\n            }\\n        }\\n        if (derived[n-1]==0){\\n            return (ori[0]==ori[n-1]);\\n        }\\n        return (ori[0]!=ori[n-1]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521915,
                "title": "day-409-easy-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition &  Approach\\n<!-- Describe your approach to solving the problem. -->\\nhey create an array A of the same size as D and fill it using the XOR operation. Then they iterate over A and D to check if the XOR of adjacent elements in A matches the corresponding element in D. If all elements match, the function returns true, otherwise it returns false.\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\npublic boolean doesValidArrayExist(int[] D) {\\n    int n = D.length;\\n    int A[] = new int[n];\\n    for(int i=0;i<n-1;i++){\\n        A[i+1]=(A[i]^D[i]);\\n    }\\n    for(int i=0;i<n;i++){\\n        int ni= (i+1)%n;\\n        if((A[i]^A[ni])!=D[i]) return false;\\n    }return true;\\n}\\n```\\n```c++ []\\nbool doesValidArrayExist(vector<int>& D) {\\n    int n = D.size();\\n    vector<int> A(n, 0);\\n    for (int i = 0; i < n - 1; i++) {\\n        A[i + 1] = A[i] ^ D[i];\\n    }\\n    for (int i = 0; i < n; i++) {\\n        int ni = (i + 1) % n;\\n        if ((A[i] ^ A[ni]) != D[i]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```\\n```python []\\ndef doesArrayExist(D: List[int]) -> bool:\\n    n = len(D)\\n    A = [0] * n\\n    for i in range(n - 1):\\n        A[i + 1] = A[i] ^ D[i]\\n    for i in range(n):\\n        ni = (i + 1) % n\\n        if (A[i] ^ A[ni]) != D[i]:\\n            return False\\n    return True",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic boolean doesValidArrayExist(int[] D) {\\n    int n = D.length;\\n    int A[] = new int[n];\\n    for(int i=0;i<n-1;i++){\\n        A[i+1]=(A[i]^D[i]);\\n    }\\n    for(int i=0;i<n;i++){\\n        int ni= (i+1)%n;\\n        if((A[i]^A[ni])!=D[i]) return false;\\n    }return true;\\n}\\n```\n```c++ []\\nbool doesValidArrayExist(vector<int>& D) {\\n    int n = D.size();\\n    vector<int> A(n, 0);\\n    for (int i = 0; i < n - 1; i++) {\\n        A[i + 1] = A[i] ^ D[i];\\n    }\\n    for (int i = 0; i < n; i++) {\\n        int ni = (i + 1) % n;\\n        if ((A[i] ^ A[ni]) != D[i]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521880,
                "title": "check-xor-0-or-not",
                "content": "```\\nclass Solution \\n{\\n    public boolean doesValidArrayExist(int[] derived)\\n    {\\n        int xor =0;\\n        for(int d: derived)\\n        {\\n           xor ^= d;\\n        }\\n        return xor == 0;\\n    }\\n}\\n/*\\nlet original array be ;  arr \\nDerived be drr :  \\n\\n drr[0] = arr[0] ^ arr[1] ;\\n drr[1] = arr[1] ^ arr[2] ;\\n ........ \\n ........\\n     \\n drr[n-1] = arr[n-1] ^ arr[0];\\n\\nif u do xor separtely for both sides L.H.S and R.H.S\\n\\ndrr[0] ^ drr[1] ^... drr[n-1] = 0\\n*/\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean doesValidArrayExist(int[] derived)\\n    {\\n        int xor =0;\\n        for(int d: derived)\\n        {\\n           xor ^= d;\\n        }\\n        return xor == 0;\\n    }\\n}\\n/*\\nlet original array be ;  arr \\nDerived be drr :  \\n\\n drr[0] = arr[0] ^ arr[1] ;\\n drr[1] = arr[1] ^ arr[2] ;\\n ........ \\n ........\\n     \\n drr[n-1] = arr[n-1] ^ arr[0];\\n\\nif u do xor separtely for both sides L.H.S and R.H.S\\n\\ndrr[0] ^ drr[1] ^... drr[n-1] = 0\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859871,
                "title": "simple-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n       int currXor=0;\\n       for(int i: derived)\\n        currXor ^= i;\\n        return currXor==0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n       int currXor=0;\\n       for(int i: derived)\\n        currXor ^= i;\\n        return currXor==0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693512,
                "title": "best-c-solution-approach-easily-explained-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets consider the first example:\\nSay `original = [a, b, c]` and given is `derived = [1, 1, 0]`\\nNow, it is given that `derived[i] = original[i]^original[i+1]` for all and `dervied[n-1] = original[n-1]^original[0] `\\nWe can see that `a^b = 1` Similarly `b^c = 1 and c^a = 0`\\nNow, if we perform XOR of all these equations then it must result in 0. \\n\\n## **Proof** \\n`(a^b) ^ (b^c) ^ (c^a) = (a^a) ^ (b^b) ^ (c^c) = 0`\\nNow, if you observe,` a^b = 1, b^c = 1 and c^a = 0` are the elements of derived array and hence must give **XOR of all elements equal to zero.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.size(); i++)\\n            ans ^= derived[i];\\n        return ans==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.size(); i++)\\n            ans ^= derived[i];\\n        return ans==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686249,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n\\n        for(int i=0; i<derived.size();i++){\\n            x^=derived[i];\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n\\n        for(int i=0; i<derived.size();i++){\\n            x^=derived[i];\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653902,
                "title": "xorr",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xoor = 0;\\n        for (auto i: derived) xoor ^= i;\\n        return !xoor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xoor = 0;\\n        for (auto i: derived) xoor ^= i;\\n        return !xoor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549808,
                "title": "neighboring-bitwise-xor-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        bool res=true;\\n        int n=derived.size();\\n        if(n==1)\\n        {\\n            if(derived[0]==0)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        vector<int> temp(n);\\n        if(derived[0]==0)\\n        {\\n            temp[0]=1;\\n            temp[1]=1;\\n        }\\n        else\\n        {\\n            temp[0]=1;\\n            temp[1]=0;\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            int val=temp[i];\\n            if(derived[i]==0)\\n            {\\n                temp[i+1]=val;\\n            }\\n            else\\n            {\\n                if(val==0)\\n                {\\n                    temp[i+1]=1;\\n                }\\n                else\\n                {\\n                    temp[i+1]=0;\\n                }\\n            }\\n        }\\n        int last=temp[n-1]^temp[0];\\n        if(last==derived[n-1])\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        bool res=true;\\n        int n=derived.size();\\n        if(n==1)\\n        {\\n            if(derived[0]==0)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        vector<int> temp(n);\\n        if(derived[0]==0)\\n        {\\n            temp[0]=1;\\n            temp[1]=1;\\n        }\\n        else\\n        {\\n            temp[0]=1;\\n            temp[1]=0;\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            int val=temp[i];\\n            if(derived[i]==0)\\n            {\\n                temp[i+1]=val;\\n            }\\n            else\\n            {\\n                if(val==0)\\n                {\\n                    temp[i+1]=1;\\n                }\\n                else\\n                {\\n                    temp[i+1]=0;\\n                }\\n            }\\n        }\\n        int last=temp[n-1]^temp[0];\\n        if(last==derived[n-1])\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538437,
                "title": "by-finding-original-array-c-bitwise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        vector<int> ori(n,0);\\n        if(n > 1)\\n        ori[1] = derived[0]^ori[0];\\n        for(int i = 2;i < n;i++){\\n            ori[i] = ori[i-1]^derived[i-1];\\n        }\\n        for(int i = 0;i < n-1;i++){\\n            if(ori[i]^ori[i+1] != derived[i])\\n            return false;\\n        }\\n        if(ori[n-1]^ori[0] != derived[n-1])\\n        return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        vector<int> ori(n,0);\\n        if(n > 1)\\n        ori[1] = derived[0]^ori[0];\\n        for(int i = 2;i < n;i++){\\n            ori[i] = ori[i-1]^derived[i-1];\\n        }\\n        for(int i = 0;i < n-1;i++){\\n            if(ori[i]^ori[i+1] != derived[i])\\n            return false;\\n        }\\n        if(ori[n-1]^ori[0] != derived[n-1])\\n        return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535178,
                "title": "python-simple-and-clean-beats-99-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\nThe problem asks us to determine whether there exists a valid binary array `original` that could have formed a given array `derived` by computing the bitwise XOR of adjacent values in `original`. Our first thought might be to check if the sum of all elements in `derived` is even. If it is, then there must be an even number of 1\\'s in `original` and a valid binary array `original` exists.\\n\\n# Approach\\n1. We can use the property that if the sum of all elements in `derived` is even, then there must be an even number of 1\\'s in `original`.\\n2. To see why this property holds, let\\'s consider two cases:\\n    - If there are an even number of 1\\'s in `original`, then each pair of adjacent 1\\'s will cancel out when computing the bitwise XOR. This means that the sum of all elements in `derived` will be even.\\n    - If there are an odd number of 1\\'s in `original`, then all but one pair of adjacent 1\\'s will cancel out when computing the bitwise XOR. This means that the sum of all elements in `derived` will be odd.\\n3. Therefore, if the sum of all elements in `derived` is even, then there must be an even number of 1\\'s in `original`, and a valid binary array `original` exists.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the length of the array `derived`. This is because we need to compute the sum of all elements in `derived`, which takes $$O(n)$$ time.\\n- Space complexity: $$O(1)$$ since we only use a constant amount of extra space.\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return sum(derived)%2 == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return sum(derived)%2 == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526322,
                "title": "java-easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int original = 0;\\n        for(int i =0;i<derived.length;i++){\\n            original = original ^ derived[i];\\n        }\\n        if(original == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int original = 0;\\n        for(int i =0;i<derived.length;i++){\\n            original = original ^ derived[i];\\n        }\\n        if(original == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525924,
                "title": "python-simulation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start with an arbitary original[0] and iteratively calculate original[n - 1] from the formula derived[i] = original[i] \\u2295 original[i + 1].\\nThe only thing we need to check is if derived[n - 1] = original[n - 1] \\u2295 original[0]. Since we\\'ve fixed original[0] = 1, we can write derived[n - 1] = original[n - 1] \\u2295 1. The function is true when derived[n - 1] is NOT original[n - 1], or we can say the array is valid if derived[n - 1] \\u2295 original[n - 1] is true. \\n\\n### Example 1:\\n**Input:** derived = [1,1,0]\\n**Output:** true\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nderived[1] = 1 &rarr; original[2] is NOT original[1] &rarr; original[2] = 1\\nFinally we need to check if derived[2] \\u2295 original[2] is true &rarr; 0 \\u2295 1, which is true!\\n\\n### Example 3:\\n**Input:** derived = [1,0]\\n**Output:** false\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nFinally we need to check if derived[1] \\u2295 original[1] is true &rarr; 0 \\u2295 0, which is false!\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525527,
                "title": "answer-in-2-lines-very-easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xorSum = 0;\\n        for (int i = 0; i < derived.size() ; i++)xorSum ^= derived[i];\\n        return xorSum == 0 && (derived[0] == 0 || derived[0] == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xorSum = 0;\\n        for (int i = 0; i < derived.size() ; i++)xorSum ^= derived[i];\\n        return xorSum == 0 && (derived[0] == 0 || derived[0] == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524654,
                "title": "c-best-shortest-4-lines-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDONE \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust count the number of 1\\'s and if its even return true else false if odd \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(auto it:derived)\\n        {\\n            if(it==1) count++;\\n        }\\n        if(count&1) return false;\\n        else return true;\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/2bf81065-0f05-4c07-bf02-71e80f866bc2_1684088543.5221298.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(auto it:derived)\\n        {\\n            if(it==1) count++;\\n        }\\n        if(count&1) return false;\\n        else return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524588,
                "title": "c-best-shortest-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(auto it:derived)\\n        {\\n            if(it==1) count++;\\n        }\\n        if(count&1) return false;\\n        else return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(auto it:derived)\\n        {\\n            if(it==1) count++;\\n        }\\n        if(count&1) return false;\\n        else return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524555,
                "title": "easy-c-solution-simple-explained",
                "content": "# Intuition\\nJust check original array for length (varying) to observe any pattern.\\nExample :-\\n- for len = 1 -> i) [0] .. true , ii) [1] - false\\n- for len = 2 -> <br>i) [00] - Original array: [00] or [11] <br>ii) [01] & [10] - Original array: Not exist <br>iii) [11] - Original array: [01] or [10]\\n\\nIt can be observed that \\'1\\' must exist in pairs for original array to exist.\\n\\n# Approach\\nJust iterate over array to find occurences of \\'1\\' in array.Return true if even ; else false.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size(); \\n        \\n        int ones = 0;\\n        for(int i=0;i<n;i++){\\n            if(derived[i] == 1) ones++;\\n        }\\n        if(ones%2 == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size(); \\n        \\n        int ones = 0;\\n        for(int i=0;i<n;i++){\\n            if(derived[i] == 1) ones++;\\n        }\\n        if(ones%2 == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524050,
                "title": "simplest-proof-xor-of-general-derived-array-even-parity-checking-for-0-1-derived-array",
                "content": "Let original array be:\\n[A, B, C, D, E, F]\\nthen derived array will be:\\n[A\\u2295B, B\\u2295C, C\\u2295D, D\\u2295E, E\\u2295F, F\\u2295A]\\nnow, if you take xor of all the elements in derived array, it will be:\\nA\\u2295B \\u2295 B\\u2295C \\u2295 C\\u2295D \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A = 0\\nas all the elements are appears twice (and  A\\u2295A = 0)\\n......................................................................................\\nor if not convinced with twice argument, you can follow the operations \\nA\\u2295B \\u2295 B\\u2295C \\u2295 C\\u2295D \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A as:\\n**A\\u2295B \\u2295 B\\u2295C** \\u2295 C\\u2295D \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A = **A\\u2295C** \\u2295 C\\u2295D \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A\\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&nbsp;**A\\u2295C \\u2295 C\\u2295D** \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A = **A\\u2295D** \\u2295 D\\u2295E \\u2295 E\\u2295F \\u2295 F\\u2295A \\n-> follow this chain to arrive to **A\\u2295A** = 0\\n......................................................................................\\nthis result is **general** and doesn\\'t limit our derived array to be 0 1 only and would work on any **input array**.\\nIf derived array is only 0 1 as in our case, as an **alternate solution**, we can just count number of 1\\'s, which should be even\\nas it is the special case of our xor result. Even number of 1\\'s will cancel out each other while taking xor.\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x = 0;\\n        for(int y: derived) x ^= y;\\n        return x == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x = 0;\\n        for(int y: derived) x ^= y;\\n        return x == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523382,
                "title": "c-solution",
                "content": "# Code\\n```\\nbool doesValidArrayExist(int* derived, int derivedSize){\\n    int res=0;\\n    for(int i=0;i<derivedSize;i++){\\n        res^=derived[i];\\n    }\\n    return res==0?true:false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool doesValidArrayExist(int* derived, int derivedSize){\\n    int res=0;\\n    for(int i=0;i<derivedSize;i++){\\n        res^=derived[i];\\n    }\\n    return res==0?true:false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523220,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return sum(derived)%2==0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return sum(derived)%2==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523033,
                "title": "java-straight-forward",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int startWith0 = 0, startWith1 = 1;\\n\\n        for(int n : derived) {\\n            startWith0 ^= n;\\n            startWith1 ^= n;\\n        }\\n\\n        return startWith0 == 0 || startWith1 == 1 ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int startWith0 = 0, startWith1 = 1;\\n\\n        for(int n : derived) {\\n            startWith0 ^= n;\\n            startWith1 ^= n;\\n        }\\n\\n        return startWith0 == 0 || startWith1 == 1 ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523031,
                "title": "c-simplest-solution-on-leetcode",
                "content": "# Please dont forget to UPVOTE\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        if(n==1 && derived[0]==0) return true;\\n        else if(n==1) return false;\\n\\n        vector<int> orignal(n,0);\\n        orignal[0]=0;\\n        orignal[1]=derived[0];\\n\\n        for(int i=2;i<n;i++) orignal[i]=orignal[i-1]^derived[i-1];\\n\\n        if(orignal[n-1]^0==derived[n-1]) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n# Please dont forget to UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        if(n==1 && derived[0]==0) return true;\\n        else if(n==1) return false;\\n\\n        vector<int> orignal(n,0);\\n        orignal[0]=0;\\n        orignal[1]=derived[0];\\n\\n        for(int i=2;i<n;i++) orignal[i]=orignal[i-1]^derived[i-1];\\n\\n        if(orignal[n-1]^0==derived[n-1]) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522919,
                "title": "generate-possible-2-array-combination-check-if-its-valid-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int[] start0 = new int[derived.length];\\n        int[] start1 = new int[derived.length];\\n        start0[0] = 0; start1[0]=1;\\n        for(int i=0;i<derived.length-1;i++){\\n            if(derived[i]==1){\\n                start0[i+1] = start0[i]==0?1:0;\\n                start1[i+1] = start1[i]==0?1:0;\\n            }else{\\n                start0[i+1] = start0[i];\\n                start1[i+1] = start1[i];\\n            }\\n        }\\n        // System.out.println(Arrays.toString(start0));\\n        // System.out.println(Arrays.toString(start1));\\n        if(derived[derived.length-1]==0){\\n            return start0[0]==start0[start0.length-1] || start1[0]==start1[start1.length-1];\\n        }else{\\n            return start0[0]!=start0[start0.length-1] || start1[0]!=start1[start1.length-1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int[] start0 = new int[derived.length];\\n        int[] start1 = new int[derived.length];\\n        start0[0] = 0; start1[0]=1;\\n        for(int i=0;i<derived.length-1;i++){\\n            if(derived[i]==1){\\n                start0[i+1] = start0[i]==0?1:0;\\n                start1[i+1] = start1[i]==0?1:0;\\n            }else{\\n                start0[i+1] = start0[i];\\n                start1[i+1] = start1[i];\\n            }\\n        }\\n        // System.out.println(Arrays.toString(start0));\\n        // System.out.println(Arrays.toString(start1));\\n        if(derived[derived.length-1]==0){\\n            return start0[0]==start0[start0.length-1] || start1[0]==start1[start1.length-1];\\n        }else{\\n            return start0[0]!=start0[start0.length-1] || start1[0]!=start1[start1.length-1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522629,
                "title": "c-easy-solution-beats-100",
                "content": "# Intuition\\nIf Xor of all element is 1 then its not possible else it is possible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N);\\n- Space complexity:O(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int ans=0;\\n        for(auto &x:d)\\n        {\\n            ans^=x;\\n        }\\n        return ans?false:true;\\n    }\\n};\\n```\\n![7dr99c.jpg](https://assets.leetcode.com/users/images/265dddef-a8d3-439d-a352-a92153ef5f5c_1684044579.1847186.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int ans=0;\\n        for(auto &x:d)\\n        {\\n            ans^=x;\\n        }\\n        return ans?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522575,
                "title": "all-four-solutions-cpp-easy-to-understand",
                "content": "# 1. Finding Losers of the circular game\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_map<int, int> m;\\n        for(int i = 0, j = 1; ; ++j){\\n            if(m[i]) break;\\n            m[i]++;\\n            int x = j*k;\\n            while(x){\\n                i++;\\n                if(i == n) i = i-n;\\n                x--;\\n            }\\n        }\\n        vector<int> v;\\n        for(int i = 0; i<n; ++i){\\n            if(!m[i]) v.push_back(i+1);\\n        }\\n        return v;\\n    }\\n};\\n```\\n# 2. Neighboring Bitwise XOR\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int res = 0;\\n        for(int i = 0; i<d.size(); ++i){\\n            res ^= d[i];\\n        }\\n        return res ? false: true;\\n    }\\n};\\n```\\n# 3. Minimum number of moves in a grid\\n```\\nclass Solution {\\npublic:\\n    vector<int> I = {-1, 0, 1};\\n    vector<int> J = {1, 1, 1};\\n    int res = 0;\\n    int dfs(vector<vector<int>>& grid, vector<vector<int>>& dp, vector<vector<int>>& v, int i, int j){\\n        if(dp[i][j] != -1) return dp[i][j];\\n        v[i][j] = 1;\\n        cout<<grid[i][j]<<\" \";\\n        for(int k = 0; k<3; ++k){\\n            int newI = i + I[k];\\n            int newJ = j + J[k];\\n            int ans = 0;\\n            if(newI >= 0 && newJ >=0 && newI < grid.size() && newJ <grid[0].size()){\\n                if(dp[newI][newJ] == -1 && !v[newI][newJ] && grid[i][j] < grid[newI][newJ]){\\n                    ans = 1+dfs(grid, dp, v, newI, newJ);\\n                }\\n                dp[i][j] = max(ans, dp[i][j]);\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        return dp[i][j] == -1 ? 0:dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<1; ++j){\\n                if(dp[i][j] == -1)\\n                    dfs(grid, dp, v, i, j);\\n            }\\n        }\\n        int ans = res;\\n        res = 0;\\n        return ans;\\n    }\\n};\\n```\\n# 4. Count the Number of Complete Components\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int i, vector<vector<int>>& m, vector<int>& v, vector<int>& res){\\n        if(!v[i]){\\n            res.push_back(i);\\n            v[i] = 1;\\n            for(int x: adj[i]) dfs(adj, x, m, v, res);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> a[n];\\n        map<pair<int,int>, int> t;\\n        for(auto x: e){\\n            a[x[0]].push_back(x[1]);\\n            a[x[1]].push_back(x[0]);\\n            t[{x[0], x[1]}]++;\\n            t[{x[1], x[0]}]++;\\n        }\\n        vector<vector<int>> m;\\n        vector<int> v(n);\\n        for(int i = 0; i<n; ++i){\\n            vector<int> res;\\n            if(!v[i]){\\n                dfs(a, i, m, v, res);\\n                m.push_back(res);\\n            }\\n        }\\n        int cnt = m.size(), f = 0;\\n        for(auto x: m){\\n            for(int i = 0; i<x.size(); ++i){\\n                for(int j = i+1; j<x.size(); ++j){\\n                    if(!t[{x[i], x[j]}]){\\n                        cnt--;\\n                        f = 1;\\n                        break;\\n                    }\\n                }\\n                if(f){\\n                    f = 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_map<int, int> m;\\n        for(int i = 0, j = 1; ; ++j){\\n            if(m[i]) break;\\n            m[i]++;\\n            int x = j*k;\\n            while(x){\\n                i++;\\n                if(i == n) i = i-n;\\n                x--;\\n            }\\n        }\\n        vector<int> v;\\n        for(int i = 0; i<n; ++i){\\n            if(!m[i]) v.push_back(i+1);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int res = 0;\\n        for(int i = 0; i<d.size(); ++i){\\n            res ^= d[i];\\n        }\\n        return res ? false: true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> I = {-1, 0, 1};\\n    vector<int> J = {1, 1, 1};\\n    int res = 0;\\n    int dfs(vector<vector<int>>& grid, vector<vector<int>>& dp, vector<vector<int>>& v, int i, int j){\\n        if(dp[i][j] != -1) return dp[i][j];\\n        v[i][j] = 1;\\n        cout<<grid[i][j]<<\" \";\\n        for(int k = 0; k<3; ++k){\\n            int newI = i + I[k];\\n            int newJ = j + J[k];\\n            int ans = 0;\\n            if(newI >= 0 && newJ >=0 && newI < grid.size() && newJ <grid[0].size()){\\n                if(dp[newI][newJ] == -1 && !v[newI][newJ] && grid[i][j] < grid[newI][newJ]){\\n                    ans = 1+dfs(grid, dp, v, newI, newJ);\\n                }\\n                dp[i][j] = max(ans, dp[i][j]);\\n                res = max(res, dp[i][j]);\\n            }\\n        }\\n        return dp[i][j] == -1 ? 0:dp[i][j];\\n    }\\n    int maxMoves(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m,-1));\\n        vector<vector<int>> v(n, vector<int>(m, 0));\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<1; ++j){\\n                if(dp[i][j] == -1)\\n                    dfs(grid, dp, v, i, j);\\n            }\\n        }\\n        int ans = res;\\n        res = 0;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> adj[], int i, vector<vector<int>>& m, vector<int>& v, vector<int>& res){\\n        if(!v[i]){\\n            res.push_back(i);\\n            v[i] = 1;\\n            for(int x: adj[i]) dfs(adj, x, m, v, res);\\n        }\\n    }\\n    int countCompleteComponents(int n, vector<vector<int>>& e) {\\n        vector<int> a[n];\\n        map<pair<int,int>, int> t;\\n        for(auto x: e){\\n            a[x[0]].push_back(x[1]);\\n            a[x[1]].push_back(x[0]);\\n            t[{x[0], x[1]}]++;\\n            t[{x[1], x[0]}]++;\\n        }\\n        vector<vector<int>> m;\\n        vector<int> v(n);\\n        for(int i = 0; i<n; ++i){\\n            vector<int> res;\\n            if(!v[i]){\\n                dfs(a, i, m, v, res);\\n                m.push_back(res);\\n            }\\n        }\\n        int cnt = m.size(), f = 0;\\n        for(auto x: m){\\n            for(int i = 0; i<x.size(); ++i){\\n                for(int j = i+1; j<x.size(); ++j){\\n                    if(!t[{x[i], x[j]}]){\\n                        cnt--;\\n                        f = 1;\\n                        break;\\n                    }\\n                }\\n                if(f){\\n                    f = 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3522558,
                "title": "only-count-no-of-1s-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++){\\n            if(derived[i]==1) count++;\\n        }\\n\\n        if(count%2==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++){\\n            if(derived[i]==1) count++;\\n        }\\n\\n        if(count%2==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522417,
                "title": "very-very-easy-solution-using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = derived[0];\\n        for(int i = 1; i < derived.size(); i++) {\\n            ans = ans xor derived[i];\\n        }\\n        if(ans == 0) {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = derived[0];\\n        for(int i = 1; i < derived.size(); i++) {\\n            ans = ans xor derived[i];\\n        }\\n        if(ans == 0) {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522333,
                "title": "c-best-solution-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int a=0, b=1, n=derived.size();\\n        for(int i=0; i<n-1; i++) a ^= derived[i], b ^= derived[i];\\n        return (a^0 == derived[n-1] || b^1 == derived[n-1]);\\n    }\\n};\\n```\\n\\n# Approach-2\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=1;\\n        for(auto it : derived) x ^= it;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int a=0, b=1, n=derived.size();\\n        for(int i=0; i<n-1; i++) a ^= derived[i], b ^= derived[i];\\n        return (a^0 == derived[n-1] || b^1 == derived[n-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=1;\\n        for(auto it : derived) x ^= it;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522332,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        vector<int>v(d.size(), 0);\\n        int n=d.size();\\n        int o=0, z=0;\\n        for(int i=0; i<n; i++){\\n            if(d[i]){\\n                if(i==n-1){\\n                    if(v[(i+1)%n]==v[i]){\\n                        return false;\\n                    }\\n                    else{return true;}\\n                }\\n                else{v[(i+1)%n]=!v[i];}\\n            }\\n            else{\\n                if(i==n-1){\\n                    if(v[(i+1)%n]!=v[i]){\\n                        return false;\\n                    }\\n                    else{\\n                        return true;\\n                    }\\n                }\\n                else{\\n                    v[(i+1)%n]=v[i];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        vector<int>v(d.size(), 0);\\n        int n=d.size();\\n        int o=0, z=0;\\n        for(int i=0; i<n; i++){\\n            if(d[i]){\\n                if(i==n-1){\\n                    if(v[(i+1)%n]==v[i]){\\n                        return false;\\n                    }\\n                    else{return true;}\\n                }\\n                else{v[(i+1)%n]=!v[i];}\\n            }\\n            else{\\n                if(i==n-1){\\n                    if(v[(i+1)%n]!=v[i]){\\n                        return false;\\n                    }\\n                    else{\\n                        return true;\\n                    }\\n                }\\n                else{\\n                    v[(i+1)%n]=v[i];\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522324,
                "title": "c-3-lines-detailed-explanation-count-1-s",
                "content": "**Explaination**\\nlet us find derived array of all the binary numbers of size \\n\\n* original = [0] -> derived = [0]\\n* original = [1] -> derived = [0]\\n\\npossible derives are:\\n* [0]\\n\\nderived was only possible for number of bits equal to **0**\\n\\n----------------------------------\\n* original = [0,0] -> derived = [0,0]\\n* original = [0,1] -> derived = [1,1]\\n* original = [1,0] -> derived = [1.1]\\n* original = [1,1] -> derived = [0,0]\\n\\npossible derives are:\\n* [0,0]\\n* [1,1]\\n\\nderived was only possible for number of bits equal to **0,2**\\n\\n ----------------------------------\\n* original = [0,0,0] -> derived = [0,0,0]\\n* original = [0,0,1] -> derived = [0,1,1]\\n* original = [0,1,0] -> derived = [1,1,0]\\n* original = [0,1,1] -> derived = [1,0,1]\\n* original = [1,0,0] -> derived = [1.0,1]\\n* original = [1,0,1] -> derived = [1.1,0]\\n* original = [1,1,0] -> derived = [0,1,1]\\n* original = [1,1,1] -> derived = [0,0,0]\\n\\n\\npossible derives are:\\n* [0,0,0]\\n* [0,1,1]\\n* [1,0,1]\\n* [1,1,0]\\n\\nderived was only possible for number of bits equal to **0,2**\\n\\n ----------------------------------\\n* original = [0,0,0,0] -> derived = [0,0,0,0]\\n* original = [0,0,0,1] -> derived = [0,0,1,1]\\n* original = [0,0,1,0] -> derived = [0,1,1,0]\\n* original = [0,0,1,1] -> derived = [0,1,0,1]\\n* original = [0,1,0,0] -> derived = [1,1,0,0]\\n* original = [0,1,0,1] -> derived = [1,1,1,1]\\n* original = [0,1,1,0] -> derived = [1,0,1,0]\\n* original = [0,1,1,1] -> derived = [1,0,0,1]\\n* original = [1,0,0,0] -> derived = [1.0,0,1]\\n* original = [1,0,0,1] -> derived = [1.0,1,0]\\n* original = [1,0,1,0] -> derived = [1.1,1,1]\\n* original = [1,0,1,1] -> derived = [1.1,0,0]\\n* original = [1,1,0,0] -> derived = [0,1,0,1]\\n* original = [1,1,0,1] -> derived = [0,1,1,0]\\n* original = [1,1,1,0] -> derived = [0,0,1,1]\\n* original = [1,1,1,1] -> derived = [0,0,0,0]\\n\\n\\n\\npossible derives are:\\n* [0,0,0,0]\\n* [0,0,1,1]\\n* [0,1,0,1]\\n* [0,1,1,0]\\n* [1,0,0,1]\\n* [1,0,1,0]\\n* [1,1,0,0]\\n* [1,1,1,1]\\n\\nderived was only possible for number of bits equal to **0,2,4**\\n\\n-------------------------------\\n\\nHence the original is possible only for sum of bits being even\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count = 0;\\n        \\n        for(auto it: derived) count+=it;\\n        \\n        return count%2==0;\\n    }\\n};\\n```\\nTime Complexity - *O(N)*\\nSpace Complexity - *O(N)*\\n\\nIf you found this solution helpful, please consider upvoting.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count = 0;\\n        \\n        for(auto it: derived) count+=it;\\n        \\n        return count%2==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522295,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& arr) {\\n        vector<int>first;\\n        if(arr.size() == 1  ){\\n             if(arr[0] == 1) return false;\\n             else return true;\\n        }       \\n        \\n       if(arr[0] == 1){\\n               first.push_back(0);\\n               first.push_back(1);\\n        }\\n        else {\\n               first.push_back(0);\\n               first.push_back(0);\\n        }\\n        for(int i = 1 ;i<arr.size();i++){\\n              \\n              if( i == arr.size() - 1){\\n                  bool flag1 = false;\\n                  if((first[0]^first[i]) == arr[i] ) return true;\\n                  else return false;\\n                  \\n              }\\n              else if( arr[i] == 1){\\n\\n                  if((first[i]^0) == arr[i] ) first.push_back(0);\\n                  else if((first[i]^1) == arr[i] ) first.push_back(1);\\n                  else return false;\\n                  \\n              }\\n             else {\\n                  if((first[i]^0) == arr[i] ) first.push_back(0);\\n                  else if((first[i]^1 )== arr[i] ) first.push_back(1);\\n                  else return false;\\n            }\\n\\n         }\\n                    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& arr) {\\n        vector<int>first;\\n        if(arr.size() == 1  ){\\n             if(arr[0] == 1) return false;\\n             else return true;\\n        }       \\n        \\n       if(arr[0] == 1){\\n               first.push_back(0);\\n               first.push_back(1);\\n        }\\n        else {\\n               first.push_back(0);\\n               first.push_back(0);\\n        }\\n        for(int i = 1 ;i<arr.size();i++){\\n              \\n              if( i == arr.size() - 1){\\n                  bool flag1 = false;\\n                  if((first[0]^first[i]) == arr[i] ) return true;\\n                  else return false;\\n                  \\n              }\\n              else if( arr[i] == 1){\\n\\n                  if((first[i]^0) == arr[i] ) first.push_back(0);\\n                  else if((first[i]^1) == arr[i] ) first.push_back(1);\\n                  else return false;\\n                  \\n              }\\n             else {\\n                  if((first[i]^0) == arr[i] ) first.push_back(0);\\n                  else if((first[i]^1 )== arr[i] ) first.push_back(1);\\n                  else return false;\\n            }\\n\\n         }\\n                    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522265,
                "title": "c-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& der) {\\n        vector<int> org(der.size());\\n        for(int i = 0; i < der.size() - 1; i++) {\\n            if(i == 0) {\\n                if(der[i] == 1) {\\n                    org[i] = 0;\\n                    org[i + 1] = 1;\\n                }\\n            }\\n            else {\\n                if(der[i] == 1) {\\n                    if(org[i] == 0) org[i + 1] = 1;\\n                    else org[i + 1] = 0;\\n                }\\n                else {\\n                    if(org[i] == 1) org[i + 1] = 1;\\n                    else org[i + 1] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < org.size(); i++) {\\n            if((i < org.size() - 1) && (org[i] ^ org[i + 1] != der[i])) return false;\\n            else if(i == org.size() - 1 && (org[i] ^ org[0] != der[i])) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& der) {\\n        vector<int> org(der.size());\\n        for(int i = 0; i < der.size() - 1; i++) {\\n            if(i == 0) {\\n                if(der[i] == 1) {\\n                    org[i] = 0;\\n                    org[i + 1] = 1;\\n                }\\n            }\\n            else {\\n                if(der[i] == 1) {\\n                    if(org[i] == 0) org[i + 1] = 1;\\n                    else org[i + 1] = 0;\\n                }\\n                else {\\n                    if(org[i] == 1) org[i + 1] = 1;\\n                    else org[i + 1] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < org.size(); i++) {\\n            if((i < org.size() - 1) && (org[i] ^ org[i + 1] != der[i])) return false;\\n            else if(i == org.size() - 1 && (org[i] ^ org[0] != der[i])) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522090,
                "title": "javascript-greedy-two-conditions-244ms",
                "content": "Main idea:\\n(1) original array only start with either 0 or 1\\n(2) how to build original array: xor formula\\n     derived[i] = original[i] ^ original[i + 1]\\n   => original[i + 1] = derived[i] ^ original[i]\\n```\\nconst aeq = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\\n\\nconst doesValidArrayExist = (a) => {\\n    let n = a.length;\\n    let b = Array(n).fill(-1), b2 = Array(n).fill(-1); // (1) build orginal array\\n    b[0] = 0;\\n    b2[0] = 1;\\n    go(a, b)\\n    if (aeq(test(b), a)) return true;\\n    go(a, b2);\\n    if (aeq(test(b2), a)) return true;\\n    return false;\\n};\\n\\nconst go = (a, b) => {\\n    let n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        if (i == n - 1) {\\n            b[i] = a[i] ^ b[0];\\n        } else {\\n            // a[i] = b[i] ^ b[i+1]\\n            b[i + 1] = a[i] ^ b[i]; // (2)\\n        }\\n    }\\n};\\n\\nconst test = (a) => {\\n    let n = a.length, res = Array(n).fill(-1);\\n    for (let i = 0; i + 1 < n; i++) res[i] = a[i] ^ a[i + 1];\\n    res[n - 1] = a[n - 1] ^ a[0];\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst aeq = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\\n\\nconst doesValidArrayExist = (a) => {\\n    let n = a.length;\\n    let b = Array(n).fill(-1), b2 = Array(n).fill(-1); // (1) build orginal array\\n    b[0] = 0;\\n    b2[0] = 1;\\n    go(a, b)\\n    if (aeq(test(b), a)) return true;\\n    go(a, b2);\\n    if (aeq(test(b2), a)) return true;\\n    return false;\\n};\\n\\nconst go = (a, b) => {\\n    let n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        if (i == n - 1) {\\n            b[i] = a[i] ^ b[0];\\n        } else {\\n            // a[i] = b[i] ^ b[i+1]\\n            b[i + 1] = a[i] ^ b[i]; // (2)\\n        }\\n    }\\n};\\n\\nconst test = (a) => {\\n    let n = a.length, res = Array(n).fill(-1);\\n    for (let i = 0; i + 1 < n; i++) res[i] = a[i] ^ a[i + 1];\\n    res[n - 1] = a[n - 1] ^ a[0];\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522077,
                "title": "easy-java-solution-100-faster-0ms",
                "content": "- Time complexity: O(n)\\n\\n- Space complexity: (1)\\n\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n    int sum=0;\\n    for(int num:derived)\\n    {\\n        sum+=num;\\n    }\\n    return sum%2==0?true:false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n    int sum=0;\\n    for(int num:derived)\\n    {\\n        sum+=num;\\n    }\\n    return sum%2==0?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522045,
                "title": "easy-simple-recursion-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        //first element can be 0 or 1\\n        return buildArray(derived,0,0,0) || buildArray(derived,0,1,1);\\n    }\\n    \\n    public boolean buildArray(int[] derived,int index,int currValue,int startValue){\\n        //for last index, check if it\\'s xor with first element matches with last element of derived array\\n        if(index==derived.length-1){\\n            if(derived[derived.length-1]==(startValue^currValue)){\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        int zero=0,one=1;\\n        //check for next element if it\\'s xor with currentElement matches element of derived array\\n         if(((currValue^0)==1 && derived[index]==1) || ((currValue^0)==0 && derived[index]==0)){\\n            if(buildArray(derived,index+1,0,startValue)){\\n                return true;\\n            }\\n        }\\n        if(((currValue^1)==1 && derived[index]==1) || ((currValue^1)==0 && derived[index]==0)){\\n            if(buildArray(derived,index+1,1,startValue)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        //first element can be 0 or 1\\n        return buildArray(derived,0,0,0) || buildArray(derived,0,1,1);\\n    }\\n    \\n    public boolean buildArray(int[] derived,int index,int currValue,int startValue){\\n        //for last index, check if it\\'s xor with first element matches with last element of derived array\\n        if(index==derived.length-1){\\n            if(derived[derived.length-1]==(startValue^currValue)){\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        int zero=0,one=1;\\n        //check for next element if it\\'s xor with currentElement matches element of derived array\\n         if(((currValue^0)==1 && derived[index]==1) || ((currValue^0)==0 && derived[index]==0)){\\n            if(buildArray(derived,index+1,0,startValue)){\\n                return true;\\n            }\\n        }\\n        if(((currValue^1)==1 && derived[index]==1) || ((currValue^1)==0 && derived[index]==0)){\\n            if(buildArray(derived,index+1,1,startValue)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521911,
                "title": "6431-neighboring-bitwise-xor-java-easy-peesy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int result=0;\\n        for(int e:derived){ result=result^e;} return result == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int result=0;\\n        for(int e:derived){ result=result^e;} return result == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521892,
                "title": "easy-java-solution-2-approaches",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int count=0;\\n        for(int i=0;i<derived.length;i++){\\n            if(derived[i]==1) count++;\\n        }\\n        return count%2==0;\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(int val : derived) xor ^= val;\\n        return xor == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int count=0;\\n        for(int i=0;i<derived.length;i++){\\n            if(derived[i]==1) count++;\\n        }\\n        return count%2==0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(int val : derived) xor ^= val;\\n        return xor == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082296,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& nums) {\\n        int s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s=s^nums[i];\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n        int k=s^nums[i];\\n           if(k!=nums[i])\\n           {\\n               return false;\\n           }\\n       }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& nums) {\\n        int s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s=s^nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4065527,
                "title": "ruby-1-liner",
                "content": "```ruby\\n# @param {Integer[]} derived\\n# @return {Boolean}\\ndef does_valid_array_exist(derived)\\n  derived.inject(:^) == 0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} derived\\n# @return {Boolean}\\ndef does_valid_array_exist(derived)\\n  derived.inject(:^) == 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4065492,
                "title": "python-1-liner",
                "content": "```python\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return not list(itertools.accumulate(derived, func=lambda a, b: a ^ b))[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return not list(itertools.accumulate(derived, func=lambda a, b: a ^ b))[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026180,
                "title": "simple-solution-with-explanation-java-neighboring-bitwise-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n=> In the derived array, each element is the XOR of the two elements that from the original array. \\n\\n=> So, if there exists an original array such that the derived array is formed by XORing consecutive elements of the original array, then the XOR of all the elements in the derived array must be 0.\\n\\n=> Because the xor of same element return 0 and by the description we can say that the every element of the original array exists two times in the derived array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n=> Let\\'s say we have an original array `arr` with the following elements:\\n\\n```\\narr = [1, 2, 3]\\n```\\n\\n=> The derived array `der` is formed by XORing consecutive elements of `arr`. So, the elements of `der` are:\\n\\n```\\nder = [1 ^ 2, 2 ^ 3, 3 ^ 1]\\n```\\n\\n=> The XOR of all the elements in `der` is 0:\\n\\n```\\n1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 1 = 0\\n```\\n\\n=> This means that all the elements in `der` are equal to each other. In this case, all the elements in `der` are equal to 0.\\n\\n=> So, we can see that if the XOR of all the elements in a derived array is 0, then all the elements in the derived array must be equal to each other.\\n\\n=> Now, let\\'s say there is no original array `arr` such that `der` is formed by XORing consecutive elements of `arr`. This means that the elements of `der` are not all equal to each other.\\n\\n=> But the XOR of all the elements in `der` is 0. This is a contradiction, because the XOR of two different numbers is never 0.\\n\\n=> Therefore, our assumption must be wrong. There must exist an original array `arr` such that `der` is formed by XORing consecutive \\nelements of `arr`.\\n\\n![Screenshot 2023-09-10 133650.png](https://assets.leetcode.com/users/images/4a7ac1ea-4aa5-41c3-a210-87d65a71ff1e_1694337411.0975177.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        int x = 0;\\n        for(int i : d)\\n        {\\n            x ^= i;\\n        }\\n        return x==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\narr = [1, 2, 3]\\n```\n```\\nder = [1 ^ 2, 2 ^ 3, 3 ^ 1]\\n```\n```\\n1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 1 = 0\\n```\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        int x = 0;\\n        for(int i : d)\\n        {\\n            x ^= i;\\n        }\\n        return x==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018931,
                "title": "java-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        if(derived.length == 1 ) {\\n            if(derived[0] == 1)\\n            return false;\\n            else return true;\\n        } \\n       \\n        if(derived[0] == 1) {\\n            // there are two cases in this also\\n            if(solve(new StringBuilder(\"01\"),derived) || solve(new StringBuilder(\"10\"),derived)) {\\n                return true;\\n            }\\n            \\n        } else {\\n            if(solve(new StringBuilder(\"00\"),derived) || solve(new StringBuilder(\"11\"),derived)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    boolean solve(StringBuilder s , int[] derived) {\\n         if(s.length() == derived.length) {\\n             if((Integer.parseInt(\"\" + s.charAt(1 % derived.length)) ^\\n             Integer.parseInt(\"\" + s.charAt(0))) == derived[derived.length-1])  {\\n                    return true;\\n             }\\n              \\n              else {\\n                 return false;\\n             }\\n\\n    }\\n    \\n         \\n\\n        for(int i = 1 ; i < derived.length - 1 ;i++) {\\n\\n           \\n\\n            if(derived[i] == 1) {\\n                if(s.charAt(i) == \\'0\\') {\\n                    s = s.append(\"1\");\\n                } else {\\n                    s = s.append(\"0\");\\n                }\\n            } else {\\n                 if(s.charAt(i) == \\'0\\') {\\n                    s = s.append(\"0\");\\n                } else {\\n                 s = s.append(\"1\");\\n                }\\n            }\\n        }\\n        // System.out.println(s);\\n     if((Integer.parseInt(\"\" + s.charAt(s.length()-1)) ^\\n             Integer.parseInt(\"\" + s.charAt(0))) == derived[derived.length-1]) {\\n                 return true;\\n             } else {\\n                 return false;\\n             }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        if(derived.length == 1 ) {\\n            if(derived[0] == 1)\\n            return false;\\n            else return true;\\n        } \\n       \\n        if(derived[0] == 1) {\\n            // there are two cases in this also\\n            if(solve(new StringBuilder(\"01\"),derived) || solve(new StringBuilder(\"10\"),derived)) {\\n                return true;\\n            }\\n            \\n        } else {\\n            if(solve(new StringBuilder(\"00\"),derived) || solve(new StringBuilder(\"11\"),derived)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    boolean solve(StringBuilder s , int[] derived) {\\n         if(s.length() == derived.length) {\\n             if((Integer.parseInt(\"\" + s.charAt(1 % derived.length)) ^\\n             Integer.parseInt(\"\" + s.charAt(0))) == derived[derived.length-1])  {\\n                    return true;\\n             }\\n              \\n              else {\\n                 return false;\\n             }\\n\\n    }\\n    \\n         \\n\\n        for(int i = 1 ; i < derived.length - 1 ;i++) {\\n\\n           \\n\\n            if(derived[i] == 1) {\\n                if(s.charAt(i) == \\'0\\') {\\n                    s = s.append(\"1\");\\n                } else {\\n                    s = s.append(\"0\");\\n                }\\n            } else {\\n                 if(s.charAt(i) == \\'0\\') {\\n                    s = s.append(\"0\");\\n                } else {\\n                 s = s.append(\"1\");\\n                }\\n            }\\n        }\\n        // System.out.println(s);\\n     if((Integer.parseInt(\"\" + s.charAt(s.length()-1)) ^\\n             Integer.parseInt(\"\" + s.charAt(0))) == derived[derived.length-1]) {\\n                 return true;\\n             } else {\\n                 return false;\\n             }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002661,
                "title": "simply-count-1-s-and-0-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n        for(int i=0;i<derived.size();i++){\\n            x^=derived[i];\\n        }\\n        return (x==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n        for(int i=0;i<derived.size();i++){\\n            x^=derived[i];\\n        }\\n        return (x==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944373,
                "title": "java-iterative-resursive",
                "content": "# Intuition \\nwe can have 2 possiblities for start values of original array. \\n1. original array can start with 1\\n2. original array can start with zero\\n\\nsince every value of derived array is depends only only current value & next of original array, we can maintain 2 variables which stores current values original array at that index. \\n\\nand based on derived value of at that index , we can alter those 2 pointers. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N$$) // $$N$$ is the length of the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int N = derived.length; \\n        \\n        int currentValueWhenOriginalStartsWithOne = 1;\\n        int currentValueWhenOriginalStartsWithZero = 0; \\n\\n        for(int index = 0; index < N-1 ;index++){\\n            if(derived[index] == 1){\\n                currentValueWhenOriginalStartsWithOne = currentValueWhenOriginalStartsWithOne == 1 ? 0 : 1; \\n                currentValueWhenOriginalStartsWithZero = currentValueWhenOriginalStartsWithZero == 1 ? 0 : 1; \\n            }\\n        }\\n\\n        if(derived[N-1] == 1){\\n            return (currentValueWhenOriginalStartsWithOne == 0) || (currentValueWhenOriginalStartsWithZero == 1);\\n        }else\\n            return (currentValueWhenOriginalStartsWithOne == 1) || (currentValueWhenOriginalStartsWithZero == 0);  \\n    }\\n}\\n\\nclass SolutionRecursive {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        return solve(derived, 0, 1, 1) \\n             || solve(derived, 0, 0, 0);\\n    }\\n\\n    public boolean solve(int[] derived, int index, int first, int current){\\n        if(index == derived.length-1){\\n            if(derived[index]==1){\\n                return (current==1 && first==0) || (current==0 && first==1);\\n            }else{\\n                return (current==0 && first==0) || (current==1 && first==1);\\n            }\\n        }\\n        if(derived[index] == 1){\\n            return solve(derived, index+1, first, current == 1 ? 0 : 1);\\n        }else{\\n            return solve(derived, index+1, first, current);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int N = derived.length; \\n        \\n        int currentValueWhenOriginalStartsWithOne = 1;\\n        int currentValueWhenOriginalStartsWithZero = 0; \\n\\n        for(int index = 0; index < N-1 ;index++){\\n            if(derived[index] == 1){\\n                currentValueWhenOriginalStartsWithOne = currentValueWhenOriginalStartsWithOne == 1 ? 0 : 1; \\n                currentValueWhenOriginalStartsWithZero = currentValueWhenOriginalStartsWithZero == 1 ? 0 : 1; \\n            }\\n        }\\n\\n        if(derived[N-1] == 1){\\n            return (currentValueWhenOriginalStartsWithOne == 0) || (currentValueWhenOriginalStartsWithZero == 1);\\n        }else\\n            return (currentValueWhenOriginalStartsWithOne == 1) || (currentValueWhenOriginalStartsWithZero == 0);  \\n    }\\n}\\n\\nclass SolutionRecursive {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        return solve(derived, 0, 1, 1) \\n             || solve(derived, 0, 0, 0);\\n    }\\n\\n    public boolean solve(int[] derived, int index, int first, int current){\\n        if(index == derived.length-1){\\n            if(derived[index]==1){\\n                return (current==1 && first==0) || (current==0 && first==1);\\n            }else{\\n                return (current==0 && first==0) || (current==1 && first==1);\\n            }\\n        }\\n        if(derived[index] == 1){\\n            return solve(derived, index+1, first, current == 1 ? 0 : 1);\\n        }else{\\n            return solve(derived, index+1, first, current);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931794,
                "title": "soln-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) \\n    {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            if(derived[i]==1)\\n                count++;\\n        }\\n        if(count%2==0)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) \\n    {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            if(derived[i]==1)\\n                count++;\\n        }\\n        if(count%2==0)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906322,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool doesValidArrayExist(vector<int>& derived) {\\n    //      original = [O[0], O[1], ..., O[n - 1]]\\n    //       derived = [O[0]^O[1], O[1]^O[2], ..., O[n - 1]^O[0]]\\n    // XOR(derivedd) = 0\\n    return accumulate(derived.begin(), derived.end(), 0, bit_xor<>()) == 0;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool doesValidArrayExist(vector<int>& derived) {\\n    //      original = [O[0], O[1], ..., O[n - 1]]\\n    //       derived = [O[0]^O[1], O[1]^O[2], ..., O[n - 1]^O[0]]\\n    // XOR(derivedd) = 0\\n    return accumulate(derived.begin(), derived.end(), 0, bit_xor<>()) == 0;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893015,
                "title": "o-n-time-o-1-space-in-place-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n = derived.length;\\n        int prevBit = derived[0];\\n        //int[] original = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            int currentBit = derived[i];\\n            derived[i] = derived[i-1] ^ prevBit;\\n            prevBit = currentBit;\\n        }\\n        return (derived[n-1] ^ derived[0]) == prevBit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n = derived.length;\\n        int prevBit = derived[0];\\n        //int[] original = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            int currentBit = derived[i];\\n            derived[i] = derived[i-1] ^ prevBit;\\n            prevBit = currentBit;\\n        }\\n        return (derived[n-1] ^ derived[0]) == prevBit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890443,
                "title": "cpp-simple-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        if(d.size()==1){\\n            if(d[0]==0) return true;return false;\\n        }\\n        int a,b,x;\\n        if(d[0]==0){\\n            a=0;b=0;x=0;\\n        }\\n        else{\\n            a=1;b=0;x=1;\\n        }\\n        for(int i=1;i<d.size()-1;i++){\\n            if(d[i]==1){\\n                if(b==0){\\n                    a=b;b=1;\\n                }\\n                else{\\n                    a=b;\\n                    b=0;\\n                }\\n            }\\n            else{\\n                 if(b==0){\\n                    a=b;b=0;\\n                }\\n                else{\\n                    a=b;\\n                    b=1;\\n                }\\n            }\\n        }\\n        if(d[d.size()-1]==0){\\n            if((x==0&&b==0)||(x==1&&b==1)) return true;\\n            return false;\\n        }\\n        else{\\n            if((x==0&&b==1)||(x==1&&b==0)) return true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        if(d.size()==1){\\n            if(d[0]==0) return true;return false;\\n        }\\n        int a,b,x;\\n        if(d[0]==0){\\n            a=0;b=0;x=0;\\n        }\\n        else{\\n            a=1;b=0;x=1;\\n        }\\n        for(int i=1;i<d.size()-1;i++){\\n            if(d[i]==1){\\n                if(b==0){\\n                    a=b;b=1;\\n                }\\n                else{\\n                    a=b;\\n                    b=0;\\n                }\\n            }\\n            else{\\n                 if(b==0){\\n                    a=b;b=0;\\n                }\\n                else{\\n                    a=b;\\n                    b=1;\\n                }\\n            }\\n        }\\n        if(d[d.size()-1]==0){\\n            if((x==0&&b==0)||(x==1&&b==1)) return true;\\n            return false;\\n        }\\n        else{\\n            if((x==0&&b==1)||(x==1&&b==0)) return true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889059,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        vector<int>original(n + 1);\\n        for(int i = 0; i < n; i++){\\n            if(original[i] ^ 0 == derived[i]) original[i + 1] = 0;\\n            else original[i + 1] = 1;\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n            if(original[i] ^ original[i + 1] != derived[i]) return false;\\n        }\\n        return original[0] ^ original[n - 1] == derived[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        vector<int>original(n + 1);\\n        for(int i = 0; i < n; i++){\\n            if(original[i] ^ 0 == derived[i]) original[i + 1] = 0;\\n            else original[i + 1] = 1;\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n            if(original[i] ^ original[i + 1] != derived[i]) return false;\\n        }\\n        return original[0] ^ original[n - 1] == derived[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858582,
                "title": "o-n-solution-simplest-fastest-soln",
                "content": "# O(n) solution simplest & fastest soln\\nIf vector start with 1 derived[0] can be 1 or 0 both (1^0 = 1 1^1 = 0) so one soln will always start wit 1 another with 0 (if exist)\\n```\\n\\n\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int> derived) \\n    {\\n        vector<int> ans{1};\\n        for(int i=0;i<derived.size()-1;i++)\\n        if(derived[i]==0)\\n        ans.push_back(ans.back());\\n        else\\n        ans.push_back(!ans.back());\\n        \\n\\n        return ans.back()^ans[0]==derived.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int> derived) \\n    {\\n        vector<int> ans{1};\\n        for(int i=0;i<derived.size()-1;i++)\\n        if(derived[i]==0)\\n        ans.push_back(ans.back());\\n        else\\n        ans.push_back(!ans.back());\\n        \\n\\n        return ans.back()^ans[0]==derived.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842124,
                "title": "beats-98-59-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> ans1,ans2;\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        if(derived[0]==1)\\n        {\\n            ans1.push_back(0);\\n            ans1.push_back(1);\\n            ans2.push_back(1);\\n            ans2.push_back(0);\\n        }\\n        else\\n        {\\n            ans1.push_back(1);\\n            ans1.push_back(1);\\n            ans2.push_back(0);\\n            ans2.push_back(0);\\n        }\\n        for(int i=1;i<derived.size();i++)\\n        {\\n            int t = derived[i];\\n            if(t==1)\\n            {\\n                int val = (ans1.back()==1)?0:1;\\n                ans1.push_back(val);\\n                val = (ans2.back()==1)?0:1;\\n                ans2.push_back(val);\\n            }\\n            else\\n            {\\n                int val = (ans1.back()==1)?1:0;\\n                ans1.push_back(val);\\n                val = (ans2.back()==1)?1:0;\\n                ans2.push_back(val);\\n            }\\n        }\\n\\n        return ((ans1[0]==ans1[ans1.size()-1]) || (ans2[0]==ans2[ans2.size()-1]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> ans1,ans2;\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        if(derived[0]==1)\\n        {\\n            ans1.push_back(0);\\n            ans1.push_back(1);\\n            ans2.push_back(1);\\n            ans2.push_back(0);\\n        }\\n        else\\n        {\\n            ans1.push_back(1);\\n            ans1.push_back(1);\\n            ans2.push_back(0);\\n            ans2.push_back(0);\\n        }\\n        for(int i=1;i<derived.size();i++)\\n        {\\n            int t = derived[i];\\n            if(t==1)\\n            {\\n                int val = (ans1.back()==1)?0:1;\\n                ans1.push_back(val);\\n                val = (ans2.back()==1)?0:1;\\n                ans2.push_back(val);\\n            }\\n            else\\n            {\\n                int val = (ans1.back()==1)?1:0;\\n                ans1.push_back(val);\\n                val = (ans2.back()==1)?1:0;\\n                ans2.push_back(val);\\n            }\\n        }\\n\\n        return ((ans1[0]==ans1[ans1.size()-1]) || (ans2[0]==ans2[ans2.size()-1]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835466,
                "title": "easiest-sol-c",
                "content": "bhailog dekho simple approach hai dekho je yeh\\noriginal array hai usme har ek element 2 bar aa raha hai matlab uske sare elements ka xor 0 hoga \\nab hum derived element ka xor check kar lenge kua vo 0 hai to return 1\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto x:d)\\n            m^=x;\\n        if(m==0)return 1;\\n        else return 0;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto x:d)\\n            m^=x;\\n        if(m==0)return 1;\\n        else return 0;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815697,
                "title": "golang-bit-manipulation-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```go\\nfunc doesValidArrayExist(derived []int) bool {\\n\\torigin0 := make([]int, len(derived))\\n\\torigin1 := make([]int, len(derived))\\n\\torigin1[0] = 1\\n\\tfor i := 0; i < len(derived)-1; i++ {\\n\\t\\torigin0[i+1] = derived[i] ^ origin0[i]\\n\\t\\torigin1[i+1] = derived[i] ^ origin1[i]\\n\\t}\\n\\tif derived[len(derived)-1] == origin0[len(derived)-1] ^ origin0[0] {\\n\\t\\treturn true\\n\\t}\\n\\tif derived[len(derived)-1] == origin1[len(derived)-1] ^ origin1[0] {\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```go\\nfunc doesValidArrayExist(derived []int) bool {\\n\\torigin0 := make([]int, len(derived))\\n\\torigin1 := make([]int, len(derived))\\n\\torigin1[0] = 1\\n\\tfor i := 0; i < len(derived)-1; i++ {\\n\\t\\torigin0[i+1] = derived[i] ^ origin0[i]\\n\\t\\torigin1[i+1] = derived[i] ^ origin1[i]\\n\\t}\\n\\tif derived[len(derived)-1] == origin0[len(derived)-1] ^ origin0[0] {\\n\\t\\treturn true\\n\\t}\\n\\tif derived[len(derived)-1] == origin1[len(derived)-1] ^ origin1[0] {\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811597,
                "title": "c-solution-simple-intuitive-construct-a-plausible-original-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince the \\'derived\\' binary array is the result of an XOR operation we have information about the original vector. Every bit in the derived vector contains comparison information about the original vector:\\n> every 1 must be the result of (0 xor 1) or (1 xor 0), i.e. neighbors were different \\n> every 0 must be the result of (0 xor 0) or (1 xor 1), i.e. neighbors were the same\\n\\nExample:\\nderived = [1, 1, 0]\\n> original [0] != original [1]\\n> original [1] != original [2]\\n> original [2] == original [0]\\n\\nderived = [1, 1]\\n> original [0] != original [1]\\n> original [1] != original [0]\\n\\nderived = [1, 0]\\n> original [0] != original [1]\\n> original [1] == original [0]\\n>> a contradiction!!\\n\\nderived = [1, 0, 1]\\n> original [0] != original [1]\\n> original [1] == original [2]\\n> original [2] != original [0]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach isn\\'t the fastest, but constructs a pluasible original vector.\\n\\nWe start by initializing our original vector with 0, (it doesn\\'t matter if the original vector is initialized with a 0 or 1, since we only know the comparison information anyways.)\\n\\nThen, we iterate through the derived vector, and keep adding bits to the original vector:\\n\\nThe next bit to add to the original vector will be:\\n> The same as the last bit added if the derived vector is (0)\\n> The opposite as the last bit added if the derived vector is (1)\\n\\nFinally, to see if the original vector is valid we look at the last bit of comparison information in the derived vector, which compares the first and last bits. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int> original;\\n        original.push_back(0); // assume a starting bit\\n\\n        // add bits to original vector, based on the comparison information in the derived bit vector.\\n        // if a bit in the derived vector is::\\n        //                 \\'1\\' -> meaning the neighbor bits in the original were different\\n        //                 \\'0\\' -> meaning the neighbor bits in the original were the same\\n        for(int i = 0; i < derived.size()-1; i ++){\\n            if (derived.at(i) == 0){\\n                original.push_back(original.at(i));\\n            } else {\\n                original.push_back(!original.at(i));\\n            }\\n        }\\n        // to determine if a valid array exists, we determine if the comparison information in the derived bit vector \\n        // is consistant with the start and end bits of our constructed \\'original\\' vector.\\n        if (derived.back() == 0){\\n            return original.front() == original.back();\\n        } else {\\n            return original.front() != original.back();\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int> original;\\n        original.push_back(0); // assume a starting bit\\n\\n        // add bits to original vector, based on the comparison information in the derived bit vector.\\n        // if a bit in the derived vector is::\\n        //                 \\'1\\' -> meaning the neighbor bits in the original were different\\n        //                 \\'0\\' -> meaning the neighbor bits in the original were the same\\n        for(int i = 0; i < derived.size()-1; i ++){\\n            if (derived.at(i) == 0){\\n                original.push_back(original.at(i));\\n            } else {\\n                original.push_back(!original.at(i));\\n            }\\n        }\\n        // to determine if a valid array exists, we determine if the comparison information in the derived bit vector \\n        // is consistant with the start and end bits of our constructed \\'original\\' vector.\\n        if (derived.back() == 0){\\n            return original.front() == original.back();\\n        } else {\\n            return original.front() != original.back();\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781517,
                "title": "simple-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        int temp1 = 0;\\n        int temp2 = 1;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            temp1 ^= derived[i];\\n            temp2 ^= derived[i];\\n        }\\n        if(temp1 ^ 0 == derived[n-1])\\n            return true;\\n        if(temp2 ^ 1 == derived[n-1])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        int temp1 = 0;\\n        int temp2 = 1;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            temp1 ^= derived[i];\\n            temp2 ^= derived[i];\\n        }\\n        if(temp1 ^ 0 == derived[n-1])\\n            return true;\\n        if(temp2 ^ 1 == derived[n-1])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781146,
                "title": "just-straight-simulatiom",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n\\n        vector<int> actual (derived.size());\\n        actual[0] = 1;\\n\\n        for(int i = 0; i < derived.size(); i++){\\n\\n            if(i == derived.size() - 1){\\n                \\n                if(derived[i] == 1){\\n\\n                    if(actual[i] == actual[0]) return false;\\n                    return true;\\n                }else{\\n                     if(actual[i] == actual[0]) return true;\\n                     return false;\\n                }\\n\\n            }else{\\n\\n                if(derived[i] == 1){ //different\\n\\n                   actual[i + 1] = !actual[i];\\n                }else{\\n                    actual[i + 1] = actual[i]; //same\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n\\n/*\\n\\n[1, 1, 0]\\n\\n[1, 0, 1]\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n\\n        vector<int> actual (derived.size());\\n        actual[0] = 1;\\n\\n        for(int i = 0; i < derived.size(); i++){\\n\\n            if(i == derived.size() - 1){\\n                \\n                if(derived[i] == 1){\\n\\n                    if(actual[i] == actual[0]) return false;\\n                    return true;\\n                }else{\\n                     if(actual[i] == actual[0]) return true;\\n                     return false;\\n                }\\n\\n            }else{\\n\\n                if(derived[i] == 1){ //different\\n\\n                   actual[i + 1] = !actual[i];\\n                }else{\\n                    actual[i + 1] = actual[i]; //same\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n\\n/*\\n\\n[1, 1, 0]\\n\\n[1, 0, 1]\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755460,
                "title": "python-o-n-solution-just-simulated-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 elements xor results in 1 means differ from previous one, xor results in 0 means same as previous element\\nso just simulated the processes:(presume first item is 1 or 0, both fine!)\\nfollow the derived generate next item until last one.\\ncompare the last item with first(presumed) if there is contradiction return Ture without conlict\\n\\n**if derived[-1]==1 means fist ans last ones must be different\\nif derived[-1]==0 means fist ans last one must be identical**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def doesValidArrayExist(self, derived):\\n        \"\"\"\\n        :type derived: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def _try(fst,derived):\\n            last=fst\\n            for d in derived[:-1]:last=1-last if d==1 else last\\n            return (derived[-1] and fst!=last) or (not derived[-1] and fst==last)\\n\\n        return _try(1,derived) \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def doesValidArrayExist(self, derived):\\n        \"\"\"\\n        :type derived: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def _try(fst,derived):\\n            last=fst\\n            for d in derived[:-1]:last=1-last if d==1 else last\\n            return (derived[-1] and fst!=last) or (not derived[-1] and fst==last)\\n\\n        return _try(1,derived) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748194,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int m=0;\\n        for(int i=0;i<d.size();i++)\\n            m^=d[i];\\n        if(m==0)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int m=0;\\n        for(int i=0;i<d.size();i++)\\n            m^=d[i];\\n        if(m==0)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728272,
                "title": "easy-c-solution-just-by-calculating-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) Constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xo=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            xo=xo^derived[i];\\n        }\\n        if(xo==0)\\n        return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xo=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            xo=xo^derived[i];\\n        }\\n        if(xo==0)\\n        return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728271,
                "title": "easy-c-solution-just-by-calculating-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) Constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xo=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            xo=xo^derived[i];\\n        }\\n        if(xo==0)\\n        return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xo=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            xo=xo^derived[i];\\n        }\\n        if(xo==0)\\n        return true;\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725939,
                "title": "3-line-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto i:d)\\n            m ^= i;\\n        return m==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n       int m=0;\\n        for(auto i:d)\\n            m ^= i;\\n        return m==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717699,
                "title": "1-liner",
                "content": "```\\nbool doesValidArrayExist(vector<int>& d)\\n{\\n\\treturn accumulate(begin(d), end(d), 1, bit_xor{});\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool doesValidArrayExist(vector<int>& d)\\n{\\n\\treturn accumulate(begin(d), end(d), 1, bit_xor{});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690129,
                "title": "easy-approach-using-xor-property",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas cyclic every element of original  appear in twice in derived array so xorr of derived must be zero\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are using property xor of same element is zero as derived[i]=original[i]^original[i+1] and cyclic so all come two times so if xor of derived array is zero then true otherwise false\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n      int xorr = 0;\\n      for(auto it:derived) {\\n          xorr^=it;\\n      }\\nif(xorr==0){\\n    return true;\\n}\\nreturn false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n      int xorr = 0;\\n      for(auto it:derived) {\\n          xorr^=it;\\n      }\\nif(xorr==0){\\n    return true;\\n}\\nreturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684847,
                "title": "simplest-java-solution-beats-100-3-lines-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(int i=0; i<derived.length; i++)\\n            xor=xor^derived[i];\\n        if(xor==0) return true;\\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(int i=0; i<derived.length; i++)\\n            xor=xor^derived[i];\\n        if(xor==0) return true;\\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676427,
                "title": "logical-solution-with-explanation-cpp",
                "content": "# Intuition\\nSay we start from any of 0 or 1 in original array . Whenever we encounter a 1 in derived array that signifies we need to change the 0 to 1 or 1 to 0. So an odd number of 1 in derived array will change 0 or 1 in the begining odd number of time and this will not be equal to arr[0] when we return back.\\n\\n# Approach\\nSo if derived array contains odd number of 1\\'s then return false.Else true.(Do some dry run youself on notebook to better understad this).\\nNote: Last line (count&1) checks if count is odd or even.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            if(derived[i]==1)\\n            {\\n                count++;\\n            }\\n        }\\n        return (count&1)?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int count=0;\\n        for(int i=0;i<derived.size();i++)\\n        {\\n            if(derived[i]==1)\\n            {\\n                count++;\\n            }\\n        }\\n        return (count&1)?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673761,
                "title": "java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(var d:derived) xor ^= d;\\n        return xor == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int xor = 0;\\n        for(var d:derived) xor ^= d;\\n        return xor == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669959,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            c^=derived[i];\\n        }\\n        if(c==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            c^=derived[i];\\n        }\\n        if(c==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663808,
                "title": "c-check-all-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n        for(auto&i:derived)x^=i;\\n        return !x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int x=0;\\n        for(auto&i:derived)x^=i;\\n        return !x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654955,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    bool solve(int val,vector<int>& derived,vector<int>&original ){\\n        original[0]=val;\\n         for(int i=0;i<derived.size();i++){\\n             if(i==derived.size()-1){\\n                 if((~val^original[0])==derived[i]){\\n                     original[i]=~val;\\n                 }\\n                 if((val^original[0])==derived[i]){\\n                     original[i]=val;\\n                 }\\n             } \\n             else{\\n                 // original[i+1] = 0/1\\n                if((~val^original[i])==derived[i]){\\n                     original[i+1]=~val;\\n                 }\\n                if((val^original[i])==derived[i]){\\n                     original[i+1]=val;\\n                 }\\n             }\\n         }\\n         vector<int>dr(derived.size());\\n\\n         for(int i=0;i<original.size();i++){\\n             if(i==derived.size()-1){\\n                dr[i]=original[i]^original[0];\\n             }\\n             else{\\n                 dr[i]=original[i]^original[i+1];\\n             }\\n         }\\n         \\n         return derived==dr;\\n    }\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int>original(derived.size());\\n        bool ans=solve(0,derived,original) or solve(1,derived,original);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool solve(int val,vector<int>& derived,vector<int>&original ){\\n        original[0]=val;\\n         for(int i=0;i<derived.size();i++){\\n             if(i==derived.size()-1){\\n                 if((~val^original[0])==derived[i]){\\n                     original[i]=~val;\\n                 }\\n                 if((val^original[0])==derived[i]){\\n                     original[i]=val;\\n                 }\\n             } \\n             else{\\n                 // original[i+1] = 0/1\\n                if((~val^original[i])==derived[i]){\\n                     original[i+1]=~val;\\n                 }\\n                if((val^original[i])==derived[i]){\\n                     original[i+1]=val;\\n                 }\\n             }\\n         }\\n         vector<int>dr(derived.size());\\n\\n         for(int i=0;i<original.size();i++){\\n             if(i==derived.size()-1){\\n                dr[i]=original[i]^original[0];\\n             }\\n             else{\\n                 dr[i]=original[i]^original[i+1];\\n             }\\n         }\\n         \\n         return derived==dr;\\n    }\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector<int>original(derived.size());\\n        bool ans=solve(0,derived,original) or solve(1,derived,original);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614687,
                "title": "simplest-solution-with-simple-explanation",
                "content": "# Intuition\\n```\\nAll rests on the fact that x^x = 0 and x^0 = x.\\nHence, since  derived[i] = original[i] ^ original[(i+1)%n]\\n=> original[(i+1)%n] = derived[i] ^ original[i].  That is, the next element of original is completely determined by the current element of original and derived.\\n\\nHence, we simply test the two possible starting points: original[0] = 0 or original[0] = 1 and use those to compute the rest of the values and check that our endpoint is the same as our starting point.\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        current = 0\\n        for i in range((n := len(derived))):\\n            current ^= derived[i] \\n\\n        if current == 0:\\n            return True\\n        \\n        current = 1\\n        for i in range((n := len(derived))):\\n            current ^= derived[i] \\n\\n        if current  == 1:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nAll rests on the fact that x^x = 0 and x^0 = x.\\nHence, since  derived[i] = original[i] ^ original[(i+1)%n]\\n=> original[(i+1)%n] = derived[i] ^ original[i].  That is, the next element of original is completely determined by the current element of original and derived.\\n\\nHence, we simply test the two possible starting points: original[0] = 0 or original[0] = 1 and use those to compute the rest of the values and check that our endpoint is the same as our starting point.\\n```\n```\\n\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        current = 0\\n        for i in range((n := len(derived))):\\n            current ^= derived[i] \\n\\n        if current == 0:\\n            return True\\n        \\n        current = 1\\n        for i in range((n := len(derived))):\\n            current ^= derived[i] \\n\\n        if current  == 1:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611505,
                "title": "solution-for-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n      int i,j,k;\\n      vector<int>r(derived.size(),0);\\n      for(i=0;i<derived.size()-1;i++)\\n          {\\n                if(derived[i]==(r[i]^r[i+1])){\\n                    ;\\n                }\\n                else{\\n                    r[i+1]=1;\\n                }\\n          }\\nif(derived[derived.size()-1]==(r[0]^r[r.size()-1]))\\n    return true;\\n    \\n    return false;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n      int i,j,k;\\n      vector<int>r(derived.size(),0);\\n      for(i=0;i<derived.size()-1;i++)\\n          {\\n                if(derived[i]==(r[i]^r[i+1])){\\n                    ;\\n                }\\n                else{\\n                    r[i+1]=1;\\n                }\\n          }\\nif(derived[derived.size()-1]==(r[0]^r[r.size()-1]))\\n    return true;\\n    \\n    return false;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589661,
                "title": "c-1st-latter-is-1-or-0-take-possiblity-can-derived-a-i-a-i-1-givenarra-i-1-chek",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        \\n        int n = derived.size();\\n        vector<int> arr1(n,0) , arr2(n,0);\\n        arr2[0] = 1 ;\\n        \\n        for( int i = 1 ; i < n ; ++i )\\n        {\\n            arr1[i] = arr1[i-1] ^ derived[i-1] ; \\n            arr2[i] = arr2[i-1] ^ derived[i-1] ;   \\n        }\\n        \\n        if( arr1[n-1] ^ derived[n-1] == 0 )\\n        {\\n            return true;\\n        }\\n        \\n        if(arr2[n-1] ^ derived[n-1]  == 1 ) \\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        \\n        int n = derived.size();\\n        vector<int> arr1(n,0) , arr2(n,0);\\n        arr2[0] = 1 ;\\n        \\n        for( int i = 1 ; i < n ; ++i )\\n        {\\n            arr1[i] = arr1[i-1] ^ derived[i-1] ; \\n            arr2[i] = arr2[i-1] ^ derived[i-1] ;   \\n        }\\n        \\n        if( arr1[n-1] ^ derived[n-1] == 0 )\\n        {\\n            return true;\\n        }\\n        \\n        if(arr2[n-1] ^ derived[n-1]  == 1 ) \\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574632,
                "title": "simple-xor-operation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int x=1;\\n        int curr=x;\\n        int last;\\n        for(int i=0;i<d.size();i++){\\n            last=curr;\\n            if(d[i]==1){\\n                if(curr==1)curr=0;\\n                else{\\n                    curr=1;\\n                }\\n\\n            }\\n           \\n        }\\n        return (x==curr);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int x=1;\\n        int curr=x;\\n        int last;\\n        for(int i=0;i<d.size();i++){\\n            last=curr;\\n            if(d[i]==1){\\n                if(curr==1)curr=0;\\n                else{\\n                    curr=1;\\n                }\\n\\n            }\\n           \\n        }\\n        return (x==curr);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574021,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int k=0;\\n      for(int i=0;i<derived.size();i++)\\n      {\\n          if(derived[i]==1)\\n          {\\n            k++;  \\n          }\\n      }\\n  return k%2-1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int k=0;\\n      for(int i=0;i<derived.size();i++)\\n      {\\n          if(derived[i]==1)\\n          {\\n            k++;  \\n          }\\n      }\\n  return k%2-1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570508,
                "title": "java-very-simple-solution-recursion",
                "content": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] arr) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        al.add(1);\\n        if(comb(arr,0,al)==true)return true;\\n        return false;\\n    }\\n   private boolean comb(int arr[],int i,ArrayList<Integer> al)\\n   {\\n       if(al.size()==arr.length)\\n           if((al.get(i)^(al.get(0)))==arr[i]) return true;\\n           else return false;\\n       \\n       if((al.get(i)^0)==arr[i] || (al.get(0)^al.get(i))==arr[i])\\n       {\\n           if((al.get(i)^0)==arr[i])al.add(0);\\n           else al.add(al.get(0));\\n           if(comb(arr,i+1,al)==true)return true;\\n           else return false;\\n       } \\n       return false;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] arr) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        al.add(1);\\n        if(comb(arr,0,al)==true)return true;\\n        return false;\\n    }\\n   private boolean comb(int arr[],int i,ArrayList<Integer> al)\\n   {\\n       if(al.size()==arr.length)\\n           if((al.get(i)^(al.get(0)))==arr[i]) return true;\\n           else return false;\\n       \\n       if((al.get(i)^0)==arr[i] || (al.get(0)^al.get(i))==arr[i])\\n       {\\n           if((al.get(i)^0)==arr[i])al.add(0);\\n           else al.add(al.get(0));\\n           if(comb(arr,i+1,al)==true)return true;\\n           else return false;\\n       } \\n       return false;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568290,
                "title": "shortest-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int k=accumulate(v.begin(),v.end(),0);\\n        return k%2==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& v) {\\n        int k=accumulate(v.begin(),v.end(),0);\\n        return k%2==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567069,
                "title": "easy-c-code-optimized",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int XOR = 0;\\n        for(auto it:derived)\\n            XOR ^=it;\\n        if(XOR == 0) \\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int XOR = 0;\\n        for(auto it:derived)\\n            XOR ^=it;\\n        if(XOR == 0) \\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554791,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(0, ^) == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(0, ^) == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549666,
                "title": "simple-o-n-brut-force-approach-beats-60",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int num = 1;\\n        for(auto &d: derived){\\n            if(d == 1) num = 1-num;\\n        }\\n        return (num == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int num = 1;\\n        for(auto &d: derived){\\n            if(d == 1) num = 1-num;\\n        }\\n        return (num == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546199,
                "title": "simple-go",
                "content": "# Intuition\\nAfter simulating a few examples by hand, realised it\\'s only about the number of 1 being odd\\n\\n# Code\\n```\\nfunc doesValidArrayExist(derived []int) bool {\\n    cntOne := 0\\n    for _,v := range derived {\\n        cntOne += v\\n    }\\n    return cntOne % 2 == 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc doesValidArrayExist(derived []int) bool {\\n    cntOne := 0\\n    for _,v := range derived {\\n        cntOne += v\\n    }\\n    return cntOne % 2 == 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545987,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n=derived.length;\\n        if(n==1) return derived[0]!=0?false:true;    \\n        int[] original=new int[n];\\n        for(int i=1;i<n;i++) original[i]=(derived[i-1]^original[i-1]);\\n        if((original[n-1]^original[0])==derived[n-1]) return true;\\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n=derived.length;\\n        if(n==1) return derived[0]!=0?false:true;    \\n        int[] original=new int[n];\\n        for(int i=1;i<n;i++) original[i]=(derived[i-1]^original[i-1]);\\n        if((original[n-1]^original[0])==derived[n-1]) return true;\\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545808,
                "title": "one-liner-c-pattern-xorsum",
                "content": "\\n# Approach\\nxor sum should be zero.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& nums) {\\n        int xo = 0;\\n        for(auto i: nums) xo = (xo^i);\\n        return !xo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& nums) {\\n        int xo = 0;\\n        for(auto i: nums) xo = (xo^i);\\n        return !xo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545368,
                "title": "c-easy-to-understand",
                "content": "```\\n bool doesValidArrayExist(vector<int>& d) {\\n        \\n        int n=d.size();\\n        if(n==1){\\n            if(d[0]==0)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        vector<int>v(n);\\n        if(d[0]==0)\\n            v[0]=1,v[1]=1;\\n        else\\n            v[0]=1,v[1]=0;\\n        for(int i=1;i<n-1;i++){\\n            if(v[i]==1 && d[i]==1)\\n                v[i+1]=0;\\n            if(v[i]==0 && d[i]==1)\\n                v[i+1]=1;\\n            if(v[i]==1 && d[i]==0)\\n                v[i+1]=1;\\n            if(v[i]==0 && d[i]==0)\\n                v[i+1]=0;\\n        }\\n        return v[n-1]^v[0]==d[n-1];\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool doesValidArrayExist(vector<int>& d) {\\n        \\n        int n=d.size();\\n        if(n==1){\\n            if(d[0]==0)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        vector<int>v(n);\\n        if(d[0]==0)\\n            v[0]=1,v[1]=1;\\n        else\\n            v[0]=1,v[1]=0;\\n        for(int i=1;i<n-1;i++){\\n            if(v[i]==1 && d[i]==1)\\n                v[i+1]=0;\\n            if(v[i]==0 && d[i]==1)\\n                v[i+1]=1;\\n            if(v[i]==1 && d[i]==0)\\n                v[i+1]=1;\\n            if(v[i]==0 && d[i]==0)\\n                v[i+1]=0;\\n        }\\n        return v[n-1]^v[0]==d[n-1];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545060,
                "title": "simple-property-of-bitwise-xor-easy-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --\\n>\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool doesValidArrayExist(vector<int> &derived)\\n    {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        int cnt1 = 0;\\n        int n = derived.size();\\n        int val1=0;\\n        int val2=0;\\n        for (int i = 0; i < derived.size(); i++)\\n        {\\n            if (i == n - 1)\\n            {\\n                 val2= derived[i] ^ ans[0];\\n                 if(val1==val2){\\n                     return true;\\n                 }\\n                   ans.push_back(val2);\\n            }\\n            else\\n            {\\n                 val1 = derived[i] ^ ans[i];\\n                   ans.push_back(val1);\\n            }\\n          \\n        }\\n       \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool doesValidArrayExist(vector<int> &derived)\\n    {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        int cnt1 = 0;\\n        int n = derived.size();\\n        int val1=0;\\n        int val2=0;\\n        for (int i = 0; i < derived.size(); i++)\\n        {\\n            if (i == n - 1)\\n            {\\n                 val2= derived[i] ^ ans[0];\\n                 if(val1==val2){\\n                     return true;\\n                 }\\n                   ans.push_back(val2);\\n            }\\n            else\\n            {\\n                 val1 = derived[i] ^ ans[i];\\n                   ans.push_back(val1);\\n            }\\n          \\n        }\\n       \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545059,
                "title": "simple-property-of-bitwise-xor-easy-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --\\n>\\na^b=c then \\na^c=b\\nb^c=a...\\nbased on this property\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool doesValidArrayExist(vector<int> &derived)\\n    {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        int cnt1 = 0;\\n        int n = derived.size();\\n        int val1=0;\\n        int val2=0;\\n        for (int i = 0; i < derived.size(); i++)\\n        {\\n            if (i == n - 1)\\n            {\\n                 val2= derived[i] ^ ans[0];\\n                 if(val1==val2){\\n                     return true;\\n                 }\\n                   ans.push_back(val2);\\n            }\\n            else\\n            {\\n                 val1 = derived[i] ^ ans[i];\\n                   ans.push_back(val1);\\n            }\\n          \\n        }\\n       \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool doesValidArrayExist(vector<int> &derived)\\n    {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        int cnt1 = 0;\\n        int n = derived.size();\\n        int val1=0;\\n        int val2=0;\\n        for (int i = 0; i < derived.size(); i++)\\n        {\\n            if (i == n - 1)\\n            {\\n                 val2= derived[i] ^ ans[0];\\n                 if(val1==val2){\\n                     return true;\\n                 }\\n                   ans.push_back(val2);\\n            }\\n            else\\n            {\\n                 val1 = derived[i] ^ ans[i];\\n                   ans.push_back(val1);\\n            }\\n          \\n        }\\n       \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544537,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isvalid(bool first,bool pre,int ind ,vector<int>&v)\\n    {\\n        if(ind==v.size()-1)\\n        {\\n            if(v[v.size()-1]==1)\\n                return first!=pre;\\n            return first==pre;\\n        }\\n        if(v[ind]==1)\\n        {\\n           if(pre)\\n               return isvalid(first,0,ind+1,v);\\n            return isvalid(first,1,ind+1,v);\\n        }\\n        if(pre)\\n            return isvalid(first,1,ind+1,v);\\n        return isvalid(first,0,ind+1,v);\\n        \\n    }\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return isvalid(0,0,0,derived)||isvalid(1,1,0,derived);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isvalid(bool first,bool pre,int ind ,vector<int>&v)\\n    {\\n        if(ind==v.size()-1)\\n        {\\n            if(v[v.size()-1]==1)\\n                return first!=pre;\\n            return first==pre;\\n        }\\n        if(v[ind]==1)\\n        {\\n           if(pre)\\n               return isvalid(first,0,ind+1,v);\\n            return isvalid(first,1,ind+1,v);\\n        }\\n        if(pre)\\n            return isvalid(first,1,ind+1,v);\\n        return isvalid(first,0,ind+1,v);\\n        \\n    }\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return isvalid(0,0,0,derived)||isvalid(1,1,0,derived);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544296,
                "title": "go-with-truth-table-of-xor",
                "content": "Truth table of xor\\n\\ni1  i2  out\\n0   0   0\\n0   1   1\\n1   0   1\\n1   1   0\\n\\nAt 0th index or nth index of help 2d array one of the entry should match.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2n+2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        // if(n == 1){\\n        //     if(derived[0] == 0)return true;\\n        //     else return false;\\n        // }\\n        vector<vector<int>> help(n+1, vector<int>(2));\\n        if(derived[0] == 0){\\n            help[0][0] = 0; help[1][0] = 0;\\n            help[0][1] = 1; help[1][1] = 1;\\n        }else{\\n            help[0][0] = 0; help[1][0] = 1;\\n            help[0][1] = 1; help[1][1] = 0;\\n        }\\n        for(int i = 1;i<n;i++){\\n            if(derived[i] == 0){// res = 0\\n                if(help[i][0] == 1){\\n                    help[i+1][0] = 1;\\n                    help[i+1][1] = 0;\\n                }else{\\n                    help[i+1][0] = 0;\\n                    help[i+1][1] = 1;\\n                }\\n            }else{\\n                if(help[i][0] == 1){\\n                    help[i+1][0] = 0;\\n                    help[i+1][1] = 1;\\n                }else{\\n                    help[i+1][0] = 1;\\n                    help[i+1][1] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(help[n][0] == help[0][0] or help[n][1] == help[0][1])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        // if(n == 1){\\n        //     if(derived[0] == 0)return true;\\n        //     else return false;\\n        // }\\n        vector<vector<int>> help(n+1, vector<int>(2));\\n        if(derived[0] == 0){\\n            help[0][0] = 0; help[1][0] = 0;\\n            help[0][1] = 1; help[1][1] = 1;\\n        }else{\\n            help[0][0] = 0; help[1][0] = 1;\\n            help[0][1] = 1; help[1][1] = 0;\\n        }\\n        for(int i = 1;i<n;i++){\\n            if(derived[i] == 0){// res = 0\\n                if(help[i][0] == 1){\\n                    help[i+1][0] = 1;\\n                    help[i+1][1] = 0;\\n                }else{\\n                    help[i+1][0] = 0;\\n                    help[i+1][1] = 1;\\n                }\\n            }else{\\n                if(help[i][0] == 1){\\n                    help[i+1][0] = 0;\\n                    help[i+1][1] = 1;\\n                }else{\\n                    help[i+1][0] = 1;\\n                    help[i+1][1] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(help[n][0] == help[0][0] or help[n][1] == help[0][1])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543952,
                "title": "c",
                "content": "bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        vector<int>original(n);\\n        original[0]=derived[0];\\n        for(int i=0;i<n-1;i++){\\n            if(derived[i]==1){\\n                original[i+1]=!original[i];\\n            }\\n            else{\\n                original[i+1]=original[i];\\n            }\\n        }\\n        if(original[0]^original[n-1]==derived[n-1])\\n            return true;\\n        return false;\\n\\n    }",
                "solutionTags": [],
                "code": "bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        vector<int>original(n);\\n        original[0]=derived[0];\\n        for(int i=0;i<n-1;i++){\\n            if(derived[i]==1){\\n                original[i+1]=!original[i];\\n            }\\n            else{\\n                original[i+1]=original[i];\\n            }\\n        }\\n        if(original[0]^original[n-1]==derived[n-1])\\n            return true;\\n        return false;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3543670,
                "title": "complete-brute-force-and-optimized-code-100-working-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif xor is 0 implies that input can be 1 1 or 0 0\\nelse if xor is 1 implies that input is 1 0 or 0 1\\naccording to the first derived we find out all the original nos and finally check the final derived element wrt to first and last element of the generated original array and return true or false accordingly.\\n\\nor else we can simply xor all the elemnts of the derived array and check if the result is 0 or not.\\n(a[0]^a[1]^a[1]^a[2] and so on a[n-1]^a[0]==0)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        if(derived.size()==1)\\n        {\\n            if(derived[0]==0)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        int n = derived.size();\\n        if(derived[0]==0)\\n        {\\n            int temp = 0;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^0)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            \\n            temp = 1;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^1)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            int temp = 1;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^0)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            \\n            temp = 0;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^1)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        if(derived.size()==1)\\n        {\\n            if(derived[0]==0)\\n            {\\n                return true;\\n            }\\n            return false;\\n        }\\n        int n = derived.size();\\n        if(derived[0]==0)\\n        {\\n            int temp = 0;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^0)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            \\n            temp = 1;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^1)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else\\n        {\\n            int temp = 1;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^0)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            \\n            temp = 0;\\n            for(int i=1;i<derived.size()-1;i++)\\n            {\\n                temp = temp^derived[i];\\n            }\\n            \\n            if((temp^1)==derived[n-1])\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542361,
                "title": "c-simplest-solution-using-single-iteration-and-xor",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n\\n        int total = 0;\\n\\n        for(auto it : derived) \\n            total = total ^ it;\\n\\n        return total == 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n\\n        int total = 0;\\n\\n        for(auto it : derived) \\n            total = total ^ it;\\n\\n        return total == 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540056,
                "title": "java-simple-brut-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        //o[(i+1)%n]= (d[i]==0) ? o[i] : 1-o[i] now we can brut force start with 0 and then with 1\\n        return (check(d,0)||check(d,1));\\n    }\\n\\n\\n    public boolean check(int[] d, int start){\\n        int n = d.length;\\n        int o[] =new int [n];\\n        o[0]=start;\\n        for(int i=1;i<n;i++)\\n            o[i] = (d[i-1] == 0) ? o[i-1] : 1- o[i-1] ;\\n        if (d[n-1]==0 && o[n-1]==o[0] || d[n-1]==1 && o[n-1]!=o[0]) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        //o[(i+1)%n]= (d[i]==0) ? o[i] : 1-o[i] now we can brut force start with 0 and then with 1\\n        return (check(d,0)||check(d,1));\\n    }\\n\\n\\n    public boolean check(int[] d, int start){\\n        int n = d.length;\\n        int o[] =new int [n];\\n        o[0]=start;\\n        for(int i=1;i<n;i++)\\n            o[i] = (d[i-1] == 0) ? o[i-1] : 1- o[i-1] ;\\n        if (d[n-1]==0 && o[n-1]==o[0] || d[n-1]==1 && o[n-1]!=o[0]) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539629,
                "title": "simple-clean-and-short-solution-c-easy-explanation",
                "content": "# Intuition\\nFor the Input derived array 110 original array is 010\\n\\nexplanation:-\\nderived array:\\n1 1 0 eqv 0^1 1^0 1^0\\nfrom here we can see that derived array is formed by orginal array where each element of the original elemnt repeted twice.\\n\\nso the sum of the array in which each elements repetead twice is = 0\\n(as XOR of two same vale is 0)\\n\\n1^1^0=(0^1)^(1^0)^(1^0)=0\\n\\n# Approach\\nIterate a single for loop and take a result of the XOR of all elements.\\n\\nreturn true if result is 0 else false.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ops=derived[0];\\n        for(int i=1;i<derived.size();i++)\\n            ops^=derived[i];\\n        return ops^1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ops=derived[0];\\n        for(int i=1;i<derived.size();i++)\\n            ops^=derived[i];\\n        return ops^1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538677,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn does_valid_array_exist(derived: Vec<i32>) -> bool {\\n        let mut original = vec![0; derived.len()];\\n\\n        for i in 1..derived.len() {\\n            if derived[i - 1] == 0 {\\n                original[i] = original[i - 1];\\n            } else {\\n                original[i] = 1 - original[i - 1];\\n            }\\n        }\\n        derived[derived.len() - 1] == original[0] ^ original[derived.len() - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn does_valid_array_exist(derived: Vec<i32>) -> bool {\\n        let mut original = vec![0; derived.len()];\\n\\n        for i in 1..derived.len() {\\n            if derived[i - 1] == 0 {\\n                original[i] = original[i - 1];\\n            } else {\\n                original[i] = 1 - original[i - 1];\\n            }\\n        }\\n        derived[derived.len() - 1] == original[0] ^ original[derived.len() - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538198,
                "title": "xor-0-java-c-python",
                "content": "Java\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(List<Integer> derived) {\\n        int x = 0;\\n        for (int it : derived) {\\n            x = x ^ it;\\n        }\\n\\n        return (x == 0);\\n    }\\n}\\n\\n```\\nC++\\n```\\nclass Solution\\n{\\n    public:\\n        bool doesValidArrayExist(vector<int> &derived)\\n        {\\n            int x = 0;\\n            for (auto it: derived)\\n            {\\n                x = x ^ it;\\n            }\\n\\n            return (x == 0);\\n        }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived):\\n        x = 0\\n        for it in derived:\\n            x = x ^ it\\n\\n        return x == 0\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(List<Integer> derived) {\\n        int x = 0;\\n        for (int it : derived) {\\n            x = x ^ it;\\n        }\\n\\n        return (x == 0);\\n    }\\n}\\n\\n```\n```\\nclass Solution\\n{\\n    public:\\n        bool doesValidArrayExist(vector<int> &derived)\\n        {\\n            int x = 0;\\n            for (auto it: derived)\\n            {\\n                x = x ^ it;\\n            }\\n\\n            return (x == 0);\\n        }\\n};\\n```\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived):\\n        x = 0\\n        for it in derived:\\n            x = x ^ it\\n\\n        return x == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537572,
                "title": "xor-cpp-sol-2-liner",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int s = 0;\\n        for (auto i:derived) s ^= i;\\n        return s == 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int s = 0;\\n        for (auto i:derived) s ^= i;\\n        return s == 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537042,
                "title": "c-solution-bit-manipulation",
                "content": "```\\nproperties of xor:\\nfor any number A\\n\\nA ^ A = 0\\nA ^ 0 = A\\n```\\n\\n```\\ngiven,\\nn -> length of array arr , derived\\nas derived[i] = arr[i]^arr[(i+1)%n]\\nfor a given array derived check is it possible to construct an array \"arr\"\\n```\\n\\n```\\nconsider this \\n\\nn = 3\\narr = {a,b,c}\\n\\nderived[0] = a ^ b\\nderived[1] = b ^ c\\nderived[2] = c ^ a\\n\\nthen xor of derived[0]^derived[1]^....derived[n-1] == 0 \\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int val = 0;\\n        for(auto it : derived)\\n            val^=it;\\n        return val==0;\\n    }\\n};\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nproperties of xor:\\nfor any number A\\n\\nA ^ A = 0\\nA ^ 0 = A\\n```\n```\\ngiven,\\nn -> length of array arr , derived\\nas derived[i] = arr[i]^arr[(i+1)%n]\\nfor a given array derived check is it possible to construct an array \"arr\"\\n```\n```\\nconsider this \\n\\nn = 3\\narr = {a,b,c}\\n\\nderived[0] = a ^ b\\nderived[1] = b ^ c\\nderived[2] = c ^ a\\n\\nthen xor of derived[0]^derived[1]^....derived[n-1] == 0 \\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int val = 0;\\n        for(auto it : derived)\\n            val^=it;\\n        return val==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535138,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& arr) {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            sum=sum^arr[i];\\n        }\\n        if(sum==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& arr) {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            sum=sum^arr[i];\\n        }\\n        if(sum==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534491,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int res=0;\\n        int n=d.size();\\n        for(int i=0;i<n-1;i++){\\n            res^=d[i];\\n        }\\n        return res==d[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int res=0;\\n        int n=d.size();\\n        for(int i=0;i<n-1;i++){\\n            res^=d[i];\\n        }\\n        return res==d[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534482,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n        int n = derived.length;\\n        \\n        int arr1[] = new int[n+1];\\n        int arr2[] = new int[n+1];\\n        \\n        arr1[0] = 0;\\n        arr2[0] = 1;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(derived[i-1] == 1)\\n            {\\n                if(arr1[i-1]==0)\\n                {\\n                    arr1[i] = 1;\\n                }\\n                else\\n                {\\n                    arr1[i] = 0;\\n                }\\n                \\n                if(arr2[i-1] == 1)\\n                {\\n                    arr2[i] = 0;\\n                }\\n                else\\n                {\\n                    arr2[i] = 1;\\n                }\\n            }\\n            else\\n            {\\n                arr1[i] = arr1[i-1];\\n                arr2[i] = arr2[i-1];\\n            }\\n        }\\n        \\n        if(arr1[n] != arr1[0] && arr2[n] != arr2[0])\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n        int n = derived.length;\\n        \\n        int arr1[] = new int[n+1];\\n        int arr2[] = new int[n+1];\\n        \\n        arr1[0] = 0;\\n        arr2[0] = 1;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(derived[i-1] == 1)\\n            {\\n                if(arr1[i-1]==0)\\n                {\\n                    arr1[i] = 1;\\n                }\\n                else\\n                {\\n                    arr1[i] = 0;\\n                }\\n                \\n                if(arr2[i-1] == 1)\\n                {\\n                    arr2[i] = 0;\\n                }\\n                else\\n                {\\n                    arr2[i] = 1;\\n                }\\n            }\\n            else\\n            {\\n                arr1[i] = arr1[i-1];\\n                arr2[i] = arr2[i-1];\\n            }\\n        }\\n        \\n        if(arr1[n] != arr1[0] && arr2[n] != arr2[0])\\n        {\\n            return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533861,
                "title": "c-xor-all-elements-from-derived",
                "content": "# Intuition\\nIf derived is formed by using every element twice from original, so if we xor every element in derived, the result should be 0.\\n\\n# Approach\\nXor all elements from derived, and return true if the result is 0, otherwise false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int allXor = 0;\\n        for(int d : derived){\\n            allXor ^= d;\\n        }\\n\\n        return allXor == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int allXor = 0;\\n        for(int d : derived){\\n            allXor ^= d;\\n        }\\n\\n        return allXor == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532567,
                "title": "very-easy-solution-only-3-lines-of-code",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int flag=0;\\n        for(auto it:derived) flag^=it;\\n        return flag==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int flag=0;\\n        for(auto it:derived) flag^=it;\\n        return flag==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530966,
                "title": "a-few-solutions",
                "content": "Use inversion: return `true` if-and-only-if the quantity of the value `1` in the derived array `A` is *even* (ie. it is impossible to create the derived array `A` otherwise).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var doesValidArrayExist = { A: IntArray -> A.sum() % 2 == 0 }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet doesValidArrayExist = A => !(_.sum(A) & 1);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    doesValidArrayExist = lambda self, A: not(sum(A) & 1)\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn does_valid_array_exist(A: Vec<i32>) -> bool { A.into_iter().sum::<i32>() % 2 == 0 }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool doesValidArrayExist(VI& A) { return !(accumulate(A.begin(), A.end(), 0) & 1); }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var doesValidArrayExist = { A: IntArray -> A.sum() % 2 == 0 }\\n}\\n```\n```\\nlet doesValidArrayExist = A => !(_.sum(A) & 1);\\n```\n```\\nclass Solution:\\n    doesValidArrayExist = lambda self, A: not(sum(A) & 1)\\n```\n```\\nimpl Solution {\\n    pub fn does_valid_array_exist(A: Vec<i32>) -> bool { A.into_iter().sum::<i32>() % 2 == 0 }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool doesValidArrayExist(VI& A) { return !(accumulate(A.begin(), A.end(), 0) & 1); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529638,
                "title": "xor-should-be-zero",
                "content": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        xor=derived[0]\\n        for i in range(1,len(derived)):\\n            xor^=derived[i]\\n        return True if xor==0 else False",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        xor=derived[0]\\n        for i in range(1,len(derived)):\\n            xor^=derived[i]\\n        return True if xor==0 else False",
                "codeTag": "Java"
            },
            {
                "id": 3529351,
                "title": "python-start-equals-end",
                "content": "try first element in original with 0 and 1, respectively. After XOR with all the elements in derived, if the final value is equal to the start value we know there is an original.\\n\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        for start in [0, 1]:\\n            xor = start\\n            for i in derived:\\n                xor = xor ^ i\\n            if xor == start:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        for start in [0, 1]:\\n            xor = start\\n            for i in derived:\\n                xor = xor ^ i\\n            if xor == start:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528627,
                "title": "simple-o-n-solution",
                "content": "Assume that `original[0]=0`. Then we can pre-calculate the entire original array as `original[i+1] = original[i]^derived[i]`. At the end we must end up with zero as `original[0]` was assume to be zero. Essentially we are doing the entire simulation with an assumption. The same logic will also work with the assumption of `original[0]=1`.\\n\\n```\\nbool doesValidArrayExist(vector<int>& derived) \\n{\\n    int cur=0;\\n    for(int item: derived) cur^=item;\\n    return (cur==0);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool doesValidArrayExist(vector<int>& derived) \\n{\\n    int cur=0;\\n    for(int item: derived) cur^=item;\\n    return (cur==0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528487,
                "title": "swift-one-liner-with-bool-explained",
                "content": "![XOR_TABLE.png](https://assets.leetcode.com/users/images/b5686452-517b-4059-86dc-623a17701ab3_1684176173.8591273.png)\\n\\n# Approach\\n###### Note that the function *xor* does not change its value when the input parameters are inverted, that is, for any $$A$$ and $$B$$ it is true that $$A \\u2295 B = notA \\u2295 notB$$. This means that if there is an original array that satisfies the condition of the problem, then an inverse of it will also be suitable. Hence we can safely assume that the original array, for example, starts with 1 and try to reconstruct it element by element.\\n###### Suppose that we have determined the value of the $$i$$-th element in the original array: `original[i]`. What can we say about the next, $$(i+1)$$-th element `original[i+1]`, looking at the result of *xor* of these two, that is `derived[i]`? It is easy to see that the output of the *xor* operation is 0 when the two input parameters are equal, and 1 when they are not. Thus, `if derived[i] == 0 { original[i+1] = original[i] } else { original[i+1] = !original[i] }`.\\n###### Proceed in this way through the whole array, determining the next element, until we get to the combination of the last element with the first one. Since the first element is already decided at the very beginning, the check if it gives the desired *xor* result with the last one will determine whether the reconstructed array is valid or not.\\n###### We don\\'t even need to store the whole reconstructed array during this process, the last current element is enough, as everything depends solely on it. Since we put that the first element must be 1 (*true*, in terms of Boolean logic), the final answer will be equal to the result of the last iteration: exists if that one is 1 (*true*), not exists if that one is 0 (*false*).\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(true) { bool, num in num == 0 ? bool : !bool }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(true) { bool, num in num == 0 ? bool : !bool }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528078,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        int ans=0;\\n        for(int a:d){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] d) {\\n        int ans=0;\\n        for(int a:d){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527825,
                "title": "swift-simulate-generating-the-original-array",
                "content": "# Approach: Simulation\\n1. Simulate generating original array from derived array and check validity at each step.\\n1. Initialize the original array with `[false]` and the current index with 1. The initial value can be `[true]` as well, as long as it follows the `XOR` logic.\\n1. Loop through derived array and append new element based on previous rule.\\n1. Check last rule for first and last elements of original array.\\n1. Return `false` if any condition violated, else return `true`.\\n\\n# Code\\n```\\nclass Solution {\\n  func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n    // If the derived array has only one element, then it must be 0 to have a valid array\\n    if derived.count == 1 {\\n      return derived.first! == 0\\n    }\\n    // Initialize the current index to 1 and the original array to [false]\\n    var currentIndex: Int = 1\\n    var original: [Bool] = [false]\\n    // Loop through the derived array\\n    for _ in 0..<derived.count {\\n      // If the current index is 0, then we have reached the end of the loop and need to check the last rule\\n      if currentIndex == 0 {\\n        // Get the last rule from the derived array\\n        let previousRule = derived.last!\\n        // If the last rule is 1, then the first and last elements of the original array must be different\\n        if previousRule == 1 {\\n          return original.last! != original.first!\\n        } else {\\n          // If the last rule is 0, then the first and last elements of the original array must be the same\\n          return original.first! == original.last!\\n        }\\n      } else {\\n        // If the current index is not 0, then we need to append a new element to the original array based on the previous rule\\n        if derived[currentIndex-1] == 1 {\\n          // If the previous rule is 1, then the new element must be the opposite of the previous element\\n          original.append(!original[currentIndex-1])\\n        } else {\\n          // If the previous rule is 0, then the new element must be the same as the previous element\\n          original.append(original[currentIndex-1])\\n        }\\n      }\\n      // Increment the current index by 1 and take modulo by the derived array count\\n      currentIndex = currentIndex + 1\\n      currentIndex = currentIndex % derived.count\\n    }\\n    // Return true if we reach this point without returning false earlier\\n    return true\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n    // If the derived array has only one element, then it must be 0 to have a valid array\\n    if derived.count == 1 {\\n      return derived.first! == 0\\n    }\\n    // Initialize the current index to 1 and the original array to [false]\\n    var currentIndex: Int = 1\\n    var original: [Bool] = [false]\\n    // Loop through the derived array\\n    for _ in 0..<derived.count {\\n      // If the current index is 0, then we have reached the end of the loop and need to check the last rule\\n      if currentIndex == 0 {\\n        // Get the last rule from the derived array\\n        let previousRule = derived.last!\\n        // If the last rule is 1, then the first and last elements of the original array must be different\\n        if previousRule == 1 {\\n          return original.last! != original.first!\\n        } else {\\n          // If the last rule is 0, then the first and last elements of the original array must be the same\\n          return original.first! == original.last!\\n        }\\n      } else {\\n        // If the current index is not 0, then we need to append a new element to the original array based on the previous rule\\n        if derived[currentIndex-1] == 1 {\\n          // If the previous rule is 1, then the new element must be the opposite of the previous element\\n          original.append(!original[currentIndex-1])\\n        } else {\\n          // If the previous rule is 0, then the new element must be the same as the previous element\\n          original.append(original[currentIndex-1])\\n        }\\n      }\\n      // Increment the current index by 1 and take modulo by the derived array count\\n      currentIndex = currentIndex + 1\\n      currentIndex = currentIndex % derived.count\\n    }\\n    // Return true if we reach this point without returning false earlier\\n    return true\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527360,
                "title": "easy-to-understand-for-beginners-fast-and-simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n= derived.size();\\n        int arr[n];\\n        arr[0]=1;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(derived[i]==1)\\n                arr[i+1]= !(arr[i]);\\n            else\\n                arr[i+1]=arr[i];\\n        }\\n        \\n        if(arr[0]^arr[n-1]==derived[n-1])\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n= derived.size();\\n        int arr[n];\\n        arr[0]=1;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(derived[i]==1)\\n                arr[i+1]= !(arr[i]);\\n            else\\n                arr[i+1]=arr[i];\\n        }\\n        \\n        if(arr[0]^arr[n-1]==derived[n-1])\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527141,
                "title": "simple-java-solution",
                "content": "# Intuition\\n only two different cases are possible at index 0 for original array and remaining values at indices are dependent on previous index value.\\n# Approach\\nfirst try::\\n let first index of original array is 0\\n  every next index will be 1 or 0 depending on the value of derived[index-1] and original[index-1];\\n  for eg: original[index-1]=0,derived[index-1]=1\\n    original[index]=1 (because derived[index-1]=original[index-1]^original[index])\\nif operation (specified in problem statement) performed on original array gives derived array return true\\nsecond try ::\\nreeat above the process with first index of original array is 1\\nif two cases does not derive derived array return false;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n=derived.length;\\n        int[] answer=new int[n];\\n        answer[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(derived[i-1]==1)\\n            {\\n                answer[i]=(answer[i-1]==1)?0:1;\\n            }\\n            else\\n            {\\n                answer[i]=answer[i-1];\\n            }\\n        }\\n        if(check(answer,derived)) return true;\\n        answer[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(derived[i-1]==1)\\n            {\\n                answer[i]=(answer[i-1]==1)?0:1;\\n            }\\n            else\\n            {\\n                answer[i]=answer[i-1];\\n            }\\n        }\\n        if(check(answer,derived)) return true;\\n        return false;\\n    }\\n    public boolean check(int[] answer,int[] derived)\\n    {\\n        int[] temp=new int[answer.length];\\n        for(int i=0;i<answer.length;i++)\\n        {\\n            if(i==answer.length-1)\\n            {\\n                temp[i]=answer[i]^answer[0];\\n            }\\n            else\\n            temp[i]=answer[i]^answer[i+1];\\n            if(temp[i]!=derived[i])  return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int n=derived.length;\\n        int[] answer=new int[n];\\n        answer[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(derived[i-1]==1)\\n            {\\n                answer[i]=(answer[i-1]==1)?0:1;\\n            }\\n            else\\n            {\\n                answer[i]=answer[i-1];\\n            }\\n        }\\n        if(check(answer,derived)) return true;\\n        answer[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(derived[i-1]==1)\\n            {\\n                answer[i]=(answer[i-1]==1)?0:1;\\n            }\\n            else\\n            {\\n                answer[i]=answer[i-1];\\n            }\\n        }\\n        if(check(answer,derived)) return true;\\n        return false;\\n    }\\n    public boolean check(int[] answer,int[] derived)\\n    {\\n        int[] temp=new int[answer.length];\\n        for(int i=0;i<answer.length;i++)\\n        {\\n            if(i==answer.length-1)\\n            {\\n                temp[i]=answer[i]^answer[0];\\n            }\\n            else\\n            temp[i]=answer[i]^answer[i+1];\\n            if(temp[i]!=derived[i])  return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527040,
                "title": "simplest-explained-solution-2-approaches",
                "content": "# Important things to understand\\n```\\nX ^ X = 0\\n2 ^ 2 = 0\\n\\nX ^ X ^ Y ^ Y = 0\\n2 ^ 5 ^ 2 ^ 5 = 0\\n\\n```\\nIt means that if same element is XORed even times then it becomes 0\\n\\n```\\nX ^ Y ^ X = Y  \\n1 ^ 5 ^ 1 = 5 \\n\\n```\\nHere the output becomes the element which appeard odd times and the elements appeared even times were cancelled out.\\n\\n# Derived Array\\nSuppose we have an `Original array` `[A B C D]`. The `Derived array`, by definition, will be `[A xor B, B xor C, C xor D, D xor A]`. Here we can see that every element of the `Original array` appears twice in the `Derived array`.\\n\\n# Approach\\nSo whenever we derive an array from `original array` consisting `1\\'s` and `0\\'s`. The `Derived array` will always contain `even` no. of `1\\'s`because we now know that every element appears twice to construct the`Derived array`\\n \\nSo it is not possible to contain`odd` number of `1\\'s` in the `Derived array` , if that is the case we will `return false` or else `return true`.\\n\\n# Solution\\n`Now we have 2 solutions: `\\n1. we can perform `XOR` operation on all elements of the `Derived array`\\n\\n    example 1: `[1,1,0]`    1 ^ 1 ^ 0 = 0, Ans is `True` because 1 appeared even times     \\n\\n    example 2: `[1,1,0,1]` 1 ^ 1 ^ 0 ^ 1 = 1, Ans is `False` because 1 appeared odd times\\n\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.length; i++){\\n            ans ^= derived[i];\\n        }\\n        return ans==0; \\n    }\\n} \\n```\\n2. We can simply count the number of `1\\'s `in the `derived array` and if the count of `1` is `even` we\\'ll return `true` or else `false`;\\n\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.length; i++){\\n            ans += derived[i];\\n        }\\n        return ans%2==0; \\n    }\\n} \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nX ^ X = 0\\n2 ^ 2 = 0\\n\\nX ^ X ^ Y ^ Y = 0\\n2 ^ 5 ^ 2 ^ 5 = 0\\n\\n```\n```\\nX ^ Y ^ X = Y  \\n1 ^ 5 ^ 1 = 5 \\n\\n```\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.length; i++){\\n            ans ^= derived[i];\\n        }\\n        return ans==0; \\n    }\\n} \\n```\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.length; i++){\\n            ans += derived[i];\\n        }\\n        return ans%2==0; \\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526849,
                "title": "c",
                "content": "```C []\\nstatic int sum_ints(const int * const nums, const int numsLen){\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\tsum += nums[i];\\n\\t}\\n\\treturn sum;\\n}\\n\\nbool doesValidArrayExist(int* derived, int derivedSize){\\n\\treturn sum_ints(derived, derivedSize) % 2 == 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nstatic int sum_ints(const int * const nums, const int numsLen){\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\tsum += nums[i];\\n\\t}\\n\\treturn sum;\\n}\\n\\nbool doesValidArrayExist(int* derived, int derivedSize){\\n\\treturn sum_ints(derived, derivedSize) % 2 == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526791,
                "title": "o-n-single-pass-intuition-explanation",
                "content": "# Intuition\\nLook at the short examples, e.g. derived array of length 2.\\nIf original array was `1, 1`, then derived array would be `0, 0` (and also if original array was `0, 0`). If the elements in the original array of length two were different, then the derived array woul be `1, 1`. Notice that there is no original array which would result in `0, 1` or `1, 0` as derived array.\\n\\nCan we guess the original array knowing the derived array? Looking at the first element in the derived, what can we say about the first two elements in the original array? \\nAssuming the first element in the original array is `0`, what is the second element, given the derived array?\\n\\n# Approach\\nFollowing the intuition section, we notice that we can pick a value for the first element in the original array, and see if we reach the same value by solving for the next element in the original array.\\n\\nWe use the fact that xor is commutative and `a xor a = 0`, so `a xor b xor a = b`. That means, to compute the second element in derived, we xor `derived[0]` with our initial guess for `original[0]`.\\n\\nIf we repeat the steps for every element, we should obtain `original[0]` at the end. I.e. `xor(<all elements in derived>) == 0`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, as we do one pass over the input array. \\n\\n- Space complexity:\\n$$O(1)$$ - we only store the xor result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int crt_guess = 0;\\n        for (int ii = 0; ii < derived.size(); ++ii) {\\n            crt_guess = crt_guess ^ derived[ii];\\n        }\\n        return crt_guess == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int crt_guess = 0;\\n        for (int ii = 0; ii < derived.size(); ++ii) {\\n            crt_guess = crt_guess ^ derived[ii];\\n        }\\n        return crt_guess == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526771,
                "title": "kotlin-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun doesValidArrayExist(derived: IntArray): Boolean {\\n        val n = derived.size\\n\\n        val bits = BooleanArray(n){ false }\\n        bits[0] = true\\n\\n        for (i in 0 until n - 1) {\\n            if (derived[i] == 1) {\\n                bits[i + 1] = bits[i].not()\\n            } else {\\n                bits[i + 1] = bits[i]\\n            }\\n        }\\n\\n        return if(derived[n - 1] == 1) bits[n - 1] != bits[0] else bits[n - 1] == bits[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun doesValidArrayExist(derived: IntArray): Boolean {\\n        val n = derived.size\\n\\n        val bits = BooleanArray(n){ false }\\n        bits[0] = true\\n\\n        for (i in 0 until n - 1) {\\n            if (derived[i] == 1) {\\n                bits[i + 1] = bits[i].not()\\n            } else {\\n                bits[i + 1] = bits[i]\\n            }\\n        }\\n\\n        return if(derived[n - 1] == 1) bits[n - 1] != bits[0] else bits[n - 1] == bits[0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526687,
                "title": "neighboring-bitwise-xor",
                "content": "**Solution-1**\\n2 ways to make original array\\n\\noriginal1[0] = 0 (array starting with 0)\\noriginal2[0] = 1 (array starting wiht 1)\\n\\nand then keep building more on both of the arrays.\\n\\nIf any of the array (either original1 or original2) satifies then return true else false.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        vector<int>original1(n);\\n        vector<int>original2(n);\\n        original1[0]=0;\\n        original2[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            original1[i]=derived[i-1] ^ original1[i-1];\\n            original2[i]=derived[i-1] ^ original2[i-1];\\n        }\\n        return ((derived[n-1]==original1[n-1]^original1[0]) || (derived[n-1]==original2[n-1]^original2[0]));\\n        \\n    }\\n};\\n```\\n\\n**Solution-2**\\nderived[0] = original[0] ^ original[1]\\nderived[1] = original[1] ^ original[2]\\nderived[2] = original[2] ^ original[3]\\n...\\nderived[n-2] = original[n-2] ^ original[n-1]\\nderived[n-1] = original[n-1] ^ original[0]\\n\\nOn xoring both the sides\\n\\nLHS\\nderived[0] ^ derived[1] ^ derived[2] ^ ... ^ derived[n-1] => same as xoring entire derived array.\\n\\nRHS\\nsince every element will appear twice so it will result into zero.\\n\\nHence valid binary array original will exist only when xor(derived) = zero.\\n\\nSummary:\\nEvery element is appearing twice in the entire process.\\nThat means at the end if xor of the entire element =0 then there exists a valid binary array, otherwise not.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans=0;\\n        for(auto x: derived)\\n        {\\n            ans=ans^x;\\n        }\\n        return (ans==0);\\n    }\\n```\\n\\none-liner code \\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\\n\\n**Solution-3**\\nWhen original and derived is a binary sequence, then this equals to sum(derived)%2==0.\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return accumulate(begin(derived),end(derived),0)%2==0;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        vector<int>original1(n);\\n        vector<int>original2(n);\\n        original1[0]=0;\\n        original2[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            original1[i]=derived[i-1] ^ original1[i-1];\\n            original2[i]=derived[i-1] ^ original2[i-1];\\n        }\\n        return ((derived[n-1]==original1[n-1]^original1[0]) || (derived[n-1]==original2[n-1]^original2[0]));\\n        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans=0;\\n        for(auto x: derived)\\n        {\\n            ans=ans^x;\\n        }\\n        return (ans==0);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return accumulate(begin(derived),end(derived),0)%2==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526617,
                "title": "python-o-n-explained",
                "content": "1. If the answer is true, `derived` must contain even number of `1`.\\n<img src=\"https://assets.leetcode.com/users/images/04a2d0a8-16c2-429d-ac4a-1962354d57d1_1684141811.9305665.png\" width=\"60%\"  />\\n2. Given a `derived` with even number of `1`, we can form an `original` like following:\\n<img src=\"https://assets.leetcode.com/users/images/b26c1e2e-862c-420c-87ee-903b6bcb34dd_1684142462.5727298.png\" width=\"40%\" />\\nThe even number of `1` assures that a_0 = a_{n-1} ^ d_{n-1}.\\n3. Note that setting a_0 = 1 also works. \\nFor example, given `derived = [0,1,1,0,1,0,1]`, setting a_0 = 0 leads to `original = [0,0,1,0,0,1,1]`, while setting a_0 = 1 leads to `original = [1,1,0,1,1,0,0]`.\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return False if sum(derived)&1 else True",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. If the answer is true, `derived` must contain even number of `1`.\\n<img src=\"https://assets.leetcode.com/users/images/04a2d0a8-16c2-429d-ac4a-1962354d57d1_1684141811.9305665.png\" width=\"60%\"  />\\n2. Given a `derived` with even number of `1`, we can form an `original` like following:\\n<img src=\"https://assets.leetcode.com/users/images/b26c1e2e-862c-420c-87ee-903b6bcb34dd_1684142462.5727298.png\" width=\"40%\" />\\nThe even number of `1` assures that a_0 = a_{n-1} ^ d_{n-1}.\\n3. Note that setting a_0 = 1 also works. \\nFor example, given `derived = [0,1,1,0,1,0,1]`, setting a_0 = 0 leads to `original = [0,0,1,0,0,1,1]`, while setting a_0 = 1 leads to `original = [1,1,0,1,1,0,0]`.\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return False if sum(derived)&1 else True",
                "codeTag": "Java"
            },
            {
                "id": 3526548,
                "title": "c-solution-bit-manipulation",
                "content": "**C++** : \\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();     //size \\n\\t\\t\\n\\t\\t//making two vector one starting from one and other starting from zero\\n        vector<int> startone(n,-1);\\n        vector<int> startzero(n,-1);\\n        \\n\\t\\t//setting first element as per two possibilities\\n        startone[0]=1;\\n        startzero[0]=0;\\n        \\n\\t\\t//for storing rest of the values running loop and checking condition as per XOR gate conditions\\n        for(int i=0;i<n-1;i++){\\n            if(derived[i]==1){\\n                startone[i+1]=(!startone[i]);\\n                startzero[i+1]=(!startzero[i]);\\n            }\\n            else{\\n                startone[i+1]=startone[i];\\n                startzero[i+1]=startzero[i];\\n            }\\n        }\\n        \\n\\t\\t//checking for last derived bit from first and last element of original array\\n        if(derived[n-1]==(startone[0]^startone[n-1]) || derived[n-1]==(startzero[0]^startzero[n-1])){\\n            return true;\\n        }\\n\\t\\t\\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();     //size \\n\\t\\t\\n\\t\\t//making two vector one starting from one and other starting from zero\\n        vector<int> startone(n,-1);\\n        vector<int> startzero(n,-1);\\n        \\n\\t\\t//setting first element as per two possibilities\\n        startone[0]=1;\\n        startzero[0]=0;\\n        \\n\\t\\t//for storing rest of the values running loop and checking condition as per XOR gate conditions\\n        for(int i=0;i<n-1;i++){\\n            if(derived[i]==1){\\n                startone[i+1]=(!startone[i]);\\n                startzero[i+1]=(!startzero[i]);\\n            }\\n            else{\\n                startone[i+1]=startone[i];\\n                startzero[i+1]=startzero[i];\\n            }\\n        }\\n        \\n\\t\\t//checking for last derived bit from first and last element of original array\\n        if(derived[n-1]==(startone[0]^startone[n-1]) || derived[n-1]==(startzero[0]^startzero[n-1])){\\n            return true;\\n        }\\n\\t\\t\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526228,
                "title": "c-beginners-friendly-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        /**\\n         original = [w,x,y,z] \\n         derived = [w^x,x^y,y^z,z^w] , xoring derived from [0 : n-2] ->\\n                   -> w^x ^ x^y ^ y^z = w^z ,\\n\\t\\t\\t\\t   w^z == z^w\\n                   if derived from [0 : n-2] == [n-1] return true. \\n         * */\\n         int xor_ = 0;\\n        for (int i = 0; i < n-1; ++i) {  // loop [0,n-2]\\n            xor_ ^= derived[i];\\n        }\\n        \\n        return xor_ == derived[n-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        /**\\n         original = [w,x,y,z] \\n         derived = [w^x,x^y,y^z,z^w] , xoring derived from [0 : n-2] ->\\n                   -> w^x ^ x^y ^ y^z = w^z ,\\n\\t\\t\\t\\t   w^z == z^w\\n                   if derived from [0 : n-2] == [n-1] return true. \\n         * */\\n         int xor_ = 0;\\n        for (int i = 0; i < n-1; ++i) {  // loop [0,n-2]\\n            xor_ ^= derived[i];\\n        }\\n        \\n        return xor_ == derived[n-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526215,
                "title": "simple-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int n=d.size(),count=0;\\n        for(int i=0;i<n;i++){\\n            if(d[i]==1)\\n                count++;\\n        }\\n        if(count%2)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int n=d.size(),count=0;\\n        for(int i=0;i<n;i++){\\n            if(d[i]==1)\\n                count++;\\n        }\\n        if(count%2)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525951,
                "title": "two-diff-methods-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool doesValidArrayExist(vector<int>& derived) \\n{\\n        int n=derived.size();\\n        vector<int> temp(n);\\n        vector<bool> vis(n,false);\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (derived[i]==1 && vis[i]==false)\\n            {\\n                temp[i]=1;\\n                temp[i+1]=0;\\n                vis[i]=true;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==0 && vis[i]==false)\\n            {\\n                temp[i]=1;\\n                temp[i+1]=1;\\n                vis[i]=true;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==1 && vis[i]==true)\\n            {\\n                int curr=temp[i];\\n                temp[i+1]=1-curr;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==0 && vis[i]==true)\\n            {\\n                int curr=temp[i];\\n                temp[i+1]=curr;\\n                vis[i+1]=true;\\n            }\\n        }\\n        if (derived[n-1]==1)\\n            return (temp[0]!=temp[n-1]);\\n        else\\n            return (temp[0]==temp[n-1]);\\n            \\n        \\n    }\\n\\n\\n\\n//another method : the xor of all elements of derived should be zero beacuse we are using each element twice to construct the derived array.\\n\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        int xori=0;\\n        for (int a:derived)\\n          xori^=a;\\n        return xori==0;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool doesValidArrayExist(vector<int>& derived) \\n{\\n        int n=derived.size();\\n        vector<int> temp(n);\\n        vector<bool> vis(n,false);\\n        for (int i=0;i<n-1;i++)\\n        {\\n            if (derived[i]==1 && vis[i]==false)\\n            {\\n                temp[i]=1;\\n                temp[i+1]=0;\\n                vis[i]=true;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==0 && vis[i]==false)\\n            {\\n                temp[i]=1;\\n                temp[i+1]=1;\\n                vis[i]=true;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==1 && vis[i]==true)\\n            {\\n                int curr=temp[i];\\n                temp[i+1]=1-curr;\\n                vis[i+1]=true;\\n            }\\n            else if (derived[i]==0 && vis[i]==true)\\n            {\\n                int curr=temp[i];\\n                temp[i+1]=curr;\\n                vis[i+1]=true;\\n            }\\n        }\\n        if (derived[n-1]==1)\\n            return (temp[0]!=temp[n-1]);\\n        else\\n            return (temp[0]==temp[n-1]);\\n            \\n        \\n    }\\n\\n\\n\\n//another method : the xor of all elements of derived should be zero beacuse we are using each element twice to construct the derived array.\\n\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n=derived.size();\\n        int xori=0;\\n        for (int a:derived)\\n          xori^=a;\\n        return xori==0;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525849,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& der) {\\n        \\n        if(der.size() == 1){\\n            if(der[0] == 0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        vector<int> ori1, ori2;\\n        \\n        if(der[0] == 0){\\n            ori1.push_back(0);\\n            ori1.push_back(0);\\n            ori2.push_back(1);\\n            ori2.push_back(1);\\n        }\\n        else{\\n            ori1.push_back(1);\\n            ori1.push_back(0);\\n            ori2.push_back(0);\\n            ori2.push_back(1);\\n        }\\n        for(int i = 1; i < der.size() - 1; i++){\\n            if(der[i] == 0){\\n                if(ori1[i] == 0)\\n                    ori1.push_back(0);\\n                else if(ori1[i] == 1)\\n                    ori1.push_back(1);\\n                \\n                if(ori2[i] == 0)\\n                    ori2.push_back(0);\\n                else if(ori2[i] == 1)\\n                    ori2.push_back(1);\\n            }\\n            else{\\n                if(ori1[i] == 0)\\n                    ori1.push_back(1);\\n                else if(ori1[i] == 1)\\n                    ori1.push_back(0);\\n                \\n                if(ori2[i] == 0)\\n                    ori2.push_back(1);\\n                else if(ori2[i] == 1)\\n                    ori2.push_back(0);\\n            }\\n        }\\n        int n = ori1.size();\\n        if((ori1[0] ^ ori1[n - 1]) == der[n - 1])\\n            return true;\\n        \\n        else if((ori2[0] ^ ori2[n - 1]) == der[n - 1])\\n            return true;\\n        \\n        else\\n            return false;\\n        \\n    }\\n    \\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& der) {\\n        \\n        if(der.size() == 1){\\n            if(der[0] == 0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        vector<int> ori1, ori2;\\n        \\n        if(der[0] == 0){\\n            ori1.push_back(0);\\n            ori1.push_back(0);\\n            ori2.push_back(1);\\n            ori2.push_back(1);\\n        }\\n        else{\\n            ori1.push_back(1);\\n            ori1.push_back(0);\\n            ori2.push_back(0);\\n            ori2.push_back(1);\\n        }\\n        for(int i = 1; i < der.size() - 1; i++){\\n            if(der[i] == 0){\\n                if(ori1[i] == 0)\\n                    ori1.push_back(0);\\n                else if(ori1[i] == 1)\\n                    ori1.push_back(1);\\n                \\n                if(ori2[i] == 0)\\n                    ori2.push_back(0);\\n                else if(ori2[i] == 1)\\n                    ori2.push_back(1);\\n            }\\n            else{\\n                if(ori1[i] == 0)\\n                    ori1.push_back(1);\\n                else if(ori1[i] == 1)\\n                    ori1.push_back(0);\\n                \\n                if(ori2[i] == 0)\\n                    ori2.push_back(1);\\n                else if(ori2[i] == 1)\\n                    ori2.push_back(0);\\n            }\\n        }\\n        int n = ori1.size();\\n        if((ori1[0] ^ ori1[n - 1]) == der[n - 1])\\n            return true;\\n        \\n        else if((ori2[0] ^ ori2[n - 1]) == der[n - 1])\\n            return true;\\n        \\n        else\\n            return false;\\n        \\n    }\\n    \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525632,
                "title": "c-bit-manipulation-with-explanation",
                "content": "let  `original` array as=[a,b,c,d] then by definition\\n`derived`  will be =[a^b,b^c,c^d,d^a] \\nsince every element in the derived array is appering twice xor of all the element will be 0\\nnecessary and sufficient condition for the derived array to be valid is `xor(derived)`=0\\n**xor of derived array is 0 means there will be even no of 1\\'s so sum of array is divisible by 2**\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int dxor = 0;\\n        for (int num : derived) {\\n            dxor ^= num;\\n        }\\n        return dxor==0;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return accumulate(derived.begin(),derived.end(),0)%2==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int dxor = 0;\\n        for (int num : derived) {\\n            dxor ^= num;\\n        }\\n        return dxor==0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        return accumulate(derived.begin(),derived.end(),0)%2==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525593,
                "title": "easy-to-understand-memory-optimized-solution",
                "content": "# Intuition\\nTo create derieved from original initially 2 possible ways ( 0 , 1 ).\\nSo starting with 2 variables compute XOR till last , if last is same as start as XOR of last element with first is to be done . \\nIf same then derieved array can be produced else not. \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        bool s1 = 0 , s2 = 1 ;\\n        bool e1 = s1 ^ d[0] , e2 = s2 ^ d[0] ;  \\n        for( int i = 1 ; i < d.size() ; i++ ){\\n            e1 ^= d[i] ; \\n            e2 ^= d[i] ; \\n        }\\n        if( s1 == e1 || s2 == e2 )\\n            return 1 ; \\n        return 0 ; \\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        bool s1 = 0 , s2 = 1 ;\\n        bool e1 = s1 ^ d[0] , e2 = s2 ^ d[0] ;  \\n        for( int i = 1 ; i < d.size() ; i++ ){\\n            e1 ^= d[i] ; \\n            e2 ^= d[i] ; \\n        }\\n        if( s1 == e1 || s2 == e2 )\\n            return 1 ; \\n        return 0 ; \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525469,
                "title": "simple-java-solution-using-xor-with-tc-o-n-and-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know the array is a binary array, so I just considered as the first element and then tried to find if it satisfies the given condition. If not then tried checking considering the first element as 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a fairly simple approach. Just calculate the XOR of 0 to n-2 th element, and check for the condition.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        return check(0, derived) || check(1, derived);\\n    }\\n\\n    private boolean check(int start, int[] derived) {\\n        int n = derived.length;\\n        int curr = start;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            curr ^= derived[i];\\n        }\\n\\n        return (curr ^ start) == derived[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        return check(0, derived) || check(1, derived);\\n    }\\n\\n    private boolean check(int start, int[] derived) {\\n        int n = derived.length;\\n        int curr = start;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            curr ^= derived[i];\\n        }\\n\\n        return (curr ^ start) == derived[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525307,
                "title": "linear-time-constant-space-solution-in-c-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservations:\\n- For any valid array satisfying the constraints, the bitwise inversion of this array is also valid. Thus we can assume that if a valid array exists, its initial element is 0.\\n- If we know what `original[i]` should be, we can use `derived[i]` to compute what `original[i+1]` should be: (i) `derived[i]` $= 0 \\\\implies$ `original[i]` $=$ `original[i+1]` and (ii) `derived[i]` $= 1 \\\\implies$ `original[i]` $\\\\neq$ `original[i+1]`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssume `original[0]` $=0$. From the second bullet point above, note that the rule for updating the next index precisely matches what XOR does. After looping through the entire derived array using this realization, we expect that the \"next\" element (which is actually `original[0]`) equals 0, else we contradict our initial assumption.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        bool next = 0;\\n        for (const int x : derived) {\\n            next ^= x;\\n        }\\n        return next == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        bool next = 0;\\n        for (const int x : derived) {\\n            next ^= x;\\n        }\\n        return next == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525081,
                "title": "determining-the-original-array-and-check-consistency-python-with-comments",
                "content": "**Idea: Initialization and Check Consistency**\\nWe can initialize the original[0] = 0 (1 is also good). Then\\nscan the derived to set the other elements in original. \\nIn general, derived[i] = org[i] ^ org[i+1]. If derived[i] == 0,\\nwe shall set org[i+1] = org[i]; If derived[i] == 1, we need to\\nset org[i+1] = 1 - org[i], i.e, org[i] and org[i+1] are different.\\n\\nWhen we at the index n - 1. Based on the val of derived[n-1] = org[n-1] ^ org[0], we need to check org[0] for consistency:\\n\\nif derived[n-1] == 0, it means org[n-1] and org[0] shall be the same. If not,\\nreturn False; if derived[n-1] == 1, it means org[n-1] and org[0] shall be different. If not, we need to return False.\\n\\nAfter the checks, if no return, we return True.\\n\\nRemark: we can set org[0] = 0 or org[0] = 1. Both options work. The difference\\nin the full org array is a flip of 0, 1.\\n\\nFor Eg.1, derived = [1, 1, 0]. If we set org[0] = 1, org = [1, 0, 1];\\nIf we set org[0] = 0, org = [0, 1, 0].\\n\\nFlipping of 0, 1 does not affect the resulted derived from org. This is due to\\noperation rule of XOR: same yield 0, different yield 1.\\n\\n1 ^ 1 = 0 ^ 0 = 0; 1 ^ 0 = 0 ^ 1 = 1.\\n\\n**Extension**: simplify the code.\\n\\n\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        n = len(derived)\\n        org = [-1] * n\\n        \\n        org[0] = 1 # you can start org[0] to be either 0 or 1. Both works.\\n        for i in range(n):\\n            cur = derived[i]\\n            if i < n-1:\\n                if cur == 0:\\n                    org[i+1] = org[i]\\n                else:\\n                    org[i+1] = 1 - org[i]\\n            if i == n-1:\\n                if cur == 0:\\n                    if org[0] != org[i]:\\n                        return False\\n                else:\\n                    if org[0] == org[i]:\\n                        return False\\n        # print(org)\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        \\n        n = len(derived)\\n        org = [-1] * n\\n        \\n        org[0] = 1 # you can start org[0] to be either 0 or 1. Both works.\\n        for i in range(n):\\n            cur = derived[i]\\n            if i < n-1:\\n                if cur == 0:\\n                    org[i+1] = org[i]\\n                else:\\n                    org[i+1] = 1 - org[i]\\n            if i == n-1:\\n                if cur == 0:\\n                    if org[0] != org[i]:\\n                        return False\\n                else:\\n                    if org[0] == org[i]:\\n                        return False\\n        # print(org)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525070,
                "title": "java-easy-to-understand-solution-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The first number of the original array only have two possible value: 0 or 1\\n2. when i < derived.length, derived[i] = original[i]^original[i+1]. original[i+1] = derived[i]^orginal[i];\\n3. init two array seperately represent first number is 0 or 1\\n4. use traverse to get all next number\\n5. check whether exists derived[n -1] == original[n-1] ^ orginal[0]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n        int[] o1 = new int[derived.length];\\n        int[] o2 = new int[derived.length];\\n        o1[0] = 0;\\n        o2[0] = 1;\\n        boolean f1 = false, f2 = false;\\n        for(int i = 0; i < derived.length; i++){\\n            if(i < derived.length - 1){\\n                o1[i+1] = o1[i]^derived[i];\\n                o2[i+1] = o2[i]^derived[i];\\n            }else{\\n                f1 = (derived[i] == (o1[i]^o1[0])) ? true : false;\\n                f2 = (derived[i] == (o2[i]^o2[0])) ? true: false;                \\n            }\\n        }\\n        return f1 || f2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        \\n        int[] o1 = new int[derived.length];\\n        int[] o2 = new int[derived.length];\\n        o1[0] = 0;\\n        o2[0] = 1;\\n        boolean f1 = false, f2 = false;\\n        for(int i = 0; i < derived.length; i++){\\n            if(i < derived.length - 1){\\n                o1[i+1] = o1[i]^derived[i];\\n                o2[i+1] = o2[i]^derived[i];\\n            }else{\\n                f1 = (derived[i] == (o1[i]^o1[0])) ? true : false;\\n                f2 = (derived[i] == (o2[i]^o2[0])) ? true: false;                \\n            }\\n        }\\n        return f1 || f2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525049,
                "title": "swift-one-liner",
                "content": "**One-Liner (accepted answer)**\\n```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(0,^) == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func doesValidArrayExist(_ derived: [Int]) -> Bool {\\n        derived.reduce(0,^) == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524559,
                "title": "just-snap-and-it-will-print-in-your-mind",
                "content": "# Intuition\\nso let a[] be an orignal array and the derived array is composed of\\n\\n```\\nderived[] = {a[0]^a[1] ,  a[1]^a[2] , a[2]^a[3] ,\\n.\\n.\\n.\\n.\\n a[n-1]^a[0]}\\n```\\n\\n\\n# Approach\\nSo the bitwise **XOR** operation is are as follows :\\nlet their be an element **X**\\n```\\n1. X^X=0\\n2. X^0=X\\n\\n```\\nSo threfore ,if we **Xor** the  derived array element it will result in **0** if their exist an orignal array ,i.e,\\n\\n```\\n(a[0]^a[1])^(a[1]^a[2])^(a[2]^a[3])^a[3]...............a[n-1]^\\n(a[n-1]^a[0])\\n```\\nSo everything will cancel and result is 0  if their exist an orignal array otherwise orignal array does\\'nt exist\\n# Complexity\\n- Time complexity:\\n**O(N)**,where N is the size of derived array\\n\\n- Space complexity:\\n**O(1)**,as no extra space have been taken \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int a=0;\\n       for(auto &c:derived){\\n           a=a^c;\\n       }\\n       return a==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nderived[] = {a[0]^a[1] ,  a[1]^a[2] , a[2]^a[3] ,\\n.\\n.\\n.\\n.\\n a[n-1]^a[0]}\\n```\n```\\n1. X^X=0\\n2. X^0=X\\n\\n```\n```\\n(a[0]^a[1])^(a[1]^a[2])^(a[2]^a[3])^a[3]...............a[n-1]^\\n(a[n-1]^a[0])\\n```\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int a=0;\\n       for(auto &c:derived){\\n           a=a^c;\\n       }\\n       return a==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524540,
                "title": "beats-100-java-c-python-xor-all-deeply-explained",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\n#### Don\\'t forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# Intuition\\nGiven an array, we are tasked with checking if there exists an array such that the XOR of every two neighboring elements equals the corresponding element in the given array. In the binary world, XOR essentially implies \\'sum without carry\\'. This fundamental property of XOR operation forms the cornerstone of our approach.\\n\\nLet\\'s first denote our original unknown array as `A[0], A[1], .... A[n-1]` and the derived array (the one we are given) as `A[0]^A[1], A[1]^A[2] .... A[n-1]^A[0]`. What we are essentially looking for is a way to get back to the original array from the derived one.\\n\\nA critical insight here is to observe that the XOR operation has a peculiar property: the sum of an odd number of 1\\'s is 1 and the sum of an even number of $$1$$\\'s is $$0$$. This is due to the XOR operation being equivalent to binary addition without carry. For example, consider four bits: `1 XOR 1 XOR 1 XOR 1 = 0`, and `1 XOR 1 XOR 1 = 1`. This pattern extends to any number of bits.\\n\\nNow, if we XOR all elements of the derived array, we would end up with 0 because every element from the original array would appear twice and thus cancel each other out. This forms the basis of our condition for the existence of a valid original array: `xor(derived) == 0`.\\n\\n# Approach\\nWith the above intuition, our approach becomes quite straightforward. We simply iterate through the given array and XOR all the elements. If the final result is $$0$$, we return `true` to indicate that a valid array exists; otherwise, we return `false`.\\n\\n# Complexity Analysis\\n- Time complexity: The time complexity for this approach is $$O(n)$$ because we\\'re traversing the array once. \\n- Space complexity: The space complexity is $$O(1)$$ because we\\'re only using a single variable to hold the sum.\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int sum = 0;\\n        for (int n: derived) {\\n            sum ^= n;\\n        }\\n        return sum == 0;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int sum = 0;\\n        for (int n: derived) {\\n            sum ^= n;\\n        }\\n        return sum == 0;\\n    }\\n};\\n```\\n``` python3 []\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return reduce(lambda a, b: a ^ b, derived) == 0\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] derived) {\\n        int sum = 0;\\n        for (int n: derived) {\\n            sum ^= n;\\n        }\\n        return sum == 0;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int sum = 0;\\n        for (int n: derived) {\\n            sum ^= n;\\n        }\\n        return sum == 0;\\n    }\\n};\\n```\n``` python3 []\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        return reduce(lambda a, b: a ^ b, derived) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524505,
                "title": "populating-original-vector-from-derived",
                "content": "# Intuition\\nExcept last digit , any other digit of derived can be obtained from original. The last digit of derived is dependent on first digit of original.\\nSo, let\\'s come up with the original vector. I start with original vector of size n+1 so as to get all n digits of derived.\\nWe can assume the starting value of original as 1 or 0. I chose 1.\\n\\n\\nNow to obtain derived[0]=1, \\n    original[1] needs to be different from original[0],\\n    else original[1]= original[0].\\n\\nRepeat above proces for all the digits of derived.\\n\\nAnd the original[n] needs be same as original[0] because the last bit of derived is supposed to be \\nderived[n-1] = original[n-1] XOR original[0];\\n\\n\\n# Code\\n```\\n bool doesValidArrayExist(vector<int>& derived) {\\n    int n = derived.size();\\n    vector<int> original(n+1,0);\\n    original[0]=1;\\n    for(int i=0;i<n;++i){\\n        if(derived[i]==1)\\n            original[i+1]=~original[i];\\n        else\\n            original[i+1]=original[i];\\n    }\\n    return original[n] == original[0];\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n bool doesValidArrayExist(vector<int>& derived) {\\n    int n = derived.size();\\n    vector<int> original(n+1,0);\\n    original[0]=1;\\n    for(int i=0;i<n;++i){\\n        if(derived[i]==1)\\n            original[i+1]=~original[i];\\n        else\\n            original[i+1]=original[i];\\n    }\\n    return original[n] == original[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524371,
                "title": "3-line-solution-greedy-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int x=0;\\n        for(auto i:d)\\n            x=x^i;\\n        return x==0?1:0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& d) {\\n        int x=0;\\n        for(auto i:d)\\n            x=x^i;\\n        return x==0?1:0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3524348,
                "title": "simulate-all-possible-cases",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool firstCheck = true;\\n    bool secondCheck = true;\\n    void updateVariation(vector<vector<int>> & variation, int & target, int & index) {\\n        for (int i = 0; i < 2; i++) {\\n            if (i == 0 && !firstCheck || i == 1 && !secondCheck) {\\n                continue;\\n            }\\n            vector<int> & var = variation[i];\\n            if (var[index + 1] != -1 && var[index] ^ var[index + 1] != target) {\\n                i == 0 ? firstCheck = false : secondCheck = false;\\n            }\\n            if (target == 0) {\\n                var[index + 1] = var[index] == 0 ? 0 : 1;\\n            }\\n            else {\\n                var[index + 1] = var[index] == 0 ? 1 : 0;\\n            }\\n        }\\n    }\\n    \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        if (n == 1 ) {\\n            return derived[0] == 0;\\n        }\\n        vector<vector<int>> variation(2, vector<int>(n, -1));\\n        if (derived[n - 1] == 1) {\\n            variation[0][0] = 1;\\n            variation[0][n - 1] = 0;\\n            variation[1][0] = 0;\\n            variation[1][n - 1] = 1;\\n        }\\n        else {\\n            variation[0][0] = 1;\\n            variation[0][n - 1] = 1;\\n            variation[1][0] = 0;\\n            variation[1][n - 1] = 0;\\n        }\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            updateVariation(variation, derived[i], i);\\n            if (!firstCheck && !secondCheck) {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool firstCheck = true;\\n    bool secondCheck = true;\\n    void updateVariation(vector<vector<int>> & variation, int & target, int & index) {\\n        for (int i = 0; i < 2; i++) {\\n            if (i == 0 && !firstCheck || i == 1 && !secondCheck) {\\n                continue;\\n            }\\n            vector<int> & var = variation[i];\\n            if (var[index + 1] != -1 && var[index] ^ var[index + 1] != target) {\\n                i == 0 ? firstCheck = false : secondCheck = false;\\n            }\\n            if (target == 0) {\\n                var[index + 1] = var[index] == 0 ? 0 : 1;\\n            }\\n            else {\\n                var[index + 1] = var[index] == 0 ? 1 : 0;\\n            }\\n        }\\n    }\\n    \\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int n = derived.size();\\n        if (n == 1 ) {\\n            return derived[0] == 0;\\n        }\\n        vector<vector<int>> variation(2, vector<int>(n, -1));\\n        if (derived[n - 1] == 1) {\\n            variation[0][0] = 1;\\n            variation[0][n - 1] = 0;\\n            variation[1][0] = 0;\\n            variation[1][n - 1] = 1;\\n        }\\n        else {\\n            variation[0][0] = 1;\\n            variation[0][n - 1] = 1;\\n            variation[1][0] = 0;\\n            variation[1][n - 1] = 0;\\n        }\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            updateVariation(variation, derived[i], i);\\n            if (!firstCheck && !secondCheck) {\\n                return false;\\n            }\\n        }\\n    \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524242,
                "title": "c-easy-implementation-o-n",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector <int> first(1,0);\\n        vector <int> second(1,1);\\n        int size=derived.size();\\n        for(int i=0;i<size-1;i++){\\n            if(derived[i]==0){\\n                if(first[i]==0) first.push_back(0);\\n                else first.push_back(1);\\n                if(second[i]==0) second.push_back(0);\\n                else second.push_back(1);                \\n            }\\n            else{\\n                if(first[i]==1)first.push_back(0);\\n                else first.push_back(1);\\n                if(second[i]==1)second.push_back(0);\\n                else second.push_back(1);\\n            }\\n        }\\n        if(first[0]^first[size-1]==derived[size-1]) return true;\\n        if(second[0]^second[size-1]==derived[size-1])return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        vector <int> first(1,0);\\n        vector <int> second(1,1);\\n        int size=derived.size();\\n        for(int i=0;i<size-1;i++){\\n            if(derived[i]==0){\\n                if(first[i]==0) first.push_back(0);\\n                else first.push_back(1);\\n                if(second[i]==0) second.push_back(0);\\n                else second.push_back(1);                \\n            }\\n            else{\\n                if(first[i]==1)first.push_back(0);\\n                else first.push_back(1);\\n                if(second[i]==1)second.push_back(0);\\n                else second.push_back(1);\\n            }\\n        }\\n        if(first[0]^first[size-1]==derived[size-1]) return true;\\n        if(second[0]^second[size-1]==derived[size-1])return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523977,
                "title": "full-explanation-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xor_val = 0;\\n        int count_ones = 0;\\n        for (int i = 0; i < derived.size(); i++) {\\n            xor_val ^= derived[i];\\n            if (derived[i] == 1) {\\n                count_ones++;\\n            }\\n        }\\n        if (xor_val != 0) {\\n            return false;\\n        }\\n        if (count_ones % 2 == 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n};\\n```\\n\\n**Explanation -:**\\n```\\nint xor_val = 0;\\nint count_ones = 0;\\n```\\nThese two lines define two integer variables xor_val and count_ones and initialize them to 0. xor_val will be used to compute the XOR of all the elements in the derived vector, while count_ones will be used to count the number of elements in derived that have the value of 1.\\n\\n```\\nfor (int i = 0; i < derived.size(); i++) {\\n    xor_val ^= derived[i];\\n    if (derived[i] == 1) {\\n        count_ones++;\\n    }\\n}\\n```\\nThis loop iterates over each element derived[i] in the derived vector, computes the XOR of all the elements using the ^= operator, and counts the number of elements with the value of 1 using the if statement.\\n\\n```\\nif (xor_val != 0) {\\n    return false;\\n}\\n```\\nThis if statement checks if the XOR of all the elements in derived is not equal to 0. If it is not, then it means that a valid array cannot be created from derived, so the function returns false.\\n\\n```\\nif (count_ones % 2 == 0) {\\n    return true;\\n} else {\\n    return false;\\n}\\n```\\nThis if statement checks if the number of elements in derived that have the value of 1 is even. If it is even, then it means that a valid array can be created from derived, so the function returns true. Otherwise, it returns false.\\n\\nIn summary, this function checks if it is possible to create a valid array from the given vector by computing the XOR of all the elements and checking if it is equal to 0, and by counting the number of elements with the value of 1 and checking if it is even.\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xor_val = 0;\\n        int count_ones = 0;\\n        for (int i = 0; i < derived.size(); i++) {\\n            xor_val ^= derived[i];\\n            if (derived[i] == 1) {\\n                count_ones++;\\n            }\\n        }\\n        if (xor_val != 0) {\\n            return false;\\n        }\\n        if (count_ones % 2 == 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n};\\n```\n```\\nint xor_val = 0;\\nint count_ones = 0;\\n```\n```\\nfor (int i = 0; i < derived.size(); i++) {\\n    xor_val ^= derived[i];\\n    if (derived[i] == 1) {\\n        count_ones++;\\n    }\\n}\\n```\n```\\nif (xor_val != 0) {\\n    return false;\\n}\\n```\n```\\nif (count_ones % 2 == 0) {\\n    return true;\\n} else {\\n    return false;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523933,
                "title": "1-line-even-sum-return-true",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n       return accumulate(derived.begin(),derived.end(),0) % 2 == 0;\\n    }\\n}; \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n       return accumulate(derived.begin(),derived.end(),0) % 2 == 0;\\n    }\\n}; \\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1895888,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Cool XOR understanding question**"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "It takes alot of time to deduce any solution where we try to develop the original array.\\nHowever the actual answer is completely out of the box."
                    },
                    {
                        "username": "Princesah999",
                        "content": "original array KMC :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "i take my whole time to find the original array and\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B "
                    }
                ]
            },
            {
                "id": 1893625,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Cool XOR understanding question**"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "It takes alot of time to deduce any solution where we try to develop the original array.\\nHowever the actual answer is completely out of the box."
                    },
                    {
                        "username": "Princesah999",
                        "content": "original array KMC :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "i take my whole time to find the original array and\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B "
                    }
                ]
            },
            {
                "id": 1893430,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Cool XOR understanding question**"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "It takes alot of time to deduce any solution where we try to develop the original array.\\nHowever the actual answer is completely out of the box."
                    },
                    {
                        "username": "Princesah999",
                        "content": "original array KMC :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "i take my whole time to find the original array and\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B "
                    }
                ]
            },
            {
                "id": 1893191,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Cool XOR understanding question**"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "It takes alot of time to deduce any solution where we try to develop the original array.\\nHowever the actual answer is completely out of the box."
                    },
                    {
                        "username": "Princesah999",
                        "content": "original array KMC :("
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "i take my whole time to find the original array and\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B "
                    }
                ]
            }
        ]
    },
    {
        "title": "Differences Between Two Objects",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1903185,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            },
            {
                "id": 1908990,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            },
            {
                "id": 1904078,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            },
            {
                "id": 1904498,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            },
            {
                "id": 1903816,
                "content": [
                    {
                        "username": "aanand07",
                        "content": "I\\'m having a hard time understanding example 4, problem description states that  `Keys that exist in one object but not in the other should not be included in the returned object.` According to this, output should be `{}`. "
                    },
                    {
                        "username": "arthur326",
                        "content": "I also found this to be a weird case. It seems the key description is that arrays should be viewed as objects with their indices as keys \"when comparing two arrays\" (and only then, I guess)."
                    },
                    {
                        "username": "AloofSage",
                        "content": "Presumably if it was ```obj2 = {\\n  \"a\": {\"c\": 1},\\n}``` ,then we would ignore the changed keys, but since the value changed from object to array we log the difference. They should probably specify though since you could argue that the second object is equivalent to ```{\"a\":{\"0\":1}}```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s confusing to me that objects and arrays that are not \\'deeply equal\\' as per  \\'2628. JSON Deep Equal\\'. Are still considered equal here, like in:\\n`{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}`\\n`{\"a\":{\"b\": [1,2,3]}, \"c\": 1}`\\n\\nin my opinion those arrays are not equal. and we should return something with  {\"a\":{\"b\":[[1,2,3,4], [1,2,3]]}}, but instead we should just ignore it because the 4 is considered as an extra/removed key? I think that is a weird way to define equality. Maybe you could be more explicit about this in the description/examples. \\n"
                    },
                    {
                        "username": "juleshwar",
                        "content": "## Testcases to test your code\\n\\n```\\n{\"a\":[]}\\n{\"a\":[]}\\n{}\\n{\"a\": 1, \"b\": 2}\\n{\"a\": 1, \"v\": 3, \"x\": [], \"z\": {\"a\": null}}\\n{\"a\": 2, \"v\": 4, \"x\": [], \"z\": {\"a\": 2}}\\n{\"a\": 5, \"v\": 6, \"z\": [1,2,4, [2,5,7]]}\\n{\"a\": 5, \"v\": 7, \"z\": [1,2,3, [1]]}\\n{\"a\":{\"b\":1}}\\n{\"a\":{\"0\":1}}\\n{\"a\": [1, 2, {}],\"b\": false}\\n{\"b\": false, \"a\": [1, 2, {}]}\\n{}\\n{}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[1,{\"b\":[{\"4\":5}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":[2,{\"b\":2}]}\\n{\"a\":[2,{\"b\":[{\"4\":6}]}]}\\n{\"a\":3}\\n{\"a\": \"c\", \"c\": [1,true], \"m\": 11}\\n{\"a\": \"f\", \"c\":[1,false], \"b\": 11}\\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "this one was tough for me: \\n{\"a\":{\"b\": [1,2,3,4]}, \"c\": 2}\\n{\"a\":{\"b\": [1,2,3]}, \"c\": 1}"
                    },
                    {
                        "username": "luismendes070",
                        "content": "Case 1 and case 5 Answers OK. ChatGPT TypeScript function objDiff(obj1: any, obj2: any): any {\\n  try {\\n    const result: any = {};\\n\\n    const compare = (val1: any, val2: any, path: string): void => {\\n      if (val1 === null && val2 === null) {\\n        return;\\n      }\\n\\n      if (typeof val1 !== typeof val2 || Array.isArray(val1) !== Array.isArray(val2)) {\\n        result[path] = [val1, val2];\\n      } else if (typeof val1 === \\'object\\') {\\n        if (Array.isArray(val1)) {\\n          const length = Math.max(val1.length, val2.length);\\n          for (let i = 0; i < length; i++) {\\n            if (i < val1.length && i < val2.length) {\\n              compare(val1[i], val2[i], `${path}[${i}]`);\\n            } else if (i < val1.length) {\\n              result[`${path}[${i}]`] = [val1[i], undefined];\\n            } else {\\n              result[`${path}[${i}]`] = [undefined, val2[i]];\\n            }\\n          }\\n        } else {\\n          const keys = new Set([...Object.keys(val1), ...Object.keys(val2)]);\\n          for (const key of keys) {\\n            if (key in val1 && key in val2) {\\n              compare(val1[key], val2[key], `${path}.${key}`);\\n            } else if (key in val1) {\\n              result[`${path}.${key}`] = [val1[key], undefined];\\n            } else {\\n              result[`${path}.${key}`] = [undefined, val2[key]];\\n            }\\n          }\\n        }\\n\\n        // Omit keys with no differences in the leaves\\n        if (Object.keys(result[path]).length === 0) {\\n          delete result[path];\\n        }\\n      } else if (val1 !== val2) {\\n        result[path] = [val1, val2];\\n      }\\n    };\\n\\n    compare(obj1, obj2, \\'\\');\\n\\n    // Omit the top-level object if it has no differences\\n    if (Object.keys(result).length === 0) {\\n      return {};\\n    }\\n\\n    return result;\\n  } catch (error) {\\n    // Handle any errors that occur during the comparison\\n    console.error(\\'An error occurred during object comparison:\\', error);\\n    return {};\\n  }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day20 : Done Solving Today\\'s Question"
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Trailing Zeros From a String",
        "question_content": "<p>Given a <strong>positive</strong> integer <code>num</code> represented as a string, return <em>the integer </em><code>num</code><em> without trailing zeros as a string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;51230100&quot;\n<strong>Output:</strong> &quot;512301&quot;\n<strong>Explanation:</strong> Integer &quot;51230100&quot; has 2 trailing zeros, we remove them and return integer &quot;512301&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;\n<strong>Output:</strong> &quot;123&quot;\n<strong>Explanation:</strong> Integer &quot;123&quot; has no trailing zeros, we return integer &quot;123&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>num</code> consists&nbsp;of only digits.</li>\n\t<li><code>num</code> doesn&#39;t&nbsp;have any leading zeros.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3570271,
                "title": "java-c-python-js-1-line-strip",
                "content": "# **Explanation**\\nStrip trailing characters by regax replacing.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)` for output\\n<br>\\n\\n**Java**\\n```java\\n    public String removeTrailingZeros(String num) {\\n        return num.replaceAll(\"0+$\", \"\");\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    string removeTrailingZeros(string num) {\\n        return regex_replace(num, regex(\"0+$\"), \"\");\\n    }\\n```\\n\\n**Python**\\n```py\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```\\n\\n**JavaScript**\\n```js\\n\\tvar removeTrailingZeros = function(num) {\\n\\t    return num.replace(/0+$/, \\'\\');\\n\\t};\\n```\\n\\n**Go**\\n```go\\n\\tfunc removeTrailingZeros(num string) string {\\n\\t    return strings.TrimRight(num, \"0\")\\n\\t}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```java\\n    public String removeTrailingZeros(String num) {\\n        return num.replaceAll(\"0+$\", \"\");\\n    }\\n```\n```cpp\\n    string removeTrailingZeros(string num) {\\n        return regex_replace(num, regex(\"0+$\"), \"\");\\n    }\\n```\n```py\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```\n```js\\n\\tvar removeTrailingZeros = function(num) {\\n\\t    return num.replace(/0+$/, \\'\\');\\n\\t};\\n```\n```go\\n\\tfunc removeTrailingZeros(num string) string {\\n\\t    return strings.TrimRight(num, \"0\")\\n\\t}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3570456,
                "title": "iterate-very-simple-easy-to-understand",
                "content": "<b> Up vote if you like the solution </b>\\n\\nFind the ith index from last which is not equal to zero, then take substring up to (i + 1)th index.\\n\\n# Code\\n```\\nstring removeTrailingZeros(string num) {\\n    int i = num.size() -1; \\n    while(i >= 0 && num[i] == \\'0\\') i--;\\n    return num.substr(0, i+1);\\n}\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring removeTrailingZeros(string num) {\\n    int i = num.size() -1; \\n    while(i >= 0 && num[i] == \\'0\\') i--;\\n    return num.substr(0, i+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571098,
                "title": "erase-find-if-and-base",
                "content": "TIL: the `base` function converts the reverse iterator to the corresponding forward iterator.\\n\\nThe `find_if` function below searches for the first non-zero character from the right (reverse).\\n\\n**C++**\\n```cpp\\nstring removeTrailingZeros(string num) {\\n    num.erase(find_if(rbegin(num), rend(num), [](char ch){\\n        return ch != \\'0\\';\\n    }).base(), end(num));\\n    return num;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring removeTrailingZeros(string num) {\\n    num.erase(find_if(rbegin(num), rend(num), [](char ch){\\n        return ch != \\'0\\';\\n    }).base(), end(num));\\n    return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571226,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570411,
                "title": "c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int j = num.length()-1;\\n        while(j >= 0 && num[j]==\\'0\\')j--;\\n        if(j<0)return \"\";\\n        return num.substr(0,j+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int j = num.length()-1;\\n        while(j >= 0 && num[j]==\\'0\\')j--;\\n        if(j<0)return \"\";\\n        return num.substr(0,j+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571035,
                "title": "java-simple-while-checking-charat-from-end",
                "content": "# Code\\n```\\npublic String removeTrailingZeros(String num) {\\n    int len = num.length();\\n    while (--len >= 0) {\\n        if (num.charAt(len) != \\'0\\') break;\\n    }\\n    return num.substring(0, ++len);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String removeTrailingZeros(String num) {\\n    int len = num.length();\\n    while (--len >= 0) {\\n        if (num.charAt(len) != \\'0\\') break;\\n    }\\n    return num.substring(0, ++len);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570865,
                "title": "rstrip-python-1-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570224,
                "title": "easiest-c-solution-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFind the index of the first character which is not 0 from the last and then return the string from starting to that index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.length();\\n        int i;\\n        for(i = n - 1; i >= 0; i--){\\n            if(num[i] != \\'0\\') break;\\n        }\\n        \\n        return num.substr(0,i + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.length();\\n        int i;\\n        for(i = n - 1; i >= 0; i--){\\n            if(num[i] != \\'0\\') break;\\n        }\\n        \\n        return num.substr(0,i + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998079,
                "title": "javascript-without-using-inbuilt-method-easy",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function (num) {\\n  let result = \"\"\\n  for (i = num.length - 1; i >= 0; i--) {\\n    if (num[i] !== \"0\" || result.length > 0) {\\n      result = num[i] + result\\n    }\\n  }\\n  return result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function (num) {\\n  let result = \"\"\\n  for (i = num.length - 1; i >= 0; i--) {\\n    if (num[i] !== \"0\" || result.length > 0) {\\n      result = num[i] + result\\n    }\\n  }\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764519,
                "title": "easy-cpp-solution-using-loops-beginer-friendly-with-stepwise-explanation",
                "content": "# Intuition\\n - Somehow use pop().\\n\\n# Approach\\n1. Initialize an integer `i` with the value of the length of the string `num` minus 1.\\n2. Start a while loop that continues as long as the character at index `i` in `num` is equal to `\\'0\\'`.\\n3. Inside the loop, remove the last character from `num` using the `pop_back()` function.\\n4. Decrement the value of `i` by 1 to move to the previous character in the string.\\n5. Once the loop ends, return the modified `num` string.\\n\\n\\n# Complexity\\n- Time complexity:\\n   - O(n)\\n\\n- Space complexity:\\n    - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n       int i=num.length()-1;\\n        while(num[i]==\\'0\\')\\n        {\\n            num.pop_back();\\n            i--;\\n        }\\n        return num;\\n\\n    }\\n};\\n```\\n# Please upvote and feel free to ask doubts",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n       int i=num.length()-1;\\n        while(num[i]==\\'0\\')\\n        {\\n            num.pop_back();\\n            i--;\\n        }\\n        return num;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570202,
                "title": "one-line-code-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // ===============================first method=============\\n        \\n        // int j = num.size() - 1;\\n        //  while (j >= 0 && num[j] == \\'0\\') {\\n        //     j--;\\n        // }\\n        // return num.substr(0, j + 1);\\n        \\n        \\n        // ===================second method============================ \\n        return num.substr(0, num.find_last_not_of(\\'0\\') + 1);\\n         \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // ===============================first method=============\\n        \\n        // int j = num.size() - 1;\\n        //  while (j >= 0 && num[j] == \\'0\\') {\\n        //     j--;\\n        // }\\n        // return num.substr(0, j + 1);\\n        \\n        \\n        // ===================second method============================ \\n        return num.substr(0, num.find_last_not_of(\\'0\\') + 1);\\n         \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570199,
                "title": "clean-short-java-solution",
                "content": "\\n``` java []\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        BigInteger n = new BigInteger(num);\\n        while(n.mod(BigInteger.TEN).equals(BigInteger.ZERO))\\n            n = n.divide(BigInteger.TEN);\\n        return n.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        BigInteger n = new BigInteger(num);\\n        while(n.mod(BigInteger.TEN).equals(BigInteger.ZERO))\\n            n = n.divide(BigInteger.TEN);\\n        return n.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782099,
                "title": "java-beats-100-easiest-solution",
                "content": "\\n\\n# Approach\\nWe start from the right end of the string and iterate backwards until we find the first non-zero digit. We keep track of the index of this non-zero digit. Finally, we return the substring from the beginning of the input string up to this index.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n    int i = num.length() - 1;\\n    while(i >= 0 && num.charAt(i) == \\'0\\') i --;\\n    return num.substring(0, i + 1);    \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n    int i = num.length() - 1;\\n    while(i >= 0 && num.charAt(i) == \\'0\\') i --;\\n    return num.substring(0, i + 1);    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644499,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string s) {\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]!=\\'0\\')\\n            break;\\n           s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string s) {\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]!=\\'0\\')\\n            break;\\n           s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634061,
                "title": "easy-java-solution-beats-100",
                "content": "# Approach\\nWe start from the right end of the string and iterate backwards until we find the first non-zero digit. We keep track of the index of this non-zero digit. Finally, we return the substring from the beginning of the input string up to this index.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        int i = num.length() - 1;\\n        while (i >= 0 && num.charAt(i) == \\'0\\') {\\n            i--;\\n        }\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        int i = num.length() - 1;\\n        while (i >= 0 && num.charAt(i) == \\'0\\') {\\n            i--;\\n        }\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587459,
                "title": "c-in-place-resizing-8ms-8-8mb",
                "content": "Nice warmup problem, we can get it done by using a reading pointer `r` we will advance from the back up to the first position which is not a `\\'0\\'`; we will then resize `num` to be `r + 1` character and `return` it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // support variables\\n        int r = num.size();\\n        // moving r to the last non-\\'0\\' digit\\n        while (num[--r] == \\'0\\');\\n        // pruning the zeroes (if any) out of num\\n        num.resize(r + 1);\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // support variables\\n        int r = num.size();\\n        // moving r to the last non-\\'0\\' digit\\n        while (num[--r] == \\'0\\');\\n        // pruning the zeroes (if any) out of num\\n        num.resize(r + 1);\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573465,
                "title": "c-java-locating-the-first-non-zero-character-from-the-end",
                "content": "Start from the last character and continue backwards until you encounter the first character that is not zero.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.size() - 1;\\n        for (; i >= 0; i--)\\n            if (num[i] != \\'0\\')\\n                break;\\n        return num.substr(0, i + 1);\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length() - 1;\\n        for (; i >= 0; i--)\\n            if (num.charAt(i) != \\'0\\') \\n                break;\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.size() - 1;\\n        for (; i >= 0; i--)\\n            if (num[i] != \\'0\\')\\n                break;\\n        return num.substr(0, i + 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length() - 1;\\n        for (; i >= 0; i--)\\n            if (num.charAt(i) != \\'0\\') \\n                break;\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570656,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n= num.size();\\n        int i =n-1;\\n        while(num[i]==\\'0\\'){\\n            i--;\\n        }\\n        string ans=\"\";\\n        for(int k =0;k<=i;k++) ans+=num[k];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n= num.size();\\n        int i =n-1;\\n        while(num[i]==\\'0\\'){\\n            i--;\\n        }\\n        string ans=\"\";\\n        for(int k =0;k<=i;k++) ans+=num[k];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570592,
                "title": "c-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.size() - 1;  // Start from the last character index\\n\\n        // Remove trailing zeros\\n        while (i >= 0 && num[i] == \\'0\\') {\\n            num.pop_back();  // Remove the last character\\n            i--;\\n        }\\n\\n        return num;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.size() - 1;  // Start from the last character index\\n\\n        // Remove trailing zeros\\n        while (i >= 0 && num[i] == \\'0\\') {\\n            num.pop_back();  // Remove the last character\\n            i--;\\n        }\\n\\n        return num;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570559,
                "title": "2710-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Remove all zeros in end of the String num;\\nex 1 : 51230100 (remove zeros from end) = 512301;\\nex 2: 67433430000 = 6743343;\\nex 2: 6743 (there are no zeros in the end)= 6743;\\n\\n# **code explanation**\\n**int i** is a last index in num\\nloop to travel right to left.\\n**num.charAt(--i) == \\'0\\'** = to find any non zero number loop will break;\\n\\n**num.substring( (star index) 0 , (end index) i);** num.substring is a method\\nreturn a string starting index to end index in num string;\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using for loop\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        for(;num.charAt(i) == \\'0\\'; i--);\\n        return num.substring(0,i+1);\\n    }\\n}\\n```\\n# Code using while loop\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length();\\n        while(num.charAt(--i) == \\'0\\');\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        for(;num.charAt(i) == \\'0\\'; i--);\\n        return num.substring(0,i+1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length();\\n        while(num.charAt(--i) == \\'0\\');\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570255,
                "title": "python-c",
                "content": "\\n```python []\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        while num[-1] == \\'0\\': \\n            num = num[:-1]\\n        return num\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num[num.size() - 1] == \\'0\\')   \\n            num.pop_back();\\n        return num;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        while num[-1] == \\'0\\': \\n            num = num[:-1]\\n        return num\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num[num.size() - 1] == \\'0\\')   \\n            num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570186,
                "title": "easy-beginner-friendly-c-direct",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i;\\n        for(i=num.size()-1;i>=0;i--){\\n            if(num[i]!=\\'0\\')\\n                break;\\n        }\\n        return num.substr(0,i+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i;\\n        for(i=num.size()-1;i>=0;i--){\\n            if(num[i]!=\\'0\\')\\n                break;\\n        }\\n        return num.substr(0,i+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993550,
                "title": "c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') {\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') {\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950961,
                "title": "python-code-for-beginner-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n I simply used the strip function which removes the trailing character from the string you may also use rstrip that will provide the same result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:95%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:95.4%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.strip(\\'0\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.strip(\\'0\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874649,
                "title": "one-liner-beats-94-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return str(int(str(num)[::-1]))[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return str(int(str(num)[::-1]))[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846783,
                "title": "approach-for-all-languages-easy-c-code-tryithindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. simply socho piche jb tk 0 hoga hatana hai 0\\n2. loop lagao, last element check karo\\n3. 0 mila to last element to 0 hatao aur last element = last element - 1, otherwise return the same string.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.length()-1;\\n        while(num[n] ==\\'0\\'){\\n            num.pop_back();\\n            n--;\\n        }\\n\\n        return num;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/1cfb7537-2330-4d9c-a411-8c55b8693eed_1690877287.7127228.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.length()-1;\\n        while(num[n] ==\\'0\\'){\\n            num.pop_back();\\n            n--;\\n        }\\n\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801485,
                "title": "python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n\\n        while(num[-1] == \\'0\\'):\\n            num = num[:-1]\\n        return num\\n        \\n```\\n## Other Problem Solutions:\\n\\n- For Python: https://github.com/Abu-bakr-Siddiqh/leetcode_solutions_python\\n\\n- For Java : https://github.com/Abu-bakr-Siddiqh/leetcode_solutions_java",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n\\n        while(num[-1] == \\'0\\'):\\n            num = num[:-1]\\n        return num\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735458,
                "title": "2710-remove-trailing-zeros-from-a-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) { // 51230100\\n    //  int size= num.length();  //8\\n    // we can use  .length() function also\\n        int size= num.size();  //8\\n        // we will use simple pointer for backward traversal\\n        int i; \\n       // declaring i before loop to use the value of i after the for loop ends\\n        for( i=size-1;i>=0;i--){   // 7 > 0 6>0 5>0 \\n            if(num[i] !=\\'0\\'){   // 0 0 1\\n                break;    // at i=5 value = 1 it breaks from the for loop\\n            }\\n        }\\n        // substr = substring which returns a part of the string\\n// variable.substr(starting position, size of substring);\\n        return num.substr(0,i+1);  // starting position = 0 == first index\\n        // size of the substring = i+ 1 = 5+1 =6 == \"512301\"\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) { // 51230100\\n    //  int size= num.length();  //8\\n    // we can use  .length() function also\\n        int size= num.size();  //8\\n        // we will use simple pointer for backward traversal\\n        int i; \\n       // declaring i before loop to use the value of i after the for loop ends\\n        for( i=size-1;i>=0;i--){   // 7 > 0 6>0 5>0 \\n            if(num[i] !=\\'0\\'){   // 0 0 1\\n                break;    // at i=5 value = 1 it breaks from the for loop\\n            }\\n        }\\n        // substr = substring which returns a part of the string\\n// variable.substr(starting position, size of substring);\\n        return num.substr(0,i+1);  // starting position = 0 == first index\\n        // size of the substring = i+ 1 = 5+1 =6 == \"512301\"\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673621,
                "title": "easy-java-solution",
                "content": "\\n\\n# Approach\\nChecking the string from backwards if the last character is not zero return the entire string else chech the string character by character if the character is \\'0\\' assign the index value to the pointer if the character is not \\'0\\' come out of the loop and the return the string from the starting index uptill to the pointer.\\n\\nOriginal string : 51230100\\nIterate the string from backwards\\nEx  : 00103215\\n\\nInititally i points to the left most end \\'0\\' .\\nAccording to our condition if the character is \\'0\\' assign the value of pointer(Ex : l) to the index value.Here i = num.length()-1 (here length = 8-1 = 7),therefore l = num.length()-1.\\ncontinue the process\\ncheck the next character if it is \\'0\\' update the l value.\\nIf the character is not zero exit the loop.\\nNow the value of l = 6\\nReturn the substring from 0 to l.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n         int l =num.length()-1;\\n         String s=\"\";\\n        if(num.charAt(num.length()-1)!=\\'0\\')\\n        return num;\\n        else{\\n        for(int i=num.length()-1;i>=0;i--){  \\n            char ch = num.charAt(i);\\n            if(ch==\\'0\\')\\n              l = i;\\n            else\\n                break;\\n        }\\n        s+= num.substring(0,l);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n         int l =num.length()-1;\\n         String s=\"\";\\n        if(num.charAt(num.length()-1)!=\\'0\\')\\n        return num;\\n        else{\\n        for(int i=num.length()-1;i>=0;i--){  \\n            char ch = num.charAt(i);\\n            if(ch==\\'0\\')\\n              l = i;\\n            else\\n                break;\\n        }\\n        s+= num.substring(0,l);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656623,
                "title": "2710-remove-trailing-zeros-from-a-string-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int n = num.length()-1;\\n        for(int i = n ;i>0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                break;\\n            }\\n            n--;\\n        }\\n        return num.substring(0,n+1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int n = num.length()-1;\\n        for(int i = n ;i>0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                break;\\n            }\\n            n--;\\n        }\\n        return num.substring(0,n+1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595097,
                "title": "very-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string removeTrailingZeros(string num) \\n    {\\n        int i=num.size()-1;\\n        while(i>0 && num[i]==\\'0\\') i--;\\n        num=num.substr(0,i+1);\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string removeTrailingZeros(string num) \\n    {\\n        int i=num.size()-1;\\n        while(i>0 && num[i]==\\'0\\') i--;\\n        num=num.substr(0,i+1);\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589455,
                "title": "my-solution-for-java-javascript",
                "content": "```java []\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int remove = 0;\\n\\n        for(int i = num.length() - 1; i > 0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                remove++;\\n            }else {\\n                break;\\n            }\\n        }\\n        String result = num.substring(0,num.length() - remove);\\n        return result;\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let remove = 0;\\n\\n    for(let i = num.length - 1; i > 0; i--){\\n        if(num.charAt(i) === \\'0\\') remove ++;\\n        else break;\\n    }\\n\\n    let result = num.substring(0,num.length - remove);\\n    return result;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int remove = 0;\\n\\n        for(int i = num.length() - 1; i > 0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                remove++;\\n            }else {\\n                break;\\n            }\\n        }\\n        String result = num.substring(0,num.length() - remove);\\n        return result;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let remove = 0;\\n\\n    for(let i = num.length - 1; i > 0; i--){\\n        if(num.charAt(i) === \\'0\\') remove ++;\\n        else break;\\n    }\\n\\n    let result = num.substring(0,num.length - remove);\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587250,
                "title": "c-1-line-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585983,
                "title": "one-liner-code-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are concerned only with the zeroes at the end of the number. The constraints mention that the number does not have any leading zeroes. So, we must start from the last index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep traversing the string from the end. Continue the traversal only till you reach a point where the character at that index represents a non zero integer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(K)$$, where K represents the number of trailing zeroes in the number\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\nNo extra data structures used\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num[num.size()-1]==\\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num[num.size()-1]==\\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585324,
                "title": "regular-expression-runtime-beats-78-memory-usage-beats-91-71",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we open an expression using //\\n2. 0+ matches one or more consecutive zero characters.\\n3. $ denotes the end of the string\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582595,
                "title": "java-o-n-solution",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length();\\n        while (num.charAt(i - 1) == \\'0\\') i--;\\n        return num.substring(0, i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length();\\n        while (num.charAt(i - 1) == \\'0\\') i--;\\n        return num.substring(0, i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579564,
                "title": "javascript-indirect-approach",
                "content": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let i = -1; //index for zeros counting back from the end of num\\n    while (num.at(i) === \"0\") i--;\\n     \\n    return num.substring(0, num.length + i + 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let i = -1; //index for zeros counting back from the end of num\\n    while (num.at(i) === \"0\") i--;\\n     \\n    return num.substring(0, num.length + i + 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576438,
                "title": "javascript-2-solutions",
                "content": "# Approach 1 - Iterate\\n```\\nfunction removeTrailingZeros(num) {\\n    const result = String(num);\\n\\n    let i = result.length - 1;\\n    while (num[i] == \\'0\\') i--;\\n\\n    return result.slice(0, i + 1);\\n};\\n```\\n\\n# Approach 2 - Regular Expression\\n```\\nfunction removeTrailingZeros(num) {\\n    return num.replace(/0+$/, \\'\\');\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction removeTrailingZeros(num) {\\n    const result = String(num);\\n\\n    let i = result.length - 1;\\n    while (num[i] == \\'0\\') i--;\\n\\n    return result.slice(0, i + 1);\\n};\\n```\n```\\nfunction removeTrailingZeros(num) {\\n    return num.replace(/0+$/, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576237,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573527,
                "title": "easy-one-line-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRemove 0 at the end by trimming the string.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n       return num.TrimEnd(\\'0\\'); \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n       return num.TrimEnd(\\'0\\'); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572709,
                "title": "easy-to-understand-simple-for-loop-o-n-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction removeTrailingZeros(num: string): string {\\n    let start = -1;\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (num[i] === \\'0\\') {\\n            start = i;\\n        } else {\\n            break;\\n        }\\n    }\\n\\n    return start >= 0 ? num.slice(0, start): num;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction removeTrailingZeros(num: string): string {\\n    let start = -1;\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (num[i] === \\'0\\') {\\n            start = i;\\n        } else {\\n            break;\\n        }\\n    }\\n\\n    return start >= 0 ? num.slice(0, start): num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571965,
                "title": "easy-solution-with-a-pointer-and-substring-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(k), where k - number of zero\\'s\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string s) {\\n        int n = s.Length-1;\\n        while( s[n]==\\'0\\' && n>-1 ) { n--; }\\n        return s.Substring(0, n+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string s) {\\n        int n = s.Length-1;\\n        while( s[n]==\\'0\\' && n>-1 ) { n--; }\\n        return s.Substring(0, n+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570958,
                "title": "python3-straightforward-solution",
                "content": "Find the difference between the length of the string obtained by reversing the string and converting it to numerical form and the original string. Then cut the original string at the corresponding index.\\n\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        idx = len(str(int(num[::-1]))) - len(num)\\n        \\n        return num[:idx] if idx < 0 else num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        idx = len(str(int(num[::-1]))) - len(num)\\n        \\n        return num[:idx] if idx < 0 else num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570899,
                "title": "easy-fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n    int ind=0;\\n    for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                ind=i;\\n                break;\\n            }\\n            }\\n            return num.substring(0, ind+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n    int ind=0;\\n    for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                ind=i;\\n                break;\\n            }\\n            }\\n            return num.substring(0, ind+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570362,
                "title": "c-simple-solution",
                "content": "# Intuition\\nJust find the 1st non-zero char from the right side.\\n\\n# Approach\\nJust find the 1st non-zero char from the right side:\\n```\\nwhile (num[index] == \\'0\\')\\n{\\n    index--;\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        var index = num.Length - 1;\\n        while (num[index] == \\'0\\')\\n        {\\n            index--;\\n        }\\n        return num.Substring(0, index + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nwhile (num[index] == \\'0\\')\\n{\\n    index--;\\n}\\n```\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        var index = num.Length - 1;\\n        while (num[index] == \\'0\\')\\n        {\\n            index--;\\n        }\\n        return num.Substring(0, index + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570344,
                "title": "beginner-friendly-solution-100ms-faster",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ans ;\\n        int j = num.size()-1;\\n        \\n        while(num[j] == \\'0\\' && j >= 0){\\n            j--;\\n        }\\n        ans = num.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ans ;\\n        int j = num.size()-1;\\n        \\n        while(num[j] == \\'0\\' && j >= 0){\\n            j--;\\n        }\\n        ans = num.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570324,
                "title": "short-intuitive-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) \\n    {\\n        int i=num.size()-1;\\n        while(i>=0 && num[i]==\\'0\\')\\n        {\\n            num.pop_back();\\n            i--;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) \\n    {\\n        int i=num.size()-1;\\n        while(i>=0 && num[i]==\\'0\\')\\n        {\\n            num.pop_back();\\n            i--;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570286,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\nStart from the end of the string representation of the number.\\n\\nIterate through the characters of the string from right to left.\\n\\nCheck if the current character is \\'0\\'.\\n\\nIf the current character is \\'0\\', remove it by using the pop_back() function, which removes the last character from the string.\\n\\nRepeat steps 3-4 until a non-zero character is encountered or until the end of the string is reached.\\n\\nReturn the modified string without the trailing zeros\\n\\n\\n\\n# Approach\\nThe approach focuses on removing trailing zeros from the string representation of the number by iterating from the end and removing the \\'0\\' characters until a non-zero character is encountered. This ensures that all trailing zeros are removed, leaving the modified string without any trailing zeros.\\n\\n# Complexity\\n\\n\\n\\n\\n\\n- Time complexity:\\nThe code iterates through the characters of the string representation of the number once, from right to left. Therefore, the time complexity is proportional to the length of the input string, which is O(n), where n is the length of the string.\\n\\nWithin the loop, the code performs a constant-time check for each character to determine if it is \\'0\\' and removes it using pop_back(). These operations do not depend on the input size and do not affect the overall time complexity.\\n\\nTherefore, the overall time complexity of the code is O(n), where n is the length of the string representation of the number.\\n\\n- Space complexity:\\nThe code does not use any additional data structures that scale with the input size. It only modifies the input string in place.\\n\\nThe space complexity is determined by the input string itself. Since the string is modified in place and no additional space is used, the space complexity is O(1), which is constant.\\n\\n\\nIn summary, the time complexity of the code is O(n), where n is the length of the input string, and the space complexity is O(1), which is constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // Loop until the last character of the string is \\'0\\'\\n        while (num.back() == \\'0\\')\\n            num.pop_back(); // Remove the trailing \\'0\\' from the string\\n        \\n        return num; // Return the modified string without trailing zeros\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        // Loop until the last character of the string is \\'0\\'\\n        while (num.back() == \\'0\\')\\n            num.pop_back(); // Remove the trailing \\'0\\' from the string\\n        \\n        return num; // Return the modified string without trailing zeros\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570278,
                "title": "explained-2-liner-c-easiest-approach",
                "content": "# Code\\n```\\n string removeTrailingZeros(string num) {\\n        int i=num.length()-1; //Fix a pointer at the end of string\\n        while(i>=0 && num[i]==\\'0\\') //While last character is 0 and i>=0\\n        {\\n            num=num.substr(0,i); //Remove last character\\n            i--; //Shift pointer to left\\n        }\\n        return num;\\n    }\\n```\\n# \\u2B06\\uFE0F **PLEASE UPVOTE IF YOU UNDERSTOOD!** \\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n string removeTrailingZeros(string num) {\\n        int i=num.length()-1; //Fix a pointer at the end of string\\n        while(i>=0 && num[i]==\\'0\\') //While last character is 0 and i>=0\\n        {\\n            num=num.substr(0,i); //Remove last character\\n            i--; //Shift pointer to left\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570263,
                "title": "easy-java-solution-100-faster-0ms",
                "content": "\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n      \\n       int i=num.length()-1; \\n       while(i>=0 && num.charAt(i)==\\'0\\')\\n       {\\n            i--;\\n       }\\n        return num.substring(0,i+1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n      \\n       int i=num.length()-1; \\n       while(i>=0 && num.charAt(i)==\\'0\\')\\n       {\\n            i--;\\n       }\\n        return num.substring(0,i+1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102277,
                "title": "1-ms-solution-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n       int count = 0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                count++;\\n            }\\n            else{\\n                return  num.substring(0,num.length()-count);\\n            }\\n        }\\n        return \"\"; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n       int count = 0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i) == \\'0\\'){\\n                count++;\\n            }\\n            else{\\n                return  num.substring(0,num.length()-count);\\n            }\\n        }\\n        return \"\"; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101781,
                "title": "easy-c-concept-beats-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int pos;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num[i]!=\\'0\\'){\\n                pos = i;\\n                break;\\n            } \\n        }\\n        return num.substr(0,pos+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int pos;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num[i]!=\\'0\\'){\\n                pos = i;\\n                break;\\n            } \\n        }\\n        return num.substr(0,pos+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098148,
                "title": "php-solution-with-best",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Memory\\n19.16MB\\nBeats 44.44%of users with PHP\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n> **10ms**\\nBeats 61.11%of users with PHP\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /**\\n     * @param String $num\\n     * @return String\\n     */\\n    function removeTrailingZeros($num) {\\n        $arr = str_split($num);\\n        $count = count($arr);\\n        \\n        $lastNonZeroIndex = $count - 1;\\n        while ($lastNonZeroIndex >= 0 && $arr[$lastNonZeroIndex] === \\'0\\') {\\n            $lastNonZeroIndex--;\\n        }\\n\\n\\n        if ($lastNonZeroIndex < 0) {\\n            return \"0\";\\n        }\\n        return implode(\"\", array_slice($arr, 0, $lastNonZeroIndex + 1));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "PHP",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * @param String $num\\n     * @return String\\n     */\\n    function removeTrailingZeros($num) {\\n        $arr = str_split($num);\\n        $count = count($arr);\\n        \\n        $lastNonZeroIndex = $count - 1;\\n        while ($lastNonZeroIndex >= 0 && $arr[$lastNonZeroIndex] === \\'0\\') {\\n            $lastNonZeroIndex--;\\n        }\\n\\n\\n        if ($lastNonZeroIndex < 0) {\\n            return \"0\";\\n        }\\n        return implode(\"\", array_slice($arr, 0, $lastNonZeroIndex + 1));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095437,
                "title": "solution-in-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n  let res = num.match(/(\\\\d+)?[^0]/g);\\n  return(`${res}`);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n  let res = num.match(/(\\\\d+)?[^0]/g);\\n  return(`${res}`);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094027,
                "title": "ruby-solution-using-pointer",
                "content": "# Code\\n```\\n# @param {String} num\\n# @return {String}\\ndef remove_trailing_zeros(num)\\n    i = -1\\n    while num[i] == \"0\"\\n      i -= 1\\n    end\\n\\n    num[0..i]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} num\\n# @return {String}\\ndef remove_trailing_zeros(num)\\n    i = -1\\n    while num[i] == \"0\"\\n      i -= 1\\n    end\\n\\n    num[0..i]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4093898,
                "title": "c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.size();\\n        for(int i = n-1;i<n;i--){\\n            if(num[i]==\\'0\\'){\\n                num.pop_back();\\n            }\\n            if(num[i]!=0){\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.size();\\n        for(int i = n-1;i<n;i--){\\n            if(num[i]==\\'0\\'){\\n                num.pop_back();\\n            }\\n            if(num[i]!=0){\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092420,
                "title": "o-n-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int c=0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n               c=i;\\n               break;\\n            }\\n        }\\n    return num.substring(0,c+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int c=0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n               c=i;\\n               break;\\n            }\\n        }\\n    return num.substring(0,c+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088716,
                "title": "one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = str(int(num[::-1])) return num[::-1]\\n        \\n        \\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = str(int(num[::-1])) return num[::-1]\\n        \\n        \\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086008,
                "title": "swift-iterating-over-string-indices",
                "content": "# Intuition\\nInstead of cranking out a regular expression or making a custom `trimRight()` function, or type-juggling between `Int` and `String`, I opted to treat this like an interview problem.\\n\\n# Approach\\nIterate over each character, track the position of the last non-zero number, and returning a substring. (But not a Swift `Substring`!)\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$ -- we\\'re iterating over an array of `String.Index`\\n\\n- Space complexity: $$O(1)$$ -- we\\'re storing one `String.Index` (Correct me if I\\'m wrong.)\\n\\n# Tips\\n\\n* Unlike most languages, you can\\'t grab the `i`th character of an array.\\n* Swift creates a `Substring` object [(read more)](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters/#Substrings) which is a pretty neat way to handle string manipulation with less memory. I always feel bad for needlessly manhandling strings and arrays.\\n* A lot of solutions use `String.lastIndex {}` which solves the problem but doesn\\'t show that *you* know how to do it, which is what interviewers are testing you for.\\n\\n# Code\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n\\n        var end = num.startIndex;\\n\\n        for index in num.indices {\\n            if (num[index] != \"0\") {\\n                end = index\\n            }\\n        }\\n\\n        return String(num[...end]);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n\\n        var end = num.startIndex;\\n\\n        for index in num.indices {\\n            if (num[index] != \"0\") {\\n                end = index\\n            }\\n        }\\n\\n        return String(num[...end]);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079529,
                "title": "solution-with-regex",
                "content": "Just solution.\\n\\n# Code\\n```\\nclass Solution {\\n    fun removeTrailingZeros(num: String): String {\\n       return Regex(\"0+$\").replace (num, \"\")        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun removeTrailingZeros(num: String): String {\\n       return Regex(\"0+$\").replace (num, \"\")        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077172,
                "title": "remove-trailing-zeros-from-a-string-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        while(num.charAt(num.length()-1)==\\'0\\')\\n        num=num.substring(0,num.length()-1);\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        while(num.charAt(num.length()-1)==\\'0\\')\\n        num=num.substring(0,num.length()-1);\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072188,
                "title": "60-days-leetcode-day-2",
                "content": "Simply iterating from back and removing the zeroes.\\n\\n```class Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back()==\\'0\\')\\n            num.pop_back();\\n        return num;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back()==\\'0\\')\\n            num.pop_back();\\n        return num;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4069292,
                "title": "2710-remove-trailing-zeros-from-a-string-easy-simple-solutions",
                "content": "# Code\\n```Python []\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        num = int(num)\\n        while num % 10 == 0:\\n            num = num // 10\\n        return str(num)\\n```\\n```JavaScript []\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \\'\\')\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        num = int(num)\\n        while num % 10 == 0:\\n            num = num // 10\\n        return str(num)\\n```\n```JavaScript []\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \\'\\')\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069232,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        for i in range(len(num)-1,-1,-1):\\n            if num[i] == \\'0\\':\\n                num = num[:-1]\\n            else:\\n                break\\n        return num\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        for i in range(len(num)-1,-1,-1):\\n            if num[i] == \\'0\\':\\n                num = num[:-1]\\n            else:\\n                break\\n        return num\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068261,
                "title": "simple-and-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i) == \\'0\\') i--;\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i) == \\'0\\') i--;\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068000,
                "title": "easy-code-using-stl-funtion-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back()==\\'0\\'){\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back()==\\'0\\'){\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067668,
                "title": "easy-explained-beginner-friendly-solution",
                "content": "# Intuition\\nThe problem is asking to remove trailing zeros from a given string. Trailing zeros are the zeros that appear at the end of a number. For example, in the number \"1200\", \"00\" are trailing zeros.\\n\\n# Approach\\nThe approach used in this code is straightforward. It starts from the end of the string and checks each character. If the character is a zero and we haven\\'t encountered any non-zero character yet (indicated by `t` being 1), it removes that character from the string using `pop_back()`. As soon as it encounters a non-zero character, it sets `t` to 0, indicating that we have encountered a non-zero character and should stop removing characters.\\n\\nHere\\'s a step-by-step breakdown:\\n1. Initialize `t` to 1. This variable acts as a flag to indicate whether we have encountered a non-zero character.\\n2. Iterate over the string from the end to the beginning.\\n3. For each character, check if it\\'s a zero and `t` is still 1.\\n4. If it is, remove that character from the string.\\n5. If it\\'s not a zero, set `t` to 0.\\n\\n# Complexity\\n- Time complexity: The time complexity is $$O(n)$$ because we\\'re iterating over the string once, where $$n$$ is the length of the string.\\n- Space complexity: The space complexity is $$O(1)$$ because we\\'re not using any additional space that scales with the input size. The input string is being modified in place.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int t=1;\\n        for(int i=num.size()-1;i>=0;i--)\\n            if(num[i]==\\'0\\'&&t)\\n            num.pop_back();\\n            else\\n            t=0;\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int t=1;\\n        for(int i=num.size()-1;i>=0;i--)\\n            if(num[i]==\\'0\\'&&t)\\n            num.pop_back();\\n            else\\n            t=0;\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067201,
                "title": "easy-solution-c-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ans;\\n        int k ;\\n        for(int i=num.size()-1;i>=0;i--) {\\n                if(num[i]!=\\'0\\') {\\n                    k = i;\\n                    break;\\n                }\\n        }\\n        ans = num.substr(0,k+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ans;\\n        int k ;\\n        for(int i=num.size()-1;i>=0;i--) {\\n                if(num[i]!=\\'0\\') {\\n                    k = i;\\n                    break;\\n                }\\n        }\\n        ans = num.substr(0,k+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066840,
                "title": "one-line-replace-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    return num.replace(/0+$/, \\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066131,
                "title": "3-liner-just-skip-last-consecutive-0s",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.length()-1;\\n        while(i >= 0 && num[i] == \\'0\\') //skip all consecutive 0s from the last\\n         i--;\\n        return num.substr(0,i+1);\\n    } //return string start from \\'0\\' index anh having \\'i+1\\' length\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = num.length()-1;\\n        while(i >= 0 && num[i] == \\'0\\') //skip all consecutive 0s from the last\\n         i--;\\n        return num.substr(0,i+1);\\n    } //return string start from \\'0\\' index anh having \\'i+1\\' length\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065372,
                "title": "java-easiest-solution-beats-100-of-users-simple-while-loop",
                "content": "# Intuition\\nCheck zeroes from last of string\\n\\n# Approach\\nuse while loop as far as you encounter zeroes ; maintain an index variable initialized from last index of string ; after that , stop ; return the substring from starting upto that particular index ; and that\\'s it...!\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i) == \\'0\\') {\\n            i--;\\n        }\\n        return num.substring(0 , i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = num.length()-1;\\n        while(num.charAt(i) == \\'0\\') {\\n            i--;\\n        }\\n        return num.substring(0 , i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065106,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        for(int i = num.Length - 1; i>=0; i--)\\n        {\\n            if (num[i] != \\'0\\') return num;\\n            else num = num.Remove(num.Length - 1);\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        for(int i = num.Length - 1; i>=0; i--)\\n        {\\n            if (num[i] != \\'0\\') return num;\\n            else num = num.Remove(num.Length - 1);\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064515,
                "title": "python-slicing-approach-beats-92-15ms-13mb",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        cursor = -1\\n        while True:\\n            if num[cursor] == \"0\":\\n                cursor -= 1\\n            else:\\n                break\\n\\n        return num[0:(cursor + 1)] if cursor != -1 else num[0:]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        cursor = -1\\n        while True:\\n            if num[cursor] == \"0\":\\n                cursor -= 1\\n            else:\\n                break\\n\\n        return num[0:(cursor + 1)] if cursor != -1 else num[0:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063814,
                "title": "simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing reverse loop to detedct if there is any number other than 0 that means tailing zero are ending here, so we will just slice the string from there\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let newS = \\'\\'\\n    for(let i = num.length -1; i=>0; i--){\\n        if(num[i]!==\\'0\\'){\\n            return num.slice(0,i+1)\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    let newS = \\'\\'\\n    for(let i = num.length -1; i=>0; i--){\\n        if(num[i]!==\\'0\\'){\\n            return num.slice(0,i+1)\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062184,
                "title": "beat-88-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        pos=0\\n        for i in range(len(num)-1,-1,-1):\\n            if num[i]!=\\'0\\':\\n                pos=i\\n                break\\n        return num[:pos+1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        pos=0\\n        for i in range(len(num)-1,-1,-1):\\n            if num[i]!=\\'0\\':\\n                pos=i\\n                break\\n        return num[:pos+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061476,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = 0;\\n        int j = num.length() - 1;\\n        while (i < num.length() && num.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (j >= 0 && num.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        return num.substring(0, j + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i = 0;\\n        int j = num.length() - 1;\\n        while (i < num.length() && num.charAt(i) == \\'0\\') {\\n            i++;\\n        }\\n        while (j >= 0 && num.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        return num.substring(0, j + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052010,
                "title": "python3-one-liner-rstrip",
                "content": "# Intuition/Approach\\n- Right Strip (Remove All Trailing Zeros/Zeros at the End) the *num* String.\\n- Python Already Has the Built-in Function *rstrip()*.\\n\\n# Complexity\\n- Time Complexity: $$O(k)$$ where *k = number of 0\\'s at the end of num*.\\n    - Absolute Worst Case Would be $$O(n)$$ where *n = the len(num)* if *num* only contained *0\\'s*.\\n- Space Complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        return num.rstrip(\\'0\\')\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051789,
                "title": "python-easy-to-understand-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        numlen=len(num)-1\\n        i =numlen\\n        count=0\\n        while i >= 0:\\n            if int(num[i]) < 1:\\n                count +=1\\n            else:\\n                break\\n            i -=1\\n        return num[0:len(num)-count]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        numlen=len(num)-1\\n        i =numlen\\n        count=0\\n        while i >= 0:\\n            if int(num[i]) < 1:\\n                count +=1\\n            else:\\n                break\\n            i -=1\\n        return num[0:len(num)-count]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050827,
                "title": "beats-100-00-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        int i=num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }\\n\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        int i=num.length()-1;\\n        while(num.charAt(i)==\\'0\\'){\\n            i--;\\n        }\\n\\n        return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050492,
                "title": "easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to only trailing zeros  simply we think about that we have to loop over string until we find character other then zero .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. start loop from string length to 0 \\n    2. check if the ith character is zero then remove it \\n    3. remove character by using substring method \\n    4. num will re assign with num.substring(0,i) which exclude last character automaticaly \\n    5.  if not the case return num\\n    6. edge case if all the character of string is zero the  we return empty string .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                num=num.substring(0,i);\\n            }else return num;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        \\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                num=num.substring(0,i);\\n            }else return num;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048584,
                "title": "java-1-ms-solution-beats-100-of-users",
                "content": "\\n# Complexity\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n## Time complexity:  1 ms\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int length = num.length();\\n        if (length == 1 && num.charAt(0) == \\'0\\') {\\n            return \"0\";\\n        }\\n        int endIndex = length - 1;\\n        while (endIndex >= 0 && num.charAt(endIndex) == \\'0\\') {\\n            endIndex--;\\n        }\\n        if (endIndex == -1) {\\n            return \"0\";\\n        }\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int length = num.length();\\n        if (length == 1 && num.charAt(0) == \\'0\\') {\\n            return \"0\";\\n        }\\n        int endIndex = length - 1;\\n        while (endIndex >= 0 && num.charAt(endIndex) == \\'0\\') {\\n            endIndex--;\\n        }\\n        if (endIndex == -1) {\\n            return \"0\";\\n        }\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046635,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n  let result = \"\"\\n  for (i = num.length - 1; i >= 0; i--) {\\n    if (num[i] !== \"0\" || result.length > 0) {\\n      result = num[i] + result\\n    }\\n  }\\n  return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n  let result = \"\"\\n  for (i = num.length - 1; i >= 0; i--) {\\n    if (num[i] !== \"0\" || result.length > 0) {\\n      result = num[i] + result\\n    }\\n  }\\n  return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045077,
                "title": "const-js-ts-great-explanation",
                "content": "**CODE**\\n```typescript\\nfunction removeTrailingZeros(num: string): string {\\n    let index = -1;\\n    for (let i = num.length - 1; i >= 0; --i) {\\n        debugger;\\n        if (num[i] !== \\'0\\') {\\n            index = i;\\n            break;\\n        }\\n    }\\n    return num.slice(0, index + 1);\\n}\\n```\\n\\nExplanation:\\n\\n1. The function `removeTrailingZeros` takes a string `num` as input and aims to remove trailing zeros from it.\\n\\n2. It initializes an `index` variable to -1. This variable will be used to keep track of the position of the last non-zero digit in the input string.\\n\\n3. The function enters a loop that iterates through the characters of the input string `num` from right to left using the variable `i`.\\n\\n4. Within the loop, it uses the `debugger` statement to pause execution for debugging purposes.\\n\\n5. It checks if the current character `num[i]` is not equal to \\'0\\'. If it\\'s not \\'0\\', it updates the `index` variable with the current position `i` and breaks out of the loop. This effectively finds the rightmost non-zero digit in the string.\\n\\n6. Finally, it uses the `index` to slice the original string from the beginning to the `index` position (inclusive) using `num.slice(0, index + 1)` and returns the resulting string.\\n\\nTime Complexity:\\n- The loop iterates through the input string from right to left once. In the worst case, it iterates through the entire string. Therefore, the time complexity of this function is O(n), where n is the length of the input string.\\n\\nSpace Complexity:\\n- The function only uses a few integer variables (`index`, `i`) and does not create any data structures that depend on the input size. It returns a new string, but the space used for this new string is proportional to the length of the output, so the space complexity is O(n), where n is the length of the output string.\\n\\nHere\\'s a diagram to illustrate the function\\'s behavior:\\n```\\nInput: \"120500\"\\n                   ^ (Last non-zero digit at index 3)\\nOutput: \"1205\"\\n```\\n\\nIn this example, the function removes the trailing zeros and returns the modified string \"1205.\"",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction removeTrailingZeros(num: string): string {\\n    let index = -1;\\n    for (let i = num.length - 1; i >= 0; --i) {\\n        debugger;\\n        if (num[i] !== \\'0\\') {\\n            index = i;\\n            break;\\n        }\\n    }\\n    return num.slice(0, index + 1);\\n}\\n```\n```\\nInput: \"120500\"\\n                   ^ (Last non-zero digit at index 3)\\nOutput: \"1205\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044133,
                "title": "easy-approach-using-java-beats-100-1-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo count the tailing zeroes \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   To count the tailing zeroes and return the substring by removing the zeros count from the length of the string \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n      int len = num.length()-1;int c=0;\\n      while(true)\\n      {\\n          if(num.charAt(len)==\\'0\\')\\n          {\\n                c++;\\n          }\\n          else\\n          {\\n              break;\\n          }\\n          len = len-1;\\n      }\\n      return num.substring(0,num.length()-c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n      int len = num.length()-1;int c=0;\\n      while(true)\\n      {\\n          if(num.charAt(len)==\\'0\\')\\n          {\\n                c++;\\n          }\\n          else\\n          {\\n              break;\\n          }\\n          len = len-1;\\n      }\\n      return num.substring(0,num.length()-c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043661,
                "title": "c-clean-code-fully-explained-solution",
                "content": "In this problem , we have a positive integer , note that the parameter is given in the form of a string. We need to remove trailing zeros , i.e the 0\\'s from the end. Note that in the constraints section we are guarenteed that the number >= 1 , so we don\\'t consider the case of 0 , and also it does not contain any leading zeros.\\n\\nSo we can just check the current last digit of the number and if it is zero remove it.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.back() == \\'0\\') num.pop_back();\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042198,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i=num.size()-1;\\n            while(num[i]==\\'0\\')\\n                i--;\\n                return num.substr(0,i+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i=num.size()-1;\\n            while(num[i]==\\'0\\')\\n                i--;\\n                return num.substr(0,i+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041467,
                "title": "easy-understandable-java-solution-using-flag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        if(num.equals(\"0\") || num.charAt(num.length()-1) != \\'0\\')\\n            return num;\\n\\n        boolean firstTrailingZero = false;\\n        int endIndex = 0;\\n\\n        for(int i=num.length()-1; i>=0; i--) {\\n            if(firstTrailingZero==false && num.charAt(i) == \\'0\\') {\\n                firstTrailingZero = true;\\n                continue;\\n            } if(firstTrailingZero==true && num.charAt(i) == \\'0\\') {\\n                continue;\\n            } if(firstTrailingZero==true && num.charAt(i) != \\'0\\') {\\n                endIndex = i;\\n                break;\\n            }\\n        } return num.substring(0, endIndex+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        if(num.equals(\"0\") || num.charAt(num.length()-1) != \\'0\\')\\n            return num;\\n\\n        boolean firstTrailingZero = false;\\n        int endIndex = 0;\\n\\n        for(int i=num.length()-1; i>=0; i--) {\\n            if(firstTrailingZero==false && num.charAt(i) == \\'0\\') {\\n                firstTrailingZero = true;\\n                continue;\\n            } if(firstTrailingZero==true && num.charAt(i) == \\'0\\') {\\n                continue;\\n            } if(firstTrailingZero==true && num.charAt(i) != \\'0\\') {\\n                endIndex = i;\\n                break;\\n            }\\n        } return num.substring(0, endIndex+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040422,
                "title": "java-easy-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int count = 0;\\n        for (int i = num.length() - 1; i > 0; i--)\\n            if (num.charAt(i) == \\'0\\') count++;\\n            else break;\\n\\n        return num.substring(0, num.length() - count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int count = 0;\\n        for (int i = num.length() - 1; i > 0; i--)\\n            if (num.charAt(i) == \\'0\\') count++;\\n            else break;\\n\\n        return num.substring(0, num.length() - count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036351,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                return num.substring(0,i+1);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                return num.substring(0,i+1);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035496,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n         \\n       int i=num.length()-1; \\n       while(i>=0 && num.charAt(i)==\\'0\\')\\n       {\\n            i--;\\n       }\\n        return num.substring(0,i+1);\\n    }\\n        \\n }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n         \\n       int i=num.length()-1; \\n       while(i>=0 && num.charAt(i)==\\'0\\')\\n       {\\n            i--;\\n       }\\n        return num.substring(0,i+1);\\n    }\\n        \\n }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032517,
                "title": "beginners-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        String res =num;\\n\\t        for(int i = num.length()-1 ; i>=0 ; i--) {\\n\\t        \\tif(num.charAt(i)!=\\'0\\') {\\n\\t        \\t\\tres = num.substring(0, i+1);\\n\\t        \\t\\tbreak;\\n\\t        \\t}\\n\\t        }\\n\\t        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        String res =num;\\n\\t        for(int i = num.length()-1 ; i>=0 ; i--) {\\n\\t        \\tif(num.charAt(i)!=\\'0\\') {\\n\\t        \\t\\tres = num.substring(0, i+1);\\n\\t        \\t\\tbreak;\\n\\t        \\t}\\n\\t        }\\n\\t        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027541,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this code is to remove trailing zeros from a given string representation of a number. Trailing zeros are zeros that appear at the end of the number and do not affect its value. The code aims to trim these trailing zeros while preserving the rest of the number\\'s digits.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable n to store the length of the input string num.\\n\\n2. Start a loop from the end of the string (rightmost character) and iterate towards the beginning.\\n\\n3. Within the loop, check each character from right to left. If the character is not \\'0\\', it means we have reached a non-zero digit that is not part of the trailing zeros.\\n\\n4. When a non-zero digit is encountered, update the value of n to the index of this digit plus one (i.e., n = i + 1) to indicate the new length of the string after removing trailing zeros. Break out of the loop since there is no need to continue checking the remaining characters.\\n\\n5. Finally, return a substring of the input string num from index 0 to n. This substring contains the original number without trailing zeros.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int n = num.length();\\n\\n        for (int i = n - 1; i >= 0; i--){\\n            if (num.charAt(i) != \\'0\\'){\\n                n = i + 1;\\n                break;\\n            }\\n        }        \\n\\n        return num.substring(0, n);\\n    }\\n}\\n\\n```\\n![Frame 76.png](https://assets.leetcode.com/users/images/71a1b987-2ac3-4610-82ee-d6dddd301d6e_1694360602.6338625.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int n = num.length();\\n\\n        for (int i = n - 1; i >= 0; i--){\\n            if (num.charAt(i) != \\'0\\'){\\n                n = i + 1;\\n                break;\\n            }\\n        }        \\n\\n        return num.substring(0, n);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024104,
                "title": "easy-and-clean-solution-swift",
                "content": "# Code\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n    var res = num\\n    while res.last == \"0\" {\\n        res.removeLast()\\n    }\\n    return res\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n    var res = num\\n    while res.last == \"0\" {\\n        res.removeLast()\\n    }\\n    return res\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024072,
                "title": "simple-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i= num.length()-1; i>=0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                sb.append(num.substring(0,i+1));\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i= num.length()-1; i>=0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                sb.append(num.substring(0,i+1));\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019875,
                "title": "5-steps-solution",
                "content": "# Intuition\\nConvert String to Array to use array methods\\n\\n---\\n\\n# Approach\\n1. Convert String to Array\\n2. Loop through array in reverse order \\n3. If you find a \"0\" then pop it\\n4. else break from the loop\\n5. Convert Array to string and return it\\n\\n---\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    <!-- 1. Convert String to Array -->\\n    let arr = num.split(\"\");\\n    <!-- 2. Loop through array in reverse order  -->\\n    for(let i=arr.length-1; i>=0; i--){\\n    <!-- 3. If you find a \"0\" then pop it -->\\n        if(arr[i]===\"0\"){\\n            arr.pop();\\n    <!-- 4. else break from the loop -->\\n        }else{\\n            break;\\n        }\\n    }\\n    <!-- 5. Convert Array to string and return it -->\\n    return arr.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n    <!-- 1. Convert String to Array -->\\n    let arr = num.split(\"\");\\n    <!-- 2. Loop through array in reverse order  -->\\n    for(let i=arr.length-1; i>=0; i--){\\n    <!-- 3. If you find a \"0\" then pop it -->\\n        if(arr[i]===\"0\"){\\n            arr.pop();\\n    <!-- 4. else break from the loop -->\\n        }else{\\n            break;\\n        }\\n    }\\n    <!-- 5. Convert Array to string and return it -->\\n    return arr.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019431,
                "title": "one-liner-ts-js-solution",
                "content": "```ts\\nfunction removeTrailingZeros(num: string): string {\\n    return num.replace(/^0+|0+$/g, \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction removeTrailingZeros(num: string): string {\\n    return num.replace(/^0+|0+$/g, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011125,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int i = num.length() - 1;\\n        \\n        for( ; i >= 0; i--) {\\n            if(num.charAt(i) != \\'0\\') break;\\n        }\\n\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int i = num.length() - 1;\\n        \\n        for( ; i >= 0; i--) {\\n            if(num.charAt(i) != \\'0\\') break;\\n        }\\n\\n        return num.substring(0, i + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011089,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ansString=\"\";\\n        int lastIndex;\\n        int i;\\n        for(i=num.length()-1;i>0;i--){\\n            if(num[i]!=\\'0\\'){\\n                lastIndex=i;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<=lastIndex;j++){\\n            ansString += num[j];\\n        }\\n        //.substr can be used instead of mainitaing last index and running for loop\\n        //ansString = num.substr(0, i+1);\\n\\n        return ansString;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        string ansString=\"\";\\n        int lastIndex;\\n        int i;\\n        for(i=num.length()-1;i>0;i--){\\n            if(num[i]!=\\'0\\'){\\n                lastIndex=i;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<=lastIndex;j++){\\n            ansString += num[j];\\n        }\\n        //.substr can be used instead of mainitaing last index and running for loop\\n        //ansString = num.substr(0, i+1);\\n\\n        return ansString;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009534,
                "title": "java-one-line-regular-expression",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        return num.replaceAll(\"0+$\", \"\");\\n    }\\n}\\n```\\n\\n**0** :  This matches the \"0\" character only.\\n**+**:  The \"+\" sign means to match the character \"0\" one or more times.\\n**\\\\$**:  The \\\\$ sign indicates that the match must be at the end of the string.\\n\\n***So, \"0+$\" is a regex expression that only matches \"0\" characters at the end of a string.***\\n\\n```\\nbool shouldYouUpvote(){ return (I helped == true) ? upvote : nothing; }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        return num.replaceAll(\"0+$\", \"\");\\n    }\\n}\\n```\n```\\nbool shouldYouUpvote(){ return (I helped == true) ? upvote : nothing; }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006454,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJava Easy Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int zeroCount =0;\\n\\t\\tfor(int i = num.length()-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(num.charAt(i) != \\'0\\') \\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else\\n\\t\\t\\t{\\n\\t\\t\\t\\tzeroCount ++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\n\\t    String str = num.substring(0, num.length()-zeroCount);\\n        return str; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int zeroCount =0;\\n\\t\\tfor(int i = num.length()-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(num.charAt(i) != \\'0\\') \\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else\\n\\t\\t\\t{\\n\\t\\t\\t\\tzeroCount ++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\n\\t    String str = num.substring(0, num.length()-zeroCount);\\n        return str; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005178,
                "title": "removing-trailing-zeroes-from-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n       StringBuilder sb = new StringBuilder();\\n       int i=0;\\n       for( i=num.length()-1;i>=0;i--){\\n           \\n           if(num.charAt(i) != \\'0\\'){\\n               break;\\n           }\\n           \\n       }\\n       \\n\\n       return num.substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n       StringBuilder sb = new StringBuilder();\\n       int i=0;\\n       for( i=num.length()-1;i>=0;i--){\\n           \\n           if(num.charAt(i) != \\'0\\'){\\n               break;\\n           }\\n           \\n       }\\n       \\n\\n       return num.substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001756,
                "title": "1ms-beats-100-00-3-lines-code-substring",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length() - 1;\\n        while (endIndex >= 0 && num.charAt(endIndex) == \\'0\\') {\\n            endIndex--;\\n        }\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length() - 1;\\n        while (endIndex >= 0 && num.charAt(endIndex) == \\'0\\') {\\n            endIndex--;\\n        }\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999881,
                "title": "using-for-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=num.length()-1;i>=0;i--){\\n           \\n                if(num.charAt(i)!=\\'0\\'){\\n                  return num.substring(0,i+1);}\\n        }\\n       return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=num.length()-1;i>=0;i--){\\n           \\n                if(num.charAt(i)!=\\'0\\'){\\n                  return num.substring(0,i+1);}\\n        }\\n       return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995823,
                "title": "simple-java-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        for(int i = num.length() - 1; i>=0; i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                return num.substring(0,i+1);\\n            }\\n        }\\n\\n        return num;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        for(int i = num.length() - 1; i>=0; i--){\\n            if(num.charAt(i)!=\\'0\\'){\\n                return num.substring(0,i+1);\\n            }\\n        }\\n\\n        return num;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995194,
                "title": "typescript-javascript-two-simple-solutions-regexp-and-loop",
                "content": "# Code\\n```\\nfunction removeTrailingZeros(num: string): string {\\n    return num.replace(/0+$/, \\'\\');\\n};\\n\\n```\\n\\n```\\nfunction removeTrailingZeros(num: string): string {\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (num[i] !== \\'0\\') {\\n            return num.slice(0, i + 1)\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction removeTrailingZeros(num: string): string {\\n    return num.replace(/0+$/, \\'\\');\\n};\\n\\n```\n```\\nfunction removeTrailingZeros(num: string): string {\\n    for (let i = num.length - 1; i >= 0; i--) {\\n        if (num[i] !== \\'0\\') {\\n            return num.slice(0, i + 1)\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990030,
                "title": "easiest-solution-java-one-line-code-direct-approch",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck from last of string if last element =0;\\nreturn that substring else continue\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(num.length()-i-1)!=\\'0\\'){\\n                return num.substring(0,num.length()-i);\\n            }\\n        } return num;\\n        \\n\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(num.length()-i-1)!=\\'0\\'){\\n                return num.substring(0,num.length()-i);\\n            }\\n        } return num;\\n        \\n\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983815,
                "title": "100-efficient-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int c=num.length();\\n        int n=0;\\n        int t=0;\\n        String s=\"\";\\n    for(int i= num.length();i>=0;i--)\\n    {\\n        if(num.charAt(i-1)==\\'0\\')\\n        {\\n            n++;  \\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n        t=c-n;\\n        \\n       \\n      return num.substring(0,t);\\n    }\\n        \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int c=num.length();\\n        int n=0;\\n        int t=0;\\n        String s=\"\";\\n    for(int i= num.length();i>=0;i--)\\n    {\\n        if(num.charAt(i-1)==\\'0\\')\\n        {\\n            n++;  \\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n        t=c-n;\\n        \\n       \\n      return num.substring(0,t);\\n    }\\n        \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983635,
                "title": "java-easy-and-optimised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        String s=\"\";\\n     \\n        char a=\\'0\\';\\n        for(int i=num.length()-1;i>=0;i--){\\n            char b=num.charAt(i);\\n            if(a!=b){\\n                s=num.substring(0,i+1);\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        String s=\"\";\\n     \\n        char a=\\'0\\';\\n        for(int i=num.length()-1;i>=0;i--){\\n            char b=num.charAt(i);\\n            if(a!=b){\\n                s=num.substring(0,i+1);\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982900,
                "title": "java-easy-one-line",
                "content": "\\tclass Solution {\\n\\t\\tpublic String removeTrailingZeros(String num) {\\n\\t\\t\\tint i = num.length()-1; \\n\\t\\t\\t// check index out of bound and match the character\\n\\t\\t\\twhile(i>=0 && num.charAt(i) == \\'0\\')i--;\\n\\t\\t\\treturn num.substring(0, i+1);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic String removeTrailingZeros(String num) {\\n\\t\\t\\tint i = num.length()-1; \\n\\t\\t\\t// check index out of bound and match the character\\n\\t\\t\\twhile(i>=0 && num.charAt(i) == \\'0\\')i--;\\n\\t\\t\\treturn num.substring(0, i+1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3981344,
                "title": "easy-java-solution",
                "content": "****Bold****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i=num.length()-1;\\n        String res=num;\\n        while(i>=0 && num.charAt(i)==\\'0\\'){\\n            res=num.substring(0,i);\\n            i--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int i=num.length()-1;\\n        String res=num;\\n        while(i>=0 && num.charAt(i)==\\'0\\'){\\n            res=num.substring(0,i);\\n            i--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972219,
                "title": "java-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length();\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) == \\'0\\') {\\n                endIndex = i;\\n            } else break;\\n        }\\n        return num.substring(0, endIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length();\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) == \\'0\\') {\\n                endIndex = i;\\n            } else break;\\n        }\\n        return num.substring(0, endIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972180,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.size() > 0 && num.back() == \\'0\\'){\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        while(num.size() > 0 && num.back() == \\'0\\'){\\n            num.pop_back();\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971465,
                "title": "simple-c-code",
                "content": "# Code\\n```\\nchar * removeTrailingZeros(char * num){\\n    int end = strlen(num) - 1;\\n    while(end >= 0 )\\n    {\\n        if(num[end] != \\'0\\')\\n            break;\\n        end--;\\n    }\\n    num[end+1] = \\'\\\\0\\';\\n    return num;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * removeTrailingZeros(char * num){\\n    int end = strlen(num) - 1;\\n    while(end >= 0 )\\n    {\\n        if(num[end] != \\'0\\')\\n            break;\\n        end--;\\n    }\\n    num[end+1] = \\'\\\\0\\';\\n    return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970674,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        ArrayList<Character> list = new ArrayList<>();\\n        char ch[] = num.toCharArray();\\n        for(char c:ch){\\n            list.add(c);\\n        }\\n\\n        for(int i=list.size()-1;i>=0;i--){\\n            if(list.get(i)==\\'0\\'){\\n                list.remove(i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        String s = \"\";\\n        for(char c:list){\\n            System.out.print(c+\" \");\\n            s = s + c;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        ArrayList<Character> list = new ArrayList<>();\\n        char ch[] = num.toCharArray();\\n        for(char c:ch){\\n            list.add(c);\\n        }\\n\\n        for(int i=list.size()-1;i>=0;i--){\\n            if(list.get(i)==\\'0\\'){\\n                list.remove(i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        String s = \"\";\\n        for(char c:list){\\n            System.out.print(c+\" \");\\n            s = s + c;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963036,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int l = num.length();\\n        int count = 0;\\n       for(int i=l-1; i>=0; i--)\\n       {\\n           count = i+1;\\n           if(num.charAt(i)!=\\'0\\')\\n                 break;\\n       }\\n       return num.substring(0,count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int l = num.length();\\n        int count = 0;\\n       for(int i=l-1; i>=0; i--)\\n       {\\n           count = i+1;\\n           if(num.charAt(i)!=\\'0\\')\\n                 break;\\n       }\\n       return num.substring(0,count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962841,
                "title": "java-faster-o-n-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Thought of solving this problem is to start from LHS of String but that will create difficulty to find index from where trailing zeros has started. \\n\\nSo, Starting from RHS will make task easier. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Start checking for character other than 0 from the right hand side of the String.\\nIf character other  than 0 is found take substring from 0 to that index+1 and break the loop.\\n\\nAt last return the String.\\n   \\n\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n       for(int i=num.length()-1;i>=0;i--)\\n       {\\n         if(num.charAt(i)!=\\'0\\')\\n         {\\n             num=num.substring(0,i+1);\\n             break;\\n         }\\n       } \\n       return num;\\n    }\\n}\\n```\\n\\n\\n\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/4dce6875-509b-4802-b150-1203a1ab14e1_1693052737.0256257.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n       for(int i=num.length()-1;i>=0;i--)\\n       {\\n         if(num.charAt(i)!=\\'0\\')\\n         {\\n             num=num.substring(0,i+1);\\n             break;\\n         }\\n       } \\n       return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952443,
                "title": "simple-java-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count=0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            char ch=num.charAt(i);\\n            if(ch==\\'0\\'){\\n                count++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return num.substring(0,num.length()-count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count=0;\\n        for(int i=num.length()-1;i>=0;i--){\\n            char ch=num.charAt(i);\\n            if(ch==\\'0\\'){\\n                count++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return num.substring(0,num.length()-count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950800,
                "title": "easy-c-approach-using-linear-search-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string s) {\\n     int idx=0;\\n    for(int i=0;i<s.size();i++)\\n    {\\n        if(s[i]!=\\'0\\')\\n        {\\n            idx=i;\\n        }\\n    }\\n    cout<<idx<<endl;\\n    string ans=\"\";\\n    for(int i=0;i<idx+1;i++)\\n    {\\n        ans+=s[i];\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string s) {\\n     int idx=0;\\n    for(int i=0;i<s.size();i++)\\n    {\\n        if(s[i]!=\\'0\\')\\n        {\\n            idx=i;\\n        }\\n    }\\n    cout<<idx<<endl;\\n    string ans=\"\";\\n    for(int i=0;i<idx+1;i++)\\n    {\\n        ans+=s[i];\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3949261,
                "title": "remove-trailing-zeros-from-a-string-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int lastIndex = num.length() - 1;\\n        while(lastIndex >= 0 && num.charAt(lastIndex) == \\'0\\')\\n        {\\n            lastIndex--;\\n        }\\n        return num.substring(0,lastIndex+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int lastIndex = num.length() - 1;\\n        while(lastIndex >= 0 && num.charAt(lastIndex) == \\'0\\')\\n        {\\n            lastIndex--;\\n        }\\n        return num.substring(0,lastIndex+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947631,
                "title": "simple-c-solution-beats-99",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        bool seen = false;\\n        int i = num.size() - 1;\\n      \\n        while(!seen){\\n          if(!seen && num[i] == \\'0\\'){\\n            i--;\\n          }\\n          else if(!seen && num[i] != \\'0\\'){\\n            seen = true;\\n          }\\n        }\\n\\n        return {num.begin(), num.begin() + (i + 1)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        bool seen = false;\\n        int i = num.size() - 1;\\n      \\n        while(!seen){\\n          if(!seen && num[i] == \\'0\\'){\\n            i--;\\n          }\\n          else if(!seen && num[i] != \\'0\\'){\\n            seen = true;\\n          }\\n        }\\n\\n        return {num.begin(), num.begin() + (i + 1)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946303,
                "title": "most-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njust simple\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        r = len(num)-1\\n        while num[r]==\"0\":\\n            r-=1\\n        return num[:r+1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        r = len(num)-1\\n        while num[r]==\"0\":\\n            r-=1\\n        return num[:r+1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943570,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) != \\'0\\') {\\n                return num.substring(0, i + 1);\\n            } \\n        }\\n\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) != \\'0\\') {\\n                return num.substring(0, i + 1);\\n            } \\n        }\\n\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942832,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n      var c = 0;\\n      for (int i = num.length - 1; i >= 0; i--) {\\n          if (num[i] == \"0\") {\\n              c += 1;\\n          } else {\\n              break;\\n          }\\n      }\\n\\n      return num.substring(0, num.length - c);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n      var c = 0;\\n      for (int i = num.length - 1; i >= 0; i--) {\\n          if (num[i] == \"0\") {\\n              c += 1;\\n          } else {\\n              break;\\n          }\\n      }\\n\\n      return num.substring(0, num.length - c);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942817,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we reverse the string, any trailing zeroes would now be \"leading\"\\nFor example:\\n\"1230\" -> \"0321\"\\n\\nWe can parse this to a BigInt which will get rid of any \"leading\" zeroes and convert it back to a string\\n\\nBigInt.parse(\"0321\") -> 321 -> \"321\"\\n\\nAfterwards, we reverse the string again, getting the answer without the trailing zeroes\\n\\n\"321\" -> \"123\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n      final r = num.split(\\'\\').reversed.join();\\n      final s = BigInt.parse(r).toString();\\n      return s.split(\\'\\').reversed.join();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n      final r = num.split(\\'\\').reversed.join();\\n      final s = BigInt.parse(r).toString();\\n      return s.split(\\'\\').reversed.join();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933742,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count=0;\\n        int n=num.length();\\n        for(int i=0;i<n;i++){\\n\\n            if(num.charAt(i)==\\'0\\'){\\n            count++;\\n            }else{\\n                count=0;\\n            }\\n\\n        }\\n       \\n\\n        return num.substring(0,n-count);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int count=0;\\n        int n=num.length();\\n        for(int i=0;i<n;i++){\\n\\n            if(num.charAt(i)==\\'0\\'){\\n            count++;\\n            }else{\\n                count=0;\\n            }\\n\\n        }\\n       \\n\\n        return num.substring(0,n-count);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930765,
                "title": "dart-regexp-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n    final index = num.indexOf(RegExp(r\\'0+$\\'));\\n    if(index == -1) return num;\\n    return num.substring(0, index);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String removeTrailingZeros(String num) {\\n    final index = num.indexOf(RegExp(r\\'0+$\\'));\\n    if(index == -1) return num;\\n    return num.substring(0, index);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928924,
                "title": "algorithmic-way-of-solving-it-in-python-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        rev = num[::-1]\\n        count_zero = 0\\n        for i in range(len(rev)):\\n            if rev[i] in \\'123456789\\':\\n                break\\n            if rev[i] == \\'0\\':\\n                count_zero+=1\\n                continue\\n\\n        print(int(num))\\n        return str(int(num) // 10 ** count_zero)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        rev = num[::-1]\\n        count_zero = 0\\n        for i in range(len(rev)):\\n            if rev[i] in \\'123456789\\':\\n                break\\n            if rev[i] == \\'0\\':\\n                count_zero+=1\\n                continue\\n\\n        print(int(num))\\n        return str(int(num) // 10 ** count_zero)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927825,
                "title": "hacky-one-liner-in-ruby",
                "content": "# Code\\n```\\n# @param {String} num\\n# @return {String}\\ndef remove_trailing_zeros(num)\\n  num.to_s.reverse.to_i.to_s.reverse\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} num\\n# @return {String}\\ndef remove_trailing_zeros(num)\\n  num.to_s.reverse.to_i.to_s.reverse\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3924662,
                "title": "simple-elixir-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec remove_trailing_zeros(num :: String.t()) :: String.t()\\n  def remove_trailing_zeros(num) do\\n    # step 1 - Convert string into an integer\\n    int_val = String.to_integer(num)\\n    lose_trailing_zeros(int_val)\\n  end\\n\\n  defp lose_trailing_zeros(n) when rem(n, 10) != 0 do\\n    Integer.to_string(n)\\n  end\\n\\n  defp lose_trailing_zeros(n) do\\n    lose_trailing_zeros(div(n, 10))\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndefmodule Solution do\\n  @spec remove_trailing_zeros(num :: String.t()) :: String.t()\\n  def remove_trailing_zeros(num) do\\n    # step 1 - Convert string into an integer\\n    int_val = String.to_integer(num)\\n    lose_trailing_zeros(int_val)\\n  end\\n\\n  defp lose_trailing_zeros(n) when rem(n, 10) != 0 do\\n    Integer.to_string(n)\\n  end\\n\\n  defp lose_trailing_zeros(n) do\\n    lose_trailing_zeros(div(n, 10))\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3923240,
                "title": "c-solution-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = 0;\\n        for(i = num.size()-1;i>= 0;i--){\\n            if(num[i] != \\'0\\'){\\n                break;\\n            }\\n        }\\n        return num.substr(0,i+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i = 0;\\n        for(i = num.size()-1;i>= 0;i--){\\n            if(num[i] != \\'0\\'){\\n                break;\\n            }\\n        }\\n        return num.substr(0,i+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922529,
                "title": "easy-solution-in-two-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.size()-1;\\n        while(n>=0){\\n            // int val = (num[n]-\\'0\\');\\n            if(num[n]-\\'0\\'==0){\\n             num.pop_back();\\n              n--;\\n            }else{\\n                // n--;\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int n = num.size()-1;\\n        while(n>=0){\\n            // int val = (num[n]-\\'0\\');\\n            if(num[n]-\\'0\\'==0){\\n             num.pop_back();\\n              n--;\\n            }else{\\n                // n--;\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921171,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i = num.length() - 1; i >= 0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                return num.substring(0,i + 1);\\n            }\\n        }\\n        return \"\";\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        for(int i = num.length() - 1; i >= 0; i--){\\n            if(num.charAt(i) != \\'0\\'){\\n                return num.substring(0,i + 1);\\n            }\\n        }\\n        return \"\";\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919702,
                "title": "beats-95-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        j= len(num) -1\\n        while j >= 0:\\n            if num[j] == \"0\":\\n                j -= 1\\n            else:\\n                break\\n\\n        return num[:j+1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        j= len(num) -1\\n        while j >= 0:\\n            if num[j] == \"0\":\\n                j -= 1\\n            else:\\n                break\\n\\n        return num[:j+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919397,
                "title": "one-line-python-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        return num.rstrip(\\'0\\') if num != \\'0\\' else \\'0\\'\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeTrailingZeros(self, num):\\n        return num.rstrip(\\'0\\') if num != \\'0\\' else \\'0\\'\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918653,
                "title": "python-here-is-my-simple-solution-easy-understanding",
                "content": "Thanks for reading :)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = list(num)\\n        if num[-1] == \\'0\\':\\n            while True:\\n                num.pop()\\n                if num[-1] != \\'0\\':\\n                    break\\n        return \\'\\'.join(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = list(num)\\n        if num[-1] == \\'0\\':\\n            while True:\\n                num.pop()\\n                if num[-1] != \\'0\\':\\n                    break\\n        return \\'\\'.join(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917375,
                "title": "simple-solution-with-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        if let lastNonZeroIndex = num.lastIndex(where: { $0 != \"0\" }) {\\n            return String(num[num.startIndex...lastNonZeroIndex])\\n        }\\n        return \"0\" \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        if let lastNonZeroIndex = num.lastIndex(where: { $0 != \"0\" }) {\\n            return String(num[num.startIndex...lastNonZeroIndex])\\n        }\\n        return \"0\" \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916196,
                "title": "swift-simple-way-don-t-use-any-swift-api",
                "content": "# Code\\n\\n### Simple way (Don\\'t use any Swift API)\\n\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        var nums = Array(num)\\n        for i in 0..<nums.count {\\n            if nums[nums.count-1-i] != \"0\" {\\n                var sum = \"\"\\n                for char in nums[0...nums.count-1-i] {\\n                    sum += String(char)\\n                }\\n                return sum\\n            }\\n        }\\n        return num\\n    }\\n}\\n```\\n\\n### More Swify code\\n\\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        var nums = Array(num)\\n        for i in 0..<nums.count where nums[nums.count-1-i] != \"0\" {\\n            return nums[0...nums.count-1-i].map { String($0) }.reduce(into: String(), +=)\\n        }\\n        return num\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        var nums = Array(num)\\n        for i in 0..<nums.count {\\n            if nums[nums.count-1-i] != \"0\" {\\n                var sum = \"\"\\n                for char in nums[0...nums.count-1-i] {\\n                    sum += String(char)\\n                }\\n                return sum\\n            }\\n        }\\n        return num\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func removeTrailingZeros(_ num: String) -> String {\\n        var nums = Array(num)\\n        for i in 0..<nums.count where nums[nums.count-1-i] != \"0\" {\\n            return nums[0...nums.count-1-i].map { String($0) }.reduce(into: String(), +=)\\n        }\\n        return num\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915890,
                "title": "bye-bye-trailing-zeros-in-numbers-a-simple-and-subtle-string-solution",
                "content": "# Intuition\\nTrailing zeros are those extra \\'0\\' digits that hang out at the end of a number. Like, in the number \\'1023000\\', there are three of these trailing zeros. When we talk about numbers as words, these trailing zeros are just the \\'0\\' characters you find at the very end of the number. \\n# Approach\\nSo try to imagine you\\'ve this number written down, but in a sneaky way \\u2013 as a bunch of characters in a row, like when you\\'re texting. We\\'re talking about a number like \"1023000\". Now, those zeros at the end? They\\'re like the stragglers that kinda just chill there and got nothing to do with anyone. We\\'re calling them \"trailing zeros\" because they\\'re just tagging along at the back, doing their thing.\\n\\nSo, what we wanna do is kick these trailing zeros out, but not mess with the other numbers. We\\'re keeping it cool, preserving the order of the digits. To do that, we\\'re gonna have a look at those characters, one by one. But here\\'s the twist: we\\'re gonna do it from the end to the beginning, like you\\'re rewinding a movie.\\n\\nAs we rewind, we\\'re gonna check if the character is a zero. And if it is, we\\'re just gonna keep moving. But here\\'s where it gets interesting: as soon as we hit a character that\\'s not a zero \\u2013 that\\'s where the real action starts. Because all those trailing zeros are officially done, and we remember the spot where things got exciting.\\n\\nNow that we know where the non-zero party begins, we\\'ll take all the characters from the start to that party spot and put them together. This new bunch of characters is like the same number but with all the trailing zeros gone. It\\'s like we\\'ve tidied up the place and kicked out the uninvited zeros.\\n\\nAnd there you have it \\u2013 a super chill way to deal with trailing zeros in a number string!\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is linear or O(n) \\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length() - 1;\\n\\n        // Find the index where the trailing zeros end\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) != \\'0\\') {\\n                endIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // Create a new string without trailing zeros\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int endIndex = num.length() - 1;\\n\\n        // Find the index where the trailing zeros end\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            if (num.charAt(i) != \\'0\\') {\\n                endIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // Create a new string without trailing zeros\\n        return num.substring(0, endIndex + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915306,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i=num.size()-1;\\n        while(num[i]==\\'0\\'){\\n            i--;\\n        }\\n        return num.substr(0,i+1);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n        int i=num.size()-1;\\n        while(num[i]==\\'0\\'){\\n            i--;\\n        }\\n        return num.substr(0,i+1);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914686,
                "title": "converting-to-array-method-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n\\n    let number= Array.from(num);\\n\\n   \\n    for(let i=number.length-1;i>=0;i--) {\\n\\n        if(number[i]==\\'0\\') {\\n            number.splice(i, 1);\\n        }\\n        else if(number[i]!=\\'0\\') {\\n            break;\\n        }\\n\\n\\n\\n\\n\\n    }\\n    return number.join(\\'\\');\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar removeTrailingZeros = function(num) {\\n\\n    let number= Array.from(num);\\n\\n   \\n    for(let i=number.length-1;i>=0;i--) {\\n\\n        if(number[i]==\\'0\\') {\\n            number.splice(i, 1);\\n        }\\n        else if(number[i]!=\\'0\\') {\\n            break;\\n        }\\n\\n\\n\\n\\n\\n    }\\n    return number.join(\\'\\');\\n    \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912342,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        char[] chars = num.toCharArray();\\n        int i = chars.length;\\n\\n        while(i > 0){\\n            i--;\\n            if(chars[i] == \\'0\\')\\n              continue;\\n            else\\n              break;\\n        }\\n\\n        return num.substring(0, i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        char[] chars = num.toCharArray();\\n        int i = chars.length;\\n\\n        while(i > 0){\\n            i--;\\n            if(chars[i] == \\'0\\')\\n              continue;\\n            else\\n              break;\\n        }\\n\\n        return num.substring(0, i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909887,
                "title": "easy-while-loop-soln",
                "content": "# Intuition \\nEasy question, can be done with for loop also.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse while loop, break from it if last char of string is not zero. \\nIf zero check second last char, and so on.\\nReturn string from beginning till last non-zero\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String s) {\\n        int n = s.length();\\n        while(n>=0){\\n            if(s.charAt(n-1) != \\'0\\')\\n            break;\\n            n--;\\n        }\\n        return s.substring(0,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String s) {\\n        int n = s.length();\\n        while(n>=0){\\n            if(s.charAt(n-1) != \\'0\\')\\n            break;\\n            n--;\\n        }\\n        return s.substring(0,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903801,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int len = num.length();\\n        while(len>=0)\\n        {\\n            if(num.charAt(len-1)!=\\'0\\')\\n            {\\n                break;\\n            }\\n            len--;\\n        }\\n        return num.substring(0,len);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int len = num.length();\\n        while(len>=0)\\n        {\\n            if(num.charAt(len-1)!=\\'0\\')\\n            {\\n                break;\\n            }\\n            len--;\\n        }\\n        return num.substring(0,len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902246,
                "title": "o-n-beginner-friendly-solution-with-o-1-space-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust traverse character array from back and find an element which is not equal to \\'0\\',In c array size is fixed so just replace i + 1 th character with \\'\\\\0\\' that is string terminator\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nchar * removeTrailingZeros(char * num){\\n    if(num[strlen(num) - 1] != \\'0\\'){\\n        return(num);\\n    }\\n    for(int i = strlen(num) - 1;i >= 0;i--){\\n        if(num[i] != \\'0\\'){\\n           num[i+1] = \\'\\\\0\\';\\n           break;\\n        }\\n    }\\n    return(num);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * removeTrailingZeros(char * num){\\n    if(num[strlen(num) - 1] != \\'0\\'){\\n        return(num);\\n    }\\n    for(int i = strlen(num) - 1;i >= 0;i--){\\n        if(num[i] != \\'0\\'){\\n           num[i+1] = \\'\\\\0\\';\\n           break;\\n        }\\n    }\\n    return(num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896479,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        StringBuilder str=new StringBuilder(num);\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                str.deleteCharAt(i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return str.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        StringBuilder str=new StringBuilder(num);\\n        for(int i=num.length()-1;i>=0;i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                str.deleteCharAt(i);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return str.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895905,
                "title": "simple-and-clear-python-solution-beat-96",
                "content": "# Is it need explanation?\\n### Approach\\nWe turn over the string - we count the first characters and as soon as we meet something that is not equal to zero, we interrupt the cycle, then we cut off the zeros using a slice and rotate the string back.\\n\\n# Code\\n```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = num[::-1]\\n        zeros = 0\\n        for s in num:\\n            if s != \\'0\\':\\n                break\\n            zeros += 1\\n        return num[zeros:][::-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def removeTrailingZeros(self, num: str) -> str:\\n        num = num[::-1]\\n        zeros = 0\\n        for s in num:\\n            if s != \\'0\\':\\n                break\\n            zeros += 1\\n        return num[zeros:][::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893458,
                "title": "easy-to-understand-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n       int i = num.size()-1;\\n       string str=num;\\n    while(i >= 0)\\n    {\\n       if(str[i]==\\'0\\')\\n       {\\n        str.erase(i);\\n       }\\n       else\\n       {\\n           break;\\n       }\\n       i--;\\n    }\\n    return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeTrailingZeros(string num) {\\n       int i = num.size()-1;\\n       string str=num;\\n    while(i >= 0)\\n    {\\n       if(str[i]==\\'0\\')\\n       {\\n        str.erase(i);\\n       }\\n       else\\n       {\\n           break;\\n       }\\n       i--;\\n    }\\n    return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893202,
                "title": "clean-short-simple-java-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int j = num.length()-1;\\n        while(num.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        return num.substring(0, j+1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n        int j = num.length()-1;\\n        while(num.charAt(j) == \\'0\\') {\\n            j--;\\n        }\\n        return num.substring(0, j+1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893000,
                "title": "c-ez-brute-force-100-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        char[] nArr = num.ToCharArray();\\n        for(int i = nArr.Length - 1; i >= 0; i--)\\n            if(nArr[i] == \\'0\\')\\n                nArr[i] = \\'@\\';\\n            else\\n                break;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < nArr.Length; i++)\\n            if(nArr[i] != \\'@\\')\\n                sb.Append(nArr[i]);\\n            else\\n                break;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string RemoveTrailingZeros(string num) {\\n        char[] nArr = num.ToCharArray();\\n        for(int i = nArr.Length - 1; i >= 0; i--)\\n            if(nArr[i] == \\'0\\')\\n                nArr[i] = \\'@\\';\\n            else\\n                break;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < nArr.Length; i++)\\n            if(nArr[i] != \\'@\\')\\n                sb.Append(nArr[i]);\\n            else\\n                break;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889986,
                "title": "simple-java-solution-o-n-time-complexity-beats-100-in-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int count=0;\\n\\n        for(int i=num.length()-1; i>=0; i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                count++;\\n            } else{\\n                break;\\n            }\\n        }\\n\\n        return num.substring(0,(num.length()-count));\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeTrailingZeros(String num) {\\n\\n        int count=0;\\n\\n        for(int i=num.length()-1; i>=0; i--){\\n            if(num.charAt(i)==\\'0\\'){\\n                count++;\\n            } else{\\n                break;\\n            }\\n        }\\n\\n        return num.substring(0,(num.length()-count));\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1909037,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1917169,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1925673,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1910909,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1908820,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 2040134,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            },
            {
                "id": 1932253,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Count the Trailing Zeros (from back) From a String and return the substring of length (0 to length-count )\n"
                    },
                    {
                        "username": "sprenten",
                        "content": "For people who are attempting to post a C solution, this uses a horrible input format of the char num[] = \"51230100\" and then being cast as char * ptr = &num[0] with the ptr variable which is then being passed passed into the function.  This is only way to get a valid solution to work the way they want to and in IMO is not the way you should write C as you will get seg faults.  Sorry but if you are telling me num = \"123\" in C I have to assume it is being assigned to a char* and not a char[].  I used valgrind over 30000 random integers I have in a program using clang, gcc, and icc and each version had zero memory leaks with the calloc submission I used because I freed the return value after use.  "
                    },
                    {
                        "username": "olehn",
                        "content": "I see that folks (including me, haha) are mostly using one of the Python's built-in functions... Is this the preferred way of doing, or should we reinvent the wheel?"
                    },
                    {
                        "username": "Aditya560",
                        "content": "Scan from back if it is 0 then pop it otherwise break the loop"
                    },
                    {
                        "username": "almostmonday",
                        "content": "It would be more interesting if `\"0\"` was allowed."
                    },
                    {
                        "username": "rastogiyash461",
                        "content": "Try to find the index of last non-zero digit."
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "i am getting \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\nerror does anybody why this is happening."
                    }
                ]
            }
        ]
    },
    {
        "title": "Is Object Empty",
        "question_content": "<p>Given an object or an array, return if it is empty.</p>\n\n<ul>\n\t<li>An empty object contains no key-value pairs.</li>\n\t<li>An empty array contains no elements.</li>\n</ul>\n\n<p>You may assume the object or array is the output of&nbsp;<code>JSON.parse</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = {&quot;x&quot;: 5, &quot;y&quot;: 42}\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The object has 2 key-value pairs so it is not empty.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = {}\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The object doesn&#39;t have any key-value pairs so it is empty.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = [null, false, 0]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The array has 3 elements so it is not empty.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>obj</code> is a valid JSON object or array</li>\n\t<li><code>2 &lt;= JSON.stringify(obj).length &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Can you solve it in O(1) time?</strong>",
        "solutions": [
            {
                "id": 3609695,
                "title": "javascript-for-iterator-time-o-1-generator-function",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    for (const _ in obj) return false;\\n    return true;\\n};\\n```\\n#### Only for Arrays\\n```\\nvar isEmpty = function(obj) {\\n    return obj[Symbol.iterator]().next().done;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    for (const _ in obj) return false;\\n    return true;\\n};\\n```\n```\\nvar isEmpty = function(obj) {\\n    return obj[Symbol.iterator]().next().done;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607988,
                "title": "simple-o-1-without-using-object-keys-or-json-stringify",
                "content": "Time/Space complexity of `JSON.stringify` and `Object.keys` depend on the size of the object/array hence execution time/space of above methods is not O(1)\\n\\nWe can instead use for-in loop since it works on both array as well as objects.\\n\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    for (let key in obj)\\n        return false;\\n    return true;\\n};\\n```\\n\\n- If array/object is not empty, interpreter will enter the for-in loop and hence first return statement (false) will be executed.\\n- If array/object is empty, interpreter won\\'t enter for-in loop and hence second return statement (true) will be executed.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    for (let key in obj)\\n        return false;\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607720,
                "title": "simple-implementation",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616283,
                "title": "javascript-one-liner",
                "content": "# Code\\n```\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3645833,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033593,
                "title": "easy-js-solution-for-is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.entries(obj).length === 0){\\n        return true\\n    }else{\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.entries(obj).length === 0){\\n        return true\\n    }else{\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032347,
                "title": "one-line-solution-using-javascript-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs this question is about Object then it is obvious that we will first think of Object methods. we look what object mehods can help us to get our desired answer.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)In JavaScript we have Object.keys() method which gives us all the keys available in the object.\\n\\nFor example:\\n```\\nconst person = {\\n  firstName: \\'John\\',\\n  lastName: \\'Doe\\',\\n  age: 30,\\n  email: \\'john@example.com\\'\\n};\\n\\nconst keys = Object.keys(person); //here it will give all the keys in our console\\n\\nconsole.log(keys);\\n```\\nOutput:\\n```\\n[ \\'firstName\\', \\'lastName\\', \\'age\\', \\'email\\' ]\\n```\\n2) Now we got the array of keys in further part we take use of length method available in JavaScript to get the length of this array and we will check if it is equals to 0 it will return true as mentioned in question otherwise if object have some keys then return false. \\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Object.keys(obj).length === 0;\\n};\\n```\\n# **Please Upvote the solution if\\'d find it useful\\u2764\\uD83D\\uDC4D**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst person = {\\n  firstName: \\'John\\',\\n  lastName: \\'Doe\\',\\n  age: 30,\\n  email: \\'john@example.com\\'\\n};\\n\\nconst keys = Object.keys(person); //here it will give all the keys in our console\\n\\nconsole.log(keys);\\n```\n```\\n[ \\'firstName\\', \\'lastName\\', \\'age\\', \\'email\\' ]\\n```\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752822,
                "title": "super-easy-and-simple-solution-in-js-0-0-wow",
                "content": "# Easy solution\\nIn Object.keys you can check not only object\\'s keys but also array\\'s keys. So it is very easy\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0 ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0 ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689771,
                "title": "simple-one-line-solution-using-object-keys-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680834,
                "title": "return-json-stringify-2",
                "content": "```js\\nvar isEmpty = function(obj) {\\n    return JSON.stringify(obj).length === 2;  \\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar isEmpty = function(obj) {\\n    return JSON.stringify(obj).length === 2;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3637796,
                "title": "easy-typescript-solution-with-iteration",
                "content": "# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n  for (let value in obj) {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n  for (let value in obj) {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608457,
                "title": "one-line-solution-ternary-operator-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Array.isArray(obj) ? obj.length === 0 : Object.keys(obj).length === 0; \\n};\\n      \\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return Array.isArray(obj) ? obj.length === 0 : Object.keys(obj).length === 0; \\n};\\n      \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607209,
                "title": "javascript-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj)){\\n        return !(obj.length);\\n    }\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj)){\\n        return !(obj.length);\\n    }\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823667,
                "title": "worst-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj))\\n        return (!obj.length);\\n    // console.log(Object.values(obj))\\n    return (!Object.values(obj).length);\\n};\\n```\\n![\\u043F\\u04350.jfif](https://assets.leetcode.com/users/images/65018b70-c72f-4501-9aef-bf9c89cf0a5b_1690460779.7540426.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj))\\n        return (!obj.length);\\n    // console.log(Object.values(obj))\\n    return (!Object.values(obj).length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749956,
                "title": "one-liner-js-const-isempty-obj-object-keys-obj-length-0",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = obj => Object.keys(obj).length === 0\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = obj => Object.keys(obj).length === 0\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665842,
                "title": "javascript",
                "content": "\\n\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    obj = JSON.stringify(obj);\\n    return obj.length == 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    obj = JSON.stringify(obj);\\n    return obj.length == 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100665,
                "title": "2727-is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    if(Object.keys(obj).length === 0 ){\\n        return true\\n    }else{\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    if(Object.keys(obj).length === 0 ){\\n        return true\\n    }else{\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100662,
                "title": "2727-is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    console.log(obj.length, Object.keys(obj).length,\"if condition\")\\n    if(Object.keys(obj).length === 0 ){\\n        return true\\n    }else{\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    console.log(obj.length, Object.keys(obj).length,\"if condition\")\\n    if(Object.keys(obj).length === 0 ){\\n        return true\\n    }else{\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100189,
                "title": "1-line-js-ts-solution-best-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nconst isEmpty = (obj: Obj): boolean => Object.keys(obj).length === 0;\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nconst isEmpty = (obj: Obj): boolean => Object.keys(obj).length === 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092524,
                "title": "solution-using-js-object-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return ( Object.values(obj).length === 0 ? true : false );\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return ( Object.values(obj).length === 0 ? true : false );\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075371,
                "title": "2727-is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074575,
                "title": "truly-a-one-liner",
                "content": "# Intuition\\n\\nUse `!` to negate the length of the Object.keys method and cast it as a boolean. If it\\'s `0` then it\\'ll flip to `true` and if it\\'s greater than zero, it\\'ll flip to `false`.\\n\\nUse the anonymous arrow function syntax because it\\'s 2023.\\n\\n# Code\\n```\\nconst isEmpty = (o => !Object.keys(o).length);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isEmpty = (o => !Object.keys(o).length);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073752,
                "title": "beats-96-64-of-users-runtime-and-beats-73-51-of-users-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem we need to check whether obj is empty or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconvert provided obj to string and you will get either \"{}\" or \"[]\",\\nput an if statement to check if the provided obj match these return true else return false\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const objStr = JSON.stringify(obj)\\n    if(objStr === \\'{}\\' || objStr ===\\'[]\\'){\\n        return true\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const objStr = JSON.stringify(obj)\\n    if(objStr === \\'{}\\' || objStr ===\\'[]\\'){\\n        return true\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067278,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0) return true;\\n    else return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0) return true;\\n    else return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067112,
                "title": "is-object-empty-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.entries(obj).length === 0){\\n        return true;\\n    }else{\\n        return false;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.entries(obj).length === 0){\\n        return true;\\n    }else{\\n        return false;\\n    }\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061537,
                "title": "easy-typescript-solution",
                "content": "\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    if(Object.keys(obj).length === 0) return true;\\n    else return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Obj = Record<string, JSONValue> | JSONValue[]\\n\\nfunction isEmpty(obj: Obj): boolean {\\n    if(Object.keys(obj).length === 0) return true;\\n    else return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058603,
                "title": "js-one-liner",
                "content": "# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => !Object.keys(obj).length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => !Object.keys(obj).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052731,
                "title": "easiest-way",
                "content": "\\nvar isEmpty = function (obj) {\\n\\n\\n// methode 1  by using object Entries \\n   const res = Object.entries(obj);\\n   if (res.length === 0) {\\n      return true;\\n   }\\n   else {\\n      return false;\\n   }\\n\\n\\n// methode 2 using object keys \\n\\n   const res2 = Object.keys(obj)\\n   if (res2.length === 0) {\\n      return true;\\n   }\\n   else {\\n      return false;\\n   }\\n\\n\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\nvar isEmpty = function (obj) {\\n\\n\\n// methode 1  by using object Entries \\n   const res = Object.entries(obj);\\n   if (res.length === 0) {\\n      return true;\\n   }\\n   else {\\n      return false;\\n   }\\n\\n\\n// methode 2 using object keys \\n\\n   const res2 = Object.keys(obj)\\n   if (res2.length === 0) {\\n      return true;\\n   }\\n   else {\\n      return false;\\n   }\\n\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4049648,
                "title": "solution-with-isarray-and-object-keys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length) return false\\n    if(Object.keys(obj).length) return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length) return false\\n    if(Object.keys(obj).length) return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049094,
                "title": "d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\nreturn Object.keys(obj).length == 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\nreturn Object.keys(obj).length == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048078,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (const _ in obj)\\n    return false;\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (const _ in obj)\\n    return false;\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046410,
                "title": "easiest-way-to-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if((Object.entries(obj).length)===0){\\n        return true\\n    }\\n    else{\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if((Object.entries(obj).length)===0){\\n        return true\\n    }\\n    else{\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042467,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n\\n    <!-- using Object.keys() Method -->\\n    // let length = Object.keys(obj).length;\\n    // return length > 0 ? false : true\\n\\n    <!-- using JSON.stringify() -->\\n    return JSON.stringify(obj).length > 2 ? false :true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n\\n    <!-- using Object.keys() Method -->\\n    // let length = Object.keys(obj).length;\\n    // return length > 0 ? false : true\\n\\n    <!-- using JSON.stringify() -->\\n    return JSON.stringify(obj).length > 2 ? false :true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041315,
                "title": "javascript-1-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj)?.length \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj)?.length \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041282,
                "title": "oneline",
                "content": "```\\nconst  isEmpty = (obj)=> !Object.values(obj).length \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst  isEmpty = (obj)=> !Object.values(obj).length \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035278,
                "title": "neat-solution-with-explanation",
                "content": "# Explanation\\n`Object.keys(obj)` provided the key in an array. Fo instance, if the object is like below\\n```\\nconst obj = {\\n a: 1,\\n b: 2,\\n}\\n```\\n`Object.keys(obj)` returns `[\"a\",\"b\"]`. Now simply checking if the length of the array is 0 should suffice the need.\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst obj = {\\n a: 1,\\n b: 2,\\n}\\n```\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033127,
                "title": "detailed-explanation-detecting-empty-objects-in-javascript",
                "content": "# Intuition\\nIn this problem, we are trying to determine whether an object in JavaScript is empty or not. An empty object in JavaScript has no properties. The intuition behind this approach is that we can use the Object.keys(obj) method to obtain all the keys (properties) of the object as an array and then check if the length of that array is equal to zero. If the length is zero, we can conclude that the object is empty.\\n\\n# Approach\\nThe approach to solving this problem is quite straightforward:\\n\\n1 We use Object.keys(obj) to obtain an array of the keys of the obj object.\\n2 Then, we compare the length of that array with zero.\\n3 If the length is equal to zero, the function returns true, indicating that the object is empty.\\n4 If the length is not equal to zero, the function returns false, indicating that the object is not empty.\\n\\n# Complexity\\nTime complexity: O(n)\\n\\nWhere \\'n\\' is the number of properties in the object. The Object.keys(obj) method iterates through all the object\\'s properties once to obtain the keys, which has a linear time complexity in terms of the number of properties.\\n\\nSpace complexity: O(n)\\nThe space used depends on the number of properties in the object because we are creating an array with those keys. Therefore, the space complexity is also linear in terms of the number of properties.\\n\\n# Code\\n```\\nfunction isEmpty(obj){\\n    return Object.keys(obj).length === 0\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isEmpty(obj){\\n    return Object.keys(obj).length === 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028445,
                "title": "typescript-solution-easy-simple-explained",
                "content": "# Intuition\\n\\nThe first thing I considered is that we have two data structures which are arrays and objects.\\n\\n# Approach\\n\\n1. Check the first the type of the input ( object or array).\\n2. If `isArray` then check its length.\\n3. If `isObject` then check the length of keys.\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(1)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    }\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    }\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028115,
                "title": "first-check-for-whether-obj-is-empty-or-not-with-object-entries-obj-then-check-the-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    let value = Object.entries(obj)\\n    if (value.length) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    let value = Object.entries(obj)\\n    if (value.length) {\\n        return false;\\n    } else {\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022197,
                "title": "simple-and-one-liner",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return Object.keys(obj).length == 0 && true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return Object.keys(obj).length == 0 && true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021588,
                "title": "is-object-empty-solution",
                "content": "# Intuition\\nChecking  if an object or array is empty.\\n\\n# Approach\\nWe can use the `Object.keys(obj).length` method to determine the number of keys in the object or the length of the array.\\nIf the length is equal to 0, the object or array is empty, and we return true. Otherwise, we return false.\\n\\n# Complexity\\n- Time complexity:\\n Time complexity: O(n), where n is the number of keys in the object or the length of the array.\\n- Space complexity: O(1), as we don\\'t use any additional data structures.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   if(Object.keys(obj).length === 0){\\n       return true;\\n   }\\n   else {\\n       return false; \\n   }\\n     \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   if(Object.keys(obj).length === 0){\\n       return true;\\n   }\\n   else {\\n       return false; \\n   }\\n     \\n    \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018904,
                "title": "simple-elegant-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return !Object.entries(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return !Object.entries(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006524,
                "title": "javascript-easy-simple-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length>0){return false;}\\n    else if ( Object.keys(obj).length>0){return false}\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length>0){return false;}\\n    else if ( Object.keys(obj).length>0){return false}\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001417,
                "title": "one-line-solution",
                "content": "# Code\\n```\\nconst isEmpty = (obj) => Object.keys(obj).length <= 0;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isEmpty = (obj) => Object.keys(obj).length <= 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000086,
                "title": "fastest-1-liner",
                "content": "# Intuition\\n![isEmpty.png](https://assets.leetcode.com/users/images/002b1ee6-0a88-46c6-a8e7-916a651723c7_1693811414.3990874.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty =  obj => Object.keys(obj).length === 0;\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty =  obj => Object.keys(obj).length === 0;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999432,
                "title": "every-case-checked-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0; // Check for empty array\\n  }\\n\\n  if (typeof obj === \"object\") {\\n    for (var prop in obj) {\\n      if (obj.hasOwnProperty(prop)) {\\n        return false; // Return false if any property is found\\n      }\\n    }\\n  }\\n\\n  return true; // If no properties were found (or not an array), return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0; // Check for empty array\\n  }\\n\\n  if (typeof obj === \"object\") {\\n    for (var prop in obj) {\\n      if (obj.hasOwnProperty(prop)) {\\n        return false; // Return false if any property is found\\n      }\\n    }\\n  }\\n\\n  return true; // If no properties were found (or not an array), return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997312,
                "title": "interview-tips",
                "content": "# Interview Tips:\\n\\n- What is the difference between an empty object and an object with no properties?\\n    - An empty object refers to an object that does not have any key-value pairs. It means that the object does not contain any properties. On the other hand, an object with no properties still exists and may have properties in the future. It simply means that it currently does not have any properties defined.\\n\\n- How can you check if an object is empty in JavaScript without using the length of its keys?\\n    - Another way to check if an object is empty without using the length of its keys is by using the Object.keys() method. This method returns an array of the object\\'s own enumerable property names (keys). You can then check if the length of the array is zero to determine if the object is empty.\\n\\n- What is a Plain Old JavaScript Object (POJO)?\\n    - A Plain Old JavaScript Object (POJO) is a term used to describe a simple JavaScript object that is created using the object literal syntax or the Object() constructor. It refers to an object that does not have any specialized behavior or methods inherited from custom prototypes or built-in JavaScript classes. POJOs are often used as data transfer objects (DTOs) or as simple containers for storing and accessing data.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Interview Tips:\\n\\n- What is the difference between an empty object and an object with no properties?\\n    - An empty object refers to an object that does not have any key-value pairs. It means that the object does not contain any properties. On the other hand, an object with no properties still exists and may have properties in the future. It simply means that it currently does not have any properties defined.\\n\\n- How can you check if an object is empty in JavaScript without using the length of its keys?\\n    - Another way to check if an object is empty without using the length of its keys is by using the Object.keys() method. This method returns an array of the object\\'s own enumerable property names (keys). You can then check if the length of the array is zero to determine if the object is empty.\\n\\n- What is a Plain Old JavaScript Object (POJO)?\\n    - A Plain Old JavaScript Object (POJO) is a term used to describe a simple JavaScript object that is created using the object literal syntax or the Object() constructor. It refers to an object that does not have any specialized behavior or methods inherited from custom prototypes or built-in JavaScript classes. POJOs are often used as data transfer objects (DTOs) or as simple containers for storing and accessing data.\\n",
                "codeTag": "Java"
            },
            {
                "id": 3995984,
                "title": "javascript-object-keys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length > 0){\\n        return false;\\n    }else{\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length > 0){\\n        return false;\\n    }else{\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995785,
                "title": "typescript-one-liner-using-object-keys-static-method-and-bitwise-operator",
                "content": "# Intuition\\n\\nThe built-in static method `Object.keys` returns an array iterable of all of the property names of an object, and the property names of an array object are the values in the array.\\n\\n# Approach\\n\\nSimply check if `Object.keys(obj)` returns an empty iterable.\\n\\n# Complexity\\n\\n* Time Complexity\\n$$O(n)$$\\n* Space complexity\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).reduce((acc, _) => acc | 1, 0) == 0\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).reduce((acc, _) => acc | 1, 0) == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987308,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (const _ in obj) return false;\\n    return true;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (const _ in obj) return false;\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985362,
                "title": "typescript-solution",
                "content": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    const keys: any[] = Object.keys(obj);\\n    return !keys.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    const keys: any[] = Object.keys(obj);\\n    return !keys.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982890,
                "title": "simple-one-liner-solution",
                "content": "# Simple One-liner Solution\\n\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => [\"{}\", \"[]\"].includes(JSON.stringify(obj));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => [\"{}\", \"[]\"].includes(JSON.stringify(obj));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979934,
                "title": "solution-in-one-line-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nlet isEmpty = obj => {return Object.keys(obj).length === 0};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nlet isEmpty = obj => {return Object.keys(obj).length === 0};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977398,
                "title": "js-most-descriptive-and-understandable-instanceof",
                "content": "# Intuition\\nNot the shortest but the most descriptive. All the solutions submitted cause some sort of cognitive load.\\n\\n# Approach\\n- Check if it\\'s an object\\n    - Check item length \\n- Check if it\\'s an array\\n    - Check item length\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (obj instanceof Object)\\n        return Object.values(obj).length === 0;\\n    \\n    if (obj instanceof Array)\\n        return array.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (obj instanceof Object)\\n        return Object.values(obj).length === 0;\\n    \\n    if (obj instanceof Array)\\n        return array.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971775,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return !Object.keys(obj).length ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return !Object.keys(obj).length ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970491,
                "title": "ezz-js-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Object.keys(obj).length !== 0)\\n        return false\\n    else\\n        return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Object.keys(obj).length !== 0)\\n        return false\\n    else\\n        return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962807,
                "title": "one-line-solution-with-object-keys",
                "content": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962080,
                "title": "object-empty-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3961705,
                "title": "oneline-liner-very-easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return Object.keys(obj).length == 0  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  return Object.keys(obj).length == 0  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958628,
                "title": "js-clear-one-line-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955685,
                "title": "js-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    \\n    var c=0;\\n    for(var k in obj){\\n        c++;\\n    }\\n\\n    return c==0;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    \\n    var c=0;\\n    for(var k in obj){\\n        c++;\\n    }\\n\\n    return c==0;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953511,
                "title": "using-object-keys-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return !Object.keys(obj).length \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n   return !Object.keys(obj).length \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952456,
                "title": "simple-1-liner-return-object-keys-obj-length-0",
                "content": "```\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952376,
                "title": "2-simple-approaches-with-tc-o-1",
                "content": "\\n# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//TC,SC - O(1) \\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(const _ in obj)\\n      return false;\\n    \\n    return true;\\n};\\n```\\n```\\n//TC,SC - O(n) \\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//TC,SC - O(1) \\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(const _ in obj)\\n      return false;\\n    \\n    return true;\\n};\\n```\n```\\n//TC,SC - O(n) \\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949321,
                "title": "simple-basic-solution-in-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  let isEmpty = true  \\n  let length = Object.keys(obj).length;\\n  if(length>0){\\n      isEmpty = false;\\n  }\\n  let lengthofArray = obj.length;\\n  if(lengthofArray >0){\\n      isEmpty = false;\\n  }\\n  return isEmpty;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  let isEmpty = true  \\n  let length = Object.keys(obj).length;\\n  if(length>0){\\n      isEmpty = false;\\n  }\\n  let lengthofArray = obj.length;\\n  if(lengthofArray >0){\\n      isEmpty = false;\\n  }\\n  return isEmpty;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944928,
                "title": "javascript-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943632,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length==0)\\n    return true\\n    else\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length==0)\\n    return true\\n    else\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942150,
                "title": "solution-using-built-in-methods",
                "content": "# Intuition\\nI done this with bulit-in method\\n\\n# Approach\\ntype of the object and array are \"object\" so we cant understand it is array or not!.\\nThere is a function in js called isArray() that checks given value is array or not. if it not that means it is a object, i\\'m getting the keys and its length, if it has keys the length not be 0 (obj is not empty)\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n// is Object Empty\\n\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    } else {\\n       return Object.keys(obj).length === 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// is Object Empty\\n\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    } else {\\n       return Object.keys(obj).length === 0;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941712,
                "title": "simple-one-liner",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940749,
                "title": "simple-solution-using-javascript-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n    here no extra space is used so space Complexity O(1)\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0)\\n        return true\\n    else\\n        return false    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0)\\n        return true\\n    else\\n        return false    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940712,
                "title": "easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length===0)\\n        return true;\\n    else\\n        return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length===0)\\n        return true;\\n    else\\n        return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938582,
                "title": "simple-solution-using-object-entries-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.entries(obj).length == 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.entries(obj).length == 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937201,
                "title": "solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length > 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length > 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3934448,
                "title": "beats-99-commented",
                "content": "# Code\\n```\\n// If the length is zero, it returns true\\nvar isEmpty = (obj) => !Object.keys(obj).length\\n```\\n![image.png](https://assets.leetcode.com/users/images/ab0bbbe6-ad0d-4a3b-910f-3df474859793_1692506773.1769793.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// If the length is zero, it returns true\\nvar isEmpty = (obj) => !Object.keys(obj).length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932708,
                "title": "typescript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys( obj ).length === 0\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys( obj ).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3928159,
                "title": "one-line",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => !Boolean(Object.keys(obj).length)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => !Boolean(Object.keys(obj).length)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927767,
                "title": "my-solution-to-the-is-object-empty-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem just wanted us to output true if the object was empty and false of it had a key value pair which is simply just a property. My first intuituon was to use the `Object.key()` method that allows us find the properties of the object that we pass.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach that i took here composed of assigning the length of the array that is produced form the `Object.key()` method. From there I just used some reverse logic to evaluate whether was empty and therefore return  the results as required by the problem.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    let Empty = Object.keys(obj).length;\\n\\n    if(Empty> 0) return false;\\n    return true;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    let Empty = Object.keys(obj).length;\\n\\n    if(Empty> 0) return false;\\n    return true;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924590,
                "title": "beginner-solution",
                "content": "# Explanation\\n\\n1st check if obj is an Object and has keys\\n2nd check if obj is an Array and its length is 0\\n\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ||\\n        Array.isArray(obj) && !obj.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ||\\n        Array.isArray(obj) && !obj.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918891,
                "title": "beats-80-15-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.values(obj).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.values(obj).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917090,
                "title": "easy-javascript-solution-one-line-code",
                "content": "> Vote Up If You Like the Solution\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    // console.log(Object.keys(obj))\\n    if(Object.values(obj).length){\\n        return false\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    // console.log(Object.keys(obj))\\n    if(Object.values(obj).length){\\n        return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915138,
                "title": "easy-way-to-solve-without-ternary-operator-just-boolean",
                "content": "# Intuition\\nTransform the object into array and then check if there is elements in it. \\nIf the array is empty then Object.values(object).length will give 0 and the reverse of 0 is 1 wich is true. The reverse of any other number is false\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.values(obj).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.values(obj).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914291,
                "title": "typescript-solution-3-different-ways",
                "content": "**for\\u2026in**\\nThis statement will loop through the enumerable property of the object.\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for (const prop in obj) {\\n        if (obj.hasOwnProperty(prop)) {\\n            return false;\\n        }   \\n    }\\n    return true;\\n};\\n```\\n\\n**Object.keys**\\nIt will return an array, which contains the property names of the object. If the length of the array is 0, then we know that the object is empty. **(In my opinion, this is the easiest)**\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).length === 0;\\n};\\n```\\n\\n**JSON.stringify**\\nThe object and the result is simply an opening and closing bracket, we know the object is empty.\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n   return JSON.stringify(obj) === \\'{}\\' || JSON.stringify(obj) === \\'[]\\';\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for (const prop in obj) {\\n        if (obj.hasOwnProperty(prop)) {\\n            return false;\\n        }   \\n    }\\n    return true;\\n};\\n```\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).length === 0;\\n};\\n```\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n   return JSON.stringify(obj) === \\'{}\\' || JSON.stringify(obj) === \\'[]\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913712,
                "title": "easy-solution-please-upvote-if-its-help",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length==0 ?true:false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length==0 ?true:false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910995,
                "title": "using-error-handling",
                "content": "\\n\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    try{\\n       if(Object.keys(obj).length==0){\\n           return true;\\n       }\\n       return false;\\n    }catch(err){\\n        return obj.length===0\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    try{\\n       if(Object.keys(obj).length==0){\\n           return true;\\n       }\\n       return false;\\n    }catch(err){\\n        return obj.length===0\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899162,
                "title": "easy-fast-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(let o in obj ){return false;}return true;};\\n\\n\\n\\n\\n2nd approach\\n\\n/** var isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0){\\n        return true;\\n    }\\n    else{\\n        return false;\\n    }\\n}; */*\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(let o in obj ){return false;}return true;};\\n\\n\\n\\n\\n2nd approach\\n\\n/** var isEmpty = function(obj) {\\n    if(Object.keys(obj).length === 0){\\n        return true;\\n    }\\n    else{\\n        return false;\\n    }\\n}; */*\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897592,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    // Check if obj is an object or an array\\n    if (typeof obj === \"object\" && obj !== null) {\\n        // Get the keys of the object or the length of the array\\n        var keys = Object.keys(obj);\\n        // Return true if there are no keys or false otherwise\\n        return keys.length === 0;\\n    } else {\\n        // Return false for invalid input\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    // Check if obj is an object or an array\\n    if (typeof obj === \"object\" && obj !== null) {\\n        // Get the keys of the object or the length of the array\\n        var keys = Object.keys(obj);\\n        // Return true if there are no keys or false otherwise\\n        return keys.length === 0;\\n    } else {\\n        // Return false for invalid input\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894009,
                "title": "1-line-code-with-explanation-simplest-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n# Approach\\nTo better comprehend the solution, it\\'s crucial to grasp the nature of arrays in JavaScript.\\n\\n**What are Arrays In Javasript?**\\n\\nArrays in JavaScript are a **specific type of object**. While arrays have a numeric index that starts from 0 and continues sequentially, they are still objects and can have additional properties and methods.\\n\\nWhen we call Object.keys(array), **it works because arrays are objects** that inherit properties and methods from the Object prototype. The Object.keys() function retrieves the enumerable property names (keys) of an object, including its prototype chain.\\n\\n**Concept in Action:**\\n\\nGiven that arrays are essentially objects, we can **avoid adding specific conditions** for array vs. object differentiation. Instead, we can directly Object.keys, simplifying the solution to a single line using **Arrow functions** and an **implicit return statement**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => Object.keys(obj).length ? false : true;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => Object.keys(obj).length ? false : true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890276,
                "title": "excellent-best-answer-than-almost-95-javascript-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWow best answer than almost 95% javascript users!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermines the length of the given object or array and returns true or false. Since it is not possible to determine the direct length of the object, we use the Object.keys() method, which returns us an array of the keys of this object.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    46ms Beats 94.77% of users with JavaScript\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    42.20mb Beats 93.07% of users with JavaScript\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    let leng = Object.keys(obj).length\\n    return leng > 0 ? false : true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    let leng = Object.keys(obj).length\\n    return leng > 0 ? false : true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886411,
                "title": "beats-99-42-users-tc-and-sc-is-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst make sure that the obj is Array or object and will check for its length and the length is in negative then return true else false\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const isArray = Array.isArray(obj)\\n    const isObj = obj instanceof Object\\n    if(isArray){\\n        return !obj.length\\n    }\\n    else if(isObj){\\n     return !Object.keys(obj).length\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const isArray = Array.isArray(obj)\\n    const isObj = obj instanceof Object\\n    if(isArray){\\n        return !obj.length\\n    }\\n    else if(isObj){\\n     return !Object.keys(obj).length\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885062,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length ? false : true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length ? false : true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880782,
                "title": "accepted-javascript",
                "content": "```\\nvar isEmpty = function(obj) {\\n    let json = JSON.stringify(obj);\\n    return json == \"{}\" || json == \"[]\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    let json = JSON.stringify(obj);\\n    return json == \"{}\" || json == \"[]\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880519,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length == 0) {\\n       return true\\n    }else{\\n       return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.keys(obj).length == 0) {\\n       return true\\n    }else{\\n       return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879304,
                "title": "simple-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can find the length of an Object literals by Object.keys(OBJ_NAME).legnth\\nif the value > 0 which means it has keys and values so we return false\\notherwise we return true;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    var l = Object.keys(obj).length;\\n    return l == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    var l = Object.keys(obj).length;\\n    return l == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878900,
                "title": "very-easy-short-solution-javascript",
                "content": "# Code\\n```\\nvar isEmpty = (obj) => Object.values(obj).length === 0 ? true : false;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = (obj) => Object.values(obj).length === 0 ? true : false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876868,
                "title": "2727-is-object-empty",
                "content": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872416,
                "title": "javascript-one-liner-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !(Object.keys(obj).length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867295,
                "title": "js-easy-solution",
                "content": "\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.values(obj).length==0 && Object.keys(obj).length==0)return true;\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Object.values(obj).length==0 && Object.keys(obj).length==0)return true;\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858207,
                "title": "for-loop",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (let i in obj) \\n        return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for (let i in obj) \\n        return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855741,
                "title": "simple-js-solution",
                "content": "\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  const length = Array.isArray(obj) ? obj.length : Object.keys(obj).length;\\n  return !length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n  const length = Array.isArray(obj) ? obj.length : Object.keys(obj).length;\\n  return !length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855669,
                "title": "fast-solution-50ms",
                "content": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\\n# Code\\n```\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```\\n### Runner up\\n```\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0;\\n};\\n```\n```\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850733,
                "title": "easy-solution-using-object-keys-length",
                "content": "# Approach\\nUse Object.keys().length\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).length == 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return Object.keys(obj).length == 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840465,
                "title": "is-object-empty-easy-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\nif (Array.isArray(obj))\\n        return obj.length === 0;\\n    \\n    return Object.values(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\nif (Array.isArray(obj))\\n        return obj.length === 0;\\n    \\n    return Object.values(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837705,
                "title": "simple-solution-object-keys",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n  return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n  return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837268,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar isEmpty = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831518,
                "title": "is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isEmpty(obj) {\\n  // Check if the input is an object\\n  if (typeof obj === \\'object\\' && obj !== null) {\\n    // For objects, check if it has any keys\\n    return Object.keys(obj).length === 0;\\n  } else if (Array.isArray(obj)) {\\n    // For arrays, check if it has any elements\\n    return obj.length === 0;\\n  }\\n\\n  // If the input is neither an object nor an array, consider it as empty\\n  return true;\\n}\\n\\n// Test with objects and arrays\\nconst emptyObject = {};\\nconst nonEmptyObject = { key: \\'value\\' };\\nconsole.log(isEmpty(emptyObject)); // Output: true\\nconsole.log(isEmpty(nonEmptyObject)); // Output: false\\n\\nconst emptyArray = [];\\nconst nonEmptyArray = [1, 2, 3];\\nconsole.log(isEmpty(emptyArray)); // Output: true\\nconsole.log(isEmpty(nonEmptyArray)); // Output: false\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isEmpty(obj) {\\n  // Check if the input is an object\\n  if (typeof obj === \\'object\\' && obj !== null) {\\n    // For objects, check if it has any keys\\n    return Object.keys(obj).length === 0;\\n  } else if (Array.isArray(obj)) {\\n    // For arrays, check if it has any elements\\n    return obj.length === 0;\\n  }\\n\\n  // If the input is neither an object nor an array, consider it as empty\\n  return true;\\n}\\n\\n// Test with objects and arrays\\nconst emptyObject = {};\\nconst nonEmptyObject = { key: \\'value\\' };\\nconsole.log(isEmpty(emptyObject)); // Output: true\\nconsole.log(isEmpty(nonEmptyObject)); // Output: false\\n\\nconst emptyArray = [];\\nconst nonEmptyArray = [1, 2, 3];\\nconsole.log(isEmpty(emptyArray)); // Output: true\\nconsole.log(isEmpty(nonEmptyArray)); // Output: false\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830946,
                "title": "interesting-json-stringify-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => JSON.stringify(obj).length === 2\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => JSON.stringify(obj).length === 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830905,
                "title": "obj-length-for-arrays-objects-keys-obj-length-for-objects",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(obj.length>0 || Object.keys(obj).length>0){\\n        return false\\n    }else{\\n        return true\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(obj.length>0 || Object.keys(obj).length>0){\\n        return false\\n    }else{\\n        return true\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830647,
                "title": "ts-one-line-ternary-operator",
                "content": "# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return !(Array.isArray(obj) ? obj.length > 0 : Object.keys(obj).length > 0);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return !(Array.isArray(obj) ? obj.length > 0 : Object.keys(obj).length > 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830271,
                "title": "typescript-hasownproperty-beats-85-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA quick foreach loop with a .hasOwnProperty check is all we need. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\\n\\nNote: .hasOwn is preferred over .hasOwnProperty, but the LeetCode backend doesn\\'t support that method yet. See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn\\n\\n# Approach\\nOne for loop with the hasOwnProperty check.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for(let prop in obj) {\\n        if (obj.hasOwnProperty(prop)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for(let prop in obj) {\\n        if (obj.hasOwnProperty(prop)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827075,
                "title": "one-liner",
                "content": "# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return (Array.isArray(obj) && obj?.length === 0) \\n        || Object.getOwnPropertyNames(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    return (Array.isArray(obj) && obj?.length === 0) \\n        || Object.getOwnPropertyNames(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3826362,
                "title": "easy-to-understand-javascript-solution-with-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we can check the type either if it\\'s object or array.\\n2. After getting the type if it\\'s object. We can use for in loop to traverse the object. If the execution goes inside the for in loop that\\'s mean the object is not empty it has key value pair.\\n3. If it\\'s array we can simply use the length check to determine if it\\'s empty or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const type = Array.isArray(obj);\\n    if(!type) {\\n        for(let key in obj) {\\n            return false;\\n        } return true;\\n    }\\n    return obj.length > 0 ? false : true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const type = Array.isArray(obj);\\n    if(!type) {\\n        for(let key in obj) {\\n            return false;\\n        } return true;\\n    }\\n    return obj.length > 0 ? false : true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825094,
                "title": "js-solution-with-57-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterate through object to see if there is at least one key. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf there is at least one key in the object, return true. Check edge case where the key is an empty string. Otherwise, the object is empty.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n\\n    console.log(\\'typeof obj= \\', typeof obj)\\n    for(key in obj){\\n        console.log(\\'key= \\', key)\\n        if(key === \"\"){\\n            return false;\\n        }\\n        if(key){\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n\\n    console.log(\\'typeof obj= \\', typeof obj)\\n    for(key in obj){\\n        console.log(\\'key= \\', key)\\n        if(key === \"\"){\\n            return false;\\n        }\\n        if(key){\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823997,
                "title": "best-solution-to-find-empty-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince they are asking to get the length, why not check if there are any keys in the object. If its an array then index will be the keys, and if its object then key specifically, will be tehe key.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will here use the property of Object, Object.key(objName) which returns an array of keys, then we can apply Array.length to get the length of the array of keys.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     return (Object.keys(obj).length === 0 ? true : false)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     return (Object.keys(obj).length === 0 ? true : false)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823293,
                "title": "easy-ts-solution",
                "content": "\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n  if (Array.isArray(obj)) return !obj.length;\\n  return !Object.keys(obj).length;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n  if (Array.isArray(obj)) return !obj.length;\\n  return !Object.keys(obj).length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821673,
                "title": "answer-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isEmpty(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \"object\" && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isEmpty(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.length === 0;\\n  } else if (typeof obj === \"object\" && obj !== null) {\\n    return Object.keys(obj).length === 0;\\n  }\\n  return false;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819089,
                "title": "a-very-easy-and-concise-code-with-a-simple-time-and-space-complexity",
                "content": "# Approach\\nThe function takes an input obj, which can be either an array or an object.\\n\\nIt first checks whether the input obj is an array using the Array.\\n\\nisArray(obj) method. If it is an array, it directly returns true if the array\\'s length is 0, indicating that the array is empty.\\n\\nIf the input obj is not an array (i.e., an object), it proceeds to the else block and converts the object\\'s values into an array using Object.values(obj).\\n\\nIt then checks whether the array\\'s length is 0. If it is 0, it means the object has no properties and is considered empty, so the function returns true.\\n\\nIf the array\\'s length is not 0, it means the object has properties, and the function returns false, indicating that the object is not empty.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Array.isArray(obj))\\n        return obj.length === 0;\\n    \\n    return Object.values(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    if (Array.isArray(obj))\\n        return obj.length === 0;\\n    \\n    return Object.values(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815886,
                "title": "easy-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && !obj.length) return true\\n    if(!Object.entries(obj).length) return true;\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && !obj.length) return true\\n    if(!Object.entries(obj).length) return true;\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3814389,
                "title": "solution-using-object-keys-time-complexity-o-n-space-complexity-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811279,
                "title": "o-1-with-easy-approach",
                "content": "# Intuition\\nSince ES `Object` has the inbuilt `keys(k)` to check the properties, we do not need further code to check the available objects.\\n\\n# Approach\\nUsing `Object.keys(obj)` is sufficient for object types.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => Object.keys(obj).length < 1\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = (obj) => Object.keys(obj).length < 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809793,
                "title": "extra-simple-solution-to-determine-whether-your-object-is-empty-or-not",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = (obj) => {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809425,
                "title": "soln-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj)\\n{\\n    // return Object.keys(obj).lenght === 0;\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj)\\n{\\n    // return Object.keys(obj).lenght === 0;\\n    return Object.keys(obj).length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809343,
                "title": "is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0 ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length == 0 ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808989,
                "title": "simple-one-line-solution-using-object-keys-method",
                "content": "``` \\n return Object.keys(obj).length<1\\n \\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\n return Object.keys(obj).length<1\\n \\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808803,
                "title": "study-what-object-entries-means-solution-by-junior",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.entries(obj).length ? 0 : true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.entries(obj).length ? 0 : true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806607,
                "title": "simple-js-logic-beats-90",
                "content": "<!-- # Intuition -->\\nThe code defines a JavaScript function named isEmpty that takes an object obj as input.\\n\\nInside the function, it uses the Object.keys(obj) method to obtain an array containing all the property names (keys) of the input object.\\nThe length of the keys array is then checked using the keys.length property.\\nIf the length of keys is equal to zero, it means the object has no properties and is considered empty.\\nIn that case, the function returns true, indicating that the object is empty.\\nIf the keys array has a length greater than zero, it means the object has one or more properties and is not empty.\\nIn that case, the function returns false, indicating that the object is not empty.\\nThe function effectively determines if the object has any properties by checking the length of the keys array.\\nNote that the function does not consider properties from the object\\'s prototype chain, only its own properties.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const keys = Object.keys(obj)\\n    if(keys.length===0){\\n        return true\\n    }\\n    return false\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    const keys = Object.keys(obj)\\n    if(keys.length===0){\\n        return true\\n    }\\n    return false\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805376,
                "title": "typescript-o-n",
                "content": "# Code\\n```ts\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for (const _ in obj) return false;\\n    return true;\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\n    for (const _ in obj) return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3802523,
                "title": "clean-and-crisp",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = obj=> Object.keys(obj).length === 0\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nconst isEmpty = obj=> Object.keys(obj).length === 0\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3798750,
                "title": "simple-javascript-solution",
                "content": "# Approach\\nSimply, use length method to see if there is any element in object or array.If if it is 0,return true else false.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789851,
                "title": "simple-js-check-if-the-object-is-empty-without-using-json",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI recommend you please check the use of json also and come up with that solution also ok bye i should also do it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     if(Object.keys(obj).length == 0){\\n         return true;\\n     }\\n     return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     if(Object.keys(obj).length == 0){\\n         return true;\\n     }\\n     return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789134,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786483,
                "title": "easysolutions-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\nreturn Object.keys(obj).length==0? true: false \\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isEmpty(obj: Record<string, any> | any[]): boolean {\\nreturn Object.keys(obj).length==0? true: false \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780336,
                "title": "pragmatic-checks-that-beat-92",
                "content": "# Approach\\nWe first check for the type we have to deal with, so either an object or an array. For an array its very straight forward, just check the lenght. For an Object it can also be simplified by using Object.keys() and checking the length of the returning array again.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length <= 0;\\n    }\\n    return Object.keys(obj).length <= 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length <= 0;\\n    }\\n    return Object.keys(obj).length <= 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3777105,
                "title": "very-basic-easy-to-understand-solution",
                "content": "# Approach\\nFirst we will check whether obj is an array or not and then if its length is zero then true will be returned. Same goes if obj is an object but to find length of object, Object.keys().length method is used.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length == 0) return true\\n    else if (Object.keys(obj).length == 0) return true\\n    else return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(Array.isArray(obj) && obj.length == 0) return true\\n    else if (Object.keys(obj).length == 0) return true\\n    else return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3769921,
                "title": "simple-program-using-ternary-operator-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length ==0 ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length ==0 ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765886,
                "title": "cleanest-simplest-solution",
                "content": "# Intuition\\nObject.keys can be used on arrays because arrays are also objects in JS.\\n\\n# Approach\\nIf there are any keys then the object is not empty. We can simply return the result of the comparison because it will be true or false.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return Object.keys(obj).length == 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return Object.keys(obj).length == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765046,
                "title": "super-simple-code",
                "content": "# Intuition\\nThe code asks to check if the key value pairs are present in the object\\n\\n# Approach\\nThe isEmpty function takes an object obj as input.\\n\\nIt uses a for...of loop to iterate over the keys of the object using the Object.entries(obj) method.\\n\\nIn each iteration, it checks the length property of the key variable, which represents each key-value pair in the form [key, value].\\n\\nIf the length of key is greater than 0, it means at least one key exists in the object.\\n\\nIn this case, the function immediately returns false, indicating that the object is not empty.\\n\\nIf the loop completes without finding any keys, it means the object is empty.\\n\\nIn that case, the function exits the loop and returns true, indicating that the object is indeed empty\\n# Complexity\\n- Time complexity:\\nTime Complexity: O(n)\\n\\nThe function iterates over the keys of the object using a for...of loop, which has a time complexity of O(n). It checks each key in the loop to determine if there are any keys present.\\nIn the worst case, when the object has n keys, the loop will iterate n times.\\nTherefore, the time complexity of the isEmpty function is O(n), as it has a linear relationship with the number of keys in the object.\\n\\n\\n- Space complexity:\\nSpace Complexity: O(1)\\n\\nThe function uses a constant amount of space for storing the key variable during each iteration of the loop.\\nIt does not use any additional data structures or memory that grow with the input size.\\nHence, the space complexity of the isEmpty function is O(1), indicating constant space usage regardless of the size of the object\\n\\n# Code\\n```\\n\\'use strict\\'\\nfunction isEmpty(obj) {\\n    for (const key of Object.entries(obj)) {\\n        if (key.length > 0) return false\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\'use strict\\'\\nfunction isEmpty(obj) {\\n    for (const key of Object.entries(obj)) {\\n        if (key.length > 0) return false\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760369,
                "title": "is-object-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(let key in obj){\\n      if(key!==null){\\n        return false\\n      }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    for(let key in obj){\\n      if(key!==null){\\n        return false\\n      }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753147,
                "title": "is-there-a-more-efficient-solution-for-this-task-i-m-looking-forward-to-your-replies",
                "content": "\\n```\\n\\nconst isEmpty = (obj) => {\\n   return Object.keys(obj).length === 0\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst isEmpty = (obj) => {\\n   return Object.keys(obj).length === 0\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751395,
                "title": "simple-one-line-solution",
                "content": "var isEmpty = function(obj) {\\n   return Object.keys(obj).length <=0? true:false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var isEmpty = function(obj) {\\n   return Object.keys(obj).length <=0? true:false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3750567,
                "title": "easiest-way-to-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0 ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749378,
                "title": "2727-is-object-empty-umarbek-s-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length===0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length===0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3747713,
                "title": "easy-js-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return !Boolean(Object.keys(obj).length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function (obj) {\\n    return !Boolean(Object.keys(obj).length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746118,
                "title": "easy-1-line-solution-just-return",
                "content": "# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return Object.keys(obj).length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743876,
                "title": "solved",
                "content": "# Noob Approches \\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     if (Object.keys(obj).length>=1) \\n        return false;\\n    if(Object.keys(obj).length===0) return true;\\n    if(Array.isArray(obj)){\\n        if(obj.length>=1)\\n            return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n     if (Object.keys(obj).length>=1) \\n        return false;\\n    if(Object.keys(obj).length===0) return true;\\n    if(Array.isArray(obj)){\\n        if(obj.length>=1)\\n            return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740484,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    switch(typeof(obj)){\\n        case \"array\":\\n            if(obj.length === 0){\\n             return true\\n            }\\n            return false\\n        break\\n        case \"object\":\\n            if(Object.entries(obj).length === 0){\\n                return true\\n            }\\n             return false\\n        break\\n    }\\n    \\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    switch(typeof(obj)){\\n        case \"array\":\\n            if(obj.length === 0){\\n             return true\\n            }\\n            return false\\n        break\\n        case \"object\":\\n            if(Object.entries(obj).length === 0){\\n                return true\\n            }\\n             return false\\n        break\\n    }\\n    \\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739672,
                "title": "object-keys-obj-returns-an-array-of-keys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737869,
                "title": "actual-isempty-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is only asking two things\\n1. If input is an object and if it has atleast one object return true else return false\\n2. If input is an array and if it\\'s length is greater than `0` return true else return false\\n\\n\\nI\\'ve realised this later.\\n\\nAnyway i\\'m sharing my solution, which will work for more depth cases and hope someone find it useful.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(!obj){\\n        return true;\\n    }\\n\\n    if(Array.isArray(obj)){\\n        return isEmptyArray(obj);\\n    }\\n\\n    return isEmptyObject(obj);\\n    \\n};\\n\\nconst isEmptyArray = (arr) => {\\n    if(arr.length === 0){\\n        return true;\\n    }\\n\\n    for(let ele of arr){\\n        if(ele === false || ele === 0 || ele === \"\" || ele){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nconst isEmptyObject = (obj) => {\\n    if(!obj){\\n        return true;\\n    }\\n\\n    for(key in obj){\\n        if(obj[key] === false || obj[key] === 0 || obj[key] === \"\" || obj[key]){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if(!obj){\\n        return true;\\n    }\\n\\n    if(Array.isArray(obj)){\\n        return isEmptyArray(obj);\\n    }\\n\\n    return isEmptyObject(obj);\\n    \\n};\\n\\nconst isEmptyArray = (arr) => {\\n    if(arr.length === 0){\\n        return true;\\n    }\\n\\n    for(let ele of arr){\\n        if(ele === false || ele === 0 || ele === \"\" || ele){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nconst isEmptyObject = (obj) => {\\n    if(!obj){\\n        return true;\\n    }\\n\\n    for(key in obj){\\n        if(obj[key] === false || obj[key] === 0 || obj[key] === \"\" || obj[key]){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734443,
                "title": "simplest-method-in-one-line",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    return !Object.keys(obj).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734250,
                "title": "js-solution",
                "content": "```\\nlet isEmpty = o => !Object.entries(o).length;\\n```",
                "solutionTags": [],
                "code": "```\\nlet isEmpty = o => !Object.entries(o).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733688,
                "title": "well-explained-solution",
                "content": "## Solution Approach\\nThe isEmpty function is defined with a parameter obj, which represents the object or array that we want to check for emptiness.\\n\\nThe function starts with an if statement to check if the obj is an array using the Array.isArray method:\\n\\n- If obj is an array, it checks if the length of the array (obj.length) is equal to 0. If it is, it means the array is empty, so the function returns true.\\n- If the length is not 0, it means the array has elements, so the function returns false.\\n\\nIf the obj is not an array, the function proceeds to the next if statement, which checks if the obj is an object and not null using typeof and the null check:\\n\\n- If obj is an object and not null, it uses Object.keys(obj) to retrieve an array of keys for the object. The Object.keys method returns an empty array if the object has no enumerable keys.\\n- The function then checks if the length of the keys array (Object.keys(obj).length) is equal to 0. If it is, it means the object has no key-value pairs and is empty, so the function returns true.\\n- If the length is not 0, it means the object has keys and is not empty, so the function returns false.\\n\\nIf the obj is neither an array nor an object, the function reaches the return false statement, indicating that it is not empty.\\n\\n# Code\\n```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    }\\n\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).length === 0;\\n    }\\n\\n    return false;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object | Array} obj\\n * @return {boolean}\\n */\\nvar isEmpty = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj.length === 0;\\n    }\\n\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).length === 0;\\n    }\\n\\n    return false;\\n};\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2033378,
                "content": [
                    {
                        "username": "ategale",
                        "content": "How to catch {\"\": \"\"} without using an if statement?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "if it is also an array then why can\\'t i simply find if the length of the array is zero and return true."
                    },
                    {
                        "username": "akv11",
                        "content": "But it can also be an object. So we have to use conditions for both array and object."
                    }
                ]
            },
            {
                "id": 1977750,
                "content": [
                    {
                        "username": "ategale",
                        "content": "How to catch {\"\": \"\"} without using an if statement?"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "if it is also an array then why can\\'t i simply find if the length of the array is zero and return true."
                    },
                    {
                        "username": "akv11",
                        "content": "But it can also be an object. So we have to use conditions for both array and object."
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Closest Marked Node",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Minimum Operations to Make the Integer Zero",
        "question_content": "<p>You are given two integers <code>num1</code> and <code>num2</code>.</p>\n\n<p>In one operation, you can choose integer <code>i</code> in the range <code>[0, 60]</code> and subtract <code>2<sup>i</sup> + num2</code> from <code>num1</code>.</p>\n\n<p>Return <em>the integer denoting the <strong>minimum</strong> number of operations needed to make</em> <code>num1</code> <em>equal to</em> <code>0</code>.</p>\n\n<p>If it is impossible to make <code>num1</code> equal to <code>0</code>, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = 3, num2 = -2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can make 3 equal to 0 with the following operations:\n- We choose i = 2 and substract 2<sup>2</sup> + (-2) from 3, 3 - (4 + (-2)) = 1.\n- We choose i = 2 and substract 2<sup>2</sup>&nbsp;+ (-2) from 1, 1 - (4 + (-2)) = -1.\n- We choose i = 0 and substract 2<sup>0</sup>&nbsp;+ (-2) from -1, (-1) - (1 + (-2)) = 0.\nIt can be proven, that 3 is the minimum number of operations that we need to perform.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = 5, num2 = 7\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It can be proven, that it is impossible to make 5 equal to 0 with the given operation.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1 &lt;= 10<sup>9</sup></code></li>\n\t<li><code><font face=\"monospace\">-10<sup>9</sup>&nbsp;&lt;= num2 &lt;= 10<sup>9</sup></font></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3679094,
                "title": "linear-search-on-answer-ft-bit-count",
                "content": "# Intuition\\nAfter a bit of playing around, it seems hard to find an explicit formula for the answer. As with many computer science problems, we can instead try to search over the answer space, trading runtime for ease of implementation.\\n\\n# Approach\\nWe can test whether or not $$k$$ operations is sufficient for some given $$k$$.\\n1. If $$k$$ operations are used, then $$\\\\mathrm{num1} = (\\\\mathrm{num2} + 2^{i_1}) + (\\\\mathrm{num2} + 2^{i_2}) + \\\\dots + (\\\\mathrm{num2} + 2^{i_k}) = k\\\\cdot\\\\mathrm{num2} + (2^{i_1}+2^{i_2}+\\\\dots+2^{i_k})$$ for some $$i_1,i_2,\\\\dots,i_k\\\\in [0, 60]$$.\\n2. Rearranging, this gives $$\\\\mathrm{target}:=\\\\mathrm{num1}-k\\\\cdot\\\\mathrm{num2}=2^{i_1}+2^{i_2}+\\\\dots+2^{i_k}$$.\\n3. Observe that we can construct any positive integer $$x$$ with at least $$x\\\\mathrm{.bit\\\\_count}()$$ powers of two and at most $$x$$ powers of two. This is because we can start with the powers of two that make up the bits of $$x$$, then continue to split apart larger powers of two into smaller powers of two until we are left with just 1\\'s. For instance, $$5=4+1=(2+2)+1=2+(1+1)+1=(1+1)+1+1+1$$. Thus, we must have `target.bit_count() <= k <= target`.\\n\\nUsing the above algorithm to determine whether a certain number of operations is valid, we can do a linear search through all possible number of operations in $$[0, 60]$$ and take the minimum valid answer.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for k in range(61):\\n            target = num1 - k * num2\\n            if target >= 0 and target.bit_count() <= k <= target:\\n                return k\\n        return -1\\n```\\n\\n#### Edit: Why the answer is bounded from above by 60\\nFor those who are asking, here\\'s an explanation of why the answer is bounded from above by 60. It can be seen intuitively but may require a bit of casework to prove rigorously.\\n\\nAssume there is no valid answer for `k <= 60`. Then, at least one of the following hold for `k = 60`:\\n1. `target < 0`,\\n2. `target.bit_count() > k`, or\\n3. `k > target`.\\n\\n(2) is impossible since `target := num1 - k * num2` is bounded from above by the input constraints.\\n\\nIf (1) is true, then `num1 - k * num2 < 0` implies `num2 > 0`, meaning `target` is strictly decreasing while `k` is strictly increasing. If we have not found a solution by this point, this implies there is no solution past 60.\\n\\nIf (3) is true, `k > num1 - k * num2` implies `k * (num2 + 1) > num1`, meaning either `num2 = 0`, in which case `k = num1.bit_count()` will have previously been a valid answer, or `num2 > 0`. Again, `target` is strictly decreasing while `k` is strictly increasing; there is no solution.\\n\\nIn all cases, there is either a contradiction or no solution; `k` is bounded from above. As a matter of fact, I believe there can be a tighter bound on `k` as long as the argument for (2) holds.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for k in range(61):\\n            target = num1 - k * num2\\n            if target >= 0 and target.bit_count() <= k <= target:\\n                return k\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679236,
                "title": "c-java-python-beginner-friendly-bit-manipulation",
                "content": "# Intution\\n- The given code aims to find the minimum number of steps required to make a given integer, num1, zero by subtracting num2 from it in each step. \\n- The code first checks if num1 is smaller than num2, in which case it is not possible to make it zero and returns -1. \\n- It then iterates through a range of steps, from 0 to 100, Within each iteration, I calculate the difference between num1 and the product of num2 and the current step. This difference is stored in the variable diff. \\n- To count the number of bits set to 1 in diff, I use the countBits function. If the number of bits is less than or equal to the current step and the step itself falls within the range of diff, it indicates that it is possible to make num1 zero in the current number of steps. In such cases, I return the minimum number of steps required.\\n\\nIf none of the valid step counts are found within the given range, then return -1, indicating that it is not possible to make num1 zero using the given subtraction operation.\\n\\n---\\n\\n\\n# C++ Code\\n```\\nclass Solution { \\npublic: \\n    int countBits(long long num) { \\n        int count = 0; \\n        while (num > 0) { \\n            count += num & 1; \\n            num >>= 1; \\n        } \\n        return count; \\n    } \\n\\n    int makeTheIntegerZero(int num1, int num2) { \\n        if (num1 < num2) { \\n            return -1; \\n        } \\n \\n        for (int steps = 0; steps <= 100; steps++) { \\n            long long diff = num1 - 1LL*(num2) * steps; \\n            int bits = countBits(diff); \\n            if (bits <= steps && steps <= diff) { \\n                return steps; \\n            } \\n        } \\n \\n        return -1; \\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public int countBits(long num) {\\n        int count = 0;\\n        while (num > 0) {\\n            count += num & 1;\\n            num >>= 1;\\n        }\\n        return count;\\n    }\\n\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2) {\\n            return -1;\\n        }\\n\\n        for (int steps = 0; steps <= 100; steps++) {\\n            long diff = num1 - 1L * num2 * steps;\\n            int bits = countBits(diff);\\n            if (bits <= steps && steps <= diff) {\\n                return steps;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n# Python Code \\n```\\ndef countBits(self, num):\\n        count = 0\\n        while num > 0:\\n            count += num & 1\\n            num >>= 1\\n        return count\\n\\n    def makeTheIntegerZero(self, num1, num2):\\n        if num1 < num2:\\n            return -1\\n\\n        for steps in range(101):\\n            diff = num1 - 1 * num2 * steps\\n            bits = self.countBits(diff)\\n            if bits <= steps and steps <= diff:\\n                return steps\\n\\n        return -1\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution { \\npublic: \\n    int countBits(long long num) { \\n        int count = 0; \\n        while (num > 0) { \\n            count += num & 1; \\n            num >>= 1; \\n        } \\n        return count; \\n    } \\n\\n    int makeTheIntegerZero(int num1, int num2) { \\n        if (num1 < num2) { \\n            return -1; \\n        } \\n \\n        for (int steps = 0; steps <= 100; steps++) { \\n            long long diff = num1 - 1LL*(num2) * steps; \\n            int bits = countBits(diff); \\n            if (bits <= steps && steps <= diff) { \\n                return steps; \\n            } \\n        } \\n \\n        return -1; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int countBits(long num) {\\n        int count = 0;\\n        while (num > 0) {\\n            count += num & 1;\\n            num >>= 1;\\n        }\\n        return count;\\n    }\\n\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2) {\\n            return -1;\\n        }\\n\\n        for (int steps = 0; steps <= 100; steps++) {\\n            long diff = num1 - 1L * num2 * steps;\\n            int bits = countBits(diff);\\n            if (bits <= steps && steps <= diff) {\\n                return steps;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```\\ndef countBits(self, num):\\n        count = 0\\n        while num > 0:\\n            count += num & 1\\n            num >>= 1\\n        return count\\n\\n    def makeTheIntegerZero(self, num1, num2):\\n        if num1 < num2:\\n            return -1\\n\\n        for steps in range(101):\\n            diff = num1 - 1 * num2 * steps\\n            bits = self.countBits(diff)\\n            if bits <= steps and steps <= diff:\\n                return steps\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679147,
                "title": "2-approach-easy-intuition-bit-manuclation-bfs",
                "content": "# INTUITION\\n\\nTo make **num1 equal to zero**, we perform a series of operations. We start by **subtracting num2 from num1**, and then subtract powers of two (2^k1, 2^k2, and so on) from the result.\\n\\nWhen we rearrange the equation, we get:\\n\\n# num1 - k * num2 - (2^k1 + 2^k2 + ...)==0\\n\\n**This equation states that num1 can be expressed as the sum of k times num2 and the sum of powers of two.**\\n\\n**The goal is to find the values of k and the powers of two that make num1 equal to zero.** By subtracting num2 and powers of two from num1 in each step, we aim to reduce the remaining value to zero.\\n\\nTherefore, the problem becomes finding the minimum combination of k and the powers of two needed to reach zero.\\n\\n\\n\\n#  Why checking bits and steps\\n\\nHere\\'s why these conditions are important:\\n\\n***Checking the number of set bits (bits):*** The count of set bits in the diff value represents the **number of powers of two needed to construct the remaining value after subtracting num2 * steps from num1.** Recall that each power of two corresponds to an operation. If the count of set bits is less than or equal to the current step, it means that we have enough powers of two to perform the required operations within the given step count.\\n\\n***Checking if the step falls within the range of diff:*** The range of diff represents the remaining value after subtracting num2 * steps from num1. If the current step falls within this range,**it indicates that we can continuously subtract powers of two from the remaining value until it becomes zero.** By ensuring the step falls within the range, we confirm that the remaining value can be reduced to zero using the given number of steps.\\n\\nBy checking both conditions, we ensure that we have enough powers of two and a valid range to perform the necessary operations and make num1 equal to zero. If both conditions are met, the function returns the minimum number of steps required. Otherwise, it continues to the next iteration to check for other possible step counts.\\n\\nIn summary, the conditions of checking the number of set bits and the range of diff validate the feasibility of making num1 zero within the given step count and help in determining the minimum number of steps required.\\n\\n# Code\\n```\\nclass Solution { \\npublic: \\n        int countBits(long long num) { \\n        int count = 0; \\n        while (num > 0) { \\n            count += num & 1; \\n            num >>= 1; \\n        } \\n        return count; \\n    } \\n    int makeTheIntegerZero(int num1, int num2) { \\n        if (num1 < num2) { \\n            return -1; \\n        } \\n \\n        for (int steps = 0; steps <= 40; steps++) { \\n            long long diff = num1 - (num2) * 1LL*steps; \\n            int bits = countBits(diff); \\n            if (bits <= steps && steps <= diff) { \\n                return steps; \\n            } \\n        } \\n \\n        return -1; \\n    } \\n     \\n\\n\\n};\\n```\\n#  Bfs But its give tle \\nThi is first approach come in my mind \\n``` class Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2)\\n            return -1;\\n        if (num1 == 0)\\n            return 0;\\n        \\n        int level = 0;\\n        queue<long long> q;\\n        q.push(num1);\\n        unordered_set<long long> vis;\\n        vis.insert(num1);\\n        \\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                long long curr = q.front();\\n                q.pop();\\n                    if (curr == 0)\\n                    return level;\\n                curr=curr-num2;\\n                \\n                for (int i = 0; i <= 60; i++) {\\n                    long long power = 1ULL << i;\\n                    if (curr - power >= 0 && vis.count(curr - power) == 0) \\n                    {\\n                        vis.insert(curr - power);\\n                        q.push(curr - power);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic: \\n        int countBits(long long num) { \\n        int count = 0; \\n        while (num > 0) { \\n            count += num & 1; \\n            num >>= 1; \\n        } \\n        return count; \\n    } \\n    int makeTheIntegerZero(int num1, int num2) { \\n        if (num1 < num2) { \\n            return -1; \\n        } \\n \\n        for (int steps = 0; steps <= 40; steps++) { \\n            long long diff = num1 - (num2) * 1LL*steps; \\n            int bits = countBits(diff); \\n            if (bits <= steps && steps <= diff) { \\n                return steps; \\n            } \\n        } \\n \\n        return -1; \\n    } \\n     \\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679281,
                "title": "java-c-python-bit-count-4-lines",
                "content": "# **Explanation**\\nStart from `k = 1`,\\nto check if `num = num1 - num2 * k` can be the sum of `k` pow sof 2.\\n\\nThe maximum operations is `num`, `num = (2 ^ 0) * num`.\\nThe minimum operations is `num` bits count.\\n\\nIf `num.bit_count() <= k <= num`,\\nthen `num` can be the sum of `k` pows of 2.\\n<br>\\n\\n# **Complexity**\\nTime `O(60log(num1 + num2))`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int makeTheIntegerZero(long x, long y) {\\n        for (int k = 1; k < 61; k++)\\n            if (Long.bitCount(x - k * y) <= k && k <= x - k * y)\\n                return k;\\n        return -1;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int makeTheIntegerZero(long x, long y) {\\n        for (int k = 1; k < 61; k++)\\n            if (__builtin_popcountll(x - k * y) <= k && k <= x - k * y)\\n                return k;\\n        return -1;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def makeTheIntegerZero(self, x: int, y: int) -> int:\\n        for k in range(1, 61):\\n            if (x - k * y).bit_count() <= k <= x - k * y:\\n                return k\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int makeTheIntegerZero(long x, long y) {\\n        for (int k = 1; k < 61; k++)\\n            if (Long.bitCount(x - k * y) <= k && k <= x - k * y)\\n                return k;\\n        return -1;\\n    }\\n```\n```cpp\\n    int makeTheIntegerZero(long x, long y) {\\n        for (int k = 1; k < 61; k++)\\n            if (__builtin_popcountll(x - k * y) <= k && k <= x - k * y)\\n                return k;\\n        return -1;\\n    }\\n```\n```py\\n    def makeTheIntegerZero(self, x: int, y: int) -> int:\\n        for k in range(1, 61):\\n            if (x - k * y).bit_count() <= k <= x - k * y:\\n                return k\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3680006,
                "title": "explained-cpp-solution",
                "content": "# Objective\\nOur objective is to minimize the number of steps required to make `num1` equal to `0` by repeatedly subtracting `(2^any + num2)` from `num1`.\\n\\n# Intuition\\nAfter observing 3-4 iterations, a pattern becomes apparent:\\n\\n```\\nop = 0: num1  ==>  num1 - num2*0 - (2^any)*0 \\nop = 1: num1 - (2^any + num2)  ==>  num1 - num2*1 - (2^any)*1 \\nop = 2: num1 - (2^any + num2) - (2^any + num2)  ==>  num1 - num2*2 - (2^any)*2 \\nop = 3: num1 - (2^any + num2) - (2^any + num2) - (2^any + num2)  ==>  num1 - num2*3 - (2^any)*3 \\n... and so on\\n```\\n\\nFrom this observation, we deduce that at operation `k`, the formula becomes:\\n\\n```\\nnum1 - num2*k - (2^any)*k  \\n```\\n\\nwhere `any` is a power between `[0,60]`. \\n\\n# Approach\\n- To solve the problem, we aim to find the minimum value of `k` at which the expression `num1 - num2*k - (2^any)*k` becomes 0.\\n- To determine the minimum value, we check if `num1 - num2*k = (2^any)*k`. \\n- We can represent any number between `[k*2^0 , k*2^60]` using this combination `(2^any)*k = 2^any + 2^any + 2^any + ... ktimes`.\\n\\nHence, the problem can be simplified by determining the minimum number of iterations that satisfy the condition `k <= num1 - num2*k <= k*2^60`.\\n\\nSince we know that a decimal number is created from binary bits, we can leverage bit manipulation techniques to evaluate the expression `num1 - num2*k <= k*2^60`. \\n\\nIf the count of set bits (bits with a value of 1) in `num1 - num2*k` is less than or equal to `k`, it indicates that we can easily obtain the value of `num1 - num2*k` using the product `k*2^any`.\\n\\n### For example, \\nConsider a scenario where the value of `num1 - num2*k` is `9`, which can be represented as `(1001)` in binary. In this case, by selecting `k = 2`, we can observe that `k*2^any` becomes `2^3 + 2^1`, which indeed equals `9`. This demonstrates how the use of the appropriate `k` value combined with the power of 2 (`2^any`) allows us to generate the desired decimal representation.\\n\\n## Final conclusion \\nTo solve the problem, we can implement a simple iteration from `0 to 60`. During each iteration, we check if there exists a combination `(k <= x && setBits(x) <= k)` that satisfies the given conditions. If such a combination is found, we return the value of `k`. However, if no such combination is found within the range, we return -1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to count the number of set bits (means 1) in a number\\n    int setBits(long long n) {\\n        int c = 0;\\n        while (n > 0) {\\n            c += n % 2;\\n            n /= 2;\\n        }\\n        return c;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2)\\n            return -1;\\n\\n        for (int k = 0; k < 61; ++k) {\\n            long long x = (long long)num1 - (long long)(num2) * k;\\n            \\n            /* Check if the k <= num1 - num2*k && setBits in `num1 - num2*k` <= k\\n             return answer as k; */\\n            if (k <= x && setBits(x) <= k ) {\\n                return k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```\\n\\n##### I understand that this question may appear somewhat complex / tricky, and I have tried to explain my solution as much I can. If you find this solution helpful, please consider upvoting it \\uD83D\\uDC4D.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nop = 0: num1  ==>  num1 - num2*0 - (2^any)*0 \\nop = 1: num1 - (2^any + num2)  ==>  num1 - num2*1 - (2^any)*1 \\nop = 2: num1 - (2^any + num2) - (2^any + num2)  ==>  num1 - num2*2 - (2^any)*2 \\nop = 3: num1 - (2^any + num2) - (2^any + num2) - (2^any + num2)  ==>  num1 - num2*3 - (2^any)*3 \\n... and so on\\n```\n```\\nnum1 - num2*k - (2^any)*k  \\n```\n```\\nclass Solution {\\npublic:\\n    // Function to count the number of set bits (means 1) in a number\\n    int setBits(long long n) {\\n        int c = 0;\\n        while (n > 0) {\\n            c += n % 2;\\n            n /= 2;\\n        }\\n        return c;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2)\\n            return -1;\\n\\n        for (int k = 0; k < 61; ++k) {\\n            long long x = (long long)num1 - (long long)(num2) * k;\\n            \\n            /* Check if the k <= num1 - num2*k && setBits in `num1 - num2*k` <= k\\n             return answer as k; */\\n            if (k <= x && setBits(x) <= k ) {\\n                return k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679519,
                "title": "go-backwards",
                "content": "Instead of iteratively applying operations, we check if we can achieve the result with `cnt` operations.\\n\\nWith `cnt` operations, `num1` should equal  `cnt * num2 + diff`.\\n\\n`diff` is the sum of `cnt` single-bit numbers; a single-bit number is 2 power something.\\n\\nSo, we check if we can make `diff`:\\n- Number of bits in `diff` should not exceed `cnt`.\\n- The minimum possible sum is `cnt * (2 ^ 0)`, so `cnt` should not be larger than `diff`.\\n\\n**C++**\\nNote that, instead of computing `diff` as `num1 - cnt * num2`, we can just subtract `num2` from `num1` for each iteration.\\n\\nAlso, we can limit `cnt` to `34`. The biggest possible value (`10e9 - cnt *(-10e9)`) can have up to 35 bits.\\n\\n```cpp\\nint makeTheIntegerZero(long long num1, long long num2) {\\n    for (int cnt = 1; cnt < 35 && num1 > 0; ++cnt) {\\n        num1 -= num2;\\n        if (__builtin_popcountll(num1) <= cnt && cnt <= num1)\\n            return cnt;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint makeTheIntegerZero(long long num1, long long num2) {\\n    for (int cnt = 1; cnt < 35 && num1 > 0; ++cnt) {\\n        num1 -= num2;\\n        if (__builtin_popcountll(num1) <= cnt && cnt <= num1)\\n            return cnt;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3681957,
                "title": "i-make-a-blunder",
                "content": "**Intution**\\n\\nlet **nums1 = x** and **nums2 = y**\\n\\nSo, given operation is substracting **2^i + y from x** which result in following equation if we do this one time\\n\\n**x = x - (2^i + y)**\\n\\nif second time, but with this time I choose some other number from [1,60] so substract **2^j + y**, Now equation looks something like\\n\\n**x = x - (2^i+y) - (2^j+y) **\\n\\nand if do it for some L times then it will look something like this\\n\\n**x =  x - (2^i+y) - (2^j+y) - (2^k+y) ........................... L times**\\n\\nat the end of the day we want LHS to be zero, so replace LHS with zero and reordering equation you will get\\n\\n**x - L * y = 2^i + 2^j + 2^k ................. L times**\\n\\n\\nNow I think you might guess. You only need to check if number can be represented as **sum of power of 2**. L ranges from [1,60] according to constraint \\n\\nThis is the code\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int bit(long long a){\\n            \\n            int count = 0;\\n            while(a){\\n                    if(a&1){\\n                            count++;   \\n                    }\\n                    a = a >> 1;\\n            }\\n            \\n            return count;\\n    }    \\n    int makeTheIntegerZero(int n1, int n2) {\\n        if(n1 - n2  < 0) return -1;\\n            \\n        long long num1 = n1;\\n        long long num2 = n2;    \\n        \\n        for(int i = 1;i<=60;i++){\\n                if((num1 - i * num2) <= 0) break;\\n                \\n                int x = bit(num1 - i * num2);\\n                \\n                if(x <= i) return i;\\n        }    \\n            return -1;\\n            \\n    }\\n};\\n```\\n\\nAbove code is wrong if you submit the above code you will see 356/357 Test case Passed And it happens with me in the contest\\nhttps://leetcode.com/submissions/detail/979421278/\\n\\nThe Condition I am missing is\\n\\n```\\n                if(x <= i && i <= (num1 - i * num2) ) return i;\\n```\\n\\nSo, Add this line inside the for loop second if condition and it work fine\\n\\nLink to AC\\n\\nhttps://leetcode.com/submissions/detail/979423011/ \\n\\nRuntime : 0ms \\nTime : O(logn)\\nSpace : O(1)\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bit(long long a){\\n            \\n            int count = 0;\\n            while(a){\\n                    if(a&1){\\n                            count++;   \\n                    }\\n                    a = a >> 1;\\n            }\\n            \\n            return count;\\n    }    \\n    int makeTheIntegerZero(int n1, int n2) {\\n        if(n1 - n2  < 0) return -1;\\n            \\n        long long num1 = n1;\\n        long long num2 = n2;    \\n        \\n        for(int i = 1;i<=60;i++){\\n                if((num1 - i * num2) <= 0) break;\\n                \\n                int x = bit(num1 - i * num2);\\n                \\n                if(x <= i) return i;\\n        }    \\n            return -1;\\n            \\n    }\\n};\\n```\n```\\n                if(x <= i && i <= (num1 - i * num2) ) return i;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679098,
                "title": "c-simple-bit-manipulation-solution-explained-with-examples-o-1",
                "content": "**Intuition 1:**\\nIgnore num2 for now. \\n\\nFor a number 5, the maximum operations to reduce to zero is `1 * 5`. The minimum number of operations to reduce to zero is the bit count of 5(`101`) which is 2. Therefore, for any i within the range `[min operations, max operations]`, there exists a sequence of ith operations that reduce the number to 0.\\n\\ne.g.\\nRange for 9 is `[2, 9]`. Since bitcount of 9 is `1001`, min possible operations to reduce 9 to 0 is 2.\\n\\n**Intuition 2:**\\nNow taking into account num2.\\nFor each additional operation, you have to add num2 to num1.\\nValue of `nth operation` = `num1 - (n * num2)`\\n\\nUse intuition 1 to check if `n` is within the range of `num1 + n * num2`.\\n\\ne.g. Example 1 where num1 = 3 and num2 = -2\\n`operations = 1`: val = 3 - (1 * -2) = 5. range is `[2, 5]` but 1 is not within range, so it is not possible.\\n`operations = 2`: val = 3 - (2 * -2) = 7. range is `[3, 7]` but 2 is not within range, so it is not possible.\\n`operations = 3`: val = 3 - (3 * -2) = 9. range is `[2, 9]`, since 3 is within the range, it is possible.\\nAnswer is 3 operations.\\n\\n**Time complexity:**\\nMaximum number of operations is 61.\\nThat is the case where all bits in position 0 to 60 is set to 1. Any greater and you cannot subtract.\\nTherefore, range is `[61, 1<<61 - 1]`. Hence, just need to check for operations up to 61. Therefore, O(1).\\n\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int opt = 0;\\n        long long lnum1 = (long long) num1;\\n        long long lnum2 = (long long) num2;\\n        \\n        while (lnum1 >= 0 && opt <= 61) {\\n            int count = __builtin_popcountll(lnum1);\\n            if (opt >= count && opt <= lnum1) {\\n                return opt;\\n            }\\n            opt++;\\n            lnum1 -= lnum2;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int opt = 0;\\n        long long lnum1 = (long long) num1;\\n        long long lnum2 = (long long) num2;\\n        \\n        while (lnum1 >= 0 && opt <= 61) {\\n            int count = __builtin_popcountll(lnum1);\\n            if (opt >= count && opt <= lnum1) {\\n                return opt;\\n            }\\n            opt++;\\n            lnum1 -= lnum2;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679108,
                "title": "java-python-3-bit-count-and-greedy-algorithm-w-explanation-and-analysis",
                "content": "**Intuition:**\\nSince `num1 > 0`, at least `1` operation needed to make it `0`. Assume we need at least `k` operations, then \\n\\nnum1 = k * num2 + (2<sup>i1</sup> + 2<sup>i2</sup> + ... + 2<sup>ik</sup>)\\n\\nTherefore, we can use greedy algorithm to iterate `k` starting from `1` till `num1 - k * num2` can be expressed as 2<sup>i1</sup> + 2<sup>i2</sup> + ... + 2<sup>ik</sup>, or `num1 - k * num2 < = 0`, in which case there is no solution.\\n\\nHow to guarantee a `int` can be expressed as 2<sup>i1</sup> + 2<sup>i2</sup> + ... + 2<sup>ik</sup> ?\\n\\n**Key Insight:**\\n1. `num1 - k * num2` at most has `k` set bits, otherwise it would be separated into MORE THAN `k` terms as those in  2<sup>i2</sup> + ... + 2<sup>ik</sup>;\\n2. `num1 - k * num2`is no more than `k`, otherwise  it would be separated into LESS THAN `k` terms as those in  2<sup>i2</sup> + ... + 2<sup>ik</sup>;\\n3. If above 2 conditions are met and `num1 - k * num2 < k`, we can always separate the more significant set bits into less significant set bits to make `k` terms as 2<sup>i2</sup> + ... + 2<sup>ik</sup>, e.g.,  \\n`num1 - k * num2 = 9 =` 2<sup>3</sup> + 2<sup>0</sup>  has `2` set bits, \\na) if `k = 3`, then we can split 2<sup>3</sup> into 2<sup>2</sup> + 2<sup>2</sup>, hence `num1 - k * num2 = 9 =`2<sup>2</sup> + 2<sup>2</sup> + 2<sup>0</sup>.\\nb) if `k = 9`, then we can split 2<sup>3</sup> into 8 * 2<sup>0</sup> =  2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup>, hence `num1 - k * num2 = 9 *`2<sup>0</sup>  = 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup>.\\n\\nNote: Java need `long` type to avoid `int` overflow.\\n\\n----\\n\\n\\n```java\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        int k = 0;\\n        long n = num1;\\n        while (n > 0) {\\n            n -= num2;\\n            if (Long.bitCount(n) <= ++k && k <= n) {\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n```python\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        k = 0\\n        while num1 > 0:\\n            num1 -= num2\\n            k += 1\\n            if num1.bit_count() <= k <= num1:\\n                return k\\n        return -1\\n```\\n\\n**Analysis:**\\n\\nIn worst case `k = O(log(num1 + k * abs(num2))) ~ O(log(k * max(num1, abs(num2)))) ~ O(logk + log(max(num1, abs(num2)))) ~ O(log(max(num1, abs(num2))))`, therefore\\n\\nTime: `O(log(max(num1, abs(num2))))`, space: `O(1)`.\\n\\n----\\n\\n**Q & A:**\\n\\n*Q1:* Why `k <= n`(`k <= num1`) in your Java (Python 3) code?\\n\\n*A1:* Since for any non-negative integer `i`, 2<sup>i</sup> `>= 1`, we can at most separate `n`  into `n` terms of   2<sup>0</sup>. If `k > n`, then 2<sup>i1</sup> + 2<sup>i2</sup> + ... + 2<sup>ik</sup> `>= k` * 2<sup>0</sup>  `> n`,  which means that we are short of the term of 2<sup>i</sup> for `n`, hence there would be no way to express `n` as `k` terms of 2<sup>i</sup>, e.g., 2<sup>i1</sup> + 2<sup>i2</sup> + ... + 2<sup>ik</sup>. Therefore, in such case there would be no solution as a result.\\n\\n**End of Q & A**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```java\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        int k = 0;\\n        long n = num1;\\n        while (n > 0) {\\n            n -= num2;\\n            if (Long.bitCount(n) <= ++k && k <= n) {\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        k = 0\\n        while num1 > 0:\\n            num1 -= num2\\n            k += 1\\n            if num1.bit_count() <= k <= num1:\\n                return k\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3681390,
                "title": "it-s-36-not-60-iterations",
                "content": "to understand why 36 read [base solution](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/discuss/3679094/Linear-Search-On-Answer-(ft.-Bit-Count)) ~~right before edit~~.\\n\\nMy Intuition:\\n**max val of (num1 - k * num2) = (k + 1) * 10 ^ 9;\\nmin value of target if all i were different in base answer: 2 ^ k - 1**\\n\\nusing calculator to find first value of k for which (k + 1) * 10 ^ 9 <= 2 ^ k - 1 becomes true\\n\\nwhich turns out to be k = 36\\n\\nhence if there is any answer it should be there for k <= 36 for given Constraints!\\n\\ncode:\\n```c++\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for (int k = 1; k <= 36; k++) {\\n            long long diff = num1 - 1LL * k * num2;\\n            if (__builtin_popcountll(diff) <= k && k <= diff)\\n                return k;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for (int k = 1; k <= 36; k++) {\\n            long long diff = num1 - 1LL * k * num2;\\n            if (__builtin_popcountll(diff) <= k && k <= diff)\\n                return k;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679118,
                "title": "python-iterate-the-answer-explanation",
                "content": "We can solve in another way:\\nConsider that we use `ans` operations, then we will have `num1 = (summation of power of 2) + ans * num2`\\nand we know any number can be split to the summation of at least the count of \\'1\\' of power of 2.\\nFor example, 19 = 0b100101 = 0b100000 + 0b100 + 0b1 = 0b1 * 19, so we can split it into [3, 19] count of power of 2.\\n\\nThe algorithm is, every time we minus num2 from num1, and check if bitcount(num1) <= ans <= num1.\\nThis algorithm will stop when we at most give `ans = 64`: \\n`num1 + 64 * num2 < 10^11 < 2 ^ 64` => `log2(num1 + 64 * num2) < 64 = ans < num1`\\n\\n```python[]\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        ans = 0\\n        while bin(num1).count(\\'1\\') > ans:\\n            ans += 1\\n            num1 -= num2\\n            if num1 < ans and num2 > 0:\\n                return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python[]\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        ans = 0\\n        while bin(num1).count(\\'1\\') > ans:\\n            ans += 1\\n            num1 -= num2\\n            if num1 < ans and num2 > 0:\\n                return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679097,
                "title": "c-java-python-enumerate-the-number-of-operations-w-brief-explanation",
                "content": "Let `x` be the number of operations, then we have:\\n```\\nnum1 - (2^i + num2) - (2^j + num2) - (2^k + num2) - ... = 0\\nnum1 - 2^i - num2 - 2^j - num2 - 2^k - num2 - ... = 0\\nnum1 - x * num2 = 2^i + 2^j + 2^k + ...\\n```\\n\\nNext, we list the values of `x` in ascending order and verify if the equation `num1 - x * num2 = 2^i + 2^j + 2^k + ...` is true.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for (int x = 0; x <= 60; x++) {\\n            long tmp = (long)(num1 - (long)x * num2);\\n            if (tmp < 0) continue;\\n            vector<long> vec;\\n            for (int k = 0; k <= 61; k++) {\\n                if (((1l << k) & tmp) != 0) {\\n                    vec.push_back(1l << k);\\n                }\\n            }\\n            long sum = 0l;\\n            for (long num : vec) sum += num;\\n            if (vec.size() <= x && sum >= x) return x;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nJava:\\n```\\npublic class Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        for (int x = 0; x <= 100; x++) {\\n            long tmp = (long)(num1 - (long)x * num2);\\n            if (tmp < 0) continue;\\n            List<Long> list = new ArrayList<>();\\n            for (int k = 0; k <= 61; k++) {\\n                if (((1l << k) & tmp) != 0) {\\n                    list.add(1l << k);\\n                }\\n            }\\n            long sum = 0l;\\n            for (long num : list) sum += num;\\n            if (list.size() <= x && sum >= x) return x;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nPython:\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for x in range(1, 101):\\n            tmp = num1 - x * num2\\n            if tmp < 0: \\n                continue\\n            arr = []\\n            for i in range(62):\\n                if (1 << i) & tmp != 0:\\n                    arr.append(1 << i)\\n            if len(arr) <= x and sum(arr) >= x:\\n                return x\\n        return -1\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nnum1 - (2^i + num2) - (2^j + num2) - (2^k + num2) - ... = 0\\nnum1 - 2^i - num2 - 2^j - num2 - 2^k - num2 - ... = 0\\nnum1 - x * num2 = 2^i + 2^j + 2^k + ...\\n```\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for (int x = 0; x <= 60; x++) {\\n            long tmp = (long)(num1 - (long)x * num2);\\n            if (tmp < 0) continue;\\n            vector<long> vec;\\n            for (int k = 0; k <= 61; k++) {\\n                if (((1l << k) & tmp) != 0) {\\n                    vec.push_back(1l << k);\\n                }\\n            }\\n            long sum = 0l;\\n            for (long num : vec) sum += num;\\n            if (vec.size() <= x && sum >= x) return x;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        for (int x = 0; x <= 100; x++) {\\n            long tmp = (long)(num1 - (long)x * num2);\\n            if (tmp < 0) continue;\\n            List<Long> list = new ArrayList<>();\\n            for (int k = 0; k <= 61; k++) {\\n                if (((1l << k) & tmp) != 0) {\\n                    list.add(1l << k);\\n                }\\n            }\\n            long sum = 0l;\\n            for (long num : list) sum += num;\\n            if (list.size() <= x && sum >= x) return x;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for x in range(1, 101):\\n            tmp = num1 - x * num2\\n            if tmp < 0: \\n                continue\\n            arr = []\\n            for i in range(62):\\n                if (1 << i) & tmp != 0:\\n                    arr.append(1 << i)\\n            if len(arr) <= x and sum(arr) >= x:\\n                return x\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694557,
                "title": "2-approaches-clear-explanation-with-pictures-counting-bits-beats-100-c",
                "content": "# Approach 1 (Gives TLE)\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet\\'s say the minimum operations are k.\\nThe power of 2 that is subtracted from num1 in the operations are n1, n2, n3 ..... nk.\\n\\nThus, the problem becomes as follows :\\n![TLE-Explain.jpg](https://assets.leetcode.com/users/images/75426a0d-ee2c-4206-88db-126861a8cc9d_1687986847.891799.jpeg)\\n\\nThe question actually boils down to :\\nCan a number be represented as a sum of exactly k numbers which all are a power of 2?\\n\\n![Recursion-Explain.jpg](https://assets.leetcode.com/users/images/ca96d345-98b8-41ec-b39e-cff38af7a989_1687987854.6343074.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O((num1/num2)*num1)\\n>> (num1/num2) for the main function while(num1-k*num2>0) since here k can take max num1/num2 values. \\nThen for every loop, we were checking check_count function which is recursively calling with (num1) complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) + Stack Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check_count(long long int num, int count){\\n        if(num==0 && count==0){\\n            return true;\\n        }\\n        if(num==0 || count==0){\\n            return false;\\n        }\\n\\n        long long int power = 1;\\n        while(power<=num){\\n            if(check_count(num-power,count-1)){\\n                return true;\\n            }\\n            power=power*2;\\n        }\\n        return false;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<num2){\\n            return -1;\\n        }\\n\\n        int k = 0;\\n        while(num1-k*num2>0){\\n            long long int val = num1-k*num2;\\n            \\n            if(check_count(val,k)){\\n                return k;\\n            }\\n            k++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n\\n# Approach 2 (Accepted + Beats 100%)\\n<!-- Describe your approach to solving the problem. -->\\nHere also the problem boils down to the same thing : Can we represent a number as sum of exactly k numbers which are a power of 2?\\n\\nNow here are the points to note:\\n1. The minimum value of number of powers of two required to make a digit is equal to the number of set bits in that number.\\n2. The maximum value of number powers of two required to make a digit is equal to that number itself.\\n\\n![MaxMin.jpg](https://assets.leetcode.com/users/images/341a32a1-fa58-4b2e-9f42-a636840f6920_1687989179.7718656.jpeg)\\n\\n3. A number can be represented as a sum of k powers of 2, where k lies between the above minimum and maximum (both inclusive). Here\\'s an example how : \\n\\n![Explain2.jpg](https://assets.leetcode.com/users/images/815fa52f-86ab-4d8b-81e3-c0460fad690d_1687989817.1418333.jpeg)\\n\\n\\nThus, for a number, it can be represented as a sum of k powers of 2, if k lies between number of set bits in that number and that number itself (both inclusive).\\n\\n# Complexity\\n- Time complexity: O(num1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count_bits(long long int num){\\n        int count = 0;\\n        while(num){\\n            if(num&1){\\n                count++;\\n            }\\n            num=num>>1;\\n        }\\n        return count;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        num1*=1LL;\\n        num2*=1LL;\\n        if(num1<num2){\\n            return -1;\\n        }\\n\\n        long long int k = 0;\\n        while(num1-k*num2>0){\\n            long long int diff = num1-k*num2;\\n            int bits_count = count_bits(diff);\\n\\n            if(k<=diff && k>=bits_count){\\n                return k;\\n            }\\n            k++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n\\n**Please UPVOTE if you like the solution! :)**",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Recursion",
                    "Brainteaser",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check_count(long long int num, int count){\\n        if(num==0 && count==0){\\n            return true;\\n        }\\n        if(num==0 || count==0){\\n            return false;\\n        }\\n\\n        long long int power = 1;\\n        while(power<=num){\\n            if(check_count(num-power,count-1)){\\n                return true;\\n            }\\n            power=power*2;\\n        }\\n        return false;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<num2){\\n            return -1;\\n        }\\n\\n        int k = 0;\\n        while(num1-k*num2>0){\\n            long long int val = num1-k*num2;\\n            \\n            if(check_count(val,k)){\\n                return k;\\n            }\\n            k++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int count_bits(long long int num){\\n        int count = 0;\\n        while(num){\\n            if(num&1){\\n                count++;\\n            }\\n            num=num>>1;\\n        }\\n        return count;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        num1*=1LL;\\n        num2*=1LL;\\n        if(num1<num2){\\n            return -1;\\n        }\\n\\n        long long int k = 0;\\n        while(num1-k*num2>0){\\n            long long int diff = num1-k*num2;\\n            int bits_count = count_bits(diff);\\n\\n            if(k<=diff && k>=bits_count){\\n                return k;\\n            }\\n            k++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688652,
                "title": "easy-to-understand-0ms-runtime-100-beat-shortest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf resultant a<b return -1. Because just subtractin b a will become negative. So we cannnot make a zero.\\nCorrespoding to every operation with subtracting 2^i you can remove 1 bit from resultent (a-b). So count the set bit after every operation let ct, and possibility to remove bits will be equal to no. of operations. Run operations as soon as no.of set bits becomes equal or smaller to no.of operations return ans as no.of opertions.\\nOne edge case must be considered, in every operation you have to remove minimum 1 from resultant (a-b). So resultant (a-b) must be greater or equal to no.of operations.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int a, int b) {\\n        int ct=0;\\n        long long t=a;\\n        while(t>b){\\n            t-=b;\\n            ct++;\\n            int k=__builtin_popcountll(t);\\n            if(t>=ct&&k<=ct){\\n                return ct;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int a, int b) {\\n        int ct=0;\\n        long long t=a;\\n        while(t>b){\\n            t-=b;\\n            ct++;\\n            int k=__builtin_popcountll(t);\\n            if(t>=ct&&k<=ct){\\n                return ct;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685398,
                "title": "hard-problem-simplified-very-easy-to-understand-fully-explained-c",
                "content": "# Intuition\\nHere in this Question it is given that we have to find the minimum number of operation to make $$num1$$ equals to $$0$$ and we are allowed to add $$2^i + num2$$.\\nLets Try to Simplify the equation Little bit...\\nOur aim is to make\\n$$num1 - (k*num2 + (2^a + 2^b + ... + 2^j) = 0 \\\\space [sum \\\\space of \\\\space k \\\\space term \\\\space of \\\\space power \\\\space of \\\\space 2]$$ such that $$k$$ is minimum right ??\\nso we can simplify the equation little bit more\\n$$num1 - k*num2 = (2^a + 2^b + ... + 2^j) \\\\space [sum \\\\space of \\\\space k \\\\space term \\\\space of \\\\space power \\\\space of \\\\space 2]$$ right ??\\nso after seeing that above equation we can clearly see that we have to choose k such that above equation satisfy...\\nso iterate over all possible $$k$$ $$[0-60]$$ and check that for which $$k$$ value we can satisfy the above equation.\\n\\nso let show me one example to you\\n$$num1 = 3$$\\n$$num2 = -2$$\\nlets form the equation\\n$$num1 - k*num2 = (2^a+2^b+...+2^j) \\\\space [sum \\\\space of \\\\space k \\\\space term \\\\space of \\\\space power \\\\space of \\\\space 2]$$\\n\\nwe have fixed the lvalue of the equation coz we have $$num1$$ , $$num2$$ and also $$k$$ (we are iterating over $$k$$) and calculate the value of lhs ...lets sat it is $$X$$. now you only need to check can you represent this value $$X$$ using sum of $$k$$ terms of power of $$2$$. if it is then that will be your answer.\\n\\nlemee illustrate above example\\nfor $$k = 0$$ : lhs = $$(3-O*(-2)) = 3$$ : we can\\'t represent $$3$$ as sum $$0$$ terms of power of $$2$$...so continue loop\\nfor $$k = 1$$ : lhs = $$(3 - 1*(-2)) = 5$$ : there is no way to represent $$5$$ as sum of $$1$$ term of power of $$2$$..so continue loop\\nfor $$k = 2$$ : lhs = $$(3 - 2*(-2)) = 7$$ : there is no way to represent $$7$$ as sum of $$2$$ term of power of $$2$$..so continue loop\\nfor $$k = 3$$ : lhs = $$(3 - 3*(-2)) = 9$$ : there is a way to represent $$9$$ as sum of $$3$$ term of power of $$2..[2 ^0 + 2^2 + 2^2]$$ so answer will be $$3$$ for this case.\\n\\n\\n\\n# Approach\\n1.The function $$makeTheIntegerZero()$$ takes two integer parameters, $$num1$$ and $$num2$$.\\n\\n2.It defines a loop that iterates over values of $$i$$ from $$0$$ to $$60$$. This loop represents the exponent of the power of $$2$$.\\n\\n3.Inside the loop, it calculates required as the difference between $$num1$$ and $$i*num2$$. This represents the remaining value after subtracting the multiple of $$num2$$.\\n\\n4.The variable setbit is assigned the number of set bits (number of ones) in the binary representation of required. This is done using the __builtin_popcountll function, which is a built-in GCC/Clang function for counting set bits in a $$64$$-bit integer (ll is defined as long long).\\n\\n5.The code then checks if the number of set bits (setbit) is less than or equal to $$i$$ (the exponent of the power of $$2$$) and also if $$i$$ is less than or equal to required.\\n \\n6.This condition ensures that the number of set bits does not exceed the available powers of $$2$$ and that the operation is possible.\\n\\n7.If the condition is satisfied, the code returns the current value of $$i$$.\\n\\n8.If no valid $$i$$ value is found within the loop, the code returns $$-1$$, indicating that it is not possible to make the integer zero using the given operation.\\n\\n# Complexity\\n- Time complexity:\\n$$O(60*64)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        //num1 = k*num2 + (2^i1 + 2^i2 + .... + 2^1k)\\n        //num1 - k*num2 = (2^i1 + 2^i2 + .... + 2^1k)\\n        for(ll i = 0 ; i <= 60 ; i++){\\n            ll required = num1 - i*num2;\\n            ll setbit = __builtin_popcountll(required);\\n            if(setbit <= i && i <= required) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**\"Hey if you liked the solution Please Upvote me\"**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        //num1 = k*num2 + (2^i1 + 2^i2 + .... + 2^1k)\\n        //num1 - k*num2 = (2^i1 + 2^i2 + .... + 2^1k)\\n        for(ll i = 0 ; i <= 60 ; i++){\\n            ll required = num1 - i*num2;\\n            ll setbit = __builtin_popcountll(required);\\n            if(setbit <= i && i <= required) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683333,
                "title": "is-this-really-medium-question",
                "content": "# LC should automate evaluating problem difficulty level.\\n\\n# Reason: \\n- It demotivates candidates after spending few hours with wrong difficulty level.\\n- I feel difficulty level diffs person to person. so some data should be used to evaluate it with current candidates ability.\\n- Also it may vary with time, some problems marked hard now may be easy for candidates as everyone\\'s level got improved. 5 years old medium may be easy now as everyone knows already.\\n- Currently many hard LC problems are marked with wrong diff level\\nEx. Hard -> Medium, East -> Medium\\n\\n# Suggestions (Data driven)\\n- average % time spent to solve problem. \\nEx. 90% taken more than 1 hour -> Hard\\n- average success attempt rate\\nEx. 20% success rate must be hard\\n- No of people solved it in contest\\nEx. If a medium problem is solved by less than 1000 persons on contest it must be hard \\n- No of dislikes > likes. Something wrong with it. must check.\\n- When someone dislike, have a reason for dislike Ex. problem is hard (wrong diff level)\\n\\nThere could be many such data points which can tell accurately upto some level that problem is easy, medium or hard.\\n\\n\\nNote: I many times got demotivated with such problems and wasted my few days to pickup in good wives again :)",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "# LC should automate evaluating problem difficulty level.\\n\\n# Reason: \\n- It demotivates candidates after spending few hours with wrong difficulty level.\\n- I feel difficulty level diffs person to person. so some data should be used to evaluate it with current candidates ability.\\n- Also it may vary with time, some problems marked hard now may be easy for candidates as everyone\\'s level got improved. 5 years old medium may be easy now as everyone knows already.\\n- Currently many hard LC problems are marked with wrong diff level\\nEx. Hard -> Medium, East -> Medium\\n\\n# Suggestions (Data driven)\\n- average % time spent to solve problem. \\nEx. 90% taken more than 1 hour -> Hard\\n- average success attempt rate\\nEx. 20% success rate must be hard\\n- No of people solved it in contest\\nEx. If a medium problem is solved by less than 1000 persons on contest it must be hard \\n- No of dislikes > likes. Something wrong with it. must check.\\n- When someone dislike, have a reason for dislike Ex. problem is hard (wrong diff level)\\n\\nThere could be many such data points which can tell accurately upto some level that problem is easy, medium or hard.\\n\\n\\nNote: I many times got demotivated with such problems and wasted my few days to pickup in good wives again :)",
                "codeTag": "Unknown"
            },
            {
                "id": 3679250,
                "title": "c-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        long long x = num1;\\n        for(int i=1;i<=59;i++){\\n            x -= num2;\\n            if(x < 0) return -1;\\n            int cnt = 0,c = 0;\\n            for(int j=0;j<59;j++){\\n                if(x>>j&1){\\n                    cnt += j + 1;\\n                    ++c;\\n                }\\n            }\\n            if(cnt >= i && i >= c) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        long long x = num1;\\n        for(int i=1;i<=59;i++){\\n            x -= num2;\\n            if(x < 0) return -1;\\n            int cnt = 0,c = 0;\\n            for(int j=0;j<59;j++){\\n                if(x>>j&1){\\n                    cnt += j + 1;\\n                    ++c;\\n                }\\n            }\\n            if(cnt >= i && i >= c) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679244,
                "title": "python3-simple-code-bit",
                "content": "# Approach\\nAssume we can make num1 equals 0, then there exist some n such that \\n$$num1 = (2^{i1} + ...+2^{in}) + n * num2$$, where the powers $$i1,...,in$$ are in [0, 60].\\nWe denote $$diff = num1 - n * num2$$, which needs to satisfy two conditions:\\n### Condition 1:\\nThe diff must be able to be constructed by n or less 2\\'s powers. We can check it by looking at the number of 1\\'s in the binary of diff.\\ne.g. diff = 5, which has binary 101 => we need at least two 2\\'s powers to construct 5.\\nQ: Why it\\'s AT LEAST?\\nA: We can always add two lower powers together to get a higher power.\\ne.g. 5 = 2^0 + 2^2 = 2^0 + (2^1 + 2^1)\\n\\n### Condition 2:\\nHowever, we may encounter the problem that the power is too small such that we can not decompose it further more.\\ne.g. if we have diff = 3, we can decompose it into three 2\\'s powers at most (i.e. three 2^0). So we need to have our condition for upper bound of n, by simply checking if diff >= n, the case when we only use 2^0 to compose the diff.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        n = 0\\n        while True:\\n            diff = num1 - n * num2\\n            if diff <= 0:\\n                break\\n            if diff.bit_count() <= n and diff >= n:\\n                return n\\n            n += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        n = 0\\n        while True:\\n            diff = num1 - n * num2\\n            if diff <= 0:\\n                break\\n            if diff.bit_count() <= n and diff >= n:\\n                return n\\n            n += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679167,
                "title": "intuition-building-simple-bitcount-method-check-if-a-number-can-be-expressed-as-sum-of-x-powers-of-2",
                "content": "**intuition: Suppose we are making the number zero after x number of operations. means we are subtracting nums2 x times from nums1. so the remaining number i.e nums1-x*nums2 must be expressible as sum of x powers of two.**\\n\\nfor eg:- nums1=20 and nums2 =7;\\n\\nfirst we check 20-(1*7)=14 . Is 14 expressible as sum of powers of 2 having only one number in the series? No.\\n\\n20-(2*7)=6 . as 6 can be expressed as 2^2+2^1; so we got 2 as the ans;\\n\\nfor positive numbers we can check until nums1- cnt*(nums2) is >0 and for negative numbers we can simply do 60 operations to cross check;\\n\\nupvote if you like it\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int popcount(long long n) {\\n        std::bitset<64> bits(n);\\n         return bits.count();\\n    }\\n    bool dos(long long n, int x) {\\n        return x<=n && x>=popcount(n);\\n    }\\n    int makeTheIntegerZero(int num1, int num2) {\\n       \\n        if(num2==0){\\n            for(int i=1;i<32;i++){\\n                if(dos(num1,i)){\\n                    return i;\\n                }\\n            }\\n        }else if(num2>0){\\n            \\n            int cnt=1,idx=1;\\n            while(true){\\n                if(num1-cnt*num2<0){\\n                    return -1;\\n                }else{\\n                    if(dos((long long)(num1-cnt*num2),idx)){\\n                        return idx;\\n                    }\\n                    cnt++;\\n                    idx++;\\n                }\\n            }\\n        }else{\\n            long long cnt=1;\\n            int idx=1;\\n            for(int i=0;i<=60;i++){\\n                \\n                long long par=cnt*num2;\\n                \\n                if(dos((long long)(num1-par),idx)){\\n                    return idx;\\n                }else{\\n                    cnt++;\\n                    idx++;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int popcount(long long n) {\\n        std::bitset<64> bits(n);\\n         return bits.count();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3682039,
                "title": "best-easy-c-code",
                "content": "# Complexity\\n- Time complexity:\\nO(32)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1 <= num2)\\n            return -1;  \\n        for(int k=1;k<=32;k++){\\n            long diff = num1 - ((long)num2 * k);\\n            int min_cnt = __builtin_popcountl(diff); \\n            if(k >= min_cnt && k <= diff)\\n                return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1 <= num2)\\n            return -1;  \\n        for(int k=1;k<=32;k++){\\n            long diff = num1 - ((long)num2 * k);\\n            int min_cnt = __builtin_popcountl(diff); \\n            if(k >= min_cnt && k <= diff)\\n                return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680839,
                "title": "easy-to-understand-c-solution-using-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count(long long n){\\n        int cnt = 0;\\n        while(n > 0){\\n            cnt += (n & 1);\\n            n >>= 1;\\n        }\\n        return cnt;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if( num1 < num2 ) return -1;\\n\\n        for(int i=0; i<100; i++){\\n            long long diff = num1 - (long long)i * num2;\\n            int setBits = count(diff);\\n            if(i >= setBits && i <= diff) return i;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(long long n){\\n        int cnt = 0;\\n        while(n > 0){\\n            cnt += (n & 1);\\n            n >>= 1;\\n        }\\n        return cnt;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if( num1 < num2 ) return -1;\\n\\n        for(int i=0; i<100; i++){\\n            long long diff = num1 - (long long)i * num2;\\n            int setBits = count(diff);\\n            if(i >= setBits && i <= diff) return i;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788402,
                "title": "beginners-can-understand-this-deduction-to-sum-of-power-of-two",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe are given num1 and num2 \\n\\n((num1 - (2^x1 + num2)) - (2^x2 + num2)) - ...  =0\\nnum1 - k*num2 -k(2^x1 + 2^x2 + ..) =0\\ndiff = num1 - k*num2 = k(2^x1 + 2^x2 + ..)\\n\\n\\nfor k = 1 \\nthere should be one power of two \\n\\nlet say diff is 99 then  2^0 + 2^0 + ... 99times = 99\\nk<=diff\\nno. of power of two <= k\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count_bits(long long int num){\\n        int count = 0;\\n        while(num){\\n            if(num&1){\\n                count++;\\n            }\\n            num=num>>1;\\n        }\\n        return count;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n       \\n       if(num1<=num2)return -1;\\n       \\n       long long int k=0;\\n       while(num1-k*num2>0)\\n       {\\n           long long int diff = num1 - k*num2 ;\\n           long long int bitCount = count_bits(diff);\\n           \\n           if(k<=diff && k>=bitCount)\\n            return k;\\n\\n            k++;\\n       }\\n\\n       return -1;\\n\\n\\n\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count_bits(long long int num){\\n        int count = 0;\\n        while(num){\\n            if(num&1){\\n                count++;\\n            }\\n            num=num>>1;\\n        }\\n        return count;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n       \\n       if(num1<=num2)return -1;\\n       \\n       long long int k=0;\\n       while(num1-k*num2>0)\\n       {\\n           long long int diff = num1 - k*num2 ;\\n           long long int bitCount = count_bits(diff);\\n           \\n           if(k<=diff && k>=bitCount)\\n            return k;\\n\\n            k++;\\n       }\\n\\n       return -1;\\n\\n\\n\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691329,
                "title": "python-runtime-o-1-memory-o-1",
                "content": "Solution from here: \\nhttps://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679094/linear-search-on-answer-ft-bit-count/\\nNote - the worst case is where every `i` is 0, making the composition 1+1+1+1....= k = target. The best case is where each `i` appears only once, and there is no need to carry the digit over. \\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        \\n        for k in range(61):\\n            target = num1 - k*num2\\n            if 0<=target and target.bit_count() <= k <= target:\\n                return k\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        \\n        for k in range(61):\\n            target = num1 - k*num2\\n            if 0<=target and target.bit_count() <= k <= target:\\n                return k\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688284,
                "title": "general-solution-no-need-of-60-best-for-beginner-faang-c",
                "content": "# Intuition\\nStart from k = 1,\\nto check if num = num1 - num2 * k can be the sum of k pow sof 2.\\nThe maximum operations is num, num = (2 ^ 0) * num.\\nThe minimum operations is num bits count.\\nIf num.bit_count() <= k <= num,\\nthen num can be the sum of k pows of 2.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:Linear\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBits(long n){\\n        if(n==0)\\n          return 0;\\n        int cnt=0;\\n        while(n>0)\\n        {\\n            cnt++;\\n            n=(n&(n-1));\\n        }\\n        return cnt;\\n    }\\n    int find(long num1,long num2,int cnt)\\n    {\\n        if(num1<=num2)\\n            return -1;\\n        num1-=num2;\\n        if(findBits(num1)<=cnt and num1>=cnt)\\n        //we can use maximum num1 time cnt when always choose 2^0 that means 1,and minimum number of cnt is the total count of the bits in the number thats why findbits(num1)<=cnt if these condition are true return ans which is cnt\\n            return cnt;\\n        else \\n        return find(num1,num2,cnt+1);\\n        //increase the value of cnt\\n    }\\n    int makeTheIntegerZero(int num1, int num2) \\n    {\\n        //Thanks Vikas for such a clean code\\n        //Thanks Lee for such a great explanataion\\n        return find(num1,num2,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBits(long n){\\n        if(n==0)\\n          return 0;\\n        int cnt=0;\\n        while(n>0)\\n        {\\n            cnt++;\\n            n=(n&(n-1));\\n        }\\n        return cnt;\\n    }\\n    int find(long num1,long num2,int cnt)\\n    {\\n        if(num1<=num2)\\n            return -1;\\n        num1-=num2;\\n        if(findBits(num1)<=cnt and num1>=cnt)\\n        //we can use maximum num1 time cnt when always choose 2^0 that means 1,and minimum number of cnt is the total count of the bits in the number thats why findbits(num1)<=cnt if these condition are true return ans which is cnt\\n            return cnt;\\n        else \\n        return find(num1,num2,cnt+1);\\n        //increase the value of cnt\\n    }\\n    int makeTheIntegerZero(int num1, int num2) \\n    {\\n        //Thanks Vikas for such a clean code\\n        //Thanks Lee for such a great explanataion\\n        return find(num1,num2,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682006,
                "title": "best-easy-solution-pure-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(num2))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num2 >= num1)\\n        {\\n            return -1;\\n        }\\n        long long int y = 0;\\n        for(int i = 1 ; i <= 40 ; i++)\\n        {\\n            y+=num2;\\n            long long int x = (long long int)((long long int)(num1) \\n            - (long long int)(y));\\n            if(x <= 0)\\n            {\\n                return -1;\\n            }\\n            if(x == 1 && i > 1)\\n            {\\n                return -1;\\n            }\\n            int cnt = 0;\\n            while(x > 0)\\n            {\\n            x = x - (long long int)(pow( 2 , (long long)(log2(x))));\\n            cnt++;\\n            }\\n            if(cnt <= i)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num2 >= num1)\\n        {\\n            return -1;\\n        }\\n        long long int y = 0;\\n        for(int i = 1 ; i <= 40 ; i++)\\n        {\\n            y+=num2;\\n            long long int x = (long long int)((long long int)(num1) \\n            - (long long int)(y));\\n            if(x <= 0)\\n            {\\n                return -1;\\n            }\\n            if(x == 1 && i > 1)\\n            {\\n                return -1;\\n            }\\n            int cnt = 0;\\n            while(x > 0)\\n            {\\n            x = x - (long long int)(pow( 2 , (long long)(log2(x))));\\n            cnt++;\\n            }\\n            if(cnt <= i)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679174,
                "title": "o-1-with-detailed-explanation-and-prove",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif we can achieve this in x operations, we know\\nnum1 = (2 ^ a1 + 2 ^ a2 + ... + 2 ^ ax) + x * num2, where ai is in range[0, 60]\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwe can greedily iterate x from 1, in each iteration num1 -= num2 and check if there exists a formula f => (2 ^ a1 + 2 ^ a2 + ... + 2 ^ ax) == num1\\n\\nin one iteration, there are several senarios:\\na. num1 becomes non-positive after minus of num2, we know there\\'s impossible to  acheive f, return -1\\n\\notherwise, count the number of bit 1 in num1:\\nb. if  bitOfnum1 is > x, it\\'s impossible to achieve f, since in f there are at most x 2^ai and each 2 ^ ai can at most\\ncontribute one bit 1, so at most x bit 1 in total\\nc. if bitOfnum1 is <= x, there will always be a formula f == num1, except one special case -- even if we set all ai to 0 (that is, set all 2 ^ ai to 2 ^ 0 = 1), the sum of  f is still bigger than x, e.g. sum f = 3(11 in binary form) and x is 4\\n\\n\\nwe iterate at most 63 times and there must be a answer for it otherwise return -1 (cause in each iteration we can add one bit 1 in num1, there\\'re at most 63 bit 1 in a long number)\\n\\n# Complexity\\n- Time complexity: O(63), actually it\\'s O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int n2) {\\n        long n1 = num1;\\n        for (int x = 1; x < 64; x++) {\\n            n1 -= n2;\\n            // case a num1 becomes <= 0\\n            if (n1 <= 0) return -1;\\n            \\n            // case b and c\\n            if (n1 > 0) {\\n                int cnt = cntBit(n1);\\n                // case c bitOfnum1 <= x\\n                if (cnt <= x) {\\n                    if (n1 >= x) return x;\\n                    // if set all operations to 2^0, x still > n1\\n                    else return -1;\\n                } \\n                // case b, continue iteration, try x + 1\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int cntBit(long num) {\\n        int cnt = 0;\\n        for (int i = 0; i < 64; i++) {\\n            long x = 1;\\n            x <<= i;\\n            if ((x & num) != 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int n2) {\\n        long n1 = num1;\\n        for (int x = 1; x < 64; x++) {\\n            n1 -= n2;\\n            // case a num1 becomes <= 0\\n            if (n1 <= 0) return -1;\\n            \\n            // case b and c\\n            if (n1 > 0) {\\n                int cnt = cntBit(n1);\\n                // case c bitOfnum1 <= x\\n                if (cnt <= x) {\\n                    if (n1 >= x) return x;\\n                    // if set all operations to 2^0, x still > n1\\n                    else return -1;\\n                } \\n                // case b, continue iteration, try x + 1\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int cntBit(long num) {\\n        int cnt = 0;\\n        for (int i = 0; i < 64; i++) {\\n            long x = 1;\\n            x <<= i;\\n            if ((x & num) != 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679121,
                "title": "java-c-clean-solution",
                "content": "**Java Solution**\\n```\\npublic class Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= 100; i++) {\\n            long diff = num1 - (long) num2 * i;\\n            int bbbiiiiittttsss = countBits(diff);\\n            if (bbbiiiiittttsss <= i && i <= diff) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int countBits(long num) {\\n        int counter = 0;\\n        while (num > 0) {\\n            counter += num & 1;\\n            num >>= 1;\\n        }\\n        return counter;\\n    }\\n}\\n```\\n**C++ Solution**\\n```\\nclass Solution {  \\npublic:  \\n    int makeTheIntegerZero(int num1, int num2) {  \\n        if (num1 < num2) {  \\n            return -1;  \\n        }  \\n  \\n        for (int steps = 0; steps <= 100; steps++) {  \\n            long long diff = num1 - static_cast<long long>(num2) * steps;  \\n            int bits = countBits(diff);  \\n            if (bits <= steps && steps <= diff) {  \\n                return steps;  \\n            }  \\n        }  \\n  \\n        return -1;  \\n    }  \\n      \\n    private:  \\n    int countBits(long long num) {  \\n        int count = 0;  \\n        while (num > 0) {  \\n            count += num & 1;  \\n            num >>= 1;  \\n        }  \\n        return count;  \\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\npublic class Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= 100; i++) {\\n            long diff = num1 - (long) num2 * i;\\n            int bbbiiiiittttsss = countBits(diff);\\n            if (bbbiiiiittttsss <= i && i <= diff) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int countBits(long num) {\\n        int counter = 0;\\n        while (num > 0) {\\n            counter += num & 1;\\n            num >>= 1;\\n        }\\n        return counter;\\n    }\\n}\\n```\n```\\nclass Solution {  \\npublic:  \\n    int makeTheIntegerZero(int num1, int num2) {  \\n        if (num1 < num2) {  \\n            return -1;  \\n        }  \\n  \\n        for (int steps = 0; steps <= 100; steps++) {  \\n            long long diff = num1 - static_cast<long long>(num2) * steps;  \\n            int bits = countBits(diff);  \\n            if (bits <= steps && steps <= diff) {  \\n                return steps;  \\n            }  \\n        }  \\n  \\n        return -1;  \\n    }  \\n      \\n    private:  \\n    int countBits(long long num) {  \\n        int count = 0;  \\n        while (num > 0) {  \\n            count += num & 1;  \\n            num >>= 1;  \\n        }  \\n        return count;  \\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061754,
                "title": "pretty-simple-approach-that-ignores-the-max-number-of-operations",
                "content": "# Intuition\\nWe should check if a `k` exists such that `num1 - k*num2` can be represented as a sum of `k` powers of `2`.\\n\\n# Approach\\nJust start with `k=1` and continue from there. Note that this shouldn\\'t take long, as pretty soon we\\'d either have a solution or will have figured out that none exists. A solution exists iff one of these happens:\\n* `num2 <= 0`\\n* `num2 > 0` and we find a `k` such that `num1 - k*num2 >= k` and `num1 - k*num2` has at most `k` bits set\\n\\nNote that while the conditions don\\'t seem to say much, the second one shows that we always halt when `num2 > 0`.\\n\\nIf *`num1 - k*num2` has at most `k` bits set*, we can generally represent this number as a sum of `k` powers of `2`: `9` has 2 bits set, and it can be represented as a sum of 2 powers of `2`, but also a sum of 3, 4, ... , 9 powers of 2 (for 3: `9==4+4+1`; for 6: `9==2+2+2+1+1+1` or `9==4+1+1+1+1+1`; etc). However, the condition `num1 - k*num2 >= k` is also needed: `9` cannot be represented as a sum of 10 or more powers of `2`.\\n\\nThe `60` in the description is too big to matter. In some worst-case scenario, we\\'d have \"all\" bits set to 1, so we\\'d need \"all\" steps. Since both `num1` and `num2` use 30 bits, we will find a solution before getting to `num1 + 36*num2`, which needs at most `36` bits. This is for the case `num2 <= 0`, where the current value increases from step to step. For `num2 > 0` the value decreases, so we need at most 30 steps (we could also get into negative territory sooner than that; if not, we\\'ll have the solution in at most 30 steps).\\n\\n\\n\\n# Complexity\\n- Time complexity: We could say $$O(1)$$, as there are hard limits of small integers. An optimization is used when computing the number of `1` bits in a number, but its worst case is the same as the non-optimized version.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        long crt = num1;\\n        for (int res = 1; ; res++) {\\n            crt -= num2;\\n            if (crt <= 0) {\\n                return -1;\\n            }\\n            int bitCnt = compBitCnt(crt);\\n            if (bitCnt <= res && res <= crt) {\\n                return res;\\n            }\\n        }\\n    }\\n\\n    private int compBitCnt(long x) {\\n        int res = 0;\\n        while (x != 0) {\\n            res++;\\n            x = x & (x - 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        long crt = num1;\\n        for (int res = 1; ; res++) {\\n            crt -= num2;\\n            if (crt <= 0) {\\n                return -1;\\n            }\\n            int bitCnt = compBitCnt(crt);\\n            if (bitCnt <= res && res <= crt) {\\n                return res;\\n            }\\n        }\\n    }\\n\\n    private int compBitCnt(long x) {\\n        int res = 0;\\n        while (x != 0) {\\n            res++;\\n            x = x & (x - 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858210,
                "title": "c-bits-manipulation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is of using Bits Manipulation.\\nSuppose k is the minimum number of operations to make num1 equals to zero.\\nNow we can write something like nums1 - ((2^i1 + nums2) + (2^i2 + nums2) + (2^i3 + nums2) + ... and so on upto k times).\\nI can also write it like nums1 - (2^i1 + 2^i2 + 2^i3 + .. upto ktimes) - (k*nums2).\\n\\nNow, from here we can conclude that the max value of k can be upto 60(although it won\\'t be more than 32) only becuase (2^i1 + 2^i2 + 2^i3 + ...) is nothing just the binary representation of any number and at max we can have all bits set.\\n\\nNow let the number (2^i1 + 2^i2 + 2^i3 + ...) be X. So, we can write nums1 - (X + k*nums2).\\nNow our target is to make it zero.\\n- nums1 - X - k*nums2 = 0\\n- X = nums1 - k*nums2\\n\\nNow just run a loop of i from 0 to 60 and just find nums1 - i * nums2. Now this number is X. Now we will count the number of set bits in it. \\n- If the number of set bits is more than i, then this can\\'t be our answer\\n- If the number of set bits is less than or equal to i then this can be our answer. Because above we have assumed i1, i2, i3, .. to be different but it may happen that i1 , i2, i3,.. can be same. And if that happen then the number of set bits will decrease.\\n- We have to take care of some edge cases also. The first edge case is the count of bits should not be zero because this is not possible. The second edge case is X should be greater than or equal to k because at min we can subtract 1 from nums1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /* rsingh2003 */\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for(int i = 0; i <= 60; i++)\\n        {\\n            long long ab = num1*1ll - 1ll*i*num2;\\n            if(ab<0)\\n                break;\\n            int cnt = 0;\\n            long long bc = ab;\\n            while(ab != 0)\\n            {\\n                ab = ab&(ab-1ll);\\n                cnt++;\\n            }\\n            if(bc >= i && cnt != 0 && cnt <= i)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* rsingh2003 */\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for(int i = 0; i <= 60; i++)\\n        {\\n            long long ab = num1*1ll - 1ll*i*num2;\\n            if(ab<0)\\n                break;\\n            int cnt = 0;\\n            long long bc = ab;\\n            while(ab != 0)\\n            {\\n                ab = ab&(ab-1ll);\\n                cnt++;\\n            }\\n            if(bc >= i && cnt != 0 && cnt <= i)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792251,
                "title": "o-1-easiest-and-shortest-pop-count-c-bit-manipulation-math",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for (int ans = 0; ans <= 60; ++ans) {\\n            ll z = (ll)num1 - (ll)ans*num2;\\n            if (z >= 0 && __builtin_popcountll(z) <= ans && ans <= z) \\n                return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for (int ans = 0; ans <= 60; ++ans) {\\n            ll z = (ll)num1 - (ll)ans*num2;\\n            if (z >= 0 && __builtin_popcountll(z) <= ans && ans <= z) \\n                return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779526,
                "title": "from-zero-to-hero-javascript-short-solution",
                "content": "```\\n/**\\n * @param {number} num1\\n * @param {number} num2\\n * @return {number}\\n */\\nvar makeTheIntegerZero = function(num1, num2) {\\n    bitCount = (n) => n.toString(2).replace(/0/g,\"\").length\\n\\n    for (let i = 0; i <= 60; i++) {\\n        k = num1 - i * num2\\n        if (bitCount(k) <= i && i <= k) return i\\n    }\\n    \\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num1\\n * @param {number} num2\\n * @return {number}\\n */\\nvar makeTheIntegerZero = function(num1, num2) {\\n    bitCount = (n) => n.toString(2).replace(/0/g,\"\").length\\n\\n    for (let i = 0; i <= 60; i++) {\\n        k = num1 - i * num2\\n        if (bitCount(k) <= i && i <= k) return i\\n    }\\n    \\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743811,
                "title": "definitely-a-good-question-implementation-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<=num2)\\n            return -1;\\n        if(num1==0)\\n            return 0;\\n        for(int op=0;op<=60;op++){\\n            long long diff=(long long)num1-(long long)op*num2;\\n            if(diff<0)\\n                return -1;\\n            //count the set bits in diff\\n            if(__builtin_popcountll(diff)>op)\\n                continue;\\n//             number of operations should lie between setbits of diff,diff\\n            if(diff>=op)\\n                return op;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<=num2)\\n            return -1;\\n        if(num1==0)\\n            return 0;\\n        for(int op=0;op<=60;op++){\\n            long long diff=(long long)num1-(long long)op*num2;\\n            if(diff<0)\\n                return -1;\\n            //count the set bits in diff\\n            if(__builtin_popcountll(diff)>op)\\n                continue;\\n//             number of operations should lie between setbits of diff,diff\\n            if(diff>=op)\\n                return op;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734777,
                "title": "super-short-fastest-easy-readable-c",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        \\n        for(ll x = 1;x < 65;x++){\\n            ll diff = num1 - x * num2;\\n            int set_bits = 0;\\n            for(int i = 63;i >= 0;i--){\\n                if(diff & (1LL << i)) set_bits++;\\n            }\\n            if(x >= set_bits and x <= diff) return x;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        \\n        for(ll x = 1;x < 65;x++){\\n            ll diff = num1 - x * num2;\\n            int set_bits = 0;\\n            for(int i = 63;i >= 0;i--){\\n                if(diff & (1LL << i)) set_bits++;\\n            }\\n            if(x >= set_bits and x <= diff) return x;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730809,
                "title": "bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2) {\\n            return -1;\\n        }\\n        for (int k = 1; k <= 32; k++) {\\n            long diff = num1 - 1L * num2 * k;\\n            int bits = Long.bitCount(diff);\\n            if (bits <= k && k <= diff) {\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 < num2) {\\n            return -1;\\n        }\\n        for (int k = 1; k <= 32; k++) {\\n            long diff = num1 - 1L * num2 * k;\\n            int bits = Long.bitCount(diff);\\n            if (bits <= k && k <= diff) {\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721514,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n        int help(long long x){\\n            int r=0;\\n            for(int j=0;j<64;j++){\\n                if(1LL<<j & x){\\n                    r++;\\n                }\\n            }\\n            return r;\\n        }\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1==0){\\n            return 0;\\n        }\\n        if(num1<num2){\\n            return -1;\\n        }\\n        for(long long i=1;i<36;i++){\\n            long long r=(long long)num1-i*num2;\\n            if(help(r)<=i && i<=r){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n        int help(long long x){\\n            int r=0;\\n            for(int j=0;j<64;j++){\\n                if(1LL<<j & x){\\n                    r++;\\n                }\\n            }\\n            return r;\\n        }\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1==0){\\n            return 0;\\n        }\\n        if(num1<num2){\\n            return -1;\\n        }\\n        for(long long i=1;i<36;i++){\\n            long long r=(long long)num1-i*num2;\\n            if(help(r)<=i && i<=r){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712044,
                "title": "count-set-bit-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        long p1=num1;\\n        long p2=num2;\\n        int ans=0;\\n        int numOfbit=0;\\n        while((p1-p2)>=0){\\n            // System.out.println(p1+\" \"+p2);\\n            p1-=p2;\\n            numOfbit++;\\n            int csb=countSet(p1);\\n            ans++;\\n            if(csb<=numOfbit && csb>0 && p1>=numOfbit)  return ans;\\n            \\n        }\\n        return -1;\\n    }\\n    int countSet(long m){\\n        int ans=0;\\n        while(m!=0){\\n            if((m&1)!=0) ans++;\\n            m=m>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        long p1=num1;\\n        long p2=num2;\\n        int ans=0;\\n        int numOfbit=0;\\n        while((p1-p2)>=0){\\n            // System.out.println(p1+\" \"+p2);\\n            p1-=p2;\\n            numOfbit++;\\n            int csb=countSet(p1);\\n            ans++;\\n            if(csb<=numOfbit && csb>0 && p1>=numOfbit)  return ans;\\n            \\n        }\\n        return -1;\\n    }\\n    int countSet(long m){\\n        int ans=0;\\n        while(m!=0){\\n            if((m&1)!=0) ans++;\\n            m=m>>1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711480,
                "title": "easy-and-fast-constant-tc-and-sc-o-1-simple-to-understand-with-an-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first solution that came in my mind was brute force. In this approach we will use take and notTake method. But this will lead to TLE since TC is exponantial. \\n    Since for each step, we decrease num1 by num2 only(Not considering pow(2,i) for now). Now we will see that we can solve this by bitset.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe know that if num>=i+1. We can surely find a way in which the number of operations will be count(Let\\'s name it count).\\n    Here, count will range from __builtin_popcountll(num)<=count<=num.\\nHow this?\\nLet\\'s say num = 12.\\nThe minimum operation will be 2(1100 = 4 + 8) and the maximum operaation will be 12(1100 = 1+1+1... 12 times).\\nAnd if the num<=0, there is no way to calculate num by power function.\\nSo we will break it or return -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ : Constant time since loop is constant and also the stl function runs in constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ : We are using only one variable for this.\\n.\\n.\\n.\\n\\n\\nIf you still find difficult to understand this, you can connect with me on linkedin : https://www.linkedin.com/in/randhir-kumar-6a6344202/\\nOr Email : randhirkumar1062000@gmail.com\\nor Instagram : https://www.instagram.com/randhir2331/\\nI would love to help you.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for(int i = 0;i<60;i++){\\n            long long num = num1*1LL - (num2*1LL*(i+1));//To avoid overflow\\n            \\n            if(num>=i+1 && __builtin_popcountll(num)<=(i+1)){\\n                return i+1;\\n            }\\n            if(num<=0) break;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for(int i = 0;i<60;i++){\\n            long long num = num1*1LL - (num2*1LL*(i+1));//To avoid overflow\\n            \\n            if(num>=i+1 && __builtin_popcountll(num)<=(i+1)){\\n                return i+1;\\n            }\\n            if(num<=0) break;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710246,
                "title": "cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(long long int num1,long long int num2) {\\n        int i=0;\\n        while(num1>0) {\\n            num1-=num2;\\n            i++;\\n            string x=bitset<64>(num1).to_string();\\n            int x1=count(x.begin(),x.end(),\\'1\\');\\n            if (x1<=i and i<=num1){\\n                return i;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(long long int num1,long long int num2) {\\n        int i=0;\\n        while(num1>0) {\\n            num1-=num2;\\n            i++;\\n            string x=bitset<64>(num1).to_string();\\n            int x1=count(x.begin(),x.end(),\\'1\\');\\n            if (x1<=i and i<=num1){\\n                return i;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706663,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int count = 0;\\n        long long t = num1;\\n        while(t > num2){\\n            t -= num2;\\n            count++;\\n            int k = __builtin_popcountll(t);\\n            if(t >= count && k <= count){\\n                return count;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int count = 0;\\n        long long t = num1;\\n        while(t > num2){\\n            t -= num2;\\n            count++;\\n            int k = __builtin_popcountll(t);\\n            if(t >= count && k <= count){\\n                return count;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706180,
                "title": "minimum-operations-to-make-the-integer-zero-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int a, int b) {\\n        int ct=0;\\n        long long t=a;\\n        while(t>b){\\n            t-=b;\\n            ct++;\\n            int k=__builtin_popcountll(t);\\n            if(t>=ct&&k<=ct){\\n                return ct;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int a, int b) {\\n        int ct=0;\\n        long long t=a;\\n        while(t>b){\\n            t-=b;\\n            ct++;\\n            int k=__builtin_popcountll(t);\\n            if(t>=ct&&k<=ct){\\n                return ct;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704395,
                "title": "good-problem-really-a-brainteaser",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## \\u601D\\u8DEF:\\n- \\u5FAA\\u73AF\\u4ECEnum1\\u51CF\\u53BBnum2\\uFF0C\\u5E76\\u8BB0\\u5F55\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0C\\u76F4\\u5230\\u5269\\u4E0B\\u7684\\u6570\\u7684\\u4E8C\\u8FDB\\u5236\\u4E2D\\u76841\\u7684\\u4E2A\\u6570\\u5C0F\\u4E8E\\u7B49\\u4E8E\\u5FAA\\u73AF\\u6B21\\u6570\\n- \\u5982\\u679C\\u5269\\u4E0B\\u7684\\u6570\\u5C0F\\u4E8E\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0C\\u5219\\u8BF4\\u660E\\u4E0D\\u53EF\\u80FD\\u8FBE\\u6210\\u76EE\\u6807\\uFF0C\\u8FD4\\u56DE-1\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u6B21\\u81F3\\u5C11\\u8981\\u51CF\\u53BB2^0\\u4E5F\\u5C31\\u662F1\\n- \\u5426\\u5219\\u8FD4\\u56DE\\u5FAA\\u73AF\\u6B21\\u6570\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- \\u8BE6\\u89C1\\u4EE3\\u7801\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(num1/num2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        # \\u601D\\u8DEF\\uFF1A\\u5FAA\\u73AF\\u4ECEnum1\\u51CF\\u53BBnum2\\uFF0C\\u5E76\\u8BB0\\u5F55\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0C\\u76F4\\u5230\\u5269\\u4E0B\\u7684\\u6570\\u7684\\u4E8C\\u8FDB\\u5236\\u4E2D\\u76841\\u7684\\u4E2A\\u6570\\u5C0F\\u4E8E\\u7B49\\u4E8E\\u5FAA\\u73AF\\u6B21\\u6570\\n        # \\u5982\\u679C\\u5269\\u4E0B\\u7684\\u6570\\u5C0F\\u4E8E\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0C\\u5219\\u8BF4\\u660E\\u4E0D\\u53EF\\u80FD\\u8FBE\\u6210\\u76EE\\u6807\\uFF0C\\u8FD4\\u56DE-1\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u6B21\\u81F3\\u5C11\\u8981\\u51CF\\u53BB2^0\\u4E5F\\u5C31\\u662F1\\n        # \\u5426\\u5219\\u8FD4\\u56DE\\u5FAA\\u73AF\\u6B21\\u6570\\n        if num1 == 0:\\n            return 0\\n        count_loop = 0\\n        count_ones = 0\\n        while True:\\n            count_ones = 0\\n            num1 = num1 - num2\\n            if num1 < 1:\\n                return -1\\n            count_loop += 1\\n            tmp = num1\\n            while tmp > 0:\\n                while tmp % 2 == 0 and tmp > 0:\\n                    tmp = tmp // 2\\n                count_ones += 1\\n                tmp = tmp // 2\\n            if count_ones <= count_loop:\\n                break\\n        if num1 < count_loop:\\n            return -1\\n        return count_loop\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        # \\u601D\\u8DEF\\uFF1A\\u5FAA\\u73AF\\u4ECEnum1\\u51CF\\u53BBnum2\\uFF0C\\u5E76\\u8BB0\\u5F55\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0C\\u76F4\\u5230\\u5269\\u4E0B\\u7684\\u6570\\u7684\\u4E8C\\u8FDB\\u5236\\u4E2D\\u76841\\u7684\\u4E2A\\u6570\\u5C0F\\u4E8E\\u7B49\\u4E8E\\u5FAA\\u73AF\\u6B21\\u6570\\n        # \\u5982\\u679C\\u5269\\u4E0B\\u7684\\u6570\\u5C0F\\u4E8E\\u5FAA\\u73AF\\u6B21\\u6570\\uFF0C\\u5219\\u8BF4\\u660E\\u4E0D\\u53EF\\u80FD\\u8FBE\\u6210\\u76EE\\u6807\\uFF0C\\u8FD4\\u56DE-1\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u6B21\\u81F3\\u5C11\\u8981\\u51CF\\u53BB2^0\\u4E5F\\u5C31\\u662F1\\n        # \\u5426\\u5219\\u8FD4\\u56DE\\u5FAA\\u73AF\\u6B21\\u6570\\n        if num1 == 0:\\n            return 0\\n        count_loop = 0\\n        count_ones = 0\\n        while True:\\n            count_ones = 0\\n            num1 = num1 - num2\\n            if num1 < 1:\\n                return -1\\n            count_loop += 1\\n            tmp = num1\\n            while tmp > 0:\\n                while tmp % 2 == 0 and tmp > 0:\\n                    tmp = tmp // 2\\n                count_ones += 1\\n                tmp = tmp // 2\\n            if count_ones <= count_loop:\\n                break\\n        if num1 < count_loop:\\n            return -1\\n        return count_loop\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702260,
                "title": "c-count-one",
                "content": "I could not come with solution on my own. I look at the hints and got an idea about the solution. \\n\\n```\\nclass Solution {\\n    int countNumOne(long long n){\\n        int cnt=0;\\n        while (n>0){\\n            cnt++;\\n            n = n & n-1;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int cntOne=0;\\n        long long t=num1;\\n        for(int i=1;i<61;i++){\\n            t-=num2;\\n            if (t<=0) continue;\\n            cntOne = countNumOne(t);\\n            if (cntOne<=i && i<=t) return i;\\n            //else if (cntOne<i+1 && num2<0) return i+1;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int countNumOne(long long n){\\n        int cnt=0;\\n        while (n>0){\\n            cnt++;\\n            n = n & n-1;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int cntOne=0;\\n        long long t=num1;\\n        for(int i=1;i<61;i++){\\n            t-=num2;\\n            if (t<=0) continue;\\n            cntOne = countNumOne(t);\\n            if (cntOne<=i && i<=t) return i;\\n            //else if (cntOne<i+1 && num2<0) return i+1;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698937,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        long n1 = num1;\\n        long n2 = num2;\\n        for(int i = 0; i <= 60; i++){\\n            long target = n1 - n2 * i;\\n            int no_of_bits = Long.bitCount(target);\\n            if(no_of_bits <= i && i <= target){\\n                return i;\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        long n1 = num1;\\n        long n2 = num2;\\n        for(int i = 0; i <= 60; i++){\\n            long target = n1 - n2 * i;\\n            int no_of_bits = Long.bitCount(target);\\n            if(no_of_bits <= i && i <= target){\\n                return i;\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696159,
                "title": "simple-implementation-math-easy-c-code",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int makeTheIntegerZero(int oye, int oye2) {\\n\\t\\n        int count=1;\\n        long long num1=oye,num2=oye2;\\n        while(num1>num2){\\n\\t\\t\\n            num1-=num2;\\n\\t\\t\\t\\n            long long int temp=num1;\\n            long long int temp2=count;\\n            double maxi=0;\\n            while(temp2-- && temp>0){\\n\\t\\t\\t\\n                long long int hi=floor(log2(temp));\\n                double p=pow(2,hi);\\n                maxi=max(maxi,pow(2,p));\\n\\t\\t\\t\\t\\n                if(hi>60){\\n                    return -1;\\n                }\\n\\t\\t\\t\\t\\n                temp-=pow(2,hi);\\n            }\\n\\t\\t\\t\\n            if(temp==0 ){\\n\\t\\t\\t\\n                if(temp2>=0){\\n\\t\\t\\t\\t\\n                    temp2++;\\n                    temp2++;\\n\\t\\t\\t\\t\\t\\n                    if(maxi>=pow(2,temp2)){\\n                        return count;\\n                    }\\n\\t\\t\\t\\t\\t\\n                    else{\\n                        continue;\\n                    }\\n\\t\\t\\t\\t\\t\\n                }\\n                return count;\\n            }\\n            count++;\\n            \\n        }\\n        return -1;\\n\\t\\t}\\n\\t\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int makeTheIntegerZero(int oye, int oye2) {\\n\\t\\n        int count=1;\\n        long long num1=oye,num2=oye2;\\n        while(num1>num2){\\n\\t\\t\\n            num1-=num2;\\n\\t\\t\\t\\n            long long int temp=num1;\\n            long long int temp2=count;\\n            double maxi=0;\\n            while(temp2-- && temp>0){\\n\\t\\t\\t\\n                long long int hi=floor(log2(temp));\\n                double p=pow(2,hi);\\n                maxi=max(maxi,pow(2,p));\\n\\t\\t\\t\\t\\n                if(hi>60){\\n                    return -1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3695873,
                "title": "o-1-tc-o-1-sc-simple-maths",
                "content": "# Intuition\\n***(2<sup>i<sub>1<sub></sup>+num2)+(2<sup>i<sub>2<sub></sup>+num2)+(2<sup>i<sub>3<sub></sup>+num2)+....+(2<sup>i<sub>m<sub></sup>+num2) - num1 = 0***\\n\\n***This equation can be written as:***\\n\\n***(2<sup>i<sub>1<sub></sup> + 2<sup>i<sub>2<sub></sup> + 2<sup>i<sub>3<sub></sup> + ....+ 2<sup>i<sub>m<sub></sup>) + m * num2 = num1***\\n\\n***let X = (2<sup>i<sub>1<sub></sup> + 2<sup>i<sub>2<sub></sup> + 2<sup>i<sub>3<sub></sup> + ....+ 2<sup>i<sub>m<sub></sup>)***\\n\\n***NOW..***\\n***X + m * num2 = num1***\\n***X = num1 - m * num2***\\n\\n**So X has to be +ve and greater than equal to m.\\nWhy greater than equal to m?\\nWhen *i<sub>1</sub> ,i<sub>2</sub>, i<sub>3</sub> ..... i<sub>m</sub>* all will be choosen to 0 then X will be.** \\n\\n**X = (2<sup>0</sup> + 2<sup>0</sup> + 2<sup>0</sup> + ....+ 2<sup>0</sup>)**\\n\\n****X = m****\\n\\n\\n# Approach\\n***Just traverse the value of m from 1 to 60 and check the condition discussed in intution part***\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int n1, int n2) {\\n        long long num1 = n1, num2 = n2;\\n        for (long long m=1; m<=60; m++){\\n            long long x = num1 - m * num2;\\n            if (x > 0){\\n                long long set_bits = __builtin_popcountll(x);\\n                if (set_bits<=m && x>=m){\\n                    return m;\\n                }\\n            }\\n        } \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int n1, int n2) {\\n        long long num1 = n1, num2 = n2;\\n        for (long long m=1; m<=60; m++){\\n            long long x = num1 - m * num2;\\n            if (x > 0){\\n                long long set_bits = __builtin_popcountll(x);\\n                if (set_bits<=m && x>=m){\\n                    return m;\\n                }\\n            }\\n        } \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691313,
                "title": "c-bits-maths-100-fast-solution",
                "content": "# Intuition\\nCount bits after checking number of operation (1...60) performed.\\nIf number of bits is less than current number of operation then return that operation as minimum number of required operation.\\n\\nNote: check if it possible to represent num1-i*(num2) in sum of power of 2\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(60) or Constant Time complexity\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<num2)\\n        return -1;\\n        for(int i=1; i<=60; i++)\\n        {\\n            ll temp=1ll*num1-1ll*i*num2;\\n            int b=0;\\n            if(temp<i)continue;\\n            while(temp>0)\\n            {\\n                if((temp&1))b++;\\n                temp>>=1;\\n            }\\n            if(b<=i)\\n            return i;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<num2)\\n        return -1;\\n        for(int i=1; i<=60; i++)\\n        {\\n            ll temp=1ll*num1-1ll*i*num2;\\n            int b=0;\\n            if(temp<i)continue;\\n            while(temp>0)\\n            {\\n                if((temp&1))b++;\\n                temp>>=1;\\n            }\\n            if(b<=i)\\n            return i;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690401,
                "title": "easy-explanation-of-approach-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, if```num1 <= num2```then ans is not possible any how. (i.e. return -1).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet Number of operation taken is ```i``` then we want ```num1=(i*num2)+(2^k1+2^k2+....+2^ki)``` where values of k1, k2, k3,...........,ki may be repeated.\\nNow we Only have to think is whether we can make ```num1-(i*num2)``` as sum of powers of 2 or not. if we able to make it then return`i`, else go to next `i`.\\nfor checking i is out answer of not, let count number of set bit (1\\'s) present in number `num1-(i*num2)` lets say count is `co`.\\nThis `co` represent minimum powers of two required to make the number `num1-(i*num2)` and  we have to take exactly `i` move.\\nThen if `co>i` means minimum move we can take for this number is greater than required move `i` means this `i` is not out answer.\\nand also **maximum** move we can do from the number `num1-(i*num2)` is `num1-(i*num2)` itself beacuse this number can be represented as only sum of `2^0`. now if `i` exceeds the number `num1-(i*num2)` means we required more move then maximum we have since beacause of this also `i` cannot be our ans. else return `i` as answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<=num2) return -1;\\n        for(ll i=1; i<=(1e9); i++){\\n            long long num=((ll)num1-(i*1ll*num2));\\n            if(num<=0) return -1;\\n            long long co=0;\\n            long long dup=num;\\n            while(num>0){\\n                if(num&1) co++;\\n                num/=2;\\n            }\\n            if(co>i) continue;\\n            if(dup<i) continue;\\n            else return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nIf You like the solution, Please **upvote**.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```num1 <= num2```\n```i```\n```num1=(i*num2)+(2^k1+2^k2+....+2^ki)```\n```num1-(i*num2)```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<=num2) return -1;\\n        for(ll i=1; i<=(1e9); i++){\\n            long long num=((ll)num1-(i*1ll*num2));\\n            if(num<=0) return -1;\\n            long long co=0;\\n            long long dup=num;\\n            while(num>0){\\n                if(num&1) co++;\\n                num/=2;\\n            }\\n            if(co>i) continue;\\n            if(dup<i) continue;\\n            else return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689646,
                "title": "c-easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the question it is mention somewhere about power of 2. So, if anywhere if we see something power of 2 then we need to think in the direction of bitwise solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all we need to understand that the minimum num of operation required is the number of one\\'s in the num and maximum number of operations is num and in between any number is a feasible answer. So, in maximum 60 iterations we can find whether we can make num1 equal to 0 or not. So simply run a for loop check it. If for any operations num1 + i*num2 becomes zero, then that operation is not feasible because we are subtracting a positive number from a negative num, so at any cost that number never becomes 0.\\n\\nThank you \\uD83D\\uDC4D\\uD83D\\uDC4D \\n\\n# Complexity\\nThe for loop runs 100 iterations and counting the bit takes O(60) in the worst case. Hence, the time complexity is multiple of both. There is no need of any extra space, we only need some intergers variable. So, overall space complexity of this function is constant. \\n- Time complexity:\\n$$O(100*60)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int makeTheIntegerZero(int num1, int num2){\\n        int ans = -1;\\n        for(int i=1;i < 100;i++){\\n            ll temp = num1 - 1LL*i*num2;\\n            if(temp > 0){\\n                ll num = temp;\\n                int bit = 0;\\n                while(num){\\n                    if(num%2 == 1) bit += 1;\\n                    num /= 2;\\n                }\\n                if(bit <= i and i <= temp){\\n                    ans = i;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int makeTheIntegerZero(int num1, int num2){\\n        int ans = -1;\\n        for(int i=1;i < 100;i++){\\n            ll temp = num1 - 1LL*i*num2;\\n            if(temp > 0){\\n                ll num = temp;\\n                int bit = 0;\\n                while(num){\\n                    if(num%2 == 1) bit += 1;\\n                    num /= 2;\\n                }\\n                if(bit <= i and i <= temp){\\n                    ans = i;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689644,
                "title": "c-easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the question it is mention somewhere about power of 2. So, if anywhere if we see something power of 2 then we need to think in the direction of bitwise solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all we need to understand that the minimum num of operation required is the number of one\\'s in the num and maximum number of operations is num and in between any number is a feasible answer. So, in maximum 60 iterations we can find whether we can make num1 equal to 0 or not. So simply run a for loop check it. If for any operations num1 + i*num2 becomes zero, then that operation is not feasible because we are subtracting a positive number from a negative num, so at any cost that number never becomes 0.\\n\\nThank you \\uD83D\\uDC4D\\uD83D\\uDC4D \\n\\n# Complexity\\nThe for loop runs 100 iterations and counting the bit takes O(60) in the worst case. Hence, the time complexity is multiple of both. There is no need of any extra space, we only need some intergers variable. So, overall space complexity of this function is constant. \\n- Time complexity:\\n$$O(100*60)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int makeTheIntegerZero(int num1, int num2){\\n        int ans = -1;\\n        for(int i=1;i < 100;i++){\\n            ll temp = num1 - 1LL*i*num2;\\n            // cout<<temp<<\" \";\\n            if(temp > 0){\\n                ll num = temp;\\n                int bit = 0;\\n                while(num){\\n                    if(num%2 == 1) bit += 1;\\n                    num /= 2;\\n                }\\n                // cout<<bit<<endl;\\n                if(bit <= i and i <= temp){\\n                    ans = i;\\n                    break;\\n                    // cout<<ans<<endl;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int makeTheIntegerZero(int num1, int num2){\\n        int ans = -1;\\n        for(int i=1;i < 100;i++){\\n            ll temp = num1 - 1LL*i*num2;\\n            // cout<<temp<<\" \";\\n            if(temp > 0){\\n                ll num = temp;\\n                int bit = 0;\\n                while(num){\\n                    if(num%2 == 1) bit += 1;\\n                    num /= 2;\\n                }\\n                // cout<<bit<<endl;\\n                if(bit <= i and i <= temp){\\n                    ans = i;\\n                    break;\\n                    // cout<<ans<<endl;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3686818,
                "title": "javascript-math-formula-transition-90ms-power-2-factorization",
                "content": "let cnt is total number of operations, the sum of power of 2 = x - cnt * y, the problem transformed the min/max count power of 2 factorization\\n```\\nconst makeTheIntegerZero = (x, y) => {\\n    for (let cnt = 0; cnt < 40; cnt++) {\\n        let sum = x - cnt * y;\\n        if (sum < 0) break;\\n        let f = SumOfPower2Factorization(sum), min = f.size, max = sum; // max factorization is all 1\\'s (2 ^ 0)\\n        if (min <= cnt && cnt <= max) return cnt;\\n    }\\n    return -1;\\n};\\n\\n// min factorization (smallest total cnt)\\nconst SumOfPower2Factorization = (x) => {\\n    let i = 0, bit = 2 ** i, v = [], res = new Set(), cur = x;\\n    while (bit <= x) {\\n        v.push(bit);\\n        i++;\\n        bit = 2 ** i;\\n    }\\n    while (cur != 0) {\\n        let idx = v.findIndex((element) => element > cur);\\n        if (idx === -1) {\\n            idx = v.length - 1;\\n        } else {\\n            idx--;\\n        }\\n        res.add(idx);\\n        cur -= v[idx];\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst makeTheIntegerZero = (x, y) => {\\n    for (let cnt = 0; cnt < 40; cnt++) {\\n        let sum = x - cnt * y;\\n        if (sum < 0) break;\\n        let f = SumOfPower2Factorization(sum), min = f.size, max = sum; // max factorization is all 1\\'s (2 ^ 0)\\n        if (min <= cnt && cnt <= max) return cnt;\\n    }\\n    return -1;\\n};\\n\\n// min factorization (smallest total cnt)\\nconst SumOfPower2Factorization = (x) => {\\n    let i = 0, bit = 2 ** i, v = [], res = new Set(), cur = x;\\n    while (bit <= x) {\\n        v.push(bit);\\n        i++;\\n        bit = 2 ** i;\\n    }\\n    while (cur != 0) {\\n        let idx = v.findIndex((element) => element > cur);\\n        if (idx === -1) {\\n            idx = v.length - 1;\\n        } else {\\n            idx--;\\n        }\\n        res.add(idx);\\n        cur -= v[idx];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3686659,
                "title": "c-bit-count",
                "content": "intuition is to convert the question to math equation and try n;\\n\\nnum1 - n * (num2 + 2^i) = 0\\nnum1 - n* num2 = n * 2^i\\n\\nwe need to make sure that n * 2^i could represent what\\'s left for num1 - n * num2. the lower boundary is n * 1 = n. so num1 - n* num2 >= n.\\nAlso number of 1\\'s in (num1 - n * num2) must be smaller than n since 2^i could only add one extra 1 in the binary representation.  \\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint makeTheIntegerZero(int num1, int num2) {\\n\\t\\t\\tif(num1 < num2) return -1;\\n\\n\\t\\t\\tlong long i = 1;\\n\\n\\t\\t\\twhile(true) {\\n\\t\\t\\t\\tlong long cur = num1 - i * num2;\\n\\t\\t\\t\\tif(cur < i) return -1;\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\t\\tcur = cur & (cur -1);\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt <= i) return i;\\n\\n\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint makeTheIntegerZero(int num1, int num2) {\\n\\t\\t\\tif(num1 < num2) return -1;\\n\\n\\t\\t\\tlong long i = 1;\\n\\n\\t\\t\\twhile(true) {\\n\\t\\t\\t\\tlong long cur = num1 - i * num2;\\n\\t\\t\\t\\tif(cur < i) return -1;\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\t\\tcur = cur & (cur -1);\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3685616,
                "title": "easy-c-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIDK what is the answer to the problem let\\'s suppose the answer to be X\\n**num1-(X*num2+(2^i1+2^i2)..X times)=0.**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**num1-X*nums2=Some number** \\nif this **number has X or less than X setbit i**t satisfies the condition (see the eqn in Intuition).\\nEg 2^2 +2^2+ 2^1=9 (in this case k=3 and set bit is two). {although k=2 will be the solution here but you get the point}\\n**Why Less than X** (set bits) => because i1 i2 can be same.\\n**Also X<=num1-X*nums because num1-X*num2 should be = 2^something*X **\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int c(long long n1){\\n        int ans=0;\\n        while(n1>0){\\n            ans+=n1&1;   // ans = ans+n1%2\\n            n1>>=1;      // n1=n1/2\\n        }\\n        return ans;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        \\n        if(num2>num1) return -1;\\n\\n        for(int X=1;X<61;X++){\\n            long long temp=num1-(long long)num2*X;\\n            int bits=c(temp);     // __builtpop_count can also be used\\n            if(X<=temp && bits<=X) return X;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int c(long long n1){\\n        int ans=0;\\n        while(n1>0){\\n            ans+=n1&1;   // ans = ans+n1%2\\n            n1>>=1;      // n1=n1/2\\n        }\\n        return ans;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        \\n        if(num2>num1) return -1;\\n\\n        for(int X=1;X<61;X++){\\n            long long temp=num1-(long long)num2*X;\\n            int bits=c(temp);     // __builtpop_count can also be used\\n            if(X<=temp && bits<=X) return X;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684933,
                "title": "problem-on-constraints",
                "content": "# Intuition\\nOne of the first thoughts that came to my mind was can we postpone substraction? $$num1$$`-=`$$num2 + 2^{i_1}$$ and then $$num1$$`-=`$$num2 + 2^{i_2}$$ and so on. Those powers of two can be subtracted later for the situation we imagine that we have some optimal sequence of subtraction.\\n\\n# Approach\\nWhat are the constraints on the number of substractions that make possible to choose $$i_1,\\\\ldots$$ to make the given integer zero? At least popcount of what has remained of num1: the powers of two will be the bits that are set. At max the num1 itselft: the powers of two will be $$2^0$$.\\n\\n# Complexity\\n- Time complexity: linear search of answer that exists in certain situations\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\ntypedef long long i64;\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(i64 num1, i64 num2) {\\n        for (int i{ 1 }; (num1 -= num2) > 0; ++i)\\n            if(i >= __builtin_popcountll(num1) && i <= num1)\\n                return i;\\n        return -1;\\n    }\\n};\\n// RHEXAOC\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long i64;\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(i64 num1, i64 num2) {\\n        for (int i{ 1 }; (num1 -= num2) > 0; ++i)\\n            if(i >= __builtin_popcountll(num1) && i <= num1)\\n                return i;\\n        return -1;\\n    }\\n};\\n// RHEXAOC\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684504,
                "title": "javascript-solution-count-bits",
                "content": "```\\n/**\\n * @param {number} num1\\n * @param {number} num2\\n * @return {number}\\n */\\nvar makeTheIntegerZero = function(num1, num2) {\\n    let n = num1\\n    let k = 1\\n    \\n    while(n > 0) {\\n        n -= num2\\n        \\n        if(bitCount(n) <= k && k <= n) { // form the target by different power of 2, maximum step can only be current n because 2 ^ 0 + 2 ^ 0 + ... + 2 ^ 0 === n\\n            return k\\n        }\\n        k++\\n    }\\n    \\n    return -1\\n};\\n\\nconst bitCount = n => {\\n    let cnt = 0\\n    for(let c of n.toString(2)) if(c === \\'1\\') cnt++\\n    return cnt\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num1\\n * @param {number} num2\\n * @return {number}\\n */\\nvar makeTheIntegerZero = function(num1, num2) {\\n    let n = num1\\n    let k = 1\\n    \\n    while(n > 0) {\\n        n -= num2\\n        \\n        if(bitCount(n) <= k && k <= n) { // form the target by different power of 2, maximum step can only be current n because 2 ^ 0 + 2 ^ 0 + ... + 2 ^ 0 === n\\n            return k\\n        }\\n        k++\\n    }\\n    \\n    return -1\\n};\\n\\nconst bitCount = n => {\\n    let cnt = 0\\n    for(let c of n.toString(2)) if(c === \\'1\\') cnt++\\n    return cnt\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683597,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        for (int x = 0; x <= 100; x++) {\\n            long tmp = (long)(num1 - (long)x * num2);\\n            if (tmp < 0) continue;\\n            List<Long> list = new ArrayList<>();\\n            for (int k = 0; k <= 61; k++) {\\n                if (((1l << k) & tmp) != 0) {\\n                    list.add(1l << k);\\n                }\\n            }\\n            long sum = 0l;\\n            for (long num : list) sum += num;\\n            if (list.size() <= x && sum >= x) return x;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        for (int x = 0; x <= 100; x++) {\\n            long tmp = (long)(num1 - (long)x * num2);\\n            if (tmp < 0) continue;\\n            List<Long> list = new ArrayList<>();\\n            for (int k = 0; k <= 61; k++) {\\n                if (((1l << k) & tmp) != 0) {\\n                    list.add(1l << k);\\n                }\\n            }\\n            long sum = 0l;\\n            for (long num : list) sum += num;\\n            if (list.size() <= x && sum >= x) return x;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683383,
                "title": "c-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation is in code below\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int ans = -1, cnt = 0, min_cnt;\\n        long long num = num1, v;\\n        while(num > 0) {\\n            ++cnt;\\n            // num is num1 - cnt * num2\\n            num -= num2;\\n            if(num < 0) break;\\n\\n            // check if it is possible that I can remove all \\'1\\'bit from num within cnt operations\\n            min_cnt = 0;\\n            v = num;\\n\\n            // count \\'1\\' from num. It is the minimum operation count to remove all \\'1\\' from num\\n            while(v > 0) {\\n                if(v&1) ++min_cnt;\\n                v >>= 1;\\n            }\\n            // num is the maximum operation count to remove \\'1\\' from num\\n            // ex)  7 = 111(2), I can remove it in 7 operations. \\n            //       ---> 111 - 001 , 110 - 001 , 101 - 001 , 100 - 001 , 011 - 001 , 010 - 001 , 001 - 001\\n            // So, if cnt is between num and min_cnt, I can remove num1 with cnt operations\\n            if(num >= cnt && min_cnt <= cnt) {\\n                ans = cnt;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int ans = -1, cnt = 0, min_cnt;\\n        long long num = num1, v;\\n        while(num > 0) {\\n            ++cnt;\\n            // num is num1 - cnt * num2\\n            num -= num2;\\n            if(num < 0) break;\\n\\n            // check if it is possible that I can remove all \\'1\\'bit from num within cnt operations\\n            min_cnt = 0;\\n            v = num;\\n\\n            // count \\'1\\' from num. It is the minimum operation count to remove all \\'1\\' from num\\n            while(v > 0) {\\n                if(v&1) ++min_cnt;\\n                v >>= 1;\\n            }\\n            // num is the maximum operation count to remove \\'1\\' from num\\n            // ex)  7 = 111(2), I can remove it in 7 operations. \\n            //       ---> 111 - 001 , 110 - 001 , 101 - 001 , 100 - 001 , 011 - 001 , 010 - 001 , 001 - 001\\n            // So, if cnt is between num and min_cnt, I can remove num1 with cnt operations\\n            if(num >= cnt && min_cnt <= cnt) {\\n                ans = cnt;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683379,
                "title": "swift-bit-logic-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func makeTheIntegerZero(_ y: Int, _ x: Int) -> Int\\n    {\\n        var y = y\\n        for k in 1...\\n        {\\n            y -= x\\n            if x > 0 && y < 0 { return -1 }\\n            if y >= 0 && (y.nonzeroBitCount == k || (y.nonzeroBitCount < k && y >= k)) { return k }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func makeTheIntegerZero(_ y: Int, _ x: Int) -> Int\\n    {\\n        var y = y\\n        for k in 1...\\n        {\\n            y -= x\\n            if x > 0 && y < 0 { return -1 }\\n            if y >= 0 && (y.nonzeroBitCount == k || (y.nonzeroBitCount < k && y >= k)) { return k }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682949,
                "title": "python3-easy-to-read-well-commented-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        # No moves needed to make num1 zero.\\n        if num1 == 0:\\n            return 0\\n\\n        # Find num_ops such that this equation is satisfied.\\n        # num1 = num_ops * num2 + (sum of |num_ops| powers of 2)\\n        num_ops = 0\\n        while True:\\n            num_ops += 1\\n\\n            # Check if |remaining| can be generated using\\n            # |num_ops| powers of 2.\\n            remaining = num1 - num2 * num_ops\\n            \\n            # No point in continuing the search if \\n            # num2 * num_ops > num1. We only have access to\\n            # positive powers of 2.\\n            if remaining < 0:\\n                return -1\\n            \\n            # Count the number of \\'1\\'s in the binary representation\\n            # of |remaining|. This is the minimum number of powers of\\n            # 2 needed to generate the number.\\n            def num_of_ones_binary(num):\\n                num_ones = 0\\n                while num != 0:\\n                    num_ones += (num & 1)\\n                    num = num // 2\\n                return num_ones\\n\\n            num_ones_binary = num_of_ones_binary(remaining)\\n            \\n            # num_ops must be within [num_ones_binary, remaining].\\n            # At minimum, we need |num_ones_binary| to generate the \\n            # number. At maximum, we can use |remaining| numbers,\\n            # where each power of a 2 is a 1.\\n            if num_ops >= num_ones_binary and num_ops <= remaining:\\n                return num_ops\\n\\n        return num_ops\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        # No moves needed to make num1 zero.\\n        if num1 == 0:\\n            return 0\\n\\n        # Find num_ops such that this equation is satisfied.\\n        # num1 = num_ops * num2 + (sum of |num_ops| powers of 2)\\n        num_ops = 0\\n        while True:\\n            num_ops += 1\\n\\n            # Check if |remaining| can be generated using\\n            # |num_ops| powers of 2.\\n            remaining = num1 - num2 * num_ops\\n            \\n            # No point in continuing the search if \\n            # num2 * num_ops > num1. We only have access to\\n            # positive powers of 2.\\n            if remaining < 0:\\n                return -1\\n            \\n            # Count the number of \\'1\\'s in the binary representation\\n            # of |remaining|. This is the minimum number of powers of\\n            # 2 needed to generate the number.\\n            def num_of_ones_binary(num):\\n                num_ones = 0\\n                while num != 0:\\n                    num_ones += (num & 1)\\n                    num = num // 2\\n                return num_ones\\n\\n            num_ones_binary = num_of_ones_binary(remaining)\\n            \\n            # num_ops must be within [num_ones_binary, remaining].\\n            # At minimum, we need |num_ones_binary| to generate the \\n            # number. At maximum, we can use |remaining| numbers,\\n            # where each power of a 2 is a 1.\\n            if num_ops >= num_ones_binary and num_ops <= remaining:\\n                return num_ops\\n\\n        return num_ops\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682948,
                "title": "python3-easy-to-read-well-commented-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        # No moves needed to make num1 zero.\\n        if num1 == 0:\\n            return 0\\n\\n        # Find num_ops such that this equation is satisfied.\\n        # num1 = num_ops * num2 + (sum of |num_ops| powers of 2)\\n        num_ops = 0\\n        while True:\\n            num_ops += 1\\n\\n            # Check if |remaining| can be generated using\\n            # |num_ops| powers of 2.\\n            remaining = num1 - num2 * num_ops\\n            \\n            # No point in continuing the search if \\n            # num2 * num_ops > num1. We only have access to\\n            # positive powers of 2.\\n            if remaining < 0:\\n                return -1\\n            \\n            # Count the number of \\'1\\'s in the binary representation\\n            # of |remaining|. This is the minimum number of powers of\\n            # 2 needed to generate the number.\\n            def num_of_ones_binary(num):\\n                num_ones = 0\\n                while num != 0:\\n                    num_ones += (num & 1)\\n                    num = num // 2\\n                return num_ones\\n\\n            num_ones_binary = num_of_ones_binary(remaining)\\n            \\n            # num_ops must be within [num_ones_binary, remaining].\\n            # At minimum, we need |num_ones_binary| to generate the \\n            # number. At maximum, we can use |remaining| numbers,\\n            # where each power of a 2 is a 1.\\n            if num_ops >= num_ones_binary and num_ops <= remaining:\\n                return num_ops\\n\\n        return num_ops\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        # No moves needed to make num1 zero.\\n        if num1 == 0:\\n            return 0\\n\\n        # Find num_ops such that this equation is satisfied.\\n        # num1 = num_ops * num2 + (sum of |num_ops| powers of 2)\\n        num_ops = 0\\n        while True:\\n            num_ops += 1\\n\\n            # Check if |remaining| can be generated using\\n            # |num_ops| powers of 2.\\n            remaining = num1 - num2 * num_ops\\n            \\n            # No point in continuing the search if \\n            # num2 * num_ops > num1. We only have access to\\n            # positive powers of 2.\\n            if remaining < 0:\\n                return -1\\n            \\n            # Count the number of \\'1\\'s in the binary representation\\n            # of |remaining|. This is the minimum number of powers of\\n            # 2 needed to generate the number.\\n            def num_of_ones_binary(num):\\n                num_ones = 0\\n                while num != 0:\\n                    num_ones += (num & 1)\\n                    num = num // 2\\n                return num_ones\\n\\n            num_ones_binary = num_of_ones_binary(remaining)\\n            \\n            # num_ops must be within [num_ones_binary, remaining].\\n            # At minimum, we need |num_ones_binary| to generate the \\n            # number. At maximum, we can use |remaining| numbers,\\n            # where each power of a 2 is a 1.\\n            if num_ops >= num_ones_binary and num_ops <= remaining:\\n                return num_ops\\n\\n        return num_ops\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682859,
                "title": "python3-check-if-num-can-be-turned-into-sum-of-powers-of-2",
                "content": "# Intuition\\nFor every `i`, we need to figure out if a sum of `i` times `2 ** j` is equal to the current num. We can do some fancy binary representation analysis to figure out how many bits are set in `num`.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for i in range(33):\\n            if num1 < 0: return -1\\n            if can_reach(num1, i): return i\\n            num1 -= num2\\n        return -1\\n\\ndef can_reach(num1, i):\\n    if i == 0: return num1 == 0\\n    if num1 <= 0: return False\\n    b = bin(num1)[2:]\\n    c = b.count(\\'1\\')\\n    if c > i: return False\\n    if i == 1: return c == 1\\n    for j in range(len(b)):\\n        if can_reach(num1 - (1 << j), i - 1): return True\\n    return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for i in range(33):\\n            if num1 < 0: return -1\\n            if can_reach(num1, i): return i\\n            num1 -= num2\\n        return -1\\n\\ndef can_reach(num1, i):\\n    if i == 0: return num1 == 0\\n    if num1 <= 0: return False\\n    b = bin(num1)[2:]\\n    c = b.count(\\'1\\')\\n    if c > i: return False\\n    if i == 1: return c == 1\\n    for j in range(len(b)):\\n        if can_reach(num1 - (1 << j), i - 1): return True\\n    return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682605,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        long ans = -1;\\n        for(long i = 1 ; i <= 60 ; i++){\\n            long check = num1 - (i * num2);\\n            if(check <= 0) continue;\\n            int bits = setBits(check);\\n            if(bits > i) continue;\\n            if(check < i) continue;\\n            ans = i;\\n            break;\\n        }\\n        return (int) ans;\\n    }\\n    private int setBits(long N) {\\n        int ans = 0;\\n        while(N > 0){\\n            ans++;\\n            N = N & (N-1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        long ans = -1;\\n        for(long i = 1 ; i <= 60 ; i++){\\n            long check = num1 - (i * num2);\\n            if(check <= 0) continue;\\n            int bits = setBits(check);\\n            if(bits > i) continue;\\n            if(check < i) continue;\\n            ans = i;\\n            break;\\n        }\\n        return (int) ans;\\n    }\\n    private int setBits(long N) {\\n        int ans = 0;\\n        while(N > 0){\\n            ans++;\\n            N = N & (N-1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682357,
                "title": "simplest-linear-search-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int a, int b) {\\n        for(int i=0;i<=100;i++)\\n        {\\n            long long x=(long long)a - ((long long)b * i);\\n            if(x<0) continue;\\n            long long set= __builtin_popcountll(x);\\n            if(set<=i && set!=0 && x>=i) return i; \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int a, int b) {\\n        for(int i=0;i<=100;i++)\\n        {\\n            long long x=(long long)a - ((long long)b * i);\\n            if(x<0) continue;\\n            long long set= __builtin_popcountll(x);\\n            if(set<=i && set!=0 && x>=i) return i; \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682310,
                "title": "c-easiest-solution-77-78-55-56",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf you observe, if there are total `n`steps, the additions should be such that:\\n`sum(n powers of 2 (diff or same)) = nums1-n*nums2`. \\n\\nThis is the only observation needed. Either this difference should have exactly `n`different powers of 2 or if the different powers are less than `n`, we can break a bigger power of 2 into two or more powers to reach `n`.\\n\\n# Complexity\\n- Time complexity: O(60*32)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(60)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<num2)return -1;\\n        long long a = num2;\\n        int count=1;\\n        while(count<60){\\n            long long temp = num1-a;\\n            if(temp<0)break;\\n            long long t = 0;\\n            long long maxi=0;\\n            long long c = 0;\\n            while(temp){\\n                c++;\\n                if(temp&1){\\n                    t++; \\n                    maxi+=c;\\n                }\\n                temp=temp>>1;\\n            }\\n            if((t==count)||((t<count)&&(maxi>=count)))return count;\\n            a+=num2;\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<num2)return -1;\\n        long long a = num2;\\n        int count=1;\\n        while(count<60){\\n            long long temp = num1-a;\\n            if(temp<0)break;\\n            long long t = 0;\\n            long long maxi=0;\\n            long long c = 0;\\n            while(temp){\\n                c++;\\n                if(temp&1){\\n                    t++; \\n                    maxi+=c;\\n                }\\n                temp=temp>>1;\\n            }\\n            if((t==count)||((t<count)&&(maxi>=count)))return count;\\n            a+=num2;\\n            count++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681822,
                "title": "c-not-intuitive-calculation-based",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool flag = true;\\n    bool isValid(int num1,int num2,int k){\\n        long long target = 1LL*num1 - 1LL*k*num2;\\n        if(target <= 0){\\n            flag = false;\\n            return false;\\n        }\\n\\n        long long mini = 0;\\n        long long maxi = target;\\n        while(target > 0){\\n            long long tmp = log2(target);\\n            if(tmp > 60)tmp = 60;\\n            long long tmp2 = pow(2,tmp);\\n            \\n            target = target - tmp2;\\n            mini++;\\n        }\\n        \\n        if(mini <= k && k <= maxi)return true;\\n        return false;\\n    }\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num2 >= num1)return -1;\\n    \\n        int lo = 0;    \\n        int ans = -1;\\n        \\n        while(flag){\\n            if(isValid(num1,num2,lo))return lo;\\n            else lo++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flag = true;\\n    bool isValid(int num1,int num2,int k){\\n        long long target = 1LL*num1 - 1LL*k*num2;\\n        if(target <= 0){\\n            flag = false;\\n            return false;\\n        }\\n\\n        long long mini = 0;\\n        long long maxi = target;\\n        while(target > 0){\\n            long long tmp = log2(target);\\n            if(tmp > 60)tmp = 60;\\n            long long tmp2 = pow(2,tmp);\\n            \\n            target = target - tmp2;\\n            mini++;\\n        }\\n        \\n        if(mini <= k && k <= maxi)return true;\\n        return false;\\n    }\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num2 >= num1)return -1;\\n    \\n        int lo = 0;    \\n        int ans = -1;\\n        \\n        while(flag){\\n            if(isValid(num1,num2,lo))return lo;\\n            else lo++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681600,
                "title": "c-brute-force-using-bit-manipulation-with-explanation",
                "content": "## Table of Contents\\n1. [Intuition](#intuition)\\n2. [Approach](#approach)\\n3. [Examples](#examples)\\n4. [Complexity](#complexity)\\n5. [Code](#code)\\n\\n# Intuition\\nBit Manipulation seem like they could be fast, especially for larger number pairs. Due to the low number of cases (`60`), it might be possible to brute-force.\\n\\n# Approach\\n1. Start iterating from `k = 1` to `k = 60`.\\n2. Calculate the target value by subtracting `k * y` from `x`.\\n3. Check two conditions:\\n   - The count of set bits (binary 1s) in the target value is less than or equal to `k`. This is checked using the `PopCount` helper method.\\n   - `k` is less than or equal to the target.\\n4. If both conditions are satisfied, return the current value of `k` as the minimum value.\\n5. If no value of `k` satisfies the conditions, return `-1` to indicate that there is no valid solution.\\n\\n# Examples\\n\\nBelow are the test cases provided in the problem description, along with a description of how the algorithm would solve the particular case.\\n\\n```Case-1 []\\nInput: num1 = 3, num2 = -2\\n\\nk = 1\\ntarget = 3 - 1 * -2 = 5\\nPopCount(5) = 2\\n\\n2 <= 1 && 1 <= 1 // Not fulfilled, keep going\\n\\nk = 2 \\ntarget = 3 - 2 * -2 = 7\\nPopCount(7) = 3\\n\\n3 <= 2 && 2 <= 7 // Not fulfilled, keep going\\n\\nk = 3\\ntarget = 3 - 3 * -2 = 9\\nPopCount(9) = 2\\n\\n2 <= 3 && 3 <= 9 // Fulfilled, stop\\nreturn k = 3\\n\\nOutput: 3\\n```\\n\\n```Case-2 []\\nInput: num1 = 5, num2 = 7\\n\\nk = 1\\ntarget = 5 - 1 * 7 = -9\\nPopCount(-9) = 63\\n\\n63 <= 1 && 1 <= -9 // Not fulfilled, keep going\\n\\nk = 2 \\ntarget = 5 - 2 * 7 = -13\\nPopCount(-13) = 62\\n\\n62 <= 2 && 2 <= -13 // Not fulfilled, keep going\\n\\n...\\n\\nk = 60\\ntarget = 5 - 60 * 7 = -415\\nPopCount(-415) = 58\\n\\n58 <= 60 && 60 <= -415 // Not fulfilled, stop\\nreturn k = -1\\n\\nOutput: -1\\n```\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\nThe algorithm iterates through the values of `k` from `1` to `60`, which is a constant range. Therefore, the time complexity of the algorithm can be considered as $$O(1)$$. The time complexity does not depend on the input size.\\n\\n- Space complexity: $$O(1)$$\\n\\nThe space complexity of the algorithm is $$O(1)$$ because it uses a fixed amount of additional space regardless of the input size. The variables `x`, `y`, and `target` are of constant size since they store individual integer or long values. The `PopCount` method also uses a fixed amount of space for the integer count variable.\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    // Function to find the minimum value of \\'k\\' such that \\'x - k * y\\' satisfies certain conditions\\n    public int MakeTheIntegerZero(long x, long y)\\n    {\\n        // Iterate from 1 to 60 (inclusive)\\n        for (int k = 1; k < 61; k++)\\n        {\\n            // Calculate the target value by subtracting \\'k\\' times \\'y\\' from \\'x\\'\\n            long target = x - k * y;\\n\\n            // Check if the count of set bits (binary 1s) in the target is less than or equal to \\'k\\'\\n            // and if \\'k\\' is less than or equal to the target\\n            if (PopCount(target) <= k && k <= target)\\n            {\\n                // Return the minimum value of \\'k\\' satisfying the conditions\\n                return k;\\n            }\\n        }\\n\\n        // If no valid value of \\'k\\' is found, return -1\\n        return -1;\\n    }\\n\\n    // Helper function to count the number of set bits (binary 1s) in a number\\n    private int PopCount(long number)\\n    {\\n        int count = 0;\\n\\n        // Iterate until the number becomes zero\\n        while (number != 0)\\n        {\\n            // Increment the count if the least significant bit is 1\\n            count++;\\n\\n            // Remove the least significant bit by performing bitwise AND with the number minus 1\\n            number &= number - 1;\\n        }\\n\\n        // Return the count of set bits\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```Case-1 []\\nInput: num1 = 3, num2 = -2\\n\\nk = 1\\ntarget = 3 - 1 * -2 = 5\\nPopCount(5) = 2\\n\\n2 <= 1 && 1 <= 1 // Not fulfilled, keep going\\n\\nk = 2 \\ntarget = 3 - 2 * -2 = 7\\nPopCount(7) = 3\\n\\n3 <= 2 && 2 <= 7 // Not fulfilled, keep going\\n\\nk = 3\\ntarget = 3 - 3 * -2 = 9\\nPopCount(9) = 2\\n\\n2 <= 3 && 3 <= 9 // Fulfilled, stop\\nreturn k = 3\\n\\nOutput: 3\\n```\n```Case-2 []\\nInput: num1 = 5, num2 = 7\\n\\nk = 1\\ntarget = 5 - 1 * 7 = -9\\nPopCount(-9) = 63\\n\\n63 <= 1 && 1 <= -9 // Not fulfilled, keep going\\n\\nk = 2 \\ntarget = 5 - 2 * 7 = -13\\nPopCount(-13) = 62\\n\\n62 <= 2 && 2 <= -13 // Not fulfilled, keep going\\n\\n...\\n\\nk = 60\\ntarget = 5 - 60 * 7 = -415\\nPopCount(-415) = 58\\n\\n58 <= 60 && 60 <= -415 // Not fulfilled, stop\\nreturn k = -1\\n\\nOutput: -1\\n```\n```\\npublic class Solution\\n{\\n    // Function to find the minimum value of \\'k\\' such that \\'x - k * y\\' satisfies certain conditions\\n    public int MakeTheIntegerZero(long x, long y)\\n    {\\n        // Iterate from 1 to 60 (inclusive)\\n        for (int k = 1; k < 61; k++)\\n        {\\n            // Calculate the target value by subtracting \\'k\\' times \\'y\\' from \\'x\\'\\n            long target = x - k * y;\\n\\n            // Check if the count of set bits (binary 1s) in the target is less than or equal to \\'k\\'\\n            // and if \\'k\\' is less than or equal to the target\\n            if (PopCount(target) <= k && k <= target)\\n            {\\n                // Return the minimum value of \\'k\\' satisfying the conditions\\n                return k;\\n            }\\n        }\\n\\n        // If no valid value of \\'k\\' is found, return -1\\n        return -1;\\n    }\\n\\n    // Helper function to count the number of set bits (binary 1s) in a number\\n    private int PopCount(long number)\\n    {\\n        int count = 0;\\n\\n        // Iterate until the number becomes zero\\n        while (number != 0)\\n        {\\n            // Increment the count if the least significant bit is 1\\n            count++;\\n\\n            // Remove the least significant bit by performing bitwise AND with the number minus 1\\n            number &= number - 1;\\n        }\\n\\n        // Return the count of set bits\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681484,
                "title": "o-1-time-c-beginner-friendly-bit-manipulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countBits(long long num){\\n        int count=0;\\n        while(num>0){\\n            count+=num&1;\\n            num>>=1;\\n        }\\n        return count;\\n    }\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<num2){\\n            return -1;\\n        }\\n\\n        for(int steps=0;steps<=100;steps++){\\n            long long diff=num1-1LL*(num2)*steps;\\n            int bits=countBits(diff);\\n            if(bits<=steps && steps<=diff){\\n                return steps;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countBits(long long num){\\n        int count=0;\\n        while(num>0){\\n            count+=num&1;\\n            num>>=1;\\n        }\\n        return count;\\n    }\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1<num2){\\n            return -1;\\n        }\\n\\n        for(int steps=0;steps<=100;steps++){\\n            long long diff=num1-1LL*(num2)*steps;\\n            int bits=countBits(diff);\\n            if(bits<=steps && steps<=diff){\\n                return steps;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681172,
                "title": "video-explanation-include-all-the-proofs-intuitions",
                "content": "# Explanation\\n\\n[Click here for the video](https://youtu.be/7RNDbY1Qaig)\\n\\n# Code\\n```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    int CountSetBits (ll x) {\\n        int result = 0;\\n        for (int j = 0; j < 64; j ++)\\n            if ((1LL << j) & x) result ++;\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 == 0) return 0;\\n        \\n        for (ll op = 1; op < 36; op ++) {\\n            ll req = (ll)num1 - op*num2;\\n            if (CountSetBits(req) <= op && op <= req) return op;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    int CountSetBits (ll x) {\\n        int result = 0;\\n        for (int j = 0; j < 64; j ++)\\n            if ((1LL << j) & x) result ++;\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if (num1 == 0) return 0;\\n        \\n        for (ll op = 1; op < 36; op ++) {\\n            ll req = (ll)num1 - op*num2;\\n            if (CountSetBits(req) <= op && op <= req) return op;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681114,
                "title": "cpp-solution-using-bit-manipulation",
                "content": "# Intuition\\nIn Decimal number system , we can convert any number to binary number with 1 and 0 combination. \\n# Approach\\nAt any time if we are able to make x = num1 - k*num2 (k == kth operation) using binary representation total 1\\'s bit is less than the k then we can say it is our answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- 60*32 = constant\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int setBit(long long x) {\\n        int count = 0;\\n        while(x) {\\n            if(x % 2 == 1) count++;\\n            x /= 2;\\n        }\\n        return count;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int sum = num1;\\n        if(num1 - num2 < 0) return -1;\\n        int count = 0;\\n        for(int i = 0; i < 61; i++) {\\n            long long x = (long long) num1 - (long long) num2*i;\\n\\n            if(i <= x && setBit(x) <= i) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int setBit(long long x) {\\n        int count = 0;\\n        while(x) {\\n            if(x % 2 == 1) count++;\\n            x /= 2;\\n        }\\n        return count;\\n    }\\n\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int sum = num1;\\n        if(num1 - num2 < 0) return -1;\\n        int count = 0;\\n        for(int i = 0; i < 61; i++) {\\n            long long x = (long long) num1 - (long long) num2*i;\\n\\n            if(i <= x && setBit(x) <= i) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680901,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1, num2):\\n        for k in range(61):\\n            if (num1 - k*num2).bit_count() <= k <= num1 - k*num2:\\n                return k\\n\\n        return -1\\n\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1, num2):\\n        for k in range(61):\\n            if (num1 - k*num2).bit_count() <= k <= num1 - k*num2:\\n                return k\\n\\n        return -1\\n\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680760,
                "title": "o-1-easy-bits-manipulation-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the number of steps at which the condition stated below must be satisfied.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to make `num1 == 0`. Suppose `num1` will become `num1 == 0`, then previously `num1 = num2 + 2^i1 + num2 + 2^i2 + ..... + num2 + 2^ik`. Simplify this we get `num1 = k*num2 + (2^i1 + 2^i2 + .... + 2^ik)` or `num1 - k*num2 = (2^i1 + 2^i2 + .... + 2^ik)`\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for (int k = 0; k <= 60; k++) {\\n            long long target = 1LL*num1 - 1LL* k * num2;\\n            if (target >= 0 && countBits(target) <= k && k <= target) {\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n\\nprivate:\\n    int countBits(long long num) { \\n        int count = 0; \\n        while (num > 0) { \\n            count += num & 1; \\n            num >>= 1; \\n        } \\n        return count; \\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        for (int k = 0; k <= 60; k++) {\\n            long long target = 1LL*num1 - 1LL* k * num2;\\n            if (target >= 0 && countBits(target) <= k && k <= target) {\\n                return k;\\n            }\\n        }\\n        return -1;\\n    }\\n\\nprivate:\\n    int countBits(long long num) { \\n        int count = 0; \\n        while (num > 0) { \\n            count += num & 1; \\n            num >>= 1; \\n        } \\n        return count; \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680474,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  int makeTheIntegerZero(const int num1, const int num2) {\\n    int ret = 1;\\n    for (; true; ++ret) {\\n      long long num = static_cast<long long>(num1) - static_cast<long long>(ret) * num2;\\n      if (num <= 0) {\\n        return -1;\\n      }\\n      if (bit_ones(num) <= ret && ret <= num) {\\n        break;\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int bit_ones(const long long n) {\\n    int ret = 0;\\n    for (long long num = n; num > 0; num &= num - 1) {\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int makeTheIntegerZero(const int num1, const int num2) {\\n    int ret = 1;\\n    for (; true; ++ret) {\\n      long long num = static_cast<long long>(num1) - static_cast<long long>(ret) * num2;\\n      if (num <= 0) {\\n        return -1;\\n      }\\n      if (bit_ones(num) <= ret && ret <= num) {\\n        break;\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int bit_ones(const long long n) {\\n    int ret = 0;\\n    for (long long num = n; num > 0; num &= num - 1) {\\n      ++ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680427,
                "title": "this-problem-was-weekly-contest-problem",
                "content": "its not showing in my progress as solved",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3680186,
                "title": "js-solution",
                "content": "# Code\\n```\\nvar makeTheIntegerZero = function(num1, num2) {\\n    //solution from Aditya00 (Java)\\n    let countBits = (num) =>{\\n        let count = BigInt(0)\\n        while (num > 0) {\\n            count += num & BigInt(1)\\n            num >>= BigInt(1)\\n        }\\n        return count\\n    }\\n\\n    if (num1 < num2) {\\n        return -1\\n    }\\n    for (let steps = 0; steps <= 100; steps++) {\\n        let diff = BigInt(num1 - 1 * num2 * steps)\\n        let bits = countBits(diff)\\n        if (bits <= steps && steps <= diff) {\\n            return steps\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeTheIntegerZero = function(num1, num2) {\\n    //solution from Aditya00 (Java)\\n    let countBits = (num) =>{\\n        let count = BigInt(0)\\n        while (num > 0) {\\n            count += num & BigInt(1)\\n            num >>= BigInt(1)\\n        }\\n        return count\\n    }\\n\\n    if (num1 < num2) {\\n        return -1\\n    }\\n    for (let steps = 0; steps <= 100; steps++) {\\n        let diff = BigInt(num1 - 1 * num2 * steps)\\n        let bits = countBits(diff)\\n        if (bits <= steps && steps <= diff) {\\n            return steps\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680101,
                "title": "c-simple-sol",
                "content": "```\\nint get(long long x) {\\n    int res = 0;\\n    for(int i = 0; i < 60; i++) {\\n        if(x & (1ll << i)) res++;\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int a, int b) {\\n        long long x = a;\\n        if(b >= 0) {\\n            for(int i = 1; i <= 62; i++) {\\n                x -= b;\\n                if(x < 0) break;\\n                int cnt = get(x);\\n                if(x >= i && i >= cnt) return i;\\n            }\\n        } else {\\n            b = -b;\\n            for(int i = 1; i <= 62; i++) {\\n                x += b;\\n                int cnt = get(x);\\n                if(i >= cnt) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint get(long long x) {\\n    int res = 0;\\n    for(int i = 0; i < 60; i++) {\\n        if(x & (1ll << i)) res++;\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int a, int b) {\\n        long long x = a;\\n        if(b >= 0) {\\n            for(int i = 1; i <= 62; i++) {\\n                x -= b;\\n                if(x < 0) break;\\n                int cnt = get(x);\\n                if(x >= i && i >= cnt) return i;\\n            }\\n        } else {\\n            b = -b;\\n            for(int i = 1; i <= 62; i++) {\\n                x += b;\\n                int cnt = get(x);\\n                if(i >= cnt) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679996,
                "title": "intuition-approach-c-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/555c71be-5b6a-4193-92fa-260bf58cfee0_1687677538.059475.jpeg)\\n\\nSame has been done in code\\n\\n```\\nint makeTheIntegerZero(int num1, int num2) {\\n        int low = 0;\\n        int high = 31;\\n        \\n        for (int k = 0; k <= 32; k++) {\\n            long long find = num1 + 0LL - (num2 * 1LL * k);\\n            if (find < k) return -1;\\n            int ones = __builtin_popcountll(find);\\n            if (ones <= k) {\\n                return k;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint makeTheIntegerZero(int num1, int num2) {\\n        int low = 0;\\n        int high = 31;\\n        \\n        for (int k = 0; k <= 32; k++) {\\n            long long find = num1 + 0LL - (num2 * 1LL * k);\\n            if (find < k) return -1;\\n            int ones = __builtin_popcountll(find);\\n            if (ones <= k) {\\n                return k;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679736,
                "title": "o-1-c-solution-using-set-bit-count-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nForget about the num2 and just think about the minimum and maximum operations required to reduce a number to zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe minimum operations required to reduce a number to 0 will be the count of set bits in the number. And the max operations will be equal to the number itself.\\nJust check if this condition hold for every operation count between 0 and 61.\\nIf not decrease num1 by num2.\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if (num2 > num1)return -1;\\n        int operation = 0;\\n        long long number1 = (long long)num1;\\n        long long number2 = (long long)num2;\\n\\n        while(number1 >=0 && operation < 61){\\n            int count = __builtin_popcountll(number1);\\n            if(operation >= count && operation <= number1){\\n                return operation;\\n            }\\n\\n            operation++;\\n            number1 -= number2;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        if (num2 > num1)return -1;\\n        int operation = 0;\\n        long long number1 = (long long)num1;\\n        long long number2 = (long long)num2;\\n\\n        while(number1 >=0 && operation < 61){\\n            int count = __builtin_popcountll(number1);\\n            if(operation >= count && operation <= number1){\\n                return operation;\\n            }\\n\\n            operation++;\\n            number1 -= number2;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679709,
                "title": "python-o-1",
                "content": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for i in range(1, 61):\\n            num1 -= num2\\n            if num1 < 1:\\n                return -1\\n            count_ones = bin(num1)[2:].count(\\'1\\')\\n            if count_ones <= i and num1 >= i:\\n                return i\\n        \\n        return -1\\n```\\n* Maximum number of steps needed would be 60.\\n* If at any point, num1 goes negative, no solution exists since summation of 2^i >= 1.\\n* Minimum number of operations to make a number using summation of 2^i elements is the count of 1s in the binary representation.\\n* num1 >= i since minimum value of number is i(2^0 + 2^0 + .... i times)\\n\\nUpvote if this helps.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for i in range(1, 61):\\n            num1 -= num2\\n            if num1 < 1:\\n                return -1\\n            count_ones = bin(num1)[2:].count(\\'1\\')\\n            if count_ones <= i and num1 >= i:\\n                return i\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679667,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution { \\n    public int setBit(long y){\\n      int c=0; \\n      while(y!=0){\\n        if((y&1)==1) c++; \\n        y>>=1; \\n      } \\n      return c; \\n    }\\n    public int makeTheIntegerZero(int n1, int n2)\\n {\\n   int c=1; \\n   while(c<=60){\\n     long y=(long)n1-(long)c*n2; \\n  System.out.println(y+\" \"+c); \\n     if(y<=0) return -1; \\n     long setB=setBit(y); \\n//to represent y as sum of c no. of 2 powers,c must be atlest equal to no. of setbits in y and c must be at most y; (as y is represented as sum of all ones)\\n     if(c>=setB && c<=y) return c; \\n     c++; \\n   } \\n   return -1;\\n }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    public int setBit(long y){\\n      int c=0; \\n      while(y!=0){\\n        if((y&1)==1) c++; \\n        y>>=1; \\n      } \\n      return c; \\n    }\\n    public int makeTheIntegerZero(int n1, int n2)\\n {\\n   int c=1; \\n   while(c<=60){\\n     long y=(long)n1-(long)c*n2; \\n  System.out.println(y+\" \"+c); \\n     if(y<=0) return -1; \\n     long setB=setBit(y); \\n//to represent y as sum of c no. of 2 powers,c must be atlest equal to no. of setbits in y and c must be at most y; (as y is represented as sum of all ones)\\n     if(c>=setB && c<=y) return c; \\n     c++; \\n   } \\n   return -1;\\n }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3679580,
                "title": "java-solution-bitcount-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if(num1 == 0) return 0;\\n        if (num1 < num2) {\\n            return -1;\\n        }\\n\\n        for (int s = 0; s <= 100; s++) {\\n            long diff = num1 - (long) num2 * s;\\n            int bits = count(diff);\\n            if (bits <= s && s <= diff) {\\n                return s;\\n            }\\n        }\\n\\n        return -1;\\n        \\n    }\\n    \\n    int count(long num) {\\n        int count = 0;\\n        while (num > 0) {\\n            count += num & 1;\\n            num >>= 1;\\n        }\\n        return count;\\n    }\\n    \\n        \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        if(num1 == 0) return 0;\\n        if (num1 < num2) {\\n            return -1;\\n        }\\n\\n        for (int s = 0; s <= 100; s++) {\\n            long diff = num1 - (long) num2 * s;\\n            int bits = count(diff);\\n            if (bits <= s && s <= diff) {\\n                return s;\\n            }\\n        }\\n\\n        return -1;\\n        \\n    }\\n    \\n    int count(long num) {\\n        int count = 0;\\n        while (num > 0) {\\n            count += num & 1;\\n            num >>= 1;\\n        }\\n        return count;\\n    }\\n    \\n        \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679572,
                "title": "java-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. if num1 < num2, answer is -1;\\n\\n2. if answer = N, then: num1 - N * (2^i + num2) = 0 or\\nnum1 - N * num2 = N * 2^i\\n2^i is the number with one bit. N * 2^i is the number from N (if i = 0) to some number with N bits(or less, because if we take 4 and 4 it will be 1 bit)\\nSo at each iteration we will substract num2 from num1 and check these conditions\\n3. we need to use long, because num2 can be < 0 and num1 will increase\\n\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int makeTheIntegerZero(long num1, long num2) {\\n        int N = 0;\\n        while (num1 > num2) {\\n            num1 -= num2;\\n            N++;\\n            if (Long.bitCount(num1) <= N && num1 >= N) {\\n                return N;\\n            } \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int makeTheIntegerZero(long num1, long num2) {\\n        int N = 0;\\n        while (num1 > num2) {\\n            num1 -= num2;\\n            N++;\\n            if (Long.bitCount(num1) <= N && num1 >= N) {\\n                return N;\\n            } \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679437,
                "title": "python-easy-solution-with-comments-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nnum1 = num1-(2^a+2^b...2^n)-n*num2\\nwe want num1 = 0\\nreplace 0 in the above equation\\n0 = num1 - ()-n*num2\\nnum1 = ()+n*num2\\n\\nSo our goal is to find that n. Be careful with n. If 2*a+2*b... contains more than n bits, n wouln\\'t be possible. And if n*num2 is greater than num1, that is also not possible. We can go from 1 and see upto 1000000.  \\n\\n# Code\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        def possible(num):\\n            num2_fac = num2 * num\\n            rem = num1 - num2_fac\\n            if rem < num:\\n                return False\\n            nbits = 0\\n            while rem != 0:\\n                nbits += rem%2\\n                rem = rem//2\\n            return nbits <= num\\n\\n        if num2 >= num1:\\n            return -1\\n        for i in range(1, 1000000000):\\n            if possible(i):\\n                return i\\n            if num2 * i > num1 :\\n                return -1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        def possible(num):\\n            num2_fac = num2 * num\\n            rem = num1 - num2_fac\\n            if rem < num:\\n                return False\\n            nbits = 0\\n            while rem != 0:\\n                nbits += rem%2\\n                rem = rem//2\\n            return nbits <= num\\n\\n        if num2 >= num1:\\n            return -1\\n        for i in range(1, 1000000000):\\n            if possible(i):\\n                return i\\n            if num2 * i > num1 :\\n                return -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679403,
                "title": "c-o-log-num1-60-solution-comments-in-code-for-explanation",
                "content": "We can express `num1 - (k * num2)`  as a number with 60 bits. The number of 1 bits and how far they shift towards left indicates how many operations they need at a minimum\\n```\\nclass Solution {\\npublic:\\n  // Find the number of 1s in the binary representation of num and find out how far\\n  // they leftShifted from the right.\\n  pair<long, long> getNumOnesAndLeftShift(long num) {\\n    long tot = 0, leftShift = 0, totLeftShift = 0;\\n    while (num > 0) {\\n      if (num & 1) {\\n        tot++;\\n        totLeftShift += leftShift;\\n      }\\n      leftShift++;\\n      num >>= 1;\\n    }\\n    return {tot, totLeftShift};\\n  }\\n  \\n  int makeTheIntegerZero(int num1Int, int num2Int) {\\n    long num1 = num1Int, num2 = num2Int;\\n    if (num1 == 0) {\\n      return 0;\\n    }\\n    for (long k = 0; k <= 60L; ++k) {\\n      if ((num1 - (k * num2)) <= 0L) continue;\\n      auto [numOnes, leftShift] = getNumOnesAndLeftShift(num1 - (k * num2));\\n      \\n      // The number of 1s in the binary representation indicate how many numbers\\n      // we need from the 2^i for i in [0,60] at a minimum. If the number of 1s\\n      // is exactly equal to k, then k works otherwise if it is less than k\\n      // then we can calculate how far they need to left shift and if the shift\\n      // is less than the difference.\\n      if (numOnes <= k && (k - numOnes) <= leftShift) {\\n        return k;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  // Find the number of 1s in the binary representation of num and find out how far\\n  // they leftShifted from the right.\\n  pair<long, long> getNumOnesAndLeftShift(long num) {\\n    long tot = 0, leftShift = 0, totLeftShift = 0;\\n    while (num > 0) {\\n      if (num & 1) {\\n        tot++;\\n        totLeftShift += leftShift;\\n      }\\n      leftShift++;\\n      num >>= 1;\\n    }\\n    return {tot, totLeftShift};\\n  }\\n  \\n  int makeTheIntegerZero(int num1Int, int num2Int) {\\n    long num1 = num1Int, num2 = num2Int;\\n    if (num1 == 0) {\\n      return 0;\\n    }\\n    for (long k = 0; k <= 60L; ++k) {\\n      if ((num1 - (k * num2)) <= 0L) continue;\\n      auto [numOnes, leftShift] = getNumOnesAndLeftShift(num1 - (k * num2));\\n      \\n      // The number of 1s in the binary representation indicate how many numbers\\n      // we need from the 2^i for i in [0,60] at a minimum. If the number of 1s\\n      // is exactly equal to k, then k works otherwise if it is less than k\\n      // then we can calculate how far they need to left shift and if the shift\\n      // is less than the difference.\\n      if (numOnes <= k && (k - numOnes) <= leftShift) {\\n        return k;\\n      }\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679372,
                "title": "python-solution-hidden-testcase-sucks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n$$num_1 = k num_2 + \\\\Sigma_ik_i2^i$$\\n$$k = \\\\Sigma_ik_i$$\\nThen what we need to do is to test $$k$$ from 1 to 60, find the binary representation of $$num_1 - k num_2$$. It has to be positive and the number of 1 bits inside the binary representation is the shortest path.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the contest the case num1 = 85 and num2 = 42 was hidden. I forgot to check for if the largest set bit in num1 - k * num2 must be at least 1 << k - 1\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$60O(log(num1 - k*num2))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for k in range(1, 61):\\n            if num1 - k*num2 >= (1 << k) - 1 and bin(num1 - k*num2)[2:].count(\\'1\\') <= k:\\n                return k\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        for k in range(1, 61):\\n            if num1 - k*num2 >= (1 << k) - 1 and bin(num1 - k*num2)[2:].count(\\'1\\') <= k:\\n                return k\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679369,
                "title": "c-count-setbits",
                "content": "```\\n//https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/discuss/3679236/o-1-time-c-java-beginner-friendly-bit-manuclation/\\n\\npublic class Solution {\\n    public int MakeTheIntegerZero(int num1, int num2) {\\n     if(num1<num2) return -1;\\n     \\n     for(int steps=0; steps<=61;++steps){\\n       long diff=num1-1L*num2*steps; \\n      int bits=cb(diff);\\n      if(bits<=steps &&   steps<=diff)\\n        return steps;  \\n         }\\n        return -1;\\n    }\\n    \\n    //gfg\\n    static int cb(long n)\\n    {\\n        long count = 0;\\n        while (n > 0) {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n        return (int)count;\\n    }\\n    \\n}\\n.``",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MakeTheIntegerZero(int num1, int num2) {\\n     if(num1<num2) return -1;\\n     \\n     for(int steps=0; steps<=61;++steps){\\n       long diff=num1-1L*num2*steps; \\n      int bits=cb(diff);\\n      if(bits<=steps &&   steps<=diff)\\n        return steps;  \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3679363,
                "title": "beats-100-solutions-simple-bit-manipulation-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int countsetbit(long long int n){\\n        unsigned int count = 0;\\n        while (n) {\\n         count += n & 1;\\n         n >>= 1;\\n        }\\n        return count;\\n    }\\n    \\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1==num2) return -1;\\n        if(num1<num2) return -1;\\n        long double z;\\n        for(int i=1;i<=60;i++){\\n            z = num1 - i*(1LL)*num2;\\n            if(z<=0) return -1;\\n            cout<<countsetbit(z)<<\" \";\\n            if((z!=1 or i==1) and countsetbit(z) <= i) return i;\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countsetbit(long long int n){\\n        unsigned int count = 0;\\n        while (n) {\\n         count += n & 1;\\n         n >>= 1;\\n        }\\n        return count;\\n    }\\n    \\n    int makeTheIntegerZero(int num1, int num2) {\\n        if(num1==num2) return -1;\\n        if(num1<num2) return -1;\\n        long double z;\\n        for(int i=1;i<=60;i++){\\n            z = num1 - i*(1LL)*num2;\\n            if(z<=0) return -1;\\n            cout<<countsetbit(z)<<\" \";\\n            if((z!=1 or i==1) and countsetbit(z) <= i) return i;\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3679320,
                "title": "check-all-possibilities",
                "content": "```\\nclass Solution:\\n    def check(self, val, x):\\n        return \"{:b}\".format(val).count(\"1\") <= x <= val\\n    \\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        res = -1\\n        x = 1\\n        while x < 65:\\n            if num1 - x * num2 > 0 and self.check(num1 - x * num2, x):\\n                return x\\n            x += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def check(self, val, x):\\n        return \"{:b}\".format(val).count(\"1\") <= x <= val\\n    \\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\\n        res = -1\\n        x = 1\\n        while x < 65:\\n            if num1 - x * num2 > 0 and self.check(num1 - x * num2, x):\\n                return x\\n            x += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679302,
                "title": "c-iteration-on-answer-explanation",
                "content": "**Intuition**\\n\\nWe know that we have to calculate minimum number of operations so that for any i from [0,60] we substract 2^i + num2 from num1 so that it will become 0, so just think what is the answer if there is no num2, we only have to subtract 2^i then we have to count number of setBits in num1 and that is only our minimum answer because any number is sum of powers of 2, so what would affect if we have this num2?. \\n\\nSo idea is we know that there can not be much operations as maximum set bits a long integer has can be 64 so if we try all possible combinations and get our minimum desired ans, so we will run a loop from i=1 to i=100 (here i denotes number of operations done) and for each Number of operations num2 is subtracted from num1 so intially for every i we first subtract that amount and then by counting set bits of that value, if the set bits are less than or equal to i,then we get our answer from that case and we will take minimum from all that answers; \\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        \\n        if(num1<num2){\\n            return -1;\\n        }\\n        \\n        for(int i=0;i<=100;i++){\\n            long long int value = num1 - 1LL*num2*i;\\n            \\n            // Counting set Bits in that value\\n            int setbits = __builtin_popcountll(value);\\n            \\n            // Check if setbits is less than or equal to i\\n            if(setbits<=i && i<=value){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        \\n        if(num1<num2){\\n            return -1;\\n        }\\n        \\n        for(int i=0;i<=100;i++){\\n            long long int value = num1 - 1LL*num2*i;\\n            \\n            // Counting set Bits in that value\\n            int setbits = __builtin_popcountll(value);\\n            \\n            // Check if setbits is less than or equal to i\\n            if(setbits<=i && i<=value){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679279,
                "title": "c-simple-and-small-iterative-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe attempt to find a suitable value of i within the range of 1 to 40, such that num1 - (long long) i * num2 is positive, i is not greater than the result, and the count of 1s in the binary representation of the result is not greater than i. If a suitable value is found, it is returned as the result. Otherwise, -1 is returned.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInside the loop, we declare a new variable X and assigned it the value. The value is calculated by subtracting i * num2 from num1. The use of (long long) type casting ensures that the multiplication is done using a 64-bit integer to avoid potential overflow issues.\\n```\\nif (x <= 0) break;\\n```\\nThis condition checks if x is less than or equal to 0. If true, it breaks out of the loop immediately, indicating that no suitable result can be found.\\n```\\nif (i > x) continue;\\n```\\nNow we check if i is greater than x. If true, it skips the rest of the current iteration and proceeds to the next iteration of the loop. This check helps to optimize the loop by avoiding unnecessary calculations.\\n```\\nif (__builtin_popcountll(x) > i) continue;\\n```\\nHere we use the __builtin_popcountll() function to count the number of set bits (1s) in the binary representation of x. It then compares this count to the value of i. If the count is greater than i, it means that x has more 1s than the current value of i, so the loop proceeds to the next iteration.\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity:  -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int ans = 0;\\n        for (int i = 1; i <= 40; i++) {\\n            long long x = num1 - (long long) i * num2;\\n            if (x <= 0) break;\\n            if (i > x) continue;\\n            if (__builtin_popcountll(x) > i) continue;\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif (x <= 0) break;\\n```\n```\\nif (i > x) continue;\\n```\n```\\nif (__builtin_popcountll(x) > i) continue;\\n```\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int ans = 0;\\n        for (int i = 1; i <= 40; i++) {\\n            long long x = num1 - (long long) i * num2;\\n            if (x <= 0) break;\\n            if (i > x) continue;\\n            if (__builtin_popcountll(x) > i) continue;\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679243,
                "title": "c-solution-bit-manipulation",
                "content": "**Please upvote if you liked!!!**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int ans=0;\\n        long long a=(long long)(num1);\\n        long long b=(long long)(num2);\\n        while(a>=0&&ans<62){\\n            int cnt=__builtin_popcountll(a);\\n            if(ans>=cnt&&ans<=a){\\n                return ans;\\n            }\\n            ans++;\\n            a-=b;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        int ans=0;\\n        long long a=(long long)(num1);\\n        long long b=(long long)(num2);\\n        while(a>=0&&ans<62){\\n            int cnt=__builtin_popcountll(a);\\n            if(ans>=cnt&&ans<=a){\\n                return ans;\\n            }\\n            ans++;\\n            a-=b;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679240,
                "title": "c-100-beat-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        long long a = num1;\\n        for(int i=1;i<=59;i++){\\n            a -= num2;\\n            if(a < 0) return -1;\\n            int cnt = 0,c = 0;\\n            for(int j=0;j<59;j++){\\n                if(a>>j&1){\\n                    cnt += j + 1;\\n                    ++c;\\n                }\\n            }\\n            if(cnt >= i && i >= c) return i;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int makeTheIntegerZero(int num1, int num2) {\\n        long long a = num1;\\n        for(int i=1;i<=59;i++){\\n            a -= num2;\\n            if(a < 0) return -1;\\n            int cnt = 0,c = 0;\\n            for(int j=0;j<59;j++){\\n                if(a>>j&1){\\n                    cnt += j + 1;\\n                    ++c;\\n                }\\n            }\\n            if(cnt >= i && i >= c) return i;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1943426,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943369,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943942,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943332,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1945917,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943232,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943284,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943395,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 2065459,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1995993,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943426,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943369,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943942,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943332,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1945917,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943232,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943284,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1943395,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 2065459,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            },
            {
                "id": 1995993,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "Why is the answer bounded by 60???"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@bparanj](/bparanj) I think part of your explanation makes sense to me, thank you! But can you explain what you mean by \n> This could potentially require us to subtract the numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, \n\nWhats the positive and negative value?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The operation value subtracted from `num1` in each step is `(2**i) + num2`, where `i` is in the range [0, 60]. The reason for this range is that the maximum possible value of `num1` as per the problem constraints is 10^9.\\n\\nIf you consider the binary representation of `num1`, it can be seen that the binary length of `num1` can go up to 30 bits (since 2^30 is roughly equal to 10^9). \\n\\nIn the worst case, where `num2` is a large negative number (say -10^9), the value `(2**i) + num2` can become very small or even negative. This could potentially require us to subtract numbers of the form 2^i twice, once for a positive value and once for a corresponding negative value, hence the range up to 60.\\n\\nIt\\'s important to note that this range is more than sufficient for the given problem constraints, and the range could potentially be smaller depending on the actual values of `num1` and `num2`. This range essentially guarantees that we can always find an operation that can subtract from `num1` and eventually make it zero, if it\\'s possible."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "I don\\'t believe it is. There are several solutions (ex. [1](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3681390/it-s-36-not-60-iterations/), [2](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/solutions/3679519/go-backwards/)) that use a fixed bound of less than 60 and they pass all the tests.\\n\\nPersonally I haven\\'t found an explanation for choosing a fixed bound for the iterations that makes sense to me, but that might just be my own lack of understanding. Once you wrap your head around the min and max operations for each iteration it is easy to see that there is an upper bound when `num2 > 0` but the lower bound is based on the count of set bits and that number does not monotonically increase.\\n\\nWhat worked for me was just thinking about the growth rates of the `num1 - k * num2` difference. Instead of picking a fixed number of iterations, just keep going until an answer becomes impossible. This only happens when the number of operations exceeds the `num1 - k * num2` difference and that can only happen when `num2 > 0`. I used that condition for my `while` loop knowing that as long as we didn\\'t hit it then we would eventually end up at an answer: https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/submissions/980975313/"
                    },
                    {
                        "username": "4dalols",
                        "content": "[@Siddhant Chimankar](/siddhantchimankar) [@abcd](/MdoingIt) [@R Liu](/Mykono) [@Samrat](/Master_Floppa) It\\'s because we are looking for when the bitcount of the updated sum is less than the number of operations, so since num1 and num2 are bounded by 32 bits, by the time there are 60 operations it is guaranteed that the bitcount of the sum is less than 60. "
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "[@Mykono](/Mykono) No 10^9 gets bounded by 32 bits, while long long gets bounded by 60 bits, and we need long long since num2 when multiplied can exceed the integer limit."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "plz someone explain this"
                    },
                    {
                        "username": "Mykono",
                        "content": "I think it\\'s cuz of this condition 1 <= num1 <= 10^9"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "This should be the first question!"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "From the last"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@rishithenoob](/rishithenoob) lol  bhai\\n"
                    },
                    {
                        "username": "rishithenoob",
                        "content": "[@Minnikeswar18](/Minnikeswar18) sarcasm bro"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Definitely not... I was able to solve the other three at first glance but not this (even now I couldnt get the solution!!!)"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Same question as https://codeforces.com/problemset/problem/1225/C"
                    },
                    {
                        "username": "vbindal051",
                        "content": "okay :)"
                    },
                    {
                        "username": "abhinav_0310",
                        "content": "Intuitively went with the bfs but got TLE. :\\'\\'"
                    },
                    {
                        "username": "luckymaster",
                        "content": "[@VILGAX5410](/VILGAX5410) \\n```\\nclass Solution {\\n    public int makeTheIntegerZero(int num1, int num2) {\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        Set<Integer> visited = new HashSet<>();\\n        \\n        queue.offer(new int[] {0,0});\\n        visited.add(num2);\\n        int operations = 0;\\n        \\n        int [] p2 = new int[31];\\n        \\n        for(int i = 0; i < 31; i++){\\n            p2[i] = (int) Math.pow(2L, i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int [] current = queue.poll();\\n                \\n                if (current[0] == num1) {\\n                    return current[1];\\n                }\\n                for (int j = 30; j >=0; j--) {\\n                    int next = current[0] + (p2[j] + num2);\\n                    \\n                    if (num1 >= next && !visited.contains(next)) {\\n                        queue.offer(new int[]{next, current[1] + 1});\\n                        visited.add(next);\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "can u please share ur code"
                    },
                    {
                        "username": "__1",
                        "content": "I did not have the intuition for this problem at all. What topics can I search to find similar questions to it? "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Hurt by the hidden case again:\\nnum1 = 85, num2 = 42"
                    },
                    {
                        "username": "mangoman",
                        "content": "Is this not supposed to be a bfs with pruning type of question?"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Babu_frik](/Babu_frik) The exit condition of the loop in this solution is when `num1` becomes zero. This is because the goal of the problem is to make `num1` equal to zero. If `num1` is already zero, the loop doesn\\'t need to start, and the function should return the count of operations, which is zero in this case.\\n\\nHowever, in some situations, `num1` may not be able to become zero (for example, when `num2` is a positive number greater than `num1`), it might run indefinitely. To avoid this, the function should also keep track of whether `num1` has become negative or not. If `num1` becomes negative, the function should immediately return `-1` because it is impossible to make `num1` equal to zero in this case. This can serve as an additional exit condition.\\n\\nTherefore, the exit conditions for this problem are when `num1` becomes zero or when `num1` becomes negative."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "could u please share ur code\\n"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "What\\'s the exit condition? or not put condition. I was stuck there. Tried multiple variations but neither did work,."
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "Cant this be done using recursion or...bfs precisely??\\nThe answer must come..because at most its gonna take 60 steps to reach answer, "
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "[@bparanj](/bparanj) thanks man ..probably would have worked for much smaller values i guess"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, theoretically, it could be solved using recursion or Breadth-First Search (BFS) due to the limit on the number of operations. However, it\\'s important to note that these methods would typically require significant resources in terms of time and space, and could be less efficient than the given solution.\\n\\nHere\\'s how you might approach this problem with recursion or BFS:\\n\\n- **Recursion**: You would start with `num1` and in each recursive call, you would subtract `2^i + num2` from `num1` for all `i` in the range `[0, 60]`. You would then recursively call the function for the new value of `num1`. If `num1` reaches 0, you would return the number of steps taken. If `num1` becomes negative, you would stop the recursion and return -1. The minimum number of steps from all recursive calls would be the final answer. \\n\\n- **BFS**: You would use a queue to store each `num1` value and its associated step count. Starting with the initial `num1`, you would dequeue each value, subtract `2^i + num2` for all `i` in the range `[0, 60]` from `num1`, and enqueue the new value with its step count. If `num1` reaches 0, you would return the number of steps. If `num1` becomes negative, you would continue with the next value in the queue. The first time `num1` becomes 0, you have found the minimum number of steps, because BFS always finds the shortest path first.\\n\\nHowever, the primary issue with these methods is that they can generate a very large number of recursive calls or queue entries due to the range of `i`, even though the answer is bounded by 60. This could potentially cause stack overflow in recursion or consume a lot of memory in BFS, and it would also increase the time complexity. The given solution avoids these problems by directly calculating the maximum `i` that can be used in each step, making it more efficient."
                    },
                    {
                        "username": "saurabh_yadav_7",
                        "content": "CodeForces question->1600*"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Instead of proving the upper bound is 60, I\\u2019m thinking since `target = num1 - k*num2` is a 32-bit number, the max value for `target` consists of 32 1\\u2019s (in binary form), ie. max value **we should search** for `k` is 32. \\n\\nOf course k can be 33, but if k=33 is valid, then k=32 must be valid and hence we only need to go up to 32. (Ps. Using this upper bound got my code accepted, so I assume the logic somehow works?)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Convert JSON String to Object",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Find the Maximum Achievable Number",
        "question_content": "<p>You are given two integers, <code>num</code> and <code>t</code>.</p>\n\n<p>An integer <code>x</code> is called <b>achievable</b> if it can become equal to <code>num</code> after applying the following operation no more than <code>t</code> times:</p>\n\n<ul>\n\t<li>Increase or decrease <code>x</code> by <code>1</code>, and simultaneously increase or decrease <code>num</code> by <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the maximum possible achievable number</em>. It can be proven that there exists at least one achievable number.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 4, t = 1\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The maximum achievable number is x = 6; it can become equal to num after performing this operation:\n1- Decrease x by 1, and increase num by 1. Now, x = 5 and num = 5. \nIt can be proven that there is no achievable number larger than 6.\n\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 3, t = 2\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The maximum achievable number is x = 7; after performing these operations, x will equal num: \n1- Decrease x by 1, and increase num by 1. Now, x = 6 and num = 4.\n2- Decrease x by 1, and increase num by 1. Now, x = 5 and num = 5.\nIt can be proven that there is no achievable number larger than 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num, t&nbsp;&lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3739377,
                "title": "o-1-tc-proper-logical-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the given problem, we can simultaneously increase or decrease the given num and a achievable number such that after t steps, the num and a achievable number are equal.\\n\\nIn order to find the maximum achievable number, we just have to use increase operation for given num and decrease operation for maximum achievable number.\\n\\nHence after t operations, the given num will be incremented by t, maximum achievable number will be decremented by t and they both will be equal.\\n\\n=> num + t = ans -t\\n=> ans = num + 2t\\n\\nHence we can infer that in all scenarios, the maximum achievable number is num+2t as it is impossible to obtain a higher number within t steps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) We need to return num + 2*t \\n\\n# Code\\nC++ code\\n```\\nclass Solution {\\npublic:\\n    int theMaxia AchievableX(int num, int t) {\\n        return 2*t+num;\\n    }\\n};\\n```\\nC code\\n```\\nint theMaximumAchievableX(int num, int t){\\n    return 2*t+num;\\n}\\n```\\nPython code\\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        \"\"\"\\n        :type num: int\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        return num+2*t\\n```\\nJava code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n}\\n```\\nJavaScript Code\\n```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return num+2*t;\\n};\\n```\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaxia AchievableX(int num, int t) {\\n        return 2*t+num;\\n    }\\n};\\n```\n```\\nint theMaximumAchievableX(int num, int t){\\n    return 2*t+num;\\n}\\n```\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        \"\"\"\\n        :type num: int\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        return num+2*t\\n```\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return num+2*t;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739121,
                "title": "very-simple-return-num-2-t",
                "content": "\\n# Code\\n```\\nint theMaximumAchievableX(int num, int t) {\\n    return num + 2*t;\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint theMaximumAchievableX(int num, int t) {\\n    return num + 2*t;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738935,
                "title": "c-javascript-easy-one-liner",
                "content": "**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return (num+2*t);\\n    }\\n};\\n```\\n\\n**JavaScript**\\n\\n```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return (num+t+t);\\n};\\n```",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return (num+2*t);\\n    }\\n};\\n```\n```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return (num+t+t);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739107,
                "title": "c-one-liner",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return (num+2*t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return (num+2*t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745320,
                "title": "one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745319,
                "title": "one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739062,
                "title": "short-one-liner-c-java",
                "content": "\\n```C++ []\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+(t*2);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(t*2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+(t*2);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(t*2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739016,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return (t*2)+num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return (t*2)+num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899434,
                "title": "simple-explanation-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSo the logic was that there is a mid point so that if u increase num by 1, t times, and decrease the max achievable nymber by 1, t times, you\\'ll get the mid point so i made an equation,\\n\\nnum + t = x - t\\nso we get,\\n\\nx = num + 2*t\\n\\nSimple as that.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n\\n        return (num+2*t);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n\\n        return (num+2*t);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785085,
                "title": "one-liner-easy-double-your-coding-skills",
                "content": "# Intuition\\nWhen first approaching this problem, my initial thought was that each operation should both increase our result and bring the number `x` closer to `num`. Therefore, for each operation, `x` should be incrementing while `num` decreases. This led me to think that the maximum achievable number would be `num` increased by twice the number of operations `t`. The reason for doubling is that in each operation we both increase `num` and decrease `x`, thus essentially taking two steps toward making them equal.\\n\\nhttps://youtu.be/7AnoRPGkmKw\\n\\n# Approach\\nThe solution approach is fairly straightforward once we\\'ve figured out the intuition. Since our goal is to find the maximum achievable number `x` which can become equal to `num` after performing an operation `t` times, we need to add `2*t` to `num` to achieve that. This is because in each operation, we are decreasing `x` by 1 and increasing `num` by 1. So, `x` initially needs to be `2*t` steps ahead of `num` to finally meet `num` after `t` operations.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(1). This is because we are not performing any loops or recursive calls. We are simply performing a mathematical operation which takes constant time.\\n\\n- Space complexity:\\nThe space complexity is also O(1). We are not using any additional data structures that grow with the input size.\\n\\n# Code\\n```python\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        # We need to double the operations since we can increase num and x at the same time \\n        return num + 2*t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        # We need to double the operations since we can increase num and x at the same time \\n        return num + 2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739154,
                "title": "c-return-num-t-2-that-s-it",
                "content": "# Intuition\\nSubtracting 1 from `x` and adding 1 to `num` is as good as adding 2 to `num`\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t)\\n    {\\n        return num+(t*2);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t)\\n    {\\n        return num+(t*2);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739002,
                "title": "python3-math",
                "content": "\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057119,
                "title": "easy-one-liner-solution-in-c",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037145,
                "title": "one-line-solution-of-find-the-maximum-achievable-number-problem",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return(num + 2 * t)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return(num + 2 * t)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923318,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn each operation, you are allowed to increase or decrease both x and num by 1. Since you want to maximize the achievable number x, you should focus on maximizing the difference between x and num. If you increase x by 1, you should decrease num by 1, and if you decrease x by 1, you should increase num by 1. This way, you\\'re effectively increasing the difference between x and num by 2 in each operation.\\n\\nNow, considering the fact that you can perform these operations up to t times, you can maximize the difference between x and num by performing the operation that increases the difference as many times as possible. This would involve performing the operations that increase x while decreasing num, or vice versa, until you\\'ve used up all t operations.\\n\\nSince each operation increases the difference by 2, using t operations would increase the difference by 2 * t. Therefore, the maximum achievable number x would be equal to num + 2 * t, because you\\'re maximizing the difference between x and num.\\n\\nTo illustrate with an example:\\nSuppose num = 3 and t = 2.\\n\\nYou can increase x by 1 and decrease num by 1, making the difference 2.\\nYou can repeat the above operation again, making the difference 4.\\nYou can\\'t perform any more operations, as you\\'ve used up the t operations.\\nSo, in this case, the maximum achievable number x is num + 2 * t = 3 + 2 * 2 = 7, which matches the solution derived from the example.\\n\\nThis formula works because it optimally utilizes the given operations to maximize the difference between x and num within the allowed constraints.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899207,
                "title": "go-faster-approach-to-multiply-by-2",
                "content": "```\\nfunc theMaximumAchievableX(num int, t int) int {\\n    return num + (t << 1)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc theMaximumAchievableX(num int, t int) int {\\n    return num + (t << 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865334,
                "title": "java-1-liner-0ms-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864229,
                "title": "beats-100-java-one-line-solution-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(t*2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(t*2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819959,
                "title": "one-line-code-easiest-java-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        \\n        return num + (t * 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        \\n        return num + (t * 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816149,
                "title": "javascript-one-liner",
                "content": "# Javascript\\n```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return num + t + t;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return num + t + t;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807772,
                "title": "easy-1-line-solution-like-class-1-math-problem",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num + (t+t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num + (t+t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799047,
                "title": "this-problem-is-worded-terribly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI never once understood what this problem was asking me to do.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLeetcode enjoys describing problems in a way that makes no sense so I just guessed based on the pattern that was shown in the 2 examples. This problem needs to be reworded or removed.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nidk\\n# Code\\n```\\nfunction theMaximumAchievableX(num: number, t: number): number {\\n    return num + (t * 2);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction theMaximumAchievableX(num: number, t: number): number {\\n    return num + (t * 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3756000,
                "title": "0ms-runtime-one-liner-solution-in-python-c-java",
                "content": "# Code\\n```java []\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num+t*2\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math"
                ],
                "code": "```java []\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num+t*2\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755985,
                "title": "easy-and-simple-solution-in-java-c-and-python-0-ms-runtime",
                "content": "```Java []\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num+2*t\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Number Theory"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num+2*t\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755935,
                "title": "java-1-liner-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n      return num + (t * 2);  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n      return num + (t * 2);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751284,
                "title": "simple-solution-using-maths-all-programming-languages-same-formula-1-line-code",
                "content": "# Flow of Code\\nReturning the num+(2 times of t) as answer, using this formula you can calculate the maximum achievable number.\\n\\n# Use the Same Formula to compute answer in any programming language(C, C+, Java, Python, JS, etc...)\\n# Formula = num+(2*t)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```\\n# Happy Coding...\\uD83E\\uDD1D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747017,
                "title": "easy-c-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return (num+2*t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return (num+2*t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742448,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        ans=num+2*t\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        ans=num+2*t\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742175,
                "title": "python-very-easy-1-line-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742138,
                "title": "simple-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n           \\n         int ans = abs(num)+t;\\n         int maxAchievable = ans + t;\\n         return maxAchievable;\\n  }\\n        \\n       \\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n           \\n         int ans = abs(num)+t;\\n         int maxAchievable = ans + t;\\n         return maxAchievable;\\n  }\\n        \\n       \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740443,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + (2*t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + (2*t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739292,
                "title": "very-easy-solution-one-liner-c-kotlin-java-javascript-python",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```\\nJava \\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t + t;\\n    }\\n}\\n```\\nPython\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + t + t\\n```\\nJavascript\\n```\\nvar theMaximumAchievableX = function(num, t) {\\n    return num + t + t;\\n};\\n```\\nKotlin\\n```\\nclass Solution {\\n    fun theMaximumAchievableX(num: Int, t: Int): Int {\\n        return num + t + t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t + t;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + t + t\\n```\n```\\nvar theMaximumAchievableX = function(num, t) {\\n    return num + t + t;\\n};\\n```\n```\\nclass Solution {\\n    fun theMaximumAchievableX(num: Int, t: Int): Int {\\n        return num + t + t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739234,
                "title": "c-one-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739095,
                "title": "easy-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        int ans=0;\\n        int xeq=num+t;\\n        while(t>0){\\n            xeq+=1;\\n            t--;\\n        }\\n        ans=xeq;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        int ans=0;\\n        int xeq=num+t;\\n        while(t>0){\\n            xeq+=1;\\n            t--;\\n        }\\n        ans=xeq;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739027,
                "title": "best-solution-in-c-one-liner-no-extra-space-o-1",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+(2*t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+(2*t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738978,
                "title": "c-simple-one-line",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738932,
                "title": "easy-one-liner",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2* t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2* t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102182,
                "title": "easiest-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return (num+ t*2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return (num+ t*2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099936,
                "title": "max-achi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085796,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082643,
                "title": "o-1-one-line-japanese",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n> Increase or decrease `x` by `1`, and simultaneously increase or decrease `num` by `1`.\\n\\n\\u3064\\u307E\\u308A\\u3001`x`\\u3092$$1$$\\u6E1B\\u5C11\\u3055\\u305B\\u3001`num`\\u3092$$1$$\\u5897\\u52A0\\u3055\\u305B\\u308B\\u3068\\u3001\\u4E00\\u56DE\\u306E\\u64CD\\u4F5C\\u3067`x`\\u3068`num`\\u306E\\u5DEE\\u306F$$\\uFF12$$\\u305A\\u3064\\u6E1B\\u5C11\\u3057\\u307E\\u3059\\u3002\\n\\u3053\\u306E\\u64CD\\u4F5C\\u3092`t`\\u56DE\\u7E70\\u308A\\u8FD4\\u3059\\u3068\\u3001`x`\\u3068`num`\\u306E\\u5DEE\\u306F$2 \\\\times t$\\u6E1B\\u5C11\\u3057\\u307E\\u3059\\u3002\\n\\u4EE5\\u4E0A\\u306E\\u3053\\u3068\\u304B\\u3089\\u3001$x = num + 2t$\\u3068\\u3044\\u3048\\u307E\\u3059\\u3002\\n\\nIn other words, if `x` is decreased by 1 and `num` is increased by 1, the difference between `x` and `num` is decreased by 2 in one operation.\\nIf this operation is repeated `t` times, the difference between `x` and `num` decreases by $2 \\\\times t$.\\nFrom the above, we can say that $x = num + 2 \\\\times t$.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + t * 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + t * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080937,
                "title": "easy-java-solution-for-everyone-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        for(int i=0;i<100000;i++){\\n            if((i-t)==(num+t)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        for(int i=0;i<100000;i++){\\n            if((i-t)==(num+t)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080812,
                "title": "easy-java-solution-easily-predict-solution-from-given-samples",
                "content": "# Intuition\\nAfter seeing two sample easily got idea that we are doing two ops at time\\n\\n# Approach\\nsimple approach just add num+2*t\\n\\n# Complexity\\no(1)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080200,
                "title": "simple-maths",
                "content": "# Intuition\\nSimple maths\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n- Beats 100% users of Java\\n\\n- Space complexity:\\nBeats 75% users of Java. \\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078403,
                "title": "simple-easy-1-line-python-solution-explanation",
                "content": "# Explanation\\n\\nx - t = num + t , we can then get the x:\\nx = num + 2 * t, so we return this to get the max x\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2 * t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2 * t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072892,
                "title": "sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071169,
                "title": "easy-java-solution-maths",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069554,
                "title": "2769-find-the-maximum-achievable-number-one-line-solution-beats-59-65-76-66-by-a-sukhramani",
                "content": "# Intuition\\nThe intuition behind the solution is to maximize the achievable number by repeatedly increasing or decreasing both num and x by 1, up to a maximum of t times. To maximize the achievable number, we should perform these operations in a way that increases x as much as possible.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/31c68aa4-db11-4333-a9e5-0b5c1fede399_1695231149.6651633.png)\\n\\n# Approach\\nThe approach in the provided solution is straightforward. To maximize the achievable number, you can simply add 2*t to the initial value of num. This is because, by performing the allowed operations, you can increase x and num simultaneously by 1 in each step, so by performing t such operations, you can increase both x and num by 2*t.\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\nThe time complexity of this algorithm is O(1), as it only involves a single arithmetic operation.\\n\\n\\n- Space complexity:  O(1)\\nThe space complexity is also O(1), as it doesn\\'t use any additional data structures that grow with the input size.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num+2*t\\n```\\n# Results\\n![image.png](https://assets.leetcode.com/users/images/1658ec51-a8b5-49b8-8c3e-94fbdda09dfa_1695231122.9537296.png)\\n\\n# FAQ \\nwhich code is faster:\\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num + t + t\\n```\\nOR\\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num + 2*t\\n```\\n# Answer:\\n\\nIn most programming languages and modern compilers, both of these code snippets are likely to be optimized to produce the same result in terms of performance. The reason is that the compiler or interpreter can recognize the mathematical operation being performed and simplify it.\\n\\nBoth num + t + t and num + 2*t represent the same mathematical operation, which is adding t to num twice. In terms of performance, the difference, if any, would be negligible. Modern compilers and interpreters are generally smart enough to optimize such simple expressions.\\n\\nHowever, for the sake of code readability and maintainability, it\\'s often recommended to use the more concise and clear expression, which in this case is num + 2*t. It directly conveys the intention of adding 2*t to num, making the code easier to understand for other developers.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num+2*t\\n```\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num + t + t\\n```\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        return num + 2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067430,
                "title": "the-maximum-achievable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int x=num+t+t;\\n        return x;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int x=num+t+t;\\n        return x;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063182,
                "title": "no-need-to-wander-it-s-python",
                "content": "# No need to Wander\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+(2*t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+(2*t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063174,
                "title": "single-line-code-in-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+(t*2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+(t*2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062418,
                "title": "simple-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI see that there is a some sort of repititon based on t, so i am thinking main solution lies on doing something with t\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo as we see from the given example we are repting t times the same action. When x is increased or decreased by 1 num goes the other direction with same amount 1. When we decrease our x by t times and increase nums by t times we should get equality. Which means we should add twice the t amount to nums to get the x. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061310,
                "title": "find-the-maximum-achievable-number-javascript-beats-76-03-of-users-with-javascript",
                "content": "\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    while(t){\\n        num=num+2;\\n        t--;\\n    }\\n    return num;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    while(t){\\n        num=num+2;\\n        t--;\\n    }\\n    return num;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056867,
                "title": "100-beats-1ms-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t +t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t +t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056512,
                "title": "asm-o-1-solution",
                "content": "# Code\\n```\\nint theMaximumAchievableX(int num, int t);\\n\\n__asm__(\"theMaximumAchievableX:;\"\\n    \"mov %rsi,%rax;\" //         t -> rax\\n    \"shl $1,%rax;\"   //   2 * rax -> rax\\n    \"add %rdi,%rax;\" // num + rax -> rax\\n    \"ret;\"           //       return rax\\n);\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint theMaximumAchievableX(int num, int t);\\n\\n__asm__(\"theMaximumAchievableX:;\"\\n    \"mov %rsi,%rax;\" //         t -> rax\\n    \"shl $1,%rax;\"   //   2 * rax -> rax\\n    \"add %rdi,%rax;\" // num + rax -> rax\\n    \"ret;\"           //       return rax\\n);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055360,
                "title": "one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054227,
                "title": "simplest-approache",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049824,
                "title": "python-rust-solution-0-ms",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + (2 * t)\\n```\\n```rust []\\nimpl Solution {\\n    pub fn the_maximum_achievable_x(num: i32, t: i32) -> i32 {\\n        num + (2 * t)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + (2 * t)\\n```\n```rust []\\nimpl Solution {\\n    pub fn the_maximum_achievable_x(num: i32, t: i32) -> i32 {\\n        num + (2 * t)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048865,
                "title": "beats-100-users-with-java",
                "content": "# Simple Approach   \\n# Time Complexity : O(1)\\n# Space Complexity : O(1)\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return (num+t+t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return (num+t+t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048822,
                "title": "find-the-maximum-achievable-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048393,
                "title": "one-line",
                "content": "# <s>Intuition</s>\\n<i>Very strange formulation of the problem... \\nStill don\\u2019t understand what needs to be done?</i>\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047964,
                "title": "c-basic-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047673,
                "title": "python3-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every number, we realize that num and the maximum number will end up being equal. So our task is to find formula that calculate the current max number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe formula is: maxNum = num + (2*t)\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + (2*t)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + (2*t)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045403,
                "title": "maximizing-achievable-numbers-with-limited-operations-in-java",
                "content": "# Intuition\\nIf we have t operations to increase or decrease x by 1, we can either use all of them to increase x by t or decrease x by t, or we can use some to increase and some to decrease x.\\n\\n# Approach\\nTo maximize the achievable number, we can use t operations to either increase x by t or decrease x by t, which means we can add 2*t to num to get the maximum achievable number.\\n        \\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045393,
                "title": "i-think-so",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        \"\"\"\\n        :type num: int\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        return num + 2 * t\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        \"\"\"\\n        :type num: int\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        return num + 2 * t\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042970,
                "title": "a-simple-solution-with-a-single-addition-operator",
                "content": "\\n# Complexity\\n $$O(1)$$ \\n\\n# Code\\n```\\nfunc theMaximumAchievableX(num int, t int) int {\\n\\treturn t + t + num\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc theMaximumAchievableX(num int, t int) int {\\n\\treturn t + t + num\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042216,
                "title": "easy-python3-solution-to-find-the-maximum-achievable-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        op = 0\\n        for _ in range(t):\\n            num += 1\\n            op += 1\\n        return num + op\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        op = 0\\n        for _ in range(t):\\n            num += 1\\n            op += 1\\n        return num + op\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041680,
                "title": "python-simple-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConverge in t steps, means x = nums + 2*t\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 0(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040722,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038946,
                "title": "easiest-way-out",
                "content": "# Intuition\\n   We need a number which can be equal to the number provided if increased or decreased by 1 upto T times.\\n\\n# Approach\\n The number we assume that can be achievable **depends on t**.\\nIf we want to check for num 4 and t is 1 then achievable number should be 6 that is 4+(2*t), similarly when num is 3 and t is 2 then achievable number should be 7  that is 3+(2*t).\\n\\nW.R.T the given question -> we will assume the achievable number , then check whether we can achieve it by running while loop till t times.Decrease the achievable number by 1 and increase the number given by 1, if they are equal we will stop iterating further else we will iterate .\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int achieve=num+(2*t);\\n\\n        while(t>0){\\n          int temp=achieve-1;\\n          num=num+1;\\n           \\n           if(num!=temp){\\n               t--;\\n           }else{\\n               break;\\n           }\\n        }\\n      return achieve;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int achieve=num+(2*t);\\n\\n        while(t>0){\\n          int temp=achieve-1;\\n          num=num+1;\\n           \\n           if(num!=temp){\\n               t--;\\n           }else{\\n               break;\\n           }\\n        }\\n      return achieve;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038719,
                "title": "c-beats-100-one-liner-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;   \\n    }\\n};\\n```\\n\\n# Upvote Please!!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036823,
                "title": "1-line-python-solution-return-num-2-t",
                "content": "# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027959,
                "title": "o-1-one-liner-python-3-math",
                "content": "# Approach\\nx = num + 2 * t\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + 2*t\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026936,
                "title": "find-the-maximum-achievable-number-c-sigma-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + t + t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + t + t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024165,
                "title": "c-best-possible-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int TheMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TheMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022714,
                "title": "harshi-s-one-line-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return 2*t+num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return 2*t+num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021568,
                "title": "maximum-achievable-number-js-one-line",
                "content": "```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return num + t * 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return num + t * 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020034,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int n1=t*2;\\n        return num+n1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int n1=t*2;\\n        return num+n1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018668,
                "title": "one-line-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016539,
                "title": "single-line-argumenet-0-ms-40-mb-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016159,
                "title": "easy-question-easy-answer-smh",
                "content": "# Code\\n```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return num + t + t\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n    return num + t + t\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014828,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n     return num + t +t;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n     return num + t +t;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014657,
                "title": "c-0-ms-easy-solution",
                "content": "# Intuition\\nNormal Arithmetic solution\\n# Approach\\nNormal Arithmetic solution\\n\\n# Complexity\\n- Time complexity:\\no(1)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n     int x;\\n     x = num  + 2*t;\\n    \\n    return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n     int x;\\n     x = num  + 2*t;\\n    \\n    return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011513,
                "title": "full-explanation-code-for-the-one-liner-solution",
                "content": "# Intution:\\n  In question they have given that simultaneously we can increment num for the t times and we can decrement our ans for the t times , so by this line I can make this equation basically :\\n\\nAs we are doing this operation simultaneously at the same time so both the increment and decrement operation are actually same :\\n\\nEquation will be :\\n\\nnum + t = ans - t;\\nnum + t + t = ans\\n**ans = num + 2t**\\n\\nand that\\'s exactly why we are returning num+(2*t)\\n\\n# Complexity\\n- Time complexity:\\n  O(1)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(2*t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(2*t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011475,
                "title": "c-1-line-beats-100",
                "content": "# Intuition\\nThe Maximum number is always going to be t*2 because you can change the gap by 2 every time.\\n\\n# Approach\\nJust add t*2 to num\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nint theMaximumAchievableX(int num, int t){\\n    return num + (t*2);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint theMaximumAchievableX(int num, int t){\\n    return num + (t*2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010233,
                "title": "bu-ne-lan",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n      int a = 2*t+num;\\n\\n      return a;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n      int a = 2*t+num;\\n\\n      return a;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009419,
                "title": "java-one-line-solution-1ms-100-beat-easy-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n       int temp=num+t;\\n       for(int i=0;i<t;i++) temp = temp+1;\\n       return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n       int temp=num+t;\\n       for(int i=0;i<t;i++) temp = temp+1;\\n       return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007884,
                "title": "const-js-ts-single-line-solution",
                "content": "# Code\\n```\\nfunction theMaximumAchievableX(num: number, t: number): number {\\n    return num + t * 2\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction theMaximumAchievableX(num: number, t: number): number {\\n    return num + t * 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004982,
                "title": "accepted-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func theMaximumAchievableX(_ num: Int, _ t: Int) -> Int {\\n        num + t + t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func theMaximumAchievableX(_ num: Int, _ t: Int) -> Int {\\n        num + t + t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003559,
                "title": "surely-you-will-like-the-code-one-line-very-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001461,
                "title": "simplest-code-with-1ms-run-time-using-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) \\n    {\\n\\n        int rk = num + (2 * t);  // accoding to question \"2\" things is happend one is increase and another one is decrease\\n\"t\" times it is happend and start from \"num\"\\n//this process is continue until we get the same values.\\n        return rk;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) \\n    {\\n\\n        int rk = num + (2 * t);  // accoding to question \"2\" things is happend one is increase and another one is decrease\\n\"t\" times it is happend and start from \"num\"\\n//this process is continue until we get the same values.\\n        return rk;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001460,
                "title": "c-what-kinds-of-problem",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000857,
                "title": "solution-using-python-in-two-lines",
                "content": "# Complexity\\n- Time complexity: 15ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 13.14 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        \"\"\"\\n        :type num: int\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        ach_num = num + (t*2)\\n        return ach_num\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        \"\"\"\\n        :type num: int\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        ach_num = num + (t*2)\\n        return ach_num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998584,
                "title": "very-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n  return num + 2 * t;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @param {number} t\\n * @return {number}\\n */\\nvar theMaximumAchievableX = function(num, t) {\\n  return num + 2 * t;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998187,
                "title": "c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) \\n    {\\n        return num+t*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) \\n    {\\n        return num+t*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998152,
                "title": "100-beats-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int x=num;\\n        for(int i=0;i<t;i++){\\n           x+=2;\\n        }\\n    return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        int x=num;\\n        for(int i=0;i<t;i++){\\n           x+=2;\\n        }\\n    return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995456,
                "title": "a-c-solution-with-time-complexity-of-o-1-easy-solution",
                "content": "# Intuition\\nFind a formula to find the maximum achievable number .\\n\\n# Approach\\nformula =(num+t*2)\\ntry the 1st test cases with it ..\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n     return (num+t*2);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n     return (num+t*2);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993809,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int theMaximumAchievableX(int num, int t) {\\n    return num+(t*2); \\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int theMaximumAchievableX(int num, int t) {\\n    return num+(t*2); \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993300,
                "title": "one-line-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+t*2\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+t*2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991896,
                "title": "swift-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func theMaximumAchievableX(_ num: Int, _ t: Int) -> Int {\\n        num + (t * 2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func theMaximumAchievableX(_ num: Int, _ t: Int) -> Int {\\n        num + (t * 2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989071,
                "title": "one-liner-c",
                "content": "\\n# Approach\\n1. You start with the initial value of num.\\n2. You can add 2 * t to it.\\n3. Adding 2 * t will result in the maximum achievable value of num because it\\'s the largest possible value you can add.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988648,
                "title": "single-line-code-if-want-use-it",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) \\n    { \\n        return (num+t)+t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) \\n    { \\n        return (num+t)+t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983376,
                "title": "o-1-time-complexity-python-1-line-code-simple-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+(2*t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+(2*t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982795,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int theMaximumAchievableX(int num, int t) \\n    {\\n        return num + t * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int theMaximumAchievableX(int num, int t) \\n    {\\n        return num + t * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982170,
                "title": "c-one-liner",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + t * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + t * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978326,
                "title": "python-solution-made-by-a-begginer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num+2*t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976678,
                "title": "memory-beats-70-92-of-users-with-typescript",
                "content": "\\n# Code\\n```\\nfunction theMaximumAchievableX(num: number, t: number): number {\\n    return num + 2*t\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction theMaximumAchievableX(num: number, t: number): number {\\n    return num + 2*t\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976004,
                "title": "java-maths-100-faster-solution",
                "content": "# Intuition\\n- Maths\\n\\n# Approach\\n- Result is num + 2*t\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975564,
                "title": "one-line-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975281,
                "title": "java-fastest-one-line-soluton",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return Math.max( num + 2 * t, num - 2 * t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return Math.max( num + 2 * t, num - 2 * t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975154,
                "title": "easy-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is very simple that, every time we add a number to n, we subtract a number to x.\\nSo, x is equal to n + t * 2, because we are adding or substracting 1. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust a one liner: n + (2*t)\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + (2*t)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + (2*t)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970748,
                "title": "this-is-very-easy",
                "content": "this is most easy solution\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966477,
                "title": "one-line-solution-c-ajeet-iit-kanpur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n\\n        return (num + t *2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n\\n        return (num + t *2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964771,
                "title": "best-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return Math.abs(num + 2*t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return Math.abs(num + 2*t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959853,
                "title": "java-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958234,
                "title": "easy-to-understand-c-solution-contant-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        int g=num+(t*2);\\n        return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        int g=num+(t*2);\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957839,
                "title": "very-easy-solution-using-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return (2*t+num)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return (2*t+num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957339,
                "title": "well-explained-solution-with-a-very-simple-equation",
                "content": "# Intuition\\nIn order to make two numbers equal by using t operations. We will increase the nums which is smaller than the maximum achievable number. So now we will increase the nums by 1 t times and decrease the maximum achievable number by 1 t times. So the desired equation will be nums + 1*t = maximumNo. - 1*t that will become. nums + 2t = maximimNo.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955027,
                "title": "such-a-weirdly-worded-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n                return num+(t*2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n                return num+(t*2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954986,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n    \\n       return ((num+t)+t);\\n    \\n\\n       \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n    \\n       return ((num+t)+t);\\n    \\n\\n       \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954887,
                "title": "easy-and-think",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953937,
                "title": "python-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num +t * 2\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num +t * 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952412,
                "title": "beginner-level-solution-one-liner-beats-93-29-runtime",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        \"\"\"\\n        :type num: int\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n\\n        return num + t + t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def theMaximumAchievableX(self, num, t):\\n        \"\"\"\\n        :type num: int\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n\\n        return num + t + t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948868,
                "title": "mathematical-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis can be solved by using mathematical deduction. By looking at the input and output of example 1 we have a concrete idea of where we are starting and where we need to end up. This allows us to more easily come up with an equation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we need to convert the given description to a math formula. \\n\\nWe want to know how many steps it takes to get from \"x\" to \"num\" so we can subtract the two $$(x - num)$$.\\n\\nNext we have simultaneous operations of increment/decrement \"x\" and \"num\" that is performed each operation. Everytime \"x\" changes \"num\" also has to change; we are doing two steps for every single operation. Therefore we only need half the steps of $$(x - num)$$ in order for \"x\" to equal \"num\". Which gives us $$(x-num)/2$$ amount of steps.\\n\\nThe number of steps allowed needs to be \"t\" so then we have the equation $$t = (x-num)/2$$.\\n\\nIn the problem we are given \"t\" and \"num\" so we solve for x, yielding the equation $$x = 2t + num$$ which can be written as code to retun the \"x\" value required by the problem.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ - We perform a constant mathematical statement\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ - No new memory required\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return 2 * t + num\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return 2 * t + num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948605,
                "title": "easy-0ms-solution-one-line-answer-o-1-time-and-space-complexity-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Mathematical Approach was used in this Problem\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nint theMaximumAchievableX(int num, int t){\\nreturn 2*t+num;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "```\\nint theMaximumAchievableX(int num, int t){\\nreturn 2*t+num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946557,
                "title": "beats-100-o-1-solution",
                "content": "# Intuition\\n<Read the question and the solved cases carefully. It is nothing more than a simple linear equation -->\\n\\n# Approach\\n<!-If we check tyhe hint then it states that it is optimal and prudent to increase nums and decrease x which is to be found. Threfore let x be the max achievable number . Therefore x=num+(2*t)\\n ->\\n\\n# Complexity\\n- Time complexity:\\n<O(1) Beats 100%>\\n\\n- Space complexity:\\n<O(1)>\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(2*t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(2*t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943242,
                "title": "python-easy-code-light",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + t*2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + t*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942820,
                "title": "simple-to-understand-c",
                "content": "Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n     for(int i=0;i<t;i++){\\n         num+=2;\\n     }   \\n     return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n     for(int i=0;i<t;i++){\\n         num+=2;\\n     }   \\n     return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941887,
                "title": "one-liner",
                "content": "\\tclass Solution:\\n\\t\\tdef theMaximumAchievableX(self, num: int, t: int) -> int:\\n\\t\\t\\treturn (num + t*2)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef theMaximumAchievableX(self, num: int, t: int) -> int:\\n\\t\\t\\treturn (num + t*2)",
                "codeTag": "Java"
            },
            {
                "id": 3941139,
                "title": "c-one-liner-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2*t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940576,
                "title": "easy-java-solution-1ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int theMaximumAchievableX(int num, int t) \\n    {\\n        return (num +t*2);   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int theMaximumAchievableX(int num, int t) \\n    {\\n        return (num +t*2);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940478,
                "title": "easy-to-understand-best-solution-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*abs(t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+2*abs(t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940472,
                "title": "easy-to-understand-best-solution-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        num += 2*abs(t);\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        num += 2*abs(t);\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939875,
                "title": "c-very-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + t * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + t * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937598,
                "title": "maximum-achievable-number-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(2*t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(2*t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935765,
                "title": "easy-python-solution-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + t * 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return num + t * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935598,
                "title": "easy-java-solution-time-complexity-o-1-space-complexity-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + (2 * t); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + (2 * t); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933894,
                "title": "easiest-problem-in-leetcode-ever-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num+t+t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933719,
                "title": "oneliner",
                "content": "# Code\\n```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return (num + t * 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\\n        return (num + t * 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932630,
                "title": "one-liner-c-solution-beats-100-very-easy",
                "content": "Upvote if You find the solution helpful\\n```cpp\\nint theMaximumAchievableX(int num, int t) \\n    {\\n        return (num+(2*t));\\n    }",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "Upvote if You find the solution helpful\\n```cpp\\nint theMaximumAchievableX(int num, int t) \\n    {\\n        return (num+(2*t));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3930698,
                "title": "java-easiest-solution-possible-easiest-problem-on-leetcode-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return (num+t*2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return (num+t*2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930248,
                "title": "1-step-java-solution",
                "content": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n         return num+2*t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n         return num+2*t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927718,
                "title": "1-line-c-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int TheMaximumAchievableX(int num, int t) {\\n        return num + (2*t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TheMaximumAchievableX(int num, int t) {\\n        return num + (2*t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924172,
                "title": "easy-c-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return (num+t+t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return (num+t+t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923431,
                "title": "easy-best-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + 2 * t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922949,
                "title": "o-1-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + (t*2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + (t*2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921243,
                "title": "100-beats-1-ms-runtime-best-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(t*2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+(t*2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919324,
                "title": "very-very-simple-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t + t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num + t + t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914973,
                "title": "easy-c-one-liner-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + t +t;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int theMaximumAchievableX(int num, int t) {\\n        return num + t +t;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912513,
                "title": "easy-one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int theMaximumAchievableX(int num, int t) {\\n        return num+t*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1963455,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1963652,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1965932,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1962712,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1964338,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1963673,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1969891,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1984531,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1982480,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1970680,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1963455,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1963652,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1965932,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1962712,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1964338,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1963673,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1969891,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1984531,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1982480,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 1970680,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "Absolute troll problem"
                    },
                    {
                        "username": "kinfaat",
                        "content": "Spended 10 minitues to understand the question, and used 10 seconds to write 1 line ......"
                    },
                    {
                        "username": "dhenusarang",
                        "content": "please remove this problem\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "I don\\'t know why I was not able to think this solution in contest\\nit was really disappointing for me"
                    },
                    {
                        "username": "bssrdf",
                        "content": "This makes a perfect math word problem for a 2nd grade. I\\'ll try it with my daughter."
                    },
                    {
                        "username": "matthew106",
                        "content": "Omg I was staring at the problem like \"surely.. you can\\'t just do *this*\"\\nRe-reading the problem statement like 50 times and thinking what else they could\\'ve possibly meant and if I missed something."
                    },
                    {
                        "username": "Socrii13",
                        "content": "Kehna kya chahte ho?"
                    },
                    {
                        "username": "dopingcode",
                        "content": "samajh nhi aaya hoga usse"
                    },
                    {
                        "username": "dcaldwell95",
                        "content": "Solved the problem and I\\'m still not even sure I understand the question. Maybe if it was worded differently."
                    },
                    {
                        "username": "ravitchd",
                        "content": "this problem should be hard difficulty"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "not problem but its description"
                    },
                    {
                        "username": "pra_shant_here",
                        "content": "i was thinking \"is this problem that much easy or i have to think more about edge cases\""
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "same lol i wasted 5 min in contest thinking surely there must be edge cases..\\n"
                    }
                ]
            },
            {
                "id": 2059711,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 2025759,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 1967213,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 2072051,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 2069278,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 2059654,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 2026653,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 2012744,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 2003203,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            },
            {
                "id": 1997395,
                "content": [
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Quick explanation :\\nThere are four operations \\n1) num-- , x++;\\n2) num-- , x--;\\n3) num++ , x--;\\n4) num++ , x++;\\n\\nthen think about which operation we need to max num\\nExamples :\\nnum=4 , t=1\\n1) num-1 = 3    , x+1 = 3  then x=2;\\n2) num-1=3 , x-1=3  then x=4 ;\\n3) num+1 =5, x-1=5 then x=6;\\n4) num+1 =5, x+1=5 then x=4;\\n"
                    },
                    {
                        "username": "Arika08",
                        "content": "why leetcode why"
                    },
                    {
                        "username": "AGNixGRASiN",
                        "content": "reading all the comments i was like wth, how to solve this question, then i read the comment by [@Kasant](/kasant) i realised how stupid i am"
                    },
                    {
                        "username": "Neworly",
                        "content": "I think, highlighting `x` in this explanation confuses a lot of people without clarifying."
                    },
                    {
                        "username": "aiyappa18",
                        "content": "The answer is in the question itself just perform simple addition and return the answer."
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Does anyone understand the problem?"
                    },
                    {
                        "username": "aassfdfhgtjyh",
                        "content": "yeah, the tricky part is that it\\'s not tricky at all. just increase the number the way it\\'s implied you should"
                    },
                    {
                        "username": "Pratyush_Kumar_Developer",
                        "content": "Just read the question carefully. This problem is nothing if you understand it. Just return num+t+t or num+(t*2)"
                    },
                    {
                        "username": "c4rtel",
                        "content": "dumbass problem statement/prompt = no attempt + downvote bozo"
                    },
                    {
                        "username": "Sakhil335",
                        "content": "when I was reading this question and saw that it saying something \\'x\\' is achievable my first thought was oh so there will be a number x given and I have to check if its achievable or not but after solving this question I didn\\'t understand what this question is asking."
                    },
                    {
                        "username": "riarurainey",
                        "content": "The task was solved, but I didn\\'t understand what it was all about."
                    }
                ]
            }
        ]
    },
    {
        "title": "Visit Array Positions to Maximize Score",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and a positive integer <code>x</code>.</p>\n\n<p>You are <strong>initially</strong> at position <code>0</code> in the array and you can visit other positions according to the following rules:</p>\n\n<ul>\n\t<li>If you are currently in position <code>i</code>, then you can move to <strong>any</strong> position <code>j</code> such that <code>i &lt; j</code>.</li>\n\t<li>For each position <code>i</code> that you visit, you get a score of <code>nums[i]</code>.</li>\n\t<li>If you move from a position <code>i</code> to a position <code>j</code> and the <strong>parities</strong> of <code>nums[i]</code> and <code>nums[j]</code> differ, then you lose a score of <code>x</code>.</li>\n</ul>\n\n<p>Return <em>the <strong>maximum</strong> total score you can get</em>.</p>\n\n<p><strong>Note</strong> that initially you have <code>nums[0]</code> points.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,6,1,9,2], x = 5\n<strong>Output:</strong> 13\n<strong>Explanation:</strong> We can visit the following positions in the array: 0 -&gt; 2 -&gt; 3 -&gt; 4.\nThe corresponding values are 2, 6, 1 and 9. Since the integers 6 and 1 have different parities, the move 2 -&gt; 3 will make you lose a score of x = 5.\nThe total score will be: 2 + 6 + 1 + 9 - 5 = 13.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,6,8], x = 3\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> All the integers in the array have the same parities, so we can visit all of them without losing any score.\nThe total score is: 2 + 4 + 6 + 8 = 20.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], x &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3801703,
                "title": "odd-even-dp",
                "content": "This seems to fall into the [198. House Robber](https://leetcode.com/problems/house-robber/) cetegory of problems.\\n    \\nWe track the maximum score for the most recent odd and even number.\\n\\nWhen we see an odd number, we have two choices (flip for even number):\\n- take score from the previous odd number\\n- take score from the previous even number, minus `x`.\\n\\nWe use the maximum of these two choices.\\n    \\nNote that we must start from `0` position, so we need to subtract `x` from either `odd` or `eve`.\\n    \\n**C++**\\n```cpp\\nlong long maxScore(vector<int>& n, int x) {\\n    long long eve = n[0] - (n[0] % 2 ? x : 0);\\n    long long odd = n[0] - (n[0] % 2 ? 0 : x);\\n    for (int i = 1; i < n.size(); ++i)\\n        if (n[i] % 2)\\n            odd = n[i] + max(odd, eve - x);\\n        else\\n            eve = n[i] + max(eve, odd - x);\\n    return max(eve, odd);\\n}\\n```\\n\\n## Compressed Version\\n**C++**\\n```cpp\\nlong long maxScore(vector<int>& n, int x) {\\n    long long p[2] = { n[0] - x * (n[0] % 2), n[0] - x * !(n[0] % 2) };\\n    for (int i = 1; i < n.size(); ++i)\\n        p[n[i] % 2] = n[i] + max(p[n[i] % 2], p[!(n[i] % 2)] - x);\\n    return max(p[0], p[1]);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long maxScore(vector<int>& n, int x) {\\n    long long eve = n[0] - (n[0] % 2 ? x : 0);\\n    long long odd = n[0] - (n[0] % 2 ? 0 : x);\\n    for (int i = 1; i < n.size(); ++i)\\n        if (n[i] % 2)\\n            odd = n[i] + max(odd, eve - x);\\n        else\\n            eve = n[i] + max(eve, odd - x);\\n    return max(eve, odd);\\n}\\n```\n```cpp\\nlong long maxScore(vector<int>& n, int x) {\\n    long long p[2] = { n[0] - x * (n[0] % 2), n[0] - x * !(n[0] % 2) };\\n    for (int i = 1; i < n.size(); ++i)\\n        p[n[i] % 2] = n[i] + max(p[n[i] % 2], p[!(n[i] % 2)] - x);\\n    return max(p[0], p[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3801819,
                "title": "simple-pick-skip",
                "content": "\\n# Code\\n```\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    ll memo[100005][2];\\n    \\n    ll fun(int ind, int isOdd, int x, vector<int>& nums) {\\n        if(ind == nums.size())return 0;\\n        if(memo[ind][isOdd] != -1)return memo[ind][isOdd];\\n        \\n        ll skip = fun(ind+1, isOdd, x, nums);\\n        ll pick = nums[ind] + fun(ind+1, (nums[ind]&1), x, nums);\\n        if((nums[ind]&1) != isOdd)pick -= x;\\n        return memo[ind][isOdd] = max(pick, skip);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(memo, -1, sizeof(memo));\\n        return nums[0] + fun(1, (nums[0] & 1), x, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    ll memo[100005][2];\\n    \\n    ll fun(int ind, int isOdd, int x, vector<int>& nums) {\\n        if(ind == nums.size())return 0;\\n        if(memo[ind][isOdd] != -1)return memo[ind][isOdd];\\n        \\n        ll skip = fun(ind+1, isOdd, x, nums);\\n        ll pick = nums[ind] + fun(ind+1, (nums[ind]&1), x, nums);\\n        if((nums[ind]&1) != isOdd)pick -= x;\\n        return memo[ind][isOdd] = max(pick, skip);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(memo, -1, sizeof(memo));\\n        return nums[0] + fun(1, (nums[0] & 1), x, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801776,
                "title": "java-c-python-dp-solution",
                "content": "# **Intuition**\\nThe latest status depends on previous score,\\nso we can solve this problem with dp approach.\\n<br>\\n\\n# **Explanation**\\n`dp[0]` means the max score with last visit is even.\\n`dp[1]` means the max score with last visit is odd.\\n\\nWe initilize `dp[0]` and `dp[1]` with `-x` to be small enough.\\nBecause we start with `A[0]`,\\nso `dp[A[0] & 1] = A[0]`\\n\\n\\nThen iterate each `A[i]` where `i > 0`:\\n\\nOne option to reach `A[i]`,\\nis going from same parities,\\nand get score `dp[A[i] & 1] + A[i]`.\\n\\nThe other option to reach `A[i]`,\\nis going from different parities,\\nand get score `dp[A[i] & 1 ^ 1] + A[i] - x`.\\n\\nWe update `dp[A[i] & 1]` with the max of both option,\\ncontinue doing this,\\nand finally return `max(dp[0], dp[1])`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long maxScore(int[] A, int x) {\\n        long dp[] = new long[] { -x, -x}, n = A.length;\\n        dp[A[0] & 1] = A[0];\\n        for (int i = 1; i < n; i++)\\n            dp[A[i] & 1] = Math.max(dp[A[i] & 1], dp[A[i] & 1 ^ 1] - x) + A[i];\\n        return Math.max(dp[0], dp[1]);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long maxScore(vector<int>& A, int x) {\\n        long long dp[2] = {-x, -x}, n = A.size();\\n        dp[A[0] & 1] = A[0];\\n        for (int i = 1; i < n; i++)\\n            dp[A[i] & 1] = max(dp[A[i] & 1], dp[A[i] & 1 ^ 1] - x) + A[i];\\n        return max(dp[0], dp[1]);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxScore(self, A: List[int], x: int) -> int:\\n        dp = [-x, -x]\\n        dp[A[0] & 1] = A[0]\\n        for i in range(1, len(A)):\\n            dp[A[i] & 1] = max(dp[A[i] & 1], dp[A[i] & 1 ^ 1] - x) + A[i]\\n        return max(dp)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long maxScore(int[] A, int x) {\\n        long dp[] = new long[] { -x, -x}, n = A.length;\\n        dp[A[0] & 1] = A[0];\\n        for (int i = 1; i < n; i++)\\n            dp[A[i] & 1] = Math.max(dp[A[i] & 1], dp[A[i] & 1 ^ 1] - x) + A[i];\\n        return Math.max(dp[0], dp[1]);\\n    }\\n```\n```cpp\\n    long long maxScore(vector<int>& A, int x) {\\n        long long dp[2] = {-x, -x}, n = A.size();\\n        dp[A[0] & 1] = A[0];\\n        for (int i = 1; i < n; i++)\\n            dp[A[i] & 1] = max(dp[A[i] & 1], dp[A[i] & 1 ^ 1] - x) + A[i];\\n        return max(dp[0], dp[1]);\\n    }\\n```\n```py\\n    def maxScore(self, A: List[int], x: int) -> int:\\n        dp = [-x, -x]\\n        dp[A[0] & 1] = A[0]\\n        for i in range(1, len(A)):\\n            dp[A[i] & 1] = max(dp[A[i] & 1], dp[A[i] & 1 ^ 1] - x) + A[i]\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3802145,
                "title": "accepted-dp-memoization-tabulation-space-optimisation",
                "content": "# Intuition\\nAccording to constraints, if we directly apply memoization we will definetely get memory limit exceeded, as we need to maintain a prev pointer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this approach we are clubbing consecutive even and odd numbers to form a new vector ```temp ``` \\n\\nSuppose in given example:\\n```nums = [2,3,6,1,9,2]```\\nThe new temp would be\\n```temp = [2,3,6,10,2]```\\n\\nNote that in this example, in even indices, the sums are coming from even numbers and in odd indices sum is coming from odd numbers, see the pattern by taking other examples\\n\\nNow in this new ```temp``` we are applying pick and not-pick type algorithm\\n\\nIf we want to pick the element then if parity of both is same then we directly pick the number, otherwise we will subtract ```x```.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Memoization\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(n * 2) + O(n)``` \\n    ```O(n*2)``` for ```dp``` vector and``` O(n)``` for forming ```temp``` vector in worst case\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\n    vector<vector<long long>> dp;\\n    int n;\\n    long long f(int i, vector<long long> &nums, int x, bool prev) {\\n        if(i >= n) return 0;\\n        if(dp[i][prev] != -1) return dp[i][prev];\\n        \\n        int scoreDiff = ((i&1) == prev) ? 0 : -x;\\n\\n        // if nums[i] is even then i&1 will be zero otherwise one\\n        long long pick = nums[i] + f(i+1, nums, x, i&1) + scoreDiff;\\n            \\n        long long notPick = f(i+1, nums, x, prev);\\n        \\n        return dp[i][prev] = max(pick, notPick);\\n    }\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        n = nums.size();\\n        vector<long long> temp;\\n        temp.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            long long mist = nums[i];\\n            while (i < n - 1 && ((nums[i] & 1) == (nums[i + 1] & 1))) {\\n                mist += nums[i + 1];\\n                i++;\\n            }\\n            temp.push_back(mist);\\n        }\\n        n = temp.size();\\n        dp.resize(n+1, vector<long long>(2, -1));\\n        return temp[0] + f(1, temp, x, 0);\\n    }\\n};\\n\\n```\\n\\n# Tabulation \\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Same as memoization\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\n    vector<vector<long long>> dp;\\n    int n;\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        n = nums.size();\\n        vector<long long> temp;\\n        temp.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            long long mist = nums[i];\\n            while (i < n - 1 && ((nums[i] & 1) == (nums[i + 1] & 1))) {\\n                mist += nums[i + 1];\\n                i++;\\n            }\\n            temp.push_back(mist);\\n        }\\n\\n        n = temp.size();\\n        dp.resize(n+1, vector<long long>(2, 0));\\n\\n        for(int i=n-1; i>=1; i--) {\\n            for(int prev = 1; prev >= 0; prev--) {\\n                int scoreDiff = ((i&1) == prev) ? 0 : -x;\\n\\n                // if nums[i] is even then i&1 will be zero otherwise one\\n                long long pick = temp[i] + dp[i+1][i&1] + scoreDiff;        \\n                long long notPick = dp[i+1][prev];\\n                \\n                dp[i][prev] = max(pick, notPick);\\n            }\\n        }\\n\\n        return temp[0] + dp[1][0];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(n)``` just for ```temp``` vector in worst case\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\n    int n;\\n    vector<long long> curr, next;\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        n = nums.size();\\n        vector<long long> temp;\\n        temp.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            long long mist = nums[i];\\n            while (i < n - 1 && ((nums[i] & 1) == (nums[i + 1] & 1))) {\\n                mist += nums[i + 1];\\n                i++;\\n            }\\n            temp.push_back(mist);\\n        }\\n\\n        n = temp.size();\\n        curr.resize(2, 0);\\n        next.resize(2, 0);\\n\\n        for(int i=n-1; i>=1; i--) {\\n            curr[0] = max(next[0], temp[i] + next[i&1] - (((i&1) == 0) ? 0 : x));\\n            curr[1] = max(next[1], temp[i] + next[i&1] - (((i&1) == 1) ? 0 : x));\\n            next = curr;\\n        }\\n\\n        return temp[0] + curr[0];\\n    }\\n};\\n\\n```\\n\\n![44ebf2d7-8246-4ed4-b136-ed4dfb6813e6_1678967256.4179664.png](https://assets.leetcode.com/users/images/a2f3b5fa-e616-429f-99d1-5b6569162dc5_1690050760.3696508.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```temp ```\n```nums = [2,3,6,1,9,2]```\n```temp = [2,3,6,10,2]```\n```temp```\n```x```\n```O(n)```\n```O(n * 2) + O(n)```\n```O(n*2)```\n```dp```\n``` O(n)```\n```temp```\n```\\nclass Solution {\\n    vector<vector<long long>> dp;\\n    int n;\\n    long long f(int i, vector<long long> &nums, int x, bool prev) {\\n        if(i >= n) return 0;\\n        if(dp[i][prev] != -1) return dp[i][prev];\\n        \\n        int scoreDiff = ((i&1) == prev) ? 0 : -x;\\n\\n        // if nums[i] is even then i&1 will be zero otherwise one\\n        long long pick = nums[i] + f(i+1, nums, x, i&1) + scoreDiff;\\n            \\n        long long notPick = f(i+1, nums, x, prev);\\n        \\n        return dp[i][prev] = max(pick, notPick);\\n    }\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        n = nums.size();\\n        vector<long long> temp;\\n        temp.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            long long mist = nums[i];\\n            while (i < n - 1 && ((nums[i] & 1) == (nums[i + 1] & 1))) {\\n                mist += nums[i + 1];\\n                i++;\\n            }\\n            temp.push_back(mist);\\n        }\\n        n = temp.size();\\n        dp.resize(n+1, vector<long long>(2, -1));\\n        return temp[0] + f(1, temp, x, 0);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    vector<vector<long long>> dp;\\n    int n;\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        n = nums.size();\\n        vector<long long> temp;\\n        temp.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            long long mist = nums[i];\\n            while (i < n - 1 && ((nums[i] & 1) == (nums[i + 1] & 1))) {\\n                mist += nums[i + 1];\\n                i++;\\n            }\\n            temp.push_back(mist);\\n        }\\n\\n        n = temp.size();\\n        dp.resize(n+1, vector<long long>(2, 0));\\n\\n        for(int i=n-1; i>=1; i--) {\\n            for(int prev = 1; prev >= 0; prev--) {\\n                int scoreDiff = ((i&1) == prev) ? 0 : -x;\\n\\n                // if nums[i] is even then i&1 will be zero otherwise one\\n                long long pick = temp[i] + dp[i+1][i&1] + scoreDiff;        \\n                long long notPick = dp[i+1][prev];\\n                \\n                dp[i][prev] = max(pick, notPick);\\n            }\\n        }\\n\\n        return temp[0] + dp[1][0];\\n    }\\n};\\n```\n```O(n)```\n```temp```\n```\\nclass Solution {\\n    int n;\\n    vector<long long> curr, next;\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        n = nums.size();\\n        vector<long long> temp;\\n        temp.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            long long mist = nums[i];\\n            while (i < n - 1 && ((nums[i] & 1) == (nums[i + 1] & 1))) {\\n                mist += nums[i + 1];\\n                i++;\\n            }\\n            temp.push_back(mist);\\n        }\\n\\n        n = temp.size();\\n        curr.resize(2, 0);\\n        next.resize(2, 0);\\n\\n        for(int i=n-1; i>=1; i--) {\\n            curr[0] = max(next[0], temp[i] + next[i&1] - (((i&1) == 0) ? 0 : x));\\n            curr[1] = max(next[1], temp[i] + next[i&1] - (((i&1) == 1) ? 0 : x));\\n            next = curr;\\n        }\\n\\n        return temp[0] + curr[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801956,
                "title": "0-1-knapsack-dp-c-java-python",
                "content": "# Intuition \\n**``` Since we need to maximize the sum as based on given condition we can apply Dynamic Programming.```**\\n# Approach\\n**```Each time we can pick an element and add it to sum and subtract x if their parity are different```**\\n\\n**To maintain a parity check we can have a state of size 2.\\nThus we can apply Pick / NotPick DP with an ease**\\n\\n# Complexity\\n**- Time complexity:**\\n**```The overall time complexity of the code is O(N * 2) => O(N) ```**\\n\\n**- Space complexity:**\\n**```Since we are using the dp table space complexity goes up to O(N * 2) => O(N) ```**\\n\\n# Code (C++)\\n```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    ll func(int idx, vector<int> &nums, int x, int prev, vector<vector<ll>> &dp)\\n    {\\n        if (idx == nums.size())\\n            return 0;\\n        ll pick = -1e12, notpick = -1e12;\\n        // Pick \\n        if (dp[idx][prev] != -1)\\n            return dp[idx][prev];\\n        if (nums[idx] % 2 != 0)\\n        {\\n            if (prev)\\n                pick = nums[idx] + func(idx + 1, nums, x, (nums[idx] % 2 != 0), dp);\\n            else\\n                pick = nums[idx] - x + func(idx + 1, nums, x, (nums[idx] % 2 != 0), dp);\\n        }\\n        else\\n        {\\n            if (prev == 0)\\n                pick = nums[idx] + func(idx + 1, nums, x, (nums[idx] % 2 != 0), dp);\\n            else\\n                pick = nums[idx] - x + func(idx + 1, nums, x, (nums[idx] % 2 != 0), dp);\\n        }\\n        notpick = 0 + func(idx + 1, nums, x, prev, dp);\\n        \\n        return dp[idx][prev] = max(notpick, pick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<ll>> dp(nums.size() + 1, vector<ll> (2, -1));\\n        return func(0, nums, x, (nums[0] % 2 == 1), dp);\\n    }\\n};\\n```\\n# Code (Java)\\n```\\nimport java.util.*;\\n\\npublic class Solution {\\n\\n    public long maxScore(List<Integer> nums, int x) {\\n        int n = nums.size();\\n        long[][] dp = new long[n + 1][2];\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return func(0, nums, x, (nums.get(0) % 2 == 1) ? 1 : 0, dp);\\n    }\\n\\n    private long func(int idx, List<Integer> nums, int x, int prev, long[][] dp) {\\n        int n = nums.size();\\n        if (idx == n)\\n            return 0;\\n        long pick = Long.MIN_VALUE, notpick = Long.MIN_VALUE;\\n        // Pick\\n        if (dp[idx][prev] != -1)\\n            return dp[idx][prev];\\n\\n        if (nums.get(idx) % 2 != 0) {\\n            if (prev != 0)\\n                pick = nums.get(idx) + func(idx + 1, nums, x, (nums.get(idx) % 2 != 0) ? 1 : 0, dp);\\n            else\\n                pick = nums.get(idx) - x + func(idx + 1, nums, x, (nums.get(idx) % 2 != 0) ? 1 : 0, dp);\\n        } else {\\n            if (prev == 0)\\n                pick = nums.get(idx) + func(idx + 1, nums, x, (nums.get(idx) % 2 != 0) ? 1 : 0, dp);\\n            else\\n                pick = nums.get(idx) - x + func(idx + 1, nums, x, (nums.get(idx) % 2 != 0) ? 1 : 0, dp);\\n        }\\n\\n        notpick = 0 + func(idx + 1, nums, x, prev, dp);\\n\\n        dp[idx][prev] = Math.max(notpick, pick);\\n        return dp[idx][prev];\\n    }\\n}\\n```\\n# Code (Python)\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        dp = [[-1 for _ in range(2)] for _ in range(len(nums) + 1)]\\n        return self.func(0, nums, x, (nums[0] % 2 == 1), dp)\\n\\n    def func(self, idx, nums, x, prev, dp):\\n        if idx == len(nums):\\n            return 0\\n        pick, notpick = float(\\'-inf\\'), float(\\'-inf\\')\\n        # Pick\\n        if dp[idx][prev] != -1:\\n            return dp[idx][prev]\\n\\n        if nums[idx] % 2 != 0:\\n            if prev != 0:\\n                pick = nums[idx] + self.func(idx + 1, nums, x, 1 if nums[idx] % 2 != 0 else 0, dp)\\n            else:\\n                pick = nums[idx] - x + self.func(idx + 1, nums, x, 1 if nums[idx] % 2 != 0 else 0, dp)\\n        else:\\n            if prev == 0:\\n                pick = nums[idx] + self.func(idx + 1, nums, x, 1 if nums[idx] % 2 != 0 else 0, dp)\\n            else:\\n                pick = nums[idx] - x + self.func(idx + 1, nums, x, 1 if nums[idx] % 2 != 0 else 0, dp)\\n\\n        notpick = 0 + self.func(idx + 1, nums, x, prev, dp)\\n\\n        dp[idx][prev] = max(notpick, pick)\\n        return dp[idx][prev]\\n```\\n``` Please Upvote if it was helpful ```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` Since we need to maximize the sum as based on given condition we can apply Dynamic Programming.```\n```Each time we can pick an element and add it to sum and subtract x if their parity are different```\n```The overall time complexity of the code is O(N * 2) => O(N) ```\n```Since we are using the dp table space complexity goes up to O(N * 2) => O(N) ```\n```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    ll func(int idx, vector<int> &nums, int x, int prev, vector<vector<ll>> &dp)\\n    {\\n        if (idx == nums.size())\\n            return 0;\\n        ll pick = -1e12, notpick = -1e12;\\n        // Pick \\n        if (dp[idx][prev] != -1)\\n            return dp[idx][prev];\\n        if (nums[idx] % 2 != 0)\\n        {\\n            if (prev)\\n                pick = nums[idx] + func(idx + 1, nums, x, (nums[idx] % 2 != 0), dp);\\n            else\\n                pick = nums[idx] - x + func(idx + 1, nums, x, (nums[idx] % 2 != 0), dp);\\n        }\\n        else\\n        {\\n            if (prev == 0)\\n                pick = nums[idx] + func(idx + 1, nums, x, (nums[idx] % 2 != 0), dp);\\n            else\\n                pick = nums[idx] - x + func(idx + 1, nums, x, (nums[idx] % 2 != 0), dp);\\n        }\\n        notpick = 0 + func(idx + 1, nums, x, prev, dp);\\n        \\n        return dp[idx][prev] = max(notpick, pick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<ll>> dp(nums.size() + 1, vector<ll> (2, -1));\\n        return func(0, nums, x, (nums[0] % 2 == 1), dp);\\n    }\\n};\\n```\n```\\nimport java.util.*;\\n\\npublic class Solution {\\n\\n    public long maxScore(List<Integer> nums, int x) {\\n        int n = nums.size();\\n        long[][] dp = new long[n + 1][2];\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return func(0, nums, x, (nums.get(0) % 2 == 1) ? 1 : 0, dp);\\n    }\\n\\n    private long func(int idx, List<Integer> nums, int x, int prev, long[][] dp) {\\n        int n = nums.size();\\n        if (idx == n)\\n            return 0;\\n        long pick = Long.MIN_VALUE, notpick = Long.MIN_VALUE;\\n        // Pick\\n        if (dp[idx][prev] != -1)\\n            return dp[idx][prev];\\n\\n        if (nums.get(idx) % 2 != 0) {\\n            if (prev != 0)\\n                pick = nums.get(idx) + func(idx + 1, nums, x, (nums.get(idx) % 2 != 0) ? 1 : 0, dp);\\n            else\\n                pick = nums.get(idx) - x + func(idx + 1, nums, x, (nums.get(idx) % 2 != 0) ? 1 : 0, dp);\\n        } else {\\n            if (prev == 0)\\n                pick = nums.get(idx) + func(idx + 1, nums, x, (nums.get(idx) % 2 != 0) ? 1 : 0, dp);\\n            else\\n                pick = nums.get(idx) - x + func(idx + 1, nums, x, (nums.get(idx) % 2 != 0) ? 1 : 0, dp);\\n        }\\n\\n        notpick = 0 + func(idx + 1, nums, x, prev, dp);\\n\\n        dp[idx][prev] = Math.max(notpick, pick);\\n        return dp[idx][prev];\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        dp = [[-1 for _ in range(2)] for _ in range(len(nums) + 1)]\\n        return self.func(0, nums, x, (nums[0] % 2 == 1), dp)\\n\\n    def func(self, idx, nums, x, prev, dp):\\n        if idx == len(nums):\\n            return 0\\n        pick, notpick = float(\\'-inf\\'), float(\\'-inf\\')\\n        # Pick\\n        if dp[idx][prev] != -1:\\n            return dp[idx][prev]\\n\\n        if nums[idx] % 2 != 0:\\n            if prev != 0:\\n                pick = nums[idx] + self.func(idx + 1, nums, x, 1 if nums[idx] % 2 != 0 else 0, dp)\\n            else:\\n                pick = nums[idx] - x + self.func(idx + 1, nums, x, 1 if nums[idx] % 2 != 0 else 0, dp)\\n        else:\\n            if prev == 0:\\n                pick = nums[idx] + self.func(idx + 1, nums, x, 1 if nums[idx] % 2 != 0 else 0, dp)\\n            else:\\n                pick = nums[idx] - x + self.func(idx + 1, nums, x, 1 if nums[idx] % 2 != 0 else 0, dp)\\n\\n        notpick = 0 + self.func(idx + 1, nums, x, prev, dp)\\n\\n        dp[idx][prev] = max(notpick, pick)\\n        return dp[idx][prev]\\n```\n``` Please Upvote if it was helpful ```",
                "codeTag": "Java"
            },
            {
                "id": 3802282,
                "title": "java-dp",
                "content": "### Intuition:\\nMaintain two scores, one for when we last visited an odd number (oddScore) and one for when we last visited an even number (evenScore), and for each number, update the relevant score. We also maintain a variable score to keep track of the maximum score seen so far.\\n\\n### Algorithm:\\n\\nInitialize oddScore, evenScore, and score to `nums[0]`. If the first number is odd, deduct `x` from evenScore, else deduct `x` from oddScore.\\n\\nStart traversing the array from the 1st index:\\n1. If the current number is even, update evenScore as the maximum of evenScore + current number and oddScore + current number - x. Then update score as the maximum of score and evenScore.\\n2. If the current number is odd, update oddScore as the maximum of oddScore + current number and evenScore + current number - x. Then update score as the maximum of score and oddScore.\\n3. Return score as the maximum total score you can get.\\n\\n### Complexity Analysis:\\n- Time Complexity: O(n), where n is the size of the array. This is because we traverse the array only once and do a constant amount of work for each element.\\n\\n- Space Complexity: O(1). This is because we only use a fixed amount of space to store our variables and do not use any additional data structures whose size depends on the input.\\n\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long oddScore = nums[0], evenScore = nums[0], score = nums[0];\\n        if (nums[0] % 2 == 0) oddScore -= x;\\n        else evenScore -= x;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                evenScore = Math.max(evenScore + nums[i], oddScore + nums[i] - x);\\n                score = Math.max(score, evenScore);\\n            } else {\\n                oddScore = Math.max(oddScore + nums[i], evenScore + nums[i] - x);\\n                score = Math.max(score, oddScore);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long oddScore = nums[0], evenScore = nums[0], score = nums[0];\\n        if (nums[0] % 2 == 0) oddScore -= x;\\n        else evenScore -= x;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                evenScore = Math.max(evenScore + nums[i], oddScore + nums[i] - x);\\n                score = Math.max(score, evenScore);\\n            } else {\\n                oddScore = Math.max(oddScore + nums[i], evenScore + nums[i] - x);\\n                score = Math.max(score, oddScore);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802267,
                "title": "dp-java-memoization",
                "content": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n=nums.length;\\n        long  dp[][]=new long[n][2];\\n        for(long p[]:dp)Arrays.fill(p,-1);\\n        \\n        return solve(1,nums,x,((nums[0]%2==0)?0:1),nums.length,dp)+nums[0]; //nums[0] is the initial value taken\\n    }\\n    public long solve(int i,int nums[],int x,int f,int n,long dp[][]){\\n        if(i>=n)return 0;\\n        //storing the parity f of before element\\n        if(dp[i][f]!=-1)return dp[i][f];\\n        \\n        long take=0;\\n        //if parity is same\\n        if((f==0 && nums[i]%2==0) || (f==1 && nums[i]%2==1)){\\n           take+=nums[i]+solve(i+1,nums,x,((nums[i]%2==0)?0:1),n,dp); \\n        }\\n        \\n        //if parity not same\\n        else if((f==0 && nums[i]%2==1) || (f==1 && nums[i]%2==0)){\\n            take+=nums[i]-x+solve(i+1,nums,x,((nums[i]%2==0)?0:1),n,dp);\\n        }\\n        \\n        long not=solve(i+1,nums,x,f,n,dp);\\n        \\n        return dp[i][f]=Math.max(take,not);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n=nums.length;\\n        long  dp[][]=new long[n][2];\\n        for(long p[]:dp)Arrays.fill(p,-1);\\n        \\n        return solve(1,nums,x,((nums[0]%2==0)?0:1),nums.length,dp)+nums[0]; //nums[0] is the initial value taken\\n    }\\n    public long solve(int i,int nums[],int x,int f,int n,long dp[][]){\\n        if(i>=n)return 0;\\n        //storing the parity f of before element\\n        if(dp[i][f]!=-1)return dp[i][f];\\n        \\n        long take=0;\\n        //if parity is same\\n        if((f==0 && nums[i]%2==0) || (f==1 && nums[i]%2==1)){\\n           take+=nums[i]+solve(i+1,nums,x,((nums[i]%2==0)?0:1),n,dp); \\n        }\\n        \\n        //if parity not same\\n        else if((f==0 && nums[i]%2==1) || (f==1 && nums[i]%2==0)){\\n            take+=nums[i]-x+solve(i+1,nums,x,((nums[i]%2==0)?0:1),n,dp);\\n        }\\n        \\n        long not=solve(i+1,nums,x,f,n,dp);\\n        \\n        return dp[i][f]=Math.max(take,not);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802115,
                "title": "c-dp-pick-notpick-with-explanation",
                "content": "We will always have to include index zero to our score so for next indexes the previous element is index zero. Store the parity of index 0 element now for coming element either we can add it to our score or move to next index without adding. In case of not pick simply move to the next index with same parity value. But in case of picking 2 cases arise if the parity of current index is equal to last picked index then add the score of current index , otherwise if the parities are different then add the number at given index and substract the number x.\\n\\n```\\nclass Solution {\\npublic:\\n    long long helper(int index,int p, vector<int>&nums,int x,vector<vector<long long>>&dp){\\n        int n= nums.size();\\n        if(index>=n) return 0;\\n        if(dp[index][p]!=-1) return dp[index][p];\\n        long long take=0;\\n        long long nottake=0;\\n        nottake= helper(index+1,p,nums,x,dp);\\n        if(nums[index]%2==p){\\n            take= nums[index]+helper(index+1,p,nums,x,dp);\\n        }\\n        else{\\n            take= nums[index]-x + helper(index+1,nums[index]%2,nums,x,dp);\\n        }\\n        return dp[index][p]= max(take,nottake);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n= nums.size();\\n        int p= nums[0]%2;\\n        vector<vector<long long>>dp(n+1,vector<long long>(2,-1));\\n        return nums[0]+ helper(1,p,nums,x,dp);\\n        \\n    }\\n};\\n```\\n**Please Upvote if u like my soln!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(int index,int p, vector<int>&nums,int x,vector<vector<long long>>&dp){\\n        int n= nums.size();\\n        if(index>=n) return 0;\\n        if(dp[index][p]!=-1) return dp[index][p];\\n        long long take=0;\\n        long long nottake=0;\\n        nottake= helper(index+1,p,nums,x,dp);\\n        if(nums[index]%2==p){\\n            take= nums[index]+helper(index+1,p,nums,x,dp);\\n        }\\n        else{\\n            take= nums[index]-x + helper(index+1,nums[index]%2,nums,x,dp);\\n        }\\n        return dp[index][p]= max(take,nottake);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n= nums.size();\\n        int p= nums[0]%2;\\n        vector<vector<long long>>dp(n+1,vector<long long>(2,-1));\\n        return nums[0]+ helper(1,p,nums,x,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801714,
                "title": "complete-intuition-approach-memoization-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nParities parities took a while to figure what parity meant in this case. Finally came to the conslusion parity means here simply x will be deducted if we move from an odd number to an even number and vice versa.\\n\\nNow since odd and even numbers are randomly located the only way to proceed is to try all possible pathways. So trying brute force and then try to do memoization.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow each pathway will start from nums[0] and move to the right (j>i always). Now we can reach any position in the nums array and we have two choices take the element or not take the element. If not taken simply go to the next position.\\n\\nIf taken then, we ahve 2 choices. Either the previous parity and current parity matches(both odd or both even) or they don\\'t (one odd, one even). For the second case we have to subtract x. \\n\\nReturn the maximum of the take and not take value.\\n\\nSince we are moving to right side only and are having repetitive structure we can use memoization.\\n\\n# Complexity\\n- Time complexity:- Time complexity: O(2N) = O(N)\\n- One dimension deals with the maximum value at that position and the other one for checking if the element at the aprent of that position is odd or even parity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2N) = O(N)\\n- Same as above.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long recur(vector<int>& nums,int pos,bool previsodd,int x,vector<vector<long>>&dp){\\n        if(pos>=nums.size())\\n            return 0;\\n        if(dp[pos][previsodd]!=-1)\\n            return dp[pos][previsodd];\\n        long take,nottake;\\n        if((previsodd && nums[pos]%2) || (previsodd==false && nums[pos]%2==0)){\\n            take=nums[pos]+recur(nums,pos+1,previsodd,x,dp);\\n        }\\n        else{\\n            take=nums[pos]-x+recur(nums,pos+1,!previsodd,x,dp);\\n        }\\n        nottake=recur(nums,pos+1,previsodd,x,dp);\\n        return dp[pos][previsodd]=max(take,nottake);\\n    }\\n    long long maxScore(vector<int>& nums, int x){\\n        vector<vector<long>>dp(nums.size(),vector<long>(2,-1));\\n        return nums[0]+recur(nums,1,nums[0]%2,x,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long recur(vector<int>& nums,int pos,bool previsodd,int x,vector<vector<long>>&dp){\\n        if(pos>=nums.size())\\n            return 0;\\n        if(dp[pos][previsodd]!=-1)\\n            return dp[pos][previsodd];\\n        long take,nottake;\\n        if((previsodd && nums[pos]%2) || (previsodd==false && nums[pos]%2==0)){\\n            take=nums[pos]+recur(nums,pos+1,previsodd,x,dp);\\n        }\\n        else{\\n            take=nums[pos]-x+recur(nums,pos+1,!previsodd,x,dp);\\n        }\\n        nottake=recur(nums,pos+1,previsodd,x,dp);\\n        return dp[pos][previsodd]=max(take,nottake);\\n    }\\n    long long maxScore(vector<int>& nums, int x){\\n        vector<vector<long>>dp(nums.size(),vector<long>(2,-1));\\n        return nums[0]+recur(nums,1,nums[0]%2,x,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820254,
                "title": "beats-100-c-python-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem requires maximizing the score by picking elements from the vector \\'nums\\' based on specific rules. We can do that by picking up all the elements one by one and checking if the element that we picked up increases or decreases the score. If it increases the score, then we take it; otherwise, we leave it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The main function `maxScore` initializes a few variables, including `p`, which represents the `parity` of the first element in the nums array`(0 for even and 1 for odd)`. It also creates a 2D memoization table,`dp`, to store previously computed results for subproblems.\\n\\n2. The function solve is a recursive helper function that takes several parameters :\\n- `nums`: The original vector of integers.\\n- `x`: The value to subtract from an odd number when choosing from the end.\\n- `i`: The current index in the nums vector.\\n- `p`: The parity of the last element chosen (0 for even and 1 for odd).\\n- `dp`: The memoization table.\\n- The base case of the recursion is when the index i goes beyond the bounds of the nums array. In such a scenario, the function returns 0, as there are no more elements to consider.\\n\\n3. Before performing any computations, the function checks if the result for the current `subproblem (i, p)` exists in the memoization table `dp`. If it does, the function directly returns the precomputed result, avoiding redundant calculations.\\n\\n1. The function proceeds to calculate the maximum score for two scenarios:\\n- `Picking` the current element at index `i` and updating `p` accordingly. The score will depend on whether `p` and the` parity of nums[i]` are the same or not.\\n- `Skipping` the current element and moving to the next index.\\nThe function recursively calls itself with updated parameters for both cases and stores the maximum of the two results.\\n\\nAfter the recursive computation, the function stores the result for the current `subproblem (i, p)` in the memoization table `dp`.\\n\\nFinally, the `maxScore` function calls `solve` with initial parameters to compute the maximum score, and then returns the maximum score plus the value of the first element (`nums[0]`) in the array. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2*n) =>$$ $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums, int x,int i,int p,vector<vector<long long>>& dp){\\n        if(i>nums.size()-1)\\n            return 0;\\n        \\n        if(dp[i][p]!=-1){\\n            return dp[i][p];\\n        }\\n        \\n        long long include,exculde;\\n        int y=nums[i]%2;\\n        if(p==y)\\n            include=nums[i]+solve(nums,x,i+1,y,dp);\\n        else\\n            include=nums[i]-x+solve(nums,x,i+1,y,dp);\\n        \\n        exculde=solve(nums,x,i+1,p,dp);\\n        \\n        return dp[i][p]=max(include,exculde);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int p=nums[0]%2;\\n        int n=nums.size();\\n       \\n        vector<vector<long long>> dp(n,vector<long long>(2,-1));\\n        return nums[0]+solve(nums,x,1,p,dp);\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def solve(self, nums, x, i, p, dp) -> int:\\n        if i > len(nums) - 1:\\n            return 0\\n\\n        if dp[i][p] != -1:\\n            return dp[i][p]\\n\\n        y = nums[i] % 2\\n        if p == y:\\n            include = nums[i] + self.solve(nums, x, i + 1, y, dp)\\n        else:\\n            include = nums[i] - x + self.solve(nums, x, i + 1, y, dp)\\n\\n        exculde = self.solve(nums, x, i + 1, p, dp)\\n\\n        dp[i][p] = max(include,exculde)\\n        return dp[i][p]\\n\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        p = nums[0] % 2\\n        n = len(nums)\\n        dp = [[-1 for _ in range(2)] for _ in range(n)]\\n        return nums[0] + self.solve(nums, x, 1, p, dp)\\n```\\n**If you have found my solution helpful, I would sincerely appreciate your Upvote.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C++ []\\n\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums, int x,int i,int p,vector<vector<long long>>& dp){\\n        if(i>nums.size()-1)\\n            return 0;\\n        \\n        if(dp[i][p]!=-1){\\n            return dp[i][p];\\n        }\\n        \\n        long long include,exculde;\\n        int y=nums[i]%2;\\n        if(p==y)\\n            include=nums[i]+solve(nums,x,i+1,y,dp);\\n        else\\n            include=nums[i]-x+solve(nums,x,i+1,y,dp);\\n        \\n        exculde=solve(nums,x,i+1,p,dp);\\n        \\n        return dp[i][p]=max(include,exculde);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int p=nums[0]%2;\\n        int n=nums.size();\\n       \\n        vector<vector<long long>> dp(n,vector<long long>(2,-1));\\n        return nums[0]+solve(nums,x,1,p,dp);\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def solve(self, nums, x, i, p, dp) -> int:\\n        if i > len(nums) - 1:\\n            return 0\\n\\n        if dp[i][p] != -1:\\n            return dp[i][p]\\n\\n        y = nums[i] % 2\\n        if p == y:\\n            include = nums[i] + self.solve(nums, x, i + 1, y, dp)\\n        else:\\n            include = nums[i] - x + self.solve(nums, x, i + 1, y, dp)\\n\\n        exculde = self.solve(nums, x, i + 1, p, dp)\\n\\n        dp[i][p] = max(include,exculde)\\n        return dp[i][p]\\n\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        p = nums[0] % 2\\n        n = len(nums)\\n        dp = [[-1 for _ in range(2)] for _ in range(n)]\\n        return nums[0] + self.solve(nums, x, 1, p, dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836583,
                "title": "c-o-n-memmoisation-tabulation",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Memoisation:**\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    ll int solve(vector<int>& nums, int idx, int parity, int x, vector<vector<ll int>> &memo){\\n        int n=nums.size();\\n        \\n        if(idx == n) return 0;\\n        \\n        if(memo[idx][parity] != -1) return memo[idx][parity];\\n        \\n        // skip\\n        ll int skip = solve(nums,idx+1,parity,x,memo);\\n        \\n        // acquire\\n        ll int acquire = nums[idx] - (nums[idx]%2 == parity ? 0:x) + solve(nums,idx+1,nums[idx]%2,x,memo);\\n        \\n        return memo[idx][parity] = max(skip, acquire);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<ll int>> memo(n,vector<ll int>(2,-1));\\n        \\n        return nums[0]+solve(nums,1,nums[0]%2, x, memo);\\n    }\\n};\\n```\\n\\n**Tabulation:**\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<ll int>> dp(n,vector<ll int>(2,0));\\n        \\n        int parity = nums[0] & 1;\\n        dp[0][parity] = nums[0];\\n        dp[0][parity^1] = nums[0]-x;\\n        \\n        ll int ans=dp[0][parity];\\n        \\n        for(int i=1;i<n;i++){\\n            parity = nums[i] & 1;\\n            \\n            // skip\\n            dp[i][parity] = dp[i-1][parity];\\n            dp[i][parity^1] = dp[i-1][parity^1];\\n            \\n            // acquire (from same parity or different)\\n            dp[i][parity] = max(dp[i][parity], max(dp[i-1][parity] + nums[i], dp[i-1][parity^1] + nums[i]-x));\\n            \\n            ans=max(ans, max(dp[i][parity], dp[i][parity^1]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    ll int solve(vector<int>& nums, int idx, int parity, int x, vector<vector<ll int>> &memo){\\n        int n=nums.size();\\n        \\n        if(idx == n) return 0;\\n        \\n        if(memo[idx][parity] != -1) return memo[idx][parity];\\n        \\n        // skip\\n        ll int skip = solve(nums,idx+1,parity,x,memo);\\n        \\n        // acquire\\n        ll int acquire = nums[idx] - (nums[idx]%2 == parity ? 0:x) + solve(nums,idx+1,nums[idx]%2,x,memo);\\n        \\n        return memo[idx][parity] = max(skip, acquire);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<ll int>> memo(n,vector<ll int>(2,-1));\\n        \\n        return nums[0]+solve(nums,1,nums[0]%2, x, memo);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<ll int>> dp(n,vector<ll int>(2,0));\\n        \\n        int parity = nums[0] & 1;\\n        dp[0][parity] = nums[0];\\n        dp[0][parity^1] = nums[0]-x;\\n        \\n        ll int ans=dp[0][parity];\\n        \\n        for(int i=1;i<n;i++){\\n            parity = nums[i] & 1;\\n            \\n            // skip\\n            dp[i][parity] = dp[i-1][parity];\\n            dp[i][parity^1] = dp[i-1][parity^1];\\n            \\n            // acquire (from same parity or different)\\n            dp[i][parity] = max(dp[i][parity], max(dp[i-1][parity] + nums[i], dp[i-1][parity^1] + nums[i]-x));\\n            \\n            ans=max(ans, max(dp[i][parity], dp[i][parity^1]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831480,
                "title": "python3-100-87-faster-beats-clean-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/831f7286-b669-4bd2-b529-10c52725d299_1690602680.2222533.png)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        dp = [0] * (length:=len(nums))\\n        dp[0] = nums[0]\\n\\n        even = nums[0] if (nums[0] % 2 == 0) else -inf\\n        odd = nums[0] if (nums[0] % 2 != 0) else -inf\\n\\n        for right in range(1,length):\\n            if (cur:=nums[right]) %2 == 0:\\n                dp[right] = max(even,odd-x)+cur\\n                even = dp[right]\\n            else:\\n                dp[right] = max(even-x,odd)+cur\\n                odd = dp[right]\\n\\n        return max(odd,even)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        dp = [0] * (length:=len(nums))\\n        dp[0] = nums[0]\\n\\n        even = nums[0] if (nums[0] % 2 == 0) else -inf\\n        odd = nums[0] if (nums[0] % 2 != 0) else -inf\\n\\n        for right in range(1,length):\\n            if (cur:=nums[right]) %2 == 0:\\n                dp[right] = max(even,odd-x)+cur\\n                even = dp[right]\\n            else:\\n                dp[right] = max(even-x,odd)+cur\\n                odd = dp[right]\\n\\n        return max(odd,even)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818421,
                "title": "dynamic-programming-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n\\n        n = len(nums)\\n        pts = [i for i in nums]\\n\\n        om,em = 0,0\\n\\n        for i in range(n-1,-1,-1):\\n            if i == n-1:\\n                pass\\n            else:\\n                if nums[i] % 2 == 0:\\n                    pts[i] = max(nums[i], nums[i] + em, nums[i] + om - x)\\n                else:\\n                    pts[i] = max(nums[i], nums[i] + em - x, nums[i] + om)\\n\\n            if nums[i] % 2 == 0:\\n                em = max(em, pts[i])\\n            else:\\n                om = max(om, pts[i])\\n\\n        #print(pts)\\n        return pts[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n\\n        n = len(nums)\\n        pts = [i for i in nums]\\n\\n        om,em = 0,0\\n\\n        for i in range(n-1,-1,-1):\\n            if i == n-1:\\n                pass\\n            else:\\n                if nums[i] % 2 == 0:\\n                    pts[i] = max(nums[i], nums[i] + em, nums[i] + om - x)\\n                else:\\n                    pts[i] = max(nums[i], nums[i] + em - x, nums[i] + om)\\n\\n            if nums[i] % 2 == 0:\\n                em = max(em, pts[i])\\n            else:\\n                om = max(om, pts[i])\\n\\n        #print(pts)\\n        return pts[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802495,
                "title": "c-sipmple-logic",
                "content": "# Approach\\nLogic: \\n-> Club togther all the even and odd consecutive numbers.\\n-> In Dp function: if you jump two indexes, you\\'ll get the same parity number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parity(int n) {\\n       if ((n %2) == 0) {\\n          return true;\\n       }\\n       return false;\\n    }\\n    long long helper(int index, vector<long long>& temp, vector<long long>& dp,int x){\\n        if(index>=temp.size())return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        long long ans = max(temp[index]+helper(index+1,temp,dp,x)-x,temp[index]+helper(index+2,temp,dp,x));\\n        return dp[index]=ans;\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<long long> temp;\\n        long long curr=0;\\n        for(int i = 0; i<nums.size(); i++){\\n            bool h = parity(nums[i]);\\n            curr+=nums[i];\\n            i++;\\n            while(i<(int)nums.size()&&parity(nums[i])==h){\\n                curr+=nums[i];\\n                i++;\\n            }\\n            i--;\\n            temp.push_back(curr);\\n            curr=0;\\n        }\\n        vector<long long> dp(temp.size(),-1);\\n        return helper(0,temp,dp,x);\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parity(int n) {\\n       if ((n %2) == 0) {\\n          return true;\\n       }\\n       return false;\\n    }\\n    long long helper(int index, vector<long long>& temp, vector<long long>& dp,int x){\\n        if(index>=temp.size())return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        long long ans = max(temp[index]+helper(index+1,temp,dp,x)-x,temp[index]+helper(index+2,temp,dp,x));\\n        return dp[index]=ans;\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<long long> temp;\\n        long long curr=0;\\n        for(int i = 0; i<nums.size(); i++){\\n            bool h = parity(nums[i]);\\n            curr+=nums[i];\\n            i++;\\n            while(i<(int)nums.size()&&parity(nums[i])==h){\\n                curr+=nums[i];\\n                i++;\\n            }\\n            i--;\\n            temp.push_back(curr);\\n            curr=0;\\n        }\\n        vector<long long> dp(temp.size(),-1);\\n        return helper(0,temp,dp,x);\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801914,
                "title": "simple-brute-force-pick-not-pick-dp-memoization",
                "content": "\\n**<<<<<UpVote**\\n\\n**Parity is basically comparing two numbers if they both are even or odd**\\n\\n```\\nclass Solution {\\npublic:\\n    long long helper(vector<int>&nums,int x,int oe,int index,vector<vector<long long>> &dp){\\n        if(nums.size()==index) return 0;\\n        if(dp[index][oe]!=-1) return dp[index][oe];\\n        long long pick=0,notpick=0;\\n        if(oe==nums[index]%2){\\n            pick=nums[index]+helper(nums,x,oe,index+1,dp);\\n        }\\n        else{\\n            pick=nums[index]-x+helper(nums,x,nums[index]%2,index+1,dp);\\n        }\\n        notpick=helper(nums,x,oe,index+1,dp);\\n        return dp[index][oe]=max(pick,notpick);\\n        \\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size(),vector<long long>(2,-1));\\n        int oe;\\n        oe=nums[0]%2==0?0:1;\\n        return helper(nums,x,oe,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(vector<int>&nums,int x,int oe,int index,vector<vector<long long>> &dp){\\n        if(nums.size()==index) return 0;\\n        if(dp[index][oe]!=-1) return dp[index][oe];\\n        long long pick=0,notpick=0;\\n        if(oe==nums[index]%2){\\n            pick=nums[index]+helper(nums,x,oe,index+1,dp);\\n        }\\n        else{\\n            pick=nums[index]-x+helper(nums,x,nums[index]%2,index+1,dp);\\n        }\\n        notpick=helper(nums,x,oe,index+1,dp);\\n        return dp[index][oe]=max(pick,notpick);\\n        \\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size(),vector<long long>(2,-1));\\n        int oe;\\n        oe=nums[0]%2==0?0:1;\\n        return helper(nums,x,oe,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801784,
                "title": "easy-clean-best-dp-code-memoization",
                "content": "### Connect with me on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Intuition\\n## Parity means LSB of a number so if two nos have different parities that means if one of them is odd then other has to be even\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## Please Upvote if u found my Solution useful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long dp[100001][2];\\n    long helper(int ind, int n, vector<int>& nums, int x, bool ch){\\n        if(ind == n){\\n            return 0;\\n        }\\n        if(dp[ind][ch] != -1)\\n            return dp[ind][ch];\\n        long maxi = 0;         \\n        bool c = (nums[ind] & 1) ? false : true;   //if nums[ind] is odd then c will be false & if it is even then c will be true\\n        if(c == ch){\\n            maxi = max(maxi,nums[ind] + helper(ind+1,n,nums,x,c));\\n        }\\n        else{\\n            maxi = max(maxi,(nums[ind] - x) + helper(ind+1,n,nums,x,c));\\n            maxi = max(maxi,helper(ind+1,n,nums,x,ch));\\n        }\\n        return dp[ind][ch] = maxi;\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        bool ch = false;\\n        if(!(nums[0] & 1))\\n            ch = true;\\n        memset(dp,-1,sizeof(dp));\\n        return helper(1,n,nums,x,ch) + nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long dp[100001][2];\\n    long helper(int ind, int n, vector<int>& nums, int x, bool ch){\\n        if(ind == n){\\n            return 0;\\n        }\\n        if(dp[ind][ch] != -1)\\n            return dp[ind][ch];\\n        long maxi = 0;         \\n        bool c = (nums[ind] & 1) ? false : true;   //if nums[ind] is odd then c will be false & if it is even then c will be true\\n        if(c == ch){\\n            maxi = max(maxi,nums[ind] + helper(ind+1,n,nums,x,c));\\n        }\\n        else{\\n            maxi = max(maxi,(nums[ind] - x) + helper(ind+1,n,nums,x,c));\\n            maxi = max(maxi,helper(ind+1,n,nums,x,ch));\\n        }\\n        return dp[ind][ch] = maxi;\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        bool ch = false;\\n        if(!(nums[0] & 1))\\n            ch = true;\\n        memset(dp,-1,sizeof(dp));\\n        return helper(1,n,nums,x,ch) + nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801756,
                "title": "0-1-knapsack-dp-memoization-java-clean-code",
                "content": "# Approach\\nSubsequence problem can be solved using pick not pick approach\\n\\n# Complexity\\n- Time complexity: $$O(n * 2)$$ (Recursion)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * 2)$$ (DP) + $$O(n)$$ (Stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private Long[][] dp;\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        dp = new Long[n][2];\\n        return nums[0] + solve(1, isOdd(nums[0]), n, x, nums);\\n    }\\n    \\n    private long solve(int idx, boolean prevParity, int n, int x, int[] nums) {\\n        if(idx == n) return 0;\\n        if(dp[idx][prevParity ? 1 : 0] != null) return dp[idx][prevParity ? 1 : 0];\\n        long notPick = solve(idx + 1, prevParity, n, x, nums);\\n        boolean curParity = isOdd(nums[idx]);\\n        long pick = nums[idx] + solve(idx + 1, curParity, n, x, nums) - (curParity == prevParity ? 0 : x);\\n        return dp[idx][prevParity ? 1 : 0] = Math.max(pick, notPick);\\n    }\\n    \\n    private boolean isOdd(int n) {\\n        return (n & 1) == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private Long[][] dp;\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        dp = new Long[n][2];\\n        return nums[0] + solve(1, isOdd(nums[0]), n, x, nums);\\n    }\\n    \\n    private long solve(int idx, boolean prevParity, int n, int x, int[] nums) {\\n        if(idx == n) return 0;\\n        if(dp[idx][prevParity ? 1 : 0] != null) return dp[idx][prevParity ? 1 : 0];\\n        long notPick = solve(idx + 1, prevParity, n, x, nums);\\n        boolean curParity = isOdd(nums[idx]);\\n        long pick = nums[idx] + solve(idx + 1, curParity, n, x, nums) - (curParity == prevParity ? 0 : x);\\n        return dp[idx][prevParity ? 1 : 0] = Math.max(pick, notPick);\\n    }\\n    \\n    private boolean isOdd(int n) {\\n        return (n & 1) == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804417,
                "title": "python-3-6-lines-recursion-t-m-2145-ms-390-mb",
                "content": "```\\nclass Solution:\\n    def maxScore(self, nums, x):\\n        \\n        @lru_cache(None)\\n        def dfs(i,oldPar):\\n            \\n            if i >= len(nums): return 0\\n\\n            newPar = nums[i]%2\\n\\n            return max(dfs(i+1,oldPar),\\n                       nums[i] + dfs(i+1,newPar)\\n                         - x*(newPar != oldPar))\\n        \\n        return dfs(0,nums[0]%2)\\n```\\n[https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001385584/?submissionId=1001386715](http://)\\n\\n\\nI could be wrong, but I think that time complexity is (worst case) *O*(2^*N*) and space complexity is *O*(*N*), in which *N* ~ `len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums, x):\\n        \\n        @lru_cache(None)\\n        def dfs(i,oldPar):\\n            \\n            if i >= len(nums): return 0\\n\\n            newPar = nums[i]%2\\n\\n            return max(dfs(i+1,oldPar),\\n                       nums[i] + dfs(i+1,newPar)\\n                         - x*(newPar != oldPar))\\n        \\n        return dfs(0,nums[0]%2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803311,
                "title": "video-beats-100-skyrocket-your-coding-skills-mastering",
                "content": "# Intuition\\nThis problem is a perfect example of a dynamic programming problem where the state of the system can be described by two variables: the score we would get if we were to pick the next number and it was odd, and the score we would get if it were even. Our goal is to maximize our score, so we need to carefully decide whether to pick the next number based on its parity and the potential score.\\n\\nhttps://youtu.be/jLnWQe4Hzps\\n\\n# Approach\\nWe start by initializing `even_score` and `odd_score` to the score of the first number, accounting for the cost \\'x\\' if necessary. Then, for each number in the array, we update the corresponding score based on its parity. If the number is odd, we update `odd_score` by adding the current number and the maximum of `odd_score` and `even_score - x`. If it\\'s even, we update `even_score` similarly. Finally, we return the maximum of `even_score` and `odd_score` as the maximum total score we can get.\\n\\n# Complexity\\n- Time complexity: \\\\(O(n)\\\\) \\nWe simply iterate over the array once, where \\'n\\' is the length of the array.\\n\\n- Space complexity: \\\\(O(1)\\\\) \\nWe only use a constant amount of space to store the scores for odd and even numbers.\\n\\nIn this problem, dynamic programming helps us keep track of the maximum score we could get if the next number we pick is odd or even. With this approach, we\\'re able to find the maximum score in a highly efficient manner. Keep practicing such problems to get a solid grasp on dynamic programming! Happy coding! \\uD83D\\uDE80\\n\\n# Code\\n```Python []\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        even_score = nums[0] - (x if nums[0] % 2 else 0)\\n        odd_score = nums[0] - (0 if nums[0] % 2 else x)\\n        for i in range(1, len(nums)):\\n            if nums[i] % 2:\\n                odd_score, even_score = nums[i] + max(odd_score, even_score - x), even_score\\n            else:\\n                odd_score, even_score = odd_score, nums[i] + max(even_score, odd_score - x)\\n        return max(even_score, odd_score)\\n```\\n``` JavaScript []\\nvar maxScore = function(nums, x) {\\n    let even_score = nums[0] - (nums[0] % 2 === 0 ? 0 : x);\\n    let odd_score = nums[0] - (nums[0] % 2 === 0 ? x : 0);\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] % 2 === 0) {\\n            even_score = nums[i] + Math.max(even_score, odd_score - x);\\n        } else {\\n            odd_score = nums[i] + Math.max(odd_score, even_score - x);\\n        }\\n    }\\n    return Math.max(even_score, odd_score);\\n};\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long even_score = nums[0] - (nums[0] % 2 ? x : 0LL);\\n        long long odd_score = nums[0] - (nums[0] % 2 ? 0 : x);\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] % 2)\\n                odd_score = nums[i] + max(odd_score, even_score - x);\\n            else\\n                even_score = nums[i] + max(even_score, odd_score - x);\\n        }\\n        return max(even_score, odd_score);\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long even_score = nums[0] - (nums[0] % 2 == 0 ? 0 : (long)x);\\n        long odd_score = nums[0] - (nums[0] % 2 == 0 ? (long)x : 0);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                even_score = nums[i] + Math.max(even_score, odd_score - x);\\n            } else {\\n                odd_score = nums[i] + Math.max(odd_score, even_score - x);\\n            }\\n        }\\n        return Math.max(even_score, odd_score);\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public long MaxScore(int[] nums, int x) {\\n        long even_score = nums[0] - (nums[0] % 2 == 0 ? 0 : (long)x);\\n        long odd_score = nums[0] - (nums[0] % 2 == 0 ? (long)x : 0);\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                even_score = nums[i] + Math.Max(even_score, odd_score - x);\\n            } else {\\n                odd_score = nums[i] + Math.Max(odd_score, even_score - x);\\n            }\\n        }\\n        return Math.Max(even_score, odd_score);\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        even_score = nums[0] - (x if nums[0] % 2 else 0)\\n        odd_score = nums[0] - (0 if nums[0] % 2 else x)\\n        for i in range(1, len(nums)):\\n            if nums[i] % 2:\\n                odd_score, even_score = nums[i] + max(odd_score, even_score - x), even_score\\n            else:\\n                odd_score, even_score = odd_score, nums[i] + max(even_score, odd_score - x)\\n        return max(even_score, odd_score)\\n```\n``` JavaScript []\\nvar maxScore = function(nums, x) {\\n    let even_score = nums[0] - (nums[0] % 2 === 0 ? 0 : x);\\n    let odd_score = nums[0] - (nums[0] % 2 === 0 ? x : 0);\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] % 2 === 0) {\\n            even_score = nums[i] + Math.max(even_score, odd_score - x);\\n        } else {\\n            odd_score = nums[i] + Math.max(odd_score, even_score - x);\\n        }\\n    }\\n    return Math.max(even_score, odd_score);\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long even_score = nums[0] - (nums[0] % 2 ? x : 0LL);\\n        long long odd_score = nums[0] - (nums[0] % 2 ? 0 : x);\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] % 2)\\n                odd_score = nums[i] + max(odd_score, even_score - x);\\n            else\\n                even_score = nums[i] + max(even_score, odd_score - x);\\n        }\\n        return max(even_score, odd_score);\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long even_score = nums[0] - (nums[0] % 2 == 0 ? 0 : (long)x);\\n        long odd_score = nums[0] - (nums[0] % 2 == 0 ? (long)x : 0);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                even_score = nums[i] + Math.max(even_score, odd_score - x);\\n            } else {\\n                odd_score = nums[i] + Math.max(odd_score, even_score - x);\\n            }\\n        }\\n        return Math.max(even_score, odd_score);\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public long MaxScore(int[] nums, int x) {\\n        long even_score = nums[0] - (nums[0] % 2 == 0 ? 0 : (long)x);\\n        long odd_score = nums[0] - (nums[0] % 2 == 0 ? (long)x : 0);\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                even_score = nums[i] + Math.Max(even_score, odd_score - x);\\n            } else {\\n                odd_score = nums[i] + Math.Max(odd_score, even_score - x);\\n            }\\n        }\\n        return Math.Max(even_score, odd_score);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802547,
                "title": "c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBefore choosing an element `nums[i]`, all we need to know is, what is `the maximum score` before `index i`. For this we can use **Dynamic Programming**.\\n\\nFor every element `nums[i]`, we have two choices:\\n1. **Take `nums[i]`:** While taking the element, there can be two cases. The maximum score can come from odd parity or the even parity of the previous index. Also the parity changes to `nums[i] & 1`.\\n2. **Skip `nums[i]`:** The parity remains the same.\\n\\n---\\n\\n### Solving a smaller subproblem first\\n`x = 6`, `nums = [3, 2]`\\n\\nIn the following table, let\\'s concentrate on  `element 2` at `index 1` for now. We\\'ll dive into the scores of 3 a bit later (base cases).\\n\\n| ``nums``        | 3  | 2                             |\\n|-----------------|----|-------------------------------|\\n| 0 (even parity) | -4 | score: `max(2 + (-4), 2 + 3 - 6) = -1` |\\n| 1 (odd parity)  | 3  | score: `3`                    |\\n\\n### Observations:\\n- When we take $2$, it is in the even parity. The score changed in two ways: from the even parity of the previous index, $2 + dp[i - 1][0]$ and from the odd parity which will include $x=6$ score deduction, $2 + dp[i - 1][1] - 6$.\\n- When we skip $2$, the parity doesn\\'t change. So we\\'re still in the odd parity and the score will settle from $dp[i - 1][1]$.\\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### State\\n`dp[i][parity]` states the maximum score upto *index i* for the respective even-odd parity.\\n\\n### Transitions\\n- take:\\n    sameParity `dp[i - 1][parity] + nums[i]`\\n    changingParity `dp[i - 1][parity ^ 1] + nums[i] - x`\\n`dp[i][parity] = max(sameParity, changingParity)`\\n- skip: `dp[i][parity ^ 1] = dp[i - 1][parity ^ 1]`\\n\\n### Base Cases\\n- `dp[0][parity] = nums[0]`\\n- `dp[0][parity ^ 1] = nums[0] - x`\\n\\n### Final Subproblem\\n- `max(dp)`\\n\\n---\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long> (2, 0));\\n        \\n        bool parity = nums[0] & 1;\\n        dp[0][parity] = nums[0];\\n        dp[0][parity ^ 1] = nums[0] - x;\\n\\n        for (int i = 1; i < n; i++) {\\n            bool parity = nums[i] & 1;\\n            long long takeSame = dp[i - 1][parity] + nums[i];\\n            long long takeDiff = dp[i - 1][parity ^ 1] + nums[i] - x;\\n            dp[i][parity] = max(takeSame, takeDiff);\\n            dp[i][parity ^ 1] = dp[i - 1][parity ^ 1];\\n        }\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = max({ans, dp[i][0], dp[i][1]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long> (2, 0));\\n        \\n        bool parity = nums[0] & 1;\\n        dp[0][parity] = nums[0];\\n        dp[0][parity ^ 1] = nums[0] - x;\\n\\n        for (int i = 1; i < n; i++) {\\n            bool parity = nums[i] & 1;\\n            long long takeSame = dp[i - 1][parity] + nums[i];\\n            long long takeDiff = dp[i - 1][parity ^ 1] + nums[i] - x;\\n            dp[i][parity] = max(takeSame, takeDiff);\\n            dp[i][parity ^ 1] = dp[i - 1][parity ^ 1];\\n        }\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = max({ans, dp[i][0], dp[i][1]});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801701,
                "title": "tabulation-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& numbersOfArray, int penalty) {\\n        long long size = numbersOfArray.size();\\n        long long table[size][2];\\n        table[0][1] = numbersOfArray[0];\\n        table[0][0] = numbersOfArray[0];\\n        \\n        int parity = numbersOfArray[0] % 2;\\n        if (parity == 1) {\\n            table[0][0] -= penalty;\\n        } else {\\n            table[0][1] -= penalty;\\n        }\\n        for (int i = 1; i < size; i++) {\\n            long long remainder = numbersOfArray[i];\\n            if (remainder % 2 != 0) {\\n                table[i][1] = max(table[i-1][1] + numbersOfArray[i], table[i-1][0] + numbersOfArray[i] - penalty);\\n                table[i][0] = table[i-1][0];\\n            }  else {   \\n                table[i][0] = max(table[i-1][0] + numbersOfArray[i], table[i-1][1] + numbersOfArray[i] - penalty);\\n                table[i][1] = table[i-1][1];\\n            }\\n        }\\n        long long uttr=max(table[size-1][0], table[size-1][1]);\\n        return uttr;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& numbersOfArray, int penalty) {\\n        long long size = numbersOfArray.size();\\n        long long table[size][2];\\n        table[0][1] = numbersOfArray[0];\\n        table[0][0] = numbersOfArray[0];\\n        \\n        int parity = numbersOfArray[0] % 2;\\n        if (parity == 1) {\\n            table[0][0] -= penalty;\\n        } else {\\n            table[0][1] -= penalty;\\n        }\\n        for (int i = 1; i < size; i++) {\\n            long long remainder = numbersOfArray[i];\\n            if (remainder % 2 != 0) {\\n                table[i][1] = max(table[i-1][1] + numbersOfArray[i], table[i-1][0] + numbersOfArray[i] - penalty);\\n                table[i][0] = table[i-1][0];\\n            }  else {   \\n                table[i][0] = max(table[i-1][0] + numbersOfArray[i], table[i-1][1] + numbersOfArray[i] - penalty);\\n                table[i][1] = table[i-1][1];\\n            }\\n        }\\n        long long uttr=max(table[size-1][0], table[size-1][1]);\\n        return uttr;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801689,
                "title": "c-easy-dp-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long> dp={0,0};\\n        long long ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int temp = nums[i]%2;\\n            long long t = dp[temp]+nums[i];  // taking parity elements\\n            long long nt = dp[1-temp]-x+nums[i]; // taking non parity elements\\n            ans = max(t,nt);  \\n            dp[temp] = max(dp[temp],ans);  // updating parity dp\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long> dp={0,0};\\n        long long ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int temp = nums[i]%2;\\n            long long t = dp[temp]+nums[i];  // taking parity elements\\n            long long nt = dp[1-temp]-x+nums[i]; // taking non parity elements\\n            ans = max(t,nt);  \\n            dp[temp] = max(dp[temp],ans);  // updating parity dp\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853080,
                "title": "two-different-approaches-for-better-understanding",
                "content": "We declare two vars evenEnd and oddEnd. \\nAt any nums[i], if it is even we can find the new evenEnd by taking the max of last evenEnd + nums[i] or last oddEnd + nums[i] - x\\nSame we can also do for if the number is odd. \\nWe will initialize the evenEnd and oddEnd based on if nums[0] is even or odd. \\nFor reference: https://www.youtube.com/watch?v=pvz4qKwBySc(Not my video)\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        oddEnd, evenEnd = 0, 0\\n        if nums[0]%2 == 0:\\n            evenEnd = nums[0]\\n            oddEnd = nums[0]-x\\n        else:\\n            oddEnd = nums[0]\\n            evenEnd = nums[0]-x\\n        \\n        ans = 0\\n        for i in range(1, len(nums)):\\n            if nums[i]%2 == 0:\\n                evenEnd = max(evenEnd + nums[i], oddEnd + nums[i] - x)\\n            else:\\n                oddEnd = max(oddEnd + nums[i], evenEnd + nums[i] - x)\\n            ans = max(evenEnd, oddEnd)\\n    \\n        return ans\\n```\\n\\n\\nWe can use Backtracking and DP to solve this problem\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        def backtrack(i, prev):\\n            if i >= len(nums):\\n                return 0 \\n            take1, take2 = 0, 0\\n            if prev%2 == nums[i]%2:\\n                take = backtrack(i+1, nums[i]) + nums[i]\\n            else:\\n                take = backtrack(i+1, nums[i]) + nums[i]-x\\n            dontTake = backtrack(i+1, prev)\\n            return max(take, dontTake)\\n        \\n        return backtrack(1, nums[0]) + nums[0]\\n```    \\n\\nWith DP(Memoization):\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        memo = {}\\n        def backtrack(i, prev):\\n            if (i, prev) in memo:\\n                return memo[(i, prev)]\\n            \\n            if i >= len(nums):\\n                return 0 \\n            take1, take2 = 0, 0\\n            if prev%2 == nums[i]%2:\\n                take = backtrack(i+1, nums[i]) + nums[i]\\n            else:\\n                take = backtrack(i+1, nums[i]) + nums[i]-x\\n            dontTake = backtrack(i+1, prev)\\n            memo[(i, prev)] = max(take, dontTake)\\n            return max(take, dontTake)\\n        \\n        return backtrack(1, nums[0]) + nums[0]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        oddEnd, evenEnd = 0, 0\\n        if nums[0]%2 == 0:\\n            evenEnd = nums[0]\\n            oddEnd = nums[0]-x\\n        else:\\n            oddEnd = nums[0]\\n            evenEnd = nums[0]-x\\n        \\n        ans = 0\\n        for i in range(1, len(nums)):\\n            if nums[i]%2 == 0:\\n                evenEnd = max(evenEnd + nums[i], oddEnd + nums[i] - x)\\n            else:\\n                oddEnd = max(oddEnd + nums[i], evenEnd + nums[i] - x)\\n            ans = max(evenEnd, oddEnd)\\n    \\n        return ans\\n```\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        def backtrack(i, prev):\\n            if i >= len(nums):\\n                return 0 \\n            take1, take2 = 0, 0\\n            if prev%2 == nums[i]%2:\\n                take = backtrack(i+1, nums[i]) + nums[i]\\n            else:\\n                take = backtrack(i+1, nums[i]) + nums[i]-x\\n            dontTake = backtrack(i+1, prev)\\n            return max(take, dontTake)\\n        \\n        return backtrack(1, nums[0]) + nums[0]\\n```\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        memo = {}\\n        def backtrack(i, prev):\\n            if (i, prev) in memo:\\n                return memo[(i, prev)]\\n            \\n            if i >= len(nums):\\n                return 0 \\n            take1, take2 = 0, 0\\n            if prev%2 == nums[i]%2:\\n                take = backtrack(i+1, nums[i]) + nums[i]\\n            else:\\n                take = backtrack(i+1, nums[i]) + nums[i]-x\\n            dontTake = backtrack(i+1, prev)\\n            memo[(i, prev)] = max(take, dontTake)\\n            return max(take, dontTake)\\n        \\n        return backtrack(1, nums[0]) + nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808964,
                "title": "c-solution",
                "content": "# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code 1\\n```\\nclass Solution {\\npublic:\\n    long long dp[100005][2];\\n    vector<int> nums;\\n    int xs;\\n\\n    long long solve(int pos, bool prevIsOdd) {\\n        if (pos == nums.size()) return 0;\\n        if (dp[pos][prevIsOdd] != -1) return dp[pos][prevIsOdd];\\n        long long take, notTake;\\n        if ((prevIsOdd && nums[pos] % 2) || (prevIsOdd == false && nums[pos] % 2 == 0)) {\\n            take = nums[pos] + solve(pos + 1, prevIsOdd);\\n        }\\n        else {\\n            take = nums[pos] - xs + solve(pos + 1, !prevIsOdd);\\n        }\\n        notTake = solve(pos+1, prevIsOdd);\\n        return dp[pos][prevIsOdd] = max(take, notTake);\\n    }\\n\\n    long long maxScore(vector<int>& num, int x) {\\n        nums = num;\\n        xs = x;\\n        memset(dp, -1, sizeof dp);\\n        return nums[0] + solve(1, nums[0] % 2);\\n    }\\n};\\n```\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n    Iterative DP\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long dp[2] = {-x, -x}, n = nums.size();\\n        dp[nums[0] & 1] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            dp[nums[i] & 1] = max(dp[nums[i] & 1], dp[nums[i] & 1 ^ 1] - x) + nums[i];\\n        return max(dp[0], dp[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100005][2];\\n    vector<int> nums;\\n    int xs;\\n\\n    long long solve(int pos, bool prevIsOdd) {\\n        if (pos == nums.size()) return 0;\\n        if (dp[pos][prevIsOdd] != -1) return dp[pos][prevIsOdd];\\n        long long take, notTake;\\n        if ((prevIsOdd && nums[pos] % 2) || (prevIsOdd == false && nums[pos] % 2 == 0)) {\\n            take = nums[pos] + solve(pos + 1, prevIsOdd);\\n        }\\n        else {\\n            take = nums[pos] - xs + solve(pos + 1, !prevIsOdd);\\n        }\\n        notTake = solve(pos+1, prevIsOdd);\\n        return dp[pos][prevIsOdd] = max(take, notTake);\\n    }\\n\\n    long long maxScore(vector<int>& num, int x) {\\n        nums = num;\\n        xs = x;\\n        memset(dp, -1, sizeof dp);\\n        return nums[0] + solve(1, nums[0] % 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long dp[2] = {-x, -x}, n = nums.size();\\n        dp[nums[0] & 1] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            dp[nums[i] & 1] = max(dp[nums[i] & 1], dp[nums[i] & 1 ^ 1] - x) + nums[i];\\n        return max(dp[0], dp[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804919,
                "title": "python3-memorization-with-comments-dp-third-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        #defining memorization\\n        memo = {}\\n        def dp(i,prev):\\n            #if the curr index is greater then or equal to the length of the array return 0\\n            if i >= len(nums):\\n                return 0\\n\\n            #if previously computed then return the precomputed result\\n            elif (i,prev) in memo:\\n                return memo[(i,prev)]\\n            else:\\n                #if parities is equal\\n                if prev==nums[i]%2:\\n                    left = dp(i+1,nums[i]%2)+nums[i]\\n                #if parities is not equal\\n                else:\\n                    left = dp(i+1,nums[i]%2)+nums[i]-x\\n\\n                #if not consider the current index\\n                memo[(i,prev)] = max(left,dp(i+1,prev))\\n                return memo[(i,prev)]\\n\\n        return dp(1,nums[0]%2) +nums[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        #defining memorization\\n        memo = {}\\n        def dp(i,prev):\\n            #if the curr index is greater then or equal to the length of the array return 0\\n            if i >= len(nums):\\n                return 0\\n\\n            #if previously computed then return the precomputed result\\n            elif (i,prev) in memo:\\n                return memo[(i,prev)]\\n            else:\\n                #if parities is equal\\n                if prev==nums[i]%2:\\n                    left = dp(i+1,nums[i]%2)+nums[i]\\n                #if parities is not equal\\n                else:\\n                    left = dp(i+1,nums[i]%2)+nums[i]-x\\n\\n                #if not consider the current index\\n                memo[(i,prev)] = max(left,dp(i+1,prev))\\n                return memo[(i,prev)]\\n\\n        return dp(1,nums[0]%2) +nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803682,
                "title": "easy-to-understand-implementation-using-dp-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long dp[100004][2];\\n    \\n    long long solve(int i, int par, vector<int>& nums, int x){\\n        if(i>=nums.size()) return 0;\\n        \\n        if(dp[i][par] != -1) return dp[i][par];\\n        \\n        long long skip = solve(i+1,par,nums,x);\\n        \\n        long long consider = 0;\\n        \\n        if(nums[i] % 2 == par) consider = nums[i] + solve(i+1,par,nums,x);\\n        else{\\n            int npar = 0;\\n            if(par == 0) npar = 1;\\n \\n            consider = -x + nums[i] + solve(i+1,npar,nums,x);\\n        } \\n\\n        return dp[i][par] = max(skip,consider);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(dp,-1,sizeof(dp));\\n        int par = nums[0]%2;\\n        return nums[0] + solve(1,par,nums,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long dp[100004][2];\\n    \\n    long long solve(int i, int par, vector<int>& nums, int x){\\n        if(i>=nums.size()) return 0;\\n        \\n        if(dp[i][par] != -1) return dp[i][par];\\n        \\n        long long skip = solve(i+1,par,nums,x);\\n        \\n        long long consider = 0;\\n        \\n        if(nums[i] % 2 == par) consider = nums[i] + solve(i+1,par,nums,x);\\n        else{\\n            int npar = 0;\\n            if(par == 0) npar = 1;\\n \\n            consider = -x + nums[i] + solve(i+1,npar,nums,x);\\n        } \\n\\n        return dp[i][par] = max(skip,consider);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(dp,-1,sizeof(dp));\\n        int par = nums[0]%2;\\n        return nums[0] + solve(1,par,nums,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802445,
                "title": "easy-solution-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long help(int i,vector<int>&n,int a,int b,vector<vector<long long>>&dp)\\n    {\\n        if(i==n.size()) return 0;\\n        if(dp[i][b+1]!=-1) return dp[i][b+1];\\n        long long c=0;\\n        if(b==-1)\\n        {\\n            c= n[i]+help(i+1,n,a,n[i]%2,dp);\\n        }\\n        if(b==0)\\n        {\\n            if(n[i]%2==0)\\n            c= max(help(i+1,n,a,b,dp),n[i]+help(i+1,n,a,n[i]%2,dp));\\n            else\\n            c= max(help(i+1,n,a,b,dp),n[i]-a+help(i+1,n,a,n[i]%2,dp));\\n        }\\n        if(b==1)\\n        {\\n            if(n[i]%2==1)\\n            c= max(help(i+1,n,a,b,dp),n[i]+help(i+1,n,a,n[i]%2,dp));\\n            else\\n            c= max(help(i+1,n,a,b,dp),n[i]-a+help(i+1,n,a,n[i]%2,dp));\\n        }\\n        return dp[i][b+1]=c;\\n    }\\n    \\n    long long maxScore(vector<int>& n, int a) {\\n        vector<vector<long long>> dp(n.size(),vector<long long>(3,-1));\\n        return help(0,n,a,-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long help(int i,vector<int>&n,int a,int b,vector<vector<long long>>&dp)\\n    {\\n        if(i==n.size()) return 0;\\n        if(dp[i][b+1]!=-1) return dp[i][b+1];\\n        long long c=0;\\n        if(b==-1)\\n        {\\n            c= n[i]+help(i+1,n,a,n[i]%2,dp);\\n        }\\n        if(b==0)\\n        {\\n            if(n[i]%2==0)\\n            c= max(help(i+1,n,a,b,dp),n[i]+help(i+1,n,a,n[i]%2,dp));\\n            else\\n            c= max(help(i+1,n,a,b,dp),n[i]-a+help(i+1,n,a,n[i]%2,dp));\\n        }\\n        if(b==1)\\n        {\\n            if(n[i]%2==1)\\n            c= max(help(i+1,n,a,b,dp),n[i]+help(i+1,n,a,n[i]%2,dp));\\n            else\\n            c= max(help(i+1,n,a,b,dp),n[i]-a+help(i+1,n,a,n[i]%2,dp));\\n        }\\n        return dp[i][b+1]=c;\\n    }\\n    \\n    long long maxScore(vector<int>& n, int a) {\\n        vector<vector<long long>> dp(n.size(),vector<long long>(3,-1));\\n        return help(0,n,a,-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801875,
                "title": "simple-and-easy-to-undersatnd-recursive-java-solution-in-o-n-time",
                "content": "# Intuition\\nPick not pick recursive approach can be used as we have choice to jump to a particular index or not. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe store the previously choosen elements parity in the prev variable and now we have two option:\\n- pick the (i+1)th index (next index)\\n- not pick the (i+1)th index\\n\\nIf we pick the next index then we compare its parity with the prev variable and add to the score. If parities dont match, subtract x aswell. If we dont pick the next index simply dont add to score and move to the next index. \\n\\nNow memoize using i and prev variable. \\n\\n# Complexity\\n- Time complexity:\\nO(N) as prev has only 2 possible values\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*N) + O(N) stack space. \\n\\n# Code\\n```\\nclass Solution {\\n    public long solve(int i,int[] nums, int x, int prev, long[][] dp){\\n        if(i+1 == nums.length){\\n            return 0;\\n        }\\n        if(dp[i][prev]!=-1){\\n            return dp[i][prev];\\n        }\\n        long jump = 0;\\n        if(nums[i+1]%2 == prev){\\n            jump = nums[i+1]+solve(i+1,nums,x,prev,dp);\\n        }\\n        else{\\n            jump = solve(i+1,nums,x,nums[i+1]%2,dp)-x+nums[i+1];\\n        }\\n        long notJump = solve(i+1,nums,x,prev,dp);\\n        return dp[i][prev] = Math.max(jump,notJump);\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][2];\\n        for(long[] arr : dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return nums[0]+solve(0,nums,x,nums[0]%2,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long solve(int i,int[] nums, int x, int prev, long[][] dp){\\n        if(i+1 == nums.length){\\n            return 0;\\n        }\\n        if(dp[i][prev]!=-1){\\n            return dp[i][prev];\\n        }\\n        long jump = 0;\\n        if(nums[i+1]%2 == prev){\\n            jump = nums[i+1]+solve(i+1,nums,x,prev,dp);\\n        }\\n        else{\\n            jump = solve(i+1,nums,x,nums[i+1]%2,dp)-x+nums[i+1];\\n        }\\n        long notJump = solve(i+1,nums,x,prev,dp);\\n        return dp[i][prev] = Math.max(jump,notJump);\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][2];\\n        for(long[] arr : dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return nums[0]+solve(0,nums,x,nums[0]%2,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801809,
                "title": "easy-detailed-explanation-c-dp-take-nottake-striver-s-way",
                "content": "# Intuition\\nso what i thought was to make a 2d dp where dp[i][0] represents sum from i index to n with even no at previous taken index and dp[i][1] will similarly for odd no at previous index taken\\n\\n# Approach\\nsince it was mentioned that we have to take the first no so we will make our call from 1 index and we will decide the parity of previous index taken with the first no \\nnow coming to solve function base case will be at index n where no more no. are there and we will have two cases take and nottake based on that we will update the dp\\n\\n# Complexity\\n- Time complexity:\\nO(n*2)\\n\\n- Space complexity:\\nO(n*2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int idx,int par,int x ,vector<int> &nums,vector<vector<long long>> &dp){\\n        int n=nums.size();\\n        if(idx==n){\\n            return 0;\\n        }\\n        if(dp[idx][par]!=-1){\\n            return dp[idx][par];\\n        }\\n        long long take=0;\\n        if((nums[idx]%2==0 && par==0) || (nums[idx]%2!=0 && par==1)){\\n            take+=nums[idx]+solve(idx+1,par,x,nums,dp);\\n        }\\n        else{\\n            take+=nums[idx]-x+solve(idx+1,par^1,x,nums,dp);\\n        }\\n        long long nottake=solve(idx+1,par,x,nums,dp);\\n        return dp[idx][par]=max(take,nottake);\\n    }\\n    \\n    \\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n      int n=nums.size(); \\n      vector<vector<long long>> dp(n+1,vector<long long>(2,-1));\\n       int par=-1;\\n        if(nums[0]%2==0){\\n            par=0;\\n        }\\n        else{\\n            par=1;\\n        }\\n      return nums[0]+solve(1,par,x,nums,dp);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int idx,int par,int x ,vector<int> &nums,vector<vector<long long>> &dp){\\n        int n=nums.size();\\n        if(idx==n){\\n            return 0;\\n        }\\n        if(dp[idx][par]!=-1){\\n            return dp[idx][par];\\n        }\\n        long long take=0;\\n        if((nums[idx]%2==0 && par==0) || (nums[idx]%2!=0 && par==1)){\\n            take+=nums[idx]+solve(idx+1,par,x,nums,dp);\\n        }\\n        else{\\n            take+=nums[idx]-x+solve(idx+1,par^1,x,nums,dp);\\n        }\\n        long long nottake=solve(idx+1,par,x,nums,dp);\\n        return dp[idx][par]=max(take,nottake);\\n    }\\n    \\n    \\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n      int n=nums.size(); \\n      vector<vector<long long>> dp(n+1,vector<long long>(2,-1));\\n       int par=-1;\\n        if(nums[0]%2==0){\\n            par=0;\\n        }\\n        else{\\n            par=1;\\n        }\\n      return nums[0]+solve(1,par,x,nums,dp);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801767,
                "title": "c-java-easy-solution-using-dp-memoization-tabulation-space-optimization",
                "content": "\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    long long f(int ind, vector<int>&nums , int x, int parity, vector<vector<long long>>&dp)\\n    {\\n        if(ind == nums.size())\\n            return 0;\\n        if(dp[ind][parity] != -1)\\n            return dp[ind][parity];\\n        long long ntake = f(ind+1,nums,x,parity,dp);\\n        long long take = 0;\\n        if(nums[ind] % 2 == parity)\\n            take = nums[ind] + f(ind+1,nums,x,parity,dp);\\n        else\\n            take = nums[ind] - x + f(ind+1,nums,x,nums[ind]%2,dp);\\n        return dp[ind][parity] = max(take,ntake);\\n    }\\n    long long tabulation(vector<int>&nums, int x)\\n    {\\n        int n = nums.size();\\n        vector<vector<long long>>dp(n+1,vector<long long>(2,0));\\n        for(int ind = n-1 ; ind >= 0 ; ind--)\\n        {\\n            for(int parity = 0 ; parity <= 1 ; parity++)\\n            {\\n                long long ntake = dp[ind+1][parity];\\n                long long take = 0;\\n                if(nums[ind] % 2 == parity)\\n                    take = nums[ind] + dp[ind+1][parity];\\n                else\\n                    take = nums[ind] - x + dp[ind+1][nums[ind]%2];\\n                 dp[ind][parity] = max(take,ntake);\\n            }\\n        }\\n        return dp[0][nums[0]%2];\\n    }\\n    long long spaceOptimized(vector<int>&nums, int x)\\n    {\\n        int n = nums.size();\\n        vector<long long>dp(2,0);\\n        vector<long long>temp(2,0);\\n        for(int ind = n-1 ; ind >= 0 ; ind--)\\n        {\\n            for(int parity = 0 ; parity <= 1 ; parity++)\\n            {\\n                long long ntake = dp[parity];\\n                long long take = 0;\\n                if(nums[ind] % 2 == parity)\\n                    take = nums[ind] + dp[parity];\\n                else\\n                    take = nums[ind] - x + dp[nums[ind]%2];\\n                 temp[parity] = max(take,ntake);\\n            }\\n            dp = temp;\\n        }\\n        return dp[nums[0]%2];\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long n = nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        int parity = nums[0]%2;\\n        //return nums[0] + f(1,nums,x,parity,dp);   \\n        //return tabulation(nums,x);\\n        return spaceOptimized(nums,x);\\n    }\\n};\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        // long[][] dp = new long[n][2];\\n        // for (long[] a : dp)\\n        //     Arrays.fill(a, -1);\\n        // int parity = nums[0] % 2;\\n        // return nums[0] + solve(nums, 1, x, parity, dp);\\n        // return tabulation(nums, n, x);\\n        return spaceOptimization(nums, n, x);\\n    }\\n    \\n    private long solve(int[] nums, int index, int x, int parity, long[][] dp) {\\n        if (index == nums.length) {\\n            return 0;\\n        }\\n        if (dp[index][parity] != -1)\\n            return dp[index][parity];\\n        long notTake = solve(nums, index + 1, x, parity, dp);\\n        long take = 0;\\n        if (nums[index] % 2 == parity) {\\n            take = nums[index] + solve(nums, index + 1, x, parity, dp);\\n        } else {\\n            take = nums[index] - x + solve(nums, index + 1, x, nums[index] % 2, dp);\\n        }\\n        return dp[index][parity] = Math.max(take, notTake);\\n    }\\n    \\n    private long tabulation (int[] nums, int n, int x) {\\n        long[][] dp = new long[n + 1][2];\\n        dp[n][0] = 0;\\n        dp[n][1] = 0;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 0; j <= 1; j++) {\\n                long notTake = dp[i + 1][j];\\n                long take = 0;\\n                if (nums[i] % 2 == j) {\\n                    take = nums[i] + dp[i + 1][j];\\n                } else {\\n                    take = nums[i] - x + dp[i + 1][nums[i] % 2];\\n                }\\n                dp[i][j] = Math.max(take, notTake);\\n            }\\n        }\\n        return dp[0][nums[0] % 2];\\n    }\\n    \\n    private long spaceOptimization (int[] nums, int n, int x) {\\n        long[] prev = new long[2];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            long[] curr = new long[2];\\n            for (int j = 0; j <= 1; j++) {\\n                long notTake = prev[j];\\n                long take = 0;\\n                if (nums[i] % 2 == j) {\\n                    take = nums[i] + prev[j];\\n                } else {\\n                    take = nums[i] - x + prev[nums[i] % 2];\\n                }\\n                curr[j] = Math.max(take, notTake);\\n            }\\n            prev = curr;\\n        }\\n        return prev[nums[0] % 2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(int ind, vector<int>&nums , int x, int parity, vector<vector<long long>>&dp)\\n    {\\n        if(ind == nums.size())\\n            return 0;\\n        if(dp[ind][parity] != -1)\\n            return dp[ind][parity];\\n        long long ntake = f(ind+1,nums,x,parity,dp);\\n        long long take = 0;\\n        if(nums[ind] % 2 == parity)\\n            take = nums[ind] + f(ind+1,nums,x,parity,dp);\\n        else\\n            take = nums[ind] - x + f(ind+1,nums,x,nums[ind]%2,dp);\\n        return dp[ind][parity] = max(take,ntake);\\n    }\\n    long long tabulation(vector<int>&nums, int x)\\n    {\\n        int n = nums.size();\\n        vector<vector<long long>>dp(n+1,vector<long long>(2,0));\\n        for(int ind = n-1 ; ind >= 0 ; ind--)\\n        {\\n            for(int parity = 0 ; parity <= 1 ; parity++)\\n            {\\n                long long ntake = dp[ind+1][parity];\\n                long long take = 0;\\n                if(nums[ind] % 2 == parity)\\n                    take = nums[ind] + dp[ind+1][parity];\\n                else\\n                    take = nums[ind] - x + dp[ind+1][nums[ind]%2];\\n                 dp[ind][parity] = max(take,ntake);\\n            }\\n        }\\n        return dp[0][nums[0]%2];\\n    }\\n    long long spaceOptimized(vector<int>&nums, int x)\\n    {\\n        int n = nums.size();\\n        vector<long long>dp(2,0);\\n        vector<long long>temp(2,0);\\n        for(int ind = n-1 ; ind >= 0 ; ind--)\\n        {\\n            for(int parity = 0 ; parity <= 1 ; parity++)\\n            {\\n                long long ntake = dp[parity];\\n                long long take = 0;\\n                if(nums[ind] % 2 == parity)\\n                    take = nums[ind] + dp[parity];\\n                else\\n                    take = nums[ind] - x + dp[nums[ind]%2];\\n                 temp[parity] = max(take,ntake);\\n            }\\n            dp = temp;\\n        }\\n        return dp[nums[0]%2];\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long n = nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        int parity = nums[0]%2;\\n        //return nums[0] + f(1,nums,x,parity,dp);   \\n        //return tabulation(nums,x);\\n        return spaceOptimized(nums,x);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        // long[][] dp = new long[n][2];\\n        // for (long[] a : dp)\\n        //     Arrays.fill(a, -1);\\n        // int parity = nums[0] % 2;\\n        // return nums[0] + solve(nums, 1, x, parity, dp);\\n        // return tabulation(nums, n, x);\\n        return spaceOptimization(nums, n, x);\\n    }\\n    \\n    private long solve(int[] nums, int index, int x, int parity, long[][] dp) {\\n        if (index == nums.length) {\\n            return 0;\\n        }\\n        if (dp[index][parity] != -1)\\n            return dp[index][parity];\\n        long notTake = solve(nums, index + 1, x, parity, dp);\\n        long take = 0;\\n        if (nums[index] % 2 == parity) {\\n            take = nums[index] + solve(nums, index + 1, x, parity, dp);\\n        } else {\\n            take = nums[index] - x + solve(nums, index + 1, x, nums[index] % 2, dp);\\n        }\\n        return dp[index][parity] = Math.max(take, notTake);\\n    }\\n    \\n    private long tabulation (int[] nums, int n, int x) {\\n        long[][] dp = new long[n + 1][2];\\n        dp[n][0] = 0;\\n        dp[n][1] = 0;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 0; j <= 1; j++) {\\n                long notTake = dp[i + 1][j];\\n                long take = 0;\\n                if (nums[i] % 2 == j) {\\n                    take = nums[i] + dp[i + 1][j];\\n                } else {\\n                    take = nums[i] - x + dp[i + 1][nums[i] % 2];\\n                }\\n                dp[i][j] = Math.max(take, notTake);\\n            }\\n        }\\n        return dp[0][nums[0] % 2];\\n    }\\n    \\n    private long spaceOptimization (int[] nums, int n, int x) {\\n        long[] prev = new long[2];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            long[] curr = new long[2];\\n            for (int j = 0; j <= 1; j++) {\\n                long notTake = prev[j];\\n                long take = 0;\\n                if (nums[i] % 2 == j) {\\n                    take = nums[i] + prev[j];\\n                } else {\\n                    take = nums[i] - x + prev[nums[i] % 2];\\n                }\\n                curr[j] = Math.max(take, notTake);\\n            }\\n            prev = curr;\\n        }\\n        return prev[nums[0] % 2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870929,
                "title": "pick-and-not-pick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    ll memo[100005][2];\\n    \\n    ll fun(int ind, int isOdd, int x, vector<int>& nums) {\\n        if(ind == nums.size())return 0;\\n        if(memo[ind][isOdd] != -1)return memo[ind][isOdd];\\n        \\n        ll skip = fun(ind+1, isOdd, x, nums);\\n        ll pick = nums[ind] + fun(ind+1, (nums[ind]&1), x, nums);\\n        if((nums[ind]&1) != isOdd)pick -= x;\\n        return memo[ind][isOdd] = max(pick, skip);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(memo, -1, sizeof(memo));\\n        return nums[0] + fun(1, (nums[0] & 1), x, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    ll memo[100005][2];\\n    \\n    ll fun(int ind, int isOdd, int x, vector<int>& nums) {\\n        if(ind == nums.size())return 0;\\n        if(memo[ind][isOdd] != -1)return memo[ind][isOdd];\\n        \\n        ll skip = fun(ind+1, isOdd, x, nums);\\n        ll pick = nums[ind] + fun(ind+1, (nums[ind]&1), x, nums);\\n        if((nums[ind]&1) != isOdd)pick -= x;\\n        return memo[ind][isOdd] = max(pick, skip);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(memo, -1, sizeof(memo));\\n        return nums[0] + fun(1, (nums[0] & 1), x, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863538,
                "title": "js-faster-than-100",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} x\\n * @return {number}\\n */\\nconst isOdd = (num) => !!(num%2)\\nvar maxScore = function(nums, x) {\\n    let odd = isOdd(nums[0]) ? nums[0] : nums[0] - x;\\n    let even = isOdd(nums[0]) ? nums[0] - x : nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n      const num = nums[i]\\n      if (isOdd(num)) {\\n        odd = Math.max(odd + num, even + num - x)\\n      } else {\\n        even = Math.max(even + num, odd + num - x)\\n      }\\n    }\\n    return Math.max(odd, even);\\n};  \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} x\\n * @return {number}\\n */\\nconst isOdd = (num) => !!(num%2)\\nvar maxScore = function(nums, x) {\\n    let odd = isOdd(nums[0]) ? nums[0] : nums[0] - x;\\n    let even = isOdd(nums[0]) ? nums[0] - x : nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n      const num = nums[i]\\n      if (isOdd(num)) {\\n        odd = Math.max(odd + num, even + num - x)\\n      } else {\\n        even = Math.max(even + num, odd + num - x)\\n      }\\n    }\\n    return Math.max(odd, even);\\n};  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836167,
                "title": "dp-easy-solution-easy-to-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //for even ->1 \\n    //for odd ->0\\n    long long solve(int i,vector<int>& nums, int x,vector<vector<long long>> &dp,int p){\\n        \\n        if(i>=nums.size())return 0;\\n        if(dp[i][p]!=-1)\\n            return dp[i][p];\\n        \\n        long long liya =0,nhiliya=0;long long res = 0;\\n        if(p==1 && nums[i]%2==0){ //for even\\n            liya = solve(i+1,nums,x,dp,p)+nums[i];\\n            nhiliya = solve(i+1,nums,x,dp,p);\\n            res = max(liya,nhiliya);\\n        }\\n        else if(p==1 && nums[i]%2!=0){\\n            liya = solve(i+1,nums,x,dp,0)+nums[i]-x;\\n            nhiliya = solve(i+1,nums,x,dp,1);\\n            res = max(liya,nhiliya);\\n        }else if(p==0 && nums[i]%2==0){\\n            liya = solve(i+1,nums,x,dp,1)+nums[i]-x;\\n            nhiliya = solve(i+1,nums,x,dp,p);\\n            res = max(liya,nhiliya);\\n        }else if(p==0 && nums[i]%2!=0){\\n            liya = solve(i+1,nums,x,dp,p)+nums[i];\\n            nhiliya = solve(i+1,nums,x,dp,p);\\n            res = max(liya,nhiliya);\\n        }\\n        return dp[i][p] = res;\\n        \\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n     vector<vector<long long>> dp(n,vector<long long>(2,-1));\\n        int p = 0;\\n        if(nums[0]%2==0)p=1;\\n        \\n        return solve(0,nums,x,dp,p);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //for even ->1 \\n    //for odd ->0\\n    long long solve(int i,vector<int>& nums, int x,vector<vector<long long>> &dp,int p){\\n        \\n        if(i>=nums.size())return 0;\\n        if(dp[i][p]!=-1)\\n            return dp[i][p];\\n        \\n        long long liya =0,nhiliya=0;long long res = 0;\\n        if(p==1 && nums[i]%2==0){ //for even\\n            liya = solve(i+1,nums,x,dp,p)+nums[i];\\n            nhiliya = solve(i+1,nums,x,dp,p);\\n            res = max(liya,nhiliya);\\n        }\\n        else if(p==1 && nums[i]%2!=0){\\n            liya = solve(i+1,nums,x,dp,0)+nums[i]-x;\\n            nhiliya = solve(i+1,nums,x,dp,1);\\n            res = max(liya,nhiliya);\\n        }else if(p==0 && nums[i]%2==0){\\n            liya = solve(i+1,nums,x,dp,1)+nums[i]-x;\\n            nhiliya = solve(i+1,nums,x,dp,p);\\n            res = max(liya,nhiliya);\\n        }else if(p==0 && nums[i]%2!=0){\\n            liya = solve(i+1,nums,x,dp,p)+nums[i];\\n            nhiliya = solve(i+1,nums,x,dp,p);\\n            res = max(liya,nhiliya);\\n        }\\n        return dp[i][p] = res;\\n        \\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n     vector<vector<long long>> dp(n,vector<long long>(2,-1));\\n        int p = 0;\\n        if(nums[0]%2==0)p=1;\\n        \\n        return solve(0,nums,x,dp,p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819667,
                "title": "just-like-knapsack-dp-pick-not-pick-approach",
                "content": "# Intuition\\nSimple Pick and Not Pick Approach\\n\\n# Complexity\\n- Time complexity : $$O(N*2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(N*2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();  \\n        vector<vector<long long>> dp(n,vector<long long>(2,-1));\\n        return f(1,nums[0]%2,x,nums,dp) + nums[0];\\n    }\\n    \\n    long long f(int idx, int prevParity, int x, vector<int> &nums, vector<vector<long long>> &dp) {\\n        if(idx >= nums.size()) return 0;\\n        \\n        if(dp[idx][prevParity] != -1) return dp[idx][prevParity];\\n        \\n        long long notPick = f(idx+1,prevParity,x,nums,dp);\\n        long long pick = 0;\\n        \\n        if(prevParity && nums[idx]%2) pick = 1ll*nums[idx] + f(idx+1,nums[idx]%2,x,nums,dp); // both odd\\n        else if(!prevParity && nums[idx]%2==0) pick = 1ll*nums[idx] + f(idx+1,nums[idx]%2,x,nums,dp); // both even\\n        else pick = 1ll*nums[idx] - x + f(idx+1,nums[idx]%2,x,nums,dp); // one odd, one even\\n        \\n        return dp[idx][prevParity] = max(pick,notPick);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();  \\n        vector<vector<long long>> dp(n,vector<long long>(2,-1));\\n        return f(1,nums[0]%2,x,nums,dp) + nums[0];\\n    }\\n    \\n    long long f(int idx, int prevParity, int x, vector<int> &nums, vector<vector<long long>> &dp) {\\n        if(idx >= nums.size()) return 0;\\n        \\n        if(dp[idx][prevParity] != -1) return dp[idx][prevParity];\\n        \\n        long long notPick = f(idx+1,prevParity,x,nums,dp);\\n        long long pick = 0;\\n        \\n        if(prevParity && nums[idx]%2) pick = 1ll*nums[idx] + f(idx+1,nums[idx]%2,x,nums,dp); // both odd\\n        else if(!prevParity && nums[idx]%2==0) pick = 1ll*nums[idx] + f(idx+1,nums[idx]%2,x,nums,dp); // both even\\n        else pick = 1ll*nums[idx] - x + f(idx+1,nums[idx]%2,x,nums,dp); // one odd, one even\\n        \\n        return dp[idx][prevParity] = max(pick,notPick);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805937,
                "title": "c-java-dp-pick-notpick-simplest-beginner-friendly",
                "content": "\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n * 2)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int getEvenOdd(int num) {\\n        return num % 2 == 0;\\n    }\\n    long long dfs(int ind, int prevPar, vector<int>& nums, int n, int penalty, vector<vector<long long>>& dp) {\\n        if (ind == n) return 0;\\n        if (dp[ind][prevPar] != -1) return dp[ind][prevPar];\\n\\n        long long pick = 0, notPick = 0;\\n        int currPar = getEvenOdd(nums[ind]);\\n\\n        notPick = dfs(ind + 1, prevPar, nums, n, penalty, dp);\\n        pick = nums[ind] + dfs(ind + 1, currPar, nums, n, penalty, dp);\\n        if (prevPar != currPar) pick -= penalty;\\n        \\n        return dp[ind][prevPar] = max(notPick, pick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n + 1, vector<long long>(2, -1));\\n        return dfs(0, getEvenOdd(nums[0]), nums, n, x, dp);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int getEvenOdd(int num) {\\n        return num % 2 == 0 ? 1 : 0;\\n    }\\n    private long dfs(int ind, int prevPar, int[] nums, int n, int penalty, long[][] dp) {\\n        if (ind == n) return 0;\\n        if (dp[ind][prevPar] != -1) return dp[ind][prevPar];\\n\\n        long pick = 0, notPick = 0;\\n        int currPar = getEvenOdd(nums[ind]);\\n\\n        notPick = dfs(ind + 1, prevPar, nums, n, penalty, dp);\\n        pick = nums[ind] + dfs(ind + 1, currPar, nums, n, penalty, dp);\\n\\n        if (prevPar != currPar) pick -= penalty;\\n\\n        dp[ind][prevPar] = Math.max(notPick, pick);\\n        return dp[ind][prevPar];\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][2];\\n\\n        for (int i = 0; i < n; ++i) Arrays.fill(dp[i], -1);\\n        return dfs(0, getEvenOdd(nums[0]), nums, n, x, dp);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int getEvenOdd(int num) {\\n        return num % 2 == 0;\\n    }\\n    long long dfs(int ind, int prevPar, vector<int>& nums, int n, int penalty, vector<vector<long long>>& dp) {\\n        if (ind == n) return 0;\\n        if (dp[ind][prevPar] != -1) return dp[ind][prevPar];\\n\\n        long long pick = 0, notPick = 0;\\n        int currPar = getEvenOdd(nums[ind]);\\n\\n        notPick = dfs(ind + 1, prevPar, nums, n, penalty, dp);\\n        pick = nums[ind] + dfs(ind + 1, currPar, nums, n, penalty, dp);\\n        if (prevPar != currPar) pick -= penalty;\\n        \\n        return dp[ind][prevPar] = max(notPick, pick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n + 1, vector<long long>(2, -1));\\n        return dfs(0, getEvenOdd(nums[0]), nums, n, x, dp);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int getEvenOdd(int num) {\\n        return num % 2 == 0 ? 1 : 0;\\n    }\\n    private long dfs(int ind, int prevPar, int[] nums, int n, int penalty, long[][] dp) {\\n        if (ind == n) return 0;\\n        if (dp[ind][prevPar] != -1) return dp[ind][prevPar];\\n\\n        long pick = 0, notPick = 0;\\n        int currPar = getEvenOdd(nums[ind]);\\n\\n        notPick = dfs(ind + 1, prevPar, nums, n, penalty, dp);\\n        pick = nums[ind] + dfs(ind + 1, currPar, nums, n, penalty, dp);\\n\\n        if (prevPar != currPar) pick -= penalty;\\n\\n        dp[ind][prevPar] = Math.max(notPick, pick);\\n        return dp[ind][prevPar];\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][2];\\n\\n        for (int i = 0; i < n; ++i) Arrays.fill(dp[i], -1);\\n        return dfs(0, getEvenOdd(nums[0]), nums, n, x, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805606,
                "title": "dp-memoization",
                "content": "# Intuition\\nThree casee:\\n1) Switching if different parity.\\n2) Not switching if same parity.\\n3) Moving on if different parity.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach - Dp (Memoization)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int ind,int par,vector<int>&nums, int x, vector<vector<long long>>&dp){\\n        if(ind==nums.size()) return 0;\\n        \\n        if(dp[ind][par]!=-1) return dp[ind][par];\\n        \\n        long long switching=0;\\n        if(nums[ind]%2!=par){\\n            switching = nums[ind] - x + solve(ind+1, nums[ind]%2, nums, x, dp);\\n        }\\n        \\n        long long not_switching=0;\\n        if(nums[ind]%2==par){\\n            not_switching = nums[ind] + solve(ind+1, par, nums, x, dp);\\n        }\\n        \\n        long long moving_on = 0 + solve(ind+1, par, nums, x, dp);\\n        \\n        return dp[ind][par] = max(moving_on,max(switching,not_switching));\\n        \\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long ans=0;\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        \\n        return nums[0] + solve(1,nums[0]%2,nums,x,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int ind,int par,vector<int>&nums, int x, vector<vector<long long>>&dp){\\n        if(ind==nums.size()) return 0;\\n        \\n        if(dp[ind][par]!=-1) return dp[ind][par];\\n        \\n        long long switching=0;\\n        if(nums[ind]%2!=par){\\n            switching = nums[ind] - x + solve(ind+1, nums[ind]%2, nums, x, dp);\\n        }\\n        \\n        long long not_switching=0;\\n        if(nums[ind]%2==par){\\n            not_switching = nums[ind] + solve(ind+1, par, nums, x, dp);\\n        }\\n        \\n        long long moving_on = 0 + solve(ind+1, par, nums, x, dp);\\n        \\n        return dp[ind][par] = max(moving_on,max(switching,not_switching));\\n        \\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long ans=0;\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        \\n        return nums[0] + solve(1,nums[0]%2,nums,x,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804309,
                "title": "java-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\n    long ans = Integer.MIN_VALUE;\\n    long[][] dp ;\\n    public long solve(int ind, int[] nums, int x,int rem){\\n        int n = nums.length;\\n        if(ind >= n)\\n            return 0;\\n        \\n        if(dp[ind][rem] != -1)\\n            return dp[ind][rem];\\n        \\n        long ret = 0;\\n        int add = rem == nums[ind]%2 ? nums[ind] : nums[ind] - x;\\n        long inc = add + solve(ind+1, nums ,x , nums[ind]%2);\\n        long dis = solve(ind+1, nums, x, rem);\\n        ret = Math.max(inc, dis);\\n        dp[ind][rem] = ret;\\n        return ret;\\n    }\\n    \\n    public long maxScore(int[] nums, int x) {\\n        dp = new long[nums.length][3];\\n        for(long[] ar : dp)\\n            Arrays.fill(ar,-1);\\n        for(int i = 1; i<nums.length;i++){\\n            long cal = solve(i, nums, x,nums[0]%2);\\n            ans = Math.max(ans,cal);\\n        }\\n        \\n        ans+=nums[0];\\n        return ans;\\n    }\\n}\\n\\n\\n\\n/*\\n\\n[1,2]\\n2\\n[1,2,3]\\n2\\n[1,2,4]\\n2\\n[2,3,6,1,9,2]\\n5\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long ans = Integer.MIN_VALUE;\\n    long[][] dp ;\\n    public long solve(int ind, int[] nums, int x,int rem){\\n        int n = nums.length;\\n        if(ind >= n)\\n            return 0;\\n        \\n        if(dp[ind][rem] != -1)\\n            return dp[ind][rem];\\n        \\n        long ret = 0;\\n        int add = rem == nums[ind]%2 ? nums[ind] : nums[ind] - x;\\n        long inc = add + solve(ind+1, nums ,x , nums[ind]%2);\\n        long dis = solve(ind+1, nums, x, rem);\\n        ret = Math.max(inc, dis);\\n        dp[ind][rem] = ret;\\n        return ret;\\n    }\\n    \\n    public long maxScore(int[] nums, int x) {\\n        dp = new long[nums.length][3];\\n        for(long[] ar : dp)\\n            Arrays.fill(ar,-1);\\n        for(int i = 1; i<nums.length;i++){\\n            long cal = solve(i, nums, x,nums[0]%2);\\n            ans = Math.max(ans,cal);\\n        }\\n        \\n        ans+=nums[0];\\n        return ans;\\n    }\\n}\\n\\n\\n\\n/*\\n\\n[1,2]\\n2\\n[1,2,3]\\n2\\n[1,2,4]\\n2\\n[2,3,6,1,9,2]\\n5\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803616,
                "title": "python3-clean-dp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        n=len(nums)\\n        \\n        @cache\\n        def f(ind,p):\\n            if ind==n:\\n                return 0\\n\\n            curr=nums[ind]%2\\n\\n            if curr==p:\\n                ans=nums[ind]+f(ind+1,curr)\\n            else:\\n                ans=nums[ind]-x+f(ind+1,curr)\\n            \\n            ans=max(ans,f(ind+1,p))\\n            return ans\\n        \\n        return nums[0] + f(1,nums[0]%2)\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        n=len(nums)\\n        \\n        @cache\\n        def f(ind,p):\\n            if ind==n:\\n                return 0\\n\\n            curr=nums[ind]%2\\n\\n            if curr==p:\\n                ans=nums[ind]+f(ind+1,curr)\\n            else:\\n                ans=nums[ind]-x+f(ind+1,curr)\\n            \\n            ans=max(ans,f(ind+1,p))\\n            return ans\\n        \\n        return nums[0] + f(1,nums[0]%2)\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802645,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long largestEven = 0;\\n        long largestOdd = 0;\\n        long result = 0;\\n        if (nums[0] % 2 == 0) {\\n            largestEven = nums[0];\\n            largestOdd = nums[0] - x;\\n        } else {\\n            largestEven = nums[0] - x;\\n            largestOdd = nums[0];\\n        }\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                largestEven = Math.max(largestEven + nums[i], largestOdd + nums[i] - x);\\n            } else {\\n                largestOdd = Math.max(largestOdd + nums[i], largestEven + nums[i] - x);\\n            }\\n            result = Math.max(largestEven, largestOdd);\\n        }  \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long largestEven = 0;\\n        long largestOdd = 0;\\n        long result = 0;\\n        if (nums[0] % 2 == 0) {\\n            largestEven = nums[0];\\n            largestOdd = nums[0] - x;\\n        } else {\\n            largestEven = nums[0] - x;\\n            largestOdd = nums[0];\\n        }\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                largestEven = Math.max(largestEven + nums[i], largestOdd + nums[i] - x);\\n            } else {\\n                largestOdd = Math.max(largestOdd + nums[i], largestEven + nums[i] - x);\\n            }\\n            result = Math.max(largestEven, largestOdd);\\n        }  \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802639,
                "title": "python-simple-odd-even-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(2N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#1-even\\n#0-odd\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        n=len(nums)\\n        @lru_cache(None)\\n        def f(idx,p):\\n            if idx>=n:\\n                return 0\\n            nopick=f(idx+1,p)\\n            if p==1 and nums[idx]%2==0:\\n                pick=nums[idx]+f(idx+1,1)\\n            elif p==0 and nums[idx]%2!=0:\\n                pick=nums[idx]+f(idx+1,0)\\n            elif p==0:\\n                pick=nums[idx]-x+f(idx+1,1)\\n            else:\\n                pick=nums[idx]-x+f(idx+1,0)\\n            return max(pick,nopick)\\n        if nums[0]%2==0:\\n            p=1\\n        else:\\n            p=0\\n        return nums[0]+f(1,p)\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#1-even\\n#0-odd\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        n=len(nums)\\n        @lru_cache(None)\\n        def f(idx,p):\\n            if idx>=n:\\n                return 0\\n            nopick=f(idx+1,p)\\n            if p==1 and nums[idx]%2==0:\\n                pick=nums[idx]+f(idx+1,1)\\n            elif p==0 and nums[idx]%2!=0:\\n                pick=nums[idx]+f(idx+1,0)\\n            elif p==0:\\n                pick=nums[idx]-x+f(idx+1,1)\\n            else:\\n                pick=nums[idx]-x+f(idx+1,0)\\n            return max(pick,nopick)\\n        if nums[0]%2==0:\\n            p=1\\n        else:\\n            p=0\\n        return nums[0]+f(1,p)\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802444,
                "title": "c-simple-pick-notpick-memoization-with-explaination",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. starting from index 0 , at each index decide wheather to pick or not pick the element.\\n2. If you decide to pick the element then add penalty based on the parity of previous number i.e if parity(prev_number) != parity(pres_number) then subtract x from solution\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,x;\\n    vector<vector<long long>> dp;\\n    long long maxScore(vector<int>& nums, int X) {\\n        n = nums.size();\\n        x= X;\\n        // memo table - there are 2 states index & parity of number \\n        dp.resize(n,vector<long long>(2,-1));\\n        return recur(nums,0,nums[0]%2);\\n    }\\n    // flag denotes parity of prev number which was picked\\n    long long recur(vector<int>& a,int idx,int flag){\\n        if(idx == n)\\n            return 0;\\n        if(dp[idx][flag] != -1) return dp[idx][flag];\\n\\n        // not Pick\\n        long long notTake = recur(a,idx+1,flag);\\n\\n        //pick\\n        // if parity of prev number picked is different then add -x to solution\\n        long long take = a[idx] +(a[idx]%2 == flag?0:(-x)) + recur(a,idx+1,a[idx]%2);\\n\\n        return dp[idx][flag] = max(notTake,take);\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,x;\\n    vector<vector<long long>> dp;\\n    long long maxScore(vector<int>& nums, int X) {\\n        n = nums.size();\\n        x= X;\\n        // memo table - there are 2 states index & parity of number \\n        dp.resize(n,vector<long long>(2,-1));\\n        return recur(nums,0,nums[0]%2);\\n    }\\n    // flag denotes parity of prev number which was picked\\n    long long recur(vector<int>& a,int idx,int flag){\\n        if(idx == n)\\n            return 0;\\n        if(dp[idx][flag] != -1) return dp[idx][flag];\\n\\n        // not Pick\\n        long long notTake = recur(a,idx+1,flag);\\n\\n        //pick\\n        // if parity of prev number picked is different then add -x to solution\\n        long long take = a[idx] +(a[idx]%2 == flag?0:(-x)) + recur(a,idx+1,a[idx]%2);\\n\\n        return dp[idx][flag] = max(notTake,take);\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802399,
                "title": "simple-short-and-sweet-recursive-memoized-solutions-o-n-and-o-n-2",
                "content": "# Intuition\\nGiven that we initially have `nums[0]`, for next `nums[ind]` we can either `take` or `not take` , just a simple knapsack variant.\\n\\n# Approach\\nIf we take the curr ind we have to check the parity of curr , compared to prev `p`, if its the same we dont have to subtract any thing , if they are diff we just subtract `x`. Choose the max of the two.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N) or O(100005*2)\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long dp[100005][2];\\n    long long maxScore(vector<int>& nums, int x) {\\n        return solve(nums, x, 0, nums[0] % 2);\\n    }\\n\\n    long long solve(vector<int>& nums, int x, int ind, int p) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if(dp[ind][p]) return dp[ind][p];\\n        long long dontTake=solve(nums,x,ind+1,p);\\n        long long takeScore = nums[ind]+solve(nums,x,ind+1,nums[ind]%2);\\n        if (nums[ind] % 2 != p) takeScore -= x;\\n        \\n        return dp[ind][p]=max(takeScore,dontTake);\\n    }\\n};\\n\\n```\\n\\n---\\n\\n\\nGiving another approach` O(n^2)` which i tried in contest but got `TLE` just so you know multiple approaches this can be solved.\\n- Time complexity:\\nO(N^2)\\n\\n```\\nclass Solution {\\npublic:\\nint dp[100005][2];\\n    long long maxScore(vector<int>& nums, int x) {\\n        return solve(nums, x, 0, nums[0] % 2);\\n    }\\n\\n    long long solve(vector<int>& nums, int x, int ind, int p) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if(dp[ind][p]) return dp[ind][p];\\n\\n        long long score = nums[ind];\\n        if (nums[ind] % 2 != p) score -= x;\\n\\n        long long move = 0;\\n        for (int i = ind + 1; i < nums.size(); i++) { \\n            move = max(move, solve(nums, x, i, nums[ind] % 2));\\n        }\\n        return dp[ind][p]=score + move;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long dp[100005][2];\\n    long long maxScore(vector<int>& nums, int x) {\\n        return solve(nums, x, 0, nums[0] % 2);\\n    }\\n\\n    long long solve(vector<int>& nums, int x, int ind, int p) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if(dp[ind][p]) return dp[ind][p];\\n        long long dontTake=solve(nums,x,ind+1,p);\\n        long long takeScore = nums[ind]+solve(nums,x,ind+1,nums[ind]%2);\\n        if (nums[ind] % 2 != p) takeScore -= x;\\n        \\n        return dp[ind][p]=max(takeScore,dontTake);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\nint dp[100005][2];\\n    long long maxScore(vector<int>& nums, int x) {\\n        return solve(nums, x, 0, nums[0] % 2);\\n    }\\n\\n    long long solve(vector<int>& nums, int x, int ind, int p) {\\n        if (ind >= nums.size()) {\\n            return 0;\\n        }\\n        if(dp[ind][p]) return dp[ind][p];\\n\\n        long long score = nums[ind];\\n        if (nums[ind] % 2 != p) score -= x;\\n\\n        long long move = 0;\\n        for (int i = ind + 1; i < nums.size(); i++) { \\n            move = max(move, solve(nums, x, i, nums[ind] % 2));\\n        }\\n        return dp[ind][p]=score + move;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802373,
                "title": "c-memoization-solution-knapsack-o-2-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ans=-1e9;\\n    vector<vector<long long>>dp;\\n    long long f(vector<int>&nums,int x,int ind,int prev,long long score){\\n        int n=nums.size();\\n        if(ind==n){\\n            return 0;\\n        }\\n        if(dp[ind][prev]!=-1)return dp[ind][prev];\\n        long long take=-1e9;\\n        if(prev!=nums[ind]%2){\\n            take=nums[ind]-x+f(nums,x,ind+1,nums[ind]%2,score+nums[ind]-x);\\n        }\\n        else{\\n            take=nums[ind]+f(nums,x,ind+1,prev,score+nums[ind]);\\n        }\\n        long long notake=f(nums,x,ind+1,prev,score);\\n        return dp[ind][prev]=max(take,notake);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        dp.resize(n,vector<long long>(2,-1));\\n        return nums[0]+f(nums,x,1,nums[0]%2,nums[0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans=-1e9;\\n    vector<vector<long long>>dp;\\n    long long f(vector<int>&nums,int x,int ind,int prev,long long score){\\n        int n=nums.size();\\n        if(ind==n){\\n            return 0;\\n        }\\n        if(dp[ind][prev]!=-1)return dp[ind][prev];\\n        long long take=-1e9;\\n        if(prev!=nums[ind]%2){\\n            take=nums[ind]-x+f(nums,x,ind+1,nums[ind]%2,score+nums[ind]-x);\\n        }\\n        else{\\n            take=nums[ind]+f(nums,x,ind+1,prev,score+nums[ind]);\\n        }\\n        long long notake=f(nums,x,ind+1,prev,score);\\n        return dp[ind][prev]=max(take,notake);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        dp.resize(n,vector<long long>(2,-1));\\n        return nums[0]+f(nums,x,1,nums[0]%2,nums[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802371,
                "title": "rust-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_score(nums: Vec<i32>, x: i32) -> i64 {\\n        let mut data = vec![i32::MIN as i64; 2];\\n        let mut ret = nums[0] as i64;\\n\\n        data[nums[0] as usize % 2] = nums[0] as i64;\\n        for i in 1 .. nums.len() {\\n            let k = nums[i] as usize % 2;\\n            let a = nums[i] as i64;\\n            data[k] = i64::max(data[k] + a, data[1 - k] + a - x as i64);\\n            ret = i64::max(ret, data[k]); \\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_score(nums: Vec<i32>, x: i32) -> i64 {\\n        let mut data = vec![i32::MIN as i64; 2];\\n        let mut ret = nums[0] as i64;\\n\\n        data[nums[0] as usize % 2] = nums[0] as i64;\\n        for i in 1 .. nums.len() {\\n            let k = nums[i] as usize % 2;\\n            let a = nums[i] as i64;\\n            data[k] = i64::max(data[k] + a, data[1 - k] + a - x as i64);\\n            ret = i64::max(ret, data[k]); \\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3802298,
                "title": "easy-solution-c-recursion-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long f(int ind, int b, vector<int>& nums, int x, vector<vector<long long>>& dp){\\n        if(ind == nums.size()) return 0;\\n        if(dp[ind][b] != -1) return dp[ind][b];\\n        long long nottake = f(ind+1, b, nums, x, dp);\\n        long long take = f(ind+1, nums[ind]%2, nums, x, dp) + nums[ind] - ((nums[ind]%2 != b && b != -1) ? x : 0);\\n        return dp[ind][b] = max(take, nottake);\\n        \\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size(), vector<long long>(2,-1));\\n        return nums[0] + f(1, nums[0]%2, nums, x, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(int ind, int b, vector<int>& nums, int x, vector<vector<long long>>& dp){\\n        if(ind == nums.size()) return 0;\\n        if(dp[ind][b] != -1) return dp[ind][b];\\n        long long nottake = f(ind+1, b, nums, x, dp);\\n        long long take = f(ind+1, nums[ind]%2, nums, x, dp) + nums[ind] - ((nums[ind]%2 != b && b != -1) ? x : 0);\\n        return dp[ind][b] = max(take, nottake);\\n        \\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size(), vector<long long>(2,-1));\\n        return nums[0] + f(1, nums[0]%2, nums, x, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802230,
                "title": "tabulation-with-space-optimization-like-striver",
                "content": "# Intuition\\nThe main idea was to only store the prev even and prev odd number which we have seen till the ith index. And check whether the current nums i will give max sum with which of the above case\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev_even=0,prev_odd=-1;\\n        if(nums[0]%2!=0){\\n            prev_even=-1;\\n            prev_odd=0;\\n        }\\n        \\n        int n=nums.size();\\n        long long sum=nums[0];\\n        vector<long long>dp(n,-1e9);\\n        dp[0]=sum;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]%2==0){\\n                if(prev_even!=-1){\\n                    long long p=dp[prev_even]+nums[i];\\n                    dp[i]=max(dp[i],p);\\n                    \\n                }\\n                 if(prev_odd!=-1){\\n                     long long p=dp[prev_odd]+nums[i]-x;\\n                    dp[i]=max(dp[i],p);\\n                } \\n                prev_even=i;\\n                sum=max(sum,dp[i]);\\n            }\\n            else{\\n                if(prev_even!=-1){\\n                    long long p=dp[prev_even]+nums[i]-x;\\n                    dp[i]=max(dp[i],p);\\n                }\\n                if(prev_odd!=-1){\\n                    long long p=dp[prev_odd]+nums[i];\\n                    dp[i]=max(dp[i],p);\\n                }   \\n                prev_odd=i;\\n                sum=max(sum,dp[i]);\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev_even=0,prev_odd=-1;\\n        if(nums[0]%2!=0){\\n            prev_even=-1;\\n            prev_odd=0;\\n        }\\n        \\n        int n=nums.size();\\n        long long sum=nums[0];\\n        vector<long long>dp(n,-1e9);\\n        dp[0]=sum;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]%2==0){\\n                if(prev_even!=-1){\\n                    long long p=dp[prev_even]+nums[i];\\n                    dp[i]=max(dp[i],p);\\n                    \\n                }\\n                 if(prev_odd!=-1){\\n                     long long p=dp[prev_odd]+nums[i]-x;\\n                    dp[i]=max(dp[i],p);\\n                } \\n                prev_even=i;\\n                sum=max(sum,dp[i]);\\n            }\\n            else{\\n                if(prev_even!=-1){\\n                    long long p=dp[prev_even]+nums[i]-x;\\n                    dp[i]=max(dp[i],p);\\n                }\\n                if(prev_odd!=-1){\\n                    long long p=dp[prev_odd]+nums[i];\\n                    dp[i]=max(dp[i],p);\\n                }   \\n                prev_odd=i;\\n                sum=max(sum,dp[i]);\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802187,
                "title": "c-clean-and-easy-solution",
                "content": "# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    ll solve(int ind,int pari,int x,int n, vector<int> &nums, vector<vector<ll>> &dp){\\n        if(ind>n-1) return 0;\\n        if(dp[ind][pari]!=-1) return dp[ind][pari];\\n        ll nottake=solve(ind+1,pari,x,n,nums,dp);\\n        ll take=INT_MIN;\\n        if(pari==nums[ind]%2) take=nums[ind]+solve(ind+1,pari,x,n,nums,dp);\\n        else take=nums[ind]-x+solve(ind+1,!pari,x,n,nums,dp);\\n        return dp[ind][pari]=max(take,nottake);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<ll>> dp(n,vector<ll>(2,-1));\\n        return nums[0]+solve(1,nums[0]%2,x,n,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    ll solve(int ind,int pari,int x,int n, vector<int> &nums, vector<vector<ll>> &dp){\\n        if(ind>n-1) return 0;\\n        if(dp[ind][pari]!=-1) return dp[ind][pari];\\n        ll nottake=solve(ind+1,pari,x,n,nums,dp);\\n        ll take=INT_MIN;\\n        if(pari==nums[ind]%2) take=nums[ind]+solve(ind+1,pari,x,n,nums,dp);\\n        else take=nums[ind]-x+solve(ind+1,!pari,x,n,nums,dp);\\n        return dp[ind][pari]=max(take,nottake);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<ll>> dp(n,vector<ll>(2,-1));\\n        return nums[0]+solve(1,nums[0]%2,x,n,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802168,
                "title": "simplest-solution-must-see",
                "content": "# Intuition:Maximize as the problem says and we can either pick a number or not hmmm...got it\\'s Knapsack.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:Keep track of the previous parity and then its simple knapsack.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][2];\\n    long long f(vector<int>&nums,int i,int x,int preparity){\\n        if(i==nums.size())return 0;\\n        if(dp[i][preparity]!=-1)return dp[i][preparity];\\n        long long notpick=f(nums,i+1,x,preparity);\\n        long long pick=0;\\n        if(preparity%2==nums[i]%2){\\n             pick=nums[i]+f(nums,i+1,x,nums[i]%2);\\n             \\n        }\\n        else{\\n            pick=nums[i]+f(nums,i+1,x,nums[i]%2)-x;\\n        }\\n        return dp[i][preparity]=max(pick,notpick);\\n     }\\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(dp,-1,sizeof(dp));\\n        return nums[0]+f(nums,1,x,nums[0]%2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2];\\n    long long f(vector<int>&nums,int i,int x,int preparity){\\n        if(i==nums.size())return 0;\\n        if(dp[i][preparity]!=-1)return dp[i][preparity];\\n        long long notpick=f(nums,i+1,x,preparity);\\n        long long pick=0;\\n        if(preparity%2==nums[i]%2){\\n             pick=nums[i]+f(nums,i+1,x,nums[i]%2);\\n             \\n        }\\n        else{\\n            pick=nums[i]+f(nums,i+1,x,nums[i]%2)-x;\\n        }\\n        return dp[i][preparity]=max(pick,notpick);\\n     }\\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(dp,-1,sizeof(dp));\\n        return nums[0]+f(nums,1,x,nums[0]%2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802160,
                "title": "house-robber-approach-using-chunks-of-same-parities-c-o-n-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        if(nums.size() == 1) return nums[0]; // one element !\\n        \\n        // a vector to store the chunks of same parity element\\'s sum... \\n        vector<long long> v;\\n        int i = 0;\\n        //  iterating over the array, and adding the same parity elements, pushing in new vector \\'v\\'\\n        while(i < nums.size()){\\n            long long sum = nums[i];\\n            while(i < nums.size()-1 && (nums[i])%2 == (nums[i+1])%2){\\n                sum += nums[i+1];\\n                i++;\\n            }\\n            \\n            v.push_back(sum);\\n            i++;\\n        }\\n        \\n        //  now the house robber type approach starts...\\n        //  two variables, for both the parities in current position\\n        long long p1 = v[0], p2 = v[0] - x; \\n        //  initially, one parity will be the first char\\n        //  another will be (first one - x)\\n        for(int i = 1; i < v.size(); i++){\\n            //  if current position is even position, the first parity will be updated...\\n            if(i%2 == 0){\\n                p1 = max(p1 + v[i], p2 + v[i] - x); \\n            } //  else the second one will be updated...\\n            else{\\n                p2 = max(p2 + v[i], p1 + v[i] - x);\\n            }\\n            \\n        }\\n        \\n        return max(p1, p2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        if(nums.size() == 1) return nums[0]; // one element !\\n        \\n        // a vector to store the chunks of same parity element\\'s sum... \\n        vector<long long> v;\\n        int i = 0;\\n        //  iterating over the array, and adding the same parity elements, pushing in new vector \\'v\\'\\n        while(i < nums.size()){\\n            long long sum = nums[i];\\n            while(i < nums.size()-1 && (nums[i])%2 == (nums[i+1])%2){\\n                sum += nums[i+1];\\n                i++;\\n            }\\n            \\n            v.push_back(sum);\\n            i++;\\n        }\\n        \\n        //  now the house robber type approach starts...\\n        //  two variables, for both the parities in current position\\n        long long p1 = v[0], p2 = v[0] - x; \\n        //  initially, one parity will be the first char\\n        //  another will be (first one - x)\\n        for(int i = 1; i < v.size(); i++){\\n            //  if current position is even position, the first parity will be updated...\\n            if(i%2 == 0){\\n                p1 = max(p1 + v[i], p2 + v[i] - x); \\n            } //  else the second one will be updated...\\n            else{\\n                p2 = max(p2 + v[i], p1 + v[i] - x);\\n            }\\n            \\n        }\\n        \\n        return max(p1, p2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802085,
                "title": "c-check-for-even-even-and-odd-odd",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int f(int &x)\\n    {\\n        if(x%2==1)\\n            return 1;\\n        return 0;\\n    }\\n    ll f(ll i,vector<int> &nums,int prev,int &x,vector<vector<ll>> &mp)\\n    {\\n        ll n=nums.size();\\n        if(i>=n)\\n            return 0;\\n        if(mp[i][prev]!=-1)\\n        return mp[i][prev];\\n        ll take=-1e8;\\n       if((f(nums[i])==1 and prev==1) or (f(nums[i])==0 and prev==0))\\n       {\\n           take=nums[i]+f(i+1,nums,(nums[i]%2==1)?1:0,x,mp);\\n       }\\n         else\\n            take=(nums[i]-x)+f(i+1,nums,(nums[i]%2==1)?1:0,x,mp);\\n        ll nottake=f(i+1,nums,prev,x,mp);\\n        return mp[i][prev]=max(take,nottake);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n         vector<vector<ll>> mp(n,vector<ll>(2,-1));\\n        return f(1,nums,(nums[0]%2==1)?1:0,x,mp)+nums[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int f(int &x)\\n    {\\n        if(x%2==1)\\n            return 1;\\n        return 0;\\n    }\\n    ll f(ll i,vector<int> &nums,int prev,int &x,vector<vector<ll>> &mp)\\n    {\\n        ll n=nums.size();\\n        if(i>=n)\\n            return 0;\\n        if(mp[i][prev]!=-1)\\n        return mp[i][prev];\\n        ll take=-1e8;\\n       if((f(nums[i])==1 and prev==1) or (f(nums[i])==0 and prev==0))\\n       {\\n           take=nums[i]+f(i+1,nums,(nums[i]%2==1)?1:0,x,mp);\\n       }\\n         else\\n            take=(nums[i]-x)+f(i+1,nums,(nums[i]%2==1)?1:0,x,mp);\\n        ll nottake=f(i+1,nums,prev,x,mp);\\n        return mp[i][prev]=max(take,nottake);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n         vector<vector<ll>> mp(n,vector<ll>(2,-1));\\n        return f(1,nums,(nums[0]%2==1)?1:0,x,mp)+nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802082,
                "title": "python-medium-prefix-sum",
                "content": "# Intuition\\ngreedily look at last even and last odd number\\'s index, they will yield the highest result\\n\\n# Approach\\nprefix sum, keeping track of last odd and last even index\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        N = len(nums)\\n        pref = [0] * N\\n\\n        pref[0] = nums[0]\\n\\n        lastEven = 0\\n        lastOdd = 0\\n\\n       \\n\\n\\n        for i in range(1, len(nums)):\\n            \\n            pref[i] = pref[lastEven] + nums[i] - (((nums[lastEven] + nums[i]) % 2) * x)\\n\\n            pref[i] = max(pref[i], pref[lastOdd] + nums[i] - (((nums[lastOdd] + nums[i]) % 2) * x))\\n\\n\\n            if nums[i] % 2:\\n                lastOdd = i\\n\\n            else:\\n                lastEven = i\\n\\n        return max(pref)\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        N = len(nums)\\n        pref = [0] * N\\n\\n        pref[0] = nums[0]\\n\\n        lastEven = 0\\n        lastOdd = 0\\n\\n       \\n\\n\\n        for i in range(1, len(nums)):\\n            \\n            pref[i] = pref[lastEven] + nums[i] - (((nums[lastEven] + nums[i]) % 2) * x)\\n\\n            pref[i] = max(pref[i], pref[lastOdd] + nums[i] - (((nums[lastOdd] + nums[i]) % 2) * x))\\n\\n\\n            if nums[i] % 2:\\n                lastOdd = i\\n\\n            else:\\n                lastEven = i\\n\\n        return max(pref)\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802063,
                "title": "c-recursive-and-memoization-dp-pick-not-pick-intuitive",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Recursive\\n    // long long f(int i,vector<int>&nums,int x,int n,int last){\\n    //     //The stuffs\\n    //     if(i==n)return 0;\\n    //     long long pick=0,notpick=0;\\n    //         if((last==0&&nums[i]%2==0)||(last!=0&&nums[i]%2!=0)){\\n    //             pick=nums[i]+f(i+1,nums,x,n,last);\\n    //         }\\n    //         else {\\n    //             pick=nums[i]+f(i+1,nums,x,n,nums[i]%2)-x;\\n    //         }\\n    //         notpick=f(i+1,nums,x,n,last);\\n    //     return max(pick,notpick);\\n    // }\\n    // long long maxScore(vector<int>& nums, int x) {\\n    //     int n=nums.size();\\n    //     return f(0,nums,x,n,nums[0]%2);\\n    // }\\n\\n\\n\\n    //Memoization\\n     long long f(int i,vector<int>&nums,int x,int n,int last,vector<vector<long long>>&dp){\\n        //The stuffs\\n        if(i==n)return 0;\\n        if(dp[i][last]!=-1)return dp[i][last];\\n        long long pick=0,notpick=0;\\n            if((last==0&&nums[i]%2==0)||(last!=0&&nums[i]%2!=0)){\\n                pick=nums[i]+f(i+1,nums,x,n,last,dp);\\n            }\\n            else {\\n                pick=nums[i]+f(i+1,nums,x,n,nums[i]%2,dp)-x;\\n            }\\n            notpick=f(i+1,nums,x,n,last,dp);\\n        return dp[i][last]=max(pick,notpick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<long long>> dp(nums.size(),vector<long long>(2,-1));\\n        return f(0,nums,x,n,nums[0]%2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Recursive\\n    // long long f(int i,vector<int>&nums,int x,int n,int last){\\n    //     //The stuffs\\n    //     if(i==n)return 0;\\n    //     long long pick=0,notpick=0;\\n    //         if((last==0&&nums[i]%2==0)||(last!=0&&nums[i]%2!=0)){\\n    //             pick=nums[i]+f(i+1,nums,x,n,last);\\n    //         }\\n    //         else {\\n    //             pick=nums[i]+f(i+1,nums,x,n,nums[i]%2)-x;\\n    //         }\\n    //         notpick=f(i+1,nums,x,n,last);\\n    //     return max(pick,notpick);\\n    // }\\n    // long long maxScore(vector<int>& nums, int x) {\\n    //     int n=nums.size();\\n    //     return f(0,nums,x,n,nums[0]%2);\\n    // }\\n\\n\\n\\n    //Memoization\\n     long long f(int i,vector<int>&nums,int x,int n,int last,vector<vector<long long>>&dp){\\n        //The stuffs\\n        if(i==n)return 0;\\n        if(dp[i][last]!=-1)return dp[i][last];\\n        long long pick=0,notpick=0;\\n            if((last==0&&nums[i]%2==0)||(last!=0&&nums[i]%2!=0)){\\n                pick=nums[i]+f(i+1,nums,x,n,last,dp);\\n            }\\n            else {\\n                pick=nums[i]+f(i+1,nums,x,n,nums[i]%2,dp)-x;\\n            }\\n            notpick=f(i+1,nums,x,n,last,dp);\\n        return dp[i][last]=max(pick,notpick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<long long>> dp(nums.size(),vector<long long>(2,-1));\\n        return f(0,nums,x,n,nums[0]%2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802002,
                "title": "c-solution-with-pick-not-pick-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxTotalScore(vector<int>& nums, int x, int i,int last_parity,vector<vector<long>>&dp) {\\n        if (i+1 == nums.size()) {\\n            return 0;\\n        }\\n        if(dp[i][last_parity]!=-1)return dp[i][last_parity];\\n        long long notpick = maxTotalScore(nums, x, i + 1, last_parity,dp);\\n        long long pick = INT_MIN;\\n        if(last_parity == nums[i+1] % 2){\\n            pick = nums[i+1]+maxTotalScore(nums, x, i + 1, last_parity,dp);\\n            \\n        }\\n        else{\\n            pick = maxTotalScore(nums, x, i + 1, nums[i+1]%2,dp)-x +nums[i+1];\\n        }\\n        return dp[i][last_parity]=max(pick, notpick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long>>dp(nums.size(),vector<long>(2,-1));\\n        return nums[0]+maxTotalScore(nums, x, 0,nums[0] % 2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxTotalScore(vector<int>& nums, int x, int i,int last_parity,vector<vector<long>>&dp) {\\n        if (i+1 == nums.size()) {\\n            return 0;\\n        }\\n        if(dp[i][last_parity]!=-1)return dp[i][last_parity];\\n        long long notpick = maxTotalScore(nums, x, i + 1, last_parity,dp);\\n        long long pick = INT_MIN;\\n        if(last_parity == nums[i+1] % 2){\\n            pick = nums[i+1]+maxTotalScore(nums, x, i + 1, last_parity,dp);\\n            \\n        }\\n        else{\\n            pick = maxTotalScore(nums, x, i + 1, nums[i+1]%2,dp)-x +nums[i+1];\\n        }\\n        return dp[i][last_parity]=max(pick, notpick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long>>dp(nums.size(),vector<long>(2,-1));\\n        return nums[0]+maxTotalScore(nums, x, 0,nums[0] % 2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801984,
                "title": "recursion-with-memoization-c",
                "content": "# Intuition\\nWe have to try out all possible combinations. So we will have to recursively consider all possibilities.\\n\\n# Approach\\nI am using a 2-d dp array with simple pick not pick logic. The flag is basically to test the parity of the number at that index. \\n\\n# Complexity\\n- Time complexity:\\nO(2*n)\\n\\n- Space complexity:\\nO(2*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long f(int idx, vector<int>& nums, bool flag, int x, vector<vector<long long>>& dp) {\\n        if(idx == nums.size()) return 0;\\n        if(dp[idx][flag] != -1) return dp[idx][flag];\\n        long long skip = f(idx+1, nums, flag, x, dp);\\n        \\n        long long take = 0;\\n        bool check = (nums[idx]%2 == 0);\\n        \\n        if(!(flag ^ check)) \\n            take = nums[idx] + f(idx+1, nums, flag, x, dp);\\n        else\\n            take = nums[idx] - x + f(idx+1, nums, !flag, x, dp);\\n        \\n        return dp[idx][flag] = max(skip, take);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(2, -1));\\n        bool flag = (nums[0]%2 == 0);\\n        \\n        return f(1, nums, flag, x, dp) + nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(int idx, vector<int>& nums, bool flag, int x, vector<vector<long long>>& dp) {\\n        if(idx == nums.size()) return 0;\\n        if(dp[idx][flag] != -1) return dp[idx][flag];\\n        long long skip = f(idx+1, nums, flag, x, dp);\\n        \\n        long long take = 0;\\n        bool check = (nums[idx]%2 == 0);\\n        \\n        if(!(flag ^ check)) \\n            take = nums[idx] + f(idx+1, nums, flag, x, dp);\\n        else\\n            take = nums[idx] - x + f(idx+1, nums, !flag, x, dp);\\n        \\n        return dp[idx][flag] = max(skip, take);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n, vector<long long>(2, -1));\\n        bool flag = (nums[0]%2 == 0);\\n        \\n        return f(1, nums, flag, x, dp) + nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801912,
                "title": "java-dp-solution",
                "content": "\\n# Approach\\nJust keep track of Max of odd numbers and max of even numbers.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long oddmax = Integer.MIN_VALUE;\\n        long evenmax = Integer.MIN_VALUE;\\n        if(nums[0] % 2 == 0) evenmax = nums[0];\\n        else oddmax = nums[0];\\n\\n        long answer = Long.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i] % 2 == 0){\\n                evenmax = Math.max(evenmax,Math.max(evenmax+nums[i],oddmax+nums[i]-x));\\n            }\\n            else{\\n                oddmax = Math.max(oddmax,Math.max(oddmax+nums[i],evenmax+nums[i]-x));\\n            }\\n        }\\n        return Math.max(oddmax,evenmax);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long oddmax = Integer.MIN_VALUE;\\n        long evenmax = Integer.MIN_VALUE;\\n        if(nums[0] % 2 == 0) evenmax = nums[0];\\n        else oddmax = nums[0];\\n\\n        long answer = Long.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i] % 2 == 0){\\n                evenmax = Math.max(evenmax,Math.max(evenmax+nums[i],oddmax+nums[i]-x));\\n            }\\n            else{\\n                oddmax = Math.max(oddmax,Math.max(oddmax+nums[i],evenmax+nums[i]-x));\\n            }\\n        }\\n        return Math.max(oddmax,evenmax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801905,
                "title": "python-simple-solution",
                "content": "\\n\\'\\'\\'\\n\\n\\tdef maxScore(self, nums: List[int], x: int) -> int:\\n\\t\\tn = len(nums)\\n\\n\\t\\tdef par(num1, num2):\\n\\t\\t\\treturn (num1 % 2 == num2 % 2)\\n\\n\\t\\t@lru_cache(None)\\n\\t\\tdef solve(ind, prev):\\n\\t\\t\\tif ind == n:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tnotTake = solve(ind + 1, prev)\\n\\t\\t\\ttake = nums[ind] + solve(ind + 1, nums[ind]%2)\\n\\n\\t\\t\\tif par(nums[ind], prev) == False:\\n\\t\\t\\t\\ttake -= x\\n\\n\\t\\t\\treturn max(take, notTake)\\n\\n\\n\\t\\tres = nums[0] + solve(1, nums[0])\\n\\t\\treturn res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\'\\'\\'\\n\\n\\tdef maxScore(self, nums: List[int], x: int) -> int:\\n\\t\\tn = len(nums)\\n\\n\\t\\tdef par(num1, num2):\\n\\t\\t\\treturn (num1 % 2 == num2 % 2)\\n\\n\\t\\t@lru_cache(None)\\n\\t\\tdef solve(ind, prev):\\n\\t\\t\\tif ind == n:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tnotTake = solve(ind + 1, prev)\\n\\t\\t\\ttake = nums[ind] + solve(ind + 1, nums[ind]%2)\\n\\n\\t\\t\\tif par(nums[ind], prev) == False:\\n\\t\\t\\t\\ttake -= x\\n\\n\\t\\t\\treturn max(take, notTake)\\n\\n\\n\\t\\tres = nums[0] + solve(1, nums[0])\\n\\t\\treturn res\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3801871,
                "title": "video-explanation-top-down-bottom-up-in-o-1-space",
                "content": "# Explanation\\n\\n[Click here for the video link]()\\n\\n# Code\\n```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    \\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        \\n        ll max_odd = 0, max_evn = 0;\\n        for (int j = n-1; j >= 0; j --) {\\n            ll nxt_odd, nxt_evn;\\n            if (nums[j] % 2 == 0) {\\n                nxt_odd = nums[j] + max_odd - x;\\n                nxt_evn = nums[j] + max_evn;\\n            }\\n            else {\\n                nxt_odd = nums[j] + max_odd;\\n                nxt_evn = nums[j] + max_evn - x;\\n            }\\n            \\n            ll cur = max(nxt_odd, nxt_evn);\\n            if (nums[j] % 2 == 0) {\\n                max_evn = max (max_evn, cur);\\n            }\\n            else {\\n                max_odd = max (max_odd, cur);\\n            }\\n        }\\n        \\n        return (nums[0] % 2 == 0)? max_evn : max_odd;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    \\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        \\n        ll max_odd = 0, max_evn = 0;\\n        for (int j = n-1; j >= 0; j --) {\\n            ll nxt_odd, nxt_evn;\\n            if (nums[j] % 2 == 0) {\\n                nxt_odd = nums[j] + max_odd - x;\\n                nxt_evn = nums[j] + max_evn;\\n            }\\n            else {\\n                nxt_odd = nums[j] + max_odd;\\n                nxt_evn = nums[j] + max_evn - x;\\n            }\\n            \\n            ll cur = max(nxt_odd, nxt_evn);\\n            if (nums[j] % 2 == 0) {\\n                max_evn = max (max_evn, cur);\\n            }\\n            else {\\n                max_odd = max (max_odd, cur);\\n            }\\n        }\\n        \\n        return (nums[0] % 2 == 0)? max_evn : max_odd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801821,
                "title": "o-n-java-python-with-explanation",
                "content": "### Python:\\n```\\ndef maxScore(self, nums: List[int], x: int) -> int:\\n        starting_with_odd, starting_with_even = 0, 0\\n\\n        if nums[0] % 2 == 0:\\n            starting_with_odd = -x\\n\\n        if nums[0] % 2 != 0:\\n            starting_with_even = -x\\n\\n        for n in nums:\\n            if n % 2 == 1:\\n                starting_with_odd = max(starting_with_odd + n, starting_with_even + (n - x))\\n            else:\\n                starting_with_even = max(starting_with_even + n, starting_with_odd + (n - x))\\n\\n        return max(starting_with_odd, starting_with_even)\\n```\\n### Java:\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long startingWithOdd = 0l, startingWithEven = 0l;\\n        if (nums[0] % 2 == 0) {\\n            startingWithOdd = -x;\\n        }\\n        if (nums[0] % 2 != 0) {\\n            startingWithEven = -x;\\n        }\\n\\n        for (int n : nums) {\\n            if (n%2 == 1) {\\n                startingWithOdd = Math.max(startingWithOdd + n, startingWithEven + (n - x));\\n            } else {\\n                startingWithEven = Math.max(startingWithEven + n, startingWithOdd + (n - x));\\n            }\\n        }\\n        \\n        return Math.max(startingWithOdd, startingWithEven);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ndef maxScore(self, nums: List[int], x: int) -> int:\\n        starting_with_odd, starting_with_even = 0, 0\\n\\n        if nums[0] % 2 == 0:\\n            starting_with_odd = -x\\n\\n        if nums[0] % 2 != 0:\\n            starting_with_even = -x\\n\\n        for n in nums:\\n            if n % 2 == 1:\\n                starting_with_odd = max(starting_with_odd + n, starting_with_even + (n - x))\\n            else:\\n                starting_with_even = max(starting_with_even + n, starting_with_odd + (n - x))\\n\\n        return max(starting_with_odd, starting_with_even)\\n```\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long startingWithOdd = 0l, startingWithEven = 0l;\\n        if (nums[0] % 2 == 0) {\\n            startingWithOdd = -x;\\n        }\\n        if (nums[0] % 2 != 0) {\\n            startingWithEven = -x;\\n        }\\n\\n        for (int n : nums) {\\n            if (n%2 == 1) {\\n                startingWithOdd = Math.max(startingWithOdd + n, startingWithEven + (n - x));\\n            } else {\\n                startingWithEven = Math.max(startingWithEven + n, startingWithOdd + (n - x));\\n            }\\n        }\\n        \\n        return Math.max(startingWithOdd, startingWithEven);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801790,
                "title": "take-not-take-memoization-easy-to-read-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long dp[100001][2];\\n    long long mod=1e9+7;\\n    \\n    long long solve(int ind, vector<int>& nums, int x, int prev){\\n        if(ind>=nums.size()) return 0;\\n        if(dp[ind][prev] != -1) return dp[ind][prev];\\n        \\n        long long not_take=0,take=0;\\n        not_take= solve(ind+1,nums,x,prev);\\n        \\n        take = (nums[ind] + (prev == nums[ind]%2 ? 0:-x) + solve(ind+1,nums,x,nums[ind]%2));\\n        \\n        return dp[ind][prev]=max(not_take,take);\\n    }\\n    \\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        long long ans= solve(1,nums,x,nums[0]%2)+nums[0];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long dp[100001][2];\\n    long long mod=1e9+7;\\n    \\n    long long solve(int ind, vector<int>& nums, int x, int prev){\\n        if(ind>=nums.size()) return 0;\\n        if(dp[ind][prev] != -1) return dp[ind][prev];\\n        \\n        long long not_take=0,take=0;\\n        not_take= solve(ind+1,nums,x,prev);\\n        \\n        take = (nums[ind] + (prev == nums[ind]%2 ? 0:-x) + solve(ind+1,nums,x,nums[ind]%2));\\n        \\n        return dp[ind][prev]=max(not_take,take);\\n    }\\n    \\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        long long ans= solve(1,nums,x,nums[0]%2)+nums[0];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801771,
                "title": "0-1-knapsack-simple-python-solution",
                "content": "Hello fellow Leetcoders, this contest was my first 4/4 ever. After grinding every day for the past 3 months, I think the practice is finally paying off. Here is my solution for this problem. I hope it helps. :>\\n\\nBasically, we go through each index carrying the information of the parity of our previous value. 1 == odd, 0 == even. We penalize accordingly when we take index i. :>\\n\\n```python\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i, prev):\\n            if i == n:\\n                return 0\\n            \\n            skip = dp(i + 1, prev)\\n            take = nums[i] + dp(i + 1, nums[i] % 2)\\n            if prev % 2 != nums[i] % 2:\\n                take -= x\\n            return max(skip, take)\\n        \\n        return nums[0] + dp(1, nums[0] % 2)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i, prev):\\n            if i == n:\\n                return 0\\n            \\n            skip = dp(i + 1, prev)\\n            take = nums[i] + dp(i + 1, nums[i] % 2)\\n            if prev % 2 != nums[i] % 2:\\n                take -= x\\n            return max(skip, take)\\n        \\n        return nums[0] + dp(1, nums[0] % 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801765,
                "title": "c-efficient-dp-solution-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we move to same parity element, it makes absolute sense to move since it will always increase the score since all the elements of $$nums$$ array are positive. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each element in the dp array, we store the scores for both the parities. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector < pair<long long, long long> > dp (nums.size(), {0,0}); //even, odd\\n        int n = nums.size();\\n        if (nums[n-1] % 2 == 0){\\n            dp[n-1].first = nums[n-1];\\n        }\\n        else{\\n            dp[n-1].second = nums[n-1];\\n        }\\n        long long deduct = x;\\n        for (int i=n-2; i>=0; i--){\\n            long long temp = nums[i];\\n            if (nums[i] % 2 == 0){ \\n                //even\\n                dp[i].first = max (dp[i].first, max(temp+dp[i+1].first, temp+dp[i+1].second-deduct));\\n                dp[i].second = dp[i+1].second;\\n            }\\n            else{\\n                //odd\\n                dp[i].first = dp[i+1].first;\\n                dp[i].second = max (dp[i].second, max(temp+dp[i+1].second, temp+dp[i+1].first-deduct));\\n            }                      \\n        }\\n        if (nums[0] % 2 == 0) return dp[0].first;\\n        return dp[0].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector < pair<long long, long long> > dp (nums.size(), {0,0}); //even, odd\\n        int n = nums.size();\\n        if (nums[n-1] % 2 == 0){\\n            dp[n-1].first = nums[n-1];\\n        }\\n        else{\\n            dp[n-1].second = nums[n-1];\\n        }\\n        long long deduct = x;\\n        for (int i=n-2; i>=0; i--){\\n            long long temp = nums[i];\\n            if (nums[i] % 2 == 0){ \\n                //even\\n                dp[i].first = max (dp[i].first, max(temp+dp[i+1].first, temp+dp[i+1].second-deduct));\\n                dp[i].second = dp[i+1].second;\\n            }\\n            else{\\n                //odd\\n                dp[i].first = dp[i+1].first;\\n                dp[i].second = max (dp[i].second, max(temp+dp[i+1].second, temp+dp[i+1].first-deduct));\\n            }                      \\n        }\\n        if (nums[0] % 2 == 0) return dp[0].first;\\n        return dp[0].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801721,
                "title": "every-step-explained-easy-dp-solution-optimised-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChecking parity of previous element taken\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long helper(int ind, vector<int>& nums, int x, int parity, vector<vector<long long>>& dp) {\\n// IF WE GO BEYOND ARRAY THEN RETURN \\n        if (ind == nums.size())\\n            return 0;\\n\\n        if (dp[ind][parity] != -1)\\n            return dp[ind][parity];\\n\\n        long long take = nums[ind] + helper(ind + 1, nums, x, nums[ind] % 2, dp);\\n// IF TAKEN CHECK IF IT HAS DIFFERENT PARITY OF NOT\\n        if (nums[ind] % 2 != parity)\\n            take -= x;\\n\\n        long long notTake = helper(ind + 1, nums, x, parity, dp);\\n\\n        return dp[ind][parity] = max(take, notTake);\\n    }\\n\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size(), vector<long long>(2, -1));\\n        return helper(0, nums, x, nums[0] % 2, dp);\\n    }\\n};\\n\\n// PlZ UPVOTE IF YOU LIKE IT\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(int ind, vector<int>& nums, int x, int parity, vector<vector<long long>>& dp) {\\n// IF WE GO BEYOND ARRAY THEN RETURN \\n        if (ind == nums.size())\\n            return 0;\\n\\n        if (dp[ind][parity] != -1)\\n            return dp[ind][parity];\\n\\n        long long take = nums[ind] + helper(ind + 1, nums, x, nums[ind] % 2, dp);\\n// IF TAKEN CHECK IF IT HAS DIFFERENT PARITY OF NOT\\n        if (nums[ind] % 2 != parity)\\n            take -= x;\\n\\n        long long notTake = helper(ind + 1, nums, x, parity, dp);\\n\\n        return dp[ind][parity] = max(take, notTake);\\n    }\\n\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size(), vector<long long>(2, -1));\\n        return helper(0, nums, x, nums[0] % 2, dp);\\n    }\\n};\\n\\n// PlZ UPVOTE IF YOU LIKE IT\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801707,
                "title": "c-dp-solution",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& a, int x) {\\n        const int n = (int)a.size();\\n        vector<array<int, 2>> nxt(n);\\n        int e = n, o = n;\\n        for (int i = n - 1; i >= 0; i--) {\\n            nxt[i][0] = e, nxt[i][1] = o;\\n            if (a[i] & 1) o = i;\\n            else e = i;\\n        }\\n        vector<int64_t> dp(n + 1, -1e9);\\n        for (int i = n; i >= 0; i--) {\\n            if (i == n) {\\n                dp[i] = 0;\\n            } else {\\n                int p = a[i] & 1;\\n                dp[i] = max(dp[nxt[i][p]], dp[nxt[i][1 - p]] - x) + a[i];\\n            }\\n        }\\n        return dp.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& a, int x) {\\n        const int n = (int)a.size();\\n        vector<array<int, 2>> nxt(n);\\n        int e = n, o = n;\\n        for (int i = n - 1; i >= 0; i--) {\\n            nxt[i][0] = e, nxt[i][1] = o;\\n            if (a[i] & 1) o = i;\\n            else e = i;\\n        }\\n        vector<int64_t> dp(n + 1, -1e9);\\n        for (int i = n; i >= 0; i--) {\\n            if (i == n) {\\n                dp[i] = 0;\\n            } else {\\n                int p = a[i] & 1;\\n                dp[i] = max(dp[nxt[i][p]], dp[nxt[i][1 - p]] - x) + a[i];\\n            }\\n        }\\n        return dp.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801687,
                "title": "c-easy-to-understand-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums,int x,int ind,vector<long long>&dp)\\n    {\\n        if(ind==nums.size()) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        long long ans=0;\\n        for(int i=ind+1;i<nums.size();i++)\\n        {\\n            if((nums[i]%2==0 and nums[ind]%2==0 ) or (nums[i]%2==1 and nums[ind]%2==1))\\n            {\\n               ans=max(ans,nums[i]+solve(nums,x,i,dp));\\n                break;\\n            }\\n            else \\n            {\\n                ans=max(ans,nums[i]-x+solve(nums,x,i,dp));\\n            }    \\n        }\\n        return dp[ind]=ans;\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<long long>dp(nums.size(),-1);\\n        return solve(nums,x,0,dp)+nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums,int x,int ind,vector<long long>&dp)\\n    {\\n        if(ind==nums.size()) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        long long ans=0;\\n        for(int i=ind+1;i<nums.size();i++)\\n        {\\n            if((nums[i]%2==0 and nums[ind]%2==0 ) or (nums[i]%2==1 and nums[ind]%2==1))\\n            {\\n               ans=max(ans,nums[i]+solve(nums,x,i,dp));\\n                break;\\n            }\\n            else \\n            {\\n                ans=max(ans,nums[i]-x+solve(nums,x,i,dp));\\n            }    \\n        }\\n        return dp[ind]=ans;\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<long long>dp(nums.size(),-1);\\n        return solve(nums,x,0,dp)+nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801685,
                "title": "only-carries-the-odd-maximum-and-the-even-maximum",
                "content": "# Approach\\nSince you can go to any index $j>i$ then the only thing that matters is the best odd/even answer since we only decrease the score in case of different parity. So it is only necessary to have those max values and finally return the one that matches $nums[0]$.\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long maxEven = 0,maxOdd = 0;\\n        \\n        for(int i = n-1;i>=0;i--){\\n            if(nums[i]&1)\\n                maxOdd = max(maxOdd+nums[i],maxEven+nums[i]-x);\\n            else\\n                maxEven = max(maxEven+nums[i],maxOdd+nums[i]-x);\\n        }\\n        \\n        if(nums[0]&1)return maxOdd;\\n        return maxEven;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long maxEven = 0,maxOdd = 0;\\n        \\n        for(int i = n-1;i>=0;i--){\\n            if(nums[i]&1)\\n                maxOdd = max(maxOdd+nums[i],maxEven+nums[i]-x);\\n            else\\n                maxEven = max(maxEven+nums[i],maxOdd+nums[i]-x);\\n        }\\n        \\n        if(nums[0]&1)return maxOdd;\\n        return maxEven;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092560,
                "title": "simple-dp-time-o-n-space-o-1",
                "content": "class Solution(object):\\n    def maxScore(self, nums, x):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        odd = 0\\n        even = 0\\n        n = len(nums)\\n        \\n        for i in range(n-1,0,-1):\\n            if nums[i] & 1:\\n                odd = max(odd + nums[i], even + nums[i] - x)\\n            else:\\n                even = max(even + nums[i], odd + nums[i] - x)\\n        \\n        #print odd, even\\n        \\n        if nums[0] & 1:\\n            return nums[0] + max(odd, even - x)\\n        else:\\n            return nums[0] + max(even, odd - x)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxScore(self, nums, x):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        odd = 0\\n        even = 0\\n        n = len(nums)\\n        \\n        for i in range(n-1,0,-1):\\n            if nums[i] & 1:\\n                odd = max(odd + nums[i], even + nums[i] - x)\\n            else:\\n                even = max(even + nums[i], odd + nums[i] - x)\\n        \\n        #print odd, even\\n        \\n        if nums[0] & 1:\\n            return nums[0] + max(odd, even - x)\\n        else:\\n            return nums[0] + max(even, odd - x)",
                "codeTag": "Java"
            },
            {
                "id": 4086114,
                "title": "clean-bottom-up-dp-o-1-memory-beats-100",
                "content": "\\n# Approach\\nWe\\'ll maintain only two variables: `even` and `odd`, which will store what is the biggest possible achievable score if the last element you picked was even and odd, respectively. \\n\\nThere are only two cases we need to consider to make the dynamic programming transitions:\\n\\n- `nums[i]` is even\\nIn this case, no change is made to `odd`, and `even` is updated as: `even = nums[i]+max(even, odd-x)`, since we can either use the biggest sum such that the last element was even, or the biggest sum such that the last element was odd and lose a score of `x`.\\n- `nums[i]` is odd\\nThe approach is the exact same: `even` is not updated, and `odd = nums[i]+max(odd, even-x)`.\\n\\nSince we always visit position 0, we can define the case to be:\\n\\n `even = nums[0], odd = -INF` $\\\\iff$ `nums[0]` is even.\\n\\nand\\n\\n `even = -INF, odd = nums[0]` $\\\\iff$ `nums[0]` is odd.\\n\\nThe answer will be the maximum between `even` and `odd`.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$\\\\text{O}(n)$\\n\\n- Space complexity:\\n$\\\\text{O}(1)$\\n\\n# Code\\nWarning: I\\'m using bitwise operators to check the parity, since they are way faster than using the modulo operator, without it, it beats 90% instead of 100%, just have in mind that `nums[i]&1 == nums[i]%2`.\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n\\n        long INF = (int)1e15;\\n\\n        long even=(nums[0]&1) == 0 ? nums[0] : -INF;\\n        long odd=(nums[0]&1) == 1 ? nums[0] : -INF;\\n\\n        for(int i = 1; i < nums.length; i++){\\n\\n            if((nums[i]&1) == 0)\\n                even = nums[i]+Math.max(even, odd-x);\\n            \\n            else\\n                odd = nums[i]+Math.max(odd, even-x);\\n\\n        }\\n        return Math.max(even, odd);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n\\n        long INF = (int)1e15;\\n\\n        long even=(nums[0]&1) == 0 ? nums[0] : -INF;\\n        long odd=(nums[0]&1) == 1 ? nums[0] : -INF;\\n\\n        for(int i = 1; i < nums.length; i++){\\n\\n            if((nums[i]&1) == 0)\\n                even = nums[i]+Math.max(even, odd-x);\\n            \\n            else\\n                odd = nums[i]+Math.max(odd, even-x);\\n\\n        }\\n        return Math.max(even, odd);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017836,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "### dynamic programming - choose or not\\ndfs(i, is_odd) is max score we can get in nums[i:] and is_odd is if number we take last time is odd or not.\\n\\nif current number nums[i]\\'s parity is the same as the number we take last time,\\nwe should choose it.\\n\\nif not, we have 2 options, choose or skip it.\\nif we choose it, we get nums[i] - x score, and parity of last number will be changed.\\nif we skip it, we get nothing, keep parity.\\n\\n\\ndfs(i, is_odd) = nums[i] + dfs(i+1, is_odd) if nums[i] % 2 == is_odd\\nor\\ndfs(i, is_odd) = max(nums[i] - x + dfs(i+1, nums[i] % 2), dfs(i+1, is_odd)).\\n\\ntc is O(n), sc is O(n).\\n\\n### python\\n```python\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        size = len(nums)\\n        @cache\\n        def dfs(i, is_odd):\\n            if i == size: return 0\\n            y = nums[i]\\n            if y % 2 == is_odd:\\n                return y + dfs(i+1, is_odd)\\n            return max(dfs(i+1, is_odd), y - x + dfs(i+1, y % 2))\\n        return dfs(0, nums[0] % 2)\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int size = nums.size();\\n        vector<vector<long long>> dp (size, vector<long long> (2, LLONG_MIN));\\n        function<long long(int, int)> dfs = [&] (int i, int is_odd) {\\n            if (i == size) return 0LL;\\n            if (dp[i][is_odd] != LLONG_MIN) return dp[i][is_odd];\\n            if (nums[i] % 2 == is_odd) return nums[i] + dfs(i+1, is_odd);\\n            long long sub = max(nums[i] - x + dfs(i+1, is_odd ^ 1), dfs(i+1, is_odd));\\n            return dp[i][is_odd] = sub;\\n        };\\n        return dfs(0, nums[0] % 2);\\n    }\\n};\\n```\\n### space optimization\\n\\n### python\\n```python\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        dp_0 = [0, 0]\\n        dp_1 = [0, 0]\\n        for y in reversed(nums):\\n            dp_1[y % 2] = y + dp_0[y % 2]\\n            dp_1[(y % 2) ^ 1] = max(dp_0[(y % 2) ^ 1], y - x + dp_0[y % 2])\\n            dp_0, dp_1 = dp_1, dp_0\\n            dp_1[0] = dp_1[1] = 0\\n        return dp_0[nums[0] % 2]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int size = nums.size();\\n        long long dp_0[] {0LL, 0LL}, dp_1[] {0LL, 0LL};\\n        for (int i = size - 1; i >= 0; i-=1) {\\n            dp_1[nums[i] % 2] = dp_0[nums[i] % 2] + nums[i];\\n            dp_1[(nums[i] % 2) ^ 1] = max(nums[i] - x + dp_0[nums[i] % 2], dp_0[(nums[i] % 2) ^ 1]);\\n            swap(dp_0, dp_1);\\n            dp_1[0] = 0LL, dp_1[1] = 0LL;\\n        }\\n        return dp_0[nums[0] % 2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        size = len(nums)\\n        @cache\\n        def dfs(i, is_odd):\\n            if i == size: return 0\\n            y = nums[i]\\n            if y % 2 == is_odd:\\n                return y + dfs(i+1, is_odd)\\n            return max(dfs(i+1, is_odd), y - x + dfs(i+1, y % 2))\\n        return dfs(0, nums[0] % 2)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int size = nums.size();\\n        vector<vector<long long>> dp (size, vector<long long> (2, LLONG_MIN));\\n        function<long long(int, int)> dfs = [&] (int i, int is_odd) {\\n            if (i == size) return 0LL;\\n            if (dp[i][is_odd] != LLONG_MIN) return dp[i][is_odd];\\n            if (nums[i] % 2 == is_odd) return nums[i] + dfs(i+1, is_odd);\\n            long long sub = max(nums[i] - x + dfs(i+1, is_odd ^ 1), dfs(i+1, is_odd));\\n            return dp[i][is_odd] = sub;\\n        };\\n        return dfs(0, nums[0] % 2);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        dp_0 = [0, 0]\\n        dp_1 = [0, 0]\\n        for y in reversed(nums):\\n            dp_1[y % 2] = y + dp_0[y % 2]\\n            dp_1[(y % 2) ^ 1] = max(dp_0[(y % 2) ^ 1], y - x + dp_0[y % 2])\\n            dp_0, dp_1 = dp_1, dp_0\\n            dp_1[0] = dp_1[1] = 0\\n        return dp_0[nums[0] % 2]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int size = nums.size();\\n        long long dp_0[] {0LL, 0LL}, dp_1[] {0LL, 0LL};\\n        for (int i = size - 1; i >= 0; i-=1) {\\n            dp_1[nums[i] % 2] = dp_0[nums[i] % 2] + nums[i];\\n            dp_1[(nums[i] % 2) ^ 1] = max(nums[i] - x + dp_0[nums[i] % 2], dp_0[(nums[i] % 2) ^ 1]);\\n            swap(dp_0, dp_1);\\n            dp_1[0] = 0LL, dp_1[1] = 0LL;\\n        }\\n        return dp_0[nums[0] % 2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013754,
                "title": "easy-c-recursion-memoisation",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(2*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long dp[100001][2];\\n long long solve(int i,vector<int>& nums, int prev,bool flag,int x,int n)\\n {\\n    if(i==n) return 0;\\n    if(dp[i][flag]!=-1) return dp[i][flag];\\n     long long ans=0;\\n     if(flag==0){\\n     ans=max(nums[i]-x+solve(i+1,nums,nums[i],(nums[i]+nums[i+1])%2==0?1:0,x,n),solve(i+1,nums,prev,(prev+nums[i+1])%2==0?1:0,x,n));\\n     }\\n     else{\\n     ans=max(solve(i+1,nums,prev,(prev+nums[i+1])%2==0?1:0,x,n),nums[i]+solve(i+1,nums,nums[i],(nums[i]+nums[i+1])%2==0?1:0,x,n));}\\n     return dp[i][flag]=ans;\\n }\\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=nums.size();\\n        nums.push_back(-1e6+1);\\n         return nums[0]+solve(1,nums,nums[0],(nums[0]+nums[1])%2==0?1:0,x,n );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long dp[100001][2];\\n long long solve(int i,vector<int>& nums, int prev,bool flag,int x,int n)\\n {\\n    if(i==n) return 0;\\n    if(dp[i][flag]!=-1) return dp[i][flag];\\n     long long ans=0;\\n     if(flag==0){\\n     ans=max(nums[i]-x+solve(i+1,nums,nums[i],(nums[i]+nums[i+1])%2==0?1:0,x,n),solve(i+1,nums,prev,(prev+nums[i+1])%2==0?1:0,x,n));\\n     }\\n     else{\\n     ans=max(solve(i+1,nums,prev,(prev+nums[i+1])%2==0?1:0,x,n),nums[i]+solve(i+1,nums,nums[i],(nums[i]+nums[i+1])%2==0?1:0,x,n));}\\n     return dp[i][flag]=ans;\\n }\\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=nums.size();\\n        nums.push_back(-1e6+1);\\n         return nums[0]+solve(1,nums,nums[0],(nums[0]+nums[1])%2==0?1:0,x,n );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990567,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>dp;\\n    long long solve(vector<int>& nums,int x,int i,int j){  // j = previous Parity\\n        if(i >= nums.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(i == 0)\\n            return dp[i][nums[i]%2] = nums[i] + solve(nums,x,i+1,nums[i]%2);\\n        long long take = nums[i] + solve(nums,x,i+1,nums[i]%2);\\n        if(j != nums[i]%2)\\n            take -= x;\\n        long long notTake = solve(nums,x,i+1,j);\\n        return dp[i][j] = max(take,notTake);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        dp = vector<vector<long long>>(nums.size(),vector<long long>(2,-1));\\n        return solve(nums,x,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>dp;\\n    long long solve(vector<int>& nums,int x,int i,int j){  // j = previous Parity\\n        if(i >= nums.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(i == 0)\\n            return dp[i][nums[i]%2] = nums[i] + solve(nums,x,i+1,nums[i]%2);\\n        long long take = nums[i] + solve(nums,x,i+1,nums[i]%2);\\n        if(j != nums[i]%2)\\n            take -= x;\\n        long long notTake = solve(nums,x,i+1,j);\\n        return dp[i][j] = max(take,notTake);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        dp = vector<vector<long long>>(nums.size(),vector<long long>(2,-1));\\n        return solve(nums,x,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987797,
                "title": "0-1-knapsack-dp-variation-clearly-explained",
                "content": "# Memoization\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n```\\nclass Solution {\\n    long long solve(int i, int prevParity, vector<int>& nums, int x, vector<vector<long long>>& dp)\\n    {\\n        if(i == nums.size())\\n         return 0;\\n\\n        if(dp[i][prevParity] != -1) //memoization step\\n         return dp[i][prevParity];\\n\\n        int currParity = nums[i]&1;\\n        //if prev choosen number and current number have same parity\\n        if(currParity == prevParity) //then, we should always pick current number to maximize the sum\\n         dp[i][prevParity] = nums[i] + solve(i+1,currParity,nums,x,dp);\\n        else\\n         { //otherwise, we have choice to pick (nums[i] - x) or skip nums[i]\\n            long long take = nums[i] - x + solve(i+1,currParity,nums,x,dp);\\n            long long notTake = solve(i+1,prevParity,nums,x,dp);\\n             dp[i][prevParity] = max(take,notTake); //take maximum of the 2 cases\\n         }\\n    return dp[i][prevParity];\\n    }\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size(),vector<long long>(2,-1));\\n        return nums[0] + solve(1,nums[0]&1,nums,x,dp);\\n    }\\n};\\n```\\n.\\n# O(1) Space solution\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long even = nums[0]%2 ? -1*x : nums[0];\\n        long long odd = nums[0]%2 ? nums[0] : -1*x;\\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i]%2)\\n             odd = nums[i] + max(odd,even-x);\\n            else\\n             even = nums[i] + max(even,odd-x);\\n        }\\n    return max(even,odd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long long solve(int i, int prevParity, vector<int>& nums, int x, vector<vector<long long>>& dp)\\n    {\\n        if(i == nums.size())\\n         return 0;\\n\\n        if(dp[i][prevParity] != -1) //memoization step\\n         return dp[i][prevParity];\\n\\n        int currParity = nums[i]&1;\\n        //if prev choosen number and current number have same parity\\n        if(currParity == prevParity) //then, we should always pick current number to maximize the sum\\n         dp[i][prevParity] = nums[i] + solve(i+1,currParity,nums,x,dp);\\n        else\\n         { //otherwise, we have choice to pick (nums[i] - x) or skip nums[i]\\n            long long take = nums[i] - x + solve(i+1,currParity,nums,x,dp);\\n            long long notTake = solve(i+1,prevParity,nums,x,dp);\\n             dp[i][prevParity] = max(take,notTake); //take maximum of the 2 cases\\n         }\\n    return dp[i][prevParity];\\n    }\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size(),vector<long long>(2,-1));\\n        return nums[0] + solve(1,nums[0]&1,nums,x,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long even = nums[0]%2 ? -1*x : nums[0];\\n        long long odd = nums[0]%2 ? nums[0] : -1*x;\\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i]%2)\\n             odd = nums[i] + max(odd,even-x);\\n            else\\n             even = nums[i] + max(even,odd-x);\\n        }\\n    return max(even,odd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986920,
                "title": "beats-95-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        int odd = -1;\\n        int even = -1;\\n        vector<long long> scores(n,0);\\n        for(int i =(n-1);i>=0;i--)\\n        {\\n            if((odd==-1)&(even==-1))\\n            {\\n                if(nums[i]%2==0)\\n                    even =i;\\n                else\\n                    odd =i;\\n                scores[i] = nums[i];\\n                continue;\\n            }\\n            if(odd==-1)\\n            {\\n                long long y = nums[i] +scores[even];\\n                int a = nums[i]%2;\\n                int b = nums[even]%2;\\n                if(a!=b)\\n                    y = y-x;\\n                if(y>nums[i])\\n                    scores[i] =y;\\n                else\\n                    scores[i] = nums[i];\\n                if(a==1)\\n                    odd =i;\\n                else\\n                    even =i;\\n                continue;\\n            }\\n            if(even==-1)\\n            {\\n                long long y = nums[i] +scores[odd];\\n                int a = nums[i]%2;\\n                int b = nums[odd]%2;\\n                if(a!=b)\\n                    y = y-x;\\n                if(y>nums[i])\\n                    scores[i] =y;\\n                else\\n                    scores[i] = nums[i];\\n                if(a==1)\\n                    odd =i;\\n                else\\n                    even =i;\\n                continue;\\n            }\\n            long long y = nums[i] +scores[odd];\\n            int a = nums[i]%2;\\n            int b = nums[odd]%2;\\n            if(a!=b)\\n                y = y-x;\\n            long long z = nums[i]+scores[even];\\n            int c = nums[even]%2;\\n            if(a!=c)\\n                z = z-x;\\n            z =  max(z,y);\\n            if(z>nums[i])\\n                scores[i]=z;\\n            else\\n                scores[i] = nums[i];\\n            if(a==1)\\n                odd =i;\\n            else\\n                even =i;\\n                \\n        }\\n        // for(int i =0;i<n;i++)\\n        //     cout<<scores[i]<<\" \";\\n        return scores[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        int odd = -1;\\n        int even = -1;\\n        vector<long long> scores(n,0);\\n        for(int i =(n-1);i>=0;i--)\\n        {\\n            if((odd==-1)&(even==-1))\\n            {\\n                if(nums[i]%2==0)\\n                    even =i;\\n                else\\n                    odd =i;\\n                scores[i] = nums[i];\\n                continue;\\n            }\\n            if(odd==-1)\\n            {\\n                long long y = nums[i] +scores[even];\\n                int a = nums[i]%2;\\n                int b = nums[even]%2;\\n                if(a!=b)\\n                    y = y-x;\\n                if(y>nums[i])\\n                    scores[i] =y;\\n                else\\n                    scores[i] = nums[i];\\n                if(a==1)\\n                    odd =i;\\n                else\\n                    even =i;\\n                continue;\\n            }\\n            if(even==-1)\\n            {\\n                long long y = nums[i] +scores[odd];\\n                int a = nums[i]%2;\\n                int b = nums[odd]%2;\\n                if(a!=b)\\n                    y = y-x;\\n                if(y>nums[i])\\n                    scores[i] =y;\\n                else\\n                    scores[i] = nums[i];\\n                if(a==1)\\n                    odd =i;\\n                else\\n                    even =i;\\n                continue;\\n            }\\n            long long y = nums[i] +scores[odd];\\n            int a = nums[i]%2;\\n            int b = nums[odd]%2;\\n            if(a!=b)\\n                y = y-x;\\n            long long z = nums[i]+scores[even];\\n            int c = nums[even]%2;\\n            if(a!=c)\\n                z = z-x;\\n            z =  max(z,y);\\n            if(z>nums[i])\\n                scores[i]=z;\\n            else\\n                scores[i] = nums[i];\\n            if(a==1)\\n                odd =i;\\n            else\\n                even =i;\\n                \\n        }\\n        // for(int i =0;i<n;i++)\\n        //     cout<<scores[i]<<\" \";\\n        return scores[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3978457,
                "title": "c-one-pass-dp-with-no-array-time-o-n-space-o-1",
                "content": "# Intuition\\nUse DP to make only one pass on the array.\\n\\n# Approach\\nWe keep track of the best odd and even value yet as we iterate over the array. We start with values of nums[0] and -x for these. Every time we see a new value, it will be better than the last of it\\'s kind since all values are positive. Do not forget to skip the first number in the for loop since it is taken into account at the init of the two variables.\\n\\n# Complexity\\n- Time complexity: O(n)\\nOne pass through the array.\\n\\n- Space complexity: O(1)\\nTwo variables only are needed.\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    public long MaxScore(int[] nums, int x) {\\n        long BestOdd = !isEven(nums[0]) ? nums[0] : -x;\\n        long BestEven = isEven(nums[0]) ? nums[0] : -x;\\n        foreach(int num in nums.Skip(1)) {\\n            if(isEven(num)) {\\n                BestEven = Math.Max(BestOdd - x, BestEven) + num;\\n            } else {\\n                BestOdd = Math.Max(BestEven - x, BestOdd) + num;\\n            }\\n        }\\n        return Math.Max(BestEven, BestOdd);\\n    }\\n\\n    private bool isEven(long n) {\\n        return n % 2 == 0;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public long MaxScore(int[] nums, int x) {\\n        long BestOdd = !isEven(nums[0]) ? nums[0] : -x;\\n        long BestEven = isEven(nums[0]) ? nums[0] : -x;\\n        foreach(int num in nums.Skip(1)) {\\n            if(isEven(num)) {\\n                BestEven = Math.Max(BestOdd - x, BestEven) + num;\\n            } else {\\n                BestOdd = Math.Max(BestEven - x, BestOdd) + num;\\n            }\\n        }\\n        return Math.Max(BestEven, BestOdd);\\n    }\\n\\n    private bool isEven(long n) {\\n        return n % 2 == 0;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966056,
                "title": "simple-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& v, int x) {\\n        int n=v.size();\\n        long long dp[n][2];\\n        if(v[0]%2==0)\\n        {\\n            dp[0][0]=v[0];\\n            dp[0][1]=INT_MIN;\\n        }\\n        else\\n        {\\n            dp[0][0]=INT_MIN;\\n            dp[0][1]=v[0];\\n        }\\n        long long ans = v[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[i]%2==0)\\n            {\\n                dp[i][0]=max(dp[i-1][0]+v[i],dp[i-1][1]+v[i]-x);\\n                dp[i][1]=dp[i-1][1];\\n                ans=max(ans,max(dp[i][0],dp[i][1]));\\n            }\\n            else\\n            {\\n                dp[i][0]=dp[i-1][0];\\n                dp[i][1]=max(dp[i-1][1]+v[i],dp[i-1][0]+v[i]-x);\\n                ans=max(ans,max(dp[i][0],dp[i][1]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& v, int x) {\\n        int n=v.size();\\n        long long dp[n][2];\\n        if(v[0]%2==0)\\n        {\\n            dp[0][0]=v[0];\\n            dp[0][1]=INT_MIN;\\n        }\\n        else\\n        {\\n            dp[0][0]=INT_MIN;\\n            dp[0][1]=v[0];\\n        }\\n        long long ans = v[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[i]%2==0)\\n            {\\n                dp[i][0]=max(dp[i-1][0]+v[i],dp[i-1][1]+v[i]-x);\\n                dp[i][1]=dp[i-1][1];\\n                ans=max(ans,max(dp[i][0],dp[i][1]));\\n            }\\n            else\\n            {\\n                dp[i][0]=dp[i-1][0];\\n                dp[i][1]=max(dp[i-1][1]+v[i],dp[i-1][0]+v[i]-x);\\n                ans=max(ans,max(dp[i][0],dp[i][1]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963268,
                "title": "c-easy-solution-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic: \\ntypedef long long ll;\\n    ll helper(int pos, int flag, vector<int>& v, int x, vector<vector<ll>>& dp)\\n    {\\n        int n=v.size();\\n        if(pos==n) return 0;\\n        if(dp[pos][flag]!=-1) return dp[pos][flag];\\n        ll notPick = helper(pos+1,flag,v,x,dp);\\n        ll pick = 0;\\n        if(v[pos]%2==flag) pick=v[pos] + helper(pos+1,flag,v,x,dp);\\n        else pick = v[pos] + helper(pos+1,v[pos]%2,v,x,dp) - x;\\n        return dp[pos][flag] = max(pick,notPick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<ll>> dp(nums.size(),vector<ll>(2,-1));\\n        return nums[0] + helper(1,nums[0]%2,nums,x,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\ntypedef long long ll;\\n    ll helper(int pos, int flag, vector<int>& v, int x, vector<vector<ll>>& dp)\\n    {\\n        int n=v.size();\\n        if(pos==n) return 0;\\n        if(dp[pos][flag]!=-1) return dp[pos][flag];\\n        ll notPick = helper(pos+1,flag,v,x,dp);\\n        ll pick = 0;\\n        if(v[pos]%2==flag) pick=v[pos] + helper(pos+1,flag,v,x,dp);\\n        else pick = v[pos] + helper(pos+1,v[pos]%2,v,x,dp) - x;\\n        return dp[pos][flag] = max(pick,notPick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<ll>> dp(nums.size(),vector<ll>(2,-1));\\n        return nums[0] + helper(1,nums[0]%2,nums,x,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961181,
                "title": "take-don-t-take-dp-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long dp[2][100011];\\n    long long f(int prev, int i, int n, vector<int> &nums, int x)\\n    {\\n        long long ans=0;\\n        if(i==n) return ans;\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        long long take=nums[i]+f(nums[i]%2!=0, i+1, n, nums, x);\\n        long long dont=f(prev, i+1, n, nums, x);\\n        if(prev == (nums[i]%2!=0)) ans=max(take,dont);\\n        else ans=max(take-x,dont);\\n        return dp[prev][i]=ans;\\n    }\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(nums[0]%2!=0,0,nums.size(),nums,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long dp[2][100011];\\n    long long f(int prev, int i, int n, vector<int> &nums, int x)\\n    {\\n        long long ans=0;\\n        if(i==n) return ans;\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        long long take=nums[i]+f(nums[i]%2!=0, i+1, n, nums, x);\\n        long long dont=f(prev, i+1, n, nums, x);\\n        if(prev == (nums[i]%2!=0)) ans=max(take,dont);\\n        else ans=max(take-x,dont);\\n        return dp[prev][i]=ans;\\n    }\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return f(nums[0]%2!=0,0,nums.size(),nums,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954844,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDp, always track max even ended and max odd ended\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        max_odd,max_even=nums[0]-x*(1-nums[0]%2),nums[0]-x*(nums[0]%2)\\n        res=nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            num=nums[i]\\n            if num%2:\\n                max_odd=max(max_odd+num,max_even+num-x)        \\n            else:\\n                max_even=max(max_even+num,max_odd+num-x)\\n            res=max(res,max_odd,max_even)\\n       \\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        max_odd,max_even=nums[0]-x*(1-nums[0]%2),nums[0]-x*(nums[0]%2)\\n        res=nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            num=nums[i]\\n            if num%2:\\n                max_odd=max(max_odd+num,max_even+num-x)        \\n            else:\\n                max_even=max(max_even+num,max_odd+num-x)\\n            res=max(res,max_odd,max_even)\\n       \\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939916,
                "title": "c-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<long>> dp;\\n    int x;\\n    long solve(vector<int>& nums, int cur,bool isOdd){\\n        if(cur==size(nums)) return 0;\\n        if(dp[cur][isOdd]!=-1) return dp[cur][isOdd];\\n        long o1=solve(nums,cur+1,isOdd);\\n        long o2=nums[cur]+solve(nums,cur+1,nums[cur]&1);\\n        if(isOdd!=(nums[cur]&1))o2-=x;\\n        return dp[cur][isOdd]=max(o1,o2);\\n    }\\n    long long maxScore(vector<int>& nums, int x1) {\\n        dp=vector<vector<long>>(size(nums)+2,vector<long>(2,-1));\\n        x=x1;\\n        return solve(nums,0,nums[0]&1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long>> dp;\\n    int x;\\n    long solve(vector<int>& nums, int cur,bool isOdd){\\n        if(cur==size(nums)) return 0;\\n        if(dp[cur][isOdd]!=-1) return dp[cur][isOdd];\\n        long o1=solve(nums,cur+1,isOdd);\\n        long o2=nums[cur]+solve(nums,cur+1,nums[cur]&1);\\n        if(isOdd!=(nums[cur]&1))o2-=x;\\n        return dp[cur][isOdd]=max(o1,o2);\\n    }\\n    long long maxScore(vector<int>& nums, int x1) {\\n        dp=vector<vector<long>>(size(nums)+2,vector<long>(2,-1));\\n        x=x1;\\n        return solve(nums,0,nums[0]&1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908276,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long maxScore(vector<int>& nums, int x) {\\n    // Note that we always need to take nums[0], so the initial definition might\\n    // not hold true.\\n\\n    // dp0 := max score so far with nums ending in an even number\\n    long long dp0 = nums[0] - (nums[0] % 2 == 1 ? x : 0);\\n    // dp1 := max score so far with nums ending in an odd number\\n    long long dp1 = nums[0] - (nums[0] % 2 == 0 ? x : 0);\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums[i] % 2 == 0)\\n        dp0 = nums[i] + max(dp0, dp1 - x);\\n      else\\n        dp1 = nums[i] + max(dp1, dp0 - x);\\n\\n    return max(dp0, dp1);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long maxScore(vector<int>& nums, int x) {\\n    // Note that we always need to take nums[0], so the initial definition might\\n    // not hold true.\\n\\n    // dp0 := max score so far with nums ending in an even number\\n    long long dp0 = nums[0] - (nums[0] % 2 == 1 ? x : 0);\\n    // dp1 := max score so far with nums ending in an odd number\\n    long long dp1 = nums[0] - (nums[0] % 2 == 0 ? x : 0);\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums[i] % 2 == 0)\\n        dp0 = nums[i] + max(dp0, dp1 - x);\\n      else\\n        dp1 = nums[i] + max(dp1, dp0 - x);\\n\\n    return max(dp0, dp1);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899570,
                "title": "why-this-code-give-me-wrong-ans-in-one-of-test-case-help-please",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    long long helper(vector<int>nums, int i,int n,int p,int x,vector<vector<int>>&dp){\\n        if(i==n)return 0;\\n        \\n        if(dp[i][p]!=-1)return dp[i][p];\\n        int take=nums[i]+helper(nums,i+1,n,nums[i]%2,x,dp);\\n        if(nums[i]%2!=p){\\n            take-=x;\\n            // cout<<nums[i]<<\" \"<<take<<endl;\\n        }\\n        int notTake=helper(nums,i+1,n,p,x,dp);\\n        dp[i][p]=max(notTake,take);\\n        ans=max(dp[i][p],ans);\\n        return dp[i][p];\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        ans=-1;\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        helper(nums,0,n,nums[0]%2,x,dp);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans;\\n    long long helper(vector<int>nums, int i,int n,int p,int x,vector<vector<int>>&dp){\\n        if(i==n)return 0;\\n        \\n        if(dp[i][p]!=-1)return dp[i][p];\\n        int take=nums[i]+helper(nums,i+1,n,nums[i]%2,x,dp);\\n        if(nums[i]%2!=p){\\n            take-=x;\\n            // cout<<nums[i]<<\" \"<<take<<endl;\\n        }\\n        int notTake=helper(nums,i+1,n,p,x,dp);\\n        dp[i][p]=max(notTake,take);\\n        ans=max(dp[i][p],ans);\\n        return dp[i][p];\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        ans=-1;\\n        vector<vector<int>>dp(n,vector<int>(2,-1));\\n        helper(nums,0,n,nums[0]%2,x,dp);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3896058,
                "title": "python-3-dp-binary-search-greedy",
                "content": "# Intuition\\nYou need dp because obviously there is only 1 state variable. But the question is how to do dp iteration effective.\\n\\nIf you study the statement carefully, you know that for each step, you have 2 choices: next odd num, or next even num. Just these 2. So you don\\'t need to do extra loop. This is greedy. To find next odd/even num effectively, use binary search.\\n\\n# Approach\\ndp + bs + greedy\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) -> n for state variable. In every dp iteration, I do bs which costs O(logn)\\n\\n- Space complexity:\\nO(n) -> cache size\\n\\n# Code\\n```\\nimport bisect\\n\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n\\n        # parity: True = odd\\n        parity2ind = collections.defaultdict(list)\\n\\n        for ind, num in enumerate(nums):\\n            parity = nums[ind] % 2 == 1\\n            parity2ind[parity].append(ind)\\n\\n        @cache\\n        def dp(i): # return int, max score?\\n            # parity: True = odd\\n            if i == nums:\\n                return 0\\n\\n            this_parity = nums[i] % 2 == 1\\n\\n            take_oddi = bisect.bisect_left(parity2ind[True], i + 1)\\n            if take_oddi < len(parity2ind[True]):\\n                final_oddi = parity2ind[True][take_oddi]\\n                odd = dp(final_oddi)\\n                if this_parity != True: # diff parity\\n                    odd -= x\\n            else:\\n                odd = 0\\n            \\n            take_eveni = bisect.bisect_left(parity2ind[False], i + 1)\\n            if take_eveni < len(parity2ind[False]):\\n                final_eveni = parity2ind[False][take_eveni]\\n                even = dp(final_eveni)\\n                if this_parity != False:\\n                    even -= x\\n            else:\\n                even = 0\\n            \\n            return max(odd, even) + nums[i]\\n\\n        return dp(0)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n\\n        # parity: True = odd\\n        parity2ind = collections.defaultdict(list)\\n\\n        for ind, num in enumerate(nums):\\n            parity = nums[ind] % 2 == 1\\n            parity2ind[parity].append(ind)\\n\\n        @cache\\n        def dp(i): # return int, max score?\\n            # parity: True = odd\\n            if i == nums:\\n                return 0\\n\\n            this_parity = nums[i] % 2 == 1\\n\\n            take_oddi = bisect.bisect_left(parity2ind[True], i + 1)\\n            if take_oddi < len(parity2ind[True]):\\n                final_oddi = parity2ind[True][take_oddi]\\n                odd = dp(final_oddi)\\n                if this_parity != True: # diff parity\\n                    odd -= x\\n            else:\\n                odd = 0\\n            \\n            take_eveni = bisect.bisect_left(parity2ind[False], i + 1)\\n            if take_eveni < len(parity2ind[False]):\\n                final_eveni = parity2ind[False][take_eveni]\\n                even = dp(final_eveni)\\n                if this_parity != False:\\n                    even -= x\\n            else:\\n                even = 0\\n            \\n            return max(odd, even) + nums[i]\\n\\n        return dp(0)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885278,
                "title": "python3-efficient-short",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        temp = [sum(y) for x,y in groupby(nums, key = lambda x : x%2)]\\n        if len(temp) == 1: return temp[0]\\n        dp =  [temp[0], temp[1] + temp[0] - x] + [0]*(len(temp)-2)\\n        for i in range(2,len(temp)):\\n            dp[i] = max(dp[i-2] + temp[i], dp[i-1] + temp[i] - x)\\n        return max(dp)\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        temp = [sum(y) for x,y in groupby(nums, key = lambda x : x%2)]\\n        if len(temp) == 1: return temp[0]\\n        dp =  [temp[0], temp[1] + temp[0] - x] + [0]*(len(temp)-2)\\n        for i in range(2,len(temp)):\\n            dp[i] = max(dp[i-2] + temp[i], dp[i-1] + temp[i] - x)\\n        return max(dp)\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874264,
                "title": "c-easy-solution-97-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<pair<long,long>>v(nums.size(),{0,0});\\n        if(nums[0]%2==0){\\n            v[0].first=nums[0];\\n            v[0].second = nums[0]-x;\\n        }\\n        else if(nums[0]%2!=0){\\n            v[0].second = nums[0];\\n            v[0].first = nums[0]-x;\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                v[i].first = max(nums[i]+v[i-1].first,v[i-1].second+nums[i]-x);\\n                v[i].second  = v[i-1].second;\\n                \\n            }\\n            else{\\n                v[i].second = max(nums[i]+v[i-1].second,v[i-1].first+nums[i]-x);\\n                v[i].first  = v[i-1].first;\\n                \\n            }\\n        }\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            long long jj = max(v[i].first,v[i].second);\\n            ans = max(ans,jj);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<pair<long,long>>v(nums.size(),{0,0});\\n        if(nums[0]%2==0){\\n            v[0].first=nums[0];\\n            v[0].second = nums[0]-x;\\n        }\\n        else if(nums[0]%2!=0){\\n            v[0].second = nums[0];\\n            v[0].first = nums[0]-x;\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                v[i].first = max(nums[i]+v[i-1].first,v[i-1].second+nums[i]-x);\\n                v[i].second  = v[i-1].second;\\n                \\n            }\\n            else{\\n                v[i].second = max(nums[i]+v[i-1].second,v[i-1].first+nums[i]-x);\\n                v[i].first  = v[i-1].first;\\n                \\n            }\\n        }\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            long long jj = max(v[i].first,v[i].second);\\n            ans = max(ans,jj);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868338,
                "title": "cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][2];\\n    long long solve(vector<int>& nums, int i,int n,bool flag,int x){\\n        if(i>=n)return 0;\\n        if(dp[i][flag]!=-1)return dp[i][flag];\\n        bool temp=false;\\n        if(nums[i]%2==0)temp=true;\\n        if(flag==temp){\\n            return dp[i][flag]=max(solve(nums,i+1,n,flag,x),nums[i]+solve(nums,i+1,n,temp,x));\\n        }else{\\n            return dp[i][flag]=max(solve(nums,i+1,n,flag,x),(nums[i]-x)+solve(nums,i+1,n,temp,x));\\n        }\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        bool flag=false;\\n        if(nums[0]%2==0)flag=true;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<2;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(nums,0,nums.size(),flag,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2];\\n    long long solve(vector<int>& nums, int i,int n,bool flag,int x){\\n        if(i>=n)return 0;\\n        if(dp[i][flag]!=-1)return dp[i][flag];\\n        bool temp=false;\\n        if(nums[i]%2==0)temp=true;\\n        if(flag==temp){\\n            return dp[i][flag]=max(solve(nums,i+1,n,flag,x),nums[i]+solve(nums,i+1,n,temp,x));\\n        }else{\\n            return dp[i][flag]=max(solve(nums,i+1,n,flag,x),(nums[i]-x)+solve(nums,i+1,n,temp,x));\\n        }\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        bool flag=false;\\n        if(nums[0]%2==0)flag=true;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<2;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(nums,0,nums.size(),flag,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866062,
                "title": "c-clean-code-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long t(int i,vector<int>& a,int x,vector<vector<long long>>& dp,int p)\\n    {\\n        if(i>=a.size()) return 0;\\n        if(dp[i][p]!=-1) return dp[i][p];\\n\\n        long long m=0,s=0;\\n        if(a[i]%2==0 && p==1)\\n        s=a[i]-x;\\n        else if(a[i]%2!=0 && p==0)\\n        s=a[i]-x;\\n        else\\n        s=a[i];\\n\\n        int j=i+1;\\n      \\n        if(a[i]%2==0 && p==1)\\n        m=t(j,a,x,dp,0);\\n        else if(a[i]%2!=0 && p==0)\\n        m=t(j,a,x,dp,1);\\n        else\\n        m=t(j,a,x,dp,p);\\n        \\n        long long y=0;\\n        y=t(i+1,a,x,dp,p);\\n        return dp[i][p]=max(m+s,y);\\n    }\\n    long long maxScore(vector<int>& a, int x) {\\n        int n=a.size();\\n        vector<vector<long long>> dp(n+1,vector<long long> (3,-1));\\n        int p;\\n        if(a[0]%2==0) p=0;\\n        else p=1;\\n       return t(0,a,x,dp,p);         \\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long t(int i,vector<int>& a,int x,vector<vector<long long>>& dp,int p)\\n    {\\n        if(i>=a.size()) return 0;\\n        if(dp[i][p]!=-1) return dp[i][p];\\n\\n        long long m=0,s=0;\\n        if(a[i]%2==0 && p==1)\\n        s=a[i]-x;\\n        else if(a[i]%2!=0 && p==0)\\n        s=a[i]-x;\\n        else\\n        s=a[i];\\n\\n        int j=i+1;\\n      \\n        if(a[i]%2==0 && p==1)\\n        m=t(j,a,x,dp,0);\\n        else if(a[i]%2!=0 && p==0)\\n        m=t(j,a,x,dp,1);\\n        else\\n        m=t(j,a,x,dp,p);\\n        \\n        long long y=0;\\n        y=t(i+1,a,x,dp,p);\\n        return dp[i][p]=max(m+s,y);\\n    }\\n    long long maxScore(vector<int>& a, int x) {\\n        int n=a.size();\\n        vector<vector<long long>> dp(n+1,vector<long long> (3,-1));\\n        int p;\\n        if(a[0]%2==0) p=0;\\n        else p=1;\\n       return t(0,a,x,dp,p);         \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865907,
                "title": "c-solution-memoization",
                "content": "> , \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int ind, int bit, vector<int> &nums, int x, vector<vector<long long>> &dp){\\n        if(ind >= nums.size())  return 0 ;\\n        if(dp[ind][bit] != -1)  return dp[ind][bit] ;\\n        long long take = 0 ; \\n        long long notTake = solve(ind+1, bit, nums, x, dp) ;\\n        if((nums[ind] & 1) == bit){\\n            take = nums[ind] + solve(ind+1, bit, nums, x, dp) ;\\n        }\\n        else    take = nums[ind]-x + solve(ind+1, !bit, nums, x, dp) ;\\n        return dp[ind][bit] = max(take, notTake) ;\\n    }\\n\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size() ;\\n        int bit=0;\\n        vector <vector <long long> > dp(n+1, vector<long long> (2, -1)) ;\\n        if(nums[0] & 1) bit=1; \\n        return solve(0,bit,nums,x, dp) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int ind, int bit, vector<int> &nums, int x, vector<vector<long long>> &dp){\\n        if(ind >= nums.size())  return 0 ;\\n        if(dp[ind][bit] != -1)  return dp[ind][bit] ;\\n        long long take = 0 ; \\n        long long notTake = solve(ind+1, bit, nums, x, dp) ;\\n        if((nums[ind] & 1) == bit){\\n            take = nums[ind] + solve(ind+1, bit, nums, x, dp) ;\\n        }\\n        else    take = nums[ind]-x + solve(ind+1, !bit, nums, x, dp) ;\\n        return dp[ind][bit] = max(take, notTake) ;\\n    }\\n\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size() ;\\n        int bit=0;\\n        vector <vector <long long> > dp(n+1, vector<long long> (2, -1)) ;\\n        if(nums[0] & 1) bit=1; \\n        return solve(0,bit,nums,x, dp) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864595,
                "title": "0-1-knapsack-easy-solution-with-dry-run-approach-dp-odd-even",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem involves finding the maximum total score while traversing an array, with certain conditions based on the parity of the numbers. We need to carefully select the numbers to maximize the score while considering the given rules.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem, we can use dynamic programming with memoization. We will define a helper function that recursively calculates the maximum score starting from each index and keeping track of the parity. We will use memoization to avoid redundant calculations and store the results of subproblems in a 2D DP array.\\n\\nAt each index, we have two options: either pick the current number with or without reduction (losing x points). We will take the maximum of these two options and continue the recursion to explore other possibilities. We will also consider the case of not picking the current number and move to the next index. The recursion will continue until we reach the end of the array.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Dry run \\nSure, let\\'s do a dry run of the provided code for the input `[2, 3, 6, 1, 9, 2]` and `x=5`.\\n\\n- `maxScore` is called with the input `[2, 3, 6, 1, 9, 2]` and `x=5`.\\n- The `maxScore` function initializes the `dp` table.\\n- The `helper` function is called with `index=0`, `nums=[2, 3, 6, 1, 9, 2]`, `x=5`, `parity=1`, and the `dp` table.\\n- `pick` and `notPick` are initialized to a large negative value.\\n- The `dp` table for the current `index` (0) and `parity` (1) is checked. Since it\\'s not calculated yet, we proceed with the calculations.\\n- The current number at index 0 is 2, which is even (2 % 2 == 0). So we go to the `else` part of the code block.\\n- We are in the `else` part with `parity=1` (odd). So, `pick` is calculated as `2 + helper(1, [2, 3, 6, 1, 9, 2], 5, 0, dp)`.\\n- The `helper` function is called recursively with `index=1`, `nums=[2, 3, 6, 1, 9, 2]`, `x=5`, `parity=0`, and the `dp` table.\\n- This process continues until the end of the array is reached.\\n- Finally, the maximum score between picking and not picking the numbers is returned.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long helper(int index, vector<int>& nums, int x, int parity, vector<vector<long long>>& dp) {\\n    // If we have reached the end of the array, return 0 as there are no more elements to consider.\\n    if (index == nums.size())\\n        return 0;\\n\\n    // Variables to store the scores for picking and not picking the current number.\\n    long long pick = -1e12, notPick = -1e12;\\n\\n    // If the score for the current index and parity is already calculated, return it.\\n    if (dp[index][parity] != -1)\\n        return dp[index][parity];\\n\\n    // Check if the current number is odd or even.\\n    if (nums[index] % 2 != 0) {\\n        // If the current number is odd, there are two options:\\n        // 1. Pick the number without reduction (no loss in score).\\n        // 2. Pick the number with reduction (lose x points in score).\\n        if (parity) {\\n            pick = nums[index] + helper(index + 1, nums, x, nums[index] % 2 != 0, dp);\\n        } else {\\n            pick = nums[index] - x + helper(index + 1, nums, x, nums[index] % 2 != 0, dp);\\n        }\\n    } else {\\n        // If the current number is even, there are two options:\\n        // 1. Pick the number without reduction (no loss in score).\\n        // 2. Pick the number with reduction (lose x points in score).\\n        if (parity == 0) {\\n            pick = nums[index] + helper(index + 1, nums, x, nums[index] % 2 != 0, dp);\\n        } else {\\n            pick = nums[index] - x + helper(index + 1, nums, x, nums[index] % 2 != 0, dp);\\n        }\\n    }\\n\\n    // Calculate the score when not picking the current number.\\n    notPick = helper(index + 1, nums, x, parity, dp);\\n\\n    // Return the maximum score among the two options: pick or not pick.\\n    return dp[index][parity] = max(pick, notPick);\\n}\\n\\nlong long maxScore(vector<int>& nums, int x) {\\n    // Initialize a 2D DP array to store calculated scores for each index and parity combination.\\n    vector<vector<long long>> dp(nums.size() + 1, vector<long long>(2, -1));\\n\\n    // Start the recursive function with the initial index 0 and the parity of the first number in the array.\\n    return helper(0, nums, x, (nums[0] % 2 == 1), dp);\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(int index, vector<int>& nums, int x, int parity, vector<vector<long long>>& dp) {\\n    // If we have reached the end of the array, return 0 as there are no more elements to consider.\\n    if (index == nums.size())\\n        return 0;\\n\\n    // Variables to store the scores for picking and not picking the current number.\\n    long long pick = -1e12, notPick = -1e12;\\n\\n    // If the score for the current index and parity is already calculated, return it.\\n    if (dp[index][parity] != -1)\\n        return dp[index][parity];\\n\\n    // Check if the current number is odd or even.\\n    if (nums[index] % 2 != 0) {\\n        // If the current number is odd, there are two options:\\n        // 1. Pick the number without reduction (no loss in score).\\n        // 2. Pick the number with reduction (lose x points in score).\\n        if (parity) {\\n            pick = nums[index] + helper(index + 1, nums, x, nums[index] % 2 != 0, dp);\\n        } else {\\n            pick = nums[index] - x + helper(index + 1, nums, x, nums[index] % 2 != 0, dp);\\n        }\\n    } else {\\n        // If the current number is even, there are two options:\\n        // 1. Pick the number without reduction (no loss in score).\\n        // 2. Pick the number with reduction (lose x points in score).\\n        if (parity == 0) {\\n            pick = nums[index] + helper(index + 1, nums, x, nums[index] % 2 != 0, dp);\\n        } else {\\n            pick = nums[index] - x + helper(index + 1, nums, x, nums[index] % 2 != 0, dp);\\n        }\\n    }\\n\\n    // Calculate the score when not picking the current number.\\n    notPick = helper(index + 1, nums, x, parity, dp);\\n\\n    // Return the maximum score among the two options: pick or not pick.\\n    return dp[index][parity] = max(pick, notPick);\\n}\\n\\nlong long maxScore(vector<int>& nums, int x) {\\n    // Initialize a 2D DP array to store calculated scores for each index and parity combination.\\n    vector<vector<long long>> dp(nums.size() + 1, vector<long long>(2, -1));\\n\\n    // Start the recursive function with the initial index 0 and the parity of the first number in the array.\\n    return helper(0, nums, x, (nums[0] % 2 == 1), dp);\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864509,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int i,vector<int>&v,int x,int k,vector<vector<long long>>&dp){\\n        if(i>=v.size()) return 0;\\n        if(dp[i-1][k]!=-1) return dp[i-1][k];\\n        long long a1=solve(i+1,v,x,k,dp);\\n        long long a2;\\n        if(v[i]%2==k) a2=v[i]+solve(i+1,v,x,k,dp);\\n        else a2=v[i]+solve(i+1,v,x,v[i]%2,dp)-x;\\n        return dp[i-1][k]=max(a1,a2);\\n    }\\n    long long maxScore(vector<int>& v, int x) {\\n        int n=v.size();\\n        vector<vector<long long>>dp(n-1,vector<long long>(2,-1));\\n        return v[0]+solve(1,v,x,v[0]%2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,vector<int>&v,int x,int k,vector<vector<long long>>&dp){\\n        if(i>=v.size()) return 0;\\n        if(dp[i-1][k]!=-1) return dp[i-1][k];\\n        long long a1=solve(i+1,v,x,k,dp);\\n        long long a2;\\n        if(v[i]%2==k) a2=v[i]+solve(i+1,v,x,k,dp);\\n        else a2=v[i]+solve(i+1,v,x,v[i]%2,dp)-x;\\n        return dp[i-1][k]=max(a1,a2);\\n    }\\n    long long maxScore(vector<int>& v, int x) {\\n        int n=v.size();\\n        vector<vector<long long>>dp(n-1,vector<long long>(2,-1));\\n        return v[0]+solve(1,v,x,v[0]%2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864333,
                "title": "python-dp-solution-877ms",
                "content": "```\\ndef maxScore(self, nums: List[int], x: int) -> int:\\n        if nums[0]%2 == 0:\\n            even = nums[0]\\n            odd = nums[0] - x\\n        else:\\n            odd = nums[0]\\n            even = nums[0] - x\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i]%2:\\n                odd = max(nums[i]+odd, even+nums[i]-x)\\n            else:\\n                even = max(nums[i]+even, odd+nums[i]-x)\\n        \\n        return max(odd,even)\\n```\\n\\n**confusing description though, took me a while to figure out what parities means actually, they should just say odd or even instead**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxScore(self, nums: List[int], x: int) -> int:\\n        if nums[0]%2 == 0:\\n            even = nums[0]\\n            odd = nums[0] - x\\n        else:\\n            odd = nums[0]\\n            even = nums[0] - x\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i]%2:\\n                odd = max(nums[i]+odd, even+nums[i]-x)\\n            else:\\n                even = max(nums[i]+even, odd+nums[i]-x)\\n        \\n        return max(odd,even)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3862237,
                "title": "two-priority-queue-linear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& a, int x) {\\n        int n = a.size();\\n        priority_queue<long long> od, ev;\\n        long long dp[n];\\n        dp[n-1] = a[n-1];\\n        if(a[n-1]%2){\\n            od.push(a[n-1]);\\n        }\\n        else{\\n            ev.push(a[n-1]);\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            long long evn = ev.size() ? ev.top() : 0;\\n            long long odd = od.size() ? od.top() : 0;\\n            if(a[i]%2){\\n                if(evn-x > odd){\\n                    dp[i] = a[i] + evn-x;\\n                }\\n                else{\\n                    dp[i] = a[i] + odd;\\n                }\\n                od.push(dp[i]);\\n            }\\n            else{\\n                if(odd-x > evn){\\n                    dp[i] = a[i] + odd-x;\\n                }\\n                else{\\n                    dp[i] = a[i] + evn;\\n                }\\n                ev.push(dp[i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n-----------------------\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& a, int x) {\\n        int n = a.size();\\n        long long dp[n];\\n        dp[n-1] = a[n-1];\\n        long long od = 0, ev = 0;\\n        if(a[n-1]%2){\\n            od = a[n-1];\\n        }\\n        else{\\n            ev = a[n-1];\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(a[i]%2){\\n                if(ev-x > od){\\n                    dp[i] = a[i] + ev-x;\\n                }\\n                else{\\n                    dp[i] = a[i] + od;\\n                }\\n                od = max(dp[i], od);\\n            }\\n            else{\\n                if(od-x > ev){\\n                    dp[i] = a[i] + od-x;\\n                }\\n                else{\\n                    dp[i] = a[i] + ev;\\n                }\\n                ev = max(ev, dp[i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& a, int x) {\\n        int n = a.size();\\n        priority_queue<long long> od, ev;\\n        long long dp[n];\\n        dp[n-1] = a[n-1];\\n        if(a[n-1]%2){\\n            od.push(a[n-1]);\\n        }\\n        else{\\n            ev.push(a[n-1]);\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            long long evn = ev.size() ? ev.top() : 0;\\n            long long odd = od.size() ? od.top() : 0;\\n            if(a[i]%2){\\n                if(evn-x > odd){\\n                    dp[i] = a[i] + evn-x;\\n                }\\n                else{\\n                    dp[i] = a[i] + odd;\\n                }\\n                od.push(dp[i]);\\n            }\\n            else{\\n                if(odd-x > evn){\\n                    dp[i] = a[i] + odd-x;\\n                }\\n                else{\\n                    dp[i] = a[i] + evn;\\n                }\\n                ev.push(dp[i]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859846,
                "title": "recursive-recursive-memoization-tabulation-space-optimization-beats-98-submissions",
                "content": "# Intuition\\nThe problem involves picking numbers from the given array and maximizing the score based on certain rules. The score is computed as the sum of selected numbers with certain adjustments based on their parity (odd/even). To maximize the score, we need to carefully choose which numbers to include in the selection.\\n\\nsimply - we are including or excluding the number to maximize the score.\\n\\n# Approach\\nThe code implements four different approaches to solve the problem:\\n\\n1. Recursive: It recursively explores all possible choices of including or excluding each number while keeping track of the parity of the current sum. `It will give TLE since the time complexity will be exponential`\\n\\n2. Recursive + Memoization: It is the same as the recursive approach but uses memoization to avoid redundant computations.\\n\\n3. Tabulation: It uses bottom-up dynamic programming with a 2D array to store intermediate results and find the maximum score iteratively.\\n\\n4. Space Optimization: It optimizes the tabulation approach by using only two arrays (curr and next) to store intermediate results, reducing space complexity.\\n\\n# Complexity\\n- Time complexity:\\n1. `Recursive`:  The `recursive` approach explores all possible combinations of including and excluding each number. In the worst case, each number can be included or excluded, leading to 2^n recursive calls, where `n` is the size of the input array `nums`. Therefore, the time complexity is `O(2^n)`.\\n\\n2. `Recursive + Memoization`: The memoization optimizes the recursive approach by avoiding redundant recursive calls. The time complexity becomes `O(n)`, where `n` is the size of the input array `nums`, as each index and parity is computed only once and stored in the memoization table.\\n\\n3. `Tabulation`: The tabulation approach iterates through all elements of the input array nums once for each parity. Therefore, the time complexity is `O(n)`.\\n\\n4. `Space Optimization`: The space-optimized tabulation approach has the same time complexity as the regular tabulation approach, which is `O(n)`.\\n\\n- Space complexity:\\n1. `Recursive`: The recursive approach uses the call stack for recursive calls, which can grow up to `O(n)` in the worst case due to recursion depth.\\n\\n2. `Recursive + Memoization`: The memoization approach uses a 2D memoization table of size (n+1) x 2, where n is the size of the input array nums. Therefore, the space complexity is `O(n)`.\\n\\n3. `Tabulation`: The tabulation approach uses a 2D array of size (n+1) x 2 to store intermediate results, where n is the size of the input array nums. Therefore, the space complexity is `O(n)`.\\n\\n4. `Space Optimization`: The space-optimized tabulation approach uses two arrays (curr and next) of size 2 to store intermediate results. Hence, the space complexity is `O(1)` since it does not depend on the size of the input array nums.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long solveRec(vector<int>& nums, int x, int parity, int index) {\\n        // base case\\n        if(index == nums.size()) return 0;\\n\\n        // include a/c to parity is same\\n        long long include;\\n        if(nums[index] % 2 == parity) { // same parity\\n            include = nums[index] + solveRec(nums, x, parity, index+1); \\n        } \\n        else { // different parity\\n            include = nums[index] - x + solveRec(nums, x, !parity, index+1);\\n        }\\n        \\n        long long exclude = solveRec(nums, x, parity, index+1);\\n        \\n        return max(include, exclude);\\n    }\\n    \\n    long long solveRec_Mem(vector<int>& nums, int x, int parity, int index, vector<vector<long long>>& dp) {\\n        // base case\\n        if(index == nums.size()) return 0;\\n        \\n        if(dp[index][parity] != -1) return dp[index][parity];\\n        \\n        // include a/c to parity is same\\n        long long include;\\n        if(nums[index] % 2 == parity) { // same parity\\n            include = nums[index] + solveRec_Mem(nums, x, parity, index+1, dp); \\n        } \\n        else { // different parity\\n            include = nums[index] - x + solveRec_Mem(nums, x, !parity, index+1, dp);\\n        }\\n        \\n        long long exclude = solveRec_Mem(nums, x, parity, index+1, dp);\\n        \\n        return dp[index][parity] = max(include, exclude);\\n    }\\n    \\n    long long solveTab(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n+1, vector<long long>(2, 0));\\n        \\n        for(int index = n - 1; index >= 1; index--) {\\n            for(int parity = 0; parity <= 1; parity++) {\\n                long long include;\\n                if(nums[index] % 2 == parity) { // same parity\\n                    include = nums[index] + dp[index+1][parity]; \\n                } \\n                else { // different parity\\n                    include = nums[index] - x + dp[index+1][nums[index] % 2];\\n                }\\n\\n                long long exclude = dp[index+1][parity];\\n\\n                dp[index][parity] = max(include, exclude);\\n            }\\n        }\\n        return dp[1][nums[0] % 2];\\n    }\\n    \\n    long long solveSO(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long> curr(2, 0);\\n        vector<long long> next(2, 0);\\n        \\n        for(int index = n - 1; index >= 1; index--) {\\n            for(int parity = 0; parity <= 1; parity++) {\\n                long long include;\\n                if(nums[index] % 2 == parity) { // same parity\\n                    include = nums[index] + next[parity]; \\n                } \\n                else { // different parity\\n                    include = nums[index] - x + next[nums[index] % 2];\\n                }\\n\\n                long long exclude = next[parity];\\n\\n                curr[parity] = max(include, exclude);\\n            }\\n            next = curr;\\n        }\\n        return next[nums[0] % 2];\\n    }\\n    \\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        // // Recursion \\n        // return nums[0] + solveRec(nums, x, nums[0] % 2, 1);\\n        \\n        \\n        // // Recursion + Memoization\\n        // vector<vector<long long>> dp(nums.size()+1, vector<long long>(2, -1));\\n        // return nums[0] + solveRec_Mem(nums, x, nums[0] % 2, 1, dp);\\n        \\n        \\n        // // Tabulation\\n        // return nums[0] + solveTab(nums, x);\\n        \\n        // Space-Optimization\\n        return nums[0] + solveSO(nums, x);\\n    }\\n};\\n```\\n\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/59e6635b-f09b-4fd5-9547-10e4cb905de2_1691089293.6577933.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long solveRec(vector<int>& nums, int x, int parity, int index) {\\n        // base case\\n        if(index == nums.size()) return 0;\\n\\n        // include a/c to parity is same\\n        long long include;\\n        if(nums[index] % 2 == parity) { // same parity\\n            include = nums[index] + solveRec(nums, x, parity, index+1); \\n        } \\n        else { // different parity\\n            include = nums[index] - x + solveRec(nums, x, !parity, index+1);\\n        }\\n        \\n        long long exclude = solveRec(nums, x, parity, index+1);\\n        \\n        return max(include, exclude);\\n    }\\n    \\n    long long solveRec_Mem(vector<int>& nums, int x, int parity, int index, vector<vector<long long>>& dp) {\\n        // base case\\n        if(index == nums.size()) return 0;\\n        \\n        if(dp[index][parity] != -1) return dp[index][parity];\\n        \\n        // include a/c to parity is same\\n        long long include;\\n        if(nums[index] % 2 == parity) { // same parity\\n            include = nums[index] + solveRec_Mem(nums, x, parity, index+1, dp); \\n        } \\n        else { // different parity\\n            include = nums[index] - x + solveRec_Mem(nums, x, !parity, index+1, dp);\\n        }\\n        \\n        long long exclude = solveRec_Mem(nums, x, parity, index+1, dp);\\n        \\n        return dp[index][parity] = max(include, exclude);\\n    }\\n    \\n    long long solveTab(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<vector<long long>> dp(n+1, vector<long long>(2, 0));\\n        \\n        for(int index = n - 1; index >= 1; index--) {\\n            for(int parity = 0; parity <= 1; parity++) {\\n                long long include;\\n                if(nums[index] % 2 == parity) { // same parity\\n                    include = nums[index] + dp[index+1][parity]; \\n                } \\n                else { // different parity\\n                    include = nums[index] - x + dp[index+1][nums[index] % 2];\\n                }\\n\\n                long long exclude = dp[index+1][parity];\\n\\n                dp[index][parity] = max(include, exclude);\\n            }\\n        }\\n        return dp[1][nums[0] % 2];\\n    }\\n    \\n    long long solveSO(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long> curr(2, 0);\\n        vector<long long> next(2, 0);\\n        \\n        for(int index = n - 1; index >= 1; index--) {\\n            for(int parity = 0; parity <= 1; parity++) {\\n                long long include;\\n                if(nums[index] % 2 == parity) { // same parity\\n                    include = nums[index] + next[parity]; \\n                } \\n                else { // different parity\\n                    include = nums[index] - x + next[nums[index] % 2];\\n                }\\n\\n                long long exclude = next[parity];\\n\\n                curr[parity] = max(include, exclude);\\n            }\\n            next = curr;\\n        }\\n        return next[nums[0] % 2];\\n    }\\n    \\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        // // Recursion \\n        // return nums[0] + solveRec(nums, x, nums[0] % 2, 1);\\n        \\n        \\n        // // Recursion + Memoization\\n        // vector<vector<long long>> dp(nums.size()+1, vector<long long>(2, -1));\\n        // return nums[0] + solveRec_Mem(nums, x, nums[0] % 2, 1, dp);\\n        \\n        \\n        // // Tabulation\\n        // return nums[0] + solveTab(nums, x);\\n        \\n        // Space-Optimization\\n        return nums[0] + solveSO(nums, x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856056,
                "title": "python-dp-short-and-clean-solution-with-parity-tracking",
                "content": "# Intuition\\n\\nDP\\n\\n# Approach\\n\\nTrack the maximum odd and even scores\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        max_odd = nums[0] if nums[0] % 2 else float(\\'-inf\\')\\n        max_even = nums[0] if nums[0] % 2 == 0 else float(\\'-inf\\')\\n        for i in range(1, n):\\n            if nums[i] % 2:\\n                max_odd = max(max_even + nums[i] - x, max_odd + nums[i])\\n            else:\\n                max_even = max(max_odd + nums[i] - x, max_even + nums[i])\\n        return max(max_odd, max_even)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        max_odd = nums[0] if nums[0] % 2 else float(\\'-inf\\')\\n        max_even = nums[0] if nums[0] % 2 == 0 else float(\\'-inf\\')\\n        for i in range(1, n):\\n            if nums[i] % 2:\\n                max_odd = max(max_even + nums[i] - x, max_odd + nums[i])\\n            else:\\n                max_even = max(max_odd + nums[i] - x, max_even + nums[i])\\n        return max(max_odd, max_even)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843205,
                "title": "easy-algorithm-for-maximum-odd-and-even",
                "content": "TC: O(n), SC: O(1) , works in single iteration\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long currentOddMax = (nums[0] % 2 != 0)? nums[0] : -1000000, currentEvenMax = (nums[0] % 2 == 0)? nums[0] : -1000000;\\n        long finalMax = nums[0];\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] % 2 == 0) {\\n                long currentMax = Math.max(currentOddMax - x, currentEvenMax);\\n                currentEvenMax = nums[i] + currentMax;\\n            }\\n            else {\\n                long currentMax = Math.max(currentEvenMax - x, currentOddMax);\\n                currentOddMax = nums[i] + currentMax;\\n            }\\n            finalMax = Math.max(currentEvenMax, currentOddMax);\\n        }\\n        return finalMax;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long currentOddMax = (nums[0] % 2 != 0)? nums[0] : -1000000, currentEvenMax = (nums[0] % 2 == 0)? nums[0] : -1000000;\\n        long finalMax = nums[0];\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] % 2 == 0) {\\n                long currentMax = Math.max(currentOddMax - x, currentEvenMax);\\n                currentEvenMax = nums[i] + currentMax;\\n            }\\n            else {\\n                long currentMax = Math.max(currentEvenMax - x, currentOddMax);\\n                currentOddMax = nums[i] + currentMax;\\n            }\\n            finalMax = Math.max(currentEvenMax, currentOddMax);\\n        }\\n        return finalMax;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841129,
                "title": "beat-99-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is traditional 1D dynamic array porblems. With the constraint at 10^5 it is clear that only solution with O(n) will works.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom any point in an array you can only move forward and thus, all the callculation happened before hand becomes constaint. Keeping in mind that, we take 2 variables to track maximum answer obtained till that point, and update itteratively.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums, x):\\n        odd = 0\\n        even = 0\\n        if nums[0]%2==0:\\n            even = nums[0]\\n            odd = nums[0]-x\\n        else:\\n            odd = nums[0]\\n            even = nums[0]-x\\n        \\n        for i in nums[1:]:\\n            if i%2==0:\\n                a = i+even\\n                b = i+odd-x\\n                even = max(a,b)\\n            else:\\n                a  = i+ even -x\\n                b = i+ odd\\n                odd = max(a,b)\\n        return max(odd,even)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums, x):\\n        odd = 0\\n        even = 0\\n        if nums[0]%2==0:\\n            even = nums[0]\\n            odd = nums[0]-x\\n        else:\\n            odd = nums[0]\\n            even = nums[0]-x\\n        \\n        for i in nums[1:]:\\n            if i%2==0:\\n                a = i+even\\n                b = i+odd-x\\n                even = max(a,b)\\n            else:\\n                a  = i+ even -x\\n                b = i+ odd\\n                odd = max(a,b)\\n        return max(odd,even)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835333,
                "title": "dp",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nlong long maxScore(vector<int>& n, int x) \\n{\\n\\tlong long e{INT_MIN}, o{INT_MIN};\\n\\t(n[0]&1 ? o : e) = n[0];\\n\\tfor(int i{1}; i<size(n); ++i)\\n\\t\\tif(n[i]&1)\\n\\t\\t\\to = max(o+n[i], e+n[i]-x);\\n\\t\\telse\\n\\t\\t\\te = max(e+n[i], o+n[i]-x);\\n\\treturn max(e,o);\\n}\\n```\\n**Similar problems:**\\n[198. House Robber](https://leetcode.com/problems/house-robber/discuss/2099794/dp)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long maxScore(vector<int>& n, int x) \\n{\\n\\tlong long e{INT_MIN}, o{INT_MIN};\\n\\t(n[0]&1 ? o : e) = n[0];\\n\\tfor(int i{1}; i<size(n); ++i)\\n\\t\\tif(n[i]&1)\\n\\t\\t\\to = max(o+n[i], e+n[i]-x);\\n\\t\\telse\\n\\t\\t\\te = max(e+n[i], o+n[i]-x);\\n\\treturn max(e,o);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832810,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long max(long long i,long long j)\\n   {\\n       if (i>j) return i;\\n       return j;\\n   }\\n   long long rec(int ind,int isOdd,vector<int>&nums,int &x,vector<vector<long long>>&dp )\\n   {\\n       if (ind==nums.size()) return 0;\\n       if (dp[ind][isOdd]!=-1) return dp[ind][isOdd];\\n       long long pick=1LL*nums[ind]+rec(ind+1,nums[ind]%2,nums,x,dp) ;\\n       if (nums[ind]%2!=isOdd) pick-=1LL*x;\\n       long long notPick=rec(ind+1,isOdd,nums,x,dp);\\n       return dp[ind][isOdd]=max(pick,notPick);\\n\\n   }\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        return nums[0]+rec(1,nums[0]%2,nums,x,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long max(long long i,long long j)\\n   {\\n       if (i>j) return i;\\n       return j;\\n   }\\n   long long rec(int ind,int isOdd,vector<int>&nums,int &x,vector<vector<long long>>&dp )\\n   {\\n       if (ind==nums.size()) return 0;\\n       if (dp[ind][isOdd]!=-1) return dp[ind][isOdd];\\n       long long pick=1LL*nums[ind]+rec(ind+1,nums[ind]%2,nums,x,dp) ;\\n       if (nums[ind]%2!=isOdd) pick-=1LL*x;\\n       long long notPick=rec(ind+1,isOdd,nums,x,dp);\\n       return dp[ind][isOdd]=max(pick,notPick);\\n\\n   }\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        return nums[0]+rec(1,nums[0]%2,nums,x,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832809,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long max(long long i,long long j)\\n   {\\n       if (i>j) return i;\\n       return j;\\n   }\\n   long long rec(int ind,int isOdd,vector<int>&nums,int &x,vector<vector<long long>>&dp )\\n   {\\n       if (ind==nums.size()) return 0;\\n       if (dp[ind][isOdd]!=-1) return dp[ind][isOdd];\\n       long long pick=1LL*nums[ind]+rec(ind+1,nums[ind]%2,nums,x,dp) ;\\n       if (nums[ind]%2!=isOdd) pick-=1LL*x;\\n       long long notPick=rec(ind+1,isOdd,nums,x,dp);\\n       return dp[ind][isOdd]=max(pick,notPick);\\n\\n   }\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        return nums[0]+rec(1,nums[0]%2,nums,x,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long max(long long i,long long j)\\n   {\\n       if (i>j) return i;\\n       return j;\\n   }\\n   long long rec(int ind,int isOdd,vector<int>&nums,int &x,vector<vector<long long>>&dp )\\n   {\\n       if (ind==nums.size()) return 0;\\n       if (dp[ind][isOdd]!=-1) return dp[ind][isOdd];\\n       long long pick=1LL*nums[ind]+rec(ind+1,nums[ind]%2,nums,x,dp) ;\\n       if (nums[ind]%2!=isOdd) pick-=1LL*x;\\n       long long notPick=rec(ind+1,isOdd,nums,x,dp);\\n       return dp[ind][isOdd]=max(pick,notPick);\\n\\n   }\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        return nums[0]+rec(1,nums[0]%2,nums,x,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832096,
                "title": "simple-python-solution-dp-with-recursion-o-n-time-complexity",
                "content": "# Intuition\\n1. Observe that once a number is selected, any consecutive numbers with the same parity can be added to the total.\\n\\n2. We can easily just add all consecutive numbers together into a new array. \\nExample:\\n[2,3,6,1,9,2] => [2,3,6,10,2]\\n\\n3. This new array (let\\'s call it `arr`) has the following properties:\\na. `arr[i]` and `arr[i+1]` will always have different parities (as they are the sum of all consequtive numbers in `nums` with the same parity). \\nb. If we wish to include index `arr[i+1]` in the `total`, we must always deduct `x` from it, while `arr[i+2]` could simply be added to the current `total`. \\n\\n4. Now we can work on the solution by defining a  `recurse` function. The `total` will be `arr[i]` + the maximum of:\\na. `recurse(i+1) - x`\\nb. `recurse(i+2)`\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        def recurse(i):\\n            if i >= len(arr):\\n                return 0\\n            if dp[i] > 0:\\n                return dp[i]\\n            dp[i] = arr[i] + max(recurse(i+1) - x, recurse(i+2))\\n            return dp[i]\\n\\n        arr = [nums[0]]\\n        parity = nums[0] % 2\\n        for i in range(1, len(nums)):\\n            if nums[i] % 2 == parity:\\n                arr[-1] += nums[i]\\n            else:\\n                parity = nums[i] % 2\\n                arr.append(nums[i])\\n\\n        dp = [0 for i in range(len(arr))]\\n        return recurse(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        def recurse(i):\\n            if i >= len(arr):\\n                return 0\\n            if dp[i] > 0:\\n                return dp[i]\\n            dp[i] = arr[i] + max(recurse(i+1) - x, recurse(i+2))\\n            return dp[i]\\n\\n        arr = [nums[0]]\\n        parity = nums[0] % 2\\n        for i in range(1, len(nums)):\\n            if nums[i] % 2 == parity:\\n                arr[-1] += nums[i]\\n            else:\\n                parity = nums[i] % 2\\n                arr.append(nums[i])\\n\\n        dp = [0 for i in range(len(arr))]\\n        return recurse(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830607,
                "title": "top-down-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long maxv = nums.front();\\n/*        vector<long long>dp(n, 0);\\n        vector<int> prev(2, 0);\\n        for(int i = 0 ; i < n; i++)dp[i]=nums[i]-x*(nums[i]%2!=nums.front()%2);\\n        \\n        for(int i = 1; i <n; i++){\\n            int id1=prev[0], id2=prev[1];\\n            dp[i] = max(dp[i], dp[id1]+nums[i]-x*(nums[id1]%2!=nums[i]%2));\\n            dp[i] = max(dp[i], dp[id2]+nums[i]-x*(nums[id2]%2!=nums[i]%2));\\n            prev[nums[i]%2]=i;\\n            maxv = max(maxv, dp[i]);\\n        }*/\\n        vector<pair<int, long long>>dp(2, make_pair(0, 0));\\n        dp[0] = {0, nums.front()}; \\n        dp[1] = {0, nums.front()}; \\n                \\n        for(int i = 1; i <n; i++){\\n            int id1=dp[0].first, id2=dp[1].first;\\n            auto dp1 = max((long long) nums[i]-x*(nums.front()%2!=nums[i]%2), dp[0].second+nums[i]-x*(nums[id1]%2!=nums[i]%2));\\n            auto dp2 = max((long long) nums[i]-x*(nums.front()%2!=nums[i]%2), dp[1].second+nums[i]-x*(nums[id2]%2!=nums[i]%2));    \\n            dp[nums[i]%2]={i, max(dp1, dp2)};\\n            maxv = max(maxv, dp1);\\n            maxv = max(maxv, dp2);\\n        }\\n        return maxv;\\n    }\\n};\\n\\n/*\\n    [2,3,6,1,9,2], x = 5\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long maxv = nums.front();\\n/*        vector<long long>dp(n, 0);\\n        vector<int> prev(2, 0);\\n        for(int i = 0 ; i < n; i++)dp[i]=nums[i]-x*(nums[i]%2!=nums.front()%2);\\n        \\n        for(int i = 1; i <n; i++){\\n            int id1=prev[0], id2=prev[1];\\n            dp[i] = max(dp[i], dp[id1]+nums[i]-x*(nums[id1]%2!=nums[i]%2));\\n            dp[i] = max(dp[i], dp[id2]+nums[i]-x*(nums[id2]%2!=nums[i]%2));\\n            prev[nums[i]%2]=i;\\n            maxv = max(maxv, dp[i]);\\n        }*/\\n        vector<pair<int, long long>>dp(2, make_pair(0, 0));\\n        dp[0] = {0, nums.front()}; \\n        dp[1] = {0, nums.front()}; \\n                \\n        for(int i = 1; i <n; i++){\\n            int id1=dp[0].first, id2=dp[1].first;\\n            auto dp1 = max((long long) nums[i]-x*(nums.front()%2!=nums[i]%2), dp[0].second+nums[i]-x*(nums[id1]%2!=nums[i]%2));\\n            auto dp2 = max((long long) nums[i]-x*(nums.front()%2!=nums[i]%2), dp[1].second+nums[i]-x*(nums[id2]%2!=nums[i]%2));    \\n            dp[nums[i]%2]={i, max(dp1, dp2)};\\n            maxv = max(maxv, dp1);\\n            maxv = max(maxv, dp2);\\n        }\\n        return maxv;\\n    }\\n};\\n\\n/*\\n    [2,3,6,1,9,2], x = 5\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829689,
                "title": "c-best-solution-beats-100-optimized-dp-o-n-o-1-short-code-explained-and-commented",
                "content": "# Intuition\\n\\nWe need to follow the parity (even/odd) of the values in the array `nums`. If we are at an index $i$, then the next step will be at an index $j>i$. There are two possibilities\\n- If `nums[i]` and `nums[i+1]` have the same parity, then we may move from `i` to `i+1` to gain `nums[i+1]` points. This still allow us to move to any other position $j>i$ to gain points from then on.\\n- However, it `nums[i]` and `nums[i+1]` have different parities, we could move from `i` to the next index `j` such that `nums[i]` and `nums[j]` have the same parity (to avoid losing $x$ points), or it could be worth it to mode from `i` to `i+1`, if from `i+1` we can gain enough points to compensate the `x` points lost.\\n\\nThus, we get a backwards recursion on the maximum amount of points we can get: Let `maxPoints[i]` be the maximum amount of points we can obtain starting at index `i`. Then\\n- `maxPoints[numsSize-1] = nums[numsSize-1]`\\n- If `nums[i]` and `nums[i+1]` have the same parity, then `maxPoints[i] = nums[i] + maxPoints[i+1]`.\\n- If `nums[i]` and `nums[i+1]` have distinct parities, then `maxPoints[i] = nums[i] + max(maxPoints[i+1]-x , maxPoints[j])`, where `j>i` is the smallest index such that `nums[i]` and `nums[j]` have the same parity.\\n\\n    (If no `j` exist, substitute `maxPoints[j]` in this formula by `0`, which is the same as ending the point-obtaining steps.)\\n\\n\\n# Recursive Approach (TLE)\\n\\nThe following is the simple, unoptimized recursive approach, obtained by simply translating the algorithm above. This gives us TLE, even for small (48 element-) arrays. This is because each computation of the recursive function makes 2 recursive calls.\\n\\n```\\nlong long maxScore_(const int* nums, const int numsSize, const int x, int i){\\n    if (i==numsSize-1) return nums[i];\\n    if (nums[i]%2 == nums[i+1]%2) {\\n        // Same parity\\n        return nums[i] + maxScore_(nums, numsSize, x, i+1);\\n    }\\n    \\n    // Find the next index with same parity as nums[i]\\n    int j = i+1;\\n    while (j<numsSize && (nums[i]%2 != nums[j] %2)) ++j;\\n\\n    if (j==numsSize) {\\n        // No index with same parity\\n        return nums[i] + MAX(maxScore_(nums, numsSize, x, i+1)-x , 0);\\n    }\\n    return nums[i] + MAX(maxScore_(nums, numsSize, x, i+1)-x , maxScore_(nums, numsSize, x, j));\\n}\\n\\n\\nlong long maxScore(int* nums, int numsSize, int x){\\n    return maxScore_(nums , numsSize, x , 0);\\n}\\n```\\n\\n## Complexity\\n\\n- Time and space complexity: $O\\\\left(\\\\left(\\\\dfrac{1+\\\\sqrt{5}}{2}\\\\right)^n\\\\right)$ (Fibonacci)\\n\\nThe obvious way to solve this problem is by DP.\\n\\n# Unoptimized DP approach\\n\\nWe store the values of the maximum points obtainable from starting from index `i` in a value `dp[i]`, which gives us a DP table/array `dp[]`, with the same length as the original array. This table is filled according to the recursive rule.\\n\\nSince `dp[i]` always depends directly on `dp[i+1]`, we implement a bottom-up approach (starting from the end and going to the beginning of the DP table).\\n\\n```\\n#define MAX(a,b) (a>=b ? a : b)\\n\\nlong long maxScore(int* nums, int numsSize, int x){\\n    long long * dp = malloc(numsSize*sizeof(long long));\\n    // Holds the maximum score obtainable from each index\\n    dp[numsSize-1] = nums[numsSize-1];\\n    int i=numsSize-2;\\n    while (i>=0) {\\n        if (nums[i]%2 == nums[i+1]%2) {\\n            // Same parity\\n            dp[i] = nums[i] + dp[i+1];\\n        } else {\\n            int j=i+1;\\n            // Find the next index with same parity as nums[i]\\n            while (j<numsSize && !(nums[i]%2 == nums[j]%2)) ++j;\\n            if (j==numsSize) {\\n                // No index with same parity\\n                if (dp[i+1]>x) {\\n                    dp[i] = nums[i] + dp[i+1]-x;\\n                } else {\\n                    dp[i] = nums[i];\\n                }\\n            } else {\\n                // nums[j] ans nums[i] have the same parity\\n                dp[i] = nums[i] + MAX(dp[i+1]-x , dp[j]);\\n            }\\n        }\\n        --i;\\n    }\\n\\n    return dp[0];\\n}\\n``` \\n\\n## Complexity\\n\\n- Time and space complexity: $O(n)$.\\n\\nThis works well and solves the problem, however it is in the lower 20% of space and time efficiency\\n\\n\\n\\n# Optimized DP approach\\n\\nWhen computing the DP table in the approach above, the problem of computing `dp[i]` in terms of `dp[j]` ($j>i$) depends on whether `nums[i]` and `nums[j]` have the same parity. But in fact we do not care about the values of `num[j]` for ***all*** $j>i$, but only the two smallest values of $j$ for which `num[j]` has the same or a different parity than `nums[i]`.\\n\\nThus, it is sufficient to only store values in our DP table which tell us the maximum obtainable points from a given index, starting from an index `j` for which `nums[j]` is odd or even. In this sense, `dp[i]` is computed as follows:\\n\\n> Choose the next index `j>i` such that the maximum obtainable points from `j` are the largest, even if `nums[j]` has a different parity from `nums[i]`.\\n\\nBy storing those maximum values for both `nums[j]` even and odd, we obtain our recursive rule: Let `dp[even]` and `dp[odd]` be the maximum attainable points which may be obtained by starting the game from an index `j>i` for which `nums[j]` is even and odd, respectively. Then\\n\\n`dp[i] = nums[i] + MAX(dp[parity(i))] , dp[not(parity(i))]-x)`\\n\\nThen the value of `dp[parity of i]` is updated with this `dp[i]`.\\n\\nA few minor optimizations apart (using `&1` to compute parity instead of `%2`; `register` and `const` keywords), we implement this code as our final solution.\\n\\n```\\n#define MAX(a,b) (a>=b ? a : b)\\n\\nlong long maxScore(const int* nums, const int numsSize, const int x){\\n    long dp[2] = {0};\\n    // dp[0] is dp of even value for nums[i]\\n    // dp[1] is dp of odd value for nums[i];\\n    // That is; dp[nums[i]%2] is the dp of the right parity\\n\\n    // Holds the maximum score obtainable from each index\\n    register int parity = nums[numsSize-1] & 1;\\n    dp[parity] = nums[numsSize-1];\\n    for ( int i=numsSize-2 ; i>=0 ; --i) {\\n        parity = nums[i] & 1;\\n        dp[parity] = nums[i] + MAX(dp[!parity]-x , dp[parity]);\\n    }\\n    // Parity holds the parity of nums[0]\\n    return dp[parity];\\n}\\n```\\n\\n## Complexity\\n- Time complexity: $O(n)$ (traverse the array once)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$ (just a few auxiliary variables)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Results\\n\\n![image.png](https://assets.leetcode.com/users/images/80155481-1b85-40be-acde-f6f69de3a7bf_1690550693.059089.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long maxScore_(const int* nums, const int numsSize, const int x, int i){\\n    if (i==numsSize-1) return nums[i];\\n    if (nums[i]%2 == nums[i+1]%2) {\\n        // Same parity\\n        return nums[i] + maxScore_(nums, numsSize, x, i+1);\\n    }\\n    \\n    // Find the next index with same parity as nums[i]\\n    int j = i+1;\\n    while (j<numsSize && (nums[i]%2 != nums[j] %2)) ++j;\\n\\n    if (j==numsSize) {\\n        // No index with same parity\\n        return nums[i] + MAX(maxScore_(nums, numsSize, x, i+1)-x , 0);\\n    }\\n    return nums[i] + MAX(maxScore_(nums, numsSize, x, i+1)-x , maxScore_(nums, numsSize, x, j));\\n}\\n\\n\\nlong long maxScore(int* nums, int numsSize, int x){\\n    return maxScore_(nums , numsSize, x , 0);\\n}\\n```\n```\\n#define MAX(a,b) (a>=b ? a : b)\\n\\nlong long maxScore(int* nums, int numsSize, int x){\\n    long long * dp = malloc(numsSize*sizeof(long long));\\n    // Holds the maximum score obtainable from each index\\n    dp[numsSize-1] = nums[numsSize-1];\\n    int i=numsSize-2;\\n    while (i>=0) {\\n        if (nums[i]%2 == nums[i+1]%2) {\\n            // Same parity\\n            dp[i] = nums[i] + dp[i+1];\\n        } else {\\n            int j=i+1;\\n            // Find the next index with same parity as nums[i]\\n            while (j<numsSize && !(nums[i]%2 == nums[j]%2)) ++j;\\n            if (j==numsSize) {\\n                // No index with same parity\\n                if (dp[i+1]>x) {\\n                    dp[i] = nums[i] + dp[i+1]-x;\\n                } else {\\n                    dp[i] = nums[i];\\n                }\\n            } else {\\n                // nums[j] ans nums[i] have the same parity\\n                dp[i] = nums[i] + MAX(dp[i+1]-x , dp[j]);\\n            }\\n        }\\n        --i;\\n    }\\n\\n    return dp[0];\\n}\\n```\n```\\n#define MAX(a,b) (a>=b ? a : b)\\n\\nlong long maxScore(const int* nums, const int numsSize, const int x){\\n    long dp[2] = {0};\\n    // dp[0] is dp of even value for nums[i]\\n    // dp[1] is dp of odd value for nums[i];\\n    // That is; dp[nums[i]%2] is the dp of the right parity\\n\\n    // Holds the maximum score obtainable from each index\\n    register int parity = nums[numsSize-1] & 1;\\n    dp[parity] = nums[numsSize-1];\\n    for ( int i=numsSize-2 ; i>=0 ; --i) {\\n        parity = nums[i] & 1;\\n        dp[parity] = nums[i] + MAX(dp[!parity]-x , dp[parity]);\\n    }\\n    // Parity holds the parity of nums[0]\\n    return dp[parity];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829596,
                "title": "easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep a check on previously taken element and decide whether to select the current element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0/1 Knapsack.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<long long>> dp(n,vector<long long>(2,LONG_MIN));\\n        function<long long(int,int)> dfs=[&](int ind,int even){\\n            if(ind==n) return 0LL;\\n            if(dp[ind][even]!=LONG_MIN) return dp[ind][even];\\n            long long res=dfs(ind+1,even);\\n            if(nums[ind]%2==0&&even==0) {\\n                res=max(res,nums[ind]-x+dfs(ind+1,1));\\n            }\\n            else if(nums[ind]%2==0&&even==1) {\\n                res=max(res,nums[ind]+dfs(ind+1,1));\\n            }\\n            else if(nums[ind]%2==1&&even==0) {\\n                res=max(res,nums[ind]+dfs(ind+1,0));\\n            }\\n            else if(nums[ind]%2==1&&even==1) {\\n                res=max(res,nums[ind]-x+dfs(ind+1,0));\\n            }\\n            return dp[ind][even]=res;\\n        };\\n        return nums[0]+dfs(1,nums[0]%2==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<long long>> dp(n,vector<long long>(2,LONG_MIN));\\n        function<long long(int,int)> dfs=[&](int ind,int even){\\n            if(ind==n) return 0LL;\\n            if(dp[ind][even]!=LONG_MIN) return dp[ind][even];\\n            long long res=dfs(ind+1,even);\\n            if(nums[ind]%2==0&&even==0) {\\n                res=max(res,nums[ind]-x+dfs(ind+1,1));\\n            }\\n            else if(nums[ind]%2==0&&even==1) {\\n                res=max(res,nums[ind]+dfs(ind+1,1));\\n            }\\n            else if(nums[ind]%2==1&&even==0) {\\n                res=max(res,nums[ind]+dfs(ind+1,0));\\n            }\\n            else if(nums[ind]%2==1&&even==1) {\\n                res=max(res,nums[ind]-x+dfs(ind+1,0));\\n            }\\n            return dp[ind][even]=res;\\n        };\\n        return nums[0]+dfs(1,nums[0]%2==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828898,
                "title": "non-dp-solution-very-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n        ll even=0;\\n        ll odd =0;\\n        ll ans=0;\\n        int n = nums.size();\\n\\n        if(nums[0]%2 ==0 )\\n        {\\n            even += nums[0];\\n            odd += nums[0] - x;\\n        }\\n        else\\n        {\\n            even += nums[0]-x;\\n            odd += nums[0];\\n        }\\n\\n        ans = max(odd,even);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i] %2 == 0)\\n            {\\n                even = max(even + nums[i], odd + nums[i] - x);\\n            }\\n            else\\n            {\\n                odd = max(even + nums[i] -x, odd + nums[i]);\\n            }\\n            ans = max(even,odd);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n        ll even=0;\\n        ll odd =0;\\n        ll ans=0;\\n        int n = nums.size();\\n\\n        if(nums[0]%2 ==0 )\\n        {\\n            even += nums[0];\\n            odd += nums[0] - x;\\n        }\\n        else\\n        {\\n            even += nums[0]-x;\\n            odd += nums[0];\\n        }\\n\\n        ans = max(odd,even);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i] %2 == 0)\\n            {\\n                even = max(even + nums[i], odd + nums[i] - x);\\n            }\\n            else\\n            {\\n                odd = max(even + nums[i] -x, odd + nums[i]);\\n            }\\n            ans = max(even,odd);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826512,
                "title": "python-find-the-max-score-at-each-index-explained",
                "content": "For each index, we can calculate the maximum score that we can get based on the scores from previous index. There are only two possible cases that we can move to current index:\\n(1) We do a parity switch: the score is the maximum score at the previous index having different parity value plus nums[index], and minus `x`.\\n(2) We do NOT do a parity switch: the score is the maximum score at the previous index having the same parity value plus nums[index]\\n\\nThe maximum score at current index is the maximum value of the above two.\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        prev_odd_idx, prev_even_idx = -1, -1\\n        if nums[0] % 2:\\n            prev_odd_idx = 0\\n        else:\\n            prev_even_idx = 0\\n            \\n        ans, idx = nums[0], 1\\n        while idx < len(nums):\\n            t_score_ns = t_score_s = float(\\'-inf\\')\\n            if nums[idx] % 2:\\n                if prev_odd_idx >= 0:\\n                    t_score_ns = nums[prev_odd_idx]\\n                if prev_even_idx >= 0:\\n                    t_score_s = nums[prev_even_idx] - x\\n                \\n                prev_odd_idx = idx\\n            else:\\n                if prev_odd_idx >= 0:\\n                    t_score_s = nums[prev_odd_idx] - x\\n                if prev_even_idx >= 0:\\n                    t_score_ns = nums[prev_even_idx]\\n                    \\n                prev_even_idx = idx\\n            \\n            nums[idx] += max(t_score_ns, t_score_s)\\n            ans = max(ans, nums[idx])\\n            idx += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        prev_odd_idx, prev_even_idx = -1, -1\\n        if nums[0] % 2:\\n            prev_odd_idx = 0\\n        else:\\n            prev_even_idx = 0\\n            \\n        ans, idx = nums[0], 1\\n        while idx < len(nums):\\n            t_score_ns = t_score_s = float(\\'-inf\\')\\n            if nums[idx] % 2:\\n                if prev_odd_idx >= 0:\\n                    t_score_ns = nums[prev_odd_idx]\\n                if prev_even_idx >= 0:\\n                    t_score_s = nums[prev_even_idx] - x\\n                \\n                prev_odd_idx = idx\\n            else:\\n                if prev_odd_idx >= 0:\\n                    t_score_s = nums[prev_odd_idx] - x\\n                if prev_even_idx >= 0:\\n                    t_score_ns = nums[prev_even_idx]\\n                    \\n                prev_even_idx = idx\\n            \\n            nums[idx] += max(t_score_ns, t_score_s)\\n            ans = max(ans, nums[idx])\\n            idx += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826176,
                "title": "c-dynamic-programming-bottom-up",
                "content": "# Intuition\\nwe need to keep track of maxEvenParity and maxOddParity at an element. Tricky thing is to find out parity for the first (0th) element. \\n\\n# Complexity\\n- Time complexity:\\nO(N) -> N= number of elements in nums\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long evenP=0, oddP=0;\\n        if (nums[0]%2==0) evenP=nums[0],oddP=-x;\\n        else evenP=-x,oddP=nums[0];\\n\\n        for (int i=1;i<nums.size();i++){\\n            if (nums[i]%2 == 0){\\n                evenP = max(evenP+nums[i],oddP-x+nums[i]);\\n                \\n            }\\n            else{\\n                oddP = max(oddP+nums[i],evenP-x+nums[i]);\\n                \\n            }\\n        }\\n        return max(evenP,oddP);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long evenP=0, oddP=0;\\n        if (nums[0]%2==0) evenP=nums[0],oddP=-x;\\n        else evenP=-x,oddP=nums[0];\\n\\n        for (int i=1;i<nums.size();i++){\\n            if (nums[i]%2 == 0){\\n                evenP = max(evenP+nums[i],oddP-x+nums[i]);\\n                \\n            }\\n            else{\\n                oddP = max(oddP+nums[i],evenP-x+nums[i]);\\n                \\n            }\\n        }\\n        return max(evenP,oddP);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823047,
                "title": "c-dp-100-time-67ms-82-space-99-44mb",
                "content": "Nice problem to practice some Dynamic Programming (henceforth: \"DP\"), since we have\\n* a base case (when we have only one element to add and we come from either an even or an odd previous sum);\\n* a general one (when we have multiple elements left).\\n\\nWe can solve it by parsing our input and having a store of the past states; we might be tempted to store all the previous states as we go, but in reality we only need two - one for the best even and one for the best odd sum we can get.\\n\\nTo do so, let\\'s start declaring our support variables:\\n* `len` will store the length of our input;\\n* `dp` is an array of two elements, our even and odd case.\\n\\nWe will then write `nums[0]` in both cells of `dp`, then subtract `x` by the one not having parity with `nums[0]` (ie: `nums[!(nums[0] & 1)]`).\\n\\nNow we can proceed, sorting all the elements from the second with `i` going from `1` to the end of the series and:\\n* storing `nums[i]` in `n`;\\n* storing our parity (ie: `n & 1`) in `curr`;\\n* if we are currently dealing with an odd `n` (ie: `curr == 1`), we will set `dp[1]` to be the maximum between its current value and `dp[0] - x`, both additioned with `n`;\\n* specularly for an even case, we will set `dp[0]` to be the maximum between its current value and `dp[1] - x`, both additioned with `n`.\\n\\nOnce done, we will `return` the maximum between the even and odd scenarios (ie: `max(dp[0], dp[1])`).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        // support variables\\n        int len = nums.size();\\n        long long dp[2];\\n        // preparing dp\\n        dp[0] = dp[1] = nums[0];\\n        dp[!(nums[0] & 1)] -= x;\\n        // updating dp with each value after the first\\n        for (int i = 1, n, curr; i < len; i++) {\\n            n = nums[i], curr = n & 1;\\n            // odd case:\\n            if (curr) dp[1] = max(dp[1], dp[0] - x) + n;\\n            // even case:\\n            else dp[0] = max(dp[0], dp[1] - x) + n;\\n        }\\n        return max(dp[0], dp[1]);\\n    }\\n};\\n```\\nOr we can make it even more concise, by already setting `dp` with the right starting values and avoiding the conditional inside our loop and just using `curr` to decide what is needed:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        // support variables\\n        int len = nums.size();\\n        long long dp[2] = {nums[0], nums[0]};\\n        // preparing dp\\n        dp[!(nums[0] & 1)] -= x;\\n        // updating dp with each value after the first\\n        for (int i = 1, n, curr; i < len; i++) {\\n            n = nums[i], curr = n & 1;\\n            dp[curr] = max(dp[curr], dp[!curr] - x) + n;\\n        }\\n        return max(dp[0], dp[1]);\\n    }\\n};\\n```\\n\\nOr we can just have the loop take all the elements, as long as we just initialise `dp` to be `0` and `-x` for the elements matching and not matching the parity of `nums[0]`, respectively:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        // support variables\\n        int len = nums.size();\\n        long long dp[2] = {};\\n        bool curr = !(nums[0] & 1);\\n        // preparing dp\\n        dp[curr] -= x;\\n        // updating dp with each value after the first\\n        for (int n: nums) {\\n            curr = n & 1;\\n            dp[curr] = max(dp[curr], dp[!curr] - x) + n;\\n        }\\n        return max(dp[0], dp[1]);\\n    }\\n};\\n```\\n\\nPrevious valiant attempt to try and solve it with memoisation, although I was fairly sure it would have TLEd.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nconstexpr int maxSize = 10001;\\n\\nclass Solution {\\n    int dp[2][maxSize], x, len;\\n    vector<int> nums;\\n    int dfs(bool isOdd, int pos = 0) {\\n        if (pos == len) return 0;\\n        if (dp[isOdd][pos] != -1) return dp[isOdd][pos];\\n        int res = 0;\\n        for (int i = pos + 1, n, tmp; i < len; i++) {\\n            n = nums[i];\\n            tmp = dfs(nums[i] & 1, i);\\n            if ((n & 1) != isOdd) tmp -= x;\\n            res = max(res, tmp);\\n        }\\n        return dp[isOdd][pos] = nums[pos] + res;\\n    }\\npublic:\\n    long long maxScore(vector<int> &tmp, int x) {\\n        swap(tmp, nums);\\n        this->x = x;\\n        len = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(nums[0] & 1);\\n    }\\n};\\n```\\n\\n# Brag\\n![image.png](https://assets.leetcode.com/users/images/b96262a2-202e-42a6-b46c-6f2daf21211a_1690451907.5754812.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        // support variables\\n        int len = nums.size();\\n        long long dp[2];\\n        // preparing dp\\n        dp[0] = dp[1] = nums[0];\\n        dp[!(nums[0] & 1)] -= x;\\n        // updating dp with each value after the first\\n        for (int i = 1, n, curr; i < len; i++) {\\n            n = nums[i], curr = n & 1;\\n            // odd case:\\n            if (curr) dp[1] = max(dp[1], dp[0] - x) + n;\\n            // even case:\\n            else dp[0] = max(dp[0], dp[1] - x) + n;\\n        }\\n        return max(dp[0], dp[1]);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        // support variables\\n        int len = nums.size();\\n        long long dp[2] = {nums[0], nums[0]};\\n        // preparing dp\\n        dp[!(nums[0] & 1)] -= x;\\n        // updating dp with each value after the first\\n        for (int i = 1, n, curr; i < len; i++) {\\n            n = nums[i], curr = n & 1;\\n            dp[curr] = max(dp[curr], dp[!curr] - x) + n;\\n        }\\n        return max(dp[0], dp[1]);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        // support variables\\n        int len = nums.size();\\n        long long dp[2] = {};\\n        bool curr = !(nums[0] & 1);\\n        // preparing dp\\n        dp[curr] -= x;\\n        // updating dp with each value after the first\\n        for (int n: nums) {\\n            curr = n & 1;\\n            dp[curr] = max(dp[curr], dp[!curr] - x) + n;\\n        }\\n        return max(dp[0], dp[1]);\\n    }\\n};\\n```\n```cpp\\nconstexpr int maxSize = 10001;\\n\\nclass Solution {\\n    int dp[2][maxSize], x, len;\\n    vector<int> nums;\\n    int dfs(bool isOdd, int pos = 0) {\\n        if (pos == len) return 0;\\n        if (dp[isOdd][pos] != -1) return dp[isOdd][pos];\\n        int res = 0;\\n        for (int i = pos + 1, n, tmp; i < len; i++) {\\n            n = nums[i];\\n            tmp = dfs(nums[i] & 1, i);\\n            if ((n & 1) != isOdd) tmp -= x;\\n            res = max(res, tmp);\\n        }\\n        return dp[isOdd][pos] = nums[pos] + res;\\n    }\\npublic:\\n    long long maxScore(vector<int> &tmp, int x) {\\n        swap(tmp, nums);\\n        this->x = x;\\n        len = nums.size();\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(nums[0] & 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822421,
                "title": "python-2-dp-array-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\'\\'\\'\\n        [2,3,6,1,9,2], x = 5\\n        \\n        [2 ,0,0,0,0,0]\\n        [-3,0,0,0,0,0]\\n        \\n        [2 ,2,0,0,0,0]\\n        [-3,0,0,0,0,0]\\n        \\n        [2 ,2,8,0,0,0]\\n        [-3,0,0,0,0,0]\\n        \\n        [2 ,2,8,8,0,0]\\n        [-3,0,0,4,0,0]\\n        \\n        [2 ,2,8,8,8, 0]\\n        [-3,0,0,4,13,0]\\n        \\n        [2 ,2,8,8,8, 10]\\n        [-3,0,0,4,13,13]\\n        \\n        \\'\\'\\'\\n        n = len(nums)\\n        even = [0]*n\\n        odd = [0]*n\\n        even[0] = odd[0] = nums[0]\\n        \\n        if nums[0]%2 == 0: odd[0] -= x\\n        else: even[0] -= x\\n        \\n        for i in range(1,n):\\n            if nums[i]%2 == 0:\\n                even[i] = max( even[i-1]+nums[i], odd[i-1]+nums[i]-x)\\n                odd[i] = odd[i-1]\\n            else:\\n                even[i] = even[i-1]\\n                odd[i] = max( even[i-1]+nums[i]-x, odd[i-1]+nums[i])\\n        return max(even[-1], odd[-1])\\n       \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\'\\'\\'\\n        [2,3,6,1,9,2], x = 5\\n        \\n        [2 ,0,0,0,0,0]\\n        [-3,0,0,0,0,0]\\n        \\n        [2 ,2,0,0,0,0]\\n        [-3,0,0,0,0,0]\\n        \\n        [2 ,2,8,0,0,0]\\n        [-3,0,0,0,0,0]\\n        \\n        [2 ,2,8,8,0,0]\\n        [-3,0,0,4,0,0]\\n        \\n        [2 ,2,8,8,8, 0]\\n        [-3,0,0,4,13,0]\\n        \\n        [2 ,2,8,8,8, 10]\\n        [-3,0,0,4,13,13]\\n        \\n        \\'\\'\\'\\n        n = len(nums)\\n        even = [0]*n\\n        odd = [0]*n\\n        even[0] = odd[0] = nums[0]\\n        \\n        if nums[0]%2 == 0: odd[0] -= x\\n        else: even[0] -= x\\n        \\n        for i in range(1,n):\\n            if nums[i]%2 == 0:\\n                even[i] = max( even[i-1]+nums[i], odd[i-1]+nums[i]-x)\\n                odd[i] = odd[i-1]\\n            else:\\n                even[i] = even[i-1]\\n                odd[i] = max( even[i-1]+nums[i]-x, odd[i-1]+nums[i])\\n        return max(even[-1], odd[-1])\\n       \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819246,
                "title": "intuitive-top-down-dp-memoization-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem appears to be a variant of the Knapsack problem where we face two choices at every step: to include or skip an element. Additionally, we must consider parity, ensuring that if the previously selected element was even, the current element must also be even; otherwise, we subtract \\'x\\' from the score.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @lru_cache(None)\\n        def solve(cur,isOdd):\\n            if cur>=len(nums):\\n                return 0\\n            currentParity=nums[cur]&1\\n            ans=solve(cur+1,isOdd)\\n            if currentParity != isOdd:\\n                ans=max(ans,solve(cur+1,currentParity)-x+nums[cur])\\n            else:\\n                ans=max(ans,solve(cur+1,currentParity)+nums[cur])\\n            return ans\\n        return solve(0,nums[0]&1)\\n\\n                \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @lru_cache(None)\\n        def solve(cur,isOdd):\\n            if cur>=len(nums):\\n                return 0\\n            currentParity=nums[cur]&1\\n            ans=solve(cur+1,isOdd)\\n            if currentParity != isOdd:\\n                ans=max(ans,solve(cur+1,currentParity)-x+nums[cur])\\n            else:\\n                ans=max(ans,solve(cur+1,currentParity)+nums[cur])\\n            return ans\\n        return solve(0,nums[0]&1)\\n\\n                \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819187,
                "title": "recursion-memoization-c-pick-not-pick",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long f(long long int n,long long prev,long long int x,vector<int>& arr,vector<vector<long long>> &dp){\\n        if(n==0){\\n            if(prev==2 || arr[n]%2 == prev) return dp[n][prev] = arr[n];\\n            else return dp[n][prev] = arr[n] - x;\\n        }\\n\\n        if(dp[n][prev] != -1) return dp[n][prev];\\n\\n        long long nt = f(n-1,prev,x,arr,dp);\\n        long long t=0;\\n        if(prev == 2 || arr[n]%2 == prev){\\n            t = arr[n] + f(n-1,arr[n]%2,x,arr,dp);\\n        }else{\\n            t = arr[n] - x + f(n-1,arr[n]%2,x,arr,dp);\\n        } \\n        return dp[n][prev] = max(nt,t);\\n    }\\n    long long maxScore(vector<int>& arr, int x) {\\n        long long int n = arr.size();\\n        vector<vector<long long>> dp(n,vector<long long>(3,-1));\\n        return f(n-1,2,x,arr,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(long long int n,long long prev,long long int x,vector<int>& arr,vector<vector<long long>> &dp){\\n        if(n==0){\\n            if(prev==2 || arr[n]%2 == prev) return dp[n][prev] = arr[n];\\n            else return dp[n][prev] = arr[n] - x;\\n        }\\n\\n        if(dp[n][prev] != -1) return dp[n][prev];\\n\\n        long long nt = f(n-1,prev,x,arr,dp);\\n        long long t=0;\\n        if(prev == 2 || arr[n]%2 == prev){\\n            t = arr[n] + f(n-1,arr[n]%2,x,arr,dp);\\n        }else{\\n            t = arr[n] - x + f(n-1,arr[n]%2,x,arr,dp);\\n        } \\n        return dp[n][prev] = max(nt,t);\\n    }\\n    long long maxScore(vector<int>& arr, int x) {\\n        long long int n = arr.size();\\n        vector<vector<long long>> dp(n,vector<long long>(3,-1));\\n        return f(n-1,2,x,arr,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818217,
                "title": "complete-explained-recursive-dp-solution",
                "content": "\\nDifferent  parities  means one number is odd and one is even and same parity means both are of same type.\\n(comparing 0th bit)\\n\\nINTUTION: first i thought let\\'s say we are done till some index idx and from this index let\\'s solve for our best solution but even by apperence it seems linear solution but it goes O(n^2) solution (see the comment out solve function )so then\\n\\ni thought to keep two pointers current and prev So here because of two variables it may seem O(n^2) solution\\n\\nbut let\\'s think why we need a pre pointer ?\\nanswer is very simple to check wheather the previous selected number was odd or even and if curr is also of the same type then we can simply either include that number without subtracting x or we can ignore it \\n\\nso to keep track of prev number was odd or even we can do it by just passing 0 or 1 as pre variable in solve function\\nand check  current num is of same type or not by taking remainder or a[idx] by 2 and compair it with  ```pre```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int x;\\n    int n;\\n    \\n    long long dp[100002][2];\\n    \\n    long long solve(int idx, vector<int>&a, int pre)\\n    {\\n        if(idx==n) return 0;\\n        if(dp[idx][pre]!=-1) return dp[idx][pre];\\n        long long ans=0;\\n        int r= a[idx]%2;\\n        if(r==pre)\\n        {               // take it                 don\\'t take it\\n            ans= max( solve(idx+1,a,r)+a[idx], solve(idx+1,a,pre));\\n        }else \\n        {               // take it                 don\\'t take it\\n            ans= max(solve(idx+1,a,r)+a[idx]-x, solve(idx+1,a,pre));\\n        }\\n        \\n        return dp[idx][pre]=ans;\\n    }\\n    \\n    \\n//     long long solve(int idx, vector<int> &a)\\n//     {\\n//         long long ans=a[idx];\\n//         if(idx==n) return 0;\\n//         if(dp[idx]!=-1) return dp[idx];\\n//         for(int i=idx+1; i<n; i++)\\n//         {\\n//             if((a[idx]%2)==(a[i]%2)) ans= max(ans, solve(i,a)+a[idx]);\\n//             else ans= max(ans, solve(i,a)+a[idx]-x);\\n//         }\\n        \\n//         return dp[idx]=ans;\\n//     }\\n    \\n    long long maxScore(vector<int>& nums, int x1) \\n    {\\n        \\n        n=nums.size();\\n        x=x1;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,nums, nums[0]%2)+nums[0];\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```pre```\n```\\nclass Solution {\\npublic:\\n    \\n    int x;\\n    int n;\\n    \\n    long long dp[100002][2];\\n    \\n    long long solve(int idx, vector<int>&a, int pre)\\n    {\\n        if(idx==n) return 0;\\n        if(dp[idx][pre]!=-1) return dp[idx][pre];\\n        long long ans=0;\\n        int r= a[idx]%2;\\n        if(r==pre)\\n        {               // take it                 don\\'t take it\\n            ans= max( solve(idx+1,a,r)+a[idx], solve(idx+1,a,pre));\\n        }else \\n        {               // take it                 don\\'t take it\\n            ans= max(solve(idx+1,a,r)+a[idx]-x, solve(idx+1,a,pre));\\n        }\\n        \\n        return dp[idx][pre]=ans;\\n    }\\n    \\n    \\n//     long long solve(int idx, vector<int> &a)\\n//     {\\n//         long long ans=a[idx];\\n//         if(idx==n) return 0;\\n//         if(dp[idx]!=-1) return dp[idx];\\n//         for(int i=idx+1; i<n; i++)\\n//         {\\n//             if((a[idx]%2)==(a[i]%2)) ans= max(ans, solve(i,a)+a[idx]);\\n//             else ans= max(ans, solve(i,a)+a[idx]-x);\\n//         }\\n        \\n//         return dp[idx]=ans;\\n//     }\\n    \\n    long long maxScore(vector<int>& nums, int x1) \\n    {\\n        \\n        n=nums.size();\\n        x=x1;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,nums, nums[0]%2)+nums[0];\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817520,
                "title": "rust-python-linear-time-constant-space-with-explanation",
                "content": "# Intuition\\nImportant part is to notice that this is a DP problem and you need to know only two values (`max_odd`, `max_even`) and at any step the recurrence relationship is:\\n\\n```\\nif el % 2 == 1 {\\n  max_even = max(max_even + el, max_odd + el - x)\\n} else {\\n  max_odd  = max(max_odd + el, max_even + el - x)\\n}\\n```\\n\\nNow all we need is to find starting values. They depend on the parity of `nums[0]`: `max_odd, max_even = (-float(\\'inf\\'), 0) if nums[0] % 2 == 0 else (0, -float(\\'inf\\'))`. But you can also use first number as a starting number and start iterating from the first value of the array (instead of zeroth)\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn max_score(nums: Vec<i32>, x: i32) -> i64 {\\n    let x = x as i64;\\n    let (mut max_odd, mut max_even) = (i32::MIN as i64, i32::MIN as i64);\\n    if nums[0] & 1 == 0 {\\n      max_even = nums[0] as i64;\\n    } else {\\n      max_odd = nums[0] as i64;\\n    }\\n\\n    for i in 1 .. nums.len() {\\n      if nums[i] & 1 == 0 {\\n        max_even = max_even.max(max_odd - x) + nums[i] as i64;\\n      } else {\\n        max_odd = max_odd.max(max_even - x) + nums[i] as i64;       \\n      }\\n    }\\n\\n    return max_even.max(max_odd);\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def maxScore(self, nums: List[int], x: int) -> int:\\n    max_odd, max_even = (-float(\\'inf\\'), 0) if nums[0] % 2 == 0 else (0, -float(\\'inf\\'))\\n    for v in nums:\\n      if v % 2:\\n        max_odd = max(max_odd + v, max_even + v - x)\\n      else:\\n        max_even = max(max_even + v, max_odd + v - x)\\n    \\n    return max(max_odd, max_even)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```\\nif el % 2 == 1 {\\n  max_even = max(max_even + el, max_odd + el - x)\\n} else {\\n  max_odd  = max(max_odd + el, max_even + el - x)\\n}\\n```\n```Rust []\\nimpl Solution {\\n  pub fn max_score(nums: Vec<i32>, x: i32) -> i64 {\\n    let x = x as i64;\\n    let (mut max_odd, mut max_even) = (i32::MIN as i64, i32::MIN as i64);\\n    if nums[0] & 1 == 0 {\\n      max_even = nums[0] as i64;\\n    } else {\\n      max_odd = nums[0] as i64;\\n    }\\n\\n    for i in 1 .. nums.len() {\\n      if nums[i] & 1 == 0 {\\n        max_even = max_even.max(max_odd - x) + nums[i] as i64;\\n      } else {\\n        max_odd = max_odd.max(max_even - x) + nums[i] as i64;       \\n      }\\n    }\\n\\n    return max_even.max(max_odd);\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def maxScore(self, nums: List[int], x: int) -> int:\\n    max_odd, max_even = (-float(\\'inf\\'), 0) if nums[0] % 2 == 0 else (0, -float(\\'inf\\'))\\n    for v in nums:\\n      if v % 2:\\n        max_odd = max(max_odd + v, max_even + v - x)\\n      else:\\n        max_even = max(max_even + v, max_odd + v - x)\\n    \\n    return max(max_odd, max_even)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816700,
                "title": "dp-with-step-by-step-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->->We have 2 choices either to pick the current element or not pick the current element\\n->We will consider even elements with 0 parity and odd elements with 1 parity\\n ->After picking a particular element we have to keep track of the parity of current element \\n->Now , we start with the first choice of not picking the element....in this we don\\'t have to change our current parity because we are not conisdering this element so we will directly call the function on i+1(next index) with same parity\\n->Our second choice is we can pick the element \\n->We have 2 options if the element is having same parity as preious or not \\n-->if it is having same parity we will add nums[i]+(function call with same parity)\\n-->if it is having a different parity we will add nums[i]-x+(function call with different parity)\\nfor changing the parity we can use nums[i]%2.\\n->return max(pick,not_pick)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long t[100001][3] ;\\n    long long solve(vector<int>& nums, int x, int i , bool parity)\\n    {\\n        if(i == nums.size())\\n            return 0 ;\\n            if(t[i][parity] != -1)\\n            return t[i][parity] ;\\n        long long not_pick = 0 ;\\n        long long pick = 0 ;\\n        not_pick = solve(nums,x,i+1,parity) ;\\n        if(parity == 0 && nums[i]%2==0 || parity == 1 && nums[i]%2 !=0)\\n//checking if the current element is having the same parity as prev\\n        {\\n           pick = nums[i]+solve(nums,x,i+1,parity) ;\\n        }\\n         else{\\n             pick = nums[i]-x+solve(nums,x,i+1,nums[i]%2) ; //chnaging the parity after picking\\n         } \\n         t[i][parity] = max(pick,not_pick) ;\\n         return t[i][parity] ;\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long parity = 0 ;\\n        if(nums[0]&1)\\n            parity = 1 ; //changing parity for odd\\n        memset(t,-1,sizeof(t)) ;\\n        int n = nums.size() ;\\n        return solve(nums , x , 0 , parity) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long t[100001][3] ;\\n    long long solve(vector<int>& nums, int x, int i , bool parity)\\n    {\\n        if(i == nums.size())\\n            return 0 ;\\n            if(t[i][parity] != -1)\\n            return t[i][parity] ;\\n        long long not_pick = 0 ;\\n        long long pick = 0 ;\\n        not_pick = solve(nums,x,i+1,parity) ;\\n        if(parity == 0 && nums[i]%2==0 || parity == 1 && nums[i]%2 !=0)\\n//checking if the current element is having the same parity as prev\\n        {\\n           pick = nums[i]+solve(nums,x,i+1,parity) ;\\n        }\\n         else{\\n             pick = nums[i]-x+solve(nums,x,i+1,nums[i]%2) ; //chnaging the parity after picking\\n         } \\n         t[i][parity] = max(pick,not_pick) ;\\n         return t[i][parity] ;\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long parity = 0 ;\\n        if(nums[0]&1)\\n            parity = 1 ; //changing parity for odd\\n        memset(t,-1,sizeof(t)) ;\\n        int n = nums.size() ;\\n        return solve(nums , x , 0 , parity) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814451,
                "title": "python-dp-chatgpt",
                "content": "<details>\\n<summary><strong style=\"font-size: 36px;\">Disclaimer</strong></summary>\\n\\nChatGPT helped me write the solution post\\n\\n</details>\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo maximize the total score while visiting positions in the array, we need to make the right decision at each step. When visiting an index `i`, we have two choices for the next index `j` (where `j` > `i`):\\n\\nIf the parity of `nums[i]` and `nums[j]` is the same, we can directly add the values of `nums[i]` and `nums[j]` to the total score.\\nIf the parity of `nums[i]` and `nums[j]` is different, we should subtract `x` from the total score.\\n\\nIf for each visiting index `i` we check for all index `j` >`i` and find a candidate the solution would become an $$O(n^2)$$ rather we can maintain a odd and even max parity sum\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe\\'ll maintain two variables, max_par_odd and max_par_even, to keep track of the maximum total scores obtained with the last visited position having odd or even parity, respectively.\\n\\n1. Initialize `max_par_odd` and `max_par_even` to 0.\\n2. Iterate over the array from left to right:\\n    *   Calculate the parity of the current number (`nums[i] % 2`).\\n    *   If the current number has odd parity:\\n        * Update max_par_odd by taking the maximum of (`max_par_odd`, `max_par_even - x + nums[i]`).\\n    * If the current number has even parity:\\n        * Update `max_par_even` by taking the maximum of (`max_par_even`, `max_par_odd - x + nums[i]`).\\n3. After the loop, the variable `max(max_par_odd, max_par_even)` will contain the maximum total score that can be obtained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe algorithm iterates through the array once, so the time complexity is $$O(n)$$, where n is the length of the array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is $$O(1)$$ as we are using a constant number of variables to store intermediate results, irrespective of the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        max_par1=max_par2=0\\n        dp=[0]*len(nums)\\n        ret_max=None\\n        \\n        for i in range(len(nums)-1,-1,-1):\\n            parity = nums[i]%2\\n            if parity:\\n                max_par1 = max(max_par1,max_par2-x) + nums[i]\\n                ret_max = max_par1\\n            else:\\n                max_par2 = max(max_par2,max_par1-x) + nums[i]\\n                ret_max = max_par2\\n        return ret_max\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        \\n        max_par1=max_par2=0\\n        dp=[0]*len(nums)\\n        ret_max=None\\n        \\n        for i in range(len(nums)-1,-1,-1):\\n            parity = nums[i]%2\\n            if parity:\\n                max_par1 = max(max_par1,max_par2-x) + nums[i]\\n                ret_max = max_par1\\n            else:\\n                max_par2 = max(max_par2,max_par1-x) + nums[i]\\n                ret_max = max_par2\\n        return ret_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813663,
                "title": "python-single-pass-o-n-time-o-1-space",
                "content": "```python\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        two_steps_prev_score = one_step_prev_score = 0\\n        contiguous_same_parity_sum = 0\\n        for i in reversed(range(len(nums))):\\n            contiguous_same_parity_sum += nums[i]\\n            if i == 0 or nums[i] % 2 != nums[i-1] % 2:\\n                current_score = contiguous_same_parity_sum + max(two_steps_prev_score, one_step_prev_score - x)\\n                two_steps_prev_score, one_step_prev_score = one_step_prev_score, current_score\\n                contiguous_same_parity_sum = 0\\n        return one_step_prev_score\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        two_steps_prev_score = one_step_prev_score = 0\\n        contiguous_same_parity_sum = 0\\n        for i in reversed(range(len(nums))):\\n            contiguous_same_parity_sum += nums[i]\\n            if i == 0 or nums[i] % 2 != nums[i-1] % 2:\\n                current_score = contiguous_same_parity_sum + max(two_steps_prev_score, one_step_prev_score - x)\\n                two_steps_prev_score, one_step_prev_score = one_step_prev_score, current_score\\n                contiguous_same_parity_sum = 0\\n        return one_step_prev_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813322,
                "title": "java-dp-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is an application of Kadane\\'s algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will create two arrays ```\\n(int[] o,int[] e)``` one for when  ```nums[i]``` is an odd value and another when ```nums[i]``` is an even number.\\n\\nif ```nums[i]``` is odd then it can either add with odd array with max value so far or with even array and subtracting x from the value. So we have to pick the max of two values and put it in ```o[i]```(odd array).\\n\\nSimilar approach for when ```nums[i]``` is even.\\n\\nSince it is given that the addition will start from ```nums[0]``` therefore we will return dp value according to the parity of ```nums[0]```.\\n\\nPlease refer to the code for better clarity.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long[] e=new long[nums.length];\\n        long[] o=new long[nums.length];\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]%2==0){\\n                if(i==nums.length-1){\\n                    o[i]=0;\\n                    e[i]=nums[i];\\n                }else{\\n                    o[i]=o[i+1];\\n                    e[i]=nums[i]+Math.max(e[i+1],o[i+1]-x);\\n                }\\n            }else{\\n                if(i==nums.length-1){\\n                    o[i]=nums[i];\\n                    e[i]=0;\\n                }else{\\n                    o[i]=nums[i]+Math.max(o[i+1],e[i+1]-x);\\n                    e[i]=e[i+1]; \\n                }\\n            }\\n        }\\n        if(nums[0]%2==0)return e[0];\\n        return o[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n(int[] o,int[] e)```\n```nums[i]```\n```nums[i]```\n```nums[i]```\n```o[i]```\n```nums[i]```\n```nums[0]```\n```nums[0]```\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long[] e=new long[nums.length];\\n        long[] o=new long[nums.length];\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]%2==0){\\n                if(i==nums.length-1){\\n                    o[i]=0;\\n                    e[i]=nums[i];\\n                }else{\\n                    o[i]=o[i+1];\\n                    e[i]=nums[i]+Math.max(e[i+1],o[i+1]-x);\\n                }\\n            }else{\\n                if(i==nums.length-1){\\n                    o[i]=nums[i];\\n                    e[i]=0;\\n                }else{\\n                    o[i]=nums[i]+Math.max(o[i+1],e[i+1]-x);\\n                    e[i]=e[i+1]; \\n                }\\n            }\\n        }\\n        if(nums[0]%2==0)return e[0];\\n        return o[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812744,
                "title": "c-0-1-knapsack-using-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have two option for each element, either we can go to that position or we can skip that. So, it is looking similar to 0-1 Knapsack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can simply create recursive function to calculate both the posibilities and will pick the maximum one. For memoizing we need to create a Table of size n * 2 (as parity is changing from 0 to 1).\\n\\nFor parity, Created a variable \"temp\" to store both the posibilites accordingly.\\n# Complexity\\n- Time complexity: O(n*2) => O(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n*2) => O(n);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector< vector<long long>> T;\\n    \\n    long long solve(vector<int>& nums, int &x, int i, int par){\\n        if(i >= nums.size()){\\n            return 0;\\n        }\\n\\n        int temp = 0;\\n        if(nums[i]%2 == par){\\n            temp = nums[i];\\n        }else{\\n            temp = nums[i] - x;\\n        }\\n        \\n        if(T[i][par] != -1){\\n            return T[i][par];\\n        }\\n\\n        long long choose = temp + 0ll + solve(nums, x, i+1, nums[i]%2);\\n        long long nope = solve(nums, x, i+1, par);\\n\\n        return T[i][par] = max(choose, nope);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        T = vector< vector<long long>> (n+1, vector<long long>(2, -1));\\n\\n        return nums[0] + 0ll + solve(nums,x,1,nums[0]%2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector< vector<long long>> T;\\n    \\n    long long solve(vector<int>& nums, int &x, int i, int par){\\n        if(i >= nums.size()){\\n            return 0;\\n        }\\n\\n        int temp = 0;\\n        if(nums[i]%2 == par){\\n            temp = nums[i];\\n        }else{\\n            temp = nums[i] - x;\\n        }\\n        \\n        if(T[i][par] != -1){\\n            return T[i][par];\\n        }\\n\\n        long long choose = temp + 0ll + solve(nums, x, i+1, nums[i]%2);\\n        long long nope = solve(nums, x, i+1, par);\\n\\n        return T[i][par] = max(choose, nope);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        T = vector< vector<long long>> (n+1, vector<long long>(2, -1));\\n\\n        return nums[0] + 0ll + solve(nums,x,1,nums[0]%2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812666,
                "title": "c-beginner-friendly-using-dp-pick-and-notpick",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long solve(int parity , int ind, vector<int>& nums, int x, vector<vector<long long>> &dp){\\n        if(ind >= nums.size()){\\n            return 0;\\n        }\\n                \\n        if(dp[ind][parity] != -1){\\n            return dp[ind][parity];\\n        }\\n        \\n        long long pick = nums[ind] + solve((nums[ind]&1), ind+1, nums,x,dp);\\n\\n        long long notpick = solve(parity, ind+1, nums,x,dp);\\n       \\n        if((nums[ind] & 1) != parity){\\n            pick -= x;\\n        }\\n        \\n        \\n        return dp[ind][parity] = max(pick, notpick);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        \\n        vector<vector<long long>> dp(n+1, vector<long long> (2,-1));\\n        \\n        return solve((nums[0]&1),1 ,nums,x,dp) + nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve(int parity , int ind, vector<int>& nums, int x, vector<vector<long long>> &dp){\\n        if(ind >= nums.size()){\\n            return 0;\\n        }\\n                \\n        if(dp[ind][parity] != -1){\\n            return dp[ind][parity];\\n        }\\n        \\n        long long pick = nums[ind] + solve((nums[ind]&1), ind+1, nums,x,dp);\\n\\n        long long notpick = solve(parity, ind+1, nums,x,dp);\\n       \\n        if((nums[ind] & 1) != parity){\\n            pick -= x;\\n        }\\n        \\n        \\n        return dp[ind][parity] = max(pick, notpick);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        \\n        vector<vector<long long>> dp(n+1, vector<long long> (2,-1));\\n        \\n        return solve((nums[0]&1),1 ,nums,x,dp) + nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812493,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake and not take concept of dynamic programming similar to find maximum sum of not adjacent element of the array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each element we have two choice either skip the element or pick the element if we pick the current and previous element is differ then we subtract x from pick and solve recursively calculate maximum sum\\nBut slight variation in memoization \\nWe cant take dp[n][n] because it gives memory limit exceeded\\nSo we take dp[n][2] here to store previously calculated answer\\nif our element is odd we store ans in dp[idx][1];\\nelse in dp[idx][0];\\n\\n# Complexity\\n- Time complexity:   O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n        private long fun(int idx,int nums[],int isOdd,int x,int n,long dp[][])\\n        {\\n            if(idx>=n) return 0;\\n            long max=0;\\n            if(dp[idx][isOdd]!=-1) return dp[idx][isOdd];\\n            long skip= fun(idx+1,nums,isOdd,x,n,dp);\\n            int isOddNew=(nums[idx]%2==1)?1:0;\\n            long pick=nums[idx]+fun(idx+1,nums,isOddNew,x,n,dp);\\n            if(isOdd!=isOddNew) pick-=x;\\n            return  dp[idx][isOdd]=Math.max(pick,skip);\\n        }\\n       \\n\\n    public long maxScore(int[] nums, int x) {\\n        int isOdd=nums[0]%2==1?1:0;\\n        int n=nums.length;\\n        long dp[][]=new long[n][2];\\n        for(long row[]:dp)  Arrays.fill(row,-1);\\n        return nums[0]+fun(1,nums,isOdd,x,nums.length,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n        private long fun(int idx,int nums[],int isOdd,int x,int n,long dp[][])\\n        {\\n            if(idx>=n) return 0;\\n            long max=0;\\n            if(dp[idx][isOdd]!=-1) return dp[idx][isOdd];\\n            long skip= fun(idx+1,nums,isOdd,x,n,dp);\\n            int isOddNew=(nums[idx]%2==1)?1:0;\\n            long pick=nums[idx]+fun(idx+1,nums,isOddNew,x,n,dp);\\n            if(isOdd!=isOddNew) pick-=x;\\n            return  dp[idx][isOdd]=Math.max(pick,skip);\\n        }\\n       \\n\\n    public long maxScore(int[] nums, int x) {\\n        int isOdd=nums[0]%2==1?1:0;\\n        int n=nums.length;\\n        long dp[][]=new long[n][2];\\n        for(long row[]:dp)  Arrays.fill(row,-1);\\n        return nums[0]+fun(1,nums,isOdd,x,nums.length,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811839,
                "title": "cpp-code-using-the-state-of-current-posistion",
                "content": "# Intuition\\nlets say you are at index i so for that you should maximum from the previous indexes and sum it.\\n\\n# Approach\\nsince we need to store maximum for a index i we can come from 0 to i-1 any index out of which it can be even or odd since as per question if it comes from even it will directly get added else it will add and substract x from it.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nnums array\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        ll mxodd = INT_MIN;\\n        ll mxeven = INT_MIN;\\n        //base condition\\n        if(nums[0]&1)\\n        {\\n            mxodd = nums[0];\\n        }\\n        else\\n        {\\n            mxeven = nums[0];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            //if its odd\\n            if(nums[i]&1)\\n            {\\n                ll odd = mxodd + nums[i];\\n                ll even = mxeven + nums[i] - x;\\n                mxodd = max({mxodd, odd, even});\\n            }\\n            else //if its even\\n            {\\n                ll even = mxeven + nums[i];\\n                ll odd = mxodd + nums[i] - x;\\n                mxeven = max({mxeven, even, odd});\\n            }\\n        }\\n        return max(mxeven, mxodd);//return max of both till now occured\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        ll mxodd = INT_MIN;\\n        ll mxeven = INT_MIN;\\n        //base condition\\n        if(nums[0]&1)\\n        {\\n            mxodd = nums[0];\\n        }\\n        else\\n        {\\n            mxeven = nums[0];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            //if its odd\\n            if(nums[i]&1)\\n            {\\n                ll odd = mxodd + nums[i];\\n                ll even = mxeven + nums[i] - x;\\n                mxodd = max({mxodd, odd, even});\\n            }\\n            else //if its even\\n            {\\n                ll even = mxeven + nums[i];\\n                ll odd = mxodd + nums[i] - x;\\n                mxeven = max({mxeven, even, odd});\\n            }\\n        }\\n        return max(mxeven, mxodd);//return max of both till now occured\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811731,
                "title": "python3-o-n-dp-solution",
                "content": "grid_odd[i] keeps the maximum score until index i if it ends up with an odd number, same for grid_even\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n      grid_odd, grid_even = [0]*len(nums), [0]*len(nums)\\n      if nums[0] % 2 == 1:\\n        grid_odd[0] = nums[0]\\n        grid_even[0] = -x\\n      else:\\n        grid_even[0] = nums[0]\\n        grid_odd[0] = -x\\n      for i in range(1, len(nums)):\\n        if nums[i] % 2 == 1:\\n          grid_even[i] = max(grid_odd[i-1] - x, grid_even[i-1])\\n          grid_odd[i] = max(grid_odd[i-1] + nums[i], grid_even[i-1] + nums[i] - x)\\n        else:\\n          grid_odd[i] = max(grid_even[i-1] - x, grid_odd[i-1])\\n          grid_even[i] = max(grid_even[i-1] + nums[i], grid_odd[i-1] + nums[i] - x)\\n      return max(grid_odd[-1], grid_even[-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n      grid_odd, grid_even = [0]*len(nums), [0]*len(nums)\\n      if nums[0] % 2 == 1:\\n        grid_odd[0] = nums[0]\\n        grid_even[0] = -x\\n      else:\\n        grid_even[0] = nums[0]\\n        grid_odd[0] = -x\\n      for i in range(1, len(nums)):\\n        if nums[i] % 2 == 1:\\n          grid_even[i] = max(grid_odd[i-1] - x, grid_even[i-1])\\n          grid_odd[i] = max(grid_odd[i-1] + nums[i], grid_even[i-1] + nums[i] - x)\\n        else:\\n          grid_odd[i] = max(grid_even[i-1] - x, grid_odd[i-1])\\n          grid_even[i] = max(grid_even[i-1] + nums[i], grid_odd[i-1] + nums[i] - x)\\n      return max(grid_odd[-1], grid_even[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811222,
                "title": "easy-understanding-solution-with-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee the consequtive numbers of the same parity as one number:\\n```\\n[2, 3, 6, 1, 9, 2] to [2, 3, 6, 10, 2]\\n```\\nBecause if we want to change the parity at `nums[4] = 9`, we can change at `nums[3] = 1` with more score.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the sum of consequtive numbers of the same parity. Only need to update the score when the parity changed, and update the score with this sum.\\n\\nThe score is the max of:\\n```\\nprevious score of same parity + sequence sum,\\nprevious score of different parity + sequence sum - penalty\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[] score = new long[2];         // score for even and odd\\n        int curr = nums[0] & 1;             // Parity identifier 0: even 1: odd\\n        long seqSum = 0;                    // Sum of consecutive series of the same parity\\n        long ans = 0;\\n        score[curr] = nums[0];\\n        score[1 - curr] = nums[0] - x;\\n        for (int i = 1; i < n + 1; i++) {\\n            if (i < n && (nums[i] & 1) == curr) {\\n                // if same parity, add to seqSum\\n                seqSum += nums[i];\\n            } else {\\n                // if parity changed, compare two scores\\n                score[curr] = Math.max(score[curr] + seqSum, score[1 - curr] + seqSum - x);\\n                ans = Math.max(ans, score[curr]);\\n                curr = 1 - curr;\\n                if (i < n) {\\n                    seqSum = nums[i];\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n[2, 3, 6, 1, 9, 2] to [2, 3, 6, 10, 2]\\n```\n```\\nprevious score of same parity + sequence sum,\\nprevious score of different parity + sequence sum - penalty\\n```\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[] score = new long[2];         // score for even and odd\\n        int curr = nums[0] & 1;             // Parity identifier 0: even 1: odd\\n        long seqSum = 0;                    // Sum of consecutive series of the same parity\\n        long ans = 0;\\n        score[curr] = nums[0];\\n        score[1 - curr] = nums[0] - x;\\n        for (int i = 1; i < n + 1; i++) {\\n            if (i < n && (nums[i] & 1) == curr) {\\n                // if same parity, add to seqSum\\n                seqSum += nums[i];\\n            } else {\\n                // if parity changed, compare two scores\\n                score[curr] = Math.max(score[curr] + seqSum, score[1 - curr] + seqSum - x);\\n                ans = Math.max(ans, score[curr]);\\n                curr = 1 - curr;\\n                if (i < n) {\\n                    seqSum = nums[i];\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810710,
                "title": "c-space-optimized-dp-solution-o-1-space-iterative-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long> curr(2);\\n        vector<long long> next(2);\\n\\n        for(int i = n - 1; i >= 1; i--) {\\n            for(int isPrevOdd = 0; isPrevOdd <= 1; isPrevOdd++) {\\n                long long op1 = next[isPrevOdd];\\n                long long op2 = nums[i] + next[nums[i] & 1];\\n\\n                if(isPrevOdd && (nums[i] & 1) == 0) op2 -= x;\\n                if(!isPrevOdd && (nums[i] & 1)) op2 -= x;\\n\\n                curr[isPrevOdd] = max(op1, op2);\\n            }\\n            next = curr;\\n        }\\n        return nums[0] + curr[nums[0] & 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long> curr(2);\\n        vector<long long> next(2);\\n\\n        for(int i = n - 1; i >= 1; i--) {\\n            for(int isPrevOdd = 0; isPrevOdd <= 1; isPrevOdd++) {\\n                long long op1 = next[isPrevOdd];\\n                long long op2 = nums[i] + next[nums[i] & 1];\\n\\n                if(isPrevOdd && (nums[i] & 1) == 0) op2 -= x;\\n                if(!isPrevOdd && (nums[i] & 1)) op2 -= x;\\n\\n                curr[isPrevOdd] = max(op1, op2);\\n            }\\n            next = curr;\\n        }\\n        return nums[0] + curr[nums[0] & 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810517,
                "title": "simple-easy-to-understand-dp-memoization-tabulation",
                "content": "# Intuition\\ntake/nottake recursive approch\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*2);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*2);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int n;\\n    static long dp[][];\\n    public long maxScore(int[] arr, int x) {\\n        n = arr.length;\\n        dp = new long[n+1][2];\\n        // for(long i[] : dp){\\n        //     Arrays.fill(i,-1);\\n        // }\\n        // return( nums[0] + solve(1,nums[0]%2,nums,x));\\n\\n        // base case already everything zero\\n        for(int i = n-1;i>=0;i--){\\n            for(int flag = 0;flag<= 1;flag++){\\n                int check = arr[i]%2;\\n                long take = 0;\\n                if(check == flag){\\n                    take = arr[i]+dp[i+1][check];\\n                }\\n                else {\\n                    take = (arr[i] - x) + dp[i+1][check];\\n                }\\n                long nt = dp[i+1][flag];\\n                \\n                dp[i][flag] =Math.max(nt,take);\\n            }\\n        }\\n\\n        return dp[0][arr[0]%2];\\n    }\\n    long solve(int i,int flag,int arr[],int x){\\n        if(i == n) return 0;\\n        \\n        if(dp[i][flag] != -1) return dp[i][flag];\\n        \\n        int check = arr[i]%2;\\n        long take = 0;\\n        if(check == flag){\\n            take = arr[i]+solve(i+1,check,arr,x);\\n        }\\n        else {\\n            take = (arr[i] - x) + solve(i+1,check,arr,x);\\n        }\\n        long nt = solve(i+1,flag,arr,x);\\n        \\n        return  dp[i][flag] =Math.max(nt,take);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static int n;\\n    static long dp[][];\\n    public long maxScore(int[] arr, int x) {\\n        n = arr.length;\\n        dp = new long[n+1][2];\\n        // for(long i[] : dp){\\n        //     Arrays.fill(i,-1);\\n        // }\\n        // return( nums[0] + solve(1,nums[0]%2,nums,x));\\n\\n        // base case already everything zero\\n        for(int i = n-1;i>=0;i--){\\n            for(int flag = 0;flag<= 1;flag++){\\n                int check = arr[i]%2;\\n                long take = 0;\\n                if(check == flag){\\n                    take = arr[i]+dp[i+1][check];\\n                }\\n                else {\\n                    take = (arr[i] - x) + dp[i+1][check];\\n                }\\n                long nt = dp[i+1][flag];\\n                \\n                dp[i][flag] =Math.max(nt,take);\\n            }\\n        }\\n\\n        return dp[0][arr[0]%2];\\n    }\\n    long solve(int i,int flag,int arr[],int x){\\n        if(i == n) return 0;\\n        \\n        if(dp[i][flag] != -1) return dp[i][flag];\\n        \\n        int check = arr[i]%2;\\n        long take = 0;\\n        if(check == flag){\\n            take = arr[i]+solve(i+1,check,arr,x);\\n        }\\n        else {\\n            take = (arr[i] - x) + solve(i+1,check,arr,x);\\n        }\\n        long nt = solve(i+1,flag,arr,x);\\n        \\n        return  dp[i][flag] =Math.max(nt,take);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810452,
                "title": "c-solution-easy-to-understand-simple-and-clear-solution-iit-roorkee",
                "content": "# Approach\\nFirst, since we already know that we don\\'t need to spend any x to get an element with the same parity, simply put consecutive elements with the same parity on another vector before using dynamic programming.\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n\\n- Space complexity:O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001][2];\\n    long long calc(vector<long long>& v,int index,int flag,int pen)\\n    {\\n         if(index>=v.size())\\n         {\\n             return 0;\\n         }\\n         if(dp[index][flag]!=-1)\\n         {\\n             return dp[index][flag];\\n         }\\n         long long ans1=0;\\n         long long ans2=0;\\n         long long ans3=0;\\n         if(index%2==flag)\\n         {\\n             ans1=v[index]+calc(v,index+1,flag,pen);\\n         }\\n         if(index%2!=flag)\\n         {\\n             ans2=(v[index]-pen)+calc(v,index+1,(flag^1),pen);\\n         }\\n         ans3=calc(v,index+1,flag,pen);\\n         return dp[index][flag]=max({ans1,ans2,ans3});\\n    }\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n       long long sum=0;\\n       vector<long long>v;    \\n       for(int i=0;i<nums.size()-1;i++)\\n       {\\n                if(nums[i]%2!=nums[i+1]%2) \\n                {\\n                    sum+=nums[i];\\n                    v.push_back(sum);\\n                    sum=0;\\n                }\\n                else\\n                {\\n                    sum+=nums[i];\\n                }\\n               \\n       }\\n       if(nums[nums.size()-1]%2==0)\\n       {\\n           sum+=nums[nums.size()-1];\\n           v.push_back(sum);         \\n       }\\n       else\\n       {\\n            sum+=nums[nums.size()-1];\\n            v.push_back(sum);\\n       } \\n       memset(dp,-1,sizeof(dp));\\n       return calc(v,1,0,x)+v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2];\\n    long long calc(vector<long long>& v,int index,int flag,int pen)\\n    {\\n         if(index>=v.size())\\n         {\\n             return 0;\\n         }\\n         if(dp[index][flag]!=-1)\\n         {\\n             return dp[index][flag];\\n         }\\n         long long ans1=0;\\n         long long ans2=0;\\n         long long ans3=0;\\n         if(index%2==flag)\\n         {\\n             ans1=v[index]+calc(v,index+1,flag,pen);\\n         }\\n         if(index%2!=flag)\\n         {\\n             ans2=(v[index]-pen)+calc(v,index+1,(flag^1),pen);\\n         }\\n         ans3=calc(v,index+1,flag,pen);\\n         return dp[index][flag]=max({ans1,ans2,ans3});\\n    }\\n    long long maxScore(vector<int>& nums, int x) \\n    {\\n       long long sum=0;\\n       vector<long long>v;    \\n       for(int i=0;i<nums.size()-1;i++)\\n       {\\n                if(nums[i]%2!=nums[i+1]%2) \\n                {\\n                    sum+=nums[i];\\n                    v.push_back(sum);\\n                    sum=0;\\n                }\\n                else\\n                {\\n                    sum+=nums[i];\\n                }\\n               \\n       }\\n       if(nums[nums.size()-1]%2==0)\\n       {\\n           sum+=nums[nums.size()-1];\\n           v.push_back(sum);         \\n       }\\n       else\\n       {\\n            sum+=nums[nums.size()-1];\\n            v.push_back(sum);\\n       } \\n       memset(dp,-1,sizeof(dp));\\n       return calc(v,1,0,x)+v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810117,
                "title": "c-easy-dp-solution-memoization-tabulation-space-optimization",
                "content": "\\n# Approach\\nSame as 0/1 Knapsack Problem .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// long long solve(vector<int> &nums, int index, bool f, int &x, vector<vector<long long>>& dp){\\n//     if(index>=nums.size())\\n//     return 0;\\n\\n//     if(dp[index][f] != -1)\\n//     return dp[index][f];\\n\\n//     long long take=0, notTake = 0;\\n\\n//     if(f == nums[index]%2)\\n//     take = nums[index] + solve(nums, index+1, f, x, dp);\\n//     else\\n//     take = nums[index]-x+solve(nums, index+1, !f, x, dp);  // !f = nums[index]%2;\\n\\n//     notTake = solve(nums, index+1, f, x, dp);\\n\\n//     return dp[index][f] = max(take, notTake);\\n// }\\n\\n    long long maxScore(vector<int>& nums, int x) {\\n\\n        //  Recursion        SC -> O(n + n)\\n\\n        // int index = 0;\\n        // bool f = nums[0]%2;\\n        // int n = nums.size();\\n        // vector<vector<long long>> dp(n+1, vector<long long> (2, -1));\\n        // return nums[0] + solve(nums, 1, f, x, dp);\\n\\n          \\n          //  Tabulation    SC -> O(n)\\n            \\n\\n        // int n = nums.size();\\n        // vector<vector<long long>> dp(n+1, vector<long long> (2, 0));  // dp[n][0] = dp[n][1] = 0;  base case\\n\\n        \\n        // for(int index=n-1 ;index>=0 ;index--){\\n        //     for(int flag=0 ;flag<2 ;flag++){\\n                \\n        //         long long take = 0, notTake = 0;\\n\\n        //         if(nums[index]%2 == flag)\\n        //         take = nums[index] + dp[index+1][flag];\\n        //         else\\n        //         take = nums[index] - x + dp[index+1][nums[index]%2];\\n\\n        //         notTake = dp[index+1][flag];\\n\\n        //         dp[index][flag] = max(take, notTake);\\n        //     }\\n        // }\\n\\n        // return dp[0][nums[0]%2];\\n\\n\\n        //    Space Optimization  ->   SC -> O(2)\\n\\n        int n = nums.size();\\n        vector<long long> next(2, 0), curr(2, 0);\\n        \\n\\n        for(int index=n-1 ;index>=0 ;index--){\\n            for(int flag=0 ;flag<2 ;flag++){\\n                \\n                long long take = 0, notTake = 0;\\n\\n                if(nums[index]%2 == flag)\\n                take = nums[index] + next[flag];\\n                else\\n                take = nums[index] - x + next[nums[index]%2];\\n\\n                notTake = next[flag];\\n\\n                curr[flag] = max(take, notTake);\\n            }\\n            next = curr;\\n        }\\n\\n        return curr[nums[0]%2];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// long long solve(vector<int> &nums, int index, bool f, int &x, vector<vector<long long>>& dp){\\n//     if(index>=nums.size())\\n//     return 0;\\n\\n//     if(dp[index][f] != -1)\\n//     return dp[index][f];\\n\\n//     long long take=0, notTake = 0;\\n\\n//     if(f == nums[index]%2)\\n//     take = nums[index] + solve(nums, index+1, f, x, dp);\\n//     else\\n//     take = nums[index]-x+solve(nums, index+1, !f, x, dp);  // !f = nums[index]%2;\\n\\n//     notTake = solve(nums, index+1, f, x, dp);\\n\\n//     return dp[index][f] = max(take, notTake);\\n// }\\n\\n    long long maxScore(vector<int>& nums, int x) {\\n\\n        //  Recursion        SC -> O(n + n)\\n\\n        // int index = 0;\\n        // bool f = nums[0]%2;\\n        // int n = nums.size();\\n        // vector<vector<long long>> dp(n+1, vector<long long> (2, -1));\\n        // return nums[0] + solve(nums, 1, f, x, dp);\\n\\n          \\n          //  Tabulation    SC -> O(n)\\n            \\n\\n        // int n = nums.size();\\n        // vector<vector<long long>> dp(n+1, vector<long long> (2, 0));  // dp[n][0] = dp[n][1] = 0;  base case\\n\\n        \\n        // for(int index=n-1 ;index>=0 ;index--){\\n        //     for(int flag=0 ;flag<2 ;flag++){\\n                \\n        //         long long take = 0, notTake = 0;\\n\\n        //         if(nums[index]%2 == flag)\\n        //         take = nums[index] + dp[index+1][flag];\\n        //         else\\n        //         take = nums[index] - x + dp[index+1][nums[index]%2];\\n\\n        //         notTake = dp[index+1][flag];\\n\\n        //         dp[index][flag] = max(take, notTake);\\n        //     }\\n        // }\\n\\n        // return dp[0][nums[0]%2];\\n\\n\\n        //    Space Optimization  ->   SC -> O(2)\\n\\n        int n = nums.size();\\n        vector<long long> next(2, 0), curr(2, 0);\\n        \\n\\n        for(int index=n-1 ;index>=0 ;index--){\\n            for(int flag=0 ;flag<2 ;flag++){\\n                \\n                long long take = 0, notTake = 0;\\n\\n                if(nums[index]%2 == flag)\\n                take = nums[index] + next[flag];\\n                else\\n                take = nums[index] - x + next[nums[index]%2];\\n\\n                notTake = next[flag];\\n\\n                curr[flag] = max(take, notTake);\\n            }\\n            next = curr;\\n        }\\n\\n        return curr[nums[0]%2];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810001,
                "title": "o-n-dp-scanning-backwards",
                "content": "Compared with scanning left to right, I prefer scan right to left, that is more straightforward.\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long ans[2]={0,0};\\n        for(int i=n-1; i>=0; --i) {\\n            if(nums[i]&1) {\\n                ans[1]=max(ans[1], ans[0]-x)+nums[i];\\n            } else {\\n                ans[0]=max(ans[0], ans[1]-x)+nums[i];\\n            }\\n        }\\n        return ans[nums[0]&1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=nums.size();\\n        long ans[2]={0,0};\\n        for(int i=n-1; i>=0; --i) {\\n            if(nums[i]&1) {\\n                ans[1]=max(ans[1], ans[0]-x)+nums[i];\\n            } else {\\n                ans[0]=max(ans[0], ans[1]-x)+nums[i];\\n            }\\n        }\\n        return ans[nums[0]&1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809675,
                "title": "c-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>dp;\\n    long long solve(int j,int i,int n,vector<int>& nums,int x)\\n    {\\n        if(j==n)return 0;\\n        if(dp[j][i]!=-1)return dp[j][i];\\n        long long ans1=0ll,ans2=0ll;\\n        if(!((nums[j]&1)^i))\\n            ans1 = nums[j]+solve(j+1,nums[j]%2,n,nums,x);\\n        else ans1 = nums[j]-x+solve(j+1,nums[j]%2,n,nums,x);\\n        ans2 = solve(j+1,i,n,nums,x);\\n        return dp[j][i]=max(ans1,ans2);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        dp = vector<vector<long long>>(n+1,vector<long long>(2,-1));\\n        return nums[0]+solve(1,nums[0]%2,n,nums,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>dp;\\n    long long solve(int j,int i,int n,vector<int>& nums,int x)\\n    {\\n        if(j==n)return 0;\\n        if(dp[j][i]!=-1)return dp[j][i];\\n        long long ans1=0ll,ans2=0ll;\\n        if(!((nums[j]&1)^i))\\n            ans1 = nums[j]+solve(j+1,nums[j]%2,n,nums,x);\\n        else ans1 = nums[j]-x+solve(j+1,nums[j]%2,n,nums,x);\\n        ans2 = solve(j+1,i,n,nums,x);\\n        return dp[j][i]=max(ans1,ans2);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        dp = vector<vector<long long>>(n+1,vector<long long>(2,-1));\\n        return nums[0]+solve(1,nums[0]%2,n,nums,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809418,
                "title": "visit-array-positions-to-maximize-scoredy",
                "content": "# Intuition\\nThe problem can be approached using dynamic programming with memoization. We need to find the maximum total score by visiting array positions with certain rules. At each position, we can decide to either move to the next position with the same parity or switch the parity and move to the next position. To maximize the score, we should keep track of the maximum score at each position and the parity of the previous position.\\n\\n# Approach\\nThe given code implements the dynamic programming approach using recursion with memoization. The helper function recursively calculates the maximum score starting from each position, considering the rules about moving to the next position and switching parities. The memoization is done using the dp array to store already computed results to avoid redundant calculations.\\n\\nThe maxScore function initializes the memoization array and then calls the helper function with the initial position set to 0 and the parity set according to the first element of the nums array.\\n\\n# Complexity\\nTime complexity: The function calculates the maximum score for each position only once, and each calculation depends on the results of the subsequent positions. Therefore, the time complexity is O(n), where n is the number of elements in the nums array.\\n\\n# Space complexity:\\n The memoization array dp has a size of O(n) to store the results for each position and parity. Therefore, the space complexity is O(n). Additionally, the recursive call stack might require additional space, but it would be at most O(n) in this case.\\n# Code\\n```\\nclass Solution {\\n    long long dp[100000][2];\\n    long long helper(vector<int>& nums, int x, int i, bool prev){\\n        if(i == nums.size())return 0;\\n        if(dp[i][prev] != -1)return dp[i][prev];\\n        if((nums[i] & 1) == prev){\\n            return dp[i][prev] = nums[i] + helper(nums, x, i + 1, prev);\\n        }\\n        return dp[i][prev] = max(1LL * nums[i] + helper(nums, x, i + 1, !prev) - x, helper(nums, x, i + 1, prev));\\n    }\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(dp, -1, sizeof(dp));\\n        return nums[0] + helper(nums, x, 1, nums[0] & 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long long dp[100000][2];\\n    long long helper(vector<int>& nums, int x, int i, bool prev){\\n        if(i == nums.size())return 0;\\n        if(dp[i][prev] != -1)return dp[i][prev];\\n        if((nums[i] & 1) == prev){\\n            return dp[i][prev] = nums[i] + helper(nums, x, i + 1, prev);\\n        }\\n        return dp[i][prev] = max(1LL * nums[i] + helper(nums, x, i + 1, !prev) - x, helper(nums, x, i + 1, prev));\\n    }\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        memset(dp, -1, sizeof(dp));\\n        return nums[0] + helper(nums, x, 1, nums[0] & 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809224,
                "title": "java-memoization-dp",
                "content": "# Intuition\\nJust a knapsack dp problem.\\n\\n# Complexity\\n- Time complexity: O(2N)\\n\\n- Space complexity: O(2N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][2];\\n        for(long[] i: dp) Arrays.fill(i, -1);\\n\\n        return memoization(nums, x, 0, nums[0]%2, dp);\\n    }\\n\\n    public long memoization(int[] nums, int x, int index, int prev, long[][] dp) {\\n\\n        if (index == nums.length) return 0;\\n\\n        if (dp[index][prev] != -1) return dp[index][prev];\\n\\n        long exclude = memoization(nums, x, index+1, prev, dp);\\n\\n        long include = 0;\\n\\n        include -= (prev == nums[index]%2) ? 0 : x;\\n\\n        include += nums[index] + memoization(nums, x, index+1, nums[index]%2, dp);\\n\\n        return dp[index][prev] = Math.max(include, exclude);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][2];\\n        for(long[] i: dp) Arrays.fill(i, -1);\\n\\n        return memoization(nums, x, 0, nums[0]%2, dp);\\n    }\\n\\n    public long memoization(int[] nums, int x, int index, int prev, long[][] dp) {\\n\\n        if (index == nums.length) return 0;\\n\\n        if (dp[index][prev] != -1) return dp[index][prev];\\n\\n        long exclude = memoization(nums, x, index+1, prev, dp);\\n\\n        long include = 0;\\n\\n        include -= (prev == nums[index]%2) ? 0 : x;\\n\\n        include += nums[index] + memoization(nums, x, index+1, nums[index]%2, dp);\\n\\n        return dp[index][prev] = Math.max(include, exclude);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808746,
                "title": "python-dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        even, odd = 0, 0\\n        if nums[0]%2:\\n            odd = nums[0]\\n            even = nums[0] - x\\n        else:\\n            odd = nums[0] - x\\n            even = nums[0]\\n        res = max(even, odd)\\n        for i in range(1, len(nums)):\\n            if nums[i]%2:\\n                odd = max(odd+nums[i], even+nums[i]-x)\\n            else:\\n                even = max(even+nums[i],odd+nums[i]-x)\\n            res = max(res, odd, even)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        even, odd = 0, 0\\n        if nums[0]%2:\\n            odd = nums[0]\\n            even = nums[0] - x\\n        else:\\n            odd = nums[0] - x\\n            even = nums[0]\\n        res = max(even, odd)\\n        for i in range(1, len(nums)):\\n            if nums[i]%2:\\n                odd = max(odd+nums[i], even+nums[i]-x)\\n            else:\\n                even = max(even+nums[i],odd+nums[i]-x)\\n            res = max(res, odd, even)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808438,
                "title": "easy-dp-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int even = nums[0] - (nums[0] % 2 ? x : 0);\\n        int odd = nums[0] - (nums[0] % 2 ? 0 : x);\\n\\n        vector<long long> dp(nums.size()+1,0);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();++i){\\n            if(nums[i]%2==0){\\n                   dp[i]=max(nums[i]+even,nums[i]+odd-x);\\n                \\n                even=dp[i];\\n            }\\n            else{\\n                        \\n                       dp[i]=max(nums[i]+odd,nums[i]+even-x);\\n                \\n                odd=dp[i];\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int even = nums[0] - (nums[0] % 2 ? x : 0);\\n        int odd = nums[0] - (nums[0] % 2 ? 0 : x);\\n\\n        vector<long long> dp(nums.size()+1,0);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.size();++i){\\n            if(nums[i]%2==0){\\n                   dp[i]=max(nums[i]+even,nums[i]+odd-x);\\n                \\n                even=dp[i];\\n            }\\n            else{\\n                        \\n                       dp[i]=max(nums[i]+odd,nums[i]+even-x);\\n                \\n                odd=dp[i];\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808437,
                "title": "c-keep-track-of-prev-even-sum-and-prev-odd-sum",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Keep track of prev even sum it indicate a last even digit maximum sum and same for keep track of prev odd\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n       long long prev_e=nums[0], prev_o=nums[0];\\n       if(nums[0]%2==0){\\n           prev_o-=x;\\n       }\\n       else{\\n           prev_e-=x;\\n       }\\n       long long ans=0;\\n       ans=max(prev_o,prev_e);\\n       for(int i=1;i<nums.size();i++){\\n           if(nums[i]%2==0){\\n               prev_e=max(prev_e+nums[i],prev_o+nums[i]-x);\\n               ans=max(ans,prev_e);\\n           }\\n           else{\\n                prev_o=max(prev_o+nums[i],prev_e+nums[i]-x);\\n                ans=max(ans,prev_o);\\n           }\\n       }\\n\\n       return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n       long long prev_e=nums[0], prev_o=nums[0];\\n       if(nums[0]%2==0){\\n           prev_o-=x;\\n       }\\n       else{\\n           prev_e-=x;\\n       }\\n       long long ans=0;\\n       ans=max(prev_o,prev_e);\\n       for(int i=1;i<nums.size();i++){\\n           if(nums[i]%2==0){\\n               prev_e=max(prev_e+nums[i],prev_o+nums[i]-x);\\n               ans=max(ans,prev_e);\\n           }\\n           else{\\n                prev_o=max(prev_o+nums[i],prev_e+nums[i]-x);\\n                ans=max(ans,prev_o);\\n           }\\n       }\\n\\n       return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808411,
                "title": "c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        \\n        using ll = long long;\\n        ll res = nums[0];\\n        ll use_odd = INT_MIN, use_even = INT_MIN;\\n        nums[0] % 2 ?  use_odd = nums[0] : use_even = nums[0];\\n\\n        for(int i = 1; i < nums.size(); i++){\\n                nums[i] % 2 ? use_odd = max(use_odd + nums[i], use_even + nums[i] - x) : use_even = max(use_odd + nums[i] - x, use_even + nums[i]);\\n                res = max(res, max(use_odd, use_even));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        \\n        using ll = long long;\\n        ll res = nums[0];\\n        ll use_odd = INT_MIN, use_even = INT_MIN;\\n        nums[0] % 2 ?  use_odd = nums[0] : use_even = nums[0];\\n\\n        for(int i = 1; i < nums.size(); i++){\\n                nums[i] % 2 ? use_odd = max(use_odd + nums[i], use_even + nums[i] - x) : use_even = max(use_odd + nums[i] - x, use_even + nums[i]);\\n                res = max(res, max(use_odd, use_even));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808298,
                "title": "simple-python-recursive-solution",
                "content": "# Intuition\\n\\nWe can either take the current array index into consideration or not to take\\n\\n# Approach\\n\\nRecursively calculate the maximum score from take(i) and not take(i) solutions. Each solution is affeacted by previous parity. \\n\\n# Complexity\\n- Time complexity:\\n\\nO(n)\\n\\n- Space complexity:\\n\\nO(n) (max implicit stack size)\\n\\n# Code\\n```\\nclass Solution:    \\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        # p = 1 -> odd, p = 0 -> even\\n        @cache\\n        def f(i,p):\\n            if i == len(nums):\\n                return 0            \\n            no_take_res = f(i + 1,p)\\n            curr_p = nums[i] & 1\\n            if curr_p == p:\\n                take_res = nums[i] + f(i + 1, curr_p)\\n            else:\\n                take_res = nums[i] - x + f(i + 1, curr_p)\\n            return max(take_res, no_take_res)\\n            \\n            \\n        return nums[0] + f(1, nums[0] & 1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:    \\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        # p = 1 -> odd, p = 0 -> even\\n        @cache\\n        def f(i,p):\\n            if i == len(nums):\\n                return 0            \\n            no_take_res = f(i + 1,p)\\n            curr_p = nums[i] & 1\\n            if curr_p == p:\\n                take_res = nums[i] + f(i + 1, curr_p)\\n            else:\\n                take_res = nums[i] - x + f(i + 1, curr_p)\\n            return max(take_res, no_take_res)\\n            \\n            \\n        return nums[0] + f(1, nums[0] & 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808077,
                "title": "easy-solution-recursion-with-memo-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[100005][2];\\n    long long fun(int ind, int x,vector<int>&v,int pre) {\\n        if(ind==v.size()) return 0;\\n        if(dp[ind][pre]!=-1) return dp[ind][pre];\\n        long long take=-1e12,ntake=-1e12;\\n\\n        if(v[ind]%2==0) {\\n            if(pre) take=v[ind]+fun(ind+1,x,v,(v[ind]%2==0));\\n            else take=v[ind]+fun(ind+1,x,v,(v[ind]%2==0))-x;\\n        }\\n        else {\\n            if(pre) take=v[ind]+fun(ind+1,x,v,(v[ind]%2==0))-x;\\n            else take=v[ind]+fun(ind+1,x,v,(v[ind]%2==0));\\n        }\\n        ntake=fun(ind+1,x,v,pre);\\n        return dp[ind][pre] = max(take,ntake);\\n    }\\n    long long maxScore(vector<int>& v, int x) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,x,v,(v[0]%2==0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100005][2];\\n    long long fun(int ind, int x,vector<int>&v,int pre) {\\n        if(ind==v.size()) return 0;\\n        if(dp[ind][pre]!=-1) return dp[ind][pre];\\n        long long take=-1e12,ntake=-1e12;\\n\\n        if(v[ind]%2==0) {\\n            if(pre) take=v[ind]+fun(ind+1,x,v,(v[ind]%2==0));\\n            else take=v[ind]+fun(ind+1,x,v,(v[ind]%2==0))-x;\\n        }\\n        else {\\n            if(pre) take=v[ind]+fun(ind+1,x,v,(v[ind]%2==0))-x;\\n            else take=v[ind]+fun(ind+1,x,v,(v[ind]%2==0));\\n        }\\n        ntake=fun(ind+1,x,v,pre);\\n        return dp[ind][pre] = max(take,ntake);\\n    }\\n    long long maxScore(vector<int>& v, int x) {\\n        memset(dp,-1,sizeof(dp));\\n        return fun(0,x,v,(v[0]%2==0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808060,
                "title": "java-explained-dynamic-programming-recursion-memoization-modified-0-1-knapsack",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to start from the first index (thats mentioned). But need not to ge till last. We just need to maximize the score.\\n\\nso, for the first index, I will always choose that element. Now the next element i will choose -\\n- If that element have the same parity, then perfectly I can incluse that in my score.\\n- If the parity of the element don\\'t matches, then I can either change the parity by paying the charges (x) and search for the next maximum score the new parity. Or I can just skip this element and search for the next maximum score wfrom next elements with the same parity.\\n\\n\\nSo this intuition seems like a 0/1 knapsack where we can have the option to choose the element or just skip the element. But this can not be always. It can be only when the parity doesn\\'t matches.\\n\\n# Complexity\\n- Time complexity: $$O(2n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] nums;\\n    int x;\\n    Long[][] dp;\\n    private long solve(int i, int par) {\\n        \\n        //The base case when no more element left for calculation\\n        if(i == nums.length) {\\n            return 0;\\n        }\\n\\n        //using memoization state to get precomputed results\\n        if(dp[i][par] != null) {\\n            return dp[i][par];\\n        }\\n        \\n        //calculating the current parity\\n        int currPar = nums[i]%2;\\n        long score = 0;\\n        \\n        //Checking if my current parity matches with the last \\n        //choosen element parity then I can include that element \\n        //in the score other case I need to seach for maximum \\n        //score using 2 different options -\\n        // 1 - Paying the charges (x)\\n        // 2 - Skipping the element\\n        if(currPar == par) {\\n            score = nums[i]+solve(i+1, par);\\n        } else {\\n            score = Math.max(solve(i+1, par), ((nums[i]-x)+(solve(i+1, currPar))));\\n        }\\n        \\n        //Storing the memoization state\\n        return dp[i][par] = score;\\n    }\\n\\n    public long maxScore(int[] nums, int x) {\\n        this.nums = nums;\\n        this.x = x;\\n        this.dp = new Long[nums.length][2];\\n        return nums[0]+solve(1, nums[0]%2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    int x;\\n    Long[][] dp;\\n    private long solve(int i, int par) {\\n        \\n        //The base case when no more element left for calculation\\n        if(i == nums.length) {\\n            return 0;\\n        }\\n\\n        //using memoization state to get precomputed results\\n        if(dp[i][par] != null) {\\n            return dp[i][par];\\n        }\\n        \\n        //calculating the current parity\\n        int currPar = nums[i]%2;\\n        long score = 0;\\n        \\n        //Checking if my current parity matches with the last \\n        //choosen element parity then I can include that element \\n        //in the score other case I need to seach for maximum \\n        //score using 2 different options -\\n        // 1 - Paying the charges (x)\\n        // 2 - Skipping the element\\n        if(currPar == par) {\\n            score = nums[i]+solve(i+1, par);\\n        } else {\\n            score = Math.max(solve(i+1, par), ((nums[i]-x)+(solve(i+1, currPar))));\\n        }\\n        \\n        //Storing the memoization state\\n        return dp[i][par] = score;\\n    }\\n\\n    public long maxScore(int[] nums, int x) {\\n        this.nums = nums;\\n        this.x = x;\\n        this.dp = new Long[nums.length][2];\\n        return nums[0]+solve(1, nums[0]%2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807893,
                "title": "python-1dp-beats-100",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        even = nums[0] if nums[0] % 2 == 0 else -9999999999\\n        odd = nums[0]  if nums[0] % 2 == 1 else -9999999999\\n        \\n        for i in range(1, n):\\n          curr = nums[i]\\n          if nums[i] % 2 == 0: # even:\\n            even = max(even + curr, odd + curr - x)\\n          else:\\n            odd = max(odd + curr, even + curr - x)\\n          \\n        return max(even, odd)\\n          \\n# [2,3,6,1,9,2]\\n# 5\\n# [2,4,6,8]\\n# 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        even = nums[0] if nums[0] % 2 == 0 else -9999999999\\n        odd = nums[0]  if nums[0] % 2 == 1 else -9999999999\\n        \\n        for i in range(1, n):\\n          curr = nums[i]\\n          if nums[i] % 2 == 0: # even:\\n            even = max(even + curr, odd + curr - x)\\n          else:\\n            odd = max(odd + curr, even + curr - x)\\n          \\n        return max(even, odd)\\n          \\n# [2,3,6,1,9,2]\\n# 5\\n# [2,4,6,8]\\n# 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807154,
                "title": "easy-to-understand-10-line-c-tc-o-n-sc-o-1",
                "content": "# Intuition\\n\\nGoing backwards, keep two counts, one for odd, another for even numbers.\\n\\nodd means, the max value if we choose to use odd parity. similar thing for even.\\n\\nAt the end, only need to check parity of nums[0] to get the correct result.\\n\\n\\n# Approach\\nAt any index, check the parity of that number, assign odd/even properly.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long odd = 0, even = 0;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if (nums[i]%2) odd = max(odd + nums[i], nums[i] + even - x);\\n            else even = max(even + nums[i], nums[i] + odd - x);\\n        }\\n        return ((nums[0]%2) ? odd : even);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long odd = 0, even = 0;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if (nums[i]%2) odd = max(odd + nums[i], nums[i] + even - x);\\n            else even = max(even + nums[i], nums[i] + odd - x);\\n        }\\n        return ((nums[0]%2) ? odd : even);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807058,
                "title": "very-simplw-dp-memo",
                "content": "we will use 2d dp to store values at a particular index and parity(even/odd) as score depends on these 2 only(dp[i][j[--> i for index and j for parity) . Then we will recursively call the function. Here are 3 cases\\n> If we don\\'t take we just move ahead and parity remains same as well as nothing is added\\n>if parity of current no. and prev no. is same just add that no. and parity remains same\\n>if parity of current no. is different we will add that no. as well as subtract \\'x\\' from it as stated in question and change the parity to parity of current no. for future calculation\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long f(int i,int state,vector<int>&nums,vector<vector<long long>>&dp,int x){\\n        \\n        if(i==nums.size()) return 0;\\n        if(dp[i][state]!=-1) return dp[i][state];\\n       long long  ans1=f(i+1,state,nums,dp,x);\\n       long long ans2=0;\\n        if(nums[i]%2==state)\\n         ans2=nums[i]+f(i+1,state,nums,dp,x);\\n        else\\n         ans2=nums[i]-x+f(i+1,(state+1)%2,nums,dp,x);\\n            \\n        return dp[i][state]=max(ans1,ans2);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(3,-1));\\n        return nums[0]+f(1,nums[0]%2,nums,dp,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long f(int i,int state,vector<int>&nums,vector<vector<long long>>&dp,int x){\\n        \\n        if(i==nums.size()) return 0;\\n        if(dp[i][state]!=-1) return dp[i][state];\\n       long long  ans1=f(i+1,state,nums,dp,x);\\n       long long ans2=0;\\n        if(nums[i]%2==state)\\n         ans2=nums[i]+f(i+1,state,nums,dp,x);\\n        else\\n         ans2=nums[i]-x+f(i+1,(state+1)%2,nums,dp,x);\\n            \\n        return dp[i][state]=max(ans1,ans2);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(3,-1));\\n        return nums[0]+f(1,nums[0]%2,nums,dp,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806632,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long[][] dp=new long[nums.length+1][2];\\n        for(long d[]:dp) Arrays.fill(d,-1);\\n        if(nums[0]%2==0) return helper(0,0,nums,x,dp);\\n        else return helper(0,1,nums,x,dp);\\n    }\\n\\n    public long helper(int i,int flag,int[] nums,int x,long[][] dp){  \\n        if(i>=nums.length)return 0;\\n        if(dp[i][flag]!=-1)return dp[i][flag];\\n        long max=0;\\n        if(flag==0){\\n            if(nums[i]%2==0){\\n            max+=nums[i]+helper(i+1,0,nums,x,dp);\\n        }else{\\n            max+=Math.max(nums[i]-x+helper(i+1,1,nums,x,dp),helper(i+1,0,nums,x,dp));\\n        }\\n        }else{\\n             if(nums[i]%2!=0){\\n            max+=nums[i]+helper(i+1,1,nums,x,dp);\\n        }else{\\n            max+=Math.max(nums[i]-x+helper(i+1,0,nums,x,dp),helper(i+1,1,nums,x,dp));\\n        }\\n        }\\n\\n        return dp[i][flag]=max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long[][] dp=new long[nums.length+1][2];\\n        for(long d[]:dp) Arrays.fill(d,-1);\\n        if(nums[0]%2==0) return helper(0,0,nums,x,dp);\\n        else return helper(0,1,nums,x,dp);\\n    }\\n\\n    public long helper(int i,int flag,int[] nums,int x,long[][] dp){  \\n        if(i>=nums.length)return 0;\\n        if(dp[i][flag]!=-1)return dp[i][flag];\\n        long max=0;\\n        if(flag==0){\\n            if(nums[i]%2==0){\\n            max+=nums[i]+helper(i+1,0,nums,x,dp);\\n        }else{\\n            max+=Math.max(nums[i]-x+helper(i+1,1,nums,x,dp),helper(i+1,0,nums,x,dp));\\n        }\\n        }else{\\n             if(nums[i]%2!=0){\\n            max+=nums[i]+helper(i+1,1,nums,x,dp);\\n        }else{\\n            max+=Math.max(nums[i]-x+helper(i+1,0,nums,x,dp),helper(i+1,1,nums,x,dp));\\n        }\\n        }\\n\\n        return dp[i][flag]=max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806466,
                "title": "c-reverse-dp",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) or use original nums\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxScore(int[] nums, int x) {\\n        List<long> T = new ();\\n        int n = nums.Length;\\n        long t = 0;\\n        int Odd = nums[0]%2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int odd = nums[i]%2;\\n            if(odd==Odd)\\n            {\\n                t += nums[i];\\n            }\\n            else\\n            {\\n                T.Add(t);\\n                t = (long)nums[i];\\n                Odd = odd;\\n            }\\n        }\\n        T.Add(t); \\n       \\n        n = T.Count;\\n        if(n>1)\\n           T[n-2] = Math.Max(T[n-2],T[n-1] + T[n-2] - x);\\n        \\n        for(int i=n-3;i>=0;i--)\\n        {\\n            T[i] =  Math.Max(T[i] + T[i+2], T[i] + T[i+1] - x);\\n        }  \\n        \\n        return T[0];\\n         \\n    }\\n    \\n     \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxScore(int[] nums, int x) {\\n        List<long> T = new ();\\n        int n = nums.Length;\\n        long t = 0;\\n        int Odd = nums[0]%2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int odd = nums[i]%2;\\n            if(odd==Odd)\\n            {\\n                t += nums[i];\\n            }\\n            else\\n            {\\n                T.Add(t);\\n                t = (long)nums[i];\\n                Odd = odd;\\n            }\\n        }\\n        T.Add(t); \\n       \\n        n = T.Count;\\n        if(n>1)\\n           T[n-2] = Math.Max(T[n-2],T[n-1] + T[n-2] - x);\\n        \\n        for(int i=n-3;i>=0;i--)\\n        {\\n            T[i] =  Math.Max(T[i] + T[i+2], T[i] + T[i+1] - x);\\n        }  \\n        \\n        return T[0];\\n         \\n    }\\n    \\n     \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806400,
                "title": "c-easy-fast-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums, int x,int idx,int prev,vector<vector<long long>> &dp)\\n    {\\n        if(idx>=nums.size())\\n        return 0;\\n\\n        if(dp[idx][prev+1]!=-1)\\n        return dp[idx][prev+1];\\n\\n        long long notpick=solve(nums,x,idx+1,prev,dp);\\n        long long pick=0;\\n        if(prev==-1 || (nums[idx]%2==prev))\\n        {\\n            pick=nums[idx]+solve(nums,x,idx+1,nums[idx]%2,dp);\\n        }\\n        else if(nums[idx]%2!=prev)\\n        {\\n            pick=nums[idx]-x+solve(nums,x,idx+1,nums[idx]%2,dp);\\n        }\\n\\n        return dp[idx][prev+1]=max(pick,notpick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size()+1,vector<long long>(3,-1));\\n        return nums[0]+solve(nums,x,1,nums[0]%2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums, int x,int idx,int prev,vector<vector<long long>> &dp)\\n    {\\n        if(idx>=nums.size())\\n        return 0;\\n\\n        if(dp[idx][prev+1]!=-1)\\n        return dp[idx][prev+1];\\n\\n        long long notpick=solve(nums,x,idx+1,prev,dp);\\n        long long pick=0;\\n        if(prev==-1 || (nums[idx]%2==prev))\\n        {\\n            pick=nums[idx]+solve(nums,x,idx+1,nums[idx]%2,dp);\\n        }\\n        else if(nums[idx]%2!=prev)\\n        {\\n            pick=nums[idx]-x+solve(nums,x,idx+1,nums[idx]%2,dp);\\n        }\\n\\n        return dp[idx][prev+1]=max(pick,notpick);\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        vector<vector<long long>> dp(nums.size()+1,vector<long long>(3,-1));\\n        return nums[0]+solve(nums,x,1,nums[0]%2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806155,
                "title": "time-o-n-space-o-1-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitialize even and odd with -x, at index i , if value is odd/even\\ncheck how to maximize the current value , if value is odd odd,\\nand prev path is also odd check if even -x +value is not giving the max value then odd+value will be the answer of odd param. similarly we can \\nconclude for even param, at last max of both will be our answer \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nFinding result using 1 iternation only so \\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1) \\n\\n# Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long even=-x;\\n        long odd=-x;\\n\\n        if((nums[0] & 1)==1){\\n            //odd \\n            odd=nums[0];\\n        }else{\\n            even=nums[0];\\n        }\\n\\n        long maxVal=Math.max(odd,even);\\n\\n        for(int i=1;i<nums.length;i++){\\n             if((nums[i] & 1)==1){//odd\\n               \\n                odd=Math.max(nums[i]+even-x,odd+nums[i]);\\n        }else{\\n            even=Math.max(nums[i]+even,odd+nums[i]-x);\\n                  \\n        }\\n            \\n        }\\n\\n        return Math.max(even,odd);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        long even=-x;\\n        long odd=-x;\\n\\n        if((nums[0] & 1)==1){\\n            //odd \\n            odd=nums[0];\\n        }else{\\n            even=nums[0];\\n        }\\n\\n        long maxVal=Math.max(odd,even);\\n\\n        for(int i=1;i<nums.length;i++){\\n             if((nums[i] & 1)==1){//odd\\n               \\n                odd=Math.max(nums[i]+even-x,odd+nums[i]);\\n        }else{\\n            even=Math.max(nums[i]+even,odd+nums[i]-x);\\n                  \\n        }\\n            \\n        }\\n\\n        return Math.max(even,odd);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806071,
                "title": "use-simple-approach-where-i-used-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long ep = 0, op = 0;\\n\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums[i]&1) {\\n                op = max(op + nums[i], ep + nums[i] - x);\\n            } else {\\n                ep = max(ep + nums[i], op + nums[i] - x);\\n            }\\n        }\\n\\n        if (nums[0]&1) \\n            return op;\\n        \\n\\n        return ep;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long ep = 0, op = 0;\\n\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums[i]&1) {\\n                op = max(op + nums[i], ep + nums[i] - x);\\n            } else {\\n                ep = max(ep + nums[i], op + nums[i] - x);\\n            }\\n        }\\n\\n        if (nums[0]&1) \\n            return op;\\n        \\n\\n        return ep;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805963,
                "title": "need-help-got-till-memoization-but-can-t-do-bottom-up-for-this",
                "content": "# Recursion\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can do this using recursion by considering the subproblem as finding the maximum score if the element is picked and if the element is not picked. \\n`If the element is picked, the score will be based on it\\'s previous element.`\\n\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ [stack space]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& n, int x,int prev,int i){\\n        if(i>=n.size()) return 0;\\n        int pick = (n[i]%2==n[prev]%2) ? n[i]+f(n,x,i,i+1) : n[i]-x+f(n,x,i,i+1);\\n        int not_pick=f(n,x,prev,i+1);\\n        return max(pick,not_pick);\\n    }\\n    long long maxScore(vector<int>& n, int x) {\\n        int prev=0;\\n        return n[0]+f(n,x,prev,1);\\n    }\\n};\\n```\\n# Memoization\\nAs there are 2 variables that recursion uses, we need to use a 2d array.\\n- Time complexity: $$O(n^2)$$ [Not sure about this]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$+$$O(n^2)$$ [stack space+2D array]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& n, int x,int prev,int i,vector<vector<int>>& dp){\\n        if(i>=n.size()) return 0;\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        return dp[prev][i]=max((n[i]%2==n[prev]%2)?n[i]+f(n,x,i,i+1,dp):n[i]-x+f(n,x,i,i+1,dp),f(n,x,prev,i+1,dp));\\n    }\\n    long long maxScore(vector<int>& n, int x) {\\n        vector<vector<int>>& dp(n.size(),vector<int>(n.size(),-1));\\n        int prev=0;\\n        return n[0]+f(n,x,prev,1,dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n\\nAnybody there???",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int>& n, int x,int prev,int i){\\n        if(i>=n.size()) return 0;\\n        int pick = (n[i]%2==n[prev]%2) ? n[i]+f(n,x,i,i+1) : n[i]-x+f(n,x,i,i+1);\\n        int not_pick=f(n,x,prev,i+1);\\n        return max(pick,not_pick);\\n    }\\n    long long maxScore(vector<int>& n, int x) {\\n        int prev=0;\\n        return n[0]+f(n,x,prev,1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& n, int x,int prev,int i,vector<vector<int>>& dp){\\n        if(i>=n.size()) return 0;\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        return dp[prev][i]=max((n[i]%2==n[prev]%2)?n[i]+f(n,x,i,i+1,dp):n[i]-x+f(n,x,i,i+1,dp),f(n,x,prev,i+1,dp));\\n    }\\n    long long maxScore(vector<int>& n, int x) {\\n        vector<vector<int>>& dp(n.size(),vector<int>(n.size(),-1));\\n        int prev=0;\\n        return n[0]+f(n,x,prev,1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805921,
                "title": "simple-c-solution-using-dynamic-programming",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool getParity(int y){\\n        return y&1;\\n    }\\n    int n;\\n    int x;\\n    long long solve(int i , bool prev ,vector<int>&arr  , vector<vector<long long>>&dp){\\n        if(i==n) return 0;\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        if(getParity(arr[i])==prev){\\n            return dp[i][prev] = max(arr[i] + solve(i+1 , getParity(arr[i]) , arr,dp) ,\\n            solve(i+1 ,prev , arr,dp)\\n             );\\n        }\\n\\n        return dp[i][prev] =max(arr[i]-x + solve(i+1 , getParity(arr[i]) , arr,dp) ,\\n            solve(i+1 ,prev , arr,dp)\\n        );\\n\\n    }\\n    long long maxScore(vector<int>& arr, int X) {\\n        n = arr.size();\\n        x = X;\\n        vector<vector<long long>> dp(n , vector<long long>(2 , -1));\\n        return  arr[0] + solve(1 ,getParity(arr[0]) , arr, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool getParity(int y){\\n        return y&1;\\n    }\\n    int n;\\n    int x;\\n    long long solve(int i , bool prev ,vector<int>&arr  , vector<vector<long long>>&dp){\\n        if(i==n) return 0;\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        if(getParity(arr[i])==prev){\\n            return dp[i][prev] = max(arr[i] + solve(i+1 , getParity(arr[i]) , arr,dp) ,\\n            solve(i+1 ,prev , arr,dp)\\n             );\\n        }\\n\\n        return dp[i][prev] =max(arr[i]-x + solve(i+1 , getParity(arr[i]) , arr,dp) ,\\n            solve(i+1 ,prev , arr,dp)\\n        );\\n\\n    }\\n    long long maxScore(vector<int>& arr, int X) {\\n        n = arr.size();\\n        x = X;\\n        vector<vector<long long>> dp(n , vector<long long>(2 , -1));\\n        return  arr[0] + solve(1 ,getParity(arr[0]) , arr, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805677,
                "title": "golang-dp-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```go\\nfunc maxScore(nums []int, x int) int64 {\\n\\tdp := make([]int, len(nums))\\n\\tprevEven, prevOdd := -1, -1\\n\\tdp[0] = nums[0]\\n\\tif nums[0] % 2 == 0 {\\n\\t\\tprevEven = 0\\n\\t} else {\\n\\t\\tprevOdd = 0\\n\\t}\\n\\tcurScore := dp[0]\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tdp[i] = math.MinInt64\\n\\t\\tif nums[i] % 2 == 0 {\\n\\t\\t\\tif prevEven != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[prevEven]+nums[i])\\n\\t\\t\\t}\\n\\t\\t\\tif prevOdd != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[prevOdd]+nums[i]-x)\\n\\t\\t\\t}\\n\\t\\t\\tprevEven = i\\n\\t\\t} else {\\n\\t\\t\\tif prevEven != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[prevEven]+nums[i]-x)\\n\\t\\t\\t}\\n\\t\\t\\tif prevOdd != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[prevOdd]+nums[i])\\n\\t\\t\\t}\\n\\t\\t\\tprevOdd = i\\n\\t\\t}\\n\\t\\tcurScore = max(curScore, dp[i])\\n\\t}\\n\\treturn int64(curScore)\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt64\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc maxScore(nums []int, x int) int64 {\\n\\tdp := make([]int, len(nums))\\n\\tprevEven, prevOdd := -1, -1\\n\\tdp[0] = nums[0]\\n\\tif nums[0] % 2 == 0 {\\n\\t\\tprevEven = 0\\n\\t} else {\\n\\t\\tprevOdd = 0\\n\\t}\\n\\tcurScore := dp[0]\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tdp[i] = math.MinInt64\\n\\t\\tif nums[i] % 2 == 0 {\\n\\t\\t\\tif prevEven != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[prevEven]+nums[i])\\n\\t\\t\\t}\\n\\t\\t\\tif prevOdd != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[prevOdd]+nums[i]-x)\\n\\t\\t\\t}\\n\\t\\t\\tprevEven = i\\n\\t\\t} else {\\n\\t\\t\\tif prevEven != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[prevEven]+nums[i]-x)\\n\\t\\t\\t}\\n\\t\\t\\tif prevOdd != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[prevOdd]+nums[i])\\n\\t\\t\\t}\\n\\t\\t\\tprevOdd = i\\n\\t\\t}\\n\\t\\tcurScore = max(curScore, dp[i])\\n\\t}\\n\\treturn int64(curScore)\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt64\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805596,
                "title": "100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, nums, x):\\n        if(nums[0]%2==0):\\n            even=nums[0]\\n            odd=nums[0]-x\\n        else:\\n            even=nums[0]-x\\n            odd=nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            if(nums[i]%2==0):\\n                even=max(even+nums[i],odd+nums[i]-x)\\n            else:\\n                odd=max(odd+nums[i],even+nums[i]-x)\\n        return max(odd,even)\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, nums, x):\\n        if(nums[0]%2==0):\\n            even=nums[0]\\n            odd=nums[0]-x\\n        else:\\n            even=nums[0]-x\\n            odd=nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            if(nums[i]%2==0):\\n                even=max(even+nums[i],odd+nums[i]-x)\\n            else:\\n                odd=max(odd+nums[i],even+nums[i]-x)\\n        return max(odd,even)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805576,
                "title": "c-time-o-n-space-o-1-solution-with-explanation",
                "content": "# Intuition\\nMaximum points we can get by starting from a point is only depend on the maximum point we can get from the  next point with same parity or different parity\\n\\n# Approach\\nWe start traversing the array and at every point we will find the maximum point we can get by starting with this point .\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long greaterodd=0;\\n        long long greatereven=0;\\n        int n=nums.size();\\n\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]%2){\\n                greaterodd=max(greaterodd+nums[i],nums[i]+greatereven-x);\\n            }\\n            else{\\n                greatereven=max(greatereven+nums[i],nums[i]+greaterodd-x);\\n            }\\n        }\\n        return nums[0]%2?greaterodd:greatereven;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long greaterodd=0;\\n        long long greatereven=0;\\n        int n=nums.size();\\n\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i]%2){\\n                greaterodd=max(greaterodd+nums[i],nums[i]+greatereven-x);\\n            }\\n            else{\\n                greatereven=max(greatereven+nums[i],nums[i]+greaterodd-x);\\n            }\\n        }\\n        return nums[0]%2?greaterodd:greatereven;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805355,
                "title": "dp-beats-100-speed-beats-100-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMaximum score in current point depends on previous score, this is DP problem. We have to identify from which point it is good to jump to current one (from odd point or from even point). So we have to keep max score from both even and odd. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize both `even` and `odd`. Remember that initialazation is tricky. \\nIf first element is even then current score is `nums[0]`, else it is `nums[0] - x` \\n\\n`long long even = nums[0]%2 == 0 ? nums[0] : nums[0] - x`\\n`long long odd = nums[0]%2 != 0 ? nums[0] : nums[0] - x`\\n\\nThen we start to iterate from first element in array. If current element is even then we check whether it is better from previous even or odd. \\n`even = max(even + nums[i], odd + nums[i] - x)`\\n\\nThe same true in odd case. \\n`odd = max(odd + nums[i], even + nums[i] - x)`\\n\\nThen we will keep maximum one \\n`ans = max(ans, max(even, odd))`\\n\\n# Complexity\\n- Time complexity:\\nWe are iterating array one time only so time complexity is `O(N)`\\n\\n- Space complexity:\\nAs we are not using any additional space so space complexity is constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long ans = nums[0];\\n        cout << nums.size();\\n        long long even = nums[0]%2 == 0 ? nums[0] : nums[0] - x;\\n        long long odd = nums[0]%2 != 0 ? nums[0] : nums[0] - x;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i]%2 == 0) {\\n                // if current is even, which point gives more score to jump from.\\n                even = max(even + nums[i], odd + nums[i] - x);\\n            } else {\\n                odd = max(odd + nums[i], even + nums[i] - x);\\n            }\\n            \\n            ans = max(ans, max(even, odd));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long ans = nums[0];\\n        cout << nums.size();\\n        long long even = nums[0]%2 == 0 ? nums[0] : nums[0] - x;\\n        long long odd = nums[0]%2 != 0 ? nums[0] : nums[0] - x;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i]%2 == 0) {\\n                // if current is even, which point gives more score to jump from.\\n                even = max(even + nums[i], odd + nums[i] - x);\\n            } else {\\n                odd = max(odd + nums[i], even + nums[i] - x);\\n            }\\n            \\n            ans = max(ans, max(even, odd));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3805258,
                "title": "simple-easy-c-memorization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    //even=1 odd=0\\n    long long solve(int ind,vector<int>&nums,int x,int prev,vector<vector<long long>>&dp){\\n        if(ind==nums.size()) return 0;\\n        long long pick=0,nonpick=0;\\n        if(dp[ind][prev]!=-1) return dp[ind][prev];\\n        if(ind==0){\\n            pick+=nums[ind]+solve(ind+1,nums,x,prev,dp);\\n        } \\n        else if((prev==1 and nums[ind]%2==0 )or (prev==0 and nums[ind]%2\\n               !=0)){\\n            pick+=nums[ind]+solve(ind+1,nums,x,nums[ind]%2==0?1:0,dp);\\n            nonpick+=solve(ind+1,nums,x,prev,dp);\\n        }\\n        else{\\n            pick+=nums[ind]+(-x)+solve(ind+1,nums,x,nums[ind]%2==0?1:0,dp);\\n            nonpick+=solve(ind+1,nums,x,prev,dp);\\n        }\\n        return dp[ind][prev]=max(pick,nonpick);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n+1,vector<long long>(2,-1));\\n        return solve(0,nums,x,nums[0]%2==0?1:0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //even=1 odd=0\\n    long long solve(int ind,vector<int>&nums,int x,int prev,vector<vector<long long>>&dp){\\n        if(ind==nums.size()) return 0;\\n        long long pick=0,nonpick=0;\\n        if(dp[ind][prev]!=-1) return dp[ind][prev];\\n        if(ind==0){\\n            pick+=nums[ind]+solve(ind+1,nums,x,prev,dp);\\n        } \\n        else if((prev==1 and nums[ind]%2==0 )or (prev==0 and nums[ind]%2\\n               !=0)){\\n            pick+=nums[ind]+solve(ind+1,nums,x,nums[ind]%2==0?1:0,dp);\\n            nonpick+=solve(ind+1,nums,x,prev,dp);\\n        }\\n        else{\\n            pick+=nums[ind]+(-x)+solve(ind+1,nums,x,nums[ind]%2==0?1:0,dp);\\n            nonpick+=solve(ind+1,nums,x,prev,dp);\\n        }\\n        return dp[ind][prev]=max(pick,nonpick);\\n    }\\n    \\n    long long maxScore(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<long long>>dp(n+1,vector<long long>(2,-1));\\n        return solve(0,nums,x,nums[0]%2==0?1:0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1981947,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I think this problem could use better description, seriously they are using the word `parity` . Anyone in computer science can think  `If the total number of set-bits in the binary representation of a number is even then the number is said to have even parity, otherwise, it will have odd parity.`  But here they simply meant even or odd. I wasted so much time in contest trying to figure out what just parity was, and couldn\\'t solve it. It\\'s unfair."
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "I also, thanks\\n"
                    },
                    {
                        "username": "1032200230",
                        "content": "I understood after reading your comment!"
                    },
                    {
                        "username": "willydlw",
                        "content": "Agreed! They need to distinguish between mathematical parity (whether an integer is odd or even) and computer science parity ( number of bits that are set to 1). "
                    },
                    {
                        "username": "nathannaveen",
                        "content": "Thanks, I didn\\u2019t understand what they meant by \\u201Cparity\\u201D before this comment! "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "WTF is parities."
                    },
                    {
                        "username": "virendras996",
                        "content": "[@ms232gg](/ms232gg) It basically means that, any two numbers can have same parity if and only if both are either even or both are odd. If either one is even/ odd and other being opposite of it, then we can consider that they have different parities."
                    },
                    {
                        "username": "ms232gg",
                        "content": "243 solutions but no one has answered this yet. People just hungry for upvotes rather than actually helping"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "They should have defined what a parity means. @leetcode, please take a note of this and resolve the statement. People reviewing this question before this was up for the contest should re-evaluate their reviewing strategies. "
                    },
                    {
                        "username": "bcs_abhisekh",
                        "content": "This Note section of this question make it easier. \nThink about the case when nums[0] is not selected initially. This might make it tougher than all other question. \nWell my idea for this case is -\nWhatever the initial category(even or odd) of number is chosen the final chosen number must be last even number or last odd number. So apply the same solution which is applied on this question but starts from last odd  number occurred index and do same for last even occurred number and return the maximum of two.\n\nNote: Feel free to share your opinion and if I am wrong then provide your approach.\n\nHere is the code link for my above approach. \n[Solution](https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001023126/)"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Q. Why my version of code is getting TLE after running 722 test cases.\\n```\\nclass Solution {\\n    private long help(int id, int prevParity, int[] nums,int n,int x,long[][] dp){\\n        if(id>=n){\\n            return 0;\\n        }\\n        if( dp[id][prevParity]!=-1) return dp[id][prevParity];\\n        int parity = nums[id]%2; //0- evn, 1-odd\\n        long currAns = 0;\\n        for(int i=id+1;i<n;i++){\\n            currAns = Math.max(currAns, help(i,parity,nums,n,x,dp));\\n        }\\n        if(prevParity==2){\\n            currAns += (long)nums[id];\\n        }else{\\n            if(prevParity!=(nums[id]&1)){\\n                currAns += (long)nums[id]-x;\\n            }else{\\n                currAns += (long)nums[id];\\n            }\\n        }\\n        return dp[id][prevParity]=currAns;\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][3];\\n        for(long[] t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        return help(0,2,nums,n,x,dp);\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Mostly because even though you have memoized, for each index you are looping through all the greater indices so in total O(n^2) calls are being made. You arent calculating it n^2 times rather just calling it that many times. Try to fix it by using the standard skip/take method instead of looping through the greater indices for each index"
                    },
                    {
                        "username": "Tejasvi_Bajaj",
                        "content": "parities loml"
                    },
                    {
                        "username": "w7089",
                        "content": "Is there a way to optimize the below code using memoization for instance? It works for small inputs only:\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @cache\\n        def pnlty(a,b):\\n            if (a % 2 == 0 and b % 2 == 0) or (a % 2 != 0 and b % 2 != 0):\\n                return 0\\n            return -x\\n\\n        n = len(nums)\\n        res = [0] * n\\n        res[0] = nums[0]\\n        for i in range(1,n):\\n            res[i] = max([res[j] + nums[i] + pnlty(nums[i],nums[j]) for j in range(i) ])\\n        return max(res)\\n```"
                    },
                    {
                        "username": "chiruu453",
                        "content": "i tried to solve this question without dp . my code has passed 160 cases and then ans obtained was different \\ncan anyone help me to find whats wrong in my code.\\nhere is my code.\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev=0;int next=1;long long int ans=nums[0];\\n        while(next<nums.size()){\\n            if(nums[prev]%2==nums[next]%2){\\n                ans=ans+nums[next];\\n                prev=next;\\n                next++;\\n            }\\n            else{\\n                if(nums[next]<=x){\\n                    next++;\\n                }\\n                else{\\n                    int maxi=0;\\n                    prev++;\\n                    for(prev;prev<next;prev++){\\n                        maxi=max(maxi,nums[prev]);\\n                    }\\n                    ans=ans+maxi+nums[next]-x;\\n                    prev=next;\\n                    next++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1982945,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I think this problem could use better description, seriously they are using the word `parity` . Anyone in computer science can think  `If the total number of set-bits in the binary representation of a number is even then the number is said to have even parity, otherwise, it will have odd parity.`  But here they simply meant even or odd. I wasted so much time in contest trying to figure out what just parity was, and couldn\\'t solve it. It\\'s unfair."
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "I also, thanks\\n"
                    },
                    {
                        "username": "1032200230",
                        "content": "I understood after reading your comment!"
                    },
                    {
                        "username": "willydlw",
                        "content": "Agreed! They need to distinguish between mathematical parity (whether an integer is odd or even) and computer science parity ( number of bits that are set to 1). "
                    },
                    {
                        "username": "nathannaveen",
                        "content": "Thanks, I didn\\u2019t understand what they meant by \\u201Cparity\\u201D before this comment! "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "WTF is parities."
                    },
                    {
                        "username": "virendras996",
                        "content": "[@ms232gg](/ms232gg) It basically means that, any two numbers can have same parity if and only if both are either even or both are odd. If either one is even/ odd and other being opposite of it, then we can consider that they have different parities."
                    },
                    {
                        "username": "ms232gg",
                        "content": "243 solutions but no one has answered this yet. People just hungry for upvotes rather than actually helping"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "They should have defined what a parity means. @leetcode, please take a note of this and resolve the statement. People reviewing this question before this was up for the contest should re-evaluate their reviewing strategies. "
                    },
                    {
                        "username": "bcs_abhisekh",
                        "content": "This Note section of this question make it easier. \nThink about the case when nums[0] is not selected initially. This might make it tougher than all other question. \nWell my idea for this case is -\nWhatever the initial category(even or odd) of number is chosen the final chosen number must be last even number or last odd number. So apply the same solution which is applied on this question but starts from last odd  number occurred index and do same for last even occurred number and return the maximum of two.\n\nNote: Feel free to share your opinion and if I am wrong then provide your approach.\n\nHere is the code link for my above approach. \n[Solution](https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001023126/)"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Q. Why my version of code is getting TLE after running 722 test cases.\\n```\\nclass Solution {\\n    private long help(int id, int prevParity, int[] nums,int n,int x,long[][] dp){\\n        if(id>=n){\\n            return 0;\\n        }\\n        if( dp[id][prevParity]!=-1) return dp[id][prevParity];\\n        int parity = nums[id]%2; //0- evn, 1-odd\\n        long currAns = 0;\\n        for(int i=id+1;i<n;i++){\\n            currAns = Math.max(currAns, help(i,parity,nums,n,x,dp));\\n        }\\n        if(prevParity==2){\\n            currAns += (long)nums[id];\\n        }else{\\n            if(prevParity!=(nums[id]&1)){\\n                currAns += (long)nums[id]-x;\\n            }else{\\n                currAns += (long)nums[id];\\n            }\\n        }\\n        return dp[id][prevParity]=currAns;\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][3];\\n        for(long[] t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        return help(0,2,nums,n,x,dp);\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Mostly because even though you have memoized, for each index you are looping through all the greater indices so in total O(n^2) calls are being made. You arent calculating it n^2 times rather just calling it that many times. Try to fix it by using the standard skip/take method instead of looping through the greater indices for each index"
                    },
                    {
                        "username": "Tejasvi_Bajaj",
                        "content": "parities loml"
                    },
                    {
                        "username": "w7089",
                        "content": "Is there a way to optimize the below code using memoization for instance? It works for small inputs only:\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @cache\\n        def pnlty(a,b):\\n            if (a % 2 == 0 and b % 2 == 0) or (a % 2 != 0 and b % 2 != 0):\\n                return 0\\n            return -x\\n\\n        n = len(nums)\\n        res = [0] * n\\n        res[0] = nums[0]\\n        for i in range(1,n):\\n            res[i] = max([res[j] + nums[i] + pnlty(nums[i],nums[j]) for j in range(i) ])\\n        return max(res)\\n```"
                    },
                    {
                        "username": "chiruu453",
                        "content": "i tried to solve this question without dp . my code has passed 160 cases and then ans obtained was different \\ncan anyone help me to find whats wrong in my code.\\nhere is my code.\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev=0;int next=1;long long int ans=nums[0];\\n        while(next<nums.size()){\\n            if(nums[prev]%2==nums[next]%2){\\n                ans=ans+nums[next];\\n                prev=next;\\n                next++;\\n            }\\n            else{\\n                if(nums[next]<=x){\\n                    next++;\\n                }\\n                else{\\n                    int maxi=0;\\n                    prev++;\\n                    for(prev;prev<next;prev++){\\n                        maxi=max(maxi,nums[prev]);\\n                    }\\n                    ans=ans+maxi+nums[next]-x;\\n                    prev=next;\\n                    next++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1984657,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I think this problem could use better description, seriously they are using the word `parity` . Anyone in computer science can think  `If the total number of set-bits in the binary representation of a number is even then the number is said to have even parity, otherwise, it will have odd parity.`  But here they simply meant even or odd. I wasted so much time in contest trying to figure out what just parity was, and couldn\\'t solve it. It\\'s unfair."
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "I also, thanks\\n"
                    },
                    {
                        "username": "1032200230",
                        "content": "I understood after reading your comment!"
                    },
                    {
                        "username": "willydlw",
                        "content": "Agreed! They need to distinguish between mathematical parity (whether an integer is odd or even) and computer science parity ( number of bits that are set to 1). "
                    },
                    {
                        "username": "nathannaveen",
                        "content": "Thanks, I didn\\u2019t understand what they meant by \\u201Cparity\\u201D before this comment! "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "WTF is parities."
                    },
                    {
                        "username": "virendras996",
                        "content": "[@ms232gg](/ms232gg) It basically means that, any two numbers can have same parity if and only if both are either even or both are odd. If either one is even/ odd and other being opposite of it, then we can consider that they have different parities."
                    },
                    {
                        "username": "ms232gg",
                        "content": "243 solutions but no one has answered this yet. People just hungry for upvotes rather than actually helping"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "They should have defined what a parity means. @leetcode, please take a note of this and resolve the statement. People reviewing this question before this was up for the contest should re-evaluate their reviewing strategies. "
                    },
                    {
                        "username": "bcs_abhisekh",
                        "content": "This Note section of this question make it easier. \nThink about the case when nums[0] is not selected initially. This might make it tougher than all other question. \nWell my idea for this case is -\nWhatever the initial category(even or odd) of number is chosen the final chosen number must be last even number or last odd number. So apply the same solution which is applied on this question but starts from last odd  number occurred index and do same for last even occurred number and return the maximum of two.\n\nNote: Feel free to share your opinion and if I am wrong then provide your approach.\n\nHere is the code link for my above approach. \n[Solution](https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001023126/)"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Q. Why my version of code is getting TLE after running 722 test cases.\\n```\\nclass Solution {\\n    private long help(int id, int prevParity, int[] nums,int n,int x,long[][] dp){\\n        if(id>=n){\\n            return 0;\\n        }\\n        if( dp[id][prevParity]!=-1) return dp[id][prevParity];\\n        int parity = nums[id]%2; //0- evn, 1-odd\\n        long currAns = 0;\\n        for(int i=id+1;i<n;i++){\\n            currAns = Math.max(currAns, help(i,parity,nums,n,x,dp));\\n        }\\n        if(prevParity==2){\\n            currAns += (long)nums[id];\\n        }else{\\n            if(prevParity!=(nums[id]&1)){\\n                currAns += (long)nums[id]-x;\\n            }else{\\n                currAns += (long)nums[id];\\n            }\\n        }\\n        return dp[id][prevParity]=currAns;\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][3];\\n        for(long[] t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        return help(0,2,nums,n,x,dp);\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Mostly because even though you have memoized, for each index you are looping through all the greater indices so in total O(n^2) calls are being made. You arent calculating it n^2 times rather just calling it that many times. Try to fix it by using the standard skip/take method instead of looping through the greater indices for each index"
                    },
                    {
                        "username": "Tejasvi_Bajaj",
                        "content": "parities loml"
                    },
                    {
                        "username": "w7089",
                        "content": "Is there a way to optimize the below code using memoization for instance? It works for small inputs only:\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @cache\\n        def pnlty(a,b):\\n            if (a % 2 == 0 and b % 2 == 0) or (a % 2 != 0 and b % 2 != 0):\\n                return 0\\n            return -x\\n\\n        n = len(nums)\\n        res = [0] * n\\n        res[0] = nums[0]\\n        for i in range(1,n):\\n            res[i] = max([res[j] + nums[i] + pnlty(nums[i],nums[j]) for j in range(i) ])\\n        return max(res)\\n```"
                    },
                    {
                        "username": "chiruu453",
                        "content": "i tried to solve this question without dp . my code has passed 160 cases and then ans obtained was different \\ncan anyone help me to find whats wrong in my code.\\nhere is my code.\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev=0;int next=1;long long int ans=nums[0];\\n        while(next<nums.size()){\\n            if(nums[prev]%2==nums[next]%2){\\n                ans=ans+nums[next];\\n                prev=next;\\n                next++;\\n            }\\n            else{\\n                if(nums[next]<=x){\\n                    next++;\\n                }\\n                else{\\n                    int maxi=0;\\n                    prev++;\\n                    for(prev;prev<next;prev++){\\n                        maxi=max(maxi,nums[prev]);\\n                    }\\n                    ans=ans+maxi+nums[next]-x;\\n                    prev=next;\\n                    next++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1981754,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I think this problem could use better description, seriously they are using the word `parity` . Anyone in computer science can think  `If the total number of set-bits in the binary representation of a number is even then the number is said to have even parity, otherwise, it will have odd parity.`  But here they simply meant even or odd. I wasted so much time in contest trying to figure out what just parity was, and couldn\\'t solve it. It\\'s unfair."
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "I also, thanks\\n"
                    },
                    {
                        "username": "1032200230",
                        "content": "I understood after reading your comment!"
                    },
                    {
                        "username": "willydlw",
                        "content": "Agreed! They need to distinguish between mathematical parity (whether an integer is odd or even) and computer science parity ( number of bits that are set to 1). "
                    },
                    {
                        "username": "nathannaveen",
                        "content": "Thanks, I didn\\u2019t understand what they meant by \\u201Cparity\\u201D before this comment! "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "WTF is parities."
                    },
                    {
                        "username": "virendras996",
                        "content": "[@ms232gg](/ms232gg) It basically means that, any two numbers can have same parity if and only if both are either even or both are odd. If either one is even/ odd and other being opposite of it, then we can consider that they have different parities."
                    },
                    {
                        "username": "ms232gg",
                        "content": "243 solutions but no one has answered this yet. People just hungry for upvotes rather than actually helping"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "They should have defined what a parity means. @leetcode, please take a note of this and resolve the statement. People reviewing this question before this was up for the contest should re-evaluate their reviewing strategies. "
                    },
                    {
                        "username": "bcs_abhisekh",
                        "content": "This Note section of this question make it easier. \nThink about the case when nums[0] is not selected initially. This might make it tougher than all other question. \nWell my idea for this case is -\nWhatever the initial category(even or odd) of number is chosen the final chosen number must be last even number or last odd number. So apply the same solution which is applied on this question but starts from last odd  number occurred index and do same for last even occurred number and return the maximum of two.\n\nNote: Feel free to share your opinion and if I am wrong then provide your approach.\n\nHere is the code link for my above approach. \n[Solution](https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001023126/)"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Q. Why my version of code is getting TLE after running 722 test cases.\\n```\\nclass Solution {\\n    private long help(int id, int prevParity, int[] nums,int n,int x,long[][] dp){\\n        if(id>=n){\\n            return 0;\\n        }\\n        if( dp[id][prevParity]!=-1) return dp[id][prevParity];\\n        int parity = nums[id]%2; //0- evn, 1-odd\\n        long currAns = 0;\\n        for(int i=id+1;i<n;i++){\\n            currAns = Math.max(currAns, help(i,parity,nums,n,x,dp));\\n        }\\n        if(prevParity==2){\\n            currAns += (long)nums[id];\\n        }else{\\n            if(prevParity!=(nums[id]&1)){\\n                currAns += (long)nums[id]-x;\\n            }else{\\n                currAns += (long)nums[id];\\n            }\\n        }\\n        return dp[id][prevParity]=currAns;\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][3];\\n        for(long[] t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        return help(0,2,nums,n,x,dp);\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Mostly because even though you have memoized, for each index you are looping through all the greater indices so in total O(n^2) calls are being made. You arent calculating it n^2 times rather just calling it that many times. Try to fix it by using the standard skip/take method instead of looping through the greater indices for each index"
                    },
                    {
                        "username": "Tejasvi_Bajaj",
                        "content": "parities loml"
                    },
                    {
                        "username": "w7089",
                        "content": "Is there a way to optimize the below code using memoization for instance? It works for small inputs only:\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @cache\\n        def pnlty(a,b):\\n            if (a % 2 == 0 and b % 2 == 0) or (a % 2 != 0 and b % 2 != 0):\\n                return 0\\n            return -x\\n\\n        n = len(nums)\\n        res = [0] * n\\n        res[0] = nums[0]\\n        for i in range(1,n):\\n            res[i] = max([res[j] + nums[i] + pnlty(nums[i],nums[j]) for j in range(i) ])\\n        return max(res)\\n```"
                    },
                    {
                        "username": "chiruu453",
                        "content": "i tried to solve this question without dp . my code has passed 160 cases and then ans obtained was different \\ncan anyone help me to find whats wrong in my code.\\nhere is my code.\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev=0;int next=1;long long int ans=nums[0];\\n        while(next<nums.size()){\\n            if(nums[prev]%2==nums[next]%2){\\n                ans=ans+nums[next];\\n                prev=next;\\n                next++;\\n            }\\n            else{\\n                if(nums[next]<=x){\\n                    next++;\\n                }\\n                else{\\n                    int maxi=0;\\n                    prev++;\\n                    for(prev;prev<next;prev++){\\n                        maxi=max(maxi,nums[prev]);\\n                    }\\n                    ans=ans+maxi+nums[next]-x;\\n                    prev=next;\\n                    next++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1981678,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I think this problem could use better description, seriously they are using the word `parity` . Anyone in computer science can think  `If the total number of set-bits in the binary representation of a number is even then the number is said to have even parity, otherwise, it will have odd parity.`  But here they simply meant even or odd. I wasted so much time in contest trying to figure out what just parity was, and couldn\\'t solve it. It\\'s unfair."
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "I also, thanks\\n"
                    },
                    {
                        "username": "1032200230",
                        "content": "I understood after reading your comment!"
                    },
                    {
                        "username": "willydlw",
                        "content": "Agreed! They need to distinguish between mathematical parity (whether an integer is odd or even) and computer science parity ( number of bits that are set to 1). "
                    },
                    {
                        "username": "nathannaveen",
                        "content": "Thanks, I didn\\u2019t understand what they meant by \\u201Cparity\\u201D before this comment! "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "WTF is parities."
                    },
                    {
                        "username": "virendras996",
                        "content": "[@ms232gg](/ms232gg) It basically means that, any two numbers can have same parity if and only if both are either even or both are odd. If either one is even/ odd and other being opposite of it, then we can consider that they have different parities."
                    },
                    {
                        "username": "ms232gg",
                        "content": "243 solutions but no one has answered this yet. People just hungry for upvotes rather than actually helping"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "They should have defined what a parity means. @leetcode, please take a note of this and resolve the statement. People reviewing this question before this was up for the contest should re-evaluate their reviewing strategies. "
                    },
                    {
                        "username": "bcs_abhisekh",
                        "content": "This Note section of this question make it easier. \nThink about the case when nums[0] is not selected initially. This might make it tougher than all other question. \nWell my idea for this case is -\nWhatever the initial category(even or odd) of number is chosen the final chosen number must be last even number or last odd number. So apply the same solution which is applied on this question but starts from last odd  number occurred index and do same for last even occurred number and return the maximum of two.\n\nNote: Feel free to share your opinion and if I am wrong then provide your approach.\n\nHere is the code link for my above approach. \n[Solution](https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001023126/)"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Q. Why my version of code is getting TLE after running 722 test cases.\\n```\\nclass Solution {\\n    private long help(int id, int prevParity, int[] nums,int n,int x,long[][] dp){\\n        if(id>=n){\\n            return 0;\\n        }\\n        if( dp[id][prevParity]!=-1) return dp[id][prevParity];\\n        int parity = nums[id]%2; //0- evn, 1-odd\\n        long currAns = 0;\\n        for(int i=id+1;i<n;i++){\\n            currAns = Math.max(currAns, help(i,parity,nums,n,x,dp));\\n        }\\n        if(prevParity==2){\\n            currAns += (long)nums[id];\\n        }else{\\n            if(prevParity!=(nums[id]&1)){\\n                currAns += (long)nums[id]-x;\\n            }else{\\n                currAns += (long)nums[id];\\n            }\\n        }\\n        return dp[id][prevParity]=currAns;\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][3];\\n        for(long[] t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        return help(0,2,nums,n,x,dp);\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Mostly because even though you have memoized, for each index you are looping through all the greater indices so in total O(n^2) calls are being made. You arent calculating it n^2 times rather just calling it that many times. Try to fix it by using the standard skip/take method instead of looping through the greater indices for each index"
                    },
                    {
                        "username": "Tejasvi_Bajaj",
                        "content": "parities loml"
                    },
                    {
                        "username": "w7089",
                        "content": "Is there a way to optimize the below code using memoization for instance? It works for small inputs only:\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @cache\\n        def pnlty(a,b):\\n            if (a % 2 == 0 and b % 2 == 0) or (a % 2 != 0 and b % 2 != 0):\\n                return 0\\n            return -x\\n\\n        n = len(nums)\\n        res = [0] * n\\n        res[0] = nums[0]\\n        for i in range(1,n):\\n            res[i] = max([res[j] + nums[i] + pnlty(nums[i],nums[j]) for j in range(i) ])\\n        return max(res)\\n```"
                    },
                    {
                        "username": "chiruu453",
                        "content": "i tried to solve this question without dp . my code has passed 160 cases and then ans obtained was different \\ncan anyone help me to find whats wrong in my code.\\nhere is my code.\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev=0;int next=1;long long int ans=nums[0];\\n        while(next<nums.size()){\\n            if(nums[prev]%2==nums[next]%2){\\n                ans=ans+nums[next];\\n                prev=next;\\n                next++;\\n            }\\n            else{\\n                if(nums[next]<=x){\\n                    next++;\\n                }\\n                else{\\n                    int maxi=0;\\n                    prev++;\\n                    for(prev;prev<next;prev++){\\n                        maxi=max(maxi,nums[prev]);\\n                    }\\n                    ans=ans+maxi+nums[next]-x;\\n                    prev=next;\\n                    next++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2004325,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I think this problem could use better description, seriously they are using the word `parity` . Anyone in computer science can think  `If the total number of set-bits in the binary representation of a number is even then the number is said to have even parity, otherwise, it will have odd parity.`  But here they simply meant even or odd. I wasted so much time in contest trying to figure out what just parity was, and couldn\\'t solve it. It\\'s unfair."
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "I also, thanks\\n"
                    },
                    {
                        "username": "1032200230",
                        "content": "I understood after reading your comment!"
                    },
                    {
                        "username": "willydlw",
                        "content": "Agreed! They need to distinguish between mathematical parity (whether an integer is odd or even) and computer science parity ( number of bits that are set to 1). "
                    },
                    {
                        "username": "nathannaveen",
                        "content": "Thanks, I didn\\u2019t understand what they meant by \\u201Cparity\\u201D before this comment! "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "WTF is parities."
                    },
                    {
                        "username": "virendras996",
                        "content": "[@ms232gg](/ms232gg) It basically means that, any two numbers can have same parity if and only if both are either even or both are odd. If either one is even/ odd and other being opposite of it, then we can consider that they have different parities."
                    },
                    {
                        "username": "ms232gg",
                        "content": "243 solutions but no one has answered this yet. People just hungry for upvotes rather than actually helping"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "They should have defined what a parity means. @leetcode, please take a note of this and resolve the statement. People reviewing this question before this was up for the contest should re-evaluate their reviewing strategies. "
                    },
                    {
                        "username": "bcs_abhisekh",
                        "content": "This Note section of this question make it easier. \nThink about the case when nums[0] is not selected initially. This might make it tougher than all other question. \nWell my idea for this case is -\nWhatever the initial category(even or odd) of number is chosen the final chosen number must be last even number or last odd number. So apply the same solution which is applied on this question but starts from last odd  number occurred index and do same for last even occurred number and return the maximum of two.\n\nNote: Feel free to share your opinion and if I am wrong then provide your approach.\n\nHere is the code link for my above approach. \n[Solution](https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001023126/)"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Q. Why my version of code is getting TLE after running 722 test cases.\\n```\\nclass Solution {\\n    private long help(int id, int prevParity, int[] nums,int n,int x,long[][] dp){\\n        if(id>=n){\\n            return 0;\\n        }\\n        if( dp[id][prevParity]!=-1) return dp[id][prevParity];\\n        int parity = nums[id]%2; //0- evn, 1-odd\\n        long currAns = 0;\\n        for(int i=id+1;i<n;i++){\\n            currAns = Math.max(currAns, help(i,parity,nums,n,x,dp));\\n        }\\n        if(prevParity==2){\\n            currAns += (long)nums[id];\\n        }else{\\n            if(prevParity!=(nums[id]&1)){\\n                currAns += (long)nums[id]-x;\\n            }else{\\n                currAns += (long)nums[id];\\n            }\\n        }\\n        return dp[id][prevParity]=currAns;\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][3];\\n        for(long[] t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        return help(0,2,nums,n,x,dp);\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Mostly because even though you have memoized, for each index you are looping through all the greater indices so in total O(n^2) calls are being made. You arent calculating it n^2 times rather just calling it that many times. Try to fix it by using the standard skip/take method instead of looping through the greater indices for each index"
                    },
                    {
                        "username": "Tejasvi_Bajaj",
                        "content": "parities loml"
                    },
                    {
                        "username": "w7089",
                        "content": "Is there a way to optimize the below code using memoization for instance? It works for small inputs only:\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @cache\\n        def pnlty(a,b):\\n            if (a % 2 == 0 and b % 2 == 0) or (a % 2 != 0 and b % 2 != 0):\\n                return 0\\n            return -x\\n\\n        n = len(nums)\\n        res = [0] * n\\n        res[0] = nums[0]\\n        for i in range(1,n):\\n            res[i] = max([res[j] + nums[i] + pnlty(nums[i],nums[j]) for j in range(i) ])\\n        return max(res)\\n```"
                    },
                    {
                        "username": "chiruu453",
                        "content": "i tried to solve this question without dp . my code has passed 160 cases and then ans obtained was different \\ncan anyone help me to find whats wrong in my code.\\nhere is my code.\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev=0;int next=1;long long int ans=nums[0];\\n        while(next<nums.size()){\\n            if(nums[prev]%2==nums[next]%2){\\n                ans=ans+nums[next];\\n                prev=next;\\n                next++;\\n            }\\n            else{\\n                if(nums[next]<=x){\\n                    next++;\\n                }\\n                else{\\n                    int maxi=0;\\n                    prev++;\\n                    for(prev;prev<next;prev++){\\n                        maxi=max(maxi,nums[prev]);\\n                    }\\n                    ans=ans+maxi+nums[next]-x;\\n                    prev=next;\\n                    next++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1983846,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I think this problem could use better description, seriously they are using the word `parity` . Anyone in computer science can think  `If the total number of set-bits in the binary representation of a number is even then the number is said to have even parity, otherwise, it will have odd parity.`  But here they simply meant even or odd. I wasted so much time in contest trying to figure out what just parity was, and couldn\\'t solve it. It\\'s unfair."
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "I also, thanks\\n"
                    },
                    {
                        "username": "1032200230",
                        "content": "I understood after reading your comment!"
                    },
                    {
                        "username": "willydlw",
                        "content": "Agreed! They need to distinguish between mathematical parity (whether an integer is odd or even) and computer science parity ( number of bits that are set to 1). "
                    },
                    {
                        "username": "nathannaveen",
                        "content": "Thanks, I didn\\u2019t understand what they meant by \\u201Cparity\\u201D before this comment! "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "WTF is parities."
                    },
                    {
                        "username": "virendras996",
                        "content": "[@ms232gg](/ms232gg) It basically means that, any two numbers can have same parity if and only if both are either even or both are odd. If either one is even/ odd and other being opposite of it, then we can consider that they have different parities."
                    },
                    {
                        "username": "ms232gg",
                        "content": "243 solutions but no one has answered this yet. People just hungry for upvotes rather than actually helping"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "They should have defined what a parity means. @leetcode, please take a note of this and resolve the statement. People reviewing this question before this was up for the contest should re-evaluate their reviewing strategies. "
                    },
                    {
                        "username": "bcs_abhisekh",
                        "content": "This Note section of this question make it easier. \nThink about the case when nums[0] is not selected initially. This might make it tougher than all other question. \nWell my idea for this case is -\nWhatever the initial category(even or odd) of number is chosen the final chosen number must be last even number or last odd number. So apply the same solution which is applied on this question but starts from last odd  number occurred index and do same for last even occurred number and return the maximum of two.\n\nNote: Feel free to share your opinion and if I am wrong then provide your approach.\n\nHere is the code link for my above approach. \n[Solution](https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001023126/)"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Q. Why my version of code is getting TLE after running 722 test cases.\\n```\\nclass Solution {\\n    private long help(int id, int prevParity, int[] nums,int n,int x,long[][] dp){\\n        if(id>=n){\\n            return 0;\\n        }\\n        if( dp[id][prevParity]!=-1) return dp[id][prevParity];\\n        int parity = nums[id]%2; //0- evn, 1-odd\\n        long currAns = 0;\\n        for(int i=id+1;i<n;i++){\\n            currAns = Math.max(currAns, help(i,parity,nums,n,x,dp));\\n        }\\n        if(prevParity==2){\\n            currAns += (long)nums[id];\\n        }else{\\n            if(prevParity!=(nums[id]&1)){\\n                currAns += (long)nums[id]-x;\\n            }else{\\n                currAns += (long)nums[id];\\n            }\\n        }\\n        return dp[id][prevParity]=currAns;\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][3];\\n        for(long[] t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        return help(0,2,nums,n,x,dp);\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Mostly because even though you have memoized, for each index you are looping through all the greater indices so in total O(n^2) calls are being made. You arent calculating it n^2 times rather just calling it that many times. Try to fix it by using the standard skip/take method instead of looping through the greater indices for each index"
                    },
                    {
                        "username": "Tejasvi_Bajaj",
                        "content": "parities loml"
                    },
                    {
                        "username": "w7089",
                        "content": "Is there a way to optimize the below code using memoization for instance? It works for small inputs only:\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @cache\\n        def pnlty(a,b):\\n            if (a % 2 == 0 and b % 2 == 0) or (a % 2 != 0 and b % 2 != 0):\\n                return 0\\n            return -x\\n\\n        n = len(nums)\\n        res = [0] * n\\n        res[0] = nums[0]\\n        for i in range(1,n):\\n            res[i] = max([res[j] + nums[i] + pnlty(nums[i],nums[j]) for j in range(i) ])\\n        return max(res)\\n```"
                    },
                    {
                        "username": "chiruu453",
                        "content": "i tried to solve this question without dp . my code has passed 160 cases and then ans obtained was different \\ncan anyone help me to find whats wrong in my code.\\nhere is my code.\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev=0;int next=1;long long int ans=nums[0];\\n        while(next<nums.size()){\\n            if(nums[prev]%2==nums[next]%2){\\n                ans=ans+nums[next];\\n                prev=next;\\n                next++;\\n            }\\n            else{\\n                if(nums[next]<=x){\\n                    next++;\\n                }\\n                else{\\n                    int maxi=0;\\n                    prev++;\\n                    for(prev;prev<next;prev++){\\n                        maxi=max(maxi,nums[prev]);\\n                    }\\n                    ans=ans+maxi+nums[next]-x;\\n                    prev=next;\\n                    next++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1981652,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I think this problem could use better description, seriously they are using the word `parity` . Anyone in computer science can think  `If the total number of set-bits in the binary representation of a number is even then the number is said to have even parity, otherwise, it will have odd parity.`  But here they simply meant even or odd. I wasted so much time in contest trying to figure out what just parity was, and couldn\\'t solve it. It\\'s unfair."
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "I also, thanks\\n"
                    },
                    {
                        "username": "1032200230",
                        "content": "I understood after reading your comment!"
                    },
                    {
                        "username": "willydlw",
                        "content": "Agreed! They need to distinguish between mathematical parity (whether an integer is odd or even) and computer science parity ( number of bits that are set to 1). "
                    },
                    {
                        "username": "nathannaveen",
                        "content": "Thanks, I didn\\u2019t understand what they meant by \\u201Cparity\\u201D before this comment! "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "WTF is parities."
                    },
                    {
                        "username": "virendras996",
                        "content": "[@ms232gg](/ms232gg) It basically means that, any two numbers can have same parity if and only if both are either even or both are odd. If either one is even/ odd and other being opposite of it, then we can consider that they have different parities."
                    },
                    {
                        "username": "ms232gg",
                        "content": "243 solutions but no one has answered this yet. People just hungry for upvotes rather than actually helping"
                    },
                    {
                        "username": "ShubhitT",
                        "content": "They should have defined what a parity means. @leetcode, please take a note of this and resolve the statement. People reviewing this question before this was up for the contest should re-evaluate their reviewing strategies. "
                    },
                    {
                        "username": "bcs_abhisekh",
                        "content": "This Note section of this question make it easier. \nThink about the case when nums[0] is not selected initially. This might make it tougher than all other question. \nWell my idea for this case is -\nWhatever the initial category(even or odd) of number is chosen the final chosen number must be last even number or last odd number. So apply the same solution which is applied on this question but starts from last odd  number occurred index and do same for last even occurred number and return the maximum of two.\n\nNote: Feel free to share your opinion and if I am wrong then provide your approach.\n\nHere is the code link for my above approach. \n[Solution](https://leetcode.com/problems/visit-array-positions-to-maximize-score/submissions/1001023126/)"
                    },
                    {
                        "username": "onishiro",
                        "content": "# Q. Why my version of code is getting TLE after running 722 test cases.\\n```\\nclass Solution {\\n    private long help(int id, int prevParity, int[] nums,int n,int x,long[][] dp){\\n        if(id>=n){\\n            return 0;\\n        }\\n        if( dp[id][prevParity]!=-1) return dp[id][prevParity];\\n        int parity = nums[id]%2; //0- evn, 1-odd\\n        long currAns = 0;\\n        for(int i=id+1;i<n;i++){\\n            currAns = Math.max(currAns, help(i,parity,nums,n,x,dp));\\n        }\\n        if(prevParity==2){\\n            currAns += (long)nums[id];\\n        }else{\\n            if(prevParity!=(nums[id]&1)){\\n                currAns += (long)nums[id]-x;\\n            }else{\\n                currAns += (long)nums[id];\\n            }\\n        }\\n        return dp[id][prevParity]=currAns;\\n    }\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] dp = new long[n][3];\\n        for(long[] t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        return help(0,2,nums,n,x,dp);\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Mostly because even though you have memoized, for each index you are looping through all the greater indices so in total O(n^2) calls are being made. You arent calculating it n^2 times rather just calling it that many times. Try to fix it by using the standard skip/take method instead of looping through the greater indices for each index"
                    },
                    {
                        "username": "Tejasvi_Bajaj",
                        "content": "parities loml"
                    },
                    {
                        "username": "w7089",
                        "content": "Is there a way to optimize the below code using memoization for instance? It works for small inputs only:\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int], x: int) -> int:\\n        @cache\\n        def pnlty(a,b):\\n            if (a % 2 == 0 and b % 2 == 0) or (a % 2 != 0 and b % 2 != 0):\\n                return 0\\n            return -x\\n\\n        n = len(nums)\\n        res = [0] * n\\n        res[0] = nums[0]\\n        for i in range(1,n):\\n            res[i] = max([res[j] + nums[i] + pnlty(nums[i],nums[j]) for j in range(i) ])\\n        return max(res)\\n```"
                    },
                    {
                        "username": "chiruu453",
                        "content": "i tried to solve this question without dp . my code has passed 160 cases and then ans obtained was different \\ncan anyone help me to find whats wrong in my code.\\nhere is my code.\\n\\nclass Solution {\\npublic:\\n    long long maxScore(vector<int>& nums, int x) {\\n        int prev=0;int next=1;long long int ans=nums[0];\\n        while(next<nums.size()){\\n            if(nums[prev]%2==nums[next]%2){\\n                ans=ans+nums[next];\\n                prev=next;\\n                next++;\\n            }\\n            else{\\n                if(nums[next]<=x){\\n                    next++;\\n                }\\n                else{\\n                    int maxi=0;\\n                    prev++;\\n                    for(prev;prev<next;prev++){\\n                        maxi=max(maxi,nums[prev]);\\n                    }\\n                    ans=ans+maxi+nums[next]-x;\\n                    prev=next;\\n                    next++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]