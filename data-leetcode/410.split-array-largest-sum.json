[
    {
        "title": "Split Array Largest Sum",
        "question_content": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\nReturn the minimized largest sum of the split.\nA subarray is a contiguous part of the array.\n&nbsp;\nExample 1:\n\nInput: nums = [7,2,5,10,8], k = 2\nOutput: 18\nExplanation: There are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5], k = 2\nOutput: 9\nExplanation: There are four ways to split nums into two subarrays.\nThe best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t0 <= nums[i] <= 106\n\t1 <= k <= min(50, nums.length)",
        "solutions": [
            {
                "id": 1899947,
                "title": "c-simple-code-easy-to-understand-tc-o-n-log-sum-nums-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n\\nFollow me on Github for Daily Leetcode Solution: [https://github.com/anant0059]()\\n\\n```\\n\\tint splitArray(vector<int>& nums, int m) {\\n        int l=0,r=0,n=nums.size();\\n        for(int i=0;i<n;++i) l=max(l,nums[i]), r+=nums[i];\\n        \\n        int mid=0,ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0,tempsum=0;\\n            for(int i=0;i<n;++i){\\n                if(tempsum+nums[i]<=mid) tempsum+=nums[i];\\n                else count++,tempsum=nums[i];\\n            }\\n            count++; \\n            \\n            if(count<=m) r=mid-1, ans=mid;\\n            else l=mid+1;\\n        }  \\n        return ans;\\n    }\\n```\\nThe [**1011. Capacity To Ship Packages Within D Days**](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/) is also the same question just it is a task to figureout this is the same question. And this question can be used as sample question, this concept are used in different questions.\\n\\nThe below two question is also similar:\\n[**2064. Minimized Maximum of Products Distributed to Any Store**](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/) - [Solution](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/1900037/C%2B%2B-oror-Easy-to-Understand-ororTC%3A-O(-m*log(-max(quantities)-)-SC%3A-O(-1-))\\n[**875. Koko Eating Bananas**](https://leetcode.com/problems/koko-eating-bananas/) - [Solution](https://leetcode.com/problems/koko-eating-bananas/discuss/1900110/C%2B%2B-oror-Easy-to-Understand-ororTC%3A-O(-m*log(-max(piles)-)-SC%3A-O(-1-))\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\tint splitArray(vector<int>& nums, int m) {\\n        int l=0,r=0,n=nums.size();\\n        for(int i=0;i<n;++i) l=max(l,nums[i]), r+=nums[i];\\n        \\n        int mid=0,ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0,tempsum=0;\\n            for(int i=0;i<n;++i){\\n                if(tempsum+nums[i]<=mid) tempsum+=nums[i];\\n                else count++,tempsum=nums[i];\\n            }\\n            count++; \\n            \\n            if(count<=m) r=mid-1, ans=mid;\\n            else l=mid+1;\\n        }  \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899144,
                "title": "python-clean-code-parametric-search",
                "content": "``` python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        lo, hi = max(nums), sum(nums)\\n        while lo < hi:\\n            mid = (lo+hi)//2\\n            tot, cnt = 0, 1\\n            for num in nums:\\n                if tot+num<=mid: \\n                    tot += num\\n                else:\\n                    tot = num\\n                    cnt += 1\\n            if cnt>m: lo = mid+1\\n            else: hi = mid\\n        return hi\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "``` python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        lo, hi = max(nums), sum(nums)\\n        while lo < hi:\\n            mid = (lo+hi)//2\\n            tot, cnt = 0, 1\\n            for num in nums:\\n                if tot+num<=mid: \\n                    tot += num\\n                else:\\n                    tot = num\\n                    cnt += 1\\n            if cnt>m: lo = mid+1\\n            else: hi = mid\\n        return hi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899033,
                "title": "java-simple-and-easy-solution-beats-100",
                "content": "```\\nclass Solution {\\n    int[] nums;\\n    public int splitArray(int[] nums, int m) {\\n        this.nums = nums;\\n        int low = 0, high = 0, min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            low = Math.max(low, nums[i]);\\n            high += nums[i];\\n        }\\n        while(low <= high) {\\n            int mid = (low + high) / 2;\\n            if(required_no_of_chunks(mid, m)){\\n               min = Math.min(min, mid);\\n               high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return min;\\n    }\\n    \\n    private boolean required_no_of_chunks(int mid, int m){\\n        int chunks = 0, i=0;\\n        while(i < nums.length){\\n            int val = 0;\\n            while(i < nums.length && nums[i] + val <= mid) val += nums[i++];\\n            chunks++;\\n        }\\n        return chunks <= m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    public int splitArray(int[] nums, int m) {\\n        this.nums = nums;\\n        int low = 0, high = 0, min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            low = Math.max(low, nums[i]);\\n            high += nums[i];\\n        }\\n        while(low <= high) {\\n            int mid = (low + high) / 2;\\n            if(required_no_of_chunks(mid, m)){\\n               min = Math.min(min, mid);\\n               high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return min;\\n    }\\n    \\n    private boolean required_no_of_chunks(int mid, int m){\\n        int chunks = 0, i=0;\\n        while(i < nums.length){\\n            int val = 0;\\n            while(i < nums.length && nums[i] + val <= mid) val += nums[i++];\\n            chunks++;\\n        }\\n        return chunks <= m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89817,
                "title": "clear-explanation-8ms-binary-search-java",
                "content": "1. The answer is between maximum value of input array numbers and sum of those numbers.\\n2. Use binary search to approach the correct answer. We have ``` l = max number of array; r = sum of all numbers in the array;```Every time we do ```mid = (l + r) / 2;```\\n3. Use greedy to narrow down left and right boundaries in binary search.\\n    3.1 Cut the array from left.\\n    3.2 Try our best to make sure that the sum of numbers between each two cuts (inclusive) is large enough but still less than ```mid```.\\n   3.3 We'll end up with two results: either we can divide the array into more than m subarrays or we cannot.\\n         **If we can**, it means that the ```mid ``` value we pick is too small because we've already tried our best to make sure each part holds as many non-negative numbers as we can but we still have numbers left. So, it is impossible to cut the array into m parts and make sure each parts is no larger than ```mid```. We should increase m. This leads to ```l = mid + 1;```\\n        **If we can't**, it is either we successfully divide the array into m parts and the sum of each part is less than ```mid```, or we used up all numbers before we reach m. Both of them mean that we should lower ```mid``` because we need to find the minimum one. This leads to ```r = mid - 1;```\\n```\\npublic class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int max = 0; long sum = 0;\\n        for (int num : nums) {\\n            max = Math.max(num, max);\\n            sum += num;\\n        }\\n        if (m == 1) return (int)sum;\\n        //binary search\\n        long l = max; long r = sum;\\n        while (l <= r) {\\n            long mid = (l + r)/ 2;\\n            if (valid(mid, nums, m)) {\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return (int)l;\\n    }\\n    public boolean valid(long target, int[] nums, int m) {\\n        int count = 1;\\n        long total = 0;\\n        for(int num : nums) {\\n            total += num;\\n            if (total > target) {\\n                total = num;\\n                count++;\\n                if (count > m) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n* list item",
                "solutionTags": [],
                "code": "``` l = max number of array; r = sum of all numbers in the array;```\n```mid = (l + r) / 2;```\n```mid```\n```mid ```\n```mid```\n```l = mid + 1;```\n```mid```\n```mid```\n```r = mid - 1;```\n```\\npublic class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int max = 0; long sum = 0;\\n        for (int num : nums) {\\n            max = Math.max(num, max);\\n            sum += num;\\n        }\\n        if (m == 1) return (int)sum;\\n        //binary search\\n        long l = max; long r = sum;\\n        while (l <= r) {\\n            long mid = (l + r)/ 2;\\n            if (valid(mid, nums, m)) {\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return (int)l;\\n    }\\n    public boolean valid(long target, int[] nums, int m) {\\n        int count = 1;\\n        long total = 0;\\n        for(int num : nums) {\\n            total += num;\\n            if (total > target) {\\n                total = num;\\n                count++;\\n                if (count > m) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89819,
                "title": "c-fast-very-clear-explanation-clean-code-solution-with-greedy-algorithm-and-binary-search",
                "content": "First thing first, below is the code:\\n```\\nclass Solution {\\nprivate:\\n    bool doable (const vector<int>& nums, int cuts, long long max) {\\n        int acc = 0;\\n        for (num : nums) {\\n            // This step is unnecessary for this problem. I didn't discard this line because I want doable function more generalized.\\n            if (num > max) return false;\\n            else if (acc + num <= max) acc += num;\\n            else {\\n                --cuts;\\n                acc = num;\\n                if (cuts < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        long long left = 0, right = 0;\\n        for (num : nums) {\\n            left = max(left, (long long)num);\\n            right += num;\\n        }\\n        \\n        while (left < right) {\\n            long long mid = left + (right - left) / 2;\\n            if (doable(nums, m - 1, mid)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\\n---------------\\nIntroduction to this problem:\\n---------------\\n\\nWe can break this problem into two smaller problems:\\n* Given an array (*A*), number of cuts (*CUTS*), and the **Largest sum of sub-arrays** (*MAX*). **Can you use at most *CUTS* cuts to segment array *A* into *CUTS + 1* sub-arrays, such that the sum of each sub-array is smaller or equal to *MAX***?\\n* Given a lower bound (*left*), an upper bound (*right*), an unknown bool array (*B*), and an API uses *i* as input and tells you whether *B[i]* is true. If we know there exists an index *k*, **that *B[i]* is false when i < k, and *B[i]* is true when i >= k**. What is the fastest way to **find this *k* (the lower bound)?**\\n-------------\\nSolution to the first sub-problem (Skip this part if you already knew how to solve 1st sub-problem):\\n-------------\\nFor the first question, we can follow these steps:\\n* For each element in the array, if its value is larger than *MAX*, we know it's not possible to cut this array into groups that the sum of all groups are smaller than *MAX*. (Reason is straightforward, if *A* is [10, 2, 3, 5] and *MAX* is 6, even you have 3 cuts by which you can cut *A* as [[10], [2], [3], [5]], the group containing 10 will still be larger than 6).\\n* Use **greedy algorithm** to cut *A*. Use an **accumulator *ACC*** to store the sum of the currently processed group, and process elements in *A* one by one. For each element *num*, if we add *num* with *ACC* and the new sum is still no larger than *MAX*, we **update *ACC* to *ACC + num***, which means we can **merge *num* into the current group**. If not, we must **use a cut before *num* to segment this array**, then *num* will be the first element in the new group.\\n* If we **didn't go through *A* but already used up all cuts**, then it's not possible only using *CUTS* cuts to segment this array into groups to make sure **sum of each sub-array** is smaller than *MAX*. Otherwise, if we can reach the end of *A* with cuts left (or use exactly *CUTS* cuts). It's possible to do so.\\n\\nThen the first question is solved.\\n\\nSolution to the second sub-problem(Skip this part if you already knew how to solve 2nd sub-problem):\\n-------------\\n* The array *B* will be something like [false, false, ..., false, true, true, ..., true]. We want to find **the index of the first true**.\\n* Use **binary search** to find this *k*. Keep a value *mid*, **mid = (left + right) / 2**. If B[mid] = false, then move the search range to the upper half of the original search range, a.k.a **left = mid + 1**, otherwise move search range to the lower half, a.k.a **right = mid**. \\n--------------\\nWhy this algorithm is correct...\\n--------------\\n* No matter how we cut the array *A*, the **Largest sum of sub-arrays** will fall into a range [left, right]. ***Left* is the value of the largest element in this array. *right* is the sum of this array.** (e.g., Given array [1, 2, 3, 4, 5], if we have 4 cuts and cut it as [[1], [2], [3], [4], [5]], the **Largest sum of sub-arrays** is 5, it cannot be smaller. And if we have 0 cut, and the only sub-array is [[1, 2, 3, 4, 5]], the **Largest sum of sub-arrays** is 15, it cannot be larger).\\n* However, we cannot decide the number of cuts (*CUTS*), this is an given constraint. But we know there must be a magic number *k*, which is the smallest value of the **Largest sum of sub-arrays** when given *CUTS* cuts. When the **Largest sum of sub-arrays** is larger than *k*, we can always find a way to cut *A* within *CUTS* cuts. When the **Largest sum of sub-arrays** is smaller than *k*, there is no way to do this.\\n\\nExample\\n------\\nFor example, given array *A* **[1, 2, 3, 4, 5]**. We can use **2** cuts.\\n* No matter how many cuts are allowed, the range of the possible value of the **Largest sum of sub-arrays** is [5, 15].\\n* When given 2 cuts, we can tell the magic number *k* here is 6, the result of segmentation is [[1, 2, 3], [4], [5]].\\n* When **Largest sum of sub-arrays** is in range [6, 15], we can always find a way to cut this array within two cuts. You can have a try.\\n* However, when **Largest sum of sub-arrays** is in range [5, 5], there is no way to do this.\\n* This mapped this problem into the second sub-problem. Bool array *B* here is [5:false, 6:true, 7:true, 8:true, ..., 15:true]. We want to find the **index *i* of the first true in *B*, which is the answer of this entire question**, and by solving the first sub-problem, we have an API that can tell us **given an *i* (*Largest sum of sub-arrays*), whether *B[i]* is true (whether we can find a way to cut *A* to satisfy the constraint)**.\\n\\n**Below is the code with comment, just in case you don't have time to read the explanations above.**\\n```\\nclass Solution {\\nprivate:\\n    /* \\n        Params:\\n            nums - The input array; \\n            cuts - How many cuts are available (cuts = #groups - 1); \\n            max - The maximum of the (sum of elements in one group);\\n        Rtn:\\n            Whether we can use at most 'cuts' number of cuts to segment the entire array, \\n            such that the sum of each group will not exceed 'max'.\\n     */\\n    bool doable (const vector<int>& nums, int cuts, long long max) {\\n        \\n        // 'acc' is the temporary accumulator for the currently processed group.\\n        \\n        int acc = 0;\\n        for (num : nums) {\\n            \\n            // If the current processed element in this array is larger than 'max', we cannot segment the array.\\n            // (Reason is straightforward, if 'nums' is [10, 2, 3, 5] and 'max' is 6, even you can have 3 cuts\\n            // (by which you can cut array as [[10], [2], [3], [5]]), the group containing 10 will be larger than 6, \\n            //  there is no way to do this).\\n            // Ps: This step is unnecessary in this solution. Because 'left' in the splitArray() function can assure \\n            // 'max' will be larger than every single element. I just want to write a generalized doable() function :)\\n            \\n            if (num > max) return false;\\n            \\n            // If the (sum of the currently processed group) + (current element) is smaller than max, we can add current \\n            // element into this group.\\n            \\n            else if (acc + num <= max) acc += num;\\n            \\n            // If not, we will make a cut before this element, and this element will be the first element in the new group.\\n            \\n            else {\\n                --cuts;\\n                acc = num;\\n                \\n                // If we've used up all cuts, this means this 'max' is not doable.\\n                if (cuts < 0) return false;\\n            }\\n        }\\n        \\n        // If we can reach here, this means we've used at most 'cuts' cut to segment the array, and the sum of each groups is\\n        // not larger than 'max'. Yeah!\\n        return true;\\n    }\\n    \\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        // Use long long to avoid overflow.\\n        long long left = 0, right = 0;\\n        // The smallest possible value ('left') is the the value of the largest element in this array.\\n        // The largest possible value ('right') is the sum of all elements in this array.\\n        for (num : nums) {\\n            left = max(left, (long long)num);\\n            right += num;\\n        }\\n        \\n        // Use binary search, find the lower bound of the possible (minimum sum of groups within m - 1 cuts).\\n        while (left < right) {\\n            long long mid = left + (right - left) / 2;\\n            if (doable(nums, m - 1, mid)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool doable (const vector<int>& nums, int cuts, long long max) {\\n        int acc = 0;\\n        for (num : nums) {\\n            // This step is unnecessary for this problem. I didn't discard this line because I want doable function more generalized.\\n            if (num > max) return false;\\n            else if (acc + num <= max) acc += num;\\n            else {\\n                --cuts;\\n                acc = num;\\n                if (cuts < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        long long left = 0, right = 0;\\n        for (num : nums) {\\n            left = max(left, (long long)num);\\n            right += num;\\n        }\\n        \\n        while (left < right) {\\n            long long mid = left + (right - left) / 2;\\n            if (doable(nums, m - 1, mid)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    /* \\n        Params:\\n            nums - The input array; \\n            cuts - How many cuts are available (cuts = #groups - 1); \\n            max - The maximum of the (sum of elements in one group);\\n        Rtn:\\n            Whether we can use at most 'cuts' number of cuts to segment the entire array, \\n            such that the sum of each group will not exceed 'max'.\\n     */\\n    bool doable (const vector<int>& nums, int cuts, long long max) {\\n        \\n        // 'acc' is the temporary accumulator for the currently processed group.\\n        \\n        int acc = 0;\\n        for (num : nums) {\\n            \\n            // If the current processed element in this array is larger than 'max', we cannot segment the array.\\n            // (Reason is straightforward, if 'nums' is [10, 2, 3, 5] and 'max' is 6, even you can have 3 cuts\\n            // (by which you can cut array as [[10], [2], [3], [5]]), the group containing 10 will be larger than 6, \\n            //  there is no way to do this).\\n            // Ps: This step is unnecessary in this solution. Because 'left' in the splitArray() function can assure \\n            // 'max' will be larger than every single element. I just want to write a generalized doable() function :)\\n            \\n            if (num > max) return false;\\n            \\n            // If the (sum of the currently processed group) + (current element) is smaller than max, we can add current \\n            // element into this group.\\n            \\n            else if (acc + num <= max) acc += num;\\n            \\n            // If not, we will make a cut before this element, and this element will be the first element in the new group.\\n            \\n            else {\\n                --cuts;\\n                acc = num;\\n                \\n                // If we've used up all cuts, this means this 'max' is not doable.\\n                if (cuts < 0) return false;\\n            }\\n        }\\n        \\n        // If we can reach here, this means we've used at most 'cuts' cut to segment the array, and the sum of each groups is\\n        // not larger than 'max'. Yeah!\\n        return true;\\n    }\\n    \\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        // Use long long to avoid overflow.\\n        long long left = 0, right = 0;\\n        // The smallest possible value ('left') is the the value of the largest element in this array.\\n        // The largest possible value ('right') is the sum of all elements in this array.\\n        for (num : nums) {\\n            left = max(left, (long long)num);\\n            right += num;\\n        }\\n        \\n        // Use binary search, find the lower bound of the possible (minimum sum of groups within m - 1 cuts).\\n        while (left < right) {\\n            long long mid = left + (right - left) / 2;\\n            if (doable(nums, m - 1, mid)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161143,
                "title": "logical-thinking-with-code-beats-99-89",
                "content": "**Logical Thinking**\\n\\nGiven **searching range** and a **target** value, it is natural to apply **Binary Search**. \\n**Searching range** is influenced by given `m`: \\n`minVal` - maximum element of nums\\n`maxVal` - sum of elements of nums (when `m = 1`)\\n**Target**: `min(largest subarray sum)`, the minimum possible value that satisfies the requirement.\\n\\nPlease note that when current `mid` enable `canSplit(mid, nums, m)` to be `true`, largest subarray sum `mid` can satisfy the requirement. Since we aim to find the minimum possible one that satisfies the requirement, we set the upper bound `maxVal = mid` and go on searching. That\\'s the same as **Lower-bound Binary Search** with template as below:\\n```\\n    public int bSLowerBound(int[] nums, int target) {\\n\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int mi = lo + (hi - lo) / 2;\\n            if (nums[mi] >= target) { // that matters\\n                hi = mi;\\n            } else {\\n                lo = mi + 1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n```\\n\\n**Clear Code**\\n\\n```\\n    public int splitArray(int[] nums, int m) {\\n\\n        int minVal = Integer.MIN_VALUE, maxVal = 0;\\n        for (int num : nums) {\\n            minVal = Math.max(minVal, num);\\n            maxVal += num;\\n        }\\n\\n        while (minVal < maxVal) {\\n            int mid = minVal + (maxVal - minVal) / 2;\\n            if (canSplit(mid, nums, m)) {\\n                maxVal = mid;\\n            } else {\\n                minVal = mid + 1;\\n            }\\n        }\\n\\n        return minVal;\\n    }\\n\\n    private boolean canSplit(int upperBoundSubarraySum, int[] nums, int m) {\\n\\n        int curSubarraySum = 0, cntSubarray = 1;\\n        for (int num : nums) {\\n            curSubarraySum += num;\\n            if (curSubarraySum > upperBoundSubarraySum) {\\n                cntSubarray++;\\n                curSubarraySum = num;\\n                if (cntSubarray > m) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    public int bSLowerBound(int[] nums, int target) {\\n\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int mi = lo + (hi - lo) / 2;\\n            if (nums[mi] >= target) { // that matters\\n                hi = mi;\\n            } else {\\n                lo = mi + 1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n```\n```\\n    public int splitArray(int[] nums, int m) {\\n\\n        int minVal = Integer.MIN_VALUE, maxVal = 0;\\n        for (int num : nums) {\\n            minVal = Math.max(minVal, num);\\n            maxVal += num;\\n        }\\n\\n        while (minVal < maxVal) {\\n            int mid = minVal + (maxVal - minVal) / 2;\\n            if (canSplit(mid, nums, m)) {\\n                maxVal = mid;\\n            } else {\\n                minVal = mid + 1;\\n            }\\n        }\\n\\n        return minVal;\\n    }\\n\\n    private boolean canSplit(int upperBoundSubarraySum, int[] nums, int m) {\\n\\n        int curSubarraySum = 0, cntSubarray = 1;\\n        for (int num : nums) {\\n            curSubarraySum += num;\\n            if (curSubarraySum > upperBoundSubarraySum) {\\n                cntSubarray++;\\n                curSubarraySum = num;\\n                if (cntSubarray > m) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 89846,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Split Array Largest Sum** https://leetcode.com/problems/split-array-largest-sum/\\n\\n**BruteForce**\\n```\\nclass Solution(object):\\n    def helper(self, nums, m):\\n        if nums == []:\\n            return 0\\n        elif m == 1:\\n            return sum(nums)\\n        else:\\n            min_result = float('inf')\\n            for j in range(1,len(nums)+1):\\n                left, right = sum(nums[:j]), self.helper(nums[j:], m-1)\\n                min_result = min(min_result, max(left, right))\\n            return min_result\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        return self.helper(nums, m)\\n```\\n\\n**Memoization**\\n```\\nfrom collections import defaultdict    \\nclass Solution(object):\\n    def helper(self, i, nums, m, cache):\\n        if i == len(nums):\\n            return 0\\n        elif m == 1:\\n            return sum(nums[i:])\\n        else:\\n            if i in cache and m in cache[i]:\\n                return cache[i][m]\\n            cache[i][m] = float('inf')\\n            for j in xrange(1,len(nums)+1):\\n                left, right = sum(nums[i:i+j]), self.helper(i+j, nums, m-1, cache)\\n                cache[i][m] = min(cache[i][m], max(left, right))\\n                if left > right:\\n                    break\\n            return cache[i][m]\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(dict)\\n        return self.helper(0, nums, m, cache)\\n```\\n\\n**Memoization + Cumulative Sum**\\n```\\nfrom collections import defaultdict            \\nclass Solution(object):\\n    def helper(self, i, nums, m, cache, cums):\\n        if i == len(nums):\\n            return 0\\n        elif m == 1:\\n            return sum(nums[i:])\\n        else:\\n            if i in cache and m in cache[i]:\\n                return cache[i][m]\\n            cache[i][m] = float('inf')\\n            for j in range(1,len(nums)+1):\\n                left, right = cums[i+j] - cums[i], self.helper(i+j, nums, m-1, cache, cums)\\n                cache[i][m] = min(cache[i][m], max(left, right))\\n                if left > right:\\n                    break\\n            return cache[i][m]\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        cums = [0]\\n        for x in nums:\\n            cums.append(cums[-1]+x)\\n        cache = defaultdict(dict)            \\n        return self.helper(0, nums, m, cache, cums)\\n```\\n\\n**Binary Search Based Solution**\\n* Imagine we split an array into m different sub-arrays. There can be several ways to do this split. Let us assume we take one possible split.\\n* In this particular split, we take the sum of each subarray j and call it S(j) where j is from 1 to m. Then we figure out the sub-array which has the maximum sum from all of these m different sums and call it max_sum(array, m). \\n* What is the least possible value of max_sum(array, m)? Answer will be max(array) - this must be obvious. The max(array) value must be in one of the m sub-arrays. The least possible amongst all possible m different sub-arrays would be a sub-array with a single element as the max(array).\\n* What is the maximum possible value of max_sum(array, m)? Answer will be sum(array) - a subarray with all elements.\\n* So the range of max_sum(array, m) is max(array) to sum(array).\\n* We now have a search problem - we need to search within the range max(array) to sum(array) such that  we find the minimum value in this range with which we can form at-most m sub-arrays such no sub-array has sum more than this value. To efficiently search a sorted range we use binary search.\\n* Imagine we pick a value mid and find that we could make more sub-arrays than m. This means we picked too small value (check the code to understand this). We should set low = mid + 1.\\n* Imagine we pick a value mid and find we could make less sub-arrays than m. Now we can easily split those sub-arrays to increase the count and still make sure that the maximum sum of those sub-arrays is less than mid (splitting will only decrease mid). In this case, we record a potential solution and make high = mid-1, hoping to get an even better solution later.\\n* Lets use an example: [7,2,5,10,8] and 2\\n* max_sum([7,2,5,10,8], 2) will be in the range [10, 32] - i.e. any split of the array into 2 sub-array will have sum of the sub-array between [10, 32].\\n* Now we want to find the minimum value in this range with which we can form 2 sub-arrays. Lets do this linearly. Can we use 10? Using 10, we can form [7, 2]; [5]; [10]; [8] - 4 subarrays. We clearly need to increase the minimum value so that we can reduce from 4 subarrays. \\n* What if we used binary search and started with mid = (10+32)/2 = 21. This gives us [7,2,5]; [10,8] - This is valid solution. Can we do better? We record 21 and reduce our range to [10, 20].\\n* This gives us mid as 15. [7,2,5]; [10]; [8] - Invalid! we got more than 2 sub-arrays. We need to increase low to mid+1 and search in the range [16, 20].\\n* [16, 20] gives us 18. [7,2,5]; [10,8] - This is a valid solution. Can we do better than 18? Let us search in the range [16,17]\\n* [16,17] gives mid as 16. [7,2,5]; [10]; [8]. This is invalid and we need to increase range. New range is [17,17]. This again gives [7,2,5]; [10]; [8] and we get the new range as [18,17].\\n* [18,17] breaks the while loop! We have recorded 18 as the last answer and return it.\\n\\n```\\nclass Solution(object):\\n    def is_valid(self, nums, m, mid):\\n        # assume mid is < max(nums)\\n        cuts, curr_sum  = 0, 0\\n        for x in nums:\\n            curr_sum += x\\n            if curr_sum > mid:\\n                cuts, curr_sum = cuts+1, x\\n        subs = cuts + 1\\n        return (subs <= m)\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        low, high, ans = max(nums), sum(nums), -1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if self.is_valid(nums, m, mid): # can you make at-most m sub-arrays with maximum sum atmost mid \\n                ans, high = mid, mid-1\\n            else:\\n                low = mid + 1\\n        return ans\\n```\\n\\nhttps://discuss.leetcode.com/topic/61395/c-fast-very-clear-explanation-clean-code-solution-with-greedy-algorithm-and-binary-search/2\\nhttps://discuss.leetcode.com/topic/61315/java-easy-binary-search-solution-8ms",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, nums, m):\\n        if nums == []:\\n            return 0\\n        elif m == 1:\\n            return sum(nums)\\n        else:\\n            min_result = float('inf')\\n            for j in range(1,len(nums)+1):\\n                left, right = sum(nums[:j]), self.helper(nums[j:], m-1)\\n                min_result = min(min_result, max(left, right))\\n            return min_result\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        return self.helper(nums, m)\\n```\n```\\nfrom collections import defaultdict    \\nclass Solution(object):\\n    def helper(self, i, nums, m, cache):\\n        if i == len(nums):\\n            return 0\\n        elif m == 1:\\n            return sum(nums[i:])\\n        else:\\n            if i in cache and m in cache[i]:\\n                return cache[i][m]\\n            cache[i][m] = float('inf')\\n            for j in xrange(1,len(nums)+1):\\n                left, right = sum(nums[i:i+j]), self.helper(i+j, nums, m-1, cache)\\n                cache[i][m] = min(cache[i][m], max(left, right))\\n                if left > right:\\n                    break\\n            return cache[i][m]\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(dict)\\n        return self.helper(0, nums, m, cache)\\n```\n```\\nfrom collections import defaultdict            \\nclass Solution(object):\\n    def helper(self, i, nums, m, cache, cums):\\n        if i == len(nums):\\n            return 0\\n        elif m == 1:\\n            return sum(nums[i:])\\n        else:\\n            if i in cache and m in cache[i]:\\n                return cache[i][m]\\n            cache[i][m] = float('inf')\\n            for j in range(1,len(nums)+1):\\n                left, right = cums[i+j] - cums[i], self.helper(i+j, nums, m-1, cache, cums)\\n                cache[i][m] = min(cache[i][m], max(left, right))\\n                if left > right:\\n                    break\\n            return cache[i][m]\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        cums = [0]\\n        for x in nums:\\n            cums.append(cums[-1]+x)\\n        cache = defaultdict(dict)            \\n        return self.helper(0, nums, m, cache, cums)\\n```\n```\\nclass Solution(object):\\n    def is_valid(self, nums, m, mid):\\n        # assume mid is < max(nums)\\n        cuts, curr_sum  = 0, 0\\n        for x in nums:\\n            curr_sum += x\\n            if curr_sum > mid:\\n                cuts, curr_sum = cuts+1, x\\n        subs = cuts + 1\\n        return (subs <= m)\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        low, high, ans = max(nums), sum(nums), -1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if self.is_valid(nums, m, mid): # can you make at-most m sub-arrays with maximum sum atmost mid \\n                ans, high = mid, mid-1\\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373306,
                "title": "python3-binarysearch-accepted-and-well-documented-solution",
                "content": "Wrote mainly for my understanding, thought it might help someone else:\\n\\n```\\n\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        # First, understand WHAT we are binary searching over\\n        # we are doing a binary search over the *search space of possible results*\\n        # What is the search space, aka what are all possible results?\\n        # For this, we need to know the minimum and maximum possible result\\n        ## minimum possible result - largest element in array. Since each element needs \\n        # to be part of some subarray, the smallest we can go is by taking the largest element\\n        # in a subarray by itself\\n        ## maximum possible result - sum of all elements in the array since we cannot form\\n        # a subarray larger than the array itself\\n        # Compute minResult and maxResult boundaries\\n        minResult, maxResult = 0,0\\n        for num in nums:\\n            maxResult += num\\n            if num > minResult:\\n                minResult = num\\n        \\n        # now that we have our minResult and maxResult boundaries, we can begin searching within this space\\n        # What are we searching for?\\n        # The smallest value within this space such that we can form m subarrays from nums and none of their sums exceed that value\\n        finalResult = float(\\'inf\\')\\n        while minResult <= maxResult:\\n            # Start by checking if the value in the middle of the search space satisfies this desired outcome\\n            # If it does, we can discard all values to the right of this in our search space since we have\\n\\t\\t\\t# something better than those already. We only need to search values to the left to see if \\n\\t\\t\\t# we can find something better\\n            # If not, we only need to search values higher than mid\\n            mid = (minResult + maxResult) // 2\\n            if self.isPossibility(mid, nums, m):\\n                finalResult = mid\\n                maxResult = mid-1\\n            else:\\n                minResult = mid+1\\n        return finalResult\\n    \\n    # Checks to see if x is a valid possibility given the constraint of m subarrays\\n    def isPossibility(self, x, nums, m):\\n        numSubarrays = 1\\n        subarraySum = 0\\n        for num in nums:\\n            # Greedily try to add this element to the current subarray as long as the subarray\\'s sum doesn\\'t exceed our upper limit x\\n            if (num + subarraySum) <= x:\\n                subarraySum += num\\n            # If sum would be exceeded by adding the current element, we need to start a new subarray and put this element into that\\n            else:\\n                numSubarrays += 1\\n                subarraySum = num\\n        \\n        return (numSubarrays <= m)\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        # First, understand WHAT we are binary searching over\\n        # we are doing a binary search over the *search space of possible results*\\n        # What is the search space, aka what are all possible results?\\n        # For this, we need to know the minimum and maximum possible result\\n        ## minimum possible result - largest element in array. Since each element needs \\n        # to be part of some subarray, the smallest we can go is by taking the largest element\\n        # in a subarray by itself\\n        ## maximum possible result - sum of all elements in the array since we cannot form\\n        # a subarray larger than the array itself\\n        # Compute minResult and maxResult boundaries\\n        minResult, maxResult = 0,0\\n        for num in nums:\\n            maxResult += num\\n            if num > minResult:\\n                minResult = num\\n        \\n        # now that we have our minResult and maxResult boundaries, we can begin searching within this space\\n        # What are we searching for?\\n        # The smallest value within this space such that we can form m subarrays from nums and none of their sums exceed that value\\n        finalResult = float(\\'inf\\')\\n        while minResult <= maxResult:\\n            # Start by checking if the value in the middle of the search space satisfies this desired outcome\\n            # If it does, we can discard all values to the right of this in our search space since we have\\n\\t\\t\\t# something better than those already. We only need to search values to the left to see if \\n\\t\\t\\t# we can find something better\\n            # If not, we only need to search values higher than mid\\n            mid = (minResult + maxResult) // 2\\n            if self.isPossibility(mid, nums, m):\\n                finalResult = mid\\n                maxResult = mid-1\\n            else:\\n                minResult = mid+1\\n        return finalResult\\n    \\n    # Checks to see if x is a valid possibility given the constraint of m subarrays\\n    def isPossibility(self, x, nums, m):\\n        numSubarrays = 1\\n        subarraySum = 0\\n        for num in nums:\\n            # Greedily try to add this element to the current subarray as long as the subarray\\'s sum doesn\\'t exceed our upper limit x\\n            if (num + subarraySum) <= x:\\n                subarraySum += num\\n            # If sum would be exceeded by adding the current element, we need to start a new subarray and put this element into that\\n            else:\\n                numSubarrays += 1\\n                subarraySum = num\\n        \\n        return (numSubarrays <= m)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 769701,
                "title": "python-clear-explanation-powerful-ultimate-binary-search-template-solved-many-problems",
                "content": "First thing first, here is the code:\\n\\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nI have built a powerful generalized binary search template and used it to solve many problems easily. Below is the detailed and clear introduction to this template. I believe it will be worth your time :)\\n\\n****\\n\\n# Intro\\n\\nBinary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). But when it comes to implementation, it\\'s rather difficult to write a bug-free code in just a few minutes. Some of the most common problems include:\\n\\n- When to exit the loop? Should we use `left < right` or `left <= right` as the while loop condition?\\n- How to initialize the boundary variable `left` and `right`?\\n- How to update the boundary? How to choose the appropriate combination from `left = mid `, `left = mid + 1` and  `right = mid`, `right = mid - 1`?\\n\\nA rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like \"Given a sorted array, find a specific value in it\". As a matter of fact, it can be applied to much more complicated situations.\\n\\nAfter a lot of practice in LeetCode, I\\'ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I\\'ll share the template with you guys in this post. I don\\'t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems. Hopefully, after reading this post, people wouldn\\'t be pissed off any more when LeetCoding, \"Holy sh*t! This problem could be solved with binary search! Why didn\\'t I think of that before!\"\\n\\n\\n\\n****\\n\\n\\n\\n# Most Generalized Binary Search\\n\\nSuppose we have a search space. It could be an array, a range, etc. Usually it\\'s sorted in ascend order. For most tasks, we can transform the requirement into the following generalized form:\\n\\n**Minimize k ,    s.t.  condition(k) is True**\\n\\nThe following code is the most generalized binary search template:\\n\\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nWhat\\'s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:\\n\\n- Correctly initialize the boundary variables `left` and `right`. Only one rule: set up the boundary to **include all possible elements**;\\n- Decide return value. Is it `return left` or `return left - 1`? Remember this: **after exiting the while loop, `left` is the minimal k\\u200B satisfying the `condition ` function**;\\n- Design the `condition` function. This is the most difficult and most beautiful part. Needs lots of practice.\\n\\nBelow I\\'ll show you guys how to apply this powerful template to many LeetCode problems.\\n\\n\\n\\n****\\n\\n\\n\\n# Basic Application\\n\\n## [278. First Bad Version [Easy]](https://leetcode.com/problems/first-bad-version/)\\n\\nYou are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API `bool isBadVersion(version)` which will return whether `version` is bad.\\n\\n**Example:**\\n\\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\\n\\nFirst, we initialize `left = 1` and `right = n` to include all possible values. Then we notice that we don\\'t even need to design the `condition` function. It\\'s already given by the `isBadVersion` API. Finding the first bad version is equivalent to finding the minimal k satisfying `isBadVersion(k) is True`. Our template can fit in very nicely:\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n****\\n\\n\\n\\n## [69. Sqrt(x) [Easy]](https://leetcode.com/problems/sqrtx/)\\n\\nImplement `int sqrt(int x)`. Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\\n\\n**Example:**\\n\\n```scala\\nInput: 4\\nOutput: 2\\n```\\n\\n```scala\\nInput: 8\\nOutput: 2\\n```\\n\\nQuite an easy problem. We need to search for maximal k satisfying `k^2 <= x`, so we can easily come up with the solution:\\n\\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\\n\\nThere\\'s one thing I\\'d like to point out. Remember I say that **we usually look for the minimal k value satisfying certain condition**? But in this problem we are searching for maximal k value instead. Feeling confused? Don\\'t be. Actually, the maximal k satisfying `condition(k) is False` is just equal to the minimal k satisfying `condition(k) is True` minus one. This is why I mentioned earlier that we need to decide which value to return, `left` or `left - 1`.\\n\\n\\n\\n****\\n\\n\\n\\n## [35. Search Insert Position [Easy]](https://leetcode.com/problems/search-insert-position/)\\n\\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\\n\\n**Example:**\\n\\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\\n\\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\\n\\nVery classic application of binary search. We are looking for the minimal k value satisfying `nums[k] >= target`, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array `nums` has duplicates. Also notice that the input  `target` might be larger than all elements in `nums` and therefore needs to placed at the end of the array. That\\'s why we should initialize `right = len(nums)` instead of `right = len(nums) - 1`.\\n\\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# Advanced Application\\n\\nThe above problems are quite easy to solve, because they already give us the array to be searched. We\\'d know that we should use binary search to solve them at first glance.  However, more often are the situations where the search space and search target are not so readily available. Sometimes we won\\'t even realize that the problem should be solved with binary search -- we might just turn to dynamic programming or DFS and get stuck for a very long time.\\n\\nAs for the question \"When can we use binary search?\", my answer is that, **If we can discover some kind of monotonicity, for example, if `condition(k) is True` then `condition(k + 1) is True`, then we can consider binary search**.\\n\\n## [1011. Capacity To Ship Packages Within D Days [Medium]](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\ndays. The `i`-th package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. \\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.\\n\\n**Example :**\\n\\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\\n\\nBinary search probably would not come to our mind when we first meet this problem. We might automatically treat `weights` as search space and then realize we\\'ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within `D` days with capacity `m`, then we can definitely ship them all with any capacity larger than `m`. Now we can design a `condition` function, let\\'s call it `feasible`, given an input `capacity`, it returns whether it\\'s possible to ship all packages within `D` days. This can run in a greedy way: if there\\'s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds `D`, we return `False`, otherwise we return `True`.\\n\\nNext, we need to initialize our boundary correctly. Obviously `capacity` should be at least `max(weights)`, otherwise the conveyor belt couldn\\'t ship the heaviest package. On the other hand, `capacity` need not be more than`sum(weights)`, because then we can ship all packages in just one day.\\n\\nNow we\\'ve got all we need to apply our binary search template:\\n\\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [410. Split Array Largest Sum [Hard]](https://leetcode.com/problems/split-array-largest-sum/)\\n\\nGiven an array which consists of non-negative integers and an integer *m*, you can split the array into *m* non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these *m* subarrays.\\n\\n**Example:**\\n\\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\\n\\nIf you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a `feasible` function: given an input `threshold`, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to `threshold`. In this way, we discover the monotonicity of the problem: if `feasible(m)` is `True`, then all inputs larger than `m` can satisfy `feasible` function. You can see that the solution code is exactly the same as LC 1011.\\n\\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nBut we probably would have doubts: It\\'s true that `left` returned by our solution is the minimal value satisfying `feasible`, but how can we know that we can split the original array to **actually get this subarray-sum**? For example, let\\'s say `nums = [7,2,5,10,8]` and `m = 2`. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: `25:[[7], [2,5,10,8]]`, `23:[[7,2], [5,10,8]]`, `18:[[7,2,5], [10,8]]`, `24:[[7,2,5,10], [8]]`. Only 4 values. But our search space `[max(nums), sum(nums)] = [10, 32]` has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.\\n\\nLet\\'s say `k` is the minimal value satisfying `feasible` function. We can prove the correctness of our solution with proof by contradiction. Assume that no subarray\\'s sum is equal to `k`, that is, every subarray sum is less than `k`. The variable `total` inside `feasible` function keeps track of the total weights of current load. If our assumption is correct, then `total` would always be less than `k`. As a result, `feasible(k - 1)` must be `True`, because `total` would at most be equal to `k - 1` and would never trigger the if-clause `if total > threshold`, therefore `feasible(k - 1)` must have the same output as `feasible(k)`, which is `True`. But we already know that `k`  is the minimal value satisfying `feasible` function, so `feasible(k - 1)` has to be `False`, which is a contradiction. So our assumption is incorrect. Now we\\'ve proved that our algorithm is correct.\\n\\n\\n\\n****\\n\\n\\n\\n## [875. Koko Eating Bananas [Medium]](https://leetcode.com/problems/koko-eating-bananas/)\\n\\nKoko loves to eat bananas. There are `N` piles of bananas, the `i`-th pile has `piles[i]` bananas. The guards have gone and will come back in `H` hours. Koko can decide her bananas-per-hour eating speed of `K`. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than `K` bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour. \\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. **Return the minimum integer `K` such that she can eat all the bananas within `H` hours**.\\n\\n**Example :**\\n\\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\\n\\nVery similar to LC 1011 and LC 410 mentioned above. Let\\'s design a `feasible` function, given an input `speed`, determine whether Koko can finish all bananas within `H` hours with hourly eating speed `speed`. Obviously, the lower bound of the search space is 1, and upper bound is `max(piles)`, because Koko can only choose one pile of bananas to eat every hour.\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1482. Minimum Number of Days to Make m Bouquets [Medium]](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n\\nGiven an integer array `bloomDay`, an integer `m` and an integer `k`. We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return *the minimum number of days* you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.\\n\\n**Examples:**\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\\n\\nNow that we\\'ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make `m` bouquets after waiting for `d` days, then we can definitely finish that as well if we wait more than `d` days.\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [668. Kth Smallest Number in Multiplication Table [Hard]](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n\\nNearly every one have used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). But could you find out the `k-th` smallest number quickly from the multiplication table? Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.\\n\\n**Example :**\\n\\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\\n\\nFor Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can  maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn\\'t work out in this problem. We don\\'t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these `m * n` values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing `condition` function is the most difficult part? In order to find the k-th smallest value in the table, we can design an `enough` function, given an input `num`, determine whether there\\'re at least k values less than or equal to `num`. **The minimal `num` satisfying `enough` function is the answer we\\'re looking for**. Recall that the key to binary search is discovering monotonicity. In this problem, if `num` satisfies `enough`, then of course any value larger than `num` can satisfy. This monotonicity is the fundament of our binary search algorithm.\\n\\nLet\\'s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is `m * n`, then we have search space `[1, m * n]`. The overwhelming advantage of binary search solution to heap solution is that it doesn\\'t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply `enough` function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.\\n\\nNext let\\'s consider how to implement `enough` function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row `[3,6,9,12,15...]` are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input `num`. Following is the complete solution.\\n\\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\\n\\nIn LC 410 above, we have doubt \"Is the result from binary search actually a subarray sum?\". Here we have a similar doubt: \"Is the result from binary search actually in the Multiplication Table?\". The answer is yes, and we also can apply proof by contradiction. Denote `num` as the minimal input that satisfies `enough` function. Let\\'s assume that `num` is not in the table, which means that `num` is not divisible by any `val` in `[1, m]`, that is, `num % val > 0`. Therefore, changing the input from `num` to `num - 1` doesn\\'t have any effect on the expression `add = min(num // val, n)`. So `enough(num)` would also return `True`,  just like `enough(num)`. But we already know `num` is the minimal input satisfying `enough` function, so `enough(num - 1)` has to be `False`. Contradiction! The opposite of our original assumption is true: `num` is actually in the table.\\n\\n\\n\\n****\\n\\n\\n\\n## [719. Find K-th Smallest Pair Distance [Hard]](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n\\nGiven an integer array, return the k-th smallest **distance** among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\\n\\n**Example :**\\n\\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\\n\\nVery similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an `enough` function, given an input `distance`, determine whether there\\'re at least k pairs whose distances are less than or equal to `distance`. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to `distance`, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:\\n\\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\\n\\nObviously, our search space should be `[0, max(nums) - min(nums)]`. Now we are ready to copy-paste our template:\\n\\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1201. Ugly Number III [Medium]](https://leetcode.com/problems/ugly-number-iii/)\\n\\nWrite a program to find the `n`-th ugly number. Ugly numbers are **positive integers** which are divisible by `a` **or** `b` **or** `c`.\\n\\n**Example :**\\n\\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\\n\\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\\n\\nNothing special. Still finding the Kth-Smallest. We need to design an `enough` function, given an input `num`, determine whether there are at least n ugly numbers less than or equal to `num`. Since `a` might be a multiple of `b` or `c`, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.\\n\\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1283. Find the Smallest Divisor Given a Threshold [Medium]](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n\\nGiven an array of integers `nums` and an integer `threshold`, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the **smallest** divisor such that the result mentioned above is less than or equal to `threshold`.\\n\\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.\\n\\n**Example :**\\n\\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\\n\\nAfter so many problems introduced above, this one should be a piece of cake. We don\\'t even need to bother to design a `condition` function, because the problem has already told us explicitly what condition we need to satisfy.\\n\\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# End\\n\\nWow, thank you so much for making it to the end, really appreciate that. As you can see from the python codes above, they all look very similar to each other. That\\'s because I copy-pasted my template all the time. No exception. This is the strong proof of my template\\'s powerfulness. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful `condition` function.\\n\\nHope this helps.\\n\\n**Reference**\\n\\n- [[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search](https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search)\\n- [Approach the problem using the \"trial and error\" algorithm](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-\"trial-and-error\"-algorithm)\\n- [Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)\\n- [ugly-number-iii Binary Search with picture & Binary Search Template - LeetCode](https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: 4\\nOutput: 2\\n```\n```scala\\nInput: 8\\nOutput: 2\\n```\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89816,
                "title": "dp-java",
                "content": "DP solution. This is obviously not as good as the binary search solutions; but it did pass OJ.\\n\\n`dp[s,j]` is the solution for splitting subarray `n[j]...n[L-1]` into `s` parts.\\n\\n`dp[s+1,i] = min{ max(dp[s,j], n[i]+...+n[j-1]) }, i+1 <= j <= L-s` \\n\\nThis solution does not take advantage of the fact that the numbers are non-negative (except to break the inner loop early). That is a loss. (On the other hand, it can be used for the problem containing arbitrary numbers)\\n\\n    public int splitArray(int[] nums, int m)\\n    {\\n        int L = nums.length;\\n        int[] S = new int[L+1];\\n        S[0]=0;\\n        for(int i=0; i<L; i++)\\n            S[i+1] = S[i]+nums[i];\\n\\n        int[] dp = new int[L];\\n        for(int i=0; i<L; i++)\\n            dp[i] = S[L]-S[i];\\n\\n        for(int s=1; s<m; s++)\\n        {\\n            for(int i=0; i<L-s; i++)\\n            {\\n                dp[i]=Integer.MAX_VALUE;\\n                for(int j=i+1; j<=L-s; j++)\\n                {\\n                    int t = Math.max(dp[j], S[j]-S[i]);\\n                    if(t<=dp[i])\\n                        dp[i]=t;\\n                    else\\n                        break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }",
                "solutionTags": [],
                "code": "DP solution. This is obviously not as good as the binary search solutions; but it did pass OJ.\\n\\n`dp[s,j]` is the solution for splitting subarray `n[j]...n[L-1]` into `s` parts.\\n\\n`dp[s+1,i] = min{ max(dp[s,j], n[i]+...+n[j-1]) }, i+1 <= j <= L-s` \\n\\nThis solution does not take advantage of the fact that the numbers are non-negative (except to break the inner loop early). That is a loss. (On the other hand, it can be used for the problem containing arbitrary numbers)\\n\\n    public int splitArray(int[] nums, int m)\\n    {\\n        int L = nums.length;\\n        int[] S = new int[L+1];\\n        S[0]=0;\\n        for(int i=0; i<L; i++)\\n            S[i+1] = S[i]+nums[i];\\n\\n        int[] dp = new int[L];\\n        for(int i=0; i<L; i++)\\n            dp[i] = S[L]-S[i];\\n\\n        for(int s=1; s<m; s++)\\n        {\\n            for(int i=0; i<L-s; i++)\\n            {\\n                dp[i]=Integer.MAX_VALUE;\\n                for(int j=i+1; j<=L-s; j++)\\n                {\\n                    int t = Math.max(dp[j], S[j]-S[i]);\\n                    if(t<=dp[i])\\n                        dp[i]=t;\\n                    else\\n                        break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1347821,
                "title": "python-2-approaches-dp-binary-search-clean-concise",
                "content": "**\\u274C Approach 1: Dynamic Programming (TLE)**\\n- Let `dp(i, m)` denote the minimum the largest sum among subarrays when dividing `nums[i...n-1]` into `m` subarrays.\\n```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i, m):\\n            if i == n:\\n                return 0\\n            if m == 0:\\n                return math.inf\\n            \\n            ans = math.inf\\n            curSum = 0\\n            for j in range(i, n-m+1):\\n                curSum += nums[j]\\n                ans = min(ans, max(curSum, dp(j+1, m-1)))\\n            return ans\\n        \\n        return dp(0, m)\\n```\\nComplexity\\n- Time: `O(N^2 * M)`, where `N <= 1000` is number of elements in array `nums`, `M <= min(50, N)` is number of non-empty subarray we need to divide.\\n- Space: `O(N * M)`\\n---\\n\\n**\\u2714\\uFE0F Approach 2: Binary Search**\\n- We binary search largest sum in range `[max(nums), sum(nums)]`, which is `left = max(nums)`, `right = sum(nums)`.\\n\\t- `mid = left + (right - left) // 2`\\n\\t- If `canPartition(mid)` then:\\n\\t\\t- Update the answer so far then try to minimize the largest sum by `right = mid - 1`\\n\\t- Else:\\n\\t\\t- Increate the largest sum by `left = mid + 1`.\\n- We need to write function `canPartition(largestSum)` to check if we can divide `nums` array into `m` subarrays such that no subarray sum is greater than `largestSum`.\\n\\t- We greedily take as many as elements to form a subarray as long as the sum of each subarray <= `largestSum`.\\n\\t- And check if we can form `k` subarray, with `k <= m`.\\n```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def canPartition(largestSum):\\n            groups = 1\\n            curSum = 0\\n            for num in nums:\\n                curSum += num\\n                if curSum > largestSum:\\n                    groups += 1\\n                    curSum = num\\n            return groups <= m\\n\\n        left = max(nums)\\n        right = sum(nums)\\n        ans = right\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if canPartition(mid):\\n                ans = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N * logSUM)`, where `N <= 1000` is number of elements in array `nums`, `SUM <= 10^9` is the total sum of all elements.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        \\n        @lru_cache(None)\\n        def dp(i, m):\\n            if i == n:\\n                return 0\\n            if m == 0:\\n                return math.inf\\n            \\n            ans = math.inf\\n            curSum = 0\\n            for j in range(i, n-m+1):\\n                curSum += nums[j]\\n                ans = min(ans, max(curSum, dp(j+1, m-1)))\\n            return ans\\n        \\n        return dp(0, m)\\n```\n```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def canPartition(largestSum):\\n            groups = 1\\n            curSum = 0\\n            for num in nums:\\n                curSum += num\\n                if curSum > largestSum:\\n                    groups += 1\\n                    curSum = num\\n            return groups <= m\\n\\n        left = max(nums)\\n        right = sum(nums)\\n        ans = right\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if canPartition(mid):\\n                ans = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141497,
                "title": "ac-java-dfs-memorization",
                "content": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int[] presum = new int[n+1];\\n        presum[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            presum[i] += nums[i-1] + presum[i-1];\\n        }\\n        \\n        int[][] visited = new int[n][m+1];\\n\\t\\tfor (int[] row : visited) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, m, nums, presum, visited);\\n    }\\n    \\n    private int dfs(int start, int m, int[] nums, int[] presum, int[][] visited) {\\n        if (m == 1) {\\n            return presum[nums.length] - presum[start];\\n        }\\n        \\n        if (visited[start][m] != -1) {\\n            return visited[start][m];\\n        }\\n        \\n        int maxSum = Integer.MAX_VALUE;\\n        \\n        for (int i = start; i < nums.length-1; i++) {\\n            int l = presum[i+1] - presum[start];\\n            int rightIntervalMax = dfs(i+1, m-1, nums, presum, visited);\\n            maxSum = Math.min(maxSum, Math.max(l, rightIntervalMax));\\n            \\n        }\\n        \\n        visited[start][m] = maxSum;\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int[] presum = new int[n+1];\\n        presum[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            presum[i] += nums[i-1] + presum[i-1];\\n        }\\n        \\n        int[][] visited = new int[n][m+1];\\n\\t\\tfor (int[] row : visited) {\\n            Arrays.fill(row, -1);\\n        }\\n        return dfs(0, m, nums, presum, visited);\\n    }\\n    \\n    private int dfs(int start, int m, int[] nums, int[] presum, int[][] visited) {\\n        if (m == 1) {\\n            return presum[nums.length] - presum[start];\\n        }\\n        \\n        if (visited[start][m] != -1) {\\n            return visited[start][m];\\n        }\\n        \\n        int maxSum = Integer.MAX_VALUE;\\n        \\n        for (int i = start; i < nums.length-1; i++) {\\n            int l = presum[i+1] - presum[start];\\n            int rightIntervalMax = dfs(i+1, m-1, nums, presum, visited);\\n            maxSum = Math.min(maxSum, Math.max(l, rightIntervalMax));\\n            \\n        }\\n        \\n        visited[start][m] = maxSum;\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89835,
                "title": "java-easy-binary-search-solution-8ms",
                "content": "1. Given a result, it is easy to test whether it is valid or not.\\n2. The max of the result is the sum of the input nums.\\n3. The min of the result is the max num of the input nums.\\nGiven the 3 conditions above we can do a binary search. (need to deal with overflow) \\n```\\npublic class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        long sum = 0;\\n        int max = 0;\\n        for(int num: nums){\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        return (int)binary(nums, m, sum, max);\\n    }\\n    \\n    private long binary(int[] nums, int m, long high, long low){\\n        long mid = 0;\\n        while(low < high){\\n            mid = (high + low)/2;\\n            if(valid(nums, m, mid)){\\n                //System.out.println(mid);\\n                high = mid;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n    \\n    private boolean valid(int[] nums, int m, long max){\\n        int cur = 0;\\n        int count = 1;\\n        for(int num: nums){\\n            cur += num;\\n            if(cur > max){\\n                cur = num;\\n                count++;\\n                if(count > m){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        long sum = 0;\\n        int max = 0;\\n        for(int num: nums){\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        return (int)binary(nums, m, sum, max);\\n    }\\n    \\n    private long binary(int[] nums, int m, long high, long low){\\n        long mid = 0;\\n        while(low < high){\\n            mid = (high + low)/2;\\n            if(valid(nums, m, mid)){\\n                //System.out.println(mid);\\n                high = mid;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n    \\n    private boolean valid(int[] nums, int m, long max){\\n        int cur = 0;\\n        int count = 1;\\n        for(int num: nums){\\n            cur += num;\\n            if(cur > max){\\n                cur = num;\\n                count++;\\n                if(count > m){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697057,
                "title": "c-0-ms-heavily-commented-very-easy-binary-search",
                "content": "**Based on the approach of the problem  \"Allocating minimum number of pages.\"**\\n* Consider the question as given an array,which is an array of different books at ith index with values as the no. of pages in ith book \\n```\\narr[]: 10 20 30 40\\nand k=2 children(suppose).\\n```\\n* Now think you want to allocate books to each of the \"k\" student such that the burden on every student can be minimized;\\nSince k=2,\\nif we partition arr as \\n\\n```\\narr1[]= 10 \\narr2[] = 20 30 40 \\n```\\nthe second student would have to read , ```20+30+40=90  ```\\nwhich is not optimal.\\n* What if we divide the arr as :\\n```\\narr1[]= 10 20\\narr2[] = 30 40 \\n```\\nso the **max** pages to be read by either student would be ```30+40=70```\\n* Can we further optimize it? Let\\'s split the arr as :\\n```\\narr1[]= 10 20 30\\narr2[] = 40 \\n```\\nNow the **max** pages to be read by either student would be ```10+20+30=60```\\nwhich is our optimal answer.\\n\\n**Now how do we implement this logic using Binary Search for the Question 410. Split Array Largest Sum?**\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\n1. At any point, the partition sum can we in the range [0,sum of all array elements]\\n2. The range can be represented as :\\n\\t```\\n\\tint low=0;\\n\\tint high =sum; //(sum is the cumulative sum of all elements in \"nums\")\\n\\t```\\n3. We calculate *mid* for the range to see if we can partition the array in *k* continous subarrays whose sum is not more than mid.\\n```\\nint mid =low+(high-low)/2;\\n```\\n\\n4. To check if this value of mid can we a valid answer we create a function named isValid().\\n*  Validiy of *mid* means , we need to determine if we need k partitions for this max sum or more.\\n*  To check that we traverse the whole array *nums* keep on adding values in *sum* such that,\\n```\\nfor( int i : nums ){\\n\\tsum+=i;\\n```\\n* If at any point the cumulative sum exceeds our value of *mid* (which is supposed to be the max sum of this partition),  and we need more than *k* partitions to accumulate it, we return false;\\ne.g. if mid =10\\nnums[] = 1 6 3 9 15 4\\nk=2\\nwe wouldn\\'t be able to create exactly 2 subarrays with their max sum = 10(mid).\\nSo we return false.\\n5. We then check for a higher value if we fail.\\n```\\nlow=mid+1;\\n```\\n\\n6. Even if we find a value of *mid* that doesn\\'t voilate the validity of partitioning the array, we still try to get a lower value.\\n```\\nif (isValid){\\n\\tres=min(res,mid);\\n\\thigh=mid-1;//we still check for a lower value than mid.\\n```\\n[Book allocation problem Link](http:https://www.***.org/allocate-minimum-number-pages///)\\n\\nTook me a lot of time to write up this, if it helps you i\\'ll be glad.\\n\\n**Below is the implementation of above logic.**\\n\\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n=size(nums); \\n        long long  sum=0;\\n        for(long long  i : nums){\\n            if (i==INT_MAX)\\n                return INT_MAX; //Even if you do n partitions you won\\'t be able to reduce this, so simply this will be the max sum.\\n            sum+=i;\\n        }\\n        if (m==1) //if you can\\'t partition it then the max value in the whole array will be the max sum.\\n            return sum;\\n        long long low=0;\\n        long high=sum; // \"high\" denotes the maximum sum that is an possible answer.\\n        long long  mid;\\n        long long  res=INT_MAX;\\n        while (low<=high){\\n            mid=low+(high-low)/2;\\n            if (isValid(nums,n,m,mid)) //\"isvalid()\" is to check if this value , \"mid\" can be a valid answer for m partitions.\\n            {\\n                res=min(res,mid);\\n                high=mid-1; //even when we find an answer we check for a lesser value;\\n            }\\n            else \\n                low=mid+1;\\n            \\n        }\\n        return res;\\n    }\\n    \\n    bool isValid(vector<int> nums,int n, int m, int mid){\\n        int assn=1; //assignments=1 initially , means can we allocate the values to 1 partition only without violating the condition of having sum <=mid;\\n        int sum=0;\\n        for(int i : nums){\\n            sum+=i;\\n            if (sum>mid){\\n                assn++;\\n                sum=i;\\n                if (sum>mid) //if at any instance we find that this value is greater than current max sum we are checking for we return false;\\n                    return false;\\n            }\\n            if (assn>m) //if we need more than required partitions for the current max (\"mid\") value we are checking for we return false;\\n                return false;\\n        }\\n        return true; // if everything is fine without violating any condition we return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\narr[]: 10 20 30 40\\nand k=2 children(suppose).\\n```\n```\\narr1[]= 10 \\narr2[] = 20 30 40 \\n```\n```20+30+40=90  ```\n```\\narr1[]= 10 20\\narr2[] = 30 40 \\n```\n```30+40=70```\n```\\narr1[]= 10 20 30\\narr2[] = 40 \\n```\n```10+20+30=60```\n```\\n\\tint low=0;\\n\\tint high =sum; //(sum is the cumulative sum of all elements in \"nums\")\\n\\t```\n```\\nint mid =low+(high-low)/2;\\n```\n```\\nfor( int i : nums ){\\n\\tsum+=i;\\n```\n```\\nlow=mid+1;\\n```\n```\\nif (isValid){\\n\\tres=min(res,mid);\\n\\thigh=mid-1;//we still check for a lower value than mid.\\n```\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n=size(nums); \\n        long long  sum=0;\\n        for(long long  i : nums){\\n            if (i==INT_MAX)\\n                return INT_MAX; //Even if you do n partitions you won\\'t be able to reduce this, so simply this will be the max sum.\\n            sum+=i;\\n        }\\n        if (m==1) //if you can\\'t partition it then the max value in the whole array will be the max sum.\\n            return sum;\\n        long long low=0;\\n        long high=sum; // \"high\" denotes the maximum sum that is an possible answer.\\n        long long  mid;\\n        long long  res=INT_MAX;\\n        while (low<=high){\\n            mid=low+(high-low)/2;\\n            if (isValid(nums,n,m,mid)) //\"isvalid()\" is to check if this value , \"mid\" can be a valid answer for m partitions.\\n            {\\n                res=min(res,mid);\\n                high=mid-1; //even when we find an answer we check for a lesser value;\\n            }\\n            else \\n                low=mid+1;\\n            \\n        }\\n        return res;\\n    }\\n    \\n    bool isValid(vector<int> nums,int n, int m, int mid){\\n        int assn=1; //assignments=1 initially , means can we allocate the values to 1 partition only without violating the condition of having sum <=mid;\\n        int sum=0;\\n        for(int i : nums){\\n            sum+=i;\\n            if (sum>mid){\\n                assn++;\\n                sum=i;\\n                if (sum>mid) //if at any instance we find that this value is greater than current max sum we are checking for we return false;\\n                    return false;\\n            }\\n            if (assn>m) //if we need more than required partitions for the current max (\"mid\") value we are checking for we return false;\\n                return false;\\n        }\\n        return true; // if everything is fine without violating any condition we return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533758,
                "title": "c-o-mnn-dp-with-explanation",
                "content": "* Step 1: construct a prefix sum\\n* Step 2: the dp[i][j] means the min of the max sum among j splits in arr[0 to i], 0 and i are inclusive\\n* Step 3: init dp, init all dp[i][1] to prefix sum, since it does not split (only one group together)\\n* Step 4: iterating all the dp[i][j] \\nfor i in [0, n - 1]:\\n    for j in [2, m]:\\n        for k in all possible splitting point in (this time we split only once, since the subproblem has been solved)\\n            [ 0 <- k -> (splitted with j - 1times)| (altogether, so not split)   ]\\n        max(dp[k][j - 1],                         |prefix_sum[i] - prefix_sum[k]))\\n\\n* Analysis:\\n    * Time complexity: O(m * n * n)\\n    * Space complexoty: O(m * n)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        \\n        vector<unsigned int> prefix_sum(n, 0);\\n        vector<vector<unsigned int> > dp(n + 1, vector<unsigned int>(m + 1, INT_MAX));\\n        prefix_sum[0] = nums[0];\\n        // Step 1:\\n        for(int i = 1; i < n; i++){\\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i];\\n        }\\n        \\n        // Step 2, 3:\\n        for(int i = 0; i < n; i++){\\n            dp[i][1] = prefix_sum[i];\\n        }\\n        \\n        dp[0][0] = 0;\\n        // Step 4\\n        for(int i = 0; i < n; i++){\\n            // check all the possible splitting mechanism\\n            for(int j = 2; j <= m; j++){\\n                // from 0 to i, \\n                for(int k = 0; k < i; k++){\\n                    dp[i][j] = min(dp[i][j], max(dp[k][j - 1], prefix_sum[i] - prefix_sum[k]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1][m];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        \\n        vector<unsigned int> prefix_sum(n, 0);\\n        vector<vector<unsigned int> > dp(n + 1, vector<unsigned int>(m + 1, INT_MAX));\\n        prefix_sum[0] = nums[0];\\n        // Step 1:\\n        for(int i = 1; i < n; i++){\\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i];\\n        }\\n        \\n        // Step 2, 3:\\n        for(int i = 0; i < n; i++){\\n            dp[i][1] = prefix_sum[i];\\n        }\\n        \\n        dp[0][0] = 0;\\n        // Step 4\\n        for(int i = 0; i < n; i++){\\n            // check all the possible splitting mechanism\\n            for(int j = 2; j <= m; j++){\\n                // from 0 to i, \\n                for(int k = 0; k < i; k++){\\n                    dp[i][j] = min(dp[i][j], max(dp[k][j - 1], prefix_sum[i] - prefix_sum[k]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084798,
                "title": "java-top-down-recursion-memoization-o-n-2-m-time",
                "content": "**Intuition**\\n\\n* Try all ways of partitioning the input array into m blocks.\\n* While doing so, keep track of the minimum of largest sums among all blocks.\\n* More concretely, answer is:\\n   `min(current partition sum, maximum partition sum for subarray to the right of the current partition)` \\n\\n**Key point**\\n\\nMemoize the recursion result so that we don\\'t solve the same subproblem again.\\n\\n**Code**\\n\\n```java\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int[][] memo = new int[nums.length][m+1];\\n        \\n        for (int i = 0; i < memo.length; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n\\n        return walk(nums, memo, 0, m);\\n    }\\n    \\n    private int walk(int[] nums, int[][] memo, int start, int rem) { \\n\\t    // base case\\n        if (rem == 0 && start == nums.length) {\\n            return 0;\\n        }\\n        if (rem == 0 || start == nums.length) {\\n\\t\\t    // if we reach the end and have not used up all patitions\\n\\t\\t\\t// or have used up all partitions and have not reached the end,\\n\\t\\t\\t// we do not want to count the current way of partitioning.\\n\\t\\t\\t// Return MAX_VALUE so that we don\\'t contribute to the return value.\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        int n = nums.length;\\n        int ret = Integer.MAX_VALUE;\\n        int curSum = 0;\\n        \\n        if (memo[start][rem] != -1) {\\n            return memo[start][rem];\\n        }\\n        \\n\\t\\t// try all positions to end the current partition.\\n        for (int i = start; i < n; i++) {\\n            curSum += nums[i];\\n            \\n\\t\\t\\t// answer for partitioning the subarray to the right of the current partition,\\n\\t\\t\\t// with one less partition number allowance, because we already used one\\n\\t\\t\\t// for the current partition. i.e. (rem - 1).\\n            int futureSum = walk(nums, memo, i + 1, rem - 1);\\n\\n            // we want to minimum of the largest sum of the partitions.\\n            ret = Math.min(ret, Math.max(curSum, futureSum));\\n        }\\n        \\n        memo[start][rem] = ret;\\n        return ret;\\n    }\\n}\\n```\\n\\n**Analysis**\\n\\nLet n = |nums|, and given m,\\nWe solve `nm` number of problems, each time we solve a problem, we access at most `n` array elements.\\n\\n* Time complexity: ~O(n^2m)\\n* Space complexity: ~O(nm) for memoization array + call stack of depth n.\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int[][] memo = new int[nums.length][m+1];\\n        \\n        for (int i = 0; i < memo.length; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n\\n        return walk(nums, memo, 0, m);\\n    }\\n    \\n    private int walk(int[] nums, int[][] memo, int start, int rem) { \\n\\t    // base case\\n        if (rem == 0 && start == nums.length) {\\n            return 0;\\n        }\\n        if (rem == 0 || start == nums.length) {\\n\\t\\t    // if we reach the end and have not used up all patitions\\n\\t\\t\\t// or have used up all partitions and have not reached the end,\\n\\t\\t\\t// we do not want to count the current way of partitioning.\\n\\t\\t\\t// Return MAX_VALUE so that we don\\'t contribute to the return value.\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        int n = nums.length;\\n        int ret = Integer.MAX_VALUE;\\n        int curSum = 0;\\n        \\n        if (memo[start][rem] != -1) {\\n            return memo[start][rem];\\n        }\\n        \\n\\t\\t// try all positions to end the current partition.\\n        for (int i = start; i < n; i++) {\\n            curSum += nums[i];\\n            \\n\\t\\t\\t// answer for partitioning the subarray to the right of the current partition,\\n\\t\\t\\t// with one less partition number allowance, because we already used one\\n\\t\\t\\t// for the current partition. i.e. (rem - 1).\\n            int futureSum = walk(nums, memo, i + 1, rem - 1);\\n\\n            // we want to minimum of the largest sum of the partitions.\\n            ret = Math.min(ret, Math.max(curSum, futureSum));\\n        }\\n        \\n        memo[start][rem] = ret;\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904499,
                "title": "java-0ms-100-clean-simplest-solution-with-comments",
                "content": "This algorithm relies on binary search technique. \\nThe answer to any test case will always lie between the max value element of the given array *(lower boundary of binary search)* and sum of all array elements *(upper boundary of binary search)* inclusive of the boundaries. This is because:\\n1. After splitting, any subarray will have atleast the max element of the array, or more (in case of multiple elements in the subarray). \\n2. The answer can never go beyond the total sum of all the array elements.**\\n\\nIn the algorithm, we assume that mid is a possible answer, and we check using binary search if it is possible to split the array into *m* subarrays such that every subarray is less than the mid. \\n1. If yes, then mid is a contender to the final answer. We store it, and further reduce the high boundary below mid to check if it is possible to get a lower answer.\\n2. If no, then the lower boundary is increased above mid to get a higher mid value in the next iteration.\\n\\nThat\\'s it! Please upvote if you find it helpful. Cheers.\\n\\n```\\nimport java.lang.Math;\\n\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        if (nums == null || nums.length == 0 || m == 0 ) {\\n            return 0;\\n        }\\n        \\n        int max = 0;\\n        int sum = 0;\\n\\t\\t\\n\\t\\t// the lower boundary will be max and upper bounder will be sum for the binary search\\n        for ( int num : nums ) {\\n            sum = sum + num;\\n            max = Math.max(num, max);\\n        }\\n        \\n\\t\\t// base checks where we do not need to apply binary search\\n        if ( m == nums.length ) {\\n            return max;\\n        } else if ( m == 1 ) {\\n            return sum;\\n        } else {\\n            \\n            int ans = 0;\\n            int lo = max;\\n            int hi = sum;\\n            \\n            while ( lo <= hi ) {\\n\\t\\t\\t    //remember that we are not using the array index here, do not use (lo+hi)/2\\n                int mid = lo + ( hi-lo )/2;\\n\\t\\t\\t\\t//check if it is possible to form m subarrays with the given mid\\n                if( isPossible(nums, mid, m) ) {   \\n\\t\\t\\t\\t    //if yes, store the answer and reduce the upper boundary\\n                    ans = mid;\\n                    hi = mid - 1; \\n                } else {\\n\\t\\t\\t\\t    //if no, increase the lower boundary to get a higher mid\\n                    lo = mid + 1;\\n                }\\n            }\\n            \\n            return ans;\\n            \\n        }\\n    }\\n    \\n    public static boolean isPossible ( int[] nums, int mid, int m ) {\\n        int sum = 0;\\n        int requiredSubarrays = 1;\\n        \\n        for ( int i=0; i < nums.length; i++ ) {\\n            sum = sum+nums[i];\\n            if ( sum > mid ) {\\n                requiredSubarrays++;\\n                sum = nums[i];\\n            }\\n        }\\n        \\n        if ( requiredSubarrays <= m ) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nimport java.lang.Math;\\n\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        if (nums == null || nums.length == 0 || m == 0 ) {\\n            return 0;\\n        }\\n        \\n        int max = 0;\\n        int sum = 0;\\n\\t\\t\\n\\t\\t// the lower boundary will be max and upper bounder will be sum for the binary search\\n        for ( int num : nums ) {\\n            sum = sum + num;\\n            max = Math.max(num, max);\\n        }\\n        \\n\\t\\t// base checks where we do not need to apply binary search\\n        if ( m == nums.length ) {\\n            return max;\\n        } else if ( m == 1 ) {\\n            return sum;\\n        } else {\\n            \\n            int ans = 0;\\n            int lo = max;\\n            int hi = sum;\\n            \\n            while ( lo <= hi ) {\\n\\t\\t\\t    //remember that we are not using the array index here, do not use (lo+hi)/2\\n                int mid = lo + ( hi-lo )/2;\\n\\t\\t\\t\\t//check if it is possible to form m subarrays with the given mid\\n                if( isPossible(nums, mid, m) ) {   \\n\\t\\t\\t\\t    //if yes, store the answer and reduce the upper boundary\\n                    ans = mid;\\n                    hi = mid - 1; \\n                } else {\\n\\t\\t\\t\\t    //if no, increase the lower boundary to get a higher mid\\n                    lo = mid + 1;\\n                }\\n            }\\n            \\n            return ans;\\n            \\n        }\\n    }\\n    \\n    public static boolean isPossible ( int[] nums, int mid, int m ) {\\n        int sum = 0;\\n        int requiredSubarrays = 1;\\n        \\n        for ( int i=0; i < nums.length; i++ ) {\\n            sum = sum+nums[i];\\n            if ( sum > mid ) {\\n                requiredSubarrays++;\\n                sum = nums[i];\\n            }\\n        }\\n        \\n        if ( requiredSubarrays <= m ) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89821,
                "title": "python-solution-dp-and-binary-search",
                "content": "First i try dp, while got TLE:(while if using java to implement dp, u may get AC...)\\n```\\nimport sys\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[sys.maxint]*(m) for _ in range(len(nums)+1)]\\n        acc = 0\\n        dp[0][0] = 0\\n        for i in range(1, len(nums)+1):\\n            acc += nums[i - 1]\\n            dp[i][0] = acc\\n\\n        for j in range(m):\\n            dp[0][j] = 0\\n\\n        for i in range(1, len(nums)+1):\\n            for i_ in range(i):\\n                for j in range(1, m):\\n                    dp[i][j] = min(dp[i][j], max(dp[i_][j-1], dp[i][0]-dp[i_][0]))\\n        #print dp\\n        return dp[len(nums)][m-1]\\n```\\nThen by binary search, got AC:\\n```\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        def valid(mid):\\n            cnt = 0\\n            current = 0\\n            for n in nums:\\n                current += n\\n                if current>mid:\\n                    cnt += 1\\n                    if cnt>=m:\\n                        return False\\n                    current = n\\n            return True\\n\\n        l = max(nums)\\n        h = sum(nums)\\n\\n        while l<h:\\n            mid = l+(h-l)/2\\n            if valid(mid):\\n                h = mid\\n            else:\\n                l = mid+1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nimport sys\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        dp = [[sys.maxint]*(m) for _ in range(len(nums)+1)]\\n        acc = 0\\n        dp[0][0] = 0\\n        for i in range(1, len(nums)+1):\\n            acc += nums[i - 1]\\n            dp[i][0] = acc\\n\\n        for j in range(m):\\n            dp[0][j] = 0\\n\\n        for i in range(1, len(nums)+1):\\n            for i_ in range(i):\\n                for j in range(1, m):\\n                    dp[i][j] = min(dp[i][j], max(dp[i_][j-1], dp[i][0]-dp[i_][0]))\\n        #print dp\\n        return dp[len(nums)][m-1]\\n```\n```\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        def valid(mid):\\n            cnt = 0\\n            current = 0\\n            for n in nums:\\n                current += n\\n                if current>mid:\\n                    cnt += 1\\n                    if cnt>=m:\\n                        return False\\n                    current = n\\n            return True\\n\\n        l = max(nums)\\n        h = sum(nums)\\n\\n        while l<h:\\n            mid = l+(h-l)/2\\n            if valid(mid):\\n                h = mid\\n            else:\\n                l = mid+1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899223,
                "title": "100-c-binary-search-easy-to-understand-simple-logic",
                "content": "First we need to find the range of Binary Search.....\\n\\nThe **minimum**  value of sum **cannot** be **lower** than the **largest element** of the array nums . This is because even if we split all element into group of size 1, largest element will have the largest sum.\\n\\nSo, this value will be the staring range of Binary Search.\\n\\ne.g. if nums = [7,2,5,10,8], then sum cannot be lower that 10.\\n\\nSimilarly, the largest possible value of Sum will be when we don\\'t divide the array at all and all elements are in the same group.\\n\\n**Ending** range of Binary Search will be the **sum** of the whole array **nums**.\\n\\nWe will then calculate mid value of this range and check if We can have atmost **m** subarray groups, such that the sum of each group does **not** exceed **mid**.\\n\\nTo do this, we can take a variable **count** to store the number of paritions needed so that the maximum sum of the nums does not exceed **mid**.\\n\\n**If** the **total number of groups** after partition is **less than the m**, we can split the any of the current group of size >=2.\\nThis will **not** increase the **maximum sum** and hence our answer will still be **valid**.\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums, int m, int curr){\\n        int i=-1, n = nums.size(), count=1;\\n        \\n        int sum=0;\\n        \\n        while(++i<n && count<=m){\\n\\t\\t//if adding the nums[i] does not make the sum greater than curr (mid), we add it to group\\n            if(sum+nums[i] <= curr) sum += nums[i];  \\n\\t\\t// else we can add a new group to store the remaining element.\\n            else sum=nums[i], count++;\\n        }\\n\\t\\t\\n\\t\\t//If the total number of groups is less than the m, we can split the any of the current group of size >=2.\\n\\t\\t//this will not increase the maximum sum and hence our answer will still be valid\\n\\t\\t\\n        return count<=m;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int e=0,s=0,mid,ans;\\n        for(auto x : nums){\\n\\t\\t\\te += x;               //e stores the sum of the nums, upper range of Binary Search\\n\\t\\t\\ts=max(s,x);          //s stores the largest element in array nums, lower range of Binary Search\\n\\t\\t}\\t\\n        ans = e; \\n        \\n        while(s<=e){\\n            mid = s + (e-s)/2;\\n            \\n            if(check(nums,m,mid)){\\n                ans = min(ans,mid);\\n                e = mid - 1;\\n            }\\n            else s = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums, int m, int curr){\\n        int i=-1, n = nums.size(), count=1;\\n        \\n        int sum=0;\\n        \\n        while(++i<n && count<=m){\\n\\t\\t//if adding the nums[i] does not make the sum greater than curr (mid), we add it to group\\n            if(sum+nums[i] <= curr) sum += nums[i];  \\n\\t\\t// else we can add a new group to store the remaining element.\\n            else sum=nums[i], count++;\\n        }\\n\\t\\t\\n\\t\\t//If the total number of groups is less than the m, we can split the any of the current group of size >=2.\\n\\t\\t//this will not increase the maximum sum and hence our answer will still be valid\\n\\t\\t\\n        return count<=m;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int e=0,s=0,mid,ans;\\n        for(auto x : nums){\\n\\t\\t\\te += x;               //e stores the sum of the nums, upper range of Binary Search\\n\\t\\t\\ts=max(s,x);          //s stores the largest element in array nums, lower range of Binary Search\\n\\t\\t}\\t\\n        ans = e; \\n        \\n        while(s<=e){\\n            mid = s + (e-s)/2;\\n            \\n            if(check(nums,m,mid)){\\n                ans = min(ans,mid);\\n                e = mid - 1;\\n            }\\n            else s = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987209,
                "title": "intuition-around-the-binary-search-approach",
                "content": "Basically, the idea is to redefine the problem.\\n\\nInstead of thinking of it as how to subdivide your array, think of it as: \"How do I set a threshold so that my array will be divided into the right number of parts?\"\\n\\nNow imagine you have a function that takes a threshold and tells you what that threshold would result in -- that is, how many subarrays your main array would be split into.\\n\\nYou could start with a guess, and if your guess is too low, you would get too many subarrays. If your guess is too high, you would get too few subarrays.\\n\\nTo make this concrete, imagine your array is [2,3,4,3,2].\\n\\nIf your guess threshold was 1,000,000, then you would easily fit all these numbers into it, so your subarrays would be 1 -- that is, you wouldn\\'t need to split the array at all.\\n\\nIf your guess threshold was 4, then you\\'d split this into 5 subarrays like this: [2], [3], [4], [3], [2]  -- because there would be no way of fitting more than one element into a subarray without crossing that threshold.\\n\\nA threshold lower than 4 would be nonsense, because you wouldn\\'t succeed in fitting your largest element, 4, into it.\\n\\nThis tells us we should never guess lower than our max element.\\n\\nSimilarly, that guess of 1,000,000 was nonsense, because we never need to guess higher than the sum of all our elements in order to fit our array into one subarray.\\n\\nNow we have all the ingredients for a binary search. We have a lower bound, an upper bound, and a (not-yet-written!) function that tells us if our guess is too high or too low.\\n\\nSo we iteratively guess at the midpoint between lower and upper bounds. If our guess turns out to be too high, then we bring our upper bound down to our guess. If our guess turns out to be too low, we raise our lower bound to our guess.\\n\\nWhat\\'s the function that takes a threshold and returns the number of subarrays it will create? Pretty simple:\\n\\n```\\nfunction getSubarrayCountForThreshold(nums, threshold) {\\n\\tvar numSubarrays = 1; // Our base case\\n\\tvar sum = 0;\\n\\tfor(var i = 0; i < nums.length; i++) {\\n\\t\\tsum += nums[i];\\n\\t\\t// Would this fit into our previous subarray?\\n\\t\\tif(sum > threshold) { //No\\n\\t\\t\\tnumSubarrays++; // we would need a new subarray\\n\\t\\t\\tsum = nums[i]; // That starts out by containing this new element\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn numSubarrays;\\n}\\n```\\n\\nIt seems to me to be pretty similar to Bresenham\\'s line-drawing algorithm.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nfunction getSubarrayCountForThreshold(nums, threshold) {\\n\\tvar numSubarrays = 1; // Our base case\\n\\tvar sum = 0;\\n\\tfor(var i = 0; i < nums.length; i++) {\\n\\t\\tsum += nums[i];\\n\\t\\t// Would this fit into our previous subarray?\\n\\t\\tif(sum > threshold) { //No\\n\\t\\t\\tnumSubarrays++; // we would need a new subarray\\n\\t\\t\\tsum = nums[i]; // That starts out by containing this new element\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn numSubarrays;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326747,
                "title": "python-solutions-with-thinking-process-similar-problems-listed",
                "content": "Please see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T...TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\nKey points of this problem:\\n1. Because all integers are non-negative, the possible range of the largest one of m sums \\nis [max(nums), sum(nums)].\\n2. Use binary search to find the minimal possible value of the largest sum:\\nGiven a guess max_sum, is it possible to split the array into m non-empty contiguous \\nsubarrays such that the sum of each subarray <= max_sum?  If not, this means the guess \\nmax_sum is too small. If yes, try another smaller guess.\\n\\nSolution 1: binary search\\ntime: O(n log(s)), where s = sum(nums)\\nspace: O(1)\\n```\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def cannot_split(max_sum, m):\\n            cuts, curr_sum  = 0, 0\\n            for x in nums:\\n                curr_sum += x\\n                if curr_sum > max_sum:\\n                    cuts += 1\\n                    curr_sum = x\\n            subs = cuts + 1\\n            return (subs > m)\\n        \\n        low, high = max(nums), sum(nums)\\n        while low < high:\\n            guess = low + (high - low) // 2\\n            if cannot_split(guess, m):\\n                low = guess + 1\\n            else:\\n                high = guess\\n        return low\\n```\\n\\nWithout hints, it is very difficult to get the above key points. Dynamic programming is the first idea in my mind to solve this problem.\\n\\nTop-down DP: without the break condition, the solution will exceed time limit\\ntime: O(n^2 m), space: O(n m)\\n```\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def recursive(m, i):\\n            if m == 1:\\n                return sums[i]\\n            if m == i:\\n                return maxs[i]\\n            if (m, i) in dp:\\n                return dp[(m, i)]\\n            tmp = float(\\'inf\\')\\n            for j in reversed(range(m - 1, i)):\\n                tmp = min(tmp, max(recursive(m - 1, j), sums[i] - sums[j]))\\n                if sums[i] - sums[j] >= tmp:\\n                    break\\n            dp[(m, i)] = tmp\\n            return dp[(m, i)]\\n        \\n        sums, maxs = [0], [0]\\n        for x in nums:\\n            sums.append(sums[-1] + x)\\n            maxs.append(max(maxs[-1], x))\\n        dp = {}\\n        return recursive(m, len(nums))\\n```\\n\\nBottom-up approach: without the break condition, the solution will exceed time limit\\ntime: O(n^2 m), space: O(n m)\\n```\\n    def splitArray(self, nums: List[int], m: int) -> int:       \\n        sums, maxs = [0], [0]\\n        for x in nums:\\n            sums.append(sums[-1] + x)\\n            maxs.append(max(maxs[-1], x))\\n        dp = [[float(\\'inf\\') for _ in range(len(nums) + 1)] for _ in range(m + 1)]\\n        for i in range(1, len(nums) + 1):\\n            dp[1][i] = sums[i]\\n        for m1 in range(1, m + 1):\\n            dp[m1][m1] = maxs[m1]\\n        for m1 in range(2, m + 1):\\n            for i in range(m1 + 1, len(nums) + 1):\\n                for j in reversed(range(m1 - 1, i)):\\n                    dp[m1][i] = min(dp[m1][i], max(dp[m1-1][j], sums[i] - sums[j]))\\n                    if sums[i] - sums[j] >= dp[m1][i]:\\n                        break\\n        return dp[m][len(nums)]\\n```\\n\\nFurther optimization:\\ndp[m1][i] = min{max{a_j, b_j} for j in range(m1 - 1, i)}\\na_j is monotonically increasing,\\nb_j is monotonically decreasing,\\nif b_j >= a_j, the optimum is located in the interval [j, high],\\nelse, the optimum is located in the interval [low, j).\\nSo, we can use binary search to optimize.\\n\\nTime: O(m n log n)\\nSpace: O(m n)\\n\\n```\\n    def splitArray(self, nums: List[int], m: int) -> int:       \\n        sums, maxs = [0], [0]\\n        for x in nums:\\n            sums.append(sums[-1] + x)\\n            maxs.append(max(maxs[-1], x))\\n        dp = [[float(\\'inf\\') for _ in range(len(nums) + 1)] for _ in range(m + 1)]\\n        for i in range(1, len(nums) + 1):\\n            dp[1][i] = sums[i]\\n        for m1 in range(1, m + 1):\\n            dp[m1][m1] = maxs[m1]\\n        for m1 in range(2, m + 1):\\n            for i in range(m1 + 1, len(nums) + 1):\\n                low, high = m1 - 1, i - 1\\n                while low < high:\\n                    mid = low + (high - low) // 2\\n                    a, b = dp[m1-1][mid], sums[i] - sums[mid]\\n                    dp[m1][i] = min(dp[m1][i], max(a, b))\\n                    if b >= a:\\n                        low = mid + 1\\n                    else:\\n                        high = mid\\n                a, b = dp[m1-1][low], sums[i] - sums[low]\\n                dp[m1][i] = min(dp[m1][i], max(a, b))\\n        return dp[m][len(nums)]\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def cannot_split(max_sum, m):\\n            cuts, curr_sum  = 0, 0\\n            for x in nums:\\n                curr_sum += x\\n                if curr_sum > max_sum:\\n                    cuts += 1\\n                    curr_sum = x\\n            subs = cuts + 1\\n            return (subs > m)\\n        \\n        low, high = max(nums), sum(nums)\\n        while low < high:\\n            guess = low + (high - low) // 2\\n            if cannot_split(guess, m):\\n                low = guess + 1\\n            else:\\n                high = guess\\n        return low\\n```\n```\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def recursive(m, i):\\n            if m == 1:\\n                return sums[i]\\n            if m == i:\\n                return maxs[i]\\n            if (m, i) in dp:\\n                return dp[(m, i)]\\n            tmp = float(\\'inf\\')\\n            for j in reversed(range(m - 1, i)):\\n                tmp = min(tmp, max(recursive(m - 1, j), sums[i] - sums[j]))\\n                if sums[i] - sums[j] >= tmp:\\n                    break\\n            dp[(m, i)] = tmp\\n            return dp[(m, i)]\\n        \\n        sums, maxs = [0], [0]\\n        for x in nums:\\n            sums.append(sums[-1] + x)\\n            maxs.append(max(maxs[-1], x))\\n        dp = {}\\n        return recursive(m, len(nums))\\n```\n```\\n    def splitArray(self, nums: List[int], m: int) -> int:       \\n        sums, maxs = [0], [0]\\n        for x in nums:\\n            sums.append(sums[-1] + x)\\n            maxs.append(max(maxs[-1], x))\\n        dp = [[float(\\'inf\\') for _ in range(len(nums) + 1)] for _ in range(m + 1)]\\n        for i in range(1, len(nums) + 1):\\n            dp[1][i] = sums[i]\\n        for m1 in range(1, m + 1):\\n            dp[m1][m1] = maxs[m1]\\n        for m1 in range(2, m + 1):\\n            for i in range(m1 + 1, len(nums) + 1):\\n                for j in reversed(range(m1 - 1, i)):\\n                    dp[m1][i] = min(dp[m1][i], max(dp[m1-1][j], sums[i] - sums[j]))\\n                    if sums[i] - sums[j] >= dp[m1][i]:\\n                        break\\n        return dp[m][len(nums)]\\n```\n```\\n    def splitArray(self, nums: List[int], m: int) -> int:       \\n        sums, maxs = [0], [0]\\n        for x in nums:\\n            sums.append(sums[-1] + x)\\n            maxs.append(max(maxs[-1], x))\\n        dp = [[float(\\'inf\\') for _ in range(len(nums) + 1)] for _ in range(m + 1)]\\n        for i in range(1, len(nums) + 1):\\n            dp[1][i] = sums[i]\\n        for m1 in range(1, m + 1):\\n            dp[m1][m1] = maxs[m1]\\n        for m1 in range(2, m + 1):\\n            for i in range(m1 + 1, len(nums) + 1):\\n                low, high = m1 - 1, i - 1\\n                while low < high:\\n                    mid = low + (high - low) // 2\\n                    a, b = dp[m1-1][mid], sums[i] - sums[mid]\\n                    dp[m1][i] = min(dp[m1][i], max(a, b))\\n                    if b >= a:\\n                        low = mid + 1\\n                    else:\\n                        high = mid\\n                a, b = dp[m1-1][low], sums[i] - sums[low]\\n                dp[m1][i] = min(dp[m1][i], max(a, b))\\n        return dp[m][len(nums)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 89828,
                "title": "python-binary-search-with-a-short-explanation",
                "content": " I found some of the earlier posters with excellent code, however, the explanation is too long and hard to understand. \\n\\nHere is mine:\\n\\nThe problem calls for a optimal value ( a ceiling) for the sum of subarray while an array is split into M subarrays. Intuitively, we know the best possible ceiling is the max element of the all input numbers (denote this as \"left\". Proof: if the ceiling is smaller than largest element, you can't put it in any group), and worst ceiling is the sum of all numbers (denote this as \"right\"). However, the left is only \"possible\" best solution, more than often it is too small to for me divide the array. So, I gradually increase left until I find a valid ceiling. On the other hand, the right is an valid ceiling since the number is so large that I can do whatever split I want. But it might not be the optimal answer. So, I will gradually decrease the right and try to find a better answer until it turns invalid.\\nGoing at both directions:\\n         From left:  invalid -> invalid->.........\\n         From right:                                       ...<- valid <- valid\\nThe solution turn out to be the point the two side meet! A perfect problem to be solved by binary search.\\n\\nTo help out finding if a ceiling is valid,  we need a utility method (isValidCeiling). It actually tries to split the array into M subarrays with a given ceiling. If possible, returns True, otherwise returns False.\\n\\n```\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n\\n        # A ceiling is max sum allowed for earch segment (subarray).\\n        def isValidCeiling(nums, m, ceiling):\\n            count, total = 1, 0  # count - # of segments. total - temp sum of the current segment.\\n            for i in range(len(nums)):\\n                if total + nums[i] <= ceiling:\\n                    total += nums[i]  # add the number to the current segment.\\n                else:\\n                    total = nums[i]    # over the ceiling, start a new segment.\\n                    count += 1\\n                if (count > m):\\n                    return False # if need more segments than m, the this an invalid ceiling.\\n            return True # if count <= m, then this is a valid ceiling, i.e. if we can split into less than M segments, sure enough we can split into M segments.\\n\\n        l, r = max(nums), sum(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if isValidCeiling(nums, m, mid):\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n\\n        # A ceiling is max sum allowed for earch segment (subarray).\\n        def isValidCeiling(nums, m, ceiling):\\n            count, total = 1, 0  # count - # of segments. total - temp sum of the current segment.\\n            for i in range(len(nums)):\\n                if total + nums[i] <= ceiling:\\n                    total += nums[i]  # add the number to the current segment.\\n                else:\\n                    total = nums[i]    # over the ceiling, start a new segment.\\n                    count += 1\\n                if (count > m):\\n                    return False # if need more segments than m, the this an invalid ceiling.\\n            return True # if count <= m, then this is a valid ceiling, i.e. if we can split into less than M segments, sure enough we can split into M segments.\\n\\n        l, r = max(nums), sum(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if isValidCeiling(nums, m, mid):\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89873,
                "title": "binary-search-c-solution",
                "content": "Obviously, the final result is in the interval [left, right] (where left is the maximal number in the array, right is sum of all numbers). \\nSo, what we need to do is to find out the first element in [left, right], which exactly we cannot split the array into m subarrays whose sum is no greater than that element. Then its previous one is the final result. The progress is much similar to lower_bound in C++.\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n\\n    bool canSplit(vector<int>& nums, int m, ll sum) {\\n        int c = 1;\\n        ll s = 0;\\n        for (auto& num : nums) {\\n            s += num;\\n            if (s > sum) {\\n                s = num;\\n                ++c;\\n            }\\n        }\\n        return c <= m;\\n    }\\n\\n    int splitArray(vector<int>& nums, int m) {\\n        ll left = 0, right = 0;\\n        for (auto& num : nums) {\\n            left = max(left, (ll)num);\\n            right += num;\\n        }\\n        while (left <= right) {\\n            ll mid = left + (right-left)/2;\\n            if (canSplit(nums, m, mid))\\n                right = mid-1;\\n            else\\n                left = mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n\\n    bool canSplit(vector<int>& nums, int m, ll sum) {\\n        int c = 1;\\n        ll s = 0;\\n        for (auto& num : nums) {\\n            s += num;\\n            if (s > sum) {\\n                s = num;\\n                ++c;\\n            }\\n        }\\n        return c <= m;\\n    }\\n\\n    int splitArray(vector<int>& nums, int m) {\\n        ll left = 0, right = 0;\\n        for (auto& num : nums) {\\n            left = max(left, (ll)num);\\n            right += num;\\n        }\\n        while (left <= right) {\\n            ll mid = left + (right-left)/2;\\n            if (canSplit(nums, m, mid))\\n                right = mid-1;\\n            else\\n                left = mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500748,
                "title": "c-4ms-easy-binary-search-solution-with-explanation",
                "content": "```\\nint splitArray(vector<int>& nums, int m) {\\n        if(nums.empty() || m==0) return 0;\\n        size_t left = 0, right = 0;\\n        for(size_t n : nums) {\\n            left = max(left, n); //highest number i.e the max it\\'ll go incase of m==nums.size()\\n            right += n; //total sum i.e the max it can go incase of m==1\\n        }\\n        if(m == nums.size()) return left; //edge case\\n        if(m == 1) return right; //edge case\\n        while(left < right) {//modified binary search w/ search space b/w highestnum...totalsum\\n            size_t mid = (left + right) / 2;\\n            size_t curr_bagsize = 0, curr_m = 1;\\n            for(auto n : nums) {\\n                if(curr_bagsize + n > mid) { //bag m is full, try the next bag now\\n                    curr_m++; \\n                    curr_bagsize = 0;\\n                }\\n                curr_bagsize += n;\\n            } \\n            if(curr_m > m) //we need a bigger bag size if curr_m > m\\n                left = mid + 1;\\n            else //current bag size is sufficient enough, so check for smaller bag sizes\\n                right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```\\n\\nComplexity :\\nTime - O(n log m), where m = binary search search space -> totalSum - highestNum\\n& n = number of non-negative integers in array nums\\nSpace - O(1) -> Inplace\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint splitArray(vector<int>& nums, int m) {\\n        if(nums.empty() || m==0) return 0;\\n        size_t left = 0, right = 0;\\n        for(size_t n : nums) {\\n            left = max(left, n); //highest number i.e the max it\\'ll go incase of m==nums.size()\\n            right += n; //total sum i.e the max it can go incase of m==1\\n        }\\n        if(m == nums.size()) return left; //edge case\\n        if(m == 1) return right; //edge case\\n        while(left < right) {//modified binary search w/ search space b/w highestnum...totalsum\\n            size_t mid = (left + right) / 2;\\n            size_t curr_bagsize = 0, curr_m = 1;\\n            for(auto n : nums) {\\n                if(curr_bagsize + n > mid) { //bag m is full, try the next bag now\\n                    curr_m++; \\n                    curr_bagsize = 0;\\n                }\\n                curr_bagsize += n;\\n            } \\n            if(curr_m > m) //we need a bigger bag size if curr_m > m\\n                left = mid + 1;\\n            else //current bag size is sufficient enough, so check for smaller bag sizes\\n                right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 89820,
                "title": "explanation-ruby-11-liner",
                "content": "I really like Ruby for binary search...\\n```\\ndef split_array(nums, m)\\n  (nums.max .. nums.inject(:+)).bsearch { |cap|\\n    subarrays = 0\\n    sum = cap\\n    nums.each { |num|\\n      if (sum += num) > cap\\n        sum = num\\n        subarrays += 1\\n      end\\n    }\\n    subarrays <= m\\n  }\\nend\\n```\\nIf we can do it with a certain cap like 9 in the example, we can of course also do it with any larger cap. Meaning we can use binary search. And we want to know the smallest cap possible.\\n\\nFor the binary search, we just need to be able to determine for a certain cap whether it's ok. Meaning whether we can split the array into m subarrays so that no subarray's sum is over this cap. To do that, we determine the **minimum** number of subarrays we can do with this cap. If it's smaller than or equal to m, this cap is ok. Wait, aren't we supposed to create **exactly** m subarrays? Yeah, but if we can do it with fewer, we can just split some up so we have exactly m.\\n\\nSo how to find the minimum number of subarrays we can do with a certain cap? We can do that greedily. Of course it's smart to stuff as many numbers into the first subarray as we can - then we don't need to try to fit them into the remaining subarrays. Same for the remaining subarrays - always stuff as many numbers into them as we can, only start a new subarray when the current number doesn't still fit into the previous subarray.\\n\\nThe initial range for possible caps is from the maximum in `nums` (because with a lower cap, we couldn't fit that number into any subarray) to the sum of `nums` (a larger cap would be useless - we'll never need more room than all numbers combined).",
                "solutionTags": [],
                "code": "```\\ndef split_array(nums, m)\\n  (nums.max .. nums.inject(:+)).bsearch { |cap|\\n    subarrays = 0\\n    sum = cap\\n    nums.each { |num|\\n      if (sum += num) > cap\\n        sum = num\\n        subarrays += 1\\n      end\\n    }\\n    subarrays <= m\\n  }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1102995,
                "title": "python-binary-search-with-comments-16-ms",
                "content": "```python\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        def split(nums, largest_sum):\\n            \"\"\"\\n            Given the largest_sum returns the number of pieces.\\n            \"\"\"\\n            pieces = 1\\n            tmp_sum = 0\\n            for num in nums:\\n                if tmp_sum + num > largest_sum:\\n                    tmp_sum = num\\n                    pieces += 1\\n                else:\\n                    tmp_sum += num\\n            return pieces\\n        \\n        # p is number of pieces for a given largest_sum\\n        # For p = len(nums) the largest_sum is max(nums)\\n        # for p = 1 the largest_sum is sum(nums)\\n        # We are looking for p=m, as we go from p=1 to p=len(nums) the \\n        # largest sum goes from max(nums) to sum(nums) - > search space\\n        low = max(nums) # m = len(nums)\\n        high = sum(nums) # m = 1\\n        # if pieces > m high is small\\n        while low < high:\\n            mid = low + (high - low) / 2\\n            pieces = split(nums, mid)\\n            if pieces > m: # the largest_sum is small, we have too many pieces and we can merge some of them\\n                low = mid + 1\\n            else:\\n                high = mid \\n        return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        def split(nums, largest_sum):\\n            \"\"\"\\n            Given the largest_sum returns the number of pieces.\\n            \"\"\"\\n            pieces = 1\\n            tmp_sum = 0\\n            for num in nums:\\n                if tmp_sum + num > largest_sum:\\n                    tmp_sum = num\\n                    pieces += 1\\n                else:\\n                    tmp_sum += num\\n            return pieces\\n        \\n        # p is number of pieces for a given largest_sum\\n        # For p = len(nums) the largest_sum is max(nums)\\n        # for p = 1 the largest_sum is sum(nums)\\n        # We are looking for p=m, as we go from p=1 to p=len(nums) the \\n        # largest sum goes from max(nums) to sum(nums) - > search space\\n        low = max(nums) # m = len(nums)\\n        high = sum(nums) # m = 1\\n        # if pieces > m high is small\\n        while low < high:\\n            mid = low + (high - low) / 2\\n            pieces = split(nums, mid)\\n            if pieces > m: # the largest_sum is small, we have too many pieces and we can merge some of them\\n                low = mid + 1\\n            else:\\n                high = mid \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89822,
                "title": "dp-o-nm-solution",
                "content": "The O(n^2m) DP solution to this problem is pretty obvious, where the transition function can be written as\\n`dp[i][j] = min{max{dp[k][j-1], subsum(k+1, i)}}, 0 <= k < i`\\nwhere `dp[i][j]` is the optimal result for splitting `nums[:i+1]` into `j` subarrays. And then for each i, j you would require O(n) time to find the k that minimizes `dp[i][j]`, which makes this an overall O(n^2m) algorithm..\\n\\nThe key to reducing time complexity down to O(nm) is the monotonic properties that `dp` and `subsum` hold. Mathematically I found myself hard to explain this well, but intuitively, if the last subarray for `dp[i][j]` is `nums[k], nums[k+1], ..., nums[i]`, then for `dp[i][j+1]` the last subarray would always be some `nums[k+x], ..., nums[i], x>=0`, because if you were cutting an array evenly into `j + 1` continuous subarray, the last subarray would always be smaller than it would had been using one less cut. So every time you find a `k` that minimizes `dp[i][j]` you only need to consider subarray starting from or after `k` when computing `dp[i][j+1]`. \\n\\n```python\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        n = len(nums)\\n        if not n:\\n            return 0\\n        pre_sum = [0] * (n + 1)\\n        for i in range(n):\\n            pre_sum[i + 1] = pre_sum[i] + nums[i]\\n        sub_sum = lambda i, j: pre_sum[j + 1] - pre_sum[i]\\n\\n        dp = [[0 for _ in range(m + 1)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][1] = pre_sum[i + 1]\\n            k = 0\\n            for j in range(2, min(m + 1, i + 2)):\\n                while k < i - 1 and max(dp[k][j-1], sub_sum(k+1, i)) > max(dp[k+1][j-1], sub_sum(k+2,i)):\\n                    k += 1\\n                dp[i][j] = max(dp[k][j - 1], sub_sum(k+1, i))\\n        return dp[n - 1][m]\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        n = len(nums)\\n        if not n:\\n            return 0\\n        pre_sum = [0] * (n + 1)\\n        for i in range(n):\\n            pre_sum[i + 1] = pre_sum[i] + nums[i]\\n        sub_sum = lambda i, j: pre_sum[j + 1] - pre_sum[i]\\n\\n        dp = [[0 for _ in range(m + 1)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][1] = pre_sum[i + 1]\\n            k = 0\\n            for j in range(2, min(m + 1, i + 2)):\\n                while k < i - 1 and max(dp[k][j-1], sub_sum(k+1, i)) > max(dp[k+1][j-1], sub_sum(k+2,i)):\\n                    k += 1\\n                dp[i][j] = max(dp[k][j - 1], sub_sum(k+1, i))\\n        return dp[n - 1][m]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476226,
                "title": "java-binary-search-intuition",
                "content": "**Intuition:**\\n\\n- Largest possible sum when `m` is equal to number of elements in array = Max element in the array => `Min` largest sum\\n- Largest possible sum when `m` is equal to 1 = Sum of all elements in the array => `Max` largest Sum\\n\\nThese 2 values ensure that for any given value of `m`, my final answer will definitely lie in between these 2 values. We\\'ll try to find the min largest sum between the computed `Min` and `Max` values. We can use the greedy technique using binary-search to find the min largest value. \\n\\nSo initially we start with the `mid` value (i.e. ((`Min` + `Max`) / 2)) and assume that this is the best possible answer by splitting the array into `m` parts that we can get to and greedily we try to find a value smaller than the `mid`.\\n\\nFor checking if the split criteria is satisfied along with the largest sum being within the `mid` value, we iterate through the array to see if the computed `sum` at any point of time is greater than `mid`. If at any point of time the computed `sum` is greater than the` mid` value then a new split is found and we increment a counter for calculating the total `splits` done. If the number of `splits` is less than or equal to `m`, it means we can still try to find a better answer by lowering the `Max` to `mid`, if not we need to increase the `Min` as the computed `mid` was too low for the largest sum.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        int start=0, end=0;\\n        \\n        for(int num : nums){\\n            start = Math.max(start, num);\\n            end += num;\\n        }\\n        \\n        int ans = start;\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            \\n            if (isPossibleSplitsFound(nums, mid, m)){\\n                ans = mid;\\n                end = mid - 1;\\n            } else start = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPossibleSplitsFound(int[] nums, int mid, int m){\\n        int sum=0;\\n        int splits=1;\\n        for (int num : nums){\\n            sum += num;\\n            if (sum > mid){\\n                sum = num;\\n                splits++;                    \\n            }\\n        }        \\n        return splits <= m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        int start=0, end=0;\\n        \\n        for(int num : nums){\\n            start = Math.max(start, num);\\n            end += num;\\n        }\\n        \\n        int ans = start;\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            \\n            if (isPossibleSplitsFound(nums, mid, m)){\\n                ans = mid;\\n                end = mid - 1;\\n            } else start = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPossibleSplitsFound(int[] nums, int mid, int m){\\n        int sum=0;\\n        int splits=1;\\n        for (int num : nums){\\n            sum += num;\\n            if (sum > mid){\\n                sum = num;\\n                splits++;                    \\n            }\\n        }        \\n        return splits <= m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427431,
                "title": "top-down-recursive-dp-c-solution-with-explanation",
                "content": "```long long solve(vector<int>& nums, int idx, int m)``` represents the solution when we want the solution starting from index ```idx``` and there are ```m``` splits left.\\n\\nIf ```m``` is the number of subsets, then it means that we have to make ```m - 1``` splits.\\n\\n```solve(nums, 0, m - 1)``` represents the answer from 0 to n - 1 with ```m - 1``` splits left.\\n\\n```\\nclass Solution {\\npublic:\\n    long long dp[1005][53];    \\n    \\n    long long solve(vector<int>& nums, int idx, int m) {\\n        // base condition\\n        long long ans = INT_MAX;  // Answer of the current state\\n        long long sum = 0;  // sum from idx to n - 1\\n        if(m == 0) {\\n\\t\\t// When there are 0 splits left, calculate the sum of the remaining potion of the given vector and return it.\\n            for(int j = idx; j < nums.size(); j++) {\\n                sum += nums[j];\\n            }\\n            return sum;\\n        }\\n        \\n        if(dp[idx][m] != -1) {\\n            return dp[idx][m];\\n        }\\n        \\n        \\n        for(int j = idx; j < nums.size(); j++) {\\n            sum += nums[j];\\n            ans = min(ans, max(sum, solve(nums, j + 1, m - 1)));\\n        }\\n        \\n        return dp[idx][m] = ans;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof dp);\\n        return solve(nums, 0, m - 1);\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```long long solve(vector<int>& nums, int idx, int m)```\n```idx```\n```m```\n```m```\n```m - 1```\n```solve(nums, 0, m - 1)```\n```m - 1```",
                "codeTag": "Unknown"
            },
            {
                "id": 1133417,
                "title": "java-clean-binary-search-dynamic-programming-solution-with-comments",
                "content": "It\\'s interesting that 1011. Capacity To Ship Packages Within D Days is a medium question while this one is marked as a hard one; Feel free to practice that one, too. \\n* [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/1133439/Java-Clean-Binary-Search-Solution-oror-with-comments)\\n\\n**Binary Search** Solution: \\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int left = nums[0], right = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            left = Math.max(left, nums[i]);\\n            right += nums[i];\\n        }\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (canSplit(nums, mid, m)) right = mid;\\n            else left = mid+1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    // can we split nums into m subarrays s.t. each subarray has sum <= amount\\n    public boolean canSplit(int[] nums, int amount, int m){\\n        int count = 1;\\n        int sum = 0;\\n        \\n        for (int num : nums) {\\n            if (sum + num <= amount) {\\n                sum += num;\\n                continue;\\n            }\\n            \\n            if (++count > m) return false;\\n            sum = num;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Dynamic Programming** Solution:  O(n * m)-Space  &  O(n^2 * m)-Time\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        \\n        int[] pfxSum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            pfxSum[i+1] = pfxSum[i] + nums[i];\\n        }\\n        \\n        // dp[i][j] : result for partition nums[0:i] into j part (for i in [0, n-1])\\n        // notice that partition into 0 part is not defined, namely dp[i][0] is never used for all i in [0,n-1]\\n        int[][] dp = new int[n][m+1];\\n        \\n        for (int i = 0; i < n; i++) Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < n; i++) {\\n            dp[i][1] = pfxSum[i+1];\\n        }\\n                \\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 2; j <= Math.min(m, i+1); j++) {\\n                // [0,i] into j part  <==> [0,k] into j-1 part  &  [k+1, i] into 1 part  for k in [0,i-1]\\n                for (int k = 0; k < i; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j-1], pfxSum[i+1] - pfxSum[k+1]));\\n                }\\n            }\\n        }\\n     \\n        return dp[n-1][m];        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int left = nums[0], right = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            left = Math.max(left, nums[i]);\\n            right += nums[i];\\n        }\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (canSplit(nums, mid, m)) right = mid;\\n            else left = mid+1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    // can we split nums into m subarrays s.t. each subarray has sum <= amount\\n    public boolean canSplit(int[] nums, int amount, int m){\\n        int count = 1;\\n        int sum = 0;\\n        \\n        for (int num : nums) {\\n            if (sum + num <= amount) {\\n                sum += num;\\n                continue;\\n            }\\n            \\n            if (++count > m) return false;\\n            sum = num;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        \\n        int[] pfxSum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            pfxSum[i+1] = pfxSum[i] + nums[i];\\n        }\\n        \\n        // dp[i][j] : result for partition nums[0:i] into j part (for i in [0, n-1])\\n        // notice that partition into 0 part is not defined, namely dp[i][0] is never used for all i in [0,n-1]\\n        int[][] dp = new int[n][m+1];\\n        \\n        for (int i = 0; i < n; i++) Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < n; i++) {\\n            dp[i][1] = pfxSum[i+1];\\n        }\\n                \\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 2; j <= Math.min(m, i+1); j++) {\\n                // [0,i] into j part  <==> [0,k] into j-1 part  &  [k+1, i] into 1 part  for k in [0,i-1]\\n                for (int k = 0; k < i; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j-1], pfxSum[i+1] - pfxSum[k+1]));\\n                }\\n            }\\n        }\\n     \\n        return dp[n-1][m];        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426487,
                "title": "python-4-approaches-dfs-dp-dp-binary-search-binary-search-greedy",
                "content": "**1. Brute Force:**\\nCheck all possible splitting plans to find the minimum largest value for subarrays.\\nWe can use depth-first search to generate all possible splitting plans. For every element in the array, we can either append it to the previous subarray or create a new subarray starting with that element (if the number of subarrays does not exceed m). The mimimum of largest subarray can be updated while generating those subarrays.\\n\\nTime: n to the m \\nSpace: n, due to recursive stack calls\\n\\n\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def dfs(i, cntSubarrays, curSum, curMax):\\n            if i == n and cntSubarrays == m:\\n                self.ans = min(self.ans, curMax)\\n                return \\n            if i == n:\\n                return\\n            if i > 0:\\n                dfs(i + 1, cntSubarrays, curSum + nums[i], max(curMax, curSum + nums[i]))\\n            if cntSubarrays < m:\\n                dfs(i + 1, cntSubarrays + 1, nums[i], max(curMax, nums[i]))\\n        n = len(nums)\\n        self.ans = float(\\'inf\\')\\n        dfs(0, 0, 0, 0)\\n        return self.ans\\n\\n```\\n\\n**2. DP(2 dimension):**\\n* Time: O(n * m * n) --> O(n^2 * m)\\n* Space: O(m * n)\\n\\n**1) without cache (passed 25/27 tests)**\\n\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        \\'\\'\\'\\n        dp[i][j] is the minimum largest subarray sum for splitting nums[0..i] into j parts.\\n        \\'\\'\\'\\n        dp = [[float(\\'inf\\') for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[0][0] = 0\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                for k in range(i):\\n                    \\'\\'\\'\\n                    dp[i][j] can be derived from max(f[k][j - 1], nums[k + 1] + ... + nums[i]).\\n                    For all valid index k, \\n                    f[i][j] should choose the minimum value of the above formula.\\n                    \\'\\'\\'\\n                    dp[i][j] = min(dp[i][j], max(dp[k][j-1], sum(nums[k:i]))) # here i == i + 1in nums\\n        return dp[n][m]       \\n```\\n\\n**2) with cache (passed 26/27 tests)**\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        dp = [[float(\\'inf\\') for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[0][0] = 0\\n\\t\\t# cache\\n\\t\\tsub = [0 for _ in range(n + 1)]\\n\\t\\tfor i in range(n):\\n\\t\\t\\tsub[i+1] = sub[i] + nums[i]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                for k in range(i):\\n                    dp[i][j] = min(dp[i][j], max(dp[k][j-1], sub[i] - sub[k])) \\n        return dp[n][m]      \\n```\\n**3) DP + Binary Search**\\n(1) since the min max sum of j splits depends on only the case j - 1 splits, we may reduce the space complexity from O(MN) to O(N). \\n(2) since the min max sum of nums[:k] must be <= to that of nums[:k+1] we can apply a binary search when updating the dp array. The time complexity is thus reduced from O(N^2 * m) to O(NlogN * m)\\'\\'\\'\\n        \\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        presum = [0] * (n + 1)\\n        for i in range(n):\\n            presum[i + 1] = presum[i] + nums[i] \\n        dp = list(presum)\\n        for j in range(1, m): # we do m - 1 splits on num[j + 1:n]\\n            for i in range(n, j, -1): # find where dp[k] = sum(nums[k:i]).\\n                # k ranges from j to i - 1\\n                l, r = j, i - 1\\n                while l <= r:\\n                    m = l + (r - l) // 2\\n                    if dp[m] >= presum[i] - presum[m]:\\n                        r = m - 1\\n                    else:\\n                        l = m + 1\\n                    dp[i] = min(max(dp[r], presum[i] - presum[r]), max(dp[l], presum[i] - presum[l]))\\n        return dp[-1]\\n         \\n```\\n\\n**3. Binary Search + Greedy**\\n\\nChinese: \\n\\u6211\\u4EEC\\u77E5\\u9053\\u7B54\\u6848\\u4E00\\u5B9A\\u5728\\u4E00\\u4E2A\\u8303\\u56F4\\u4E4B\\u5185\\uFF0C\\u8FD9\\u4E2A\\u8303\\u56F4\\u662F\\u4EC0\\u4E48\\u5462\\uFF1F\\n* \\u5047\\u8BBEm == n, \\u90A3\\u4E48\\u8FD9\\u4E2A\\u89E3\\u7684\\u8BDD\\u5C31\\u662F\\u6574\\u4E2A\\u6570\\u7EC4\\u4E2D\\u6700\\u5927\\u7684\\u5143\\u7D20\\u3002\\u56E0\\u4E3A\\u4E0D\\u53EF\\u80FD\\u6BD4\\u8FD9\\u4E2A\\u8FD8\\u8981\\u5C0F\\u4E86\\uFF0C\\u6240\\u4EE5\\u6570\\u7EC4\\u4E2D\\u6700\\u5927\\u7684\\u5143\\u7D20\\u662Fbinary search\\u7684lower bound\\u3002\\n\\t* l = max(nums)\\n* \\u8FD9\\u4E2AUppper bound\\u5C31\\u662F\\u628A\\u6574\\u4E2A\\u6570\\u7EC4\\u5212\\u5206\\u6210\\u4E00\\u7EC4\\uFF0C\\u5C31\\u662F\\u6574\\u4E2A\\u6570\\u7EC4\\u5143\\u7D20\\u7684\\u548C\\u3002\\n\\t* R = sum(nums) \\n\\n\\u77E5\\u9053\\u8FD9\\u4E2A\\u8303\\u56F4\\u540E\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u8FDB\\u884Cbinary search, \\u76F4\\u63A5\\u641C\\u7D22\\u8FD9\\u4E2A\\u89E3\\u662F\\u591A\\u5C11\\u3002\\n\\n\\u7ED9\\u5B9A\\u4E00\\u4E2Acandidate\\u89E3, C\\u3002\\u6211\\u4EEC\\u5C31\\u53BB\\u7B97\\u4E00\\u4E0B\\u6211\\u6700\\u5C11\\u80FD\\u591F\\u628A\\u8FD9\\u4E2A\\u6570\\u7EC4\\u5212\\u5206\\u6210\\u591A\\u5C11\\u7EC4\\uFF0C\\u4F7F\\u5F97\\u6BCF\\u4E00\\u7EC4\\u5143\\u7D20\\u7684\\u548C\\u4E0D\\u8D85\\u8FC7C\\u3002\\n\\n\\u90A3\\u6211\\u600E\\u4E48\\u53BB\\u5212\\u5206\\u7EC4\\u5462\\uFF1F\\u2014 Greedy\\n\\u5BF9\\u6BCF\\u4E00\\u4E2A\\u5143\\u7D20\\uFF0C\\u4ECE\\u5DE6\\u5F80\\u53F3\\u626B\\u63CF\\uFF0C\\u52A0\\u5230sum\\u5927\\u4E8EC\\u4E3A\\u6B62\\uFF0C\\u5982\\u679C\\u5B83\\u5927\\u4E8EC\\u7684\\u8BDD\\u6211\\u5C31\\u6362\\u4E00\\u4E2A\\u65B0\\u7684\\u7EC4\\u3002\\u8FD9\\u6837\\u6211\\u53EF\\u4EE5\\u786E\\u4FDD\\u6BCF\\u4E00\\u4E2Aconsecutive subarray\\u7684\\u548C\\u90FD\\u662F\\u5C0F\\u4E8E\\u7B49\\u4E8EC\\u7684\\uFF0C\\u4E00\\u65E6\\u5927\\u4E8EC\\u6211\\u5C31\\u7528\\u5F53\\u524Dnum\\u65B0\\u5F00\\u4E00\\u4E2A\\u7EC4\\u3002 \\u6700\\u540E\\u53D1\\u73B0\\u53EF\\u4EE5\\u5212\\u5206\\u6210k\\u7EC4\\u3002\\n\\nif k > m:  # c is too small\\n\\tl = C + 1\\nelse:\\n\\tr = C\\n\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        l, r = max(nums), sum(nums)\\n        while l < r:\\n            upperLimit = (l + r) // 2\\n            curSum, pieces = 0, 1\\n            for num in nums:\\n                curSum += num\\n                if curSum > upperLimit:\\n                    curSum = num\\n                    pieces += 1\\n            if pieces <= m: \\n                r = upperLimit\\n            else: \\n                l = upperLimit + 1\\n        return l \\n```\\n* Time: assume `S` represents `sum(nums)`, binary Seach\\u5FAA\\u73AF`log(S)`\\u6B21\\uFF0C\\u6BCF\\u4E00\\u6B21\\u5FAA\\u73AF\\u7684\\u8BDD\\u6211\\u9700\\u8981\\u53BB\\u626B\\u63CF\\u6574\\u4E2A\\u6570\\u7EC4\\u6765\\u628A\\u8FD9\\u4E9B\\u5143\\u7D20\\u5212\\u5206\\u5230\\u7EC4\\u91CC\\u9762\\u53BB\\uFF0C\\u6BCF\\u6B21\\u7684\\u65F6\\u95F4\\u662F`O(N)`\\u3002\\u6240\\u4EE5\\u603B\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u662F`O(N * log(S))`.\\n* Space: `O(1)`.\\n---------------\\nSimilar problems:\\n- https://leetcode.com/problems/first-bad-version/\\n\\t```\\n\\tdef firstBadVersion(self, n):\\n\\t\\tl, r = 1, n\\n\\t\\twhile l < r:\\n\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\tif isBadVersion(m):\\n\\t\\t\\t\\tr = m\\n\\t\\t\\telse:\\n\\t\\t\\t\\tl = m + 1\\n\\t\\treturn l \\n\\t```\\n\\n- https://leetcode.com/problems/reach-a-number/  (very similar)\\n\\n---------\\nRelated Problem:\\nhttps://leetcode.com/problems/divide-chocolate/discuss/427598/Python-Binary-Search",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def dfs(i, cntSubarrays, curSum, curMax):\\n            if i == n and cntSubarrays == m:\\n                self.ans = min(self.ans, curMax)\\n                return \\n            if i == n:\\n                return\\n            if i > 0:\\n                dfs(i + 1, cntSubarrays, curSum + nums[i], max(curMax, curSum + nums[i]))\\n            if cntSubarrays < m:\\n                dfs(i + 1, cntSubarrays + 1, nums[i], max(curMax, nums[i]))\\n        n = len(nums)\\n        self.ans = float(\\'inf\\')\\n        dfs(0, 0, 0, 0)\\n        return self.ans\\n\\n```\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        \\'\\'\\'\\n        dp[i][j] is the minimum largest subarray sum for splitting nums[0..i] into j parts.\\n        \\'\\'\\'\\n        dp = [[float(\\'inf\\') for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[0][0] = 0\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                for k in range(i):\\n                    \\'\\'\\'\\n                    dp[i][j] can be derived from max(f[k][j - 1], nums[k + 1] + ... + nums[i]).\\n                    For all valid index k, \\n                    f[i][j] should choose the minimum value of the above formula.\\n                    \\'\\'\\'\\n                    dp[i][j] = min(dp[i][j], max(dp[k][j-1], sum(nums[k:i]))) # here i == i + 1in nums\\n        return dp[n][m]       \\n```\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        dp = [[float(\\'inf\\') for _ in range(m + 1)] for _ in range(n + 1)]\\n        dp[0][0] = 0\\n\\t\\t# cache\\n\\t\\tsub = [0 for _ in range(n + 1)]\\n\\t\\tfor i in range(n):\\n\\t\\t\\tsub[i+1] = sub[i] + nums[i]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                for k in range(i):\\n                    dp[i][j] = min(dp[i][j], max(dp[k][j-1], sub[i] - sub[k])) \\n        return dp[n][m]      \\n```\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        presum = [0] * (n + 1)\\n        for i in range(n):\\n            presum[i + 1] = presum[i] + nums[i] \\n        dp = list(presum)\\n        for j in range(1, m): # we do m - 1 splits on num[j + 1:n]\\n            for i in range(n, j, -1): # find where dp[k] = sum(nums[k:i]).\\n                # k ranges from j to i - 1\\n                l, r = j, i - 1\\n                while l <= r:\\n                    m = l + (r - l) // 2\\n                    if dp[m] >= presum[i] - presum[m]:\\n                        r = m - 1\\n                    else:\\n                        l = m + 1\\n                    dp[i] = min(max(dp[r], presum[i] - presum[r]), max(dp[l], presum[i] - presum[l]))\\n        return dp[-1]\\n         \\n```\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        l, r = max(nums), sum(nums)\\n        while l < r:\\n            upperLimit = (l + r) // 2\\n            curSum, pieces = 0, 1\\n            for num in nums:\\n                curSum += num\\n                if curSum > upperLimit:\\n                    curSum = num\\n                    pieces += 1\\n            if pieces <= m: \\n                r = upperLimit\\n            else: \\n                l = upperLimit + 1\\n        return l \\n```\n```\\n\\tdef firstBadVersion(self, n):\\n\\t\\tl, r = 1, n\\n\\t\\twhile l < r:\\n\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\tif isBadVersion(m):\\n\\t\\t\\t\\tr = m\\n\\t\\t\\telse:\\n\\t\\t\\t\\tl = m + 1\\n\\t\\treturn l \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 226465,
                "title": "java-dp-solution-with-comments-improved-based-on-solution",
                "content": "I came up a solution which is very similar to Approach #1  in Solution, but I simplified with only one dp array, which makes base cases more clear. The basic algorithm is same, but I replace `int[] sub` with  `dp[i][1]`, which saves some space\\nTime  : O(n^2 * m), n = length of nums array\\nSpace: O(m * n)\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        if (nums.length == 1) return nums[0];\\n        \\n        // dp[i][j] is the minimum largest subarray sum for splitting nums[0..i] into j parts.\\n        int[][] dp = new int[nums.length][m+1];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        // Base case 1\\n        dp[0][1] = nums[0];\\n        \\n        // Base case 2 - dp[i][1] is the sum from nums[0] to nums[i]\\n        for (int i=1; i<nums.length; i++){\\n            dp[i][1] = dp[i-1][1] + nums[i];\\n        }\\n        \\n        if (m == 1) return dp[nums.length-1][1];\\n        \\n        for (int i=1; i<nums.length; i++)\\n            for (int j=2; j<=m; j++){\\n                for (int k=0; k<i; k++){\\n\\t\\t\\t\\t\\t//dp[i][j] - minimum largest subarray sum for splitting nums[0..i] into j parts\\n\\t\\t\\t\\t\\t// dp[i][1] - dp[k][1], sum between nums[k+1] to nums[i]\\n\\t\\t\\t\\t\\t//dp[k][j-1] - minimum largest subarray sum at index k when m = j-1\\n                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i][1] - dp[k][1], dp[k][j-1]));\\n                }\\n            }\\n        \\n        return dp[nums.length-1][m];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        if (nums.length == 1) return nums[0];\\n        \\n        // dp[i][j] is the minimum largest subarray sum for splitting nums[0..i] into j parts.\\n        int[][] dp = new int[nums.length][m+1];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        // Base case 1\\n        dp[0][1] = nums[0];\\n        \\n        // Base case 2 - dp[i][1] is the sum from nums[0] to nums[i]\\n        for (int i=1; i<nums.length; i++){\\n            dp[i][1] = dp[i-1][1] + nums[i];\\n        }\\n        \\n        if (m == 1) return dp[nums.length-1][1];\\n        \\n        for (int i=1; i<nums.length; i++)\\n            for (int j=2; j<=m; j++){\\n                for (int k=0; k<i; k++){\\n\\t\\t\\t\\t\\t//dp[i][j] - minimum largest subarray sum for splitting nums[0..i] into j parts\\n\\t\\t\\t\\t\\t// dp[i][1] - dp[k][1], sum between nums[k+1] to nums[i]\\n\\t\\t\\t\\t\\t//dp[k][j-1] - minimum largest subarray sum at index k when m = j-1\\n                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i][1] - dp[k][1], dp[k][j-1]));\\n                }\\n            }\\n        \\n        return dp[nums.length-1][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721066,
                "title": "javascript-fast-detail-explanation-clean-code-solution-with-binary-search",
                "content": "# Explanation\\n**DO CHECK COMMENTS FOR IN DETAIL QUESTION EXPLANATION**\\nQuestion says split the array into \"m\" parts such that we can minimize the largest sum among these subarray\\nfor eg if we have nums = [4 , 5 , 1 , 7, 9, 3, 2, 8] as array and we want to split it into m = 3 parts so lets consider in how many ways we can split this array into 3 parts,\\n1st - part 1 = [4], part 2 = [5, 1, 7, 9], part 3 = [3, 2, 8], largest part is 5 + 1 + 7 + 9 = 21\\n2nd - part 1 = [4, 5], part 2 = [1, 7, 9, 3], part 3 = [2, 8], largest part is 1 + 7 + 9 + 3 = 20\\nsimilary we can split this array into 3 parts as we wish but question says, we are splitting the array that is okay but we have a condition\\n# we want to split the array in such a way that the largest part we are getting should be minimum i.e in above two examples we got one largest part as 21 and in other 20, so there can be a way that we can split the array in such a way that largest part can be reduced.\\n\\n# Approach\\n1. Notice one thing, the largest part cannot be less than the maximum element of the array, why ? because no matter in how many pieces we want to split the array, 2 , 3 , 4 any number, but the maximum element from the array will lie in some part, so we can go as low as largest element of the array\\n2. Notice the max we can do is put every element of the array into one part, I know that would be invalid but this gives a hint that at max we can go sum of all the elements of the array\\n3. We got low, we got high, we can now apply binary search and see if we can achieve our result\\n\\n# How\\nApply binary search, we will get our mid, if we can split the array into \"m\" parts such that largest sub-array sum will be smaller than mid, then this can be our possible answer, not the final answer but a possible answer\\nIf this answer is possible, then we can try a smaller number and again check if it is possible to split the array into \"m\" parts such that largest sub-array sum will be smaller than mid and how we do that ? by putting high = mid - 1, if that thing is not possible that means we won\\'t be able to do that and we will require larger number so we will put low = mid + 1.\\n\\n\\n\\n\\n```\\nvar splitArray = function(nums, m) {\\n    let low = Math.max(...nums);\\n    let high = 0;\\n    let ans = 0;\\n    \\n    for(let num of nums) {\\n        high += num;\\n    }\\n    \\n    while(low <= high) {\\n        let mid = Math.floor(low + (high - low) / 2); // to prevent overflow\\n        \\n        if(isPossible(nums, mid, m)) {\\n            ans = mid;\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\nfunction isPossible(arr, mid, noOfParts) {\\n    let part = 1;\\n    let sum = 0;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        sum += arr[i];\\n        \\n        if(sum > mid) {\\n            part++;\\n            sum = arr[i];\\n        }\\n    }\\n    return part <= noOfParts; \\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f7a5e1d4-ddd3-427a-a45e-5dc61108dc08_1643215593.684427.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar splitArray = function(nums, m) {\\n    let low = Math.max(...nums);\\n    let high = 0;\\n    let ans = 0;\\n    \\n    for(let num of nums) {\\n        high += num;\\n    }\\n    \\n    while(low <= high) {\\n        let mid = Math.floor(low + (high - low) / 2); // to prevent overflow\\n        \\n        if(isPossible(nums, mid, m)) {\\n            ans = mid;\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\nfunction isPossible(arr, mid, noOfParts) {\\n    let part = 1;\\n    let sum = 0;\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        sum += arr[i];\\n        \\n        if(sum > mid) {\\n            part++;\\n            sum = arr[i];\\n        }\\n    }\\n    return part <= noOfParts; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 722980,
                "title": "c-top-down-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1001][51];\\n    \\n    int ff(vector<int>& nums, int m, int i) {\\n        \\n        if (i == nums.size() && m == 0) return 0;\\n        if (i == nums.size() || m == 0) return INT_MAX;\\n        if (dp[i][m] != -1) return dp[i][m];\\n        \\n        int final_ans = INT_MAX;\\n        \\n        for (int idx=i; idx < nums.size(); idx++) {\\n            int res = nums[idx] - ((i - 1 >= 0) ? nums[i - 1] : 0);\\n            int t = ff(nums, m - 1, idx + 1);\\n            final_ans = min(final_ans, max(res, t));\\n        }\\n        \\n        return dp[i][m] = final_ans;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i=0; i < nums.size(); i++) {\\n            if (nums[i] == INT_MAX) return INT_MAX;\\n            nums[i] += (i - 1 >= 0) ? nums[i - 1] : 0;\\n        }\\n        return ff(nums, m, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[1001][51];\\n    \\n    int ff(vector<int>& nums, int m, int i) {\\n        \\n        if (i == nums.size() && m == 0) return 0;\\n        if (i == nums.size() || m == 0) return INT_MAX;\\n        if (dp[i][m] != -1) return dp[i][m];\\n        \\n        int final_ans = INT_MAX;\\n        \\n        for (int idx=i; idx < nums.size(); idx++) {\\n            int res = nums[idx] - ((i - 1 >= 0) ? nums[i - 1] : 0);\\n            int t = ff(nums, m - 1, idx + 1);\\n            final_ans = min(final_ans, max(res, t));\\n        }\\n        \\n        return dp[i][m] = final_ans;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i=0; i < nums.size(); i++) {\\n            if (nums[i] == INT_MAX) return INT_MAX;\\n            nums[i] += (i - 1 >= 0) ? nums[i - 1] : 0;\\n        }\\n        return ff(nums, m, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405801,
                "title": "python-binary-search-solution-with-inline-explanation",
                "content": "Credits to the author(s) who posted the solution in the `Solution` section. All I am doing here is to provide a perspective in a hope to shed light on the solution.\\n\\n```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        \"\"\"\\n        The goal is to find the minimum largest subarray sum among the `m` \\n        splits from the given array. Obviously, that sum must fall in the range \\n        of [max(nums), sum(nums)] - the minimum sum is at least `max(nums)` when\\n        the max number in the array is a subarray by itself; the maximum sum is \\n        the sum of the whole array when `m == 1`. Herein, the goal is to search \\n        for the minimum largest subarray sum among `m` splits of the given array \\n        in this range.\\n        \\n        The strategy is to find a largest subarray sum tentatively and check \\n        if the sum allows us to divide the given array into `m` splits. \\n        Intuitively, we can use binary search and adjust the bounds accordingly \\n        - if we have more than `m` splits, that means the current sum is too \\n        small and forces more splits in order to keep each subarray sum smaller \\n        than or equal to it, therefore we need to increase the lower bound to \\n        find a larger sum; if we have fewer than `m` splits, that means the \\n        subarray sum is too large and there is room to further split certain \\n        subarray(s) and decrease the largest subarray sum, thus we need to \\n        decrease the upper bound to find a smaller sum; if we have `m` splits \\n        even, there is still room for decreasing the sum, since the split \\n        pattern may not necessarily be optimal, e.g., there could be a gigantic \\n        subarray with a huge sum and others with small sums, therefore we can \\n        further decrease the upper bound to find a smaller sum tentatively until\\n        the bounds meet. \\n        \"\"\"\\n        # lower and upper bound of the largest subarray sum\\n        lo, hi = max(nums), sum(nums)\\n\\n        res = hi\\n        while lo <= hi:\\n            # find a tentaive sum\\n            mid = (lo + hi)//2\\n            # start with a single subarray, which is the entire given array,\\n            # keep adding the numbers in the array to the sum to determine if a \\n            # split should be done\\n            sum_, count = 0, 1\\n            for n in nums:\\n                # when the sum is greater than the tentative sum, a split is \\n                # required to keep the subarray sum smaller than the tentative \\n                # sum\\n                if sum_ + n > mid:\\n                    # reset the sum to the current number in the array\\n                    sum_ = n\\n                    # increment the number of splits by 1 since a split is done\\n                    count += 1\\n                # otherwise, keep adding the numbers to the sum\\n                else:\\n                    sum_ += n\\n            # when the number of splits is fewer than or equal to `m`, decrease \\n            # the upper bound to decrease the largest subarray sum\\n            if count <= m:\\n                res = min(res, mid)\\n                hi = mid - 1\\n            # otherwise, increase the lower bound to ensure there are no more \\n            # than `m` splits required\\n            else:\\n                lo = mid + 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        \"\"\"\\n        The goal is to find the minimum largest subarray sum among the `m` \\n        splits from the given array. Obviously, that sum must fall in the range \\n        of [max(nums), sum(nums)] - the minimum sum is at least `max(nums)` when\\n        the max number in the array is a subarray by itself; the maximum sum is \\n        the sum of the whole array when `m == 1`. Herein, the goal is to search \\n        for the minimum largest subarray sum among `m` splits of the given array \\n        in this range.\\n        \\n        The strategy is to find a largest subarray sum tentatively and check \\n        if the sum allows us to divide the given array into `m` splits. \\n        Intuitively, we can use binary search and adjust the bounds accordingly \\n        - if we have more than `m` splits, that means the current sum is too \\n        small and forces more splits in order to keep each subarray sum smaller \\n        than or equal to it, therefore we need to increase the lower bound to \\n        find a larger sum; if we have fewer than `m` splits, that means the \\n        subarray sum is too large and there is room to further split certain \\n        subarray(s) and decrease the largest subarray sum, thus we need to \\n        decrease the upper bound to find a smaller sum; if we have `m` splits \\n        even, there is still room for decreasing the sum, since the split \\n        pattern may not necessarily be optimal, e.g., there could be a gigantic \\n        subarray with a huge sum and others with small sums, therefore we can \\n        further decrease the upper bound to find a smaller sum tentatively until\\n        the bounds meet. \\n        \"\"\"\\n        # lower and upper bound of the largest subarray sum\\n        lo, hi = max(nums), sum(nums)\\n\\n        res = hi\\n        while lo <= hi:\\n            # find a tentaive sum\\n            mid = (lo + hi)//2\\n            # start with a single subarray, which is the entire given array,\\n            # keep adding the numbers in the array to the sum to determine if a \\n            # split should be done\\n            sum_, count = 0, 1\\n            for n in nums:\\n                # when the sum is greater than the tentative sum, a split is \\n                # required to keep the subarray sum smaller than the tentative \\n                # sum\\n                if sum_ + n > mid:\\n                    # reset the sum to the current number in the array\\n                    sum_ = n\\n                    # increment the number of splits by 1 since a split is done\\n                    count += 1\\n                # otherwise, keep adding the numbers to the sum\\n                else:\\n                    sum_ += n\\n            # when the number of splits is fewer than or equal to `m`, decrease \\n            # the upper bound to decrease the largest subarray sum\\n            if count <= m:\\n                res = min(res, mid)\\n                hi = mid - 1\\n            # otherwise, increase the lower bound to ensure there are no more \\n            # than `m` splits required\\n            else:\\n                lo = mid + 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135212,
                "title": "javascript-solution-beats-100-runtime-56ms-use-binary-search",
                "content": "#### Four steps:\\n1. let max = sum(nums)\\n2. let min = Math.max(...nums)\\n3. **binary search (min, max)**, to find out **the smallest number** that can divide nums into m parts and every part\\'s sum is less or equal to **this smallest number**;\\n4. define the function to verify: if to divide the array into m parts and every part\\'s sum is not larger than target is possible;\\n   **verify(nums, m, target)** return false in two kinds of situations:\\n\\t *  after divide nums into m groups and make sure the sum of each group is no larger than target, there are still elements left;\\n\\t *  nums.length < m\\n\\n```\\nvar splitArray = function(nums, m) {\\n    let max = nums.reduce((a,b)=>a+b,0);\\n    let min = Math.max(...nums);\\n\\n    function verify(array, m, target){\\n    \\tlet len = array.length;\\n    \\tif(len<m) return false;\\n    \\tlet count=1, i=0, sum=0;  //pay attention: count=1\\n    \\tfor(let i=0; i<len; i++){\\n    \\t\\tsum += array[i];\\n    \\t\\tif(sum>target){\\n    \\t\\t\\tsum = array[i];\\n    \\t\\t\\tcount++;\\n    \\t\\t\\tif(count>m) return false;\\n    \\t\\t}\\n    \\t}\\n    \\treturn true;\\n    }\\n\\n    while(min<=max){\\n    \\tlet mid = Math.floor((min+max)/2);\\n    \\tif(verify(nums, m, mid)) max=mid-1;\\n    \\telse min=mid+1;\\n    }\\n    return min;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar splitArray = function(nums, m) {\\n    let max = nums.reduce((a,b)=>a+b,0);\\n    let min = Math.max(...nums);\\n\\n    function verify(array, m, target){\\n    \\tlet len = array.length;\\n    \\tif(len<m) return false;\\n    \\tlet count=1, i=0, sum=0;  //pay attention: count=1\\n    \\tfor(let i=0; i<len; i++){\\n    \\t\\tsum += array[i];\\n    \\t\\tif(sum>target){\\n    \\t\\t\\tsum = array[i];\\n    \\t\\t\\tcount++;\\n    \\t\\t\\tif(count>m) return false;\\n    \\t\\t}\\n    \\t}\\n    \\treturn true;\\n    }\\n\\n    while(min<=max){\\n    \\tlet mid = Math.floor((min+max)/2);\\n    \\tif(verify(nums, m, mid)) max=mid-1;\\n    \\telse min=mid+1;\\n    }\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715665,
                "title": "c-binary-search-simple-approach",
                "content": "**Please upvote if you find helpful:)**\\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int sum=0, maxi=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n            maxi=max(maxi, nums[i]);\\n        }\\n        int low=maxi, high=sum;\\n        while(low<=high)\\n        {\\n            int s=0, d=1;\\n            int mid=low+(high-low)/2;\\n            for(int i=0; i<nums.size(); i++)\\n            {\\n                s+=nums[i];\\n                if(s>mid)\\n                {\\n                    d++;\\n                    s=nums[i];\\n                }\\n            }\\n            if(d<=m)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int sum=0, maxi=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n            maxi=max(maxi, nums[i]);\\n        }\\n        int low=maxi, high=sum;\\n        while(low<=high)\\n        {\\n            int s=0, d=1;\\n            int mid=low+(high-low)/2;\\n            for(int i=0; i<nums.size(); i++)\\n            {\\n                s+=nums[i];\\n                if(s>mid)\\n                {\\n                    d++;\\n                    s=nums[i];\\n                }\\n            }\\n            if(d<=m)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460481,
                "title": "binary-search-approach-how-can-we-figure-out-that-we-can-apply-a-binary-search-in-this-problem",
                "content": "Given an array=[7,2,5,10,8], m=2, We need to find a sum by dividing the array into m partitions. Sum here is the max sum of m partitions. Now its mentioned that you have to come up with a partition such that the sum obtained is min.\\n\\neg. possible m=2 partitions are:\\n==> [7,2,5,10] and [8]       sum1=24 and sum2=8  Therefor maxsum=24\\n==> [7,2,5] and [10,8]       sum1=12 and sum2=18  maxsum=18\\n==> [7,2] and [5,10,8]       maxsum=23\\n==> [7] and [2,5,10,8]       maxsum=25\\n\\nso out of all these, min mxsum =18 results from the following partition scheme [7,2,5] and [10,8]\\n\\nHow can one figure out the solution. How can we reach to this mxsum??\\n\\nfacts:\\n1. maxpossible mxsum can be obtained if #partition==1 i.e sum(arr)\\n2. minpossible mxsum can be obtained if #partition==len(arr) so now minsum=max(arr)\\n\\nso the required mxsum will definitely lie between max(arr) and sum(arr)\\n=> now the problem becomes - We need to search mxsum in given range ensuring that this mxsum results in m partitions. (hint gets triggered: binary search can be applied now)\\n\\n```\\nl=max(arr)\\nr=sum(arr)\\nwhile l<r:\\n          mid=l+(r-l)//2\\n\\t\\t  #lets check if mid is the mxsum. make sure that partitions possible for this mxsum==m\\n\\t\\t  partitions=get_partitions(mid)\\n\\t\\t  \"\"\"\\n\\t\\t  def get_partitions(mxsum):\\n\\t\\t\\t\\t  count=1\\n\\t\\t\\t\\t  s=0\\n\\t\\t\\t\\t  for el in arr:\\n\\t\\t\\t\\t\\t  s+=el\\n\\t\\t\\t\\t\\t  if s>mxsum:\\n\\t\\t\\t\\t\\t\\t  count+=1\\n\\t\\t\\t\\t\\t\\t  s=el\\n\\t\\t\\t\\treturn count\\t\\t\\t\\t  \\n```\\n\\t\\t\\n\\t\\t#if no of partitions are less than m, then that means that we need to decrease mxsum. Also if partitions==m, make sure that mxsum is the min mxsum we can obtain\\n\\t\\tif partitions<=m:\\n\\t\\t\\tr=mid\\n\\t\\telse:\\n\\t\\t\\tl=mid+1         #if partitions are greater than m, increase the mxsum\\n\\n#while loop breaks when l==r==mid and thats the point where we find our required mxsum\\n\\n\\treturn l\\n\\t\\nThe time complexity is O(log(sumOfArray - max) * n)\\n\\nspace complexity= O(1)\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nl=max(arr)\\nr=sum(arr)\\nwhile l<r:\\n          mid=l+(r-l)//2\\n\\t\\t  #lets check if mid is the mxsum. make sure that partitions possible for this mxsum==m\\n\\t\\t  partitions=get_partitions(mid)\\n\\t\\t  \"\"\"\\n\\t\\t  def get_partitions(mxsum):\\n\\t\\t\\t\\t  count=1\\n\\t\\t\\t\\t  s=0\\n\\t\\t\\t\\t  for el in arr:\\n\\t\\t\\t\\t\\t  s+=el\\n\\t\\t\\t\\t\\t  if s>mxsum:\\n\\t\\t\\t\\t\\t\\t  count+=1\\n\\t\\t\\t\\t\\t\\t  s=el\\n\\t\\t\\t\\treturn count\\t\\t\\t\\t  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1534776,
                "title": "c-binary-search-100-faster",
                "content": "```\\nbool check(int bar, int m, vector<int> &nums) {\\n\\n    int count = 0, sum = 0;\\n    for (auto it : nums){\\n        sum += it;\\n        if (sum == bar) { count++; sum = 0; }\\n        else if (sum > bar) {count++; sum = it; }\\n    }\\n    if (sum > 0) count++;\\n    if (count <= m) return true;\\n    return false;\\n}\\n\\nint splitArray(vector<int> &nums, int m) {\\n\\n    int beg = INT_MIN, end = 0, ans;\\n    for (auto it : nums) {\\n        end += it;\\n        if (it > beg) beg = it;\\n    }\\n    while (beg <= end) {\\n        int mid = beg + (end - beg) / 2;\\n        if (check(mid, m, nums)){\\n            ans = mid;\\n            end = mid - 1;\\n        }\\n        else beg = mid + 1;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool check(int bar, int m, vector<int> &nums) {\\n\\n    int count = 0, sum = 0;\\n    for (auto it : nums){\\n        sum += it;\\n        if (sum == bar) { count++; sum = 0; }\\n        else if (sum > bar) {count++; sum = it; }\\n    }\\n    if (sum > 0) count++;\\n    if (count <= m) return true;\\n    return false;\\n}\\n\\nint splitArray(vector<int> &nums, int m) {\\n\\n    int beg = INT_MIN, end = 0, ans;\\n    for (auto it : nums) {\\n        end += it;\\n        if (it > beg) beg = it;\\n    }\\n    while (beg <= end) {\\n        int mid = beg + (end - beg) / 2;\\n        if (check(mid, m, nums)){\\n            ans = mid;\\n            end = mid - 1;\\n        }\\n        else beg = mid + 1;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804362,
                "title": "2-solutions-binary-search-and-dp-in-c-with-explanation-and-comments",
                "content": "**Binary Search Soltn***(4 ms,70% beat)*\\n*->the idea is that min max sum will lie in the range (max(nums[i]),sum(nums[i])) for(i=0 to n)\\n->every time we find avg of this range and see how many intervals\\' sum exceed the avg\\n->if there are more than \"m\" intervals, then we need to increase the bar becoz many intervals are demanding to get separated\\n->if they are less than \"m\", then we need to lower the bar becoz very few intervals are willing to get separated\\n->we will keep doing this until if reach a postn when exactly \"m\" intervals will get separated\\n->at this point we will obvsly have lower bar=upper bar*\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleToReachHigh(vector<int>& nums, int& m,int mid){\\n        long long int n=nums.size(),count=1,sum=0;\\n        for(int i=0;i<n;i++){\\n            if(sum+nums[i]<=mid) sum+=nums[i];\\n            else{\\n                count++;\\n                sum=nums[i];\\n                if(count>m) return true; //more than \"m\" intervals want to get separated\\n            }\\n        }\\n        return false; //fewer than \"m\" intervals want to get separated\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int n=nums.size();\\n        long long int low=INT_MIN,high=0,mid;\\n        for(int i=0;i<n;i++){\\n            low=max(low,(long long int) (nums[i]));\\n            high+=nums[i];\\n        }\\n        while(low<high){\\n            mid=low+(high-low)/2;\\n            if(isPossibleToReachHigh(nums,m,mid)) //increase the bar\\n                low=mid+1;\\n            else high=mid; //lower the bar\\n        }\\n        return low;\\n    }\\n};\\n```\\n**DP soltn** *(276 ms!!!) (beats 20% )\\n->the idea is to keep a track of min max sum for suffix arrays\\n->dp[i][j]= minimum max sum possible from i to n-1 with exacty j partitions\\n->the last element can have atmost one partition and likewise properties for other elems should be kept in mind\\n->for 1<=i<n, we need to calculate dp[i][j] only for j=1 to m-1, becoz we wont divide any array in this range in m parts in final answer\\n->we need to return dp[0][m]*\\n   ``` \\n   class Solution {\\n    public:\\n        int splitArray(vector<int>& nums, int m) {\\n            long long int runningsum, n=nums.size();\\n            vector<long long int> sums(n,0);\\n            runningsum=sums[n-1]=nums[n-1];\\n            for(int i=n-2;i>=0;i--){\\n                runningsum+=nums[i];\\n                sums[i]=runningsum;\\n            }\\n            if(m==1) return sums[0];\\n            vector<vector<long long int>> dp(n,vector<long long int>(m+1,2147483648));\\n            dp[n-1][1]=nums[n-1];    //initialisation\\n            for(int i=n-2;i>0;i--){\\n                int j=1;             //start calculating for all m in possible range\\n                while(j<m&&j<=n-i){\\n                    if(j==1) dp[i][1]=sums[i]; //no partition\\n                    else{\\n                        for(int k=i+1;k<n;k++){ // deciding on numb of elems to be include in the set with starting elem\\n                            dp[i][j]=min(v[i][j],(max(sums[i]-sums[k],dp[k][j-1]))); \\n                        }\\n                    }\\n                    j++;\\n                }\\n            }\\n            for(int k=1;k<n;k++){\\n                dp[0][m]=min(max(sums[0]-sums[k],dp[k][m-1]),v[0][m]);\\n            }\\n            return v[0][m];\\n        }\\n    };\\n\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossibleToReachHigh(vector<int>& nums, int& m,int mid){\\n        long long int n=nums.size(),count=1,sum=0;\\n        for(int i=0;i<n;i++){\\n            if(sum+nums[i]<=mid) sum+=nums[i];\\n            else{\\n                count++;\\n                sum=nums[i];\\n                if(count>m) return true; //more than \"m\" intervals want to get separated\\n            }\\n        }\\n        return false; //fewer than \"m\" intervals want to get separated\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int n=nums.size();\\n        long long int low=INT_MIN,high=0,mid;\\n        for(int i=0;i<n;i++){\\n            low=max(low,(long long int) (nums[i]));\\n            high+=nums[i];\\n        }\\n        while(low<high){\\n            mid=low+(high-low)/2;\\n            if(isPossibleToReachHigh(nums,m,mid)) //increase the bar\\n                low=mid+1;\\n            else high=mid; //lower the bar\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898788,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\nhey every one, i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search, this question is the part of that playlist:\\n\\nhttps://youtu.be/FkNz59urgto\\n\\nPlaylist link: \\nhttps://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool predicate(vector<int>& nums, int k,int th){\\n        int temp_k=1;\\n        int total=0;\\n        for(auto num:nums){\\n            total+= num;\\n            if(total>th){\\n                total=num;\\n                temp_k++;\\n                if(temp_k>k){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int splitArray(vector<int>& nums, int k) {\\n        int l= *max_element(nums.begin(),nums.end());\\n        int r= accumulate(nums.begin(),nums.end(),0);\\n\\n        while(l<r){\\n            int m = l +(r-l)/2;\\n            if(predicate(nums,k,m)){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool predicate(vector<int>& nums, int k,int th){\\n        int temp_k=1;\\n        int total=0;\\n        for(auto num:nums){\\n            total+= num;\\n            if(total>th){\\n                total=num;\\n                temp_k++;\\n                if(temp_k>k){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int splitArray(vector<int>& nums, int k) {\\n        int l= *max_element(nums.begin(),nums.end());\\n        int r= accumulate(nums.begin(),nums.end(),0);\\n\\n        while(l<r){\\n            int m = l +(r-l)/2;\\n            if(predicate(nums,k,m)){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899567,
                "title": "java-easy-to-understand-binary-search-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int low = 0,high=0;\\n        for(int i:nums)\\n        {\\n            low = Math.max(low,i);\\n            high += i;\\n        }\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(isPossible(nums,m,mid))\\n            {\\n                high = mid-1;\\n            }\\n            else    low = mid+1;\\n        }\\n        return low;\\n    }\\n    boolean isPossible(int[] nums,int m,int limit)\\n    {\\n        int count = 1,sum=0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum += nums[i];\\n            if(sum > limit)\\n            {\\n                count++;\\n                sum = nums[i];\\n                if(count > m)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int low = 0,high=0;\\n        for(int i:nums)\\n        {\\n            low = Math.max(low,i);\\n            high += i;\\n        }\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            if(isPossible(nums,m,mid))\\n            {\\n                high = mid-1;\\n            }\\n            else    low = mid+1;\\n        }\\n        return low;\\n    }\\n    boolean isPossible(int[] nums,int m,int limit)\\n    {\\n        int count = 1,sum=0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum += nums[i];\\n            if(sum > limit)\\n            {\\n                count++;\\n                sum = nums[i];\\n                if(count > m)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819170,
                "title": "6-questions-in-one-template-of-binary-search-for-beginners-python",
                "content": "6 questions in one template of binary search - for beginners! - python\\n\\n**Method:**\\n1. left - inclusive; right - exclusive\\n2. use while left < right\\n3. if finding min value, define \\'isok\\' function (and return left) ; \\n4. if finding max value, define \\'isfail\\' function (and return left-1).\\n\\nIn Chinese:\\n\\n1. \\u5DE6\\u95ED\\u53F3\\u5F00\\uFF1B\\n2. \\u4F7F\\u7528left < right\\n3. binary search\\u662F\\u7528\\u6765\\u67E5\\u627E\\u6700\\u5C0F\\u503C\\u7684\\uFF0C\\u5982\\u679C\\u9898\\u76EE\\u662F\\u5BFB\\u627E\\u6700\\u5C0F\\u503C\\uFF0C\\u90A3\\u5C31\\u76F4\\u63A5\\u8FD4\\u56DEleft\\uFF1B\\n4. \\u5982\\u679C\\u9898\\u76EE\\u8981\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF0C\\u90A3\\u5B9A\\u4E49\\u4E00\\u4E2Aisfail\\u51FD\\u6570\\uFF0C\\u5E76\\u627E\\u8BA9isfail\\u8FD4\\u56DEtrue\\u7684\\u6700\\u5C0F\\u7684left\\uFF0C\\u8FD9\\u6837\\u7684\\u8BDD\\uFF0Cleft-1\\u5C31\\u662F\\u6211\\u4EEC\\u8981\\u6C42\\u7684\\u6700\\u5927\\u7684\\u6EE1\\u8DB3\\u6761\\u4EF6\\u7684\\u503C\\u4E86\\u3002\\n\\n\\n**1011. Capacity To Ship Packages Within D Days**\\n\\nMedium\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nShare\\nA conveyor belt has packages that must be shipped from one port to another within D days.\\n\\nThe i-th package on the conveyor belt has a weight of weights[i].  Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\\n\\nExample 1:\\n\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n\\'\\'\\'\\n\\n```\\n# # looking for a min value, then build a \\'isok\\' function and directly use binary search to \\n# find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode1011:\\n    def shipWithinDays(self, weights, D):\\n        # binary search\\n        # min weight capacity of the ship\\n        \\n        def isok(mid):\\n            # real days needed with max weight capacity of mid\\n            day = 1\\n            cursum = 0\\n            for weight in weights:\\n                if cursum + weight > mid:\\n                    day += 1\\n                    cursum = 0\\n                cursum += weight\\n            return day <= D\\n        \\n        left = max(weights) # note that this should be max(weights), not min(weights)!!\\n        right = sum(weights) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n\\n**1231. Divide Chocolate**\\n\\nHard\\nhttps://leetcode.com/problems/divide-chocolate/\\n\\nYou have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness.\\n\\nYou want to share the chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts, each piece consists of some consecutive chunks.\\n\\nBeing generous, you will eat the piece with the minimum total sweetness and give the other pieces to your friends.\\n\\nFind the maximum total sweetness of the piece you can get by cutting the chocolate bar optimally.\\n\\nExample 1:\\n\\nInput: sweetness = [1,2,3,4,5,6,7,8,9], K = 5\\nOutput: 6\\nExplanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]\\n\\n```\\n# point: looking for max value, then build a \"fail\" function,\\n# and use binary search to find the min \\'left\\' that let fail(left) return True.\\n# then, left-1 is the max value to let fail(left-1) return False (i.e., not_fail(left-1) is true)!\\nclass Solution_Leetcode1231(object):\\n    def maximizeSweetness(self, sweetness, K):\\n        # binary search method is for looking for the MIN value! so, we find the min value (left) that fail\\n        # then left-1 is the max value that success!\\n        # look for max value, find the min value that fail, and then min.value - 1 is the result of success\\n        \\n        left = min(sweetness)\\n        right = sum(sweetness)+ 1\\n        \\n        def fail(mid):\\n            pieces = 0\\n            cursum = 0\\n            for sweet in sweetness:\\n                cursum += sweet\\n                if cursum >= mid:\\n                    # then current piece is ensure to be >= mid, we can start a new piece\\n                    pieces += 1\\n                    cursum = 0\\n            return pieces < K+1\\n        \\n        while left < right:\\n            mid = left+ (right-left)//2\\n            if fail(mid): # the result \\'left\\' is the min value that let fail(left)=True!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1\\n```        \\n\\nhttps://leetcode.com/problems/split-array-largest-sum/\\n**410. Split Array Largest Sum**\\n\\nHard\\nGiven an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\\n\\nWrite an algorithm to minimize the largest sum among these m subarrays.\\n\\nExample 1:\\n\\nInput: nums = [7,2,5,10,8], m = 2\\nOutput: 18\\nExplanation:\\nThere are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8],\\nwhere the largest sum among the two subarrays is only 18.\\n\\'\\'\\'\\n```\\n# looking for a min value, then build a \\'isok\\' function and directly use binary search,\\n# to find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode410(object):\\n    def splitArray(self, nums, m):\\n        # binary search\\n        # make a guess and then check how many subarrays x; if x > m, the guess is too big; else, the guess is too small\\n        left = max(nums)\\n        right = sum(nums) + 1\\n        \\n        def isok(mid): # or, you can change \\'isok\\' name into \\'is_mid_too_big\\'\\n            # all subarray\\'s sum <= mid\\n            setcount = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num> mid:\\n                    setcount += 1\\n                    cursum = 0\\n                cursum += num\\n            return setcount <= m # this is <=, not >=! which is very important!\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid): # is_mid_too_big, and we do not have enough subset when separating under mid, so we should make mid smaller!\\n                # or, think extremelly, if mid=2**31-1, then all numbers are in one subset, 1 <= m, so we should make mid smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\nclass Solution_leetcode410_2(object):\\n    def splitArray(self, nums, m):\\n        # use binary search - it is finding the min value!\\n        # find the min sum value such that for the m sbusets of nums, sum of a subset <= x\\n        \\n        left = max(nums)\\n        right = sum(nums)\\n        \\n        def subsetnum(mid):\\n            setnum = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num > mid:  # \\u8F6C\\u6362\\u601D\\u60F3\\uFF1A\\u672C\\u6765\\u662F\\u7ED9\\u5B9Am\\u4E2A\\u5B50\\u96C6\\uFF0C\\u6C42\\u5F97\\u662F\\u5B50\\u96C6\\u548C\\u5F97\\u6700\\u5927\\u503C\\u3002\\n\\t\\t\\t\\t\\t# \\u6211\\u4EEC\\u53CD\\u8FC7\\u6765\\uFF0C\\u5148\\u6307\\u5B9A\\u5B50\\u96C6\\u7684\\u548C\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u7136\\u540E\\u53BB\\u53CD\\u63A8\\u80FD\\u80FD\\u591F\\u5206\\u6210\\u591A\\u5C11\\u4E2A\\u5B50\\u96C6\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570>m\\uFF0C\\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5C0F\\u4E86\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570< m, \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\n\\t\\t\\t\\t\\t# \\uFF08\\u8003\\u8651\\u731C\\u6D4B\\u4E3A\\u65E0\\u7A77\\u5927\\u7684\\u65F6\\u5019\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u4E00\\u4E2Asubset\\u5C31\\u53EF\\u4EE5\\u4E86\\uFF09=\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u53D8\\u5C0F\\u5B83\\n                    setnum += 1\\n                    cursum = 0\\n                cursum += num\\n            return setnum\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if subsetnum(mid) <= m: # \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF01\\u6211\\u4EEC\\u9700\\u8981\\u51CF\\u5C0Fmid! \\u8FD9\\u4E00\\u70B9\\u975E\\u5E38\\u91CD\\u8981!\\n                # extremely, if we guess mid = 2**31-1, then subsetnum(mid) = 1 \\n\\t\\t\\t\\t# (all elements are in one subset), this means that our guessing is too big\\n                # we can make it smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\'\\'\\'\\n\\n**1482. Minimum Number of Days to Make m Bouquets**\\n\\nhttps://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/\\nGiven an integer array bloomDay, an integer m and an integer k.\\n\\nWe need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\\n\\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\\n\\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\\n\\'\\'\\'\\n```\\nclass Solution_Leetcode1482:\\n    def minDays(self, bloomdays, m, k):\\n        # binary search method, seek for the min day, \\n        # guess a day, -> check how many bouquets \\u82B1\\u675F\\n        \\n        left = min(bloomdays)\\n        right = max(bloomdays) + 1\\n        \\n        def isgood(mid):\\n            count = 0\\n            cursum = 0\\n            for aday in bloomdays:\\n                if aday > mid:\\n                    cursum = 0 # reset to 0\\n                else:\\n                    cursum += 1\\n                    if cursum == k:\\n                        count += 1\\n                        cursum = 0 # need to reset cursum here!\\n            return count >= m\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isgood(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left if left <= max(bloomdays) else -1\\n```\\n\\n\\n**875. Koko Eating Bananas**\\nhttps://leetcode.com/problems/koko-eating-bananas/\\n\\nKoko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.\\n\\nKoko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour.\\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\\n\\nReturn the minimum integer K such that she can eat all the bananas within H hours.\\n```\\n\\nclass Solution_leetcode875(object):\\n    def minEatingSpeed(self, piles, H):\\n        # still, change the problem, binary search,\\n        # guess the target value and compute how many banana koko can eat -> min speed\\n        left = 1\\n        right = max(piles) + 1\\n        \\n        def caneatall(mid): # isok(mid)\\n            # hours cost really should <=H\\n            hours = 0\\n            for pile in piles:\\n                hours += math.ceil(pile/float(mid)) \\n                # do not work if we use pile/mid!!! should change int into float!! this is very important!\\n            return hours <= H\\n        \\n        while left < right:\\n            mid = left + (right - left)//2\\n            if caneatall(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left # the min speed that satisfies caneatall(left)\\n```\\n\\n\\nGo back to finding max value again, using binary search!\\n\\n**1552. Magnetic Force Between Two Balls**\\nhttps://leetcode.com/problems/magnetic-force-between-two-balls/\\n\\nIn universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\\n\\nRick stated that magnetic force between two different balls at positions x and y is |x - y|.\\n\\nGiven the integer array position and the integer m. Return the required force.\\n```\\nclass Solution_Leetcode1552:\\n    def maxDistance(self, position, m):\\n        n = len(position)\\n        position.sort()\\n        \\n        def isfail(mid):\\n            ans = 1\\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\\n            for i in range(1, n):\\n                if position[i] - curr >= mid:\\n                    ans += 1\\n                    curr = position[i]\\n            return ans < m\\n        \\n        left = 0 # \\u6CE8\\u610F\\uFF0C\\u4E0D\\u5E94\\u8BE5\\u628Aleft\\u8D4B\\u503C\\u4E3Amin(position)! \\u56E0\\u4E3A\\u6211\\u4EEC\\u6C42\\u5F97\\u662Fdistance!\\n        # note that, left = min(position) is wrong, since we are looking for \\'distance\\'!\\n        right = max(position) - min(position) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isfail(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1 # left is the min value to fail, so left-1 is the max value to succeed!\\n        # \\u56E0\\u4E3A\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF01\\u6240\\u4EE5\\u9700\\u8981\\u5DE7\\u5999\\u4F7F\\u7528binary search!\\n```",
                "solutionTags": [],
                "code": "```\\n# # looking for a min value, then build a \\'isok\\' function and directly use binary search to \\n# find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode1011:\\n    def shipWithinDays(self, weights, D):\\n        # binary search\\n        # min weight capacity of the ship\\n        \\n        def isok(mid):\\n            # real days needed with max weight capacity of mid\\n            day = 1\\n            cursum = 0\\n            for weight in weights:\\n                if cursum + weight > mid:\\n                    day += 1\\n                    cursum = 0\\n                cursum += weight\\n            return day <= D\\n        \\n        left = max(weights) # note that this should be max(weights), not min(weights)!!\\n        right = sum(weights) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\n# point: looking for max value, then build a \"fail\" function,\\n# and use binary search to find the min \\'left\\' that let fail(left) return True.\\n# then, left-1 is the max value to let fail(left-1) return False (i.e., not_fail(left-1) is true)!\\nclass Solution_Leetcode1231(object):\\n    def maximizeSweetness(self, sweetness, K):\\n        # binary search method is for looking for the MIN value! so, we find the min value (left) that fail\\n        # then left-1 is the max value that success!\\n        # look for max value, find the min value that fail, and then min.value - 1 is the result of success\\n        \\n        left = min(sweetness)\\n        right = sum(sweetness)+ 1\\n        \\n        def fail(mid):\\n            pieces = 0\\n            cursum = 0\\n            for sweet in sweetness:\\n                cursum += sweet\\n                if cursum >= mid:\\n                    # then current piece is ensure to be >= mid, we can start a new piece\\n                    pieces += 1\\n                    cursum = 0\\n            return pieces < K+1\\n        \\n        while left < right:\\n            mid = left+ (right-left)//2\\n            if fail(mid): # the result \\'left\\' is the min value that let fail(left)=True!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1\\n```\n```\\n# looking for a min value, then build a \\'isok\\' function and directly use binary search,\\n# to find the min value \\'left\\' so that ok(left) returns True!\\nclass Solution_leetcode410(object):\\n    def splitArray(self, nums, m):\\n        # binary search\\n        # make a guess and then check how many subarrays x; if x > m, the guess is too big; else, the guess is too small\\n        left = max(nums)\\n        right = sum(nums) + 1\\n        \\n        def isok(mid): # or, you can change \\'isok\\' name into \\'is_mid_too_big\\'\\n            # all subarray\\'s sum <= mid\\n            setcount = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num> mid:\\n                    setcount += 1\\n                    cursum = 0\\n                cursum += num\\n            return setcount <= m # this is <=, not >=! which is very important!\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isok(mid): # is_mid_too_big, and we do not have enough subset when separating under mid, so we should make mid smaller!\\n                # or, think extremelly, if mid=2**31-1, then all numbers are in one subset, 1 <= m, so we should make mid smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\nclass Solution_leetcode410_2(object):\\n    def splitArray(self, nums, m):\\n        # use binary search - it is finding the min value!\\n        # find the min sum value such that for the m sbusets of nums, sum of a subset <= x\\n        \\n        left = max(nums)\\n        right = sum(nums)\\n        \\n        def subsetnum(mid):\\n            setnum = 1\\n            cursum = 0\\n            for num in nums:\\n                if cursum + num > mid:  # \\u8F6C\\u6362\\u601D\\u60F3\\uFF1A\\u672C\\u6765\\u662F\\u7ED9\\u5B9Am\\u4E2A\\u5B50\\u96C6\\uFF0C\\u6C42\\u5F97\\u662F\\u5B50\\u96C6\\u548C\\u5F97\\u6700\\u5927\\u503C\\u3002\\n\\t\\t\\t\\t\\t# \\u6211\\u4EEC\\u53CD\\u8FC7\\u6765\\uFF0C\\u5148\\u6307\\u5B9A\\u5B50\\u96C6\\u7684\\u548C\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u7136\\u540E\\u53BB\\u53CD\\u63A8\\u80FD\\u80FD\\u591F\\u5206\\u6210\\u591A\\u5C11\\u4E2A\\u5B50\\u96C6\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570>m\\uFF0C\\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5C0F\\u4E86\\n                    # \\u5982\\u679C\\u5B50\\u96C6\\u7684\\u4E2A\\u6570< m, \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\n\\t\\t\\t\\t\\t# \\uFF08\\u8003\\u8651\\u731C\\u6D4B\\u4E3A\\u65E0\\u7A77\\u5927\\u7684\\u65F6\\u5019\\uFF0C\\u6211\\u4EEC\\u53EA\\u9700\\u8981\\u4E00\\u4E2Asubset\\u5C31\\u53EF\\u4EE5\\u4E86\\uFF09=\\u4E5F\\u5C31\\u662F\\u8BF4\\uFF0C\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u53D8\\u5C0F\\u5B83\\n                    setnum += 1\\n                    cursum = 0\\n                cursum += num\\n            return setnum\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if subsetnum(mid) <= m: # \\u8BF4\\u660E\\u6211\\u4EEC\\u7684\\u731C\\u6D4B\\u592A\\u5927\\u4E86\\uFF01\\u6211\\u4EEC\\u9700\\u8981\\u51CF\\u5C0Fmid! \\u8FD9\\u4E00\\u70B9\\u975E\\u5E38\\u91CD\\u8981!\\n                # extremely, if we guess mid = 2**31-1, then subsetnum(mid) = 1 \\n\\t\\t\\t\\t# (all elements are in one subset), this means that our guessing is too big\\n                # we can make it smaller!\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\nclass Solution_Leetcode1482:\\n    def minDays(self, bloomdays, m, k):\\n        # binary search method, seek for the min day, \\n        # guess a day, -> check how many bouquets \\u82B1\\u675F\\n        \\n        left = min(bloomdays)\\n        right = max(bloomdays) + 1\\n        \\n        def isgood(mid):\\n            count = 0\\n            cursum = 0\\n            for aday in bloomdays:\\n                if aday > mid:\\n                    cursum = 0 # reset to 0\\n                else:\\n                    cursum += 1\\n                    if cursum == k:\\n                        count += 1\\n                        cursum = 0 # need to reset cursum here!\\n            return count >= m\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isgood(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left if left <= max(bloomdays) else -1\\n```\n```\\n\\nclass Solution_leetcode875(object):\\n    def minEatingSpeed(self, piles, H):\\n        # still, change the problem, binary search,\\n        # guess the target value and compute how many banana koko can eat -> min speed\\n        left = 1\\n        right = max(piles) + 1\\n        \\n        def caneatall(mid): # isok(mid)\\n            # hours cost really should <=H\\n            hours = 0\\n            for pile in piles:\\n                hours += math.ceil(pile/float(mid)) \\n                # do not work if we use pile/mid!!! should change int into float!! this is very important!\\n            return hours <= H\\n        \\n        while left < right:\\n            mid = left + (right - left)//2\\n            if caneatall(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left # the min speed that satisfies caneatall(left)\\n```\n```\\nclass Solution_Leetcode1552:\\n    def maxDistance(self, position, m):\\n        n = len(position)\\n        position.sort()\\n        \\n        def isfail(mid):\\n            ans = 1\\n            curr = position[0] # alike greedy idea, we just put the first ball at position 0!\\n            for i in range(1, n):\\n                if position[i] - curr >= mid:\\n                    ans += 1\\n                    curr = position[i]\\n            return ans < m\\n        \\n        left = 0 # \\u6CE8\\u610F\\uFF0C\\u4E0D\\u5E94\\u8BE5\\u628Aleft\\u8D4B\\u503C\\u4E3Amin(position)! \\u56E0\\u4E3A\\u6211\\u4EEC\\u6C42\\u5F97\\u662Fdistance!\\n        # note that, left = min(position) is wrong, since we are looking for \\'distance\\'!\\n        right = max(position) - min(position) + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isfail(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1 # left is the min value to fail, so left-1 is the max value to succeed!\\n        # \\u56E0\\u4E3A\\u6C42\\u7684\\u662F\\u6700\\u5927\\u503C\\uFF01\\u6240\\u4EE5\\u9700\\u8981\\u5DE7\\u5999\\u4F7F\\u7528binary search!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900165,
                "title": "binary-search-with-a-local-function-no-dp-recursion",
                "content": "```csharp\\npublic class Solution\\n{\\n    public int SplitArray(int[] nums, int m)\\n    {\\n        int lo = nums.Max();\\n        int hi = nums.Sum();\\n            \\n        while (lo < hi)\\n        {\\n            int mid = lo + (hi - lo) / 2;\\n            if (IsHighEnough(mid)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        \\n        return lo;\\n        \\n        bool IsHighEnough(int target)\\n        {\\n            int sum = 0;\\n            int count = 1;\\n\\n            foreach (int n in nums)\\n            {\\n                sum += n;\\n                if (sum > target)\\n                {\\n                    sum = n;\\n                    if (++count > m) return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int SplitArray(int[] nums, int m)\\n    {\\n        int lo = nums.Max();\\n        int hi = nums.Sum();\\n            \\n        while (lo < hi)\\n        {\\n            int mid = lo + (hi - lo) / 2;\\n            if (IsHighEnough(mid)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        \\n        return lo;\\n        \\n        bool IsHighEnough(int target)\\n        {\\n            int sum = 0;\\n            int count = 1;\\n\\n            foreach (int n in nums)\\n            {\\n                sum += n;\\n                if (sum > target)\\n                {\\n                    sum = n;\\n                    if (++count > m) return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877064,
                "title": "100-fast-easy-c-solution-binary-search",
                "content": "**#### If you like this solution, please don\\'t forget to upvote it...**\\n\\n### **For better understanding please refer to Aditya verma\\'s binary search playlist Allocate minimum no of pages video.**\\n\\nIn this question first of all we have to find min sum in which we can divide the array in M parts.\\n\\n\\n```\\nbool isvalid(vector<int> arr, int n, int k, int max)\\n    {\\n        int student=1;\\n        int sum=0;\\n        \\n```\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            \\n            if(sum>max)\\n            {\\n                student++;\\n                sum=arr[i];\\n            }\\n            \\n            \\n            if(student>k)\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        \\n        int n=nums.size();\\n        \\n        // finding max and sum of array\\n        \\n        int start=nums[0];\\n        int end=nums[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>start)\\n                start=nums[i];\\n            \\n            end+=nums[i];\\n        }\\n        \\n        \\n        // applying binary search\\n        int res=-1;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start+ (end-start)/2;\\n            \\n            if(isvalid(nums, n, m, mid)==true)\\n            {\\n                res=mid;\\n                end=mid-1;\\n            }\\n            \\n            else\\n                start=mid+1;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nbool isvalid(vector<int> arr, int n, int k, int max)\\n    {\\n        int student=1;\\n        int sum=0;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 89838,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        //dp[i][k] means max sum of k parts of elements 0..i\\n        vector<vector<long>> dp(n, vector<long>(m+1, INT_MAX));\\n        //sum array is used to calculate range sum of i..j\\n        vector<long> sum(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            sum[i] = i == 0 ?nums[0] :(sum[i-1] + nums[i]);\\n        }\\n        // build dp from 0 to n-1 emelents\\n        for (int i = 0; i < nums.size(); i++) {\\n            //elements from 0 to indexi can be divided to i+1 parts mostly;\\n            int maxDivide = min(m, i+1);\\n            //for each dividing choice\\n            for (int k = 1; k <= maxDivide; k++) {\\n                if (k == 1) {\\n                    dp[i][k] = sum[i];\\n                    continue;\\n                }\\n                //divide 0..i to k parts, so i can be with i-1; i-1, i-2...; i-1, i-2..k-1;\\n                for (int j = i; j >= k-1; j--) {//0..k-2 can be divided to mostly k-1 parts\\n                    long partsum = sum[i] - sum[j] + nums[j];\\n                    if (partsum > dp[i][k]) break; //early termination\\n                    dp[i][k] = min(dp[i][k], max(partsum, dp[j-1][k-1]));\\n                }\\n            }\\n        }\\n        return dp[n-1][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        //dp[i][k] means max sum of k parts of elements 0..i\\n        vector<vector<long>> dp(n, vector<long>(m+1, INT_MAX));\\n        //sum array is used to calculate range sum of i..j\\n        vector<long> sum(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            sum[i] = i == 0 ?nums[0] :(sum[i-1] + nums[i]);\\n        }\\n        // build dp from 0 to n-1 emelents\\n        for (int i = 0; i < nums.size(); i++) {\\n            //elements from 0 to indexi can be divided to i+1 parts mostly;\\n            int maxDivide = min(m, i+1);\\n            //for each dividing choice\\n            for (int k = 1; k <= maxDivide; k++) {\\n                if (k == 1) {\\n                    dp[i][k] = sum[i];\\n                    continue;\\n                }\\n                //divide 0..i to k parts, so i can be with i-1; i-1, i-2...; i-1, i-2..k-1;\\n                for (int j = i; j >= k-1; j--) {//0..k-2 can be divided to mostly k-1 parts\\n                    long partsum = sum[i] - sum[j] + nums[j];\\n                    if (partsum > dp[i][k]) break; //early termination\\n                    dp[i][k] = min(dp[i][k], max(partsum, dp[j-1][k-1]));\\n                }\\n            }\\n        }\\n        return dp[n-1][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057988,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& weights, int days, int m)\\n    {\\n        int n=weights.size();\\n        int s=0;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s+=weights[i];\\n            if(s>m)\\n            {\\n                c++;\\n                s=weights[i];\\n            }\\n        }\\n        if(s>0)\\n        c++;\\n        if(c<=days)\\n        return true;\\n        return false;\\n    }\\n    int splitArray(vector<int>& weights, int days) {\\n        int n=weights.size();\\n        int mx=0;\\n        int s=0;\\n        for(int i:weights)\\n        {\\n            mx=max(mx, i);\\n            s+=i;\\n        }\\n        int l=mx, h=s;\\n        if(days>=n)\\n        return mx;\\n        int ans=h;\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(check(weights, days, m))\\n            {\\n                ans=m;\\n                h=m-1;\\n            }\\n            else\\n            l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& weights, int days, int m)\\n    {\\n        int n=weights.size();\\n        int s=0;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s+=weights[i];\\n            if(s>m)\\n            {\\n                c++;\\n                s=weights[i];\\n            }\\n        }\\n        if(s>0)\\n        c++;\\n        if(c<=days)\\n        return true;\\n        return false;\\n    }\\n    int splitArray(vector<int>& weights, int days) {\\n        int n=weights.size();\\n        int mx=0;\\n        int s=0;\\n        for(int i:weights)\\n        {\\n            mx=max(mx, i);\\n            s+=i;\\n        }\\n        int l=mx, h=s;\\n        if(days>=n)\\n        return mx;\\n        int ans=h;\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(check(weights, days, m))\\n            {\\n                ans=m;\\n                h=m-1;\\n            }\\n            else\\n            l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427933,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Binary Search***\\n\\n* ***Time Complexity :- O(N * log(total_sum - max. element))***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // this function check that is it possible to take max. sum od subarray == mid\\n    \\n    bool is_possible(vector<int>& arr, int mid, int k)\\n    {\\n        int n = arr.size();\\n        \\n        // calculate no. of possible partition\\n    \\n        int count = 1;\\n    \\n        int curr_sum = 0;\\n    \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(curr_sum + arr[i] <= mid)\\n            {\\n                curr_sum += arr[i];\\n            }\\n            \\n            // if curr_sum exceed the mid, then increment the no. of partition and update the curr_sum\\n            \\n            else\\n            {\\n                count++;\\n            \\n                curr_sum = arr[i];\\n            }\\n        }\\n        \\n        return count <= k;\\n    }\\n    \\n    int splitArray(vector<int>& arr, int k) {\\n        \\n        // apply binary search to get minimum\\n        \\n        // lowest max. sum will be the max. of array\\n        \\n        int low = *max_element(arr.begin(), arr.end());\\n        \\n        // highest max sum will be the sum of whole array\\n    \\n        int high = 0;\\n    \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            high += arr[i];\\n        }\\n    \\n        int mini = -1;\\n    \\n        while(low <= high)\\n        {\\n            // find mid\\n            \\n            int mid = low + (high - low) / 2;\\n            \\n            // if the no. of required partition is <= k\\n        \\n            if(is_possible(arr, mid, k))\\n            {\\n                // update mini\\n                \\n                mini = mid;\\n            \\n                high = mid - 1;\\n            }\\n            \\n            // if no. of required partition is more than k\\n            \\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // this function check that is it possible to take max. sum od subarray == mid\\n    \\n    bool is_possible(vector<int>& arr, int mid, int k)\\n    {\\n        int n = arr.size();\\n        \\n        // calculate no. of possible partition\\n    \\n        int count = 1;\\n    \\n        int curr_sum = 0;\\n    \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(curr_sum + arr[i] <= mid)\\n            {\\n                curr_sum += arr[i];\\n            }\\n            \\n            // if curr_sum exceed the mid, then increment the no. of partition and update the curr_sum\\n            \\n            else\\n            {\\n                count++;\\n            \\n                curr_sum = arr[i];\\n            }\\n        }\\n        \\n        return count <= k;\\n    }\\n    \\n    int splitArray(vector<int>& arr, int k) {\\n        \\n        // apply binary search to get minimum\\n        \\n        // lowest max. sum will be the max. of array\\n        \\n        int low = *max_element(arr.begin(), arr.end());\\n        \\n        // highest max sum will be the sum of whole array\\n    \\n        int high = 0;\\n    \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            high += arr[i];\\n        }\\n    \\n        int mini = -1;\\n    \\n        while(low <= high)\\n        {\\n            // find mid\\n            \\n            int mid = low + (high - low) / 2;\\n            \\n            // if the no. of required partition is <= k\\n        \\n            if(is_possible(arr, mid, k))\\n            {\\n                // update mini\\n                \\n                mini = mid;\\n            \\n                high = mid - 1;\\n            }\\n            \\n            // if no. of required partition is more than k\\n            \\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900337,
                "title": "c-binary-search-explained-0ms-time",
                "content": "Initialise start with max element and end with sum of all elements\\nNow use binary search to get minimum largest sum subarray split.\\n\\n\\n|PLEASE UPVOTE IF YOU LIKE THE SOLUTION|\\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int start=INT_MIN;\\n        int end=0;\\n        for(int n:nums){\\n            start=max(n,start);\\n            end+=n;\\n        }\\n        \\n        int mid,ans;\\n        while(start<=end){\\n            mid=start+(end-start)/2;\\n            if(isPossible(nums,mid,m)){\\n                end=mid-1;\\n                ans=mid;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>&n,int mid,int m){\\n        int sum=0,count=1;\\n        for(int i=0;i<n.size();i++){\\n            sum+=n[i];\\n            if(sum>mid){\\n                sum=n[i];\\n                count++;\\n            }\\n            if(count>m)return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int start=INT_MIN;\\n        int end=0;\\n        for(int n:nums){\\n            start=max(n,start);\\n            end+=n;\\n        }\\n        \\n        int mid,ans;\\n        while(start<=end){\\n            mid=start+(end-start)/2;\\n            if(isPossible(nums,mid,m)){\\n                end=mid-1;\\n                ans=mid;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>&n,int mid,int m){\\n        int sum=0,count=1;\\n        for(int i=0;i<n.size();i++){\\n            sum+=n[i];\\n            if(sum>mid){\\n                sum=n[i];\\n                count++;\\n            }\\n            if(count>m)return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900256,
                "title": "c-binary-search-solution-no-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool ispossible(vector<int> &nums,int curr,int m){\\n\\t\\t\\tint total=1;\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t   sum+=nums[i];\\n\\t\\t\\t   if(sum>curr){\\n\\t\\t\\t\\t   sum=nums[i];\\n\\t\\t\\t\\t   total++;\\n\\t\\t\\t   }\\n\\t\\t\\t\\tif(nums[i]>curr) return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn total<=m;\\n\\t\\t}\\n\\t\\tint splitArray(vector<int>& nums, int m) {\\n\\t\\t\\t int low=*min_element(nums.begin(),nums.end());\\n\\t\\t\\t int high=accumulate(nums.begin(),nums.end(),0);\\n\\t\\t\\t int ans=low;\\n\\t\\t\\t while(low<=high){\\n\\t\\t\\t\\t int curr=(low+high)/2;\\n\\t\\t\\t\\t if(ispossible(nums,curr,m)){\\n\\t\\t\\t\\t\\t ans=curr;\\n\\t\\t\\t\\t\\t high=curr-1;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t else\\n\\t\\t\\t\\t\\t low=curr+1;\\n\\t\\t\\t }\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\nIF IT WAS **HELPFUL** DO CONSIDER\\u2B06\\uFE0F **UPVOTING** !\\t",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool ispossible(vector<int> &nums,int curr,int m){\\n\\t\\t\\tint total=1;\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t   sum+=nums[i];\\n\\t\\t\\t   if(sum>curr){\\n\\t\\t\\t\\t   sum=nums[i];\\n\\t\\t\\t\\t   total++;\\n\\t\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1900096,
                "title": "python-2-solutions-explained",
                "content": "#### Solution 1\\nOne way is to use binary search for `Q`: check if we can split numbers into `m` groups such that the largest sum `<=  Q`. We do it in greedy way.\\n\\n#### Complexity\\nTime complexity of this approach is `O(n * log(SUM))`, where `SUM` is sum of all numbers in array. Space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def splitArray(self, nums, m):\\n        def check(Q):\\n            if max(nums) > Q: return False\\n            acc, ans = 0, 1\\n            for num in nums:\\n                if acc + num <= Q:\\n                    acc += num\\n                else:\\n                    acc = num\\n                    ans += 1\\n            return ans <= m\\n        \\n        beg, end = max(nums) - 1, sum(nums)\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if check(mid):\\n                end = mid\\n            else:\\n                beg = mid\\n        \\n        return end\\n```\\n\\n#### Solution 2\\nAnother solution is use DP: let `dp[i][j]` be an answer for first `i` numbers and `j` groups. Then to evaluate `dp[i][j]` we need to look find `min_k[max(dp[k][j-1], S_k-S_i)]`, where `S_k` are cumulative sums. To find this minimum we can either use linear search with `O(m n^2)`, but it will give TLE. Alternative is to use binary search, where we use the property that first term of max is increasing and the second is decreasing. \\n\\n#### Complexity\\nTime complexity is `O(mn log n)`, space is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def splitArray(self, nums, m):\\n        n = len(nums)\\n        acc = [0] + list(accumulate(nums))\\n        dp = list(acc)\\n        \\n        for j in range(1, m):\\n            for i in range(n, j, -1):\\n                beg, end = j - 1, i\\n                while beg + 1 < end:\\n                    mid = (beg + end)//2\\n                    if dp[mid] >= acc[i] - acc[mid]:\\n                        end = mid\\n                    else:\\n                        beg = mid\\n                    dp[i] = min(max(dp[end], acc[i] - acc[end]), max(dp[beg], acc[i] - acc[beg]))\\n        \\n        return dp[-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def splitArray(self, nums, m):\\n        def check(Q):\\n            if max(nums) > Q: return False\\n            acc, ans = 0, 1\\n            for num in nums:\\n                if acc + num <= Q:\\n                    acc += num\\n                else:\\n                    acc = num\\n                    ans += 1\\n            return ans <= m\\n        \\n        beg, end = max(nums) - 1, sum(nums)\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if check(mid):\\n                end = mid\\n            else:\\n                beg = mid\\n        \\n        return end\\n```\n```python\\nclass Solution:\\n    def splitArray(self, nums, m):\\n        n = len(nums)\\n        acc = [0] + list(accumulate(nums))\\n        dp = list(acc)\\n        \\n        for j in range(1, m):\\n            for i in range(n, j, -1):\\n                beg, end = j - 1, i\\n                while beg + 1 < end:\\n                    mid = (beg + end)//2\\n                    if dp[mid] >= acc[i] - acc[mid]:\\n                        end = mid\\n                    else:\\n                        beg = mid\\n                    dp[i] = min(max(dp[end], acc[i] - acc[end]), max(dp[beg], acc[i] - acc[beg]))\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900034,
                "title": "3-solutions-memoization-dp-binary-search-time-space-complexities",
                "content": "**Recursion + Memoization**      *TC- O(N\\xD7M\\xD7K) & SC - O(N\\xD7M)*\\n```\\nclass Solution {\\nprivate:\\n    int dp[1001][51];\\n    int fun(vector<int>& nums, int ind, int m){\\n        if(ind == 0 && m == 0) return 0;\\n        if(ind == 0 || m == 0) return INT_MAX;\\n        if(dp[ind][m]!=-1) return dp[ind][m];\\n        int ans = INT_MAX;\\n        int cur = 0;\\n        for(int k = ind; k > 0; k--){\\n            cur += nums[k-1];\\n            ans = min(ans, max(cur, fun(nums, k-1, m-1)));\\n        }\\n        return dp[ind][m] = ans;\\n    }\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof dp);\\n        return fun(nums, nums.size(), m);\\n    }\\n};\\n```\\n\\n**Tabulation DP**      *TC- O(N\\xD7M\\xD7K) & SC - O(N\\xD7M)*\\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, INT_MAX));\\n        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j<=m; j++){\\n                int cur = 0;\\n                for(int k = i; k > 0; k--){\\n                    cur += nums[k-1];\\n                    dp[i][j] = min(dp[i][j], max(cur, dp[k-1][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n**Binary-Search + Greedy**      *TC- O(N\\xD7Log(Sum_of_nums) & SC - O(1)*\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int>& nums, int val, int m){\\n        int curSum = 0, subArrays = 1;\\n        for(int &i : nums){\\n            if(curSum + i > val){ subArrays++; curSum = 0;}\\n            curSum += i;\\n        }\\n        return subArrays <= m;\\n    }\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int l = *max_element(nums.begin(), nums.end()); \\n        int r = accumulate(nums.begin(), nums.end(), 0);\\n        int ans = 0;\\n        while(l <= r){\\n            int mid = l + ((r-l)>>1);\\n            if(isPossible(nums, mid, m)) r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][51];\\n    int fun(vector<int>& nums, int ind, int m){\\n        if(ind == 0 && m == 0) return 0;\\n        if(ind == 0 || m == 0) return INT_MAX;\\n        if(dp[ind][m]!=-1) return dp[ind][m];\\n        int ans = INT_MAX;\\n        int cur = 0;\\n        for(int k = ind; k > 0; k--){\\n            cur += nums[k-1];\\n            ans = min(ans, max(cur, fun(nums, k-1, m-1)));\\n        }\\n        return dp[ind][m] = ans;\\n    }\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof dp);\\n        return fun(nums, nums.size(), m);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        vector<vector<int>>dp(n+1, vector<int>(m+1, INT_MAX));\\n        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j<=m; j++){\\n                int cur = 0;\\n                for(int k = i; k > 0; k--){\\n                    cur += nums[k-1];\\n                    dp[i][j] = min(dp[i][j], max(cur, dp[k-1][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int>& nums, int val, int m){\\n        int curSum = 0, subArrays = 1;\\n        for(int &i : nums){\\n            if(curSum + i > val){ subArrays++; curSum = 0;}\\n            curSum += i;\\n        }\\n        return subArrays <= m;\\n    }\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int l = *max_element(nums.begin(), nums.end()); \\n        int r = accumulate(nums.begin(), nums.end(), 0);\\n        int ans = 0;\\n        while(l <= r){\\n            int mid = l + ((r-l)>>1);\\n            if(isPossible(nums, mid, m)) r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587653,
                "title": "c-solution-using-dp-and-binary-search-faster-than-100-00-of-c-online-submissions",
                "content": "**Solution 1:** Derived from the DP solution given under the solution tab for this question on leetcode. So we use a 2D DP, where dp[i][j] the max sum until ith number, with j partitions (Remember here we talking about numbers (start from 1) and not indexes, hence dp[0][0] = 0). Now, if there is some value k<i, then dp[i][j] = min(dp[i][j], max(dp[k][j-1], sum of elements in range k to i)).\\nMeaning for until kth number with j-1 partitions, whatever as the maximum, and compare it to the sum of elements between k and i. Update the dp (use the value) that gives us minimum sum.\\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, INT_MAX));\\n        dp[0][0] = 0;\\n        vector<int> prefix(n+1, 0);\\n        for(int i=0; i<n; i++)\\n        {\\n            prefix[i+1] = prefix[i] + nums[i];\\n        }\\n        for(int i=1; i<=n; i++)\\n        {\\n            for(int j=1; j<=m; j++)\\n            {\\n                for(int k=0; k<i; k++)\\n                {\\n                    dp[i][j] = min(dp[i][j], max(dp[k][j-1], prefix[i]-prefix[k]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\nTime complexity: O(n^2 * m)\\nSpace complexity: O(n * m)\\n\\n**Solution 2:** This is the solution that is the fast implemention. Basically imagine an l and r value between which the maximum sum of subarray exists. Now we need to split the array such that this maximum sum is minimised. \\nNow, if we split array at some point, and maximum sum of subarray is some value x, we go on to find find if there exists another value between range [l, x) (less than x) for same condition, i.e. if there exists x_0 (<x) that corresponds to maximum sum of subarrray while dividing in another way.\\nSo, first set the l and r values to maximum element in array and sum of all elements in the array.\\nNow, do a binary search on this range (mid = (left+right)/2)and while doing so, traverse whole array and split the array in such a way that no subarray sum goes > mid. \\nIf at any point, the current sum goes >mid. Then start sum of subarray from nums[i] and increment the count of partitions.\\nAtlast check if the count of partitions is <= m (the number of partitions given in input). If it is so (maximum sum is less than mid with partitions <= m) then we compare the mid with ans and update it. Also we update r = mid-1. As now we need to find it on left side range.\\nIf not, then we need to find in the RHS range and set l  = mid+1.\\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        long l = 0, r = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            r+=nums[i];\\n            if(l<nums[i])\\n                l =nums[i];\\n        } //left value will be a single largest element and r value will be sum of all elements\\n        //all elements in one subarray\\n        long ans = r;\\n        while(l<=r)\\n        {\\n            long mid = (long)(l+r)/2;\\n            long sum = 0;\\n            int count = 1;\\n            for(int i=0; i<n; i++)\\n            {\\n                if(sum+nums[i]>mid)\\n                {\\n                    count++;\\n                    sum = nums[i];\\n                }\\n                else\\n                    sum+=nums[i];\\n            }\\n            if(count<=m)\\n            {\\n                ans = min(ans, mid);\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime complexity : O(n * log(sum_of_array))\\nSpace complexity: O(1)\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, INT_MAX));\\n        dp[0][0] = 0;\\n        vector<int> prefix(n+1, 0);\\n        for(int i=0; i<n; i++)\\n        {\\n            prefix[i+1] = prefix[i] + nums[i];\\n        }\\n        for(int i=1; i<=n; i++)\\n        {\\n            for(int j=1; j<=m; j++)\\n            {\\n                for(int k=0; k<i; k++)\\n                {\\n                    dp[i][j] = min(dp[i][j], max(dp[k][j-1], prefix[i]-prefix[k]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        long l = 0, r = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            r+=nums[i];\\n            if(l<nums[i])\\n                l =nums[i];\\n        } //left value will be a single largest element and r value will be sum of all elements\\n        //all elements in one subarray\\n        long ans = r;\\n        while(l<=r)\\n        {\\n            long mid = (long)(l+r)/2;\\n            long sum = 0;\\n            int count = 1;\\n            for(int i=0; i<n; i++)\\n            {\\n                if(sum+nums[i]>mid)\\n                {\\n                    count++;\\n                    sum = nums[i];\\n                }\\n                else\\n                    sum+=nums[i];\\n            }\\n            if(count<=m)\\n            {\\n                ans = min(ans, mid);\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397756,
                "title": "java-binary-search-solution-dp-solution",
                "content": "Binary Search Solution\\n```\\n// Binary Search Solution\\n// 1. The lower bound is the max of nums, upper bound is sum of nums\\n// 2. Binary search to get the target.\\n// 3. Check whether we can divide the array into more than m subarrays whose sum is largest but less than mid.\\n// Constrains: nums[i] <= 10^6, nums.length <= 1000, then sum <= 10^9 < Integer.MAX_VALUE.\\n// Time complexity: O(N * logL), where L = sum - max\\n// Space complexity: O(1)\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        // 1 <= m <= nums.length\\n        int max = 0, sum = 0;\\n        for (int num : nums) {\\n            max = Math.max(num, max);\\n            sum += num;\\n        }\\n        if (m == 1) return sum;\\n        int l = max, r = sum;\\n        int res = r;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (isValid(nums, m, mid)) {\\n                res = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValid(int[] nums, int m, int target) {\\n        int count = 1;\\n        int sum = 0;\\n        for(int num : nums) {\\n            if (sum + num > target) {\\n                sum = 0;\\n                count ++;\\n                if (count > m) {\\n                    return false;\\n                }\\n            }\\n            sum += num;\\n        }\\n        return true;\\n    }\\n}\\n```\\nDP Solution\\n```\\n// DP Solution\\n// Constrains: nums[i] <= 10^6, nums.length <= 1000, then sum <= 10^9 < Integer.MAX_VALUE.\\n// Time complexity: O(M*N*N)\\n// Space complexity: O(M*N)\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        final int N = nums.length;\\n        Integer[][] memo = new Integer[m+1][N];\\n        int[] sums = new int[N+1];\\n        for (int i = 0; i < N; i++) {\\n            sums[i+1] = sums[i] + nums[i];\\n        }\\n        return explore(0, nums, m, sums, memo);\\n    }\\n    \\n    private int explore(int start, int[] nums, int m, int sums[], Integer[][] memo) {\\n        final int N = nums.length;\\n        if (m == 1) return sums[N] - sums[start];\\n        if (memo[m][start] != null) return memo[m][start];\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i <= N - m; i++) {\\n            int leftSum = sums[i+1] - sums[start];\\n            int rightSum = explore(i + 1, nums, m-1, sums, memo);\\n            int maxSum = Math.max(leftSum, rightSum);\\n            min = Math.min(min, maxSum);\\n        }\\n        memo[m][start] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Binary Search Solution\\n// 1. The lower bound is the max of nums, upper bound is sum of nums\\n// 2. Binary search to get the target.\\n// 3. Check whether we can divide the array into more than m subarrays whose sum is largest but less than mid.\\n// Constrains: nums[i] <= 10^6, nums.length <= 1000, then sum <= 10^9 < Integer.MAX_VALUE.\\n// Time complexity: O(N * logL), where L = sum - max\\n// Space complexity: O(1)\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        // 1 <= m <= nums.length\\n        int max = 0, sum = 0;\\n        for (int num : nums) {\\n            max = Math.max(num, max);\\n            sum += num;\\n        }\\n        if (m == 1) return sum;\\n        int l = max, r = sum;\\n        int res = r;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (isValid(nums, m, mid)) {\\n                res = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private boolean isValid(int[] nums, int m, int target) {\\n        int count = 1;\\n        int sum = 0;\\n        for(int num : nums) {\\n            if (sum + num > target) {\\n                sum = 0;\\n                count ++;\\n                if (count > m) {\\n                    return false;\\n                }\\n            }\\n            sum += num;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n// DP Solution\\n// Constrains: nums[i] <= 10^6, nums.length <= 1000, then sum <= 10^9 < Integer.MAX_VALUE.\\n// Time complexity: O(M*N*N)\\n// Space complexity: O(M*N)\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        final int N = nums.length;\\n        Integer[][] memo = new Integer[m+1][N];\\n        int[] sums = new int[N+1];\\n        for (int i = 0; i < N; i++) {\\n            sums[i+1] = sums[i] + nums[i];\\n        }\\n        return explore(0, nums, m, sums, memo);\\n    }\\n    \\n    private int explore(int start, int[] nums, int m, int sums[], Integer[][] memo) {\\n        final int N = nums.length;\\n        if (m == 1) return sums[N] - sums[start];\\n        if (memo[m][start] != null) return memo[m][start];\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i <= N - m; i++) {\\n            int leftSum = sums[i+1] - sums[start];\\n            int rightSum = explore(i + 1, nums, m-1, sums, memo);\\n            int maxSum = Math.max(leftSum, rightSum);\\n            min = Math.min(min, maxSum);\\n        }\\n        memo[m][start] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329836,
                "title": "javascript-binary-search-sol-with-comments",
                "content": "```\\nvar splitArray = function(nums, m) {\\n    /*Largest sum will be atleast as large as the largest number in nums*/\\n    let startS = Math.max(...nums);\\n    /*Largest sum that will be possible is the sum of all the nums*/\\n    let endS = 0;\\n    for(let num of nums){\\n        endS += num;\\n    }\\n    while(startS <= endS){\\n        let midS = Math.floor(startS + (endS - startS)/2);\\n        /*If midS is the sum that we are trying to achieve then how many splits are required*/\\n        let noOfSplits = 1;\\n        let currSum = 0;\\n        /*Keep adding to currSum*/\\n        for(let num of nums){\\n            currSum += num;\\n            /*If currSum exceeds the required sum we create a new split*/\\n            if(currSum > midS){\\n                noOfSplits += 1;\\n                currSum = num;\\n            }\\n        }\\n        /*If number of splits is greater than m that means midS is \\n        too small so increase it by setting startS to midS + 1*/\\n        if(noOfSplits > m){\\n            startS = midS + 1;\\n        }else{\\n            /*Number of splits are less than equal to m that means midS can be achieved using m splits\\n            so try to minimize it since need to minimize the largest sum*/\\n            endS = midS - 1;\\n        }\\n    }\\n    return startS;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nvar splitArray = function(nums, m) {\\n    /*Largest sum will be atleast as large as the largest number in nums*/\\n    let startS = Math.max(...nums);\\n    /*Largest sum that will be possible is the sum of all the nums*/\\n    let endS = 0;\\n    for(let num of nums){\\n        endS += num;\\n    }\\n    while(startS <= endS){\\n        let midS = Math.floor(startS + (endS - startS)/2);\\n        /*If midS is the sum that we are trying to achieve then how many splits are required*/\\n        let noOfSplits = 1;\\n        let currSum = 0;\\n        /*Keep adding to currSum*/\\n        for(let num of nums){\\n            currSum += num;\\n            /*If currSum exceeds the required sum we create a new split*/\\n            if(currSum > midS){\\n                noOfSplits += 1;\\n                currSum = num;\\n            }\\n        }\\n        /*If number of splits is greater than m that means midS is \\n        too small so increase it by setting startS to midS + 1*/\\n        if(noOfSplits > m){\\n            startS = midS + 1;\\n        }else{\\n            /*Number of splits are less than equal to m that means midS can be achieved using m splits\\n            so try to minimize it since need to minimize the largest sum*/\\n            endS = midS - 1;\\n        }\\n    }\\n    return startS;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 725284,
                "title": "clean-python-code-commented-o-n-log-sum-time-o-1-space",
                "content": "**Clean Python Code - Commented - O( N log Sum ) time, O(1) space**\\n\\n\\nCommented version of a clean binary search.\\n\\nAn alternative code with a grindy DP search is also attached (it works with Top 30% speed for all its suffering lol).\\n\\nIdea from:\\nhttps://leetcode.com/problems/split-array-largest-sum/discuss/89846/Python-solution-with-detailed-explanation\\nhttps://leetcode.com/problems/split-array-largest-sum/discuss/89835/java-easy-binary-search-solution-8ms\\nhttps://leetcode.com/problems/split-array-largest-sum/discuss/89819/c-fast-very-clear-explanation-clean-code-solution-with-greedy-algorithm-and-binary-search\\n\\n```\\n# Clean Binary Search Code, O(N log Sum) time complexity, O(1) space\\nclass Solution:\\n    def splitArray(self, A, m: int) -> int:\\n        lo,hi = max(A),sum(A) # lowest and highest value imaginable\\n        while lo<hi: # if lo==hi, there\\'s nothing to be done\\n            mid = (hi+lo)//2 # Guessed max. sub-array value, check how many containers you actually need\\n            n, now = 1, 0 # n = numbers of containers ; now = value of current container\\n            for x in A:\\n                now += x\\n                if now>mid:\\n                    now  = x # Start new container\\n                    n   += 1\\n            if n<=m:\\n                hi = mid # \"mid\" was a valid answer, so we can bound \"answer\"<=mid (perhaps we can still get away with a lower threshold)\\n            else:\\n                lo = mid + 1 # \"mid\" was too small and produced too many containers, our answer is higher\\n        return lo\\n```\\n\\n```\\n# My Original Code, it was a grindy DP search.\\n# It has Top 35% Speed nonetheless, quite good for all its design flaws lol\\nfmin = lambda x,y: x if x<y else y\\nfmax = lambda x,y: x if x>y else y\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def splitArray(self, A, m: int) -> int:\\n        L = len(A)\\n        S = [0]\\n        for x in A:\\n            S.append( S[-1] + x )\\n        total = S[-1]\\n        def getsum(i,j):\\n            return S[j+1]-S[i]\\n        memo = {}\\n        def dp(i,n):\\n            key = i,n\\n            if key in memo:\\n                return memo[key]\\n            #\\n            if (L-i)<n:\\n                result = posInf\\n            elif n==1:\\n                result = getsum(i,L-1)\\n            else:\\n                result = posInf\\n                for j in range(i,L):\\n                    s = getsum(i,j)\\n                    if s<result:\\n                        result = fmin(result, fmax( s,dp(j+1,n-1) ) )\\n                    else:\\n                        break\\n                    if (total-s)<s:\\n                        break\\n            #\\n            memo[key] = result\\n            return result\\n        return dp(0,m)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Clean Binary Search Code, O(N log Sum) time complexity, O(1) space\\nclass Solution:\\n    def splitArray(self, A, m: int) -> int:\\n        lo,hi = max(A),sum(A) # lowest and highest value imaginable\\n        while lo<hi: # if lo==hi, there\\'s nothing to be done\\n            mid = (hi+lo)//2 # Guessed max. sub-array value, check how many containers you actually need\\n            n, now = 1, 0 # n = numbers of containers ; now = value of current container\\n            for x in A:\\n                now += x\\n                if now>mid:\\n                    now  = x # Start new container\\n                    n   += 1\\n            if n<=m:\\n                hi = mid # \"mid\" was a valid answer, so we can bound \"answer\"<=mid (perhaps we can still get away with a lower threshold)\\n            else:\\n                lo = mid + 1 # \"mid\" was too small and produced too many containers, our answer is higher\\n        return lo\\n```\n```\\n# My Original Code, it was a grindy DP search.\\n# It has Top 35% Speed nonetheless, quite good for all its design flaws lol\\nfmin = lambda x,y: x if x<y else y\\nfmax = lambda x,y: x if x>y else y\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def splitArray(self, A, m: int) -> int:\\n        L = len(A)\\n        S = [0]\\n        for x in A:\\n            S.append( S[-1] + x )\\n        total = S[-1]\\n        def getsum(i,j):\\n            return S[j+1]-S[i]\\n        memo = {}\\n        def dp(i,n):\\n            key = i,n\\n            if key in memo:\\n                return memo[key]\\n            #\\n            if (L-i)<n:\\n                result = posInf\\n            elif n==1:\\n                result = getsum(i,L-1)\\n            else:\\n                result = posInf\\n                for j in range(i,L):\\n                    s = getsum(i,j)\\n                    if s<result:\\n                        result = fmin(result, fmax( s,dp(j+1,n-1) ) )\\n                    else:\\n                        break\\n                    if (total-s)<s:\\n                        break\\n            #\\n            memo[key] = result\\n            return result\\n        return dp(0,m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558116,
                "title": "java-binary-search-beats-100",
                "content": "We can first restrict the search space to **[max(nums), sum(nums)]**, the lower bound `max(nums)` means the biggest one is grouped solely and the upper bound `sum(nums)` means there is only one group. \\n\\nTo search in a consecutive range, we can easily think of Binary Search to decrease search space. The valid condition in this problem is almost the same as LC1011, which is whether we can seperate this array into m groups and each group\\'s sum is no larger than current value. \\n\\nSince the subarray should be continuous, it is much easier. We can simply calculate how much groups we need and compare it to m.\\n\\n**Time Complexity**: O(n log(sum(nums))), where n is the length of nums[].\\n**Space Complexity**: O(1)\\n\\nSimilar to: LC1011\\n\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        //range[max(nums), sum(nums)]\\n        int lo = 0, hi = 0;\\n        for(int num: nums){\\n            if(num > lo){\\n                lo = num;\\n            }\\n            hi += num;\\n        }\\n        while (lo <= hi){\\n            int mid = lo + (hi - lo) / 2;\\n            if(mIsValid(nums, m, mid)){\\n                hi = mid - 1;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    private boolean mIsValid(int[] nums, int m, int val){\\n        //if group into m groups, each group\\'s sum <= val\\n        int groupNeed = 0, curSum = 0;\\n        for(int num: nums){\\n            curSum += num;\\n            if(curSum > val){\\n                ++groupNeed;\\n                curSum = num;\\n            }\\n        }\\n        if(curSum > 0){\\n            ++groupNeed;\\n        }\\n        return groupNeed <= m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        //range[max(nums), sum(nums)]\\n        int lo = 0, hi = 0;\\n        for(int num: nums){\\n            if(num > lo){\\n                lo = num;\\n            }\\n            hi += num;\\n        }\\n        while (lo <= hi){\\n            int mid = lo + (hi - lo) / 2;\\n            if(mIsValid(nums, m, mid)){\\n                hi = mid - 1;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    private boolean mIsValid(int[] nums, int m, int val){\\n        //if group into m groups, each group\\'s sum <= val\\n        int groupNeed = 0, curSum = 0;\\n        for(int num: nums){\\n            curSum += num;\\n            if(curSum > val){\\n                ++groupNeed;\\n                curSum = num;\\n            }\\n        }\\n        if(curSum > 0){\\n            ++groupNeed;\\n        }\\n        return groupNeed <= m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360417,
                "title": "java-three-solutions",
                "content": "**1. backtrak + memo + presum**\\n\\nFirstly, in such \\'cut down into regions\\' problems, we could always use backtrack (dfs) method, which enable us to search every possible solution.\\n\\nHere, I additionally leverage memo and presum techniques to make the search process faster. But ultimatly, the time usage is still quiet a lot. (40ms)\\n\\n```\\nclass Solution {\\n    int[] presum;\\n    int[][] dp;\\n    int n,cuts;\\n    public int splitArray(int[] nums, int m) {\\n        n = nums.length;\\n        cuts = m-1;\\n        dp = new int[n][cuts+1];\\n        presum = new int[n+1];\\n        for (int i=1;i<=n;i++) presum[i] = nums[i-1]+presum[i-1];\\n        return dfs(0,presum,cuts);\\n    }\\n    \\n    int dfs(int pos, int[] presum, int cut){\\n        if (cut==0) return presum[n]-presum[pos];\\n        if (dp[pos][cut]!=0) return dp[pos][cut];\\n        int curmax = Integer.MAX_VALUE;\\n        for (int i=pos+1; i<n && cut<=n-i;i++){\\n            curmax = Math.min(curmax, Math.max(presum[i]-presum[pos],\\n                              dfs(i, presum, cut-1)));\\n        }\\n        dp[pos][cut] = curmax;\\n        return curmax;\\n    }\\n}\\n```\\n\\n**2. bottom-up dp**\\n\\nAlso, when there is a top-down dfs, there would be a bottom-up method. \\nAnd the time is reduced for a half. (20ms)\\n\\n```\\nclass Solution {\\n    int n;\\n    int[] presum;\\n    int[][] dp;\\n    public int splitArray(int[] nums, int m) {\\n        n = nums.length;\\n        dp = new int[m][n];\\n        presum = new int[n+1];\\n        for (int i=1;i<=n;i++) presum[i] = nums[i-1]+presum[i-1];\\n        for (int ord=0; ord<m; ord++){\\n            int curmax = Integer.MAX_VALUE;\\n            for (int tail=ord; tail<n-(m-1-ord); tail++){\\n                for (int pre=ord; pre<=tail; pre++){\\n                    if (ord==0) {\\n                        curmax = presum[tail+1];\\n                        continue;\\n                    }\\n                    curmax = Math.min(curmax, Math.max(\\n                      presum[tail+1]-presum[pre],dp[ord-1][pre-1]));\\n                }\\n                dp[ord][tail] = curmax;\\n                curmax = Integer.MAX_VALUE;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n\\n**3. Trial and Error**\\nThe  above  solutions take nearly O(N^3) time complexity to solve the problem.\\nBut by leveraging the binary search tool in trial and error, the time could be reduced to O(NlogN).\\n\\nThe main goal is to test every possible min sum (which is in the rage [max, sum] for correctness), and in every test step, we use a trial process to determine whether the current min sum is valid or not.\\n\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int low=0, high=0, mid, cnt;\\n        for (int i: nums){\\n            low = Math.max(low, i);\\n            high = i>Integer.MAX_VALUE-high?Integer.MAX_VALUE:high+i;\\n        }\\n        while (low < high){\\n            mid = low + (high-low)/2;\\n            cnt = trial(nums, mid);\\n            if (cnt>m){\\n                low = mid+1;\\n            }else if (cnt<m){\\n                high = mid-1;\\n            }else{\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    int trial(int[] nums, int k){\\n        int cnt=1, cursum=0;\\n        for (int i:nums){\\n            cursum += i;\\n            if (cursum>k){\\n                cursum=i;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] presum;\\n    int[][] dp;\\n    int n,cuts;\\n    public int splitArray(int[] nums, int m) {\\n        n = nums.length;\\n        cuts = m-1;\\n        dp = new int[n][cuts+1];\\n        presum = new int[n+1];\\n        for (int i=1;i<=n;i++) presum[i] = nums[i-1]+presum[i-1];\\n        return dfs(0,presum,cuts);\\n    }\\n    \\n    int dfs(int pos, int[] presum, int cut){\\n        if (cut==0) return presum[n]-presum[pos];\\n        if (dp[pos][cut]!=0) return dp[pos][cut];\\n        int curmax = Integer.MAX_VALUE;\\n        for (int i=pos+1; i<n && cut<=n-i;i++){\\n            curmax = Math.min(curmax, Math.max(presum[i]-presum[pos],\\n                              dfs(i, presum, cut-1)));\\n        }\\n        dp[pos][cut] = curmax;\\n        return curmax;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int n;\\n    int[] presum;\\n    int[][] dp;\\n    public int splitArray(int[] nums, int m) {\\n        n = nums.length;\\n        dp = new int[m][n];\\n        presum = new int[n+1];\\n        for (int i=1;i<=n;i++) presum[i] = nums[i-1]+presum[i-1];\\n        for (int ord=0; ord<m; ord++){\\n            int curmax = Integer.MAX_VALUE;\\n            for (int tail=ord; tail<n-(m-1-ord); tail++){\\n                for (int pre=ord; pre<=tail; pre++){\\n                    if (ord==0) {\\n                        curmax = presum[tail+1];\\n                        continue;\\n                    }\\n                    curmax = Math.min(curmax, Math.max(\\n                      presum[tail+1]-presum[pre],dp[ord-1][pre-1]));\\n                }\\n                dp[ord][tail] = curmax;\\n                curmax = Integer.MAX_VALUE;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int low=0, high=0, mid, cnt;\\n        for (int i: nums){\\n            low = Math.max(low, i);\\n            high = i>Integer.MAX_VALUE-high?Integer.MAX_VALUE:high+i;\\n        }\\n        while (low < high){\\n            mid = low + (high-low)/2;\\n            cnt = trial(nums, mid);\\n            if (cnt>m){\\n                low = mid+1;\\n            }else if (cnt<m){\\n                high = mid-1;\\n            }else{\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    int trial(int[] nums, int k){\\n        int cnt=1, cursum=0;\\n        for (int i:nums){\\n            cursum += i;\\n            if (cursum>k){\\n                cursum=i;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351393,
                "title": "binary-search-with-greedy",
                "content": "```\\n/**\\n     * splitArray(): The answer must lie somewhere in between {maximum item, sum of all items}.\\n     * We can use bracketing techniques to keep guessing and checking until we found the\\n     * final answer.\\n     */\\n    public static int splitArray(int[] array, int m) {\\n        int lower = getMaximumOfArray(array);\\n        int upper = getSumOfArray(array);\\n        if(m == 1){\\n            return upper;\\n        }else if(m == array.length){\\n            return lower;\\n        }\\n        while (lower <= upper) {\\n            int mid = (lower + upper) / 2;\\n            if (isValid(array, m, mid)){ //if this bracket works\\n                upper = mid - 1; //try to do better\\n            } else {\\n                lower = mid + 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n\\n    public static int getMaximumOfArray(int[] array) {\\n        int max = 0;\\n        for (int item : array) {\\n            max = Math.max(item, max);\\n        }\\n        return max;\\n    }\\n\\n    public static int getSumOfArray(int[] array) {\\n        int sum = 0;\\n        for (int item : array) {\\n            sum += item;\\n        }\\n        return sum;\\n    }\\n\\n    /**\\n     * check if the array can be split into m sub-arrays, where each sub-array\\'s sum <= mid.\\n     *\\n     * Suppose you have the sub-array [2,3, 4, 1, 6, 0] and you want to see if you can split\\n     * it into three subarray such that all are less than the ceiling 6. A greedy strategy\\n     * is to start the first subarray at index two and stretch it as much as possible while\\n     * it is less than the ceiling. Once it passes the ceiling, immediately start the next\\n     * sub array. If you keep doing this and the subarray count passes m, its not possible.\\n     */\\n    public static boolean isValid(int[] array, int m, int ceiling) {\\n        int subarrayCount = 1;\\n        long subarraySum = 0;\\n        for (int item : array) {\\n            if ((subarraySum + item) <= ceiling) {\\n                subarraySum += item; //we can afford this item\\n            } else { //must start new sub-array\\n                subarrayCount++;\\n                subarraySum = item;\\n            }\\n        }\\n        return (subarrayCount <= m);\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n     * splitArray(): The answer must lie somewhere in between {maximum item, sum of all items}.\\n     * We can use bracketing techniques to keep guessing and checking until we found the\\n     * final answer.\\n     */\\n    public static int splitArray(int[] array, int m) {\\n        int lower = getMaximumOfArray(array);\\n        int upper = getSumOfArray(array);\\n        if(m == 1){\\n            return upper;\\n        }else if(m == array.length){\\n            return lower;\\n        }\\n        while (lower <= upper) {\\n            int mid = (lower + upper) / 2;\\n            if (isValid(array, m, mid)){ //if this bracket works\\n                upper = mid - 1; //try to do better\\n            } else {\\n                lower = mid + 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n\\n    public static int getMaximumOfArray(int[] array) {\\n        int max = 0;\\n        for (int item : array) {\\n            max = Math.max(item, max);\\n        }\\n        return max;\\n    }\\n\\n    public static int getSumOfArray(int[] array) {\\n        int sum = 0;\\n        for (int item : array) {\\n            sum += item;\\n        }\\n        return sum;\\n    }\\n\\n    /**\\n     * check if the array can be split into m sub-arrays, where each sub-array\\'s sum <= mid.\\n     *\\n     * Suppose you have the sub-array [2,3, 4, 1, 6, 0] and you want to see if you can split\\n     * it into three subarray such that all are less than the ceiling 6. A greedy strategy\\n     * is to start the first subarray at index two and stretch it as much as possible while\\n     * it is less than the ceiling. Once it passes the ceiling, immediately start the next\\n     * sub array. If you keep doing this and the subarray count passes m, its not possible.\\n     */\\n    public static boolean isValid(int[] array, int m, int ceiling) {\\n        int subarrayCount = 1;\\n        long subarraySum = 0;\\n        for (int item : array) {\\n            if ((subarraySum + item) <= ceiling) {\\n                subarraySum += item; //we can afford this item\\n            } else { //must start new sub-array\\n                subarrayCount++;\\n                subarraySum = item;\\n            }\\n        }\\n        return (subarrayCount <= m);\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 316692,
                "title": "easy-c-100",
                "content": "Using **binary search** we`d like to find the minimal number **x** such that we can split our array in **m or less subarrays** with the largest sum  **x**. The function **can** cheks if we can split our array into these subarrays.\\n```\\nclass Solution {\\npublic:\\n    bool can(long long v, int m, const vector<int> & nums)\\n    {\\n        long long temp = 0, amount = 1, n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(nums[i] > v)\\n                return false;\\n            \\n            if(temp + nums[i] <= v)\\n                temp += nums[i];\\n            else\\n            {\\n                ++amount;\\n                temp = nums[i];\\n            }\\n        }\\n     \\n        return (amount <= m);\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        \\n        for(int i = 0; i < n; ++i)\\n            sum += nums[i];\\n        \\n        long long l = 0, r = sum, curans;\\n        \\n        while(l <= r)\\n        {\\n            long long mid = (l + r) / 2;\\n            if(can(mid, m, nums))\\n            {\\n                curans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        \\n        \\n        return curans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool can(long long v, int m, const vector<int> & nums)\\n    {\\n        long long temp = 0, amount = 1, n = nums.size();\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            if(nums[i] > v)\\n                return false;\\n            \\n            if(temp + nums[i] <= v)\\n                temp += nums[i];\\n            else\\n            {\\n                ++amount;\\n                temp = nums[i];\\n            }\\n        }\\n     \\n        return (amount <= m);\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        long long sum = 0;\\n        \\n        for(int i = 0; i < n; ++i)\\n            sum += nums[i];\\n        \\n        long long l = 0, r = sum, curans;\\n        \\n        while(l <= r)\\n        {\\n            long long mid = (l + r) / 2;\\n            if(can(mid, m, nums))\\n            {\\n                curans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        \\n        \\n        return curans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89836,
                "title": "python-dp-memoization-gets-tle-but-java-passes-can-this-be-fixed",
                "content": "```\\nclass Solution(object):\\n    def helper(self, i, nums, m, cache):\\n        if i == len(nums):\\n            return 0\\n        elif m == 1:\\n            return sum(nums[i:])\\n        else:\\n            if i in cache and m in cache[i]:\\n                return cache[i][m]\\n            cache.setdefault(i, {})\\n            cache[i][m] = float('inf')\\n            for j in range(1,len(nums)+1):\\n                left, right = sum(nums[i:i+j]), self.helper(i+j, nums, m-1, cache)\\n                cache[i][m] = min(cache[i][m], max(left, right))\\n            return cache[i][m]\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        cache = {}\\n        return self.helper(0, nums, m, cache)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, i, nums, m, cache):\\n        if i == len(nums):\\n            return 0\\n        elif m == 1:\\n            return sum(nums[i:])\\n        else:\\n            if i in cache and m in cache[i]:\\n                return cache[i][m]\\n            cache.setdefault(i, {})\\n            cache[i][m] = float('inf')\\n            for j in range(1,len(nums)+1):\\n                left, right = sum(nums[i:i+j]), self.helper(i+j, nums, m-1, cache)\\n                cache[i][m] = min(cache[i][m], max(left, right))\\n            return cache[i][m]\\n    \\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        cache = {}\\n        return self.helper(0, nums, m, cache)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89825,
                "title": "java-recursive-dp-having-trouble-in-iterative-dp",
                "content": "I solved this by recursion that will go TLE :( But I am having trouble in converting it into iterative version. Please help!\\n\\n\\tpublic int splitArray(int[] nums, int m) {\\n\\t\\tif (nums.length == 0 || nums == null || m == 0)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\treturn splitArray(nums, m, 0);\\n\\t}\\n\\n\\tpublic int splitArray(int[] nums, int m, int start) {\\n\\t\\tif (nums.length == 0 || nums == null || m == 0)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\tif (start > nums.length)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\tif (m == 1) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int i = start; i < nums.length; i++)\\n\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\tint sum = 0;\\n\\t\\tint split = 0;\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tfor (int i = start; i < nums.length; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tsplit = Math.max(sum, splitArray(nums, m - 1, i + 1));\\n\\t\\t\\tmin = Math.min(min, split);\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}",
                "solutionTags": [],
                "code": "I solved this by recursion that will go TLE :( But I am having trouble in converting it into iterative version. Please help!\\n\\n\\tpublic int splitArray(int[] nums, int m) {\\n\\t\\tif (nums.length == 0 || nums == null || m == 0)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\treturn splitArray(nums, m, 0);\\n\\t}\\n\\n\\tpublic int splitArray(int[] nums, int m, int start) {\\n\\t\\tif (nums.length == 0 || nums == null || m == 0)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\tif (start > nums.length)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\t\\tif (m == 1) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int i = start; i < nums.length; i++)\\n\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\tint sum = 0;\\n\\t\\tint split = 0;\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tfor (int i = start; i < nums.length; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tsplit = Math.max(sum, splitArray(nums, m - 1, i + 1));\\n\\t\\t\\tmin = Math.min(min, split);\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3891469,
                "title": "an-easy-to-understand-and-well-explained-solution",
                "content": "# Intuition\\n##### The intuition behind the problem is that if the sum of a subarray is too small, then we will not be able to split the array into k subarrays. This is because the sum of each subarray must be at least the minimum sum of a subarray. Therefore we can solve the problem by performing binary search on sum of the elements\\n\\n---\\n\\n\\n# Approach\\n##### First find the maximum element in the array. This is the smallest possible sum of a subarray when k = nums.length. Then calculate the sum of all elements in the array. This is the largest possible sum of a subarray when k=1 and therefore one subarray is only possible. Then do binary search on the possible sums of subarrays. The low bound is the maximum element in the array, and the high bound is the sum of all elements in the array.\\n\\n###### The code repeatedly does the following:\\n\\n1. Calculate the middle value between the low bound and the high bound.\\n2. Check if it is possible to split the array into k subarrays where the sum of each subarray is at most the middle value.\\n- If it is possible, then the high bound is set to the middle value minus 1. This means that we can find a solution with a sum that is at most the middle value.\\n- Otherwise, the low bound is set to the middle value plus 1. This means that the middle value is too small, and we need to look for a solution with a larger sum.\\nThe code continues the binary search until the low bound is greater than the high bound. At this point, we have found the smallest possible sum of a subarray that can be split into k subarrays.\\n\\n---\\n\\n\\n# Complexity\\n##### - Time complexity:\\n###### The time complexity of the algorithm is O(n log n), where n is the length of the array. This is because the binary search algorithm requires O(log n) time to find the middle value, and the isPossible function requires O(n) time to check if it is possible to split the array into k subarrays with a sum of the middle value.\\n\\n##### - Space complexity:\\n###### The space complexity of the algorithm is O(1), because it only requires a constant amount of space to store the low bound, the high bound, and the middle value.\\n\\n###### I hope this explanation is helpful!\\n\\n# Code\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n        int maxElement = Integer.MIN_VALUE;\\n        int sum = 0;\\n        for(int i : nums) {\\n            maxElement = Math.max(i, maxElement);\\n            sum += i;\\n        }\\n        //as lowest max subarray sum will be maxElement when k=nums.length\\n        int low = maxElement;\\n        int high = sum;\\n\\n        while(low<=high) {\\n            int mid = low+(high-low)/2;\\n            //it is possible so try for less value\\n            if(isPossible(nums, mid, k)) high = mid-1;\\n            //not possible try for some higher value\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean isPossible(int[] nums, int mid, int k) {\\n        int sum=0;\\n        int count=1; //the last one\\n        for(int i=0; i<nums.length; i++) {\\n            sum+= nums[i];\\n            if(sum>mid) {\\n                sum=0;\\n                count++;\\n                sum=nums[i];\\n            }\\n            //as if no of subarrays are exceeding k the sum is too small hence increase the low\\n            if(count>k) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n        int maxElement = Integer.MIN_VALUE;\\n        int sum = 0;\\n        for(int i : nums) {\\n            maxElement = Math.max(i, maxElement);\\n            sum += i;\\n        }\\n        //as lowest max subarray sum will be maxElement when k=nums.length\\n        int low = maxElement;\\n        int high = sum;\\n\\n        while(low<=high) {\\n            int mid = low+(high-low)/2;\\n            //it is possible so try for less value\\n            if(isPossible(nums, mid, k)) high = mid-1;\\n            //not possible try for some higher value\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean isPossible(int[] nums, int mid, int k) {\\n        int sum=0;\\n        int count=1; //the last one\\n        for(int i=0; i<nums.length; i++) {\\n            sum+= nums[i];\\n            if(sum>mid) {\\n                sum=0;\\n                count++;\\n                sum=nums[i];\\n            }\\n            //as if no of subarrays are exceeding k the sum is too small hence increase the low\\n            if(count>k) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704698,
                "title": "simple-c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int k,int limit){\\n        int t=1;\\n        int sum=limit;\\n        for(auto i:nums){\\n            if(sum>=i) sum-=i;\\n            else{\\n                sum=limit;\\n                t++;\\n                if(sum<i) return 0;\\n                sum-=i;\\n            }\\n            if(t>k) return 0;\\n            \\n        }\\n        \\n        return 1;\\n\\n    }\\n    int splitArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int i=0,j=nums.size()-1;\\n        int ans=INT_MAX;\\n        for(int it=0;it<n;++it) i=max(i,nums[it]), j+=nums[it];\\n        while(i<=j){\\n            int m=(i+j)/2;\\n            if(solve(nums,k,m)){\\n                ans=min(ans,m);\\n                j=m-1;\\n\\n            }\\n            else i=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int k,int limit){\\n        int t=1;\\n        int sum=limit;\\n        for(auto i:nums){\\n            if(sum>=i) sum-=i;\\n            else{\\n                sum=limit;\\n                t++;\\n                if(sum<i) return 0;\\n                sum-=i;\\n            }\\n            if(t>k) return 0;\\n            \\n        }\\n        \\n        return 1;\\n\\n    }\\n    int splitArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int i=0,j=nums.size()-1;\\n        int ans=INT_MAX;\\n        for(int it=0;it<n;++it) i=max(i,nums[it]), j+=nums[it];\\n        while(i<=j){\\n            int m=(i+j)/2;\\n            if(solve(nums,k,m)){\\n                ans=min(ans,m);\\n                j=m-1;\\n\\n            }\\n            else i=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669191,
                "title": "binary-search-on-answer-code-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIts a binary search on answer problem. Here we do binary search on largest sum if the array is split in k subarrayas. Lets our answer be $$S$$, minimum value it can acheive is the maximum element of `nums` and maximum value can be the sum of all elements in `nums`.\\n\\nIn check function we will check the condition if we took the sum less than or equal to $$S$$ in one segment (subarray) then how many such segments we require? If the number of such segments is less than or equal to the given `k` then that may be a potential answer and we try to find the perfect one.\\n\\nThis question is exactly same as [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/) . You can refer refer to my discussion for this question as well [Discussion](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3658582/binary-search-on-answer-code-approach/) .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    vector<int>pre;\\n    int n;\\n    int check(int mid)\\n    {\\n        int seg = 0, prev = -1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (prev == -1 and pre[i] > mid)\\n            {\\n                seg++;\\n                prev = pre[i - 1];\\n            }\\n            if (prev != -1 and pre[i] - prev > mid)\\n            {\\n                seg++;\\n                prev = pre[i - 1];\\n            }\\n        }\\n        seg++;\\n        return seg;\\n    }\\n\\n    int splitArray(vector<int>& arr, int k) {\\n        n = arr.size();\\n        pre.resize(n);\\n        pre[0] = arr[0];\\n        for (int i = 1; i < n; i++)\\n            pre[i] = pre[i - 1] + arr[i];\\n        int lo = *max_element(arr.begin(),arr.end()), hi = pre.back(), ans = pre.back();\\n        while (lo <= hi)\\n        {\\n            int mid = (lo + hi) / 2;\\n            if (check(mid)>k)\\n                lo=mid+1;\\n            else\\n                hi= mid - 1,ans=mid;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    vector<int>pre;\\n    int n;\\n    int check(int mid)\\n    {\\n        int seg = 0, prev = -1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (prev == -1 and pre[i] > mid)\\n            {\\n                seg++;\\n                prev = pre[i - 1];\\n            }\\n            if (prev != -1 and pre[i] - prev > mid)\\n            {\\n                seg++;\\n                prev = pre[i - 1];\\n            }\\n        }\\n        seg++;\\n        return seg;\\n    }\\n\\n    int splitArray(vector<int>& arr, int k) {\\n        n = arr.size();\\n        pre.resize(n);\\n        pre[0] = arr[0];\\n        for (int i = 1; i < n; i++)\\n            pre[i] = pre[i - 1] + arr[i];\\n        int lo = *max_element(arr.begin(),arr.end()), hi = pre.back(), ans = pre.back();\\n        while (lo <= hi)\\n        {\\n            int mid = (lo + hi) / 2;\\n            if (check(mid)>k)\\n                lo=mid+1;\\n            else\\n                hi= mid - 1,ans=mid;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604082,
                "title": "100-beats-most-optimized-c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        long long int mn=INT_MIN,mid,ans, mx = 0,sum;\\n        int tmp;\\n        for(auto &i: nums){\\n            mx += i;//MAXIMUM POSSIBLE SUM OF AN SUBARRAY\\n            mn = max(mn,i*1LL);//MAX OF MINIMUM POSSIBLE SUM OF SUBARRAY\\n        }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            tmp = 1,sum=0;\\n            for(auto &i: nums){\\n                sum += i;\\n                if(sum>mid){\\n                    tmp++;\\n                    sum = i;\\n                }\\n            }\\n            if(tmp==k){\\n                ans = mid;\\n                mx = mid-1;\\n            }else if(tmp>k){\\n                mn = mid+1;\\n            }else{\\n                ans = mid;\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        long long int mn=INT_MIN,mid,ans, mx = 0,sum;\\n        int tmp;\\n        for(auto &i: nums){\\n            mx += i;//MAXIMUM POSSIBLE SUM OF AN SUBARRAY\\n            mn = max(mn,i*1LL);//MAX OF MINIMUM POSSIBLE SUM OF SUBARRAY\\n        }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            tmp = 1,sum=0;\\n            for(auto &i: nums){\\n                sum += i;\\n                if(sum>mid){\\n                    tmp++;\\n                    sum = i;\\n                }\\n            }\\n            if(tmp==k){\\n                ans = mid;\\n                mx = mid-1;\\n            }else if(tmp>k){\\n                mn = mid+1;\\n            }else{\\n                ans = mid;\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474073,
                "title": "the-only-python-solution-with-dp-memoization",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        x = nums.count(0)\\n        if x>k:\\n            nums.sort()\\n            while(nums.count(0)!=k):\\n                nums.pop(0)\\n  \\n\\n\\n        \\n        ind = 0\\n        dp = {}\\n        return self.splitAray(nums,ind,k,dp)\\n\\n        \\n    def splitAray(self,nums,ind,k,dp):\\n        if k==1:\\n            return sum(nums[ind:len(nums)])\\n            \\n\\n        if (ind,k) in dp:\\n            return dp[(ind,k)]\\n\\n        ans = 1e9\\n        sumi = 0\\n        for i in range(ind,len(nums)):\\n            sumi +=nums[i]\\n            ans = min(ans, max(sumi , self.splitAray(nums,i+1,k-1,dp)))\\n        dp[(ind,k)] = ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        x = nums.count(0)\\n        if x>k:\\n            nums.sort()\\n            while(nums.count(0)!=k):\\n                nums.pop(0)\\n  \\n\\n\\n        \\n        ind = 0\\n        dp = {}\\n        return self.splitAray(nums,ind,k,dp)\\n\\n        \\n    def splitAray(self,nums,ind,k,dp):\\n        if k==1:\\n            return sum(nums[ind:len(nums)])\\n            \\n\\n        if (ind,k) in dp:\\n            return dp[(ind,k)]\\n\\n        ans = 1e9\\n        sumi = 0\\n        for i in range(ind,len(nums)):\\n            sumi +=nums[i]\\n            ans = min(ans, max(sumi , self.splitAray(nums,i+1,k-1,dp)))\\n        dp[(ind,k)] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283045,
                "title": "java-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   binary search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  We have to find the split  such that the largest sum of any       subarray is minimized.\\nThen our search space would be from maxOf(arr) to sumOf(arr)\\nlow = maxOf(arr)\\nhigh = sumOf(arr)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean isSplittable(int maxSum , int[] nums , int k) {\\n       int currentSum = 0 , count = 1;\\n       for(int num : nums) {\\n           currentSum += num;\\n           if(currentSum > maxSum) {\\n               count++;\\n               currentSum = num;\\n               if(count > k) return false;\\n           }\\n\\n       }\\n       return true;\\n    }\\n\\n    public int splitArray(int[] nums, int k) {\\n        int low = 0;\\n        int high = 0;\\n        for(int num : nums) {\\n            low = Math.max(low,num);\\n            high += num;\\n        }\\n\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(isSplittable(mid,nums,k)) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n}\\n\\n/*\\nPlease UpVote If You Like It!!\\nHappy Coding :)\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isSplittable(int maxSum , int[] nums , int k) {\\n       int currentSum = 0 , count = 1;\\n       for(int num : nums) {\\n           currentSum += num;\\n           if(currentSum > maxSum) {\\n               count++;\\n               currentSum = num;\\n               if(count > k) return false;\\n           }\\n\\n       }\\n       return true;\\n    }\\n\\n    public int splitArray(int[] nums, int k) {\\n        int low = 0;\\n        int high = 0;\\n        for(int num : nums) {\\n            low = Math.max(low,num);\\n            high += num;\\n        }\\n\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(isSplittable(mid,nums,k)) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n}\\n\\n/*\\nPlease UpVote If You Like It!!\\nHappy Coding :)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262557,
                "title": "410-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First, we define the range for our binary search. The minimum value can be the maximum value in the array since we cannot have a subarray with a sum greater than the maximum value. The maximum value can be the sum of all elements in the array since we can have k subarrays with each subarray having a sum of at least 1 element.\\n2. We define a helper function \\'is_possible\\' to check if it is possible to split the array into k subarrays such that the maximum sum of any subarray is less than or equal to \\'mid\\'.\\n3. Inside the \\'is_possible\\' function, we iterate through the array and keep adding the current element to a running sum \\'curr_sum\\'. If \\'curr_sum\\' becomes greater than \\'mid\\', we increment our \\'count\\' variable and reset \\'curr_sum\\' to the current element. If \\'count\\' becomes greater than \\'k\\', it means that it is not possible to split the array into k subarrays such that the maximum sum of any subarray is less than or equal to \\'mid\\', so we return False.\\n4. If we have successfully iterated through the entire array and \\'count\\' is less than or equal to \\'k\\', it means that it is possible to split the array into k subarrays such that the maximum sum of any subarray is less than or equal to \\'mid\\', so we return True.\\n5. We then perform binary search on the range defined in step 1. If \\'is_possible(mid)\\' returns True, it means that it is possible to split the array into k subarrays such that the maximum sum of any subarray is less than or equal to \\'mid\\', so we narrow down the search range to the left half. Otherwise, we increase the search range to the right half.\\n6. We continue the binary search until the search range is reduced to a single value. This value is the answer.\\n7. We return the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        # Define the binary search range\\n        left = max(nums)\\n        right = sum(nums)\\n        \\n        # Define a helper function to check if it\\'s possible to split the array into k subarrays\\n        def is_possible(mid):\\n            count = 1\\n            curr_sum = 0\\n            for num in nums:\\n                curr_sum += num\\n                if curr_sum > mid:\\n                    count += 1\\n                    curr_sum = num\\n                    if count > k:\\n                        return False\\n            return True\\n        \\n        # Binary search\\n        while left < right:\\n            mid = (left + right) // 2\\n            if is_possible(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        # Return the answer\\n        return left\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        # Define the binary search range\\n        left = max(nums)\\n        right = sum(nums)\\n        \\n        # Define a helper function to check if it\\'s possible to split the array into k subarrays\\n        def is_possible(mid):\\n            count = 1\\n            curr_sum = 0\\n            for num in nums:\\n                curr_sum += num\\n                if curr_sum > mid:\\n                    count += 1\\n                    curr_sum = num\\n                    if count > k:\\n                        return False\\n            return True\\n        \\n        # Binary search\\n        while left < right:\\n            mid = (left + right) // 2\\n            if is_possible(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        # Return the answer\\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209005,
                "title": "100-faster-time-o-nlogn-space-o-1-nimary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        int mn = 0, mx = 0, mid, x,sum,y;\\n        for(auto &i: nums){\\n            mn = max(mn,i);\\n            mx += i;\\n        }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            x = 1;\\n            sum = 0,y=0;\\n            for(auto &i: nums){\\n                sum += i;\\n                if(sum>mid){\\n                    x++;\\n                    sum = i;\\n                }\\n                y = max(y,sum);\\n            }\\n            if(x>k){\\n                mn = mid+1;\\n            }else {\\n                    // ans = min(ans,y);\\n                mx = mid-1;\\n            }\\n        }\\n        return mx+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        int mn = 0, mx = 0, mid, x,sum,y;\\n        for(auto &i: nums){\\n            mn = max(mn,i);\\n            mx += i;\\n        }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            x = 1;\\n            sum = 0,y=0;\\n            for(auto &i: nums){\\n                sum += i;\\n                if(sum>mid){\\n                    x++;\\n                    sum = i;\\n                }\\n                y = max(y,sum);\\n            }\\n            if(x>k){\\n                mn = mid+1;\\n            }else {\\n                    // ans = min(ans,y);\\n                mx = mid-1;\\n            }\\n        }\\n        return mx+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087796,
                "title": "super-easily-understandable-java-sol-binary-search-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(sum(nums))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n       if(k>nums.length) return -1;\\n       int max=0;\\n       int sum=0;\\n       for(int val:nums){\\n           sum+=val;\\n           max = Math.max(max,val);\\n       }\\n       int low = max, high = sum, ans=0;\\n       while(low<=high){\\n           int mid = low+(high-low)/2;\\n           if(isPossible(nums,mid,k) == true){\\n               ans = mid;\\n               high = mid-1;\\n           }else{\\n               low = mid+1;\\n           }\\n       }return ans;\\n\\n    }\\n    public boolean isPossible(int[] nums, int mid, int k){\\n        int ct=1;\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(sum>mid){\\n                ct++;\\n                sum = nums[i];\\n            }\\n        }return ct<=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n       if(k>nums.length) return -1;\\n       int max=0;\\n       int sum=0;\\n       for(int val:nums){\\n           sum+=val;\\n           max = Math.max(max,val);\\n       }\\n       int low = max, high = sum, ans=0;\\n       while(low<=high){\\n           int mid = low+(high-low)/2;\\n           if(isPossible(nums,mid,k) == true){\\n               ans = mid;\\n               high = mid-1;\\n           }else{\\n               low = mid+1;\\n           }\\n       }return ans;\\n\\n    }\\n    public boolean isPossible(int[] nums, int mid, int k){\\n        int ct=1;\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(sum>mid){\\n                ct++;\\n                sum = nums[i];\\n            }\\n        }return ct<=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857960,
                "title": "python-ez-dp",
                "content": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        \\n        \\n        @cache\\n        def dp(ci, remains): # returns, from ci onwards, min possible sum \\n            \\n            if remains == 1:\\n                return sum(nums[ci:])\\n            \\n            m = inf\\n            curr_sum = 0\\n            for i in range(ci, len(nums)):\\n                curr_sum += nums[i]\\n                temp = max(curr_sum, dp(i + 1, remains - 1))\\n                m = min(m, temp)\\n                \\n                if curr_sum >= m:\\n                    break # minor optimization\\n                \\n            return m\\n                \\n        return dp(0, k)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        \\n        \\n        @cache\\n        def dp(ci, remains): # returns, from ci onwards, min possible sum \\n            \\n            if remains == 1:\\n                return sum(nums[ci:])\\n            \\n            m = inf\\n            curr_sum = 0\\n            for i in range(ci, len(nums)):\\n                curr_sum += nums[i]\\n                temp = max(curr_sum, dp(i + 1, remains - 1))\\n                m = min(m, temp)\\n                \\n                if curr_sum >= m:\\n                    break # minor optimization\\n                \\n            return m\\n                \\n        return dp(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792705,
                "title": "java-binary-search-4ms-solution",
                "content": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n        int low = IntStream.of(nums).max().getAsInt(); //Minimum sum of the subarray\\n        int high = Arrays.stream(nums).sum(); //Maximum sum of the subarray\\n        int min = Integer.MAX_VALUE; //To keep track of our answer.\\n        while(low <= high) {\\n            int mid = (low + high)/2; //Current sum of subarray\\n            if(isValid(mid,nums,k)) { //If subarray sum is valid i.e., it can be used to divide array into K subarrays.\\n                min = Math.min(min,mid);\\n                high = mid - 1; //Find a smaller subarray\\n            }\\n            else low = mid + 1; //We didn\\'t find a subarray large enough to split array into K parts.\\n        }\\n        return min; //return answer\\n    }\\n    private boolean isValid(int mid,int[] nums,int k) {\\n        int count = 0; //No of subarrays that\\'ll be generated for current sum\\n        int low = 0;\\n        while(low < nums.length) {\\n            int sum = 0;\\n            while(low < nums.length && sum + nums[low] <= mid) sum += nums[low++]; \\n            count++; //Increment in no. of subarrays when one subarray is completed.\\n        }\\n        return count <= k; //If no. of subarrays are in the range of K return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n        int low = IntStream.of(nums).max().getAsInt(); //Minimum sum of the subarray\\n        int high = Arrays.stream(nums).sum(); //Maximum sum of the subarray\\n        int min = Integer.MAX_VALUE; //To keep track of our answer.\\n        while(low <= high) {\\n            int mid = (low + high)/2; //Current sum of subarray\\n            if(isValid(mid,nums,k)) { //If subarray sum is valid i.e., it can be used to divide array into K subarrays.\\n                min = Math.min(min,mid);\\n                high = mid - 1; //Find a smaller subarray\\n            }\\n            else low = mid + 1; //We didn\\'t find a subarray large enough to split array into K parts.\\n        }\\n        return min; //return answer\\n    }\\n    private boolean isValid(int mid,int[] nums,int k) {\\n        int count = 0; //No of subarrays that\\'ll be generated for current sum\\n        int low = 0;\\n        while(low < nums.length) {\\n            int sum = 0;\\n            while(low < nums.length && sum + nums[low] <= mid) sum += nums[low++]; \\n            count++; //Increment in no. of subarrays when one subarray is completed.\\n        }\\n        return count <= k; //If no. of subarrays are in the range of K return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233661,
                "title": "recursion-memoization-java-solution",
                "content": "Recursion\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        return recursive(nums, m, 0);\\n    }\\n    \\n    private int recursive(int[] nums, int m, int index) {\\n        if(m==1){\\n            int sum=0;\\n            for(int i=index; i<nums.length; i++)\\n                sum += nums[i];\\n            return sum;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        int sum=0;\\n        for(int i=index; i<=nums.length-m; i++) {\\n            sum += nums[i];\\n            min = Math.min(min, Math.max(sum, recursive(nums, m-1, i+1)));\\n        }\\n        return min;\\n    }\\n}\\n```\\nMemoization\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int[][] memo = new int[m+1][nums.length];\\n        for(int i=0; i<=m; i++)\\n          Arrays.fill(memo[i], -1);\\n        return recursive(nums, m, 0, memo);\\n    }\\n    \\n    private int recursive(int[] nums, int m, int index, int[][] memo) {\\n        if(m==1){\\n            int sum=0;\\n            for(int i=index; i<nums.length; i++)\\n                sum += nums[i];\\n            return sum;\\n        }\\n        if(memo[m][index]!=-1)\\n            return memo[m][index];\\n        \\n        int min = Integer.MAX_VALUE;\\n        int sum=0;\\n        for(int i=index; i<=nums.length-m; i++) {\\n            sum += nums[i];\\n            min = Math.min(min, Math.max(sum, recursive(nums, m-1, i+1, memo)));\\n        }\\n        return memo[m][index]=min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        return recursive(nums, m, 0);\\n    }\\n    \\n    private int recursive(int[] nums, int m, int index) {\\n        if(m==1){\\n            int sum=0;\\n            for(int i=index; i<nums.length; i++)\\n                sum += nums[i];\\n            return sum;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        int sum=0;\\n        for(int i=index; i<=nums.length-m; i++) {\\n            sum += nums[i];\\n            min = Math.min(min, Math.max(sum, recursive(nums, m-1, i+1)));\\n        }\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int[][] memo = new int[m+1][nums.length];\\n        for(int i=0; i<=m; i++)\\n          Arrays.fill(memo[i], -1);\\n        return recursive(nums, m, 0, memo);\\n    }\\n    \\n    private int recursive(int[] nums, int m, int index, int[][] memo) {\\n        if(m==1){\\n            int sum=0;\\n            for(int i=index; i<nums.length; i++)\\n                sum += nums[i];\\n            return sum;\\n        }\\n        if(memo[m][index]!=-1)\\n            return memo[m][index];\\n        \\n        int min = Integer.MAX_VALUE;\\n        int sum=0;\\n        for(int i=index; i<=nums.length-m; i++) {\\n            sum += nums[i];\\n            min = Math.min(min, Math.max(sum, recursive(nums, m-1, i+1, memo)));\\n        }\\n        return memo[m][index]=min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991746,
                "title": "very-clearly-explained-binary-search-solution-in-python-easy-to-understand",
                "content": "**Great question** that could be easily solved using **binary search**!\\n\\nThe question asks us to find out the minimum largest sum, given the array be split into m subarrays.\\n\\nNow, try to **think about the question this way**:\\nIt is obvious that this minimum largest sum ranges from ***max(nums)*** to ***sum(nums).*** So at most we could check all these possibilities, the number of which is sum(nums) - max(nums).\\nFor each of them (the largest sum, from max(nums) to sum(nums)), we just need to **loop through the original array**, finding out if the original array could be **split into less than or equal to m subarrays**.\\nIf not, this largest sum is not qualified, meaning that we need to increase it.\\n\\nBut checking every possible largest sum takes linear time. We could **choose possible largest sum** to check **using binary search**, taking only log time.\\n\\n**Time:** O(n * lg(s))\\nn is the length of original array, for each checking, we need to loop through the original array, taking O(n).\\ns is the sum of original array, which is sum(nums). We binary search from max(nums) to sum(nums), taking O(lg(sum(nums) - max(nums))), approximately O(lg(s)).\\n**Space:** O(1)\\n\\n\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        \\n        low = max(nums)\\n        high = sum(nums)\\n        while low + 1 < high:\\n            mid = (low + high) // 2\\n            count_subarray = self.check(nums, mid)\\n            if count_subarray > m:\\n                low = mid\\n            else:\\n                high = mid \\n        if self.check(nums, low) <= m:\\n            return low\\n        if self.check(nums, high) <= m:\\n            return high\\n    \\n    def check(self, nums, largest_sum):\\n        res = 1\\n        tmp_total = 0\\n        for num in nums:\\n            if tmp_total + num > largest_sum:\\n                res += 1\\n                tmp_total = num\\n            else:\\n                tmp_total += num\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        \\n        low = max(nums)\\n        high = sum(nums)\\n        while low + 1 < high:\\n            mid = (low + high) // 2\\n            count_subarray = self.check(nums, mid)\\n            if count_subarray > m:\\n                low = mid\\n            else:\\n                high = mid \\n        if self.check(nums, low) <= m:\\n            return low\\n        if self.check(nums, high) <= m:\\n            return high\\n    \\n    def check(self, nums, largest_sum):\\n        res = 1\\n        tmp_total = 0\\n        for num in nums:\\n            if tmp_total + num > largest_sum:\\n                res += 1\\n                tmp_total = num\\n            else:\\n                tmp_total += num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901167,
                "title": "c-binary-search-well-commented-solution",
                "content": "Do Binary Search on answer range..below code explains the intuition\\n```\\nclass Solution {\\n    bool subarray(vector<int> nums,int limit,int m){\\n        int count=1;\\n        int sum=0;\\n        for(auto it:nums){\\n            if(it>limit)return false;\\n            if(sum+it>limit)         //if sum exceeds increase subarray count\\n            {\\n            count+=1;\\n            sum=it;\\n                          \\n            }\\n           else sum+=it;          \\n            \\n        }\\n        return count<=m;     //return true if subarray count<=m\\n    }\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int n=nums.size();\\n        int low=*max_element(nums.begin(),nums.end());   //if m==1 then maximum sum would be the largest element in the array\\n        int high;\\n        int ans=0;\\n        for(auto it:nums){\\n            high+=it;          //if m==nums.size() then maximum sum would be sum of all elements in array\\n        } \\n        //so the ans lies between high and low..so use binary search on answer range\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(subarray(nums,mid,m)==false)low=mid+1; //find if mid satisfies condition\\n            else{\\n                ans=mid;       //if it  satisfies still look for  minimized sum\\n                high=mid-1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    bool subarray(vector<int> nums,int limit,int m){\\n        int count=1;\\n        int sum=0;\\n        for(auto it:nums){\\n            if(it>limit)return false;\\n            if(sum+it>limit)         //if sum exceeds increase subarray count\\n            {\\n            count+=1;\\n            sum=it;\\n                          \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901138,
                "title": "python-short-and-simple-nlogsum",
                "content": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def isPossible(maxSum):\\n            curr = count = 0\\n            for i in nums:\\n                count += (i + curr > maxSum)\\n                curr = curr + i if i + curr <= maxSum else i\\n            return count + 1 <= m\\n        \\n        lo, hi = max(nums), sum(nums)\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if isPossible(mid): hi = mid - 1\\n            else: lo = mid + 1\\n        return lo\\n```\\n***\\n```Time complexity: N * Log(max+sum)```\\n```N``` for checking isPossible function and ```Log(max+sum)``` for selecting each mid(maxSum) using binary search.\\n***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def isPossible(maxSum):\\n            curr = count = 0\\n            for i in nums:\\n                count += (i + curr > maxSum)\\n                curr = curr + i if i + curr <= maxSum else i\\n            return count + 1 <= m\\n        \\n        lo, hi = max(nums), sum(nums)\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if isPossible(mid): hi = mid - 1\\n            else: lo = mid + 1\\n        return lo\\n```\n```Time complexity: N * Log(max+sum)```\n```N```\n```Log(max+sum)```",
                "codeTag": "Java"
            },
            {
                "id": 1901112,
                "title": "c-binary-search-easy-to-understand-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& nums, int sum, int m) {\\n        int curSum = 0, maxSum = 0, cnt = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(curSum + nums[i] <= sum) \\n                curSum+= nums[i];\\n            else {\\n                maxSum = max(maxSum, curSum);\\n                curSum = nums[i];\\n                cnt++;\\n            }\\n        }\\n        maxSum = max(maxSum, curSum);\\n        if(maxSum <= sum && cnt < m)\\n            return true;\\n        return false;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int minm = *max_element(nums.begin(), nums.end()), maxm = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        int ans = maxm;\\n        while(minm <= maxm) {\\n            int check = minm + (maxm - minm) / 2;\\n            if(canSplit(nums, check, m)) {\\n                ans = min(ans, check);\\n                maxm = check - 1;\\n            }\\n            else\\n                minm = check + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& nums, int sum, int m) {\\n        int curSum = 0, maxSum = 0, cnt = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(curSum + nums[i] <= sum) \\n                curSum+= nums[i];\\n            else {\\n                maxSum = max(maxSum, curSum);\\n                curSum = nums[i];\\n                cnt++;\\n            }\\n        }\\n        maxSum = max(maxSum, curSum);\\n        if(maxSum <= sum && cnt < m)\\n            return true;\\n        return false;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int minm = *max_element(nums.begin(), nums.end()), maxm = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        int ans = maxm;\\n        while(minm <= maxm) {\\n            int check = minm + (maxm - minm) / 2;\\n            if(canSplit(nums, check, m)) {\\n                ans = min(ans, check);\\n                maxm = check - 1;\\n            }\\n            else\\n                minm = check + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900339,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int startSum=0;\\n        int lastSum=1e9+1;\\n        int ans=0;\\n        while(startSum<=lastSum){\\n            int midSum = startSum+(lastSum-startSum)/2;\\n            if(isPossible(midSum,m,nums)){\\n                ans=midSum;\\n                lastSum=midSum-1;\\n            }\\n            else{\\n                startSum=midSum+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    bool isPossible(int midSum,int m,vector<int>& nums){\\n        int subArrays=1;\\n        int currSum=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>midSum||subArrays>m)\\n                return false;\\n            if(currSum+nums[i]<=midSum){\\n                currSum+=nums[i];\\n            }\\n            else{\\n                currSum=nums[i];\\n                subArrays++;\\n            }\\n        }\\n        return (subArrays<=m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int startSum=0;\\n        int lastSum=1e9+1;\\n        int ans=0;\\n        while(startSum<=lastSum){\\n            int midSum = startSum+(lastSum-startSum)/2;\\n            if(isPossible(midSum,m,nums)){\\n                ans=midSum;\\n                lastSum=midSum-1;\\n            }\\n            else{\\n                startSum=midSum+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    bool isPossible(int midSum,int m,vector<int>& nums){\\n        int subArrays=1;\\n        int currSum=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>midSum||subArrays>m)\\n                return false;\\n            if(currSum+nums[i]<=midSum){\\n                currSum+=nums[i];\\n            }\\n            else{\\n                currSum=nums[i];\\n                subArrays++;\\n            }\\n        }\\n        return (subArrays<=m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900149,
                "title": "410-c-easy-solution-with-comments",
                "content": "**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    //check whether mid value can divide nums into m subarrays \\n    bool isPossible(vector<int>&nums, int mid, int m)\\n    {\\n        int cnt=0, sum=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(sum+nums[i] <= mid) \\n            {\\n                sum += nums[i];\\n            }\\n            else //when subarray\\'s sum is greater than mid\\n            {\\n                cnt++; //increase count for another subarray\\n                sum = nums[i]; //put current value into it\\n                if(nums[i] > mid) return false; //if current value > mid return false\\n            }\\n        }\\n        if(cnt<m) return true; //if we can divide nums into m subarrays return true \\n        return false; //otherwise false;\\n    }\\n    \\n    \\n    int splitArray(vector<int>& nums, int m) \\n    {\\n        if(nums.size()<m) return -1;\\n        \\n        //find low (mini value in nums) and high (total sum of nums)\\n        int low=nums[0], high=0;\\n        for(auto it:nums)\\n        {\\n            low = min(low, it);\\n            high += it;\\n        }\\n        \\n        //use binary search approach\\n        while(low<=high)\\n        {\\n            int mid = (low+high)>>1;\\n            \\n            //if nums easily divided into m subarrays with mid value\\n            if(isPossible(nums, mid, m))\\n            {\\n                high = mid-1;\\n            }\\n            //if nums doesn\\'t divide into m subarrays with mid value\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return low; //it is the min. largest sum\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //check whether mid value can divide nums into m subarrays \\n    bool isPossible(vector<int>&nums, int mid, int m)\\n    {\\n        int cnt=0, sum=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(sum+nums[i] <= mid) \\n            {\\n                sum += nums[i];\\n            }\\n            else //when subarray\\'s sum is greater than mid\\n            {\\n                cnt++; //increase count for another subarray\\n                sum = nums[i]; //put current value into it\\n                if(nums[i] > mid) return false; //if current value > mid return false\\n            }\\n        }\\n        if(cnt<m) return true; //if we can divide nums into m subarrays return true \\n        return false; //otherwise false;\\n    }\\n    \\n    \\n    int splitArray(vector<int>& nums, int m) \\n    {\\n        if(nums.size()<m) return -1;\\n        \\n        //find low (mini value in nums) and high (total sum of nums)\\n        int low=nums[0], high=0;\\n        for(auto it:nums)\\n        {\\n            low = min(low, it);\\n            high += it;\\n        }\\n        \\n        //use binary search approach\\n        while(low<=high)\\n        {\\n            int mid = (low+high)>>1;\\n            \\n            //if nums easily divided into m subarrays with mid value\\n            if(isPossible(nums, mid, m))\\n            {\\n                high = mid-1;\\n            }\\n            //if nums doesn\\'t divide into m subarrays with mid value\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return low; //it is the min. largest sum\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899733,
                "title": "python-binary-search-solution",
                "content": "**Working of splitArray function**:\\n1. We will take **start** as 0 and **end** as sum of nums.\\n2. apply the simple binary search and check if it is possible that **we can divide the array by mid**.\\n3. If **we can divide** array by mid then **move to left side** because we have to**minimize the largest sum** of splitted array.\\n4. If **we can\\'t divide** the array by mid then **move to right** to **increase the sum** of splitted array.\\n\\n\\n**Working of check function**:\\n1. We will add the array element in sumz variable and check if it is less than mid value we will add in sumz.\\n2. if calculated sum if **greater than mid value** than we will increase the value of c (which is no of split required)  or  element of array is greater than mid then we will return **False**\\n3. Otherwise return **True**\\n \\n```\\ndef check(self,nums,mid,m):\\n        sumz = 0\\n        c = 1\\n        n = len(nums)     \\n        \\n        for i in range(n):\\n            if nums[i] + sumz <= mid:\\n                sumz += nums[i]\\n                \\n            else:\\n                c += 1 \\n                if c > m or nums[i] > mid:\\n                    return False\\n                    \\n                sumz = nums[i]\\n        \\n        return True        \\n    \\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        start = 0 \\n        end = sum(nums)\\n        \\n        ans = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start)//2\\n            \\n\\t\\t\\t#if true then mid can be possible answer so store in ans\\n            if self.check(nums,mid,m):\\n                ans = mid\\n                end = mid - 1\\n                \\n            else:\\n                start = mid + 1\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef check(self,nums,mid,m):\\n        sumz = 0\\n        c = 1\\n        n = len(nums)     \\n        \\n        for i in range(n):\\n            if nums[i] + sumz <= mid:\\n                sumz += nums[i]\\n                \\n            else:\\n                c += 1 \\n                if c > m or nums[i] > mid:\\n                    return False\\n                    \\n                sumz = nums[i]\\n        \\n        return True        \\n    \\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        start = 0 \\n        end = sum(nums)\\n        \\n        ans = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start)//2\\n            \\n\\t\\t\\t#if true then mid can be possible answer so store in ans\\n            if self.check(nums,mid,m):\\n                ans = mid\\n                end = mid - 1\\n                \\n            else:\\n                start = mid + 1\\n                \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1899209,
                "title": "binary-search-java-with-notes",
                "content": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int start = 0;\\n        int end = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            start = Math.max(start, nums[i]); // in the end of loop this will contain the max item from the array //\\n                                              // linear search\\n            end += nums[i];\\n        }\\n\\n        // binary search\\n\\n        while (start < end) {\\n            // try for middle as potential answer\\n            int mid = start + (end - start) / 2;\\n\\n            // calculate how many pieces you can divide this in with this max sum\\n            int sum = 0;\\n            int pieces = 1; // atleast 1 you can divide\\n            for (int num : nums) {\\n                if (sum + num > mid) {\\n                    // you cannot add this in this subarray, make new one\\n                    // say you add this in new subarray, then sum = num\\n                    sum = num;\\n                    pieces++;\\n                } else {\\n                    sum += num;\\n                }\\n            }\\n            if (pieces > m) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        return end; // here start == end\\n    }\\n}\\n```\\n\\n**Notes Link** : https://github.com/rizonkumar/LeetCode-Notes/blob/main/410.pdf\\n\\nIf you find the solution useful do upvote! comment down for any doubt.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int start = 0;\\n        int end = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            start = Math.max(start, nums[i]); // in the end of loop this will contain the max item from the array //\\n                                              // linear search\\n            end += nums[i];\\n        }\\n\\n        // binary search\\n\\n        while (start < end) {\\n            // try for middle as potential answer\\n            int mid = start + (end - start) / 2;\\n\\n            // calculate how many pieces you can divide this in with this max sum\\n            int sum = 0;\\n            int pieces = 1; // atleast 1 you can divide\\n            for (int num : nums) {\\n                if (sum + num > mid) {\\n                    // you cannot add this in this subarray, make new one\\n                    // say you add this in new subarray, then sum = num\\n                    sum = num;\\n                    pieces++;\\n                } else {\\n                    sum += num;\\n                }\\n            }\\n            if (pieces > m) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        return end; // here start == end\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899154,
                "title": "c-solution-100-with-binary-search",
                "content": "```\\nint splitArray(int* nums, int numsSize, int m){\\n    long right = 0, left = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        left = left > nums[i] ? left : nums[i];\\n        right += nums[i];\\n    }\\n    right++;\\n    while(left < right)\\n    {\\n        long mid = (left + right) / 2;\\n        int count = 1, temp = 0;\\n        for(int i = 0; i < numsSize; i++)\\n        {\\n            if(temp + nums[i] > mid)\\n            {\\n                count++;\\n                temp = nums[i];\\n            }\\n            else\\n                temp += nums[i];\\n        }\\n        if(count > m) left = mid + 1;\\n        else right = mid;\\n    }\\n    return (int)left;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint splitArray(int* nums, int numsSize, int m){\\n    long right = 0, left = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        left = left > nums[i] ? left : nums[i];\\n        right += nums[i];\\n    }\\n    right++;\\n    while(left < right)\\n    {\\n        long mid = (left + right) / 2;\\n        int count = 1, temp = 0;\\n        for(int i = 0; i < numsSize; i++)\\n        {\\n            if(temp + nums[i] > mid)\\n            {\\n                count++;\\n                temp = nums[i];\\n            }\\n            else\\n                temp += nums[i];\\n        }\\n        if(count > m) left = mid + 1;\\n        else right = mid;\\n    }\\n    return (int)left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728454,
                "title": "simple-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& nums ,  int m  , long long int minLargestSum)\\n    {\\n\\n        int n=nums.size();\\n        int count=1;\\n        long long int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>minLargestSum)\\n            {\\n                return false;\\n            }\\n            if(sum+nums[i]<=minLargestSum)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            else\\n            {\\n                ++count;\\n                sum=nums[i];\\n            }\\n        }\\n        \\n        if(count>m)\\n        {\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n    int splitArray(vector<int>& nums, int m) {\\n\\n        long long int left=0,right=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           right=right+nums[i];\\n           if(left>=nums[i])\\n           {\\n               left=nums[i];\\n           }\\n        }\\n        while(right-left>1)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isPossible(nums , m , mid ))\\n            {\\n                right=mid;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        if(isPossible(nums , m , left))\\n        {\\n            return left;\\n        }\\n        return right;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& nums ,  int m  , long long int minLargestSum)\\n    {\\n\\n        int n=nums.size();\\n        int count=1;\\n        long long int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>minLargestSum)\\n            {\\n                return false;\\n            }\\n            if(sum+nums[i]<=minLargestSum)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            else\\n            {\\n                ++count;\\n                sum=nums[i];\\n            }\\n        }\\n        \\n        if(count>m)\\n        {\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n\\n    int splitArray(vector<int>& nums, int m) {\\n\\n        long long int left=0,right=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           right=right+nums[i];\\n           if(left>=nums[i])\\n           {\\n               left=nums[i];\\n           }\\n        }\\n        while(right-left>1)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isPossible(nums , m , mid ))\\n            {\\n                right=mid;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        if(isPossible(nums , m , left))\\n        {\\n            return left;\\n        }\\n        return right;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598085,
                "title": "improved-dp-with-o-mn-time-and-o-n-space",
                "content": "The editorial DP solution can be improved to `O(mn)` from `O(m * n^2)` by removing the inner-most loop. This is possible because the minimum max-sum of the (k-1)th-step is always increasing while the sum of last split on the kth step is always decreasing. Therefore, we can use the 2-pointer approach to reduce the searching time for the optimal point on the k-th step from `O(n^2)` to to `O(n)`.\\n\\nWe can reduce the space complexity from `O(mn)` to `O(n)` by keeping only the last 2 rows of the DP array.\\n\\nThis approach is better than the editorial Approach 3 (binary search) when sum of the array is large and m is small. However, the test cases seems to be the other case (sum of the array is small and m is large), making the DP approach slower than the Approach 3.\\n\\n\\nO(mn)-space solution:\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        mins = [[0] * len(nums) for _ in range(m + 1)]\\n        \\n        for j in range(len(nums)):\\n            mins[1][j] = nums[j] + (mins[1][j-1] if j >= 1 else 0)\\n        \\n        for i in range(2, m + 1):\\n            k = i - 1\\n            right_total = 0\\n            \\n            for j in range(i-1, len(nums)):\\n                right_total += nums[j]     # sum(nums[k:])\\n                min_max_sum = float(\\'inf\\')\\n                while True:\\n                    left_min_max = mins[i - 1][k - 1]  # min_max of nums[:k-1] with i-1 splits\\n                    min_max_sum = min(min_max_sum, max(left_min_max, right_total))\\n                    if left_min_max >= right_total or k == j:\\n                        break\\n                    # Pre-check next step.\\n                    cand_right_total = right_total - nums[k+1]\\n                    if max(mins[i-1][k], cand_right_total) > min_max_sum:\\n                        break\\n                        \\n                    right_total -= nums[k]\\n                    k += 1\\n                mins[i][j] = min_max_sum\\n        return mins[m][len(nums) - 1]\\n```\\n\\nO(n)-space solution:\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        mins = [0] * len(nums)\\n        for j in range(len(nums)):\\n            mins[j] = nums[j] + (mins[j-1] if j >= 1 else 0)\\n            \\n        for i in range(2, m + 1):\\n            k = i - 1\\n            right_total = 0\\n            \\n            prior_mins = mins\\n            mins = [0] * len(nums)\\n            for j in range(i-1, len(nums)):\\n                right_total += nums[j]     # sum(nums[k:])\\n                min_max_sum = float(\\'inf\\')\\n                while True:\\n                    left_min_max = prior_mins[k - 1]  # min_max of nums[:k-1] with i-1 splits\\n                    min_max_sum = min(min_max_sum, max(left_min_max, right_total))\\n                    if left_min_max >= right_total or k == j:\\n                        break\\n                    # Pre-check next step.\\n                    cand_right_total = right_total - nums[k+1]\\n                    if max(prior_mins[k], cand_right_total) > min_max_sum:\\n                        break\\n                        \\n                    right_total -= nums[k]\\n                    k += 1\\n                mins[j] = min_max_sum\\n            \\n        return mins[len(nums) - 1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        mins = [[0] * len(nums) for _ in range(m + 1)]\\n        \\n        for j in range(len(nums)):\\n            mins[1][j] = nums[j] + (mins[1][j-1] if j >= 1 else 0)\\n        \\n        for i in range(2, m + 1):\\n            k = i - 1\\n            right_total = 0\\n            \\n            for j in range(i-1, len(nums)):\\n                right_total += nums[j]     # sum(nums[k:])\\n                min_max_sum = float(\\'inf\\')\\n                while True:\\n                    left_min_max = mins[i - 1][k - 1]  # min_max of nums[:k-1] with i-1 splits\\n                    min_max_sum = min(min_max_sum, max(left_min_max, right_total))\\n                    if left_min_max >= right_total or k == j:\\n                        break\\n                    # Pre-check next step.\\n                    cand_right_total = right_total - nums[k+1]\\n                    if max(mins[i-1][k], cand_right_total) > min_max_sum:\\n                        break\\n                        \\n                    right_total -= nums[k]\\n                    k += 1\\n                mins[i][j] = min_max_sum\\n        return mins[m][len(nums) - 1]\\n```\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        mins = [0] * len(nums)\\n        for j in range(len(nums)):\\n            mins[j] = nums[j] + (mins[j-1] if j >= 1 else 0)\\n            \\n        for i in range(2, m + 1):\\n            k = i - 1\\n            right_total = 0\\n            \\n            prior_mins = mins\\n            mins = [0] * len(nums)\\n            for j in range(i-1, len(nums)):\\n                right_total += nums[j]     # sum(nums[k:])\\n                min_max_sum = float(\\'inf\\')\\n                while True:\\n                    left_min_max = prior_mins[k - 1]  # min_max of nums[:k-1] with i-1 splits\\n                    min_max_sum = min(min_max_sum, max(left_min_max, right_total))\\n                    if left_min_max >= right_total or k == j:\\n                        break\\n                    # Pre-check next step.\\n                    cand_right_total = right_total - nums[k+1]\\n                    if max(prior_mins[k], cand_right_total) > min_max_sum:\\n                        break\\n                        \\n                    right_total -= nums[k]\\n                    k += 1\\n                mins[j] = min_max_sum\\n            \\n        return mins[len(nums) - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491640,
                "title": "python-binary-search-simplest-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def countSubArrays(self, nums, maxSum):\\n        subArrays = 1\\n        numsSum = 0\\n        for num in nums:\\n            if numsSum + num <= maxSum:\\n                numsSum += num\\n            else:\\n                subArrays += 1\\n                numsSum = num\\n        return subArrays\\n                \\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        \"\"\"\\n            Let\\'s say m = 1 then, the maximum sum of m sub-arrays would definitely be sum(nums) as there would be only one sub-array.\\n            Let\\'s say m = len(nums) then, the maximum sum of m sub-arrays would definitely be max(nums) as there would be len(nums) sub-arrays of length 1 each.\\n            So the maximum sum of m sub-arrays would lie between max(nums) to sum(nums).\\n            Now we have to check which number between max(nums) and sum(nums) satisfies the split of nums into m pieces.\\n            This can be done using binary search.\\n        \"\"\"\\n        minSum = max(nums)\\n        maxSum = sum(nums)\\n        if m == 1:\\n            return maxSum\\n        elif m >= len(nums):\\n            return minSum\\n\\n        while minSum <= maxSum:\\n            midSum = minSum + ((maxSum - minSum) // 2)\\n            \"\"\"\\n                Now how to check whether this midSum will satisfy the split of nums into m pieces and it would be the max sum among all the m sub-arrays.\\n                We will iterate the nums and keep adding the num of nums into sub array until its sum reaches the midSum. \\n\\t\\t\\t\\tOnce midSum is reached, we will take new sub array. Thus midSum would be the max sum among all m sub arrays.\\n            \"\"\"\\n            subArrays = self.countSubArrays(nums, midSum)\\n            if subArrays > m:\\n                minSum = midSum + 1\\n            else:\\n                maxSum = midSum - 1\\n            \\n        return minSum\\n            \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countSubArrays(self, nums, maxSum):\\n        subArrays = 1\\n        numsSum = 0\\n        for num in nums:\\n            if numsSum + num <= maxSum:\\n                numsSum += num\\n            else:\\n                subArrays += 1\\n                numsSum = num\\n        return subArrays\\n                \\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        \"\"\"\\n            Let\\'s say m = 1 then, the maximum sum of m sub-arrays would definitely be sum(nums) as there would be only one sub-array.\\n            Let\\'s say m = len(nums) then, the maximum sum of m sub-arrays would definitely be max(nums) as there would be len(nums) sub-arrays of length 1 each.\\n            So the maximum sum of m sub-arrays would lie between max(nums) to sum(nums).\\n            Now we have to check which number between max(nums) and sum(nums) satisfies the split of nums into m pieces.\\n            This can be done using binary search.\\n        \"\"\"\\n        minSum = max(nums)\\n        maxSum = sum(nums)\\n        if m == 1:\\n            return maxSum\\n        elif m >= len(nums):\\n            return minSum\\n\\n        while minSum <= maxSum:\\n            midSum = minSum + ((maxSum - minSum) // 2)\\n            \"\"\"\\n                Now how to check whether this midSum will satisfy the split of nums into m pieces and it would be the max sum among all the m sub-arrays.\\n                We will iterate the nums and keep adding the num of nums into sub array until its sum reaches the midSum. \\n\\t\\t\\t\\tOnce midSum is reached, we will take new sub array. Thus midSum would be the max sum among all m sub arrays.\\n            \"\"\"\\n            subArrays = self.countSubArrays(nums, midSum)\\n            if subArrays > m:\\n                minSum = midSum + 1\\n            else:\\n                maxSum = midSum - 1\\n            \\n        return minSum\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135084,
                "title": "easy-python-solution-binary-search",
                "content": "\\tl, r = max(nums), sum(nums)\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tcount, cur = 1, 0\\n\\t\\tfor num in nums:\\n\\t\\t\\tcur += num\\n\\t\\t\\tif cur > mid:\\n\\t\\t\\t\\tcur = num\\n\\t\\t\\t\\tcount += 1\\n\\t\\tif count > m:\\n\\t\\t\\tl = mid + 1\\n\\t\\telse:\\n\\t\\t\\tr = mid\\n\\treturn l",
                "solutionTags": [],
                "code": "\\tl, r = max(nums), sum(nums)\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tcount, cur = 1, 0\\n\\t\\tfor num in nums:\\n\\t\\t\\tcur += num\\n\\t\\t\\tif cur > mid:\\n\\t\\t\\t\\tcur = num\\n\\t\\t\\t\\tcount += 1\\n\\t\\tif count > m:\\n\\t\\t\\tl = mid + 1\\n\\t\\telse:\\n\\t\\t\\tr = mid\\n\\treturn l",
                "codeTag": "Unknown"
            },
            {
                "id": 847572,
                "title": "my-java-solution-binary-search",
                "content": "class Solution {\\n \\n\\t public int splitArray(int[] arr, int m) {\\n        int n = arr.length;\\n        int ans = -1, max = arr[0], sum = 0;\\n\\t\\t\\n\\t\\tfor(int val:arr) {\\n\\t\\t\\tsum += val;\\n\\t\\t\\tmax = Math.max(max, val);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint lo = max, hi = sum, mid = -1;\\n\\t\\t\\n\\t\\twhile(lo<=hi) {\\n\\t\\t\\tmid = lo + (hi-lo)/2;\\n\\t\\t\\tint x = parts(arr, n, mid);\\n\\t\\t\\tif(x>m) lo = mid + 1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n    }\\n    \\n    public int parts(int[] arr, int n, int cap) {\\n\\t\\t\\n\\t\\tint x = 1, sum = 0;\\n\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tif(sum>cap) {\\n\\t\\t\\t\\tsum = arr[i];\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t}\\n \\t\\t}\\n\\t\\t\\n\\t\\treturn x;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n \\n\\t public int splitArray(int[] arr, int m) {\\n        int n = arr.length;\\n        int ans = -1, max = arr[0], sum = 0;\\n\\t\\t\\n\\t\\tfor(int val:arr) {\\n\\t\\t\\tsum += val;\\n\\t\\t\\tmax = Math.max(max, val);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 563926,
                "title": "explained-java-solution",
                "content": "Space complexity = constant OR 1; anything less than n is considered as constant\\nConsidering input array length = n\\nConsidering feed for binary search is of length.= m [10------32] \\nTime Complexity = O(n) + O(log m) * n\\n\\tExplaination: \\n\\t\\t```log For the first O(n) it is because of iterating over nums array to get max and sum.\\n\\t\\tFor the second O(log m) * n is because binary search over low and high AND in each iteration we iterate over n items. ```log\\nPlease feel free to correct the explainations or any mistakes so done.\\n\\n\\n```java\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        //without hint it is difficult to get to the solution and not intuitive\\n        //we can use binary search to solve this question\\n        //principle for binary search is \\n        //1 sorted\\n        //2 low, mid and high\\n        //we need to find the case when m is max and when m is min\\n        //when m is high means the number of partition is max which means each entry in array is considered an individual array \\n        //meaning m is high then result would be max(all elements)\\n        //when m is low means m = 1 because we cant have 0 partitions(m = 0)\\n        //in such case the result would be sum of entire array\\n        //when m = 1; nums = [7,2,5,10, 8] the result would be sum of all numbers since this is one partition ==>sum(nums)\\n        //when m = max; meaning max number of partition possible which would be [7][2][5][10][8] or m = 5 and result would be\\n        //max of each element in partition which would be the minimum sum possible\\n        \\n        int max = 0, sum = 0;\\n        //when m is  lowest; sum should be the result\\n        //when m is highest; max should be the result\\n        \\n        for(int num: nums) {\\n            sum +=num;\\n            max = Math.max(max, num);\\n        }\\n        \\n        \\n        //now the binary search part we need to go from minimum m result to maximum m result keeping in mind we need to stabilize \\n        //between number of partition and the sum\\n        int low = max, high = sum;\\n        while(low < high) {\\n            int mid = low + (high - low)/2;//considering higher values for number overflow\\n            //now ballpark minimal largest sum viz result is mid at this iteration\\n            //low = 32 OR sum(nums)\\n            //high = 10\\n            //mid is between 10 and 32 which is 21 so we need to see what is partition count when target for each chunk is 21\\n            if (getPartitionCount(nums, mid) > m) {\\n                //the number of partition count we got with mid as result is making more partitions than asked in question\\n                //so let us reduce our result value and switch to the first half of the range where we can place our ball for \\n                //result or where each chunk can be of that as a sum\\n               low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n            \\n        }        \\n        return low;\\n    }\\n    //largestCurrentSum ===> mid ===> 21(for first iteration)==>[low---------mid-------high]\\n    //based on what the partotition count is obtained the caller func would set high or low and truncate length by half(ofsearch)\\n    public int getPartitionCount(int[] nums, int largestCurrentSum) {\\n        \\n        int tempSum = 0, partitionCount = 1;\\n        \\n        //logic is try to partition based on mid ; we keep on virtually chopping the array once we reach that value\\n        //OR given an array find how many chunks u can break the array into ,  to reach mid\\n        \\n        for(int num: nums) {\\n            if (tempSum+num >largestCurrentSum) {\\n                //re-init since the last entry was contained within mid\\n                tempSum = num;\\n                partitionCount++;\\n                \\n            } else {\\n                tempSum +=num;\\n                \\n            }\\n            \\n        \\n        }\\n        \\n            return partitionCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```log For the first O(n) it is because of iterating over nums array to get max and sum.\\n\\t\\tFor the second O(log m) * n is because binary search over low and high AND in each iteration we iterate over n items. ```\n```java\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        //without hint it is difficult to get to the solution and not intuitive\\n        //we can use binary search to solve this question\\n        //principle for binary search is \\n        //1 sorted\\n        //2 low, mid and high\\n        //we need to find the case when m is max and when m is min\\n        //when m is high means the number of partition is max which means each entry in array is considered an individual array \\n        //meaning m is high then result would be max(all elements)\\n        //when m is low means m = 1 because we cant have 0 partitions(m = 0)\\n        //in such case the result would be sum of entire array\\n        //when m = 1; nums = [7,2,5,10, 8] the result would be sum of all numbers since this is one partition ==>sum(nums)\\n        //when m = max; meaning max number of partition possible which would be [7][2][5][10][8] or m = 5 and result would be\\n        //max of each element in partition which would be the minimum sum possible\\n        \\n        int max = 0, sum = 0;\\n        //when m is  lowest; sum should be the result\\n        //when m is highest; max should be the result\\n        \\n        for(int num: nums) {\\n            sum +=num;\\n            max = Math.max(max, num);\\n        }\\n        \\n        \\n        //now the binary search part we need to go from minimum m result to maximum m result keeping in mind we need to stabilize \\n        //between number of partition and the sum\\n        int low = max, high = sum;\\n        while(low < high) {\\n            int mid = low + (high - low)/2;//considering higher values for number overflow\\n            //now ballpark minimal largest sum viz result is mid at this iteration\\n            //low = 32 OR sum(nums)\\n            //high = 10\\n            //mid is between 10 and 32 which is 21 so we need to see what is partition count when target for each chunk is 21\\n            if (getPartitionCount(nums, mid) > m) {\\n                //the number of partition count we got with mid as result is making more partitions than asked in question\\n                //so let us reduce our result value and switch to the first half of the range where we can place our ball for \\n                //result or where each chunk can be of that as a sum\\n               low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n            \\n        }        \\n        return low;\\n    }\\n    //largestCurrentSum ===> mid ===> 21(for first iteration)==>[low---------mid-------high]\\n    //based on what the partotition count is obtained the caller func would set high or low and truncate length by half(ofsearch)\\n    public int getPartitionCount(int[] nums, int largestCurrentSum) {\\n        \\n        int tempSum = 0, partitionCount = 1;\\n        \\n        //logic is try to partition based on mid ; we keep on virtually chopping the array once we reach that value\\n        //OR given an array find how many chunks u can break the array into ,  to reach mid\\n        \\n        for(int num: nums) {\\n            if (tempSum+num >largestCurrentSum) {\\n                //re-init since the last entry was contained within mid\\n                tempSum = num;\\n                partitionCount++;\\n                \\n            } else {\\n                tempSum +=num;\\n                \\n            }\\n            \\n        \\n        }\\n        \\n            return partitionCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343015,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:      \\n        def valid(x):\\n            count = 1\\n            temp = 0\\n            for n in nums:\\n                if temp + n > x:\\n                    count += 1\\n                    if count > m:\\n                        return False\\n                    temp = n\\n                else:\\n                    temp += n\\n            return True\\n        \\n        l,r = max(nums),sum(nums)\\n        while l < r:\\n            mid = (l+r)//2\\n            if valid(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```\\nTime Onlogn\\nSpace O1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:      \\n        def valid(x):\\n            count = 1\\n            temp = 0\\n            for n in nums:\\n                if temp + n > x:\\n                    count += 1\\n                    if count > m:\\n                        return False\\n                    temp = n\\n                else:\\n                    temp += n\\n            return True\\n        \\n        l,r = max(nums),sum(nums)\\n        while l < r:\\n            mid = (l+r)//2\\n            if valid(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89878,
                "title": "easy-c-binary-search-solution-with-explanation",
                "content": "Since subarrays are non empty, and numbers are non-negative, result can be no less than max element in the array. It also can not be more than the sum of array elements. We now have min and max possible answers and can use binary search to get the exact result\\n```\\n    bool splits(vector<int>& nums, int m, long max_largest_sum)\\n    {\\n        long cur_subarray_sum = nums[0];\\n        int nsubarays = 1;\\n        for(int i = 1; i < nums.size(); ++i)\\n        {\\n            cur_subarray_sum += nums[i];\\n            if(cur_subarray_sum > max_largest_sum)\\n            {\\n                ++nsubarays;\\n                cur_subarray_sum = nums[i];\\n            }\\n        }\\n        if(nsubarays > m)\\n           return false;\\n        return true;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        long minres = nums[0], maxres = nums[0];\\n        for(int i = 1; i < n; ++i)\\n        {\\n            minres = max(minres,long(nums[i]));\\n            maxres += nums[i];\\n        }\\n        int res = 0;\\n        while(minres <= maxres)\\n        {\\n            long mid = (minres+maxres)/2;\\n            if(splits(nums,m,mid))\\n            {\\n               maxres  = mid-1;\\n               res = mid;\\n            }\\n            else\\n               minres = mid+1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool splits(vector<int>& nums, int m, long max_largest_sum)\\n    {\\n        long cur_subarray_sum = nums[0];\\n        int nsubarays = 1;\\n        for(int i = 1; i < nums.size(); ++i)\\n        {\\n            cur_subarray_sum += nums[i];\\n            if(cur_subarray_sum > max_largest_sum)\\n            {\\n                ++nsubarays;\\n                cur_subarray_sum = nums[i];\\n            }\\n        }\\n        if(nsubarays > m)\\n           return false;\\n        return true;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        long minres = nums[0], maxres = nums[0];\\n        for(int i = 1; i < n; ++i)\\n        {\\n            minres = max(minres,long(nums[i]));\\n            maxres += nums[i];\\n        }\\n        int res = 0;\\n        while(minres <= maxres)\\n        {\\n            long mid = (minres+maxres)/2;\\n            if(splits(nums,m,mid))\\n            {\\n               maxres  = mid-1;\\n               res = mid;\\n            }\\n            else\\n               minres = mid+1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971504,
                "title": "0ms-binary-search-o-n-log-sum-nums-max-nums",
                "content": "***I hope it is clear to understand***\\n***Any questions and suggestions are welcome***\\n\\n\\n- Time complexity:\\n```O(n*(log(sum(nums) - max(nums)))```\\n\\n# Code\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n\\n        int l = 0,r = 0,m;\\n\\n        for(int i = 0; i< nums.length;i++){\\n            l = Math.max(l,nums[i]);\\n            r+=nums[i];\\n        }\\n\\n        while(l<r){\\n            m=(l+r)/2;\\n            if(canBeSplitted(m, k, nums)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n    public boolean canBeSplitted(int m, int k, int[] nums){\\n        int count = 1;\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(sum+nums[i]>m){\\n                count++;\\n                sum=0;\\n            }\\n            sum+=nums[i];\\n        }\\n        return count<=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```O(n*(log(sum(nums) - max(nums)))```\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n\\n        int l = 0,r = 0,m;\\n\\n        for(int i = 0; i< nums.length;i++){\\n            l = Math.max(l,nums[i]);\\n            r+=nums[i];\\n        }\\n\\n        while(l<r){\\n            m=(l+r)/2;\\n            if(canBeSplitted(m, k, nums)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n    public boolean canBeSplitted(int m, int k, int[] nums){\\n        int count = 1;\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(sum+nums[i]>m){\\n                count++;\\n                sum=0;\\n            }\\n            sum+=nums[i];\\n        }\\n        return count<=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922644,
                "title": "most-optimal-solution-using-binary-search-with-explanation",
                "content": "\\n\\n# Approach\\nThe countPartitions function takes an array and a maximum sum as input and returns the number of partitions needed to ensure that no subarray\\'s sum exceeds the maximum sum. It iterates through the array, keeping track of a running sum (subSum). If adding the current element to subSum keeps it within the maximum sum limit, the element is included in the current partition. If adding the current element would exceed the maximum sum, a new partition is started, and the current element becomes the start of the new partition. The function returns the total number of partitions.\\n\\nThe splitArray function uses binary search to find the optimal value for the minimum maximum sum. It initializes low as the maximum element in the array (as any subarray\\'s sum must be at least that) and high as the sum of all elements in the array. It then performs binary search in the range [low, high]. For each mid-point value, it calculates the number of partitions using the countPartitions function. If the number of partitions exceeds \\'K\\', it means the maximum sum is too small, so the binary search narrows the range to the upper half. If the number of partitions is less than or equal to \\'K\\', it means the maximum sum is achievable, and the binary search narrows the range to the lower half. Finally, when the binary search converges, it returns the optimal minimum maximum sum.\\n\\n# Complexity\\n- Time complexity:\\nO(log(sum-max+1)*n)\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int> nums, int maxSum) {\\n        int partitions = 1;\\n        long long subSum = 0;\\n        for(int i = 0; i< nums.size(); i++) {\\n            if(subSum + nums[i] <= maxSum) subSum += nums[i];\\n            else {\\n                partitions++;\\n                subSum = nums[i];\\n            }\\n        }\\n        return partitions;\\n    }\\n\\n    int splitArray(vector<int>& nums, int k) {\\n        int low = *max_element(nums.begin(), nums.end());\\n        int high = accumulate(nums.begin(), nums.end(), 0);\\n        while(low <= high) {\\n            int mid = (low+high)/2;\\n            int partitions = countPartitions(nums, mid);\\n            if(partitions >k ) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public int countPartitions(int[] nums, int maxSum) {\\n        int partitions = 1;\\n        long subSum = 0;\\n        for (int num : nums) {\\n            if (subSum + num <= maxSum) {\\n                subSum += num;\\n            } else {\\n                partitions++;\\n                subSum = num;\\n            }\\n        }\\n        return partitions;\\n    }\\n\\n    public int splitArray(int[] nums, int k) {\\n        int low = Arrays.stream(nums).max().getAsInt();\\n        int high = Arrays.stream(nums).sum();\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            int partitions = countPartitions(nums, mid);\\n            if (partitions > k) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def countPartitions(self, nums, maxSum):\\n        partitions = 1\\n        subSum = 0\\n        for num in nums:\\n            if subSum + num <= maxSum:\\n                subSum += num\\n            else:\\n                partitions += 1\\n                subSum = num\\n        return partitions\\n\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        low = max(nums)\\n        high = sum(nums)\\n        while low <= high:\\n            mid = (low + high) // 2\\n            partitions = self.countPartitions(nums, mid)\\n            if partitions > k:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return low\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int countPartitions(vector<int> nums, int maxSum) {\\n        int partitions = 1;\\n        long long subSum = 0;\\n        for(int i = 0; i< nums.size(); i++) {\\n            if(subSum + nums[i] <= maxSum) subSum += nums[i];\\n            else {\\n                partitions++;\\n                subSum = nums[i];\\n            }\\n        }\\n        return partitions;\\n    }\\n\\n    int splitArray(vector<int>& nums, int k) {\\n        int low = *max_element(nums.begin(), nums.end());\\n        int high = accumulate(nums.begin(), nums.end(), 0);\\n        while(low <= high) {\\n            int mid = (low+high)/2;\\n            int partitions = countPartitions(nums, mid);\\n            if(partitions >k ) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public int countPartitions(int[] nums, int maxSum) {\\n        int partitions = 1;\\n        long subSum = 0;\\n        for (int num : nums) {\\n            if (subSum + num <= maxSum) {\\n                subSum += num;\\n            } else {\\n                partitions++;\\n                subSum = num;\\n            }\\n        }\\n        return partitions;\\n    }\\n\\n    public int splitArray(int[] nums, int k) {\\n        int low = Arrays.stream(nums).max().getAsInt();\\n        int high = Arrays.stream(nums).sum();\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            int partitions = countPartitions(nums, mid);\\n            if (partitions > k) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def countPartitions(self, nums, maxSum):\\n        partitions = 1\\n        subSum = 0\\n        for num in nums:\\n            if subSum + num <= maxSum:\\n                subSum += num\\n            else:\\n                partitions += 1\\n                subSum = num\\n        return partitions\\n\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        low = max(nums)\\n        high = sum(nums)\\n        while low <= high:\\n            mid = (low + high) // 2\\n            partitions = self.countPartitions(nums, mid)\\n            if partitions > k:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return low\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858020,
                "title": "c-partition-dp-problem-list-of-partition-dp-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis type is a partition dp problem where you keep on installing partitons recursively and get your answer accordingly.\\n\\n# Similar Questions\\n[Find punishment number of an Integer\\n](https://leetcode.com/problems/find-the-punishment-number-of-an-integer/description/)[Partition equal subset sum\\n](https://leetcode.com/problems/partition-equal-subset-sum/)[Partition to k equal sum subset](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = INT_MAX;\\n    vector<vector<int>> dp;\\n\\n    int solve(vector<int> &nums, int k, int st)\\n    {\\n        //base conditions\\n        if(k == 0 and st<nums.size()) return -1;\\n\\n        if(st==nums.size() and k > 0) return -1;\\n\\n        if(k==0 and st == nums.size()) return 0;\\n\\n        if(dp[st][k] != -1) return dp[st][k];\\n   \\n        int sum = 0;\\n        int ans = INT_MAX;\\n\\n        //i have to return the minimum of max subarray sums i get from each type of partition\\n\\n        for(int i =st; i<nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            \\n            //supppose i put a partition here\\n            int temp = solve(nums,k-1,i+1);\\n\\n            //for every partition made i calc the possible ans\\n            if(temp != -1) //checking if the partition was valid\\n            {\\n                temp = max(temp,sum);\\n                ans = min(ans,temp);\\n            }\\n        }\\n\\n        return dp[st][k] = ans;\\n    }\\n\\n\\n    int splitArray(vector<int>& nums, int k) {\\n\\n        dp.resize(nums.size()+1, vector<int> (k+1,-1));\\n\\n        //i will have to follow recursive partitioning with taking wiht me the sum of subarray as it should be minimized\\n\\n        return solve(nums,k,0);\\n\\n        // return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = INT_MAX;\\n    vector<vector<int>> dp;\\n\\n    int solve(vector<int> &nums, int k, int st)\\n    {\\n        //base conditions\\n        if(k == 0 and st<nums.size()) return -1;\\n\\n        if(st==nums.size() and k > 0) return -1;\\n\\n        if(k==0 and st == nums.size()) return 0;\\n\\n        if(dp[st][k] != -1) return dp[st][k];\\n   \\n        int sum = 0;\\n        int ans = INT_MAX;\\n\\n        //i have to return the minimum of max subarray sums i get from each type of partition\\n\\n        for(int i =st; i<nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            \\n            //supppose i put a partition here\\n            int temp = solve(nums,k-1,i+1);\\n\\n            //for every partition made i calc the possible ans\\n            if(temp != -1) //checking if the partition was valid\\n            {\\n                temp = max(temp,sum);\\n                ans = min(ans,temp);\\n            }\\n        }\\n\\n        return dp[st][k] = ans;\\n    }\\n\\n\\n    int splitArray(vector<int>& nums, int k) {\\n\\n        dp.resize(nums.size()+1, vector<int> (k+1,-1));\\n\\n        //i will have to follow recursive partitioning with taking wiht me the sum of subarray as it should be minimized\\n\\n        return solve(nums,k,0);\\n\\n        // return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748029,
                "title": "book-allocation-problem-code",
                "content": "problem link:-\\n[https://www.codingninjas.com/studio/problems/allocate-books_1090540]()\\n\\n---\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n        if (n < k) return -1;\\n\\n        ll low = 0, high = 0;\\n        for (auto i: nums) {\\n            low = max(low, 1ll*i);\\n            high += i;\\n        }\\n\\n        ll res = -1;\\n        while (low <= high) {\\n            ll mid = low + (high - low)/2;\\n            ll cnt = 1;\\n            ll sum = 0;\\n\\n            for (auto i: nums) {\\n                if (sum + i <= mid) sum += i;\\n                else {\\n                    sum = i;\\n                    cnt ++;\\n                }\\n            }\\n\\n            if (cnt > k) low = mid + 1;\\n            else {\\n                res = mid;\\n                high = mid - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n        if (n < k) return -1;\\n\\n        ll low = 0, high = 0;\\n        for (auto i: nums) {\\n            low = max(low, 1ll*i);\\n            high += i;\\n        }\\n\\n        ll res = -1;\\n        while (low <= high) {\\n            ll mid = low + (high - low)/2;\\n            ll cnt = 1;\\n            ll sum = 0;\\n\\n            for (auto i: nums) {\\n                if (sum + i <= mid) sum += i;\\n                else {\\n                    sum = i;\\n                    cnt ++;\\n                }\\n            }\\n\\n            if (cnt > k) low = mid + 1;\\n            else {\\n                res = mid;\\n                high = mid - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633092,
                "title": "100-fast-simple-c-code-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int k, int &mid){\\n       int count=1;\\n       int sum=0;\\n       for(int i=0;i<nums.size();i++){\\n           sum+=nums[i];\\n           if(sum>mid){\\n               count++;\\n               sum=nums[i];\\n           }\\n       }\\n        if(count>k)  return false;\\n        \\n        return true;\\n    }\\n\\n    int splitArray(vector<int>& nums, int k) {\\n        int ans=-1;\\n        int s=*max_element(nums.begin(),nums.end()),e=accumulate(nums.begin(),nums.end(),0);\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(solve(nums,k,mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int k, int &mid){\\n       int count=1;\\n       int sum=0;\\n       for(int i=0;i<nums.size();i++){\\n           sum+=nums[i];\\n           if(sum>mid){\\n               count++;\\n               sum=nums[i];\\n           }\\n       }\\n        if(count>k)  return false;\\n        \\n        return true;\\n    }\\n\\n    int splitArray(vector<int>& nums, int k) {\\n        int ans=-1;\\n        int s=*max_element(nums.begin(),nums.end()),e=accumulate(nums.begin(),nums.end(),0);\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(solve(nums,k,mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else s=mid+1;\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607052,
                "title": "python-binary-search-readable-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        def check(x):\\n            splits = 1\\n            n = 0\\n            for num in nums:\\n                n += num\\n                if n > x:\\n                    n = num\\n                    splits += 1\\n                    if splits > k:\\n                        return False\\n            return True\\n        l = max(nums)\\n        r = sum(nums)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        def check(x):\\n            splits = 1\\n            n = 0\\n            for num in nums:\\n                n += num\\n                if n > x:\\n                    n = num\\n                    splits += 1\\n                    if splits > k:\\n                        return False\\n            return True\\n        l = max(nums)\\n        r = sum(nums)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217295,
                "title": "simple-java-binary-search",
                "content": "[Capacity To Ship Packages Within D Days (Medium)\\n](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\n```\\nclass Solution {\\n    public int shipWithinDays(int[] weights, int days) {\\n         \\n        int left = 0;\\n        int right = 0;\\n        int totalWeight = 0, maxWeight = 0;\\n        \\n        for (int weight: weights) {\\n            totalWeight += weight;\\n            maxWeight = Math.max(maxWeight, weight);\\n        }\\n        \\n        left = maxWeight;\\n        right = totalWeight;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (f (weights, mid, days)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    static boolean f (int[] weights, int target, int days) {\\n\\n        int totalDays = 1;\\n        int weight = 0;\\n\\n        for (int i = 0; i < weights.length; i++) {\\n            weight += weights[i];\\n            if (weight > target) {\\n                weight = weights[i];\\n                totalDays++;\\n            }\\n        }\\n        return totalDays <= days;\\n    }\\n}\\n```\\n\\n**Another Problem with same solution\\nSame Solution, Literally Copy paste** !\\n\\n[Split Array Largest Sum (Hard)\\n](https://leetcode.com/problems/split-array-largest-sum/)\\n\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n        \\n        int left = 0;\\n        int right = 0;\\n        int totalSum = 0, maxSum = 0;\\n        \\n        for (int x : nums) {\\n            totalSum += x;\\n            maxSum = Math.max(x, maxSum);\\n        }\\n        \\n        left = maxSum;\\n        right = totalSum;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (f (nums, mid, k)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    static boolean f (int[] nums, int target, int k) {\\n\\n        int maxChunks = 1;\\n        int sum = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (sum > target) {\\n                sum = nums[i];\\n                maxChunks++;\\n            }\\n        }\\n        return maxChunks <= k;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int shipWithinDays(int[] weights, int days) {\\n         \\n        int left = 0;\\n        int right = 0;\\n        int totalWeight = 0, maxWeight = 0;\\n        \\n        for (int weight: weights) {\\n            totalWeight += weight;\\n            maxWeight = Math.max(maxWeight, weight);\\n        }\\n        \\n        left = maxWeight;\\n        right = totalWeight;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (f (weights, mid, days)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    static boolean f (int[] weights, int target, int days) {\\n\\n        int totalDays = 1;\\n        int weight = 0;\\n\\n        for (int i = 0; i < weights.length; i++) {\\n            weight += weights[i];\\n            if (weight > target) {\\n                weight = weights[i];\\n                totalDays++;\\n            }\\n        }\\n        return totalDays <= days;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int k) {\\n        \\n        int left = 0;\\n        int right = 0;\\n        int totalSum = 0, maxSum = 0;\\n        \\n        for (int x : nums) {\\n            totalSum += x;\\n            maxSum = Math.max(x, maxSum);\\n        }\\n        \\n        left = maxSum;\\n        right = totalSum;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (f (nums, mid, k)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    static boolean f (int[] nums, int target, int k) {\\n\\n        int maxChunks = 1;\\n        int sum = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (sum > target) {\\n                sum = nums[i];\\n                maxChunks++;\\n            }\\n        }\\n        return maxChunks <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079621,
                "title": "beats-100-binary-search-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<int>&a, int n, int m,int mid){\\n            int x=0,c=1;\\n            for(int i=0;i<n;i++){\\n                if(a[i]>mid) return false;\\n                if((a[i]+x)>mid){\\n                    c++;\\n                    x=a[i];\\n                }\\n                else{\\n                    x+=a[i];\\n                }\\n            }\\n            if(c>m) return false;\\n                return true;\\n        }\\n    int splitArray(vector<int>& a, int m) {\\n        int n=a.size();\\n        int low=0;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=a[i];\\n        }\\n        int high=sum;\\n        int res=-1;\\n        if(n<m) return res;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(f(a,n,m,mid)==true){\\n                res=mid;\\n                high =mid-1;\\n                \\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<int>&a, int n, int m,int mid){\\n            int x=0,c=1;\\n            for(int i=0;i<n;i++){\\n                if(a[i]>mid) return false;\\n                if((a[i]+x)>mid){\\n                    c++;\\n                    x=a[i];\\n                }\\n                else{\\n                    x+=a[i];\\n                }\\n            }\\n            if(c>m) return false;\\n                return true;\\n        }\\n    int splitArray(vector<int>& a, int m) {\\n        int n=a.size();\\n        int low=0;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=a[i];\\n        }\\n        int high=sum;\\n        int res=-1;\\n        if(n<m) return res;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(f(a,n,m,mid)==true){\\n                res=mid;\\n                high =mid-1;\\n                \\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958110,
                "title": "concise-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &nums, int k) {\\n        int cnt = 1, s = 0, n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] > x) return false;\\n            s += nums[i];\\n            if(s > x) { \\n                cnt++;\\n                s = nums[i];\\n                if(cnt > k) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        int s = 0, e = 1e9, ans = INT_MAX;\\n        // for(int i : nums) e += i;\\n        \\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, nums, k)) e = m - 1, ans = min(ans, m);\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &nums, int k) {\\n        int cnt = 1, s = 0, n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] > x) return false;\\n            s += nums[i];\\n            if(s > x) { \\n                cnt++;\\n                s = nums[i];\\n                if(cnt > k) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        int s = 0, e = 1e9, ans = INT_MAX;\\n        // for(int i : nums) e += i;\\n        \\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, nums, k)) e = m - 1, ans = min(ans, m);\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867051,
                "title": "3ms-easy-understand-c-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int l=0,r=0,n=nums.size();\\n        for(int i=0;i<n;++i) l=max(l,nums[i]), r+=nums[i];\\n        \\n        int mid=0,ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0,tempsum=0;\\n            for(int i=0;i<n;++i){\\n                if(tempsum+nums[i]<=mid) tempsum+=nums[i];\\n                else count++,tempsum=nums[i];\\n            }\\n            count++; \\n            \\n            if(count<=m) r=mid-1, ans=mid;\\n            else l=mid+1;\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int l=0,r=0,n=nums.size();\\n        for(int i=0;i<n;++i) l=max(l,nums[i]), r+=nums[i];\\n        \\n        int mid=0,ans=0;\\n        while(l<=r){\\n            mid=(l+r)/2;\\n            int count=0,tempsum=0;\\n            for(int i=0;i<n;++i){\\n                if(tempsum+nums[i]<=mid) tempsum+=nums[i];\\n                else count++,tempsum=nums[i];\\n            }\\n            count++; \\n            \\n            if(count<=m) r=mid-1, ans=mid;\\n            else l=mid+1;\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606081,
                "title": "c-easy-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,int m,int mid)\\n    {\\n        int spiliting=1;\\n        int sum=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>mid)\\n            {\\n                return false;\\n            }\\n            if(nums[i]+sum>mid)\\n            {\\n                spiliting++;\\n                sum=nums[i];\\n            }\\n            else\\n            {\\n                sum=sum+nums[i];\\n            }\\n        }\\n        return spiliting<=m;\\n    }\\n    int splitArray(vector<int>& nums, int m) \\n    {\\n        int low=*min_element(nums.begin(),nums.end());\\n        long long int high=accumulate(nums.begin(),nums.end(),0);\\n        int ans=0;\\n        if(nums.size()==1)\\n        {\\n            return high;\\n        }\\n        while(low<=high)\\n        {\\n            long long int mid=low+(high-low)/2;\\n            if(ispossible(nums,m,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,int m,int mid)\\n    {\\n        int spiliting=1;\\n        int sum=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>mid)\\n            {\\n                return false;\\n            }\\n            if(nums[i]+sum>mid)\\n            {\\n                spiliting++;\\n                sum=nums[i];\\n            }\\n            else\\n            {\\n                sum=sum+nums[i];\\n            }\\n        }\\n        return spiliting<=m;\\n    }\\n    int splitArray(vector<int>& nums, int m) \\n    {\\n        int low=*min_element(nums.begin(),nums.end());\\n        long long int high=accumulate(nums.begin(),nums.end(),0);\\n        int ans=0;\\n        if(nums.size()==1)\\n        {\\n            return high;\\n        }\\n        while(low<=high)\\n        {\\n            long long int mid=low+(high-low)/2;\\n            if(ispossible(nums,m,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467770,
                "title": "c-o-n-logsum-binary-search-on-answer",
                "content": "\\n```\\n    int splitArray(vector<int>& nums, int m) \\n    {\\n        int low = nums[0];\\n        int high = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            low = max(low,nums[i]);\\n            high += nums[i]; \\n        }\\n        // Binary Search\\n        int ans ;\\n        while(low<=high)\\n        {\\n           int mid = (low+high)/2;\\n           int sum = 0;\\n           int count = 1;\\n           for(int i=0;i<nums.size();i++)\\n           {\\n               if(sum+nums[i]<=mid)\\n                sum += nums[i];\\n               else\\n               {\\n                   sum = nums[i];\\n                   count++;\\n               }\\n           }\\n           if(count<=m)\\n           {\\n              ans = mid;\\n              high = mid-1;\\n           }\\n           else \\n              low = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n    int splitArray(vector<int>& nums, int m) \\n    {\\n        int low = nums[0];\\n        int high = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            low = max(low,nums[i]);\\n            high += nums[i]; \\n        }\\n        // Binary Search\\n        int ans ;\\n        while(low<=high)\\n        {\\n           int mid = (low+high)/2;\\n           int sum = 0;\\n           int count = 1;\\n           for(int i=0;i<nums.size();i++)\\n           {\\n               if(sum+nums[i]<=mid)\\n                sum += nums[i];\\n               else\\n               {\\n                   sum = nums[i];\\n                   count++;\\n               }\\n           }\\n           if(count<=m)\\n           {\\n              ans = mid;\\n              high = mid-1;\\n           }\\n           else \\n              low = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161842,
                "title": "c-binary-search-on-answer",
                "content": "```\\nUNOptimal Recursive DP with Memoization Based Solution\\n    long long int findPage(vector<int>& nums, vector<long long>&prefix, vector<vector<long long>>& dp, int n, int l, int N, int M){\\n        if(dp[l][M-1]!=-1) return dp[l][M-1];\\n        if(M==1){\\n            return prefix[n]-prefix[l];\\n        }\\n        long long int ret=INT_MAX;\\n        for(int i=l; i<=n-M; i++){\\n             ret = min(ret, max(prefix[i+1]-prefix[l], findPage(nums, prefix, dp, n, i+1, N-i-1, M-1)));\\n        }\\n        dp[l][M-1] = ret;\\n        return ret;\\n    }\\n    int splitArray(vector<int>& nums, int M)\\n    {\\n        int N = nums.size();\\n        vector<long long int> prefix(N+1);\\n        prefix[0]=0;\\n        for(int i=1; i<=N; i++) prefix[i] = nums[i-1]+prefix[i-1];\\n        if(M==1){\\n            return prefix[N];\\n        }\\n        if(M>N) return -1;\\n        if(M==N) {\\n            int maxi=INT_MIN;\\n            for(auto i:nums)\\n            maxi = max(maxi, i);\\n            return maxi;\\n        }\\n        vector<vector<long long>> dp(N, vector<long long>(M,-1));\\n        long long int ret=INT_MAX;\\n        \\n        for(int i=0; i<=N-M; i++){\\n            ret = min(ret, max(prefix[i+1], findPage(nums, prefix, dp, N, i+1, N-i-1, M-1)));\\n        }\\n        return ret;\\n    }\\n```\\nThanks \\u270C",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nUNOptimal Recursive DP with Memoization Based Solution\\n    long long int findPage(vector<int>& nums, vector<long long>&prefix, vector<vector<long long>>& dp, int n, int l, int N, int M){\\n        if(dp[l][M-1]!=-1) return dp[l][M-1];\\n        if(M==1){\\n            return prefix[n]-prefix[l];\\n        }\\n        long long int ret=INT_MAX;\\n        for(int i=l; i<=n-M; i++){\\n             ret = min(ret, max(prefix[i+1]-prefix[l], findPage(nums, prefix, dp, n, i+1, N-i-1, M-1)));\\n        }\\n        dp[l][M-1] = ret;\\n        return ret;\\n    }\\n    int splitArray(vector<int>& nums, int M)\\n    {\\n        int N = nums.size();\\n        vector<long long int> prefix(N+1);\\n        prefix[0]=0;\\n        for(int i=1; i<=N; i++) prefix[i] = nums[i-1]+prefix[i-1];\\n        if(M==1){\\n            return prefix[N];\\n        }\\n        if(M>N) return -1;\\n        if(M==N) {\\n            int maxi=INT_MIN;\\n            for(auto i:nums)\\n            maxi = max(maxi, i);\\n            return maxi;\\n        }\\n        vector<vector<long long>> dp(N, vector<long long>(M,-1));\\n        long long int ret=INT_MAX;\\n        \\n        for(int i=0; i<=N-M; i++){\\n            ret = min(ret, max(prefix[i+1], findPage(nums, prefix, dp, N, i+1, N-i-1, M-1)));\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161838,
                "title": "c-binary-search-in-solution-space",
                "content": "```\\n//Optimal Binary Search in Solution Space Solution\\n    bool isvalid(vector<int>& nums, int& M, int& m){\\n        long long Nsubarrays=1, sum=0;\\n        for(int i:nums){\\n            sum += i;\\n            if(sum>m){\\n                Nsubarrays++;\\n                sum = i;\\n            }\\n            if(Nsubarrays>M) return false;\\n        }\\n        return true;\\n    }\\n    int splitArray(vector<int>& nums, int M) {\\n        int n=nums.size();\\n        long long maxi=INT_MIN, sum=0;\\n        for(long long int i:nums) {\\n            maxi = max(maxi, i);\\n            sum += i;\\n        }\\n        if(M==1) return sum;\\n        if(M==n) return maxi;\\n        long long l=maxi, r=sum, ret=l;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(isvalid(nums, M, m)){\\n                ret = m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ret;\\n    }\\n```\\n\\nThanks",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n//Optimal Binary Search in Solution Space Solution\\n    bool isvalid(vector<int>& nums, int& M, int& m){\\n        long long Nsubarrays=1, sum=0;\\n        for(int i:nums){\\n            sum += i;\\n            if(sum>m){\\n                Nsubarrays++;\\n                sum = i;\\n            }\\n            if(Nsubarrays>M) return false;\\n        }\\n        return true;\\n    }\\n    int splitArray(vector<int>& nums, int M) {\\n        int n=nums.size();\\n        long long maxi=INT_MIN, sum=0;\\n        for(long long int i:nums) {\\n            maxi = max(maxi, i);\\n            sum += i;\\n        }\\n        if(M==1) return sum;\\n        if(M==n) return maxi;\\n        long long l=maxi, r=sum, ret=l;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(isvalid(nums, M, m)){\\n                ret = m;\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901327,
                "title": "c-binary-search-dlc-march-31",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleSum(int mid, vector<int> &nums, int limit){\\n        int total = 0;\\n        int subArrays = 1;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n             if(nums[i] > mid)\\n            return false;\\n        \\n            else if(nums[i] + total > mid){\\n                subArrays++;\\n                total = nums[i];\\n            }\\n            else\\n                total += nums[i];\\n        }\\n        \\n        return subArrays <= limit;\\n    }\\n    \\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int ans = 0;\\n        \\n        int low = 0;\\n        int high = 1e9;\\n        \\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            if(possibleSum(mid, nums, m)){\\n                high = mid-1;\\n                ans = mid;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleSum(int mid, vector<int> &nums, int limit){\\n        int total = 0;\\n        int subArrays = 1;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n             if(nums[i] > mid)\\n            return false;\\n        \\n            else if(nums[i] + total > mid){\\n                subArrays++;\\n                total = nums[i];\\n            }\\n            else\\n                total += nums[i];\\n        }\\n        \\n        return subArrays <= limit;\\n    }\\n    \\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int ans = 0;\\n        \\n        int low = 0;\\n        int high = 1e9;\\n        \\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            if(possibleSum(mid, nums, m)){\\n                high = mid-1;\\n                ans = mid;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901033,
                "title": "c-1ms-fast-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int SplitArrayLargestSums(vector<int> &nums, int parts)\\n{\\n    int low = INT_MIN; // 10\\n    int high = 0;      // 32\\n    for (auto i : nums)\\n    {\\n        high += i;         //\\n        low = max(low, i); //\\n    }\\n    while (low < high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        cout << \"mid= \" << mid << endl;\\n        int tempParts = 0;\\n        int temp = 0;\\n        for (auto i : nums)\\n        {\\n            if (temp + i > mid)\\n            {\\n                temp = i;\\n                tempParts++;\\n            }\\n            else\\n            {\\n                temp += i;\\n            }\\n        }\\n        if(temp>0){\\n            tempParts++;\\n        }\\n        cout << tempParts << endl;\\n        if (tempParts > parts)\\n        {\\n            low = mid + 1;\\n        }\\n        else\\n        {\\n            high = mid;\\n        }\\n    }\\n    return high;\\n}\\n    int splitArray(vector<int>& nums, int m) {\\n        return SplitArrayLargestSums(nums, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int SplitArrayLargestSums(vector<int> &nums, int parts)\\n{\\n    int low = INT_MIN; // 10\\n    int high = 0;      // 32\\n    for (auto i : nums)\\n    {\\n        high += i;         //\\n        low = max(low, i); //\\n    }\\n    while (low < high)\\n    {\\n        int mid = low + (high - low) / 2;\\n        cout << \"mid= \" << mid << endl;\\n        int tempParts = 0;\\n        int temp = 0;\\n        for (auto i : nums)\\n        {\\n            if (temp + i > mid)\\n            {\\n                temp = i;\\n                tempParts++;\\n            }\\n            else\\n            {\\n                temp += i;\\n            }\\n        }\\n        if(temp>0){\\n            tempParts++;\\n        }\\n        cout << tempParts << endl;\\n        if (tempParts > parts)\\n        {\\n            low = mid + 1;\\n        }\\n        else\\n        {\\n            high = mid;\\n        }\\n    }\\n    return high;\\n}\\n    int splitArray(vector<int>& nums, int m) {\\n        return SplitArrayLargestSums(nums, m);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1900886,
                "title": "100-java-simple",
                "content": "```\\nclass Solution {\\n    int[] nums;\\n    public int splitArray(int[] nums, int m) {\\n        this.nums = nums;\\n        int low = 0, high = 0, min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            low = Math.max(low, nums[i]);\\n            high += nums[i];\\n        }\\n        while(low <= high) {\\n            int mid = (low + high) / 2;\\n            if(required_no_of_apple(mid, m)){\\n               min = Math.min(min, mid);\\n               high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return min;\\n    }\\n    \\n    private boolean required_no_of_apple(int mid, int m){\\n        int apple = 0, i=0;\\n        while(i < nums.length){\\n            int val = 0;\\n            while(i < nums.length && nums[i] + val <= mid) val += nums[i++];\\n            apple++;\\n        }\\n        return apple <= m;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    public int splitArray(int[] nums, int m) {\\n        this.nums = nums;\\n        int low = 0, high = 0, min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            low = Math.max(low, nums[i]);\\n            high += nums[i];\\n        }\\n        while(low <= high) {\\n            int mid = (low + high) / 2;\\n            if(required_no_of_apple(mid, m)){\\n               min = Math.min(min, mid);\\n               high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return min;\\n    }\\n    \\n    private boolean required_no_of_apple(int mid, int m){\\n        int apple = 0, i=0;\\n        while(i < nums.length){\\n            int val = 0;\\n            while(i < nums.length && nums[i] + val <= mid) val += nums[i++];\\n            apple++;\\n        }\\n        return apple <= m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900433,
                "title": "c-three-approaches-easy-dp-binary-greedy",
                "content": "**Recursion + Memoization**\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][51];\\n    int fun(vector<int>& nums, int ind, int m) {\\n        if(ind == 0 and m == 0)\\n            return 0;\\n        if(ind == 0 or m == 0)\\n            return INT_MAX;\\n        if(dp[ind][m] != -1)\\n            return dp[ind][m];\\n        int ans = INT_MAX;\\n        int curr = 0;\\n        for(int k = ind; k > 0; k--) {\\n            curr += nums[k - 1];\\n            ans = min(ans, max(curr, fun(nums, k - 1, m - 1)));\\n        }\\n        return dp[ind][m] = ans;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof dp);\\n        return fun(nums, nums.size(), m);\\n    }\\n};\\n```\\n\\n**Tabulation DP**\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][51];\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, INT_MAX));\\n        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= m; j++) {\\n                int curr = 0;\\n                for(int k = i; k > 0; k--) {\\n                    curr += nums[k - 1];\\n                    dp[i][j] = min(dp[i][j], max(curr, dp[k - 1][j - 1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n**Binary-Search + Greedy**\\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int low = 0;\\n        int high = 0;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            high += nums[i];\\n            low = max(low, nums[i]);\\n        }\\n        \\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(canSplit(nums, mid, m)) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    bool canSplit(vector<int>& nums, int maxSum, int m) {\\n        int totalPart = 0;\\n        int currSum = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(currSum + nums[i] <= maxSum) {\\n                currSum += nums[i];\\n            }\\n            else {\\n                currSum = nums[i];\\n                totalPart++;\\n            }\\n        }\\n        return (totalPart + 1) <= m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][51];\\n    int fun(vector<int>& nums, int ind, int m) {\\n        if(ind == 0 and m == 0)\\n            return 0;\\n        if(ind == 0 or m == 0)\\n            return INT_MAX;\\n        if(dp[ind][m] != -1)\\n            return dp[ind][m];\\n        int ans = INT_MAX;\\n        int curr = 0;\\n        for(int k = ind; k > 0; k--) {\\n            curr += nums[k - 1];\\n            ans = min(ans, max(curr, fun(nums, k - 1, m - 1)));\\n        }\\n        return dp[ind][m] = ans;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof dp);\\n        return fun(nums, nums.size(), m);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[1001][51];\\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, INT_MAX));\\n        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= m; j++) {\\n                int curr = 0;\\n                for(int k = i; k > 0; k--) {\\n                    curr += nums[k - 1];\\n                    dp[i][j] = min(dp[i][j], max(curr, dp[k - 1][j - 1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int low = 0;\\n        int high = 0;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            high += nums[i];\\n            low = max(low, nums[i]);\\n        }\\n        \\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(canSplit(nums, mid, m)) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    bool canSplit(vector<int>& nums, int maxSum, int m) {\\n        int totalPart = 0;\\n        int currSum = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(currSum + nums[i] <= maxSum) {\\n                currSum += nums[i];\\n            }\\n            else {\\n                currSum = nums[i];\\n                totalPart++;\\n            }\\n        }\\n        return (totalPart + 1) <= m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900175,
                "title": "memoization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int pre[1005];\\n    int dp[1005][52];\\n    int ans;\\n    int n;\\n    \\n    int solve(int ind, vector<int>& nums, int m){\\n        if(ind==n && m==0)\\n            return 0;\\n        if(ind==n || m==0)\\n            return INT_MAX;\\n        if(dp[ind][m]!=-1)\\n            return dp[ind][m];\\n        int ans=INT_MAX;\\n        for(int i=ind;i<n;i++){\\n            int curr=pre[i]-((ind-1>=0)?pre[ind-1]:0);\\n            int nxt=solve(i+1, nums,m-1);\\n            ans=min(ans, max(curr, nxt));\\n        }\\n        return dp[ind][m]=ans;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        n=nums.size();\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ind=0;\\n        return solve(ind, nums, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pre[1005];\\n    int dp[1005][52];\\n    int ans;\\n    int n;\\n    \\n    int solve(int ind, vector<int>& nums, int m){\\n        if(ind==n && m==0)\\n            return 0;\\n        if(ind==n || m==0)\\n            return INT_MAX;\\n        if(dp[ind][m]!=-1)\\n            return dp[ind][m];\\n        int ans=INT_MAX;\\n        for(int i=ind;i<n;i++){\\n            int curr=pre[i]-((ind-1>=0)?pre[ind-1]:0);\\n            int nxt=solve(i+1, nums,m-1);\\n            ans=min(ans, max(curr, nxt));\\n        }\\n        return dp[ind][m]=ans;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        n=nums.size();\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ind=0;\\n        return solve(ind, nums, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900135,
                "title": "split-array-largest-sum-c-code-explanation-0-ms-100-faster-binary-search-on-answer",
                "content": "Hello Hustlers!! ,\\n**Question Explanation : In this question we have to find minimum possible largest sum of the subarrays if there are m possible subarrays.**\\nQuestion Parameters : - \\n*  **nums array** : We are given an array whose size can be **at most 1000** where each element can range **from -10^6 to 10^6**.\\n* **m** : **Total number of possible subarray** we can make.\\n\\nApproach : On reading problem statement carefully we can see **that problem is of optimization type**, so we can think of something like **Dynamic Programming** approach or some kind of **Binary Search**.\\n\\n**What kind of Binary Search can be applied here ?**\\nAns : Since problem is of **optimization type under given constraint** which means we have to **find minimum possible largest sum but we can only make m subarray out of the whole array**. So, we can think of a **binary search on a range** where my **range will be the possible sum** ( that we have to find or we can say our answer ), and we will also take account on **how many subarrays** are created. (Here, my range will be in **sorted order**, so we can easily apply binary search on it ).\\n\\nThis technique of Binary Search is also termed as **Binary Search on Answer**.\\n\\nCode Explanation : - \\nSince we are applying **Binary Search**, so first we have to **find the required range**. In answer we have to output the the **minimum possible largest sum**, so our range will be **[ max(nums),  sum(nums) ].**\\nWe will apply binary search on this range , and we will **manipulate our low and high pointers** according to the number of subarrays formed if we are given the required sum. (Here, **inside of binary search loop, my required sum will be the mid of the given range** ).\\n\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n // Feasiblility Check of BS\\n    bool isValid(vector<int>&nums, ll mid, int m) {\\n        int n = nums.size();\\n        int curr_sum = 0, subarray = 0;\\n        for(int i=0; i<n; i++) {\\n            curr_sum += nums[i];                        // we will keep calculating current sum of subarray \\n            if(curr_sum > mid) {                       // if curr_sum is > mid ( required sum ) we will increment \\n\\t\\t\\t                                           // our subarray count.\\n                subarray++;\\n                curr_sum = nums[i];\\n            }\\n            \\n            if(subarray+1 > m) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        ll sum = 0;\\n        \\n        for(int n:nums)\\n            sum += n;\\n        \\n        ll low = *max_element(begin(nums), end(nums));        // lowest possible sum\\n        ll high = sum;                                        // highest possible sum\\n        \\n        while(low<high) {\\n            ll mid = low + (high - low)/2;                    // applying BS on answer\\n                                                              // (largest sum) \\n            \\n            if(isValid(nums, mid, m)) high = mid;             // if there are m possible\\n                                                              // subarrays with given sum mid we will go on left \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // side as we have to find minimum possible largest sum\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n            else low = mid + 1;                  // else, we will go on right side \\n        } \\n        \\n        return high;                  // at last we will return the high pointer which will now store the \\n\\t\\t                             // minimum possible largest sum.\\n    }\\n};\\n```\\n\\n**Time Complexity Analysis** : \\n*  First, we are calculating the total sum of array  -> **O(n)**\\n*  Second,  we are are applying binary search on range ( let size of range be m ) - > **O(Log m**)\\n*  Third, again we are traversing our array to calculate number of subarray under given sum ( mid ) \\n      - > **O( Log m . n )**\\n \\n So therefore, total time complexity : **O ( n log m )** where n is size of my nums.\\n\\nI hope this post will help you a lot also if you have any doubt you can ask in the comments.\\nIf so, don\\'t forget to upvote it!! \\nThanks.\\n\\n\\n\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n // Feasiblility Check of BS\\n    bool isValid(vector<int>&nums, ll mid, int m) {\\n        int n = nums.size();\\n        int curr_sum = 0, subarray = 0;\\n        for(int i=0; i<n; i++) {\\n            curr_sum += nums[i];                        // we will keep calculating current sum of subarray \\n            if(curr_sum > mid) {                       // if curr_sum is > mid ( required sum ) we will increment \\n\\t\\t\\t                                           // our subarray count.\\n                subarray++;\\n                curr_sum = nums[i];\\n            }\\n            \\n            if(subarray+1 > m) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int n = nums.size();\\n        ll sum = 0;\\n        \\n        for(int n:nums)\\n            sum += n;\\n        \\n        ll low = *max_element(begin(nums), end(nums));        // lowest possible sum\\n        ll high = sum;                                        // highest possible sum\\n        \\n        while(low<high) {\\n            ll mid = low + (high - low)/2;                    // applying BS on answer\\n                                                              // (largest sum) \\n            \\n            if(isValid(nums, mid, m)) high = mid;             // if there are m possible\\n                                                              // subarrays with given sum mid we will go on left \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // side as we have to find minimum possible largest sum\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n            else low = mid + 1;                  // else, we will go on right side \\n        } \\n        \\n        return high;                  // at last we will return the high pointer which will now store the \\n\\t\\t                             // minimum possible largest sum.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900109,
                "title": "c-two-solutions-backtracking-and-binary-search",
                "content": "BACKTRACKING Solution - Time Limit Exceeded\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int n, int m, int index, int sum, int maxSum, int& ans) {\\n        if(m == 1) {\\n            maxSum = max(maxSum, sum);\\n            sum = 0;\\n            for(int i = index; i < n; i++)\\n                sum += nums[i];\\n            maxSum = max(maxSum, sum);\\n            ans = min(ans, maxSum);\\n            \\n        } else {\\n            sum = 0;\\n            for(int i = index; i < n; i++) {\\n                sum += nums[i];\\n                maxSum = max(maxSum, sum);\\n                \\n                helper(nums, n, m - 1, i + 1, sum, maxSum, ans);\\n            }\\n        }\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n        \\n        helper(nums, n, m, 0, 0, 0, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\nBINARY SEARCH Solution - Optimized Solution\\n```\\nclass Solution {\\npublic:    \\n    bool check(vector<int>& nums, int mid, int m) {\\n        int count = 0, sum = 0;\\n        for(int num : nums) {\\n            if(num > mid)\\n                return false;\\n            sum += num;\\n            if(sum > mid) {\\n                count++;\\n                sum = num;\\n            }\\n        }\\n        count++;\\n        \\n        return count <= m;\\n    }\\n    \\n    void helper(vector<int>& nums, int m, int& ans) {\\n        int max = *max_element(nums.begin(), nums.end());\\n        int start = max;\\n        int end = 0;\\n        for(int num : nums)\\n            end += num;\\n\\n        while(start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if(check(nums, mid, m)) {\\n                ans = mid;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n    }\\n\\n    int splitArray(vector<int>& nums, int m) {\\n        int ans = 0;\\n        int n = nums.size();\\n\\n        helper(nums, m, ans);\\n\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<int>& nums, int n, int m, int index, int sum, int maxSum, int& ans) {\\n        if(m == 1) {\\n            maxSum = max(maxSum, sum);\\n            sum = 0;\\n            for(int i = index; i < n; i++)\\n                sum += nums[i];\\n            maxSum = max(maxSum, sum);\\n            ans = min(ans, maxSum);\\n            \\n        } else {\\n            sum = 0;\\n            for(int i = index; i < n; i++) {\\n                sum += nums[i];\\n                maxSum = max(maxSum, sum);\\n                \\n                helper(nums, n, m - 1, i + 1, sum, maxSum, ans);\\n            }\\n        }\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n        \\n        helper(nums, n, m, 0, 0, 0, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    bool check(vector<int>& nums, int mid, int m) {\\n        int count = 0, sum = 0;\\n        for(int num : nums) {\\n            if(num > mid)\\n                return false;\\n            sum += num;\\n            if(sum > mid) {\\n                count++;\\n                sum = num;\\n            }\\n        }\\n        count++;\\n        \\n        return count <= m;\\n    }\\n    \\n    void helper(vector<int>& nums, int m, int& ans) {\\n        int max = *max_element(nums.begin(), nums.end());\\n        int start = max;\\n        int end = 0;\\n        for(int num : nums)\\n            end += num;\\n\\n        while(start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if(check(nums, mid, m)) {\\n                ans = mid;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n    }\\n\\n    int splitArray(vector<int>& nums, int m) {\\n        int ans = 0;\\n        int n = nums.size();\\n\\n        helper(nums, m, ans);\\n\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899980,
                "title": "c-concept-of-mcm-dp-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\tint dp[1001][51];     // To memoize it  \\n    \\n    int solve(vector<int>&nums,int idx, int m){\\n        int n = nums.size(); \\n\\t\\t\\t // Base case : when the size is equal to 1 i.e. we have to take all the elements. \\n\\t\\t\\tif (m == 1){      \\n            int sum = 0;\\n            for(int i = idx; i < n; i++)\\n                sum += nums[i]; \\n            return sum; \\n        }\\n        if (dp[idx][m] != -1)\\n            return dp[idx][m]; \\n        \\n        int ans =   INT_MAX; \\n        int sum = 0; \\n        for(int i = idx; i <= n - m; i++){   // Here n-m because we can\\'t take the elements more then m so that it can be further form non-empty subarray\\n            sum += nums[i]; \\n            int next_sum = solve(nums, i+1, m-1);    // Calling for the next maximum sum that can be obtained by spllitting next sequence\\n            int temp = max(sum, next_sum);   // Here maximum because we have to consider the largest sum among all the splitted sub array\\n            ans = min(ans, temp);  // Answer would be the smallest in all the possible splittings . \\n        }\\n\\t\\t\\treturn dp[idx][m] = ans; \\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof(dp)); \\n        return solve(nums, 0, m); \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\tint dp[1001][51];     // To memoize it  \\n    \\n    int solve(vector<int>&nums,int idx, int m){\\n        int n = nums.size(); \\n\\t\\t\\t // Base case : when the size is equal to 1 i.e. we have to take all the elements. \\n\\t\\t\\tif (m == 1){      \\n            int sum = 0;\\n            for(int i = idx; i < n; i++)\\n                sum += nums[i]; \\n            return sum; \\n        }\\n        if (dp[idx][m] != -1)\\n            return dp[idx][m]; \\n        \\n        int ans =   INT_MAX; \\n        int sum = 0; \\n        for(int i = idx; i <= n - m; i++){   // Here n-m because we can\\'t take the elements more then m so that it can be further form non-empty subarray\\n            sum += nums[i]; \\n            int next_sum = solve(nums, i+1, m-1);    // Calling for the next maximum sum that can be obtained by spllitting next sequence\\n            int temp = max(sum, next_sum);   // Here maximum because we have to consider the largest sum among all the splitted sub array\\n            ans = min(ans, temp);  // Answer would be the smallest in all the possible splittings . \\n        }\\n\\t\\t\\treturn dp[idx][m] = ans; \\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp, -1, sizeof(dp)); \\n        return solve(nums, 0, m); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899728,
                "title": "simple-easy-to-understand-binary-search-c",
                "content": "**Idea?**\\n* We need to minimize the largest sum such that it contains at most m continuous subarrays.\\n* Let\\'s **Binary Search** the answer.\\n* Consider **mid** be the largest sum possible.\\n* Then, all the possible subarrays must have a sum less than or equal to **mid**.\\n* So, check if for a given mid, if we have **at most m subarrays** possible such that each subarray has sum at most mid, then check for a smaller answer, otherwise, check for larger answer.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// Time Complexity:- O(log(sum-maxEle)*n)\\n\\t// Space Complexity:- O(1)\\n    bool ok(int maxsum,vector<int>& nums,int n,int m){\\n        m--;\\n        int sum = 0;\\n        for(auto& x:nums){\\n            if(sum+x<=maxsum){\\n                sum += x;\\n            }\\n            else{\\n                m--;\\n                sum = x;\\n            }\\n        }\\n        return m>=0;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        int l = INT_MIN,r = 0,n = nums.size();\\n        for(auto& x:nums){\\n            r += x;\\n            l = max(l,x);\\n        }\\n        int ans = r;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(ok(mid,nums,n,m)){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Time Complexity:- O(log(sum-maxEle)*n)\\n\\t// Space Complexity:- O(1)\\n    bool ok(int maxsum,vector<int>& nums,int n,int m){\\n        m--;\\n        int sum = 0;\\n        for(auto& x:nums){\\n            if(sum+x<=maxsum){\\n                sum += x;\\n            }\\n            else{\\n                m--;\\n                sum = x;\\n            }\\n        }\\n        return m>=0;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        int l = INT_MIN,r = 0,n = nums.size();\\n        for(auto& x:nums){\\n            r += x;\\n            l = max(l,x);\\n        }\\n        int ans = r;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(ok(mid,nums,n,m)){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899533,
                "title": "clean-and-short-binary-search-with-succinct-explanation-python",
                "content": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        \\n        # step-1 define a boolean fn\\n        # this function is such that if we could guarantee that\\n        # if we split the array into m consecutive subarray, each sum\\n        # of the subarray is <= k.\\n        def fulfill(k):\\n            cnt = 0\\n            s = 0\\n            for y in nums:\\n                if s + y > k:\\n                    cnt += 1\\n                    s = y\\n                else:\\n                    s += y\\n            if s <= k:\\n                cnt += 1\\n            return cnt <= m\\n        \\n\\n        # step-2 binary search\\n        # the question now is transformed to be:\\n        # find min k such that fulfill(k) is True.\\n        # notice that the search range is not a trivial thing\\n        # lower = min(nums), can not use smaller values, e.g., 1 \\n        # b/c the trivial fact that no number is smaller than min(nums) in nums\\n        # the upper level shall be greater or equal to sum(nums)\\n        # if one replace upper = sum(nums) by upper = sum(nums) + nonnegative_integer,\\n        # it will work. But the time complexity increases.\\n        lower, upper = max(nums), sum(nums)\\n        while lower < upper:\\n            mid = lower + (upper - lower) // 2\\n            if fulfill(mid):\\n                upper = mid\\n            else:\\n                lower = mid + 1\\n        return lower\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        \\n        # step-1 define a boolean fn\\n        # this function is such that if we could guarantee that\\n        # if we split the array into m consecutive subarray, each sum\\n        # of the subarray is <= k.\\n        def fulfill(k):\\n            cnt = 0\\n            s = 0\\n            for y in nums:\\n                if s + y > k:\\n                    cnt += 1\\n                    s = y\\n                else:\\n                    s += y\\n            if s <= k:\\n                cnt += 1\\n            return cnt <= m\\n        \\n\\n        # step-2 binary search\\n        # the question now is transformed to be:\\n        # find min k such that fulfill(k) is True.\\n        # notice that the search range is not a trivial thing\\n        # lower = min(nums), can not use smaller values, e.g., 1 \\n        # b/c the trivial fact that no number is smaller than min(nums) in nums\\n        # the upper level shall be greater or equal to sum(nums)\\n        # if one replace upper = sum(nums) by upper = sum(nums) + nonnegative_integer,\\n        # it will work. But the time complexity increases.\\n        lower, upper = max(nums), sum(nums)\\n        while lower < upper:\\n            mid = lower + (upper - lower) // 2\\n            if fulfill(mid):\\n                upper = mid\\n            else:\\n                lower = mid + 1\\n        return lower\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899305,
                "title": "java-binary-solution",
                "content": "\\n\\n        int sum=0,max=0;\\n        for(int i:nums)\\n        {\\n            sum+=i;\\n            max=Math.max(max,i);\\n        }\\n        if(nums.length==m)\\n            return max;\\n        if(m==1)\\n            return sum;\\n        int lo=max,hi=sum,ans=0;\\n        while(lo<=hi)\\n        {\\n            int mid=lo+(hi-lo)/2;\\n            if(fun(nums,mid,m))\\n            {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else\\n                lo=mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n    boolean fun(int a[],int mid,int m)\\n    {\\n        int st=1,sum=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            sum+=a[i];\\n            if(sum>mid)\\n            {\\n                sum=a[i];\\n                st++;\\n            }\\n        }\\n        if(st<=m)\\n            return true;\\n        return false;\\n \\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\n\\n        int sum=0,max=0;\\n        for(int i:nums)\\n        {\\n            sum+=i;\\n            max=Math.max(max,i);\\n        }\\n        if(nums.length==m)\\n            return max;\\n        if(m==1)\\n            return sum;\\n        int lo=max,hi=sum,ans=0;\\n        while(lo<=hi)\\n        {\\n            int mid=lo+(hi-lo)/2;\\n            if(fun(nums,mid,m))\\n            {\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else\\n                lo=mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n    boolean fun(int a[],int mid,int m)\\n    {\\n        int st=1,sum=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            sum+=a[i];\\n            if(sum>mid)\\n            {\\n                sum=a[i];\\n                st++;\\n            }\\n        }\\n        if(st<=m)\\n            return true;\\n        return false;\\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1805635,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int min = Arrays.stream(nums).max().getAsInt(); // min possible result is the max num of the array.\\n        int max = Arrays.stream(nums).sum(); // max possible result is the sum of the whole array.\\n        \\n        while (min < max) { // binary search the min value between [min - max] range.\\n            int mid = min + (max - min) / 2;\\n            int count = split(nums, mid); // put this value to see the count of the splitted array\\n            \\n            if (count <= m) { \\n                max = mid; // set max boundary to try left range.\\n            } else {\\n                min = mid + 1; // set min boundary to try right range.\\n            }\\n        }\\n        return min; // min is the \"min\" of the largest sum.\\n    }\\n    \\n    \\n    // get the count of subarrays with given max sum limit\\n    int split(int[] nums, int maxSum) {\\n        int count = 1;\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (sum + nums[i] > maxSum) {\\n                count++;\\n                sum = nums[i];\\n            } else {\\n                sum = sum + nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int min = Arrays.stream(nums).max().getAsInt(); // min possible result is the max num of the array.\\n        int max = Arrays.stream(nums).sum(); // max possible result is the sum of the whole array.\\n        \\n        while (min < max) { // binary search the min value between [min - max] range.\\n            int mid = min + (max - min) / 2;\\n            int count = split(nums, mid); // put this value to see the count of the splitted array\\n            \\n            if (count <= m) { \\n                max = mid; // set max boundary to try left range.\\n            } else {\\n                min = mid + 1; // set min boundary to try right range.\\n            }\\n        }\\n        return min; // min is the \"min\" of the largest sum.\\n    }\\n    \\n    \\n    // get the count of subarrays with given max sum limit\\n    int split(int[] nums, int maxSum) {\\n        int count = 1;\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (sum + nums[i] > maxSum) {\\n                count++;\\n                sum = nums[i];\\n            } else {\\n                sum = sum + nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755156,
                "title": "c-100-fast-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& nums, int mid, int m){\\n          int sa = 1;\\n          int sum = 0;\\n         for(int i=0; i<nums.size(); i++){\\n             sum += nums[i];\\n             if(sum > mid){\\n                 sa++;\\n                 sum = nums[i];\\n             }\\n         }    \\n          return sa <= m;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        \\n        int hi = accumulate(nums.begin(), nums.end(), 0);\\n        int lo = *max_element(nums.begin(), nums.end());\\n        \\n        // edge cases\\n        \\n        if(m == nums.size()) return lo;\\n        if(m == 1) return hi;\\n        int ans = 0;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo) / 2;\\n\\t\\t\\t\\n            if(isPossible(nums, mid, m)) {  ans = mid;  hi = mid - 1; }            \\n            else  lo = mid + 1;\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& nums, int mid, int m){\\n          int sa = 1;\\n          int sum = 0;\\n         for(int i=0; i<nums.size(); i++){\\n             sum += nums[i];\\n             if(sum > mid){\\n                 sa++;\\n                 sum = nums[i];\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1705209,
                "title": "binary-search-c-simple-solution",
                "content": "```\\n bool isValid(vector<int>& nums, int m, int mx) {\\n        int index = 1;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if(sum > mx) {\\n                index++;\\n                sum = nums[i];\\n            }\\n            \\n            if(index > m)\\n                return false;\\n        }\\n        \\n        \\n        return true;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int max = -1, sum = 0;\\n        \\n        for(int i : nums) {\\n            if(i > max)\\n                max = i;\\n            \\n            sum += i;\\n        }\\n        \\n        int start = max;\\n        int end = sum;\\n        int ans = -1;\\n        \\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(isValid(nums, m, mid)) {\\n                ans = mid;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n bool isValid(vector<int>& nums, int m, int mx) {\\n        int index = 1;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if(sum > mx) {\\n                index++;\\n                sum = nums[i];\\n            }\\n            \\n            if(index > m)\\n                return false;\\n        }\\n        \\n        \\n        return true;\\n    }\\n    \\n    int splitArray(vector<int>& nums, int m) {\\n        int max = -1, sum = 0;\\n        \\n        for(int i : nums) {\\n            if(i > max)\\n                max = i;\\n            \\n            sum += i;\\n        }\\n        \\n        int start = max;\\n        int end = sum;\\n        int ans = -1;\\n        \\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(isValid(nums, m, mid)) {\\n                ans = mid;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1643630,
                "title": "binary-search-java-with-notes",
                "content": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int start = 0;\\n        int end = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            start = Math.max(start, nums[i]); // in the end of loop this will contain the max item from the array //\\n                                              // linear search\\n            end += nums[i];\\n        }\\n\\n        // binary search\\n\\n        while (start < end) {\\n            // try for middle as potential answer\\n            int mid = start + (end - start) / 2;\\n\\n            // calculate how many pieces you can divide this in with this max sum\\n            int sum = 0;\\n            int pieces = 1; // atleast 1 you can divide\\n            for (int num : nums) {\\n                if (sum + num > mid) {\\n                    // you cannot add this in this subarray, make new one\\n                    // say you add this in new subarray, then sum = num\\n                    sum = num;\\n                    pieces++;\\n                } else {\\n                    sum += num;\\n                }\\n            }\\n            if (pieces > m) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        return end; // here start == end\\n    }\\n}\\n```\\nfor explaination check my link : [https://drive.google.com/file/d/1bJ2Z169s9kyNvuiLPaZNLARhfmNYHslN/view?usp=sharing]\\n\\nIf you find the solution useful do upvote! comment down for any doubt.\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int start = 0;\\n        int end = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            start = Math.max(start, nums[i]); // in the end of loop this will contain the max item from the array //\\n                                              // linear search\\n            end += nums[i];\\n        }\\n\\n        // binary search\\n\\n        while (start < end) {\\n            // try for middle as potential answer\\n            int mid = start + (end - start) / 2;\\n\\n            // calculate how many pieces you can divide this in with this max sum\\n            int sum = 0;\\n            int pieces = 1; // atleast 1 you can divide\\n            for (int num : nums) {\\n                if (sum + num > mid) {\\n                    // you cannot add this in this subarray, make new one\\n                    // say you add this in new subarray, then sum = num\\n                    sum = num;\\n                    pieces++;\\n                } else {\\n                    sum += num;\\n                }\\n            }\\n            if (pieces > m) {\\n                start = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        return end; // here start == end\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621063,
                "title": "python-binary-search",
                "content": "```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def cond(mid, m):\\n            capacity = -1\\n            for num in nums:  # becasue it\\'s splitting continuous sub-arrays, we can do it this way\\n                if num <= capacity:\\n                    capacity -= num\\n                else:\\n                    capacity = mid - num\\n                    m -= 1\\n            return m >= 0\\n        \\n        l, r = max(nums), sum(nums)\\n        while l < r:\\n            mid = (l + r) // 2\\n            if cond(mid, m):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        def cond(mid, m):\\n            capacity = -1\\n            for num in nums:  # becasue it\\'s splitting continuous sub-arrays, we can do it this way\\n                if num <= capacity:\\n                    capacity -= num\\n                else:\\n                    capacity = mid - num\\n                    m -= 1\\n            return m >= 0\\n        \\n        l, r = max(nums), sum(nums)\\n        while l < r:\\n            mid = (l + r) // 2\\n            if cond(mid, m):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567621,
                "title": "best-top-down-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    const int MOD=1e9+7;\\n    int dp[1002][52];\\n    int rec(int i,int m,vector<int>& nums){\\n        if(i==nums.size()){\\n            return (m)? MOD:0;\\n        }\\n        if(!m)return MOD;\\n        if(m==1){\\n            int sum=accumulate(nums.begin()+i,nums.end(),0LL);\\n            return sum;\\n        }\\n        if(dp[i][m]!=-1)return dp[i][m];\\n        int ans=MOD;\\n        int sum=0;\\n        for(int j=i;j<nums.size()-m+1;j++){\\n            sum+=nums[j];\\n            ans=min(ans,max(sum,rec(j+1,m-1,nums)));\\n        }\\n        return dp[i][m]=ans;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,m,nums);\\n    }\\n};\\n```\\nIf you guys also want explanation please comment and let me know.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD=1e9+7;\\n    int dp[1002][52];\\n    int rec(int i,int m,vector<int>& nums){\\n        if(i==nums.size()){\\n            return (m)? MOD:0;\\n        }\\n        if(!m)return MOD;\\n        if(m==1){\\n            int sum=accumulate(nums.begin()+i,nums.end(),0LL);\\n            return sum;\\n        }\\n        if(dp[i][m]!=-1)return dp[i][m];\\n        int ans=MOD;\\n        int sum=0;\\n        for(int j=i;j<nums.size()-m+1;j++){\\n            sum+=nums[j];\\n            ans=min(ans,max(sum,rec(j+1,m-1,nums)));\\n        }\\n        return dp[i][m]=ans;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,m,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530093,
                "title": "intuition-approaches-code-of-both-methods-completely-explained-faster-than-100",
                "content": "Intuition-\\nSo clearly a brute force solution would include making all the possible subarrays when array has been divided in m parts.\\nThis step alone would cost approx O(n^(m-1)) and n*n-1*n-2........................m-1 terms to be exact. \\n//if you don\\'t understand this ,don\\'t sweat it\\'s not important.\\nSo clearly we can try and find an optimal substructure which could help find the optimal solution for this problem.\\nOne solution could be if we can somehow check that what is the minimum largest sum of the array is if it\\'s the m-1th subarray and  ended at some index i then we could use this information to find what would be the minimum largest sum of the array if it\\'s the mth part and ended at some index k.\\nNow if it\\'s not clear ..it will be in a second\\n\\nlets define dp[i][j] to be minimum largest sum if the ith subarray ended at jth index(inclusive)\\nfor all indexes k from i-1 to j-1//both included ..this is the range where i-1th subarray could have ended\\ndp[i][j]=min(dp[i][j],,max(dp[i-1][k],sum of array from k+1th to jth elements))\\n//this sum could be easily calculated using prefixsum\\nthis recurrence states that minimum largest sum of the ith part ending at jth index would be minimum of previously found value of this and maximum of (min largest sum of i-1th part ending at some index k<j,sum of elements of last formed array)\\n```\\nint splitArray(vector<int>& nums, int m) {\\n        vector<vector<int>>dp(m,vector<int>(nums.size(),INT_MAX));\\n        vector<int>prefixsum;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            prefixsum.push_back(sum);\\n        }\\n        int n=nums.size();\\n        for(int j=0;j<=n-m;j++)\\n        {\\n            dp[0][j]=prefixsum[j];\\n        }\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=i;j<=n-m+i;j++)\\n            {\\n                for(int k=i-1;k<=j-1;k++)\\n                {\\n                    dp[i][j]=min(dp[i][j],max(dp[i-1][k],prefixsum[j]-prefixsum[k]));\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n```\\nRuntime Complexity-O(n*n*m)\\nSpace Complexity-O(n*m) which could be further reduced to O(m)\\n\\nMethod 2 Binary search + Greedy \\nSo if there\\'s some method that could tell us if given a number and m ( the number of parts ) if array can be divided such that no subarray would have sum of elements greater than this number and with parts <=m.\\nthen we could use this function to binary search our answer as m is fixed and so if on a sum the solution is possible then the solution is possible for any number greater than it .\\nNow question arised how to get this method..it\\'\\'s very simple ..\\nyou just put elements in a array until you can\\'t (until you can\\'t without violating the property that it\\'s sum <=number) and in the end if parts you needed<=m then ans is yes else no\\n\\nCode-\\n```\\nint check(vector<int>&nums,int sum,int m)\\n    {\\n        int parts=1;\\n        int curr=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>sum)\\n                return 0;\\n            else if(nums[i]+curr<=sum)\\n            {\\n                curr+=nums[i];\\n            }\\n            else\\n            {\\n                curr=nums[i];\\n                parts+=1;\\n                if(parts>m)\\n                    return 0;\\n            }\\n        }\\n        if(parts<=m)\\n            return 1;\\n        return 0;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        int left=0;\\n        int right=pow(10,9);\\n        int already=0;\\n        while(left!=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(check(nums,mid,m)==1)\\n                right=mid;\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n```\\nRuntime Complexity-O(log(10^9)*n)//why pow(10,9) because that\\'s the max sum a subarray could have\\nSpace-O(1)",
                "solutionTags": [],
                "code": "```\\nint splitArray(vector<int>& nums, int m) {\\n        vector<vector<int>>dp(m,vector<int>(nums.size(),INT_MAX));\\n        vector<int>prefixsum;\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            prefixsum.push_back(sum);\\n        }\\n        int n=nums.size();\\n        for(int j=0;j<=n-m;j++)\\n        {\\n            dp[0][j]=prefixsum[j];\\n        }\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=i;j<=n-m+i;j++)\\n            {\\n                for(int k=i-1;k<=j-1;k++)\\n                {\\n                    dp[i][j]=min(dp[i][j],max(dp[i-1][k],prefixsum[j]-prefixsum[k]));\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n```\n```\\nint check(vector<int>&nums,int sum,int m)\\n    {\\n        int parts=1;\\n        int curr=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>sum)\\n                return 0;\\n            else if(nums[i]+curr<=sum)\\n            {\\n                curr+=nums[i];\\n            }\\n            else\\n            {\\n                curr=nums[i];\\n                parts+=1;\\n                if(parts>m)\\n                    return 0;\\n            }\\n        }\\n        if(parts<=m)\\n            return 1;\\n        return 0;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        int left=0;\\n        int right=pow(10,9);\\n        int already=0;\\n        while(left!=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(check(nums,mid,m)==1)\\n                right=mid;\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1523331,
                "title": "python-binary-search-using-template",
                "content": "```\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        def feasible(arr, m, target):\\n            \\n            res = 0\\n            cnt = 0\\n            \\n            for i, a in enumerate(arr):\\n                if res + a > target:\\n                    cnt += 1\\n                    res = 0\\n                res += a\\n                if i == len(arr) - 1 and res > 0:\\n                    cnt += 1\\n              \\n            return cnt <= m\\n        \\n        l, r = max(nums), sum(nums)\\n\\n        \\n        while l < r:\\n            \\n            mid = l + (r - l) // 2\\n\\n            if feasible(nums, m, mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        def feasible(arr, m, target):\\n            \\n            res = 0\\n            cnt = 0\\n            \\n            for i, a in enumerate(arr):\\n                if res + a > target:\\n                    cnt += 1\\n                    res = 0\\n                res += a\\n                if i == len(arr) - 1 and res > 0:\\n                    cnt += 1\\n              \\n            return cnt <= m\\n        \\n        l, r = max(nums), sum(nums)\\n\\n        \\n        while l < r:\\n            \\n            mid = l + (r - l) // 2\\n\\n            if feasible(nums, m, mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495762,
                "title": "java-split-array-largest-sum",
                "content": "***// Runtime: 1 ms, faster than 69.91% of Java online submissions for Split Array Largest Sum***\\n\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n         int start = 0;\\n        int end = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            start = Math.max(start, nums[i]); // in the end of the loop this will contain the max item from the array\\n            end += nums[i];\\n        }\\n        // binary search\\n        while (start < end){\\n            // try for middle as potential ans\\n            int mid = start + (end - start)/2;\\n\\n            // calculate how many pieces you divide this in wit this max sum\\n            int sum = 0;\\n            int pieces = 1;\\n            for(int num: nums){\\n                if (sum + num>mid){\\n                    // we can not add this in this sub array make new one\\n                    // say we add this num in new sub array then sum = num\\n                    sum = num;\\n                    pieces++;\\n                }\\n                else {\\n                    sum+= num;\\n                }\\n            }\\n            if (pieces > m){\\n                start = mid +1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return end; // here start == end\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int splitArray(int[] nums, int m) {\\n         int start = 0;\\n        int end = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            start = Math.max(start, nums[i]); // in the end of the loop this will contain the max item from the array\\n            end += nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1475425,
                "title": "simple-c-solution-using-binary-search-concept-similar-to-allocate-min-number-of-pages",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int> a, int k,int mid)\\n    {\\n        int n=a.size();\\n        int sum=0;\\n        int subarray=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]>mid)\\n                return false;\\n            sum+=a[i];\\n            if(sum>mid)\\n            {\\n                subarray++;\\n                sum=a[i];\\n            }\\n            if(subarray>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        int n=nums.size();\\n        int mn=INT_MAX;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=min(mn,nums[i]);\\n            sum+=nums[i];\\n        }\\n        int low=mn;\\n        int high=sum;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(nums,m,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\tPlease consider upvoting.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int> a, int k,int mid)\\n    {\\n        int n=a.size();\\n        int sum=0;\\n        int subarray=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]>mid)\\n                return false;\\n            sum+=a[i];\\n            if(sum>mid)\\n            {\\n                subarray++;\\n                sum=a[i];\\n            }\\n            if(subarray>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        int n=nums.size();\\n        int mn=INT_MAX;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=min(mn,nums[i]);\\n            sum+=nums[i];\\n        }\\n        int low=mn;\\n        int high=sum;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=low+((high-low)>>1);\\n            if(isValid(nums,m,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433241,
                "title": "python-memoization-binary-search-o-mn-log-n",
                "content": "The problem can be solved with dp since there are overlapping subproblems.\\n\\nGiven m splits we should try every possible subarray with start of \\'index\\' and end index ranging from index to len(arr)-splits-1 (and determine its sum) and the subproblem is finding the minimized maximum from end index to len(arr) with m-1 splits. Take the maximum of the subarray sum and the minimized maximum from subproblem (which I named maxLeftover in my code). The maximum should be compared with the current minimized maximum.\\n\\nAn issue that arises is the need to calculate the sum of subarrays efficiently. We can do it in O(1) time using prefixSum rather than wasting O(n) work each time for a subarray by looping through. So, I wrote a function getSum for this. \\n\\nAnother thing to note is I prefered working with the idea of splits rather than the number of subarrays. splits = number of subarrays - 1 but similar code can be written for number of subarrays. \\n\\nm = the given m\\nn = length of array\\n\\nthe O(mn^2) solution that can be improved. There are O(mn) unmemoized calls and each of these unmemoized calls do O(n) work from the for loop.\\n```\\nclass Solution:\\n    def splitArray(self, nums: [int], m: int) -> int:\\n        prefixSum = []\\n        curSum = 0 \\n        for num in nums: \\n            curSum += num\\n            prefixSum.append(curSum)\\n        self.prefixSum = prefixSum   \\n        memo = dict()\\n        minMax = self.helper(0, m-1, memo)\\n        return minMax\\n        \\n    def getSum(self, start: int, end: int) -> int: \\n        res = self.prefixSum[end]\\n        res -= self.prefixSum[start-1] if start-1 >= 0 else 0 \\n        return res\\n    \\n    def helper(self, index: int, splits: int, memo: dict) -> int: \\n        if splits == 0: \\n            subarray = self.getSum(index, len(self.prefixSum)-1)\\n            return subarray\\n        \\n        key = (index, splits) \\n        if key in memo: \\n            return memo[key]\\n        \\n        minMax = float(\\'inf\\')\\n        maxIndex = len(self.prefixSum)-splits\\n        for i in range (index, maxIndex): \\n            subarray = self.getSum(index, i)\\n            maxLeftover = self.helper(i+1, splits-1, memo)\\n            maximum = max(subarray, maxLeftover) \\n            minMax = min(minMax, maximum)\\n        memo[key] = minMax\\n        return minMax  \\n```\\n\\nThe O(mn^2) solution I wrote TLEs but there is one fact that we haven\\'t made use of. The array only consists of non-negatives. This means that given 2 subarrays that start at the same indices sum(longer subarray) >= sum(shorter subarray). Similarly, the minimized maximum of a longer region and shorter region (assuming same number of splits left) follow a similar pattern. In very exact terms, the sum of subarrays and minimized maximums are monotonically increasing.\\n\\nSo, we can binary search by minimizing the difference between subarray and maxLeftover in the O(mn) solution. If subarray > maxLeftover, we should move the end pointer more to the left to decrease subarray and increase maxLeftover. If subarray < maxLeftover, we should move the end pointer to the right to increase subarray and decrease maxLeftover. If they are equal, we should just break and use those values. \\n\\nO(mn log n) solution. There are O(mn) unmemoized calls and each of these unmemoized calls do O(log n) work in the binary search.  \\n```\\nclass Solution:\\n    def splitArray(self, nums: [int], m: int) -> int:\\n        prefixSum = []\\n        curSum = 0 \\n        for num in nums: \\n            curSum += num\\n            prefixSum.append(curSum)\\n        self.prefixSum = prefixSum   \\n        memo = [[-1] * m for i in range (len(nums))]\\n        minMax = self.helper(0, m-1, memo)\\n        return minMax\\n        \\n    def getSum(self, start: int, end: int) -> int: \\n        res = self.prefixSum[end]\\n        res -= self.prefixSum[start-1] if start-1 >= 0 else 0 \\n        return res\\n    \\n    def helper(self, index: int, splits: int, memo: [[int]]) -> int: \\n        if splits == 0: \\n            subarray = self.getSum(index, len(self.prefixSum)-1)\\n            return subarray\\n        \\n        if memo[index][splits] != -1: \\n            return memo[index][splits]\\n        \\n        minMax = float(\\'inf\\')\\n        low = index\\n        high = len(self.prefixSum)-splits-1\\n        while low <= high: \\n            mid = low + (high-low) // 2\\n            subarray = self.getSum(index, mid)\\n            maxLeftover = self.helper(mid+1, splits-1, memo)\\n            minMax = min(minMax, max(subarray, maxLeftover))\\n            if subarray < maxLeftover: \\n                low = mid+1\\n            elif subarray > maxLeftover: \\n                high = mid-1\\n            else: \\n                break \\n        memo[index][splits] = minMax\\n        return minMax\\n```\\nLet me know if you have any questions.",
                "solutionTags": [
                    "Python3",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: [int], m: int) -> int:\\n        prefixSum = []\\n        curSum = 0 \\n        for num in nums: \\n            curSum += num\\n            prefixSum.append(curSum)\\n        self.prefixSum = prefixSum   \\n        memo = dict()\\n        minMax = self.helper(0, m-1, memo)\\n        return minMax\\n        \\n    def getSum(self, start: int, end: int) -> int: \\n        res = self.prefixSum[end]\\n        res -= self.prefixSum[start-1] if start-1 >= 0 else 0 \\n        return res\\n    \\n    def helper(self, index: int, splits: int, memo: dict) -> int: \\n        if splits == 0: \\n            subarray = self.getSum(index, len(self.prefixSum)-1)\\n            return subarray\\n        \\n        key = (index, splits) \\n        if key in memo: \\n            return memo[key]\\n        \\n        minMax = float(\\'inf\\')\\n        maxIndex = len(self.prefixSum)-splits\\n        for i in range (index, maxIndex): \\n            subarray = self.getSum(index, i)\\n            maxLeftover = self.helper(i+1, splits-1, memo)\\n            maximum = max(subarray, maxLeftover) \\n            minMax = min(minMax, maximum)\\n        memo[key] = minMax\\n        return minMax  \\n```\n```\\nclass Solution:\\n    def splitArray(self, nums: [int], m: int) -> int:\\n        prefixSum = []\\n        curSum = 0 \\n        for num in nums: \\n            curSum += num\\n            prefixSum.append(curSum)\\n        self.prefixSum = prefixSum   \\n        memo = [[-1] * m for i in range (len(nums))]\\n        minMax = self.helper(0, m-1, memo)\\n        return minMax\\n        \\n    def getSum(self, start: int, end: int) -> int: \\n        res = self.prefixSum[end]\\n        res -= self.prefixSum[start-1] if start-1 >= 0 else 0 \\n        return res\\n    \\n    def helper(self, index: int, splits: int, memo: [[int]]) -> int: \\n        if splits == 0: \\n            subarray = self.getSum(index, len(self.prefixSum)-1)\\n            return subarray\\n        \\n        if memo[index][splits] != -1: \\n            return memo[index][splits]\\n        \\n        minMax = float(\\'inf\\')\\n        low = index\\n        high = len(self.prefixSum)-splits-1\\n        while low <= high: \\n            mid = low + (high-low) // 2\\n            subarray = self.getSum(index, mid)\\n            maxLeftover = self.helper(mid+1, splits-1, memo)\\n            minMax = min(minMax, max(subarray, maxLeftover))\\n            if subarray < maxLeftover: \\n                low = mid+1\\n            elif subarray > maxLeftover: \\n                high = mid-1\\n            else: \\n                break \\n        memo[index][splits] = minMax\\n        return minMax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370449,
                "title": "java-0-ms-binary-search-solution",
                "content": "\\n```\\nclass Solution {\\n    public int splitArray(int[] arr, int m) {\\n        if (arr.length == 0)\\n            return 0;\\n        int sum = 0, maxEl = -1;\\n        for (int i: arr) {\\n            sum += i;\\n            maxEl = Math.max(maxEl, i);\\n        }\\n        int largestSum = bs(arr, maxEl, sum, m);\\n        return largestSum;\\n    }\\n    private int bs(int[] arr, int low, int high, int m) {\\n        if (low > high)\\n            return low;\\n        int mid = (low + high) / 2;\\n        if (countSplits(arr, mid) <= m)\\n            return bs(arr, low, mid - 1, m);\\n        else\\n            return bs(arr, mid + 1, high, m);\\n    }\\n    private int countSplits(int[] arr, int mid) {\\n        int splits = 1;\\n        int curSum = 0;\\n        for (int i: arr) {\\n            curSum += i;\\n            if (curSum > mid) {\\n                splits++;\\n                curSum = i;\\n            }\\n        }\\n\\n        return splits;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] arr, int m) {\\n        if (arr.length == 0)\\n            return 0;\\n        int sum = 0, maxEl = -1;\\n        for (int i: arr) {\\n            sum += i;\\n            maxEl = Math.max(maxEl, i);\\n        }\\n        int largestSum = bs(arr, maxEl, sum, m);\\n        return largestSum;\\n    }\\n    private int bs(int[] arr, int low, int high, int m) {\\n        if (low > high)\\n            return low;\\n        int mid = (low + high) / 2;\\n        if (countSplits(arr, mid) <= m)\\n            return bs(arr, low, mid - 1, m);\\n        else\\n            return bs(arr, mid + 1, high, m);\\n    }\\n    private int countSplits(int[] arr, int mid) {\\n        int splits = 1;\\n        int curSum = 0;\\n        for (int i: arr) {\\n            curSum += i;\\n            if (curSum > mid) {\\n                splits++;\\n                curSum = i;\\n            }\\n        }\\n\\n        return splits;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354507,
                "title": "dp-based-approach-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pre;\\n    vector<int> maxm;\\n    int sum(int i,int j){\\n        if(i == 0){\\n            return pre[j];\\n        }\\n        return pre[j]-pre[i-1];\\n    }\\n    \\n    int solve(vector<int> &arr,int i,int m,vector<vector<int>> &dp){\\n        if(arr.size() <= i) return INT_MAX;\\n        if(m == 1){\\n            return dp[i][m] = sum(i,arr.size()-1);\\n        }\\n        if(arr.size()-i == m){\\n            return dp[i][m] = maxm[i];\\n        }\\n        if(dp[i][m] != -1){\\n            return dp[i][m];\\n        }\\n        int ans = INT_MAX;\\n        int sum = 0;\\n        int currMax = 0;\\n        for(int j=i;j<arr.size();j++){\\n            sum += arr[j];\\n            \\n            currMax = max(sum,solve(arr,j+1,m-1,dp));\\n            ans = min(ans,currMax);\\n        }\\n        return dp[i][m] = ans ;\\n    }\\n    int dp(vector<int>& arr, int m){\\n        int n = arr.size();\\n        vector<vector<int>> dp(n,vector<int>(m+1,-1));\\n        pre.push_back(arr[0]);\\n        maxm.resize(arr.size());\\n        for(int i=1;i<arr.size();i++){\\n            pre.push_back(arr[i]+pre[i-1]);\\n        }\\n        maxm[n-1] = arr[n-1];\\n        for(int i=arr.size()-2;i>=0;i--){\\n            maxm[i] = max(maxm[i+1],arr[i]);\\n        }\\n        \\n        if(n == m){\\n            return maxm[0];\\n        }\\n        \\n        return solve(arr,0,m,dp);\\n    }\\n    \\n    \\n    int splitArray(vector<int>& arr, int m) {\\n        return dp(arr,m);\\n    }\\n};\\n```\\n\\nDefine **dp[i][m]** as the answer to the subproblem from index **i** to **(n-1)** with **m** number of cuts. \\nTry cutting array at each index **i** and solve for the remaining **(i+1)th** to **(n-1)th** index with **(m-1)** cuts. If m == 1 then no cuts are required and the sum of all the remaining elements is the answer. If the number of remaining elements are equal to m i.e **arr.size()-i == m** , then each element is considered and maximum from **i to (n-1)th index** element is considered.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pre;\\n    vector<int> maxm;\\n    int sum(int i,int j){\\n        if(i == 0){\\n            return pre[j];\\n        }\\n        return pre[j]-pre[i-1];\\n    }\\n    \\n    int solve(vector<int> &arr,int i,int m,vector<vector<int>> &dp){\\n        if(arr.size() <= i) return INT_MAX;\\n        if(m == 1){\\n            return dp[i][m] = sum(i,arr.size()-1);\\n        }\\n        if(arr.size()-i == m){\\n            return dp[i][m] = maxm[i];\\n        }\\n        if(dp[i][m] != -1){\\n            return dp[i][m];\\n        }\\n        int ans = INT_MAX;\\n        int sum = 0;\\n        int currMax = 0;\\n        for(int j=i;j<arr.size();j++){\\n            sum += arr[j];\\n            \\n            currMax = max(sum,solve(arr,j+1,m-1,dp));\\n            ans = min(ans,currMax);\\n        }\\n        return dp[i][m] = ans ;\\n    }\\n    int dp(vector<int>& arr, int m){\\n        int n = arr.size();\\n        vector<vector<int>> dp(n,vector<int>(m+1,-1));\\n        pre.push_back(arr[0]);\\n        maxm.resize(arr.size());\\n        for(int i=1;i<arr.size();i++){\\n            pre.push_back(arr[i]+pre[i-1]);\\n        }\\n        maxm[n-1] = arr[n-1];\\n        for(int i=arr.size()-2;i>=0;i--){\\n            maxm[i] = max(maxm[i+1],arr[i]);\\n        }\\n        \\n        if(n == m){\\n            return maxm[0];\\n        }\\n        \\n        return solve(arr,0,m,dp);\\n    }\\n    \\n    \\n    int splitArray(vector<int>& arr, int m) {\\n        return dp(arr,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318853,
                "title": "python-beats-99-78-cheating",
                "content": "I wish I could say that I beat `99.78%` because I came up with a clever algorithm that does this faster. But actually, I just cheated and the test cases didn\\'t catch me.\\nHere\\'s my solution where I narrow the binary search space to `sum(nums)` minus the `m-1` largest elements.\\nAnd here\\'s a test case that breaks it:\\n```\\n[100,2,100,10,100]\\n4\\n```\\nI don\\'t know who to complain to, but leetcode should really add this test case, so my invalid solution won\\'t pass. Until then, here\\'s my (incorrect) solution.\\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        def canSplit(k: int) -> bool:\\n            curr = 0\\n            count = 0\\n            for num in nums:\\n                curr += num\\n                if curr > k:\\n                    count += 1\\n                    curr = num\\n            if curr:\\n                count += 1\\n            return count <= m\\n        l, r = max(nums), sum(nums) - sum(heapq.nlargest(m-1, nums))\\n        while l < r:\\n            k = (l+r) // 2\\n            if canSplit(k):\\n                r = k\\n            else:\\n                l = k+1\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n[100,2,100,10,100]\\n4\\n```\n```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        n = len(nums)\\n        def canSplit(k: int) -> bool:\\n            curr = 0\\n            count = 0\\n            for num in nums:\\n                curr += num\\n                if curr > k:\\n                    count += 1\\n                    curr = num\\n            if curr:\\n                count += 1\\n            return count <= m\\n        l, r = max(nums), sum(nums) - sum(heapq.nlargest(m-1, nums))\\n        while l < r:\\n            k = (l+r) // 2\\n            if canSplit(k):\\n                r = k\\n            else:\\n                l = k+1\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316559,
                "title": "c-dfs-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        vector<vector<int>> memo(nums.size(), vector<int>(m, INT_MIN));\\n        return DFS_split(nums, 0, m, memo);\\n    }\\n    int DFS_split(vector<int>& nums, int istart, int m, vector<vector<int>>& memo) {\\n        if (m == 0 && istart < nums.size()) return -1;\\n        if (istart == nums.size()) {\\n            return m == 0? 0 : -1;\\n        }\\n        if (memo[istart][m-1] != INT_MIN) return memo[istart][m-1];\\n        int curr_sum = 0;\\n        int ans = INT_MAX;\\n        for (int i = istart; i < nums.size(); ++i) {\\n            curr_sum += nums[i];\\n            int rest_max_splits = nums.size()-(i+1);\\n            if (rest_max_splits < m-1) break;\\n            int rest_max_sum = DFS_split(nums, i+1, m-1, memo);\\n            if (rest_max_sum == -1) continue;\\n            int curr_split_max_sum = std::max(curr_sum, rest_max_sum);\\n            ans = std::min(ans, curr_split_max_sum);\\n        }\\n        memo[istart][m-1] = ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        vector<vector<int>> memo(nums.size(), vector<int>(m, INT_MIN));\\n        return DFS_split(nums, 0, m, memo);\\n    }\\n    int DFS_split(vector<int>& nums, int istart, int m, vector<vector<int>>& memo) {\\n        if (m == 0 && istart < nums.size()) return -1;\\n        if (istart == nums.size()) {\\n            return m == 0? 0 : -1;\\n        }\\n        if (memo[istart][m-1] != INT_MIN) return memo[istart][m-1];\\n        int curr_sum = 0;\\n        int ans = INT_MAX;\\n        for (int i = istart; i < nums.size(); ++i) {\\n            curr_sum += nums[i];\\n            int rest_max_splits = nums.size()-(i+1);\\n            if (rest_max_splits < m-1) break;\\n            int rest_max_sum = DFS_split(nums, i+1, m-1, memo);\\n            if (rest_max_sum == -1) continue;\\n            int curr_split_max_sum = std::max(curr_sum, rest_max_sum);\\n            ans = std::min(ans, curr_split_max_sum);\\n        }\\n        memo[istart][m-1] = ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298783,
                "title": "brute-force-to-optimized-dfs",
                "content": "```\\n/*\\n[7,2,5,10,8], m = 2\\n\\nbags: [7,10][2,5,8]\\nsum:  [17,15]\\nsubsequence or subbarray\\n\\n7,2,5,10,8\\nsum:?\\n[7,2,5][10,8]\\n\\n1,2,3,4,5 m = 2\\n[1,2,3,4][5] :max(10,5)=10\\n[1,2,3][4,5] :max(6,9)=9\\n\\n[1][2,3,4,5] :max(1,14)=14\\n[][1,2,3,4,5]: max(0,15)=15\\n\\ngenerate all possible partitions by taking and not taking nums\\nreturn DFS(1, m - 1, nums[0], nums[0])\\n\\nDFS(i, #remaing partition, curSum, maxSumSofar)\\n\\n  if i == n && m = 0;\\n    return maxSumSofar\\n\\n  if m == 1\\n    max(maxSumSofar, curSum + sum of remainings in array)\\n    \\n  curSum += nums[i];\\n  return min(DFS(i+1, m, curSum, maxSumSofar), DFS(i+1, m - 1, nums[1], max(maxSumSofar, curSum))\\n\\nT:O(2^N)\\nS:(N)\\n\\n1,2,3 m = 2\\n    i\\n[1,2][3]\\n\\nDFS(0,2,0,0)\\n  DFS(1,2,1,0)\\n    DFS(2,2,3,0)\\n      DFS(3,2,6,0)\\n        DFS(3,2,6,0)\\n    DFS(2,1,0,3)\\n  DFS(1,1,0,1)\\n    DFS(2,1,3,1)\\n      DFS(3,1,6,1)\\n      DFS(3,0,0,6)\\n    DFS(2,0,0,3)\\n\\n*/\\n\\npublic class Solution {\\n  public int SplitArray(int[] nums, int M) {\\n    var ans = int.MaxValue;\\n    var n = nums.Length;\\n    //DFS(0, M, 0, 0);\\n    //return ans;      \\n\\n    void DFS(int i, int m, int curSum, int maxSumSofar){\\n      if (i == n && m == 0){\\n        ans = Math.Min(ans, maxSumSofar);\\n        return;\\n      }\\n      if (i == n || m == 0)\\n        return;\\n\\n      curSum += nums[i];\\n      DFS(i + 1, m, curSum, maxSumSofar);\\n      DFS(i + 1, m - 1, 0, Math.Max(maxSumSofar, curSum));\\n    }\\n    \\n    var cache = new Dictionary<string, int>();\\n    // DFS_Memoiz_Dic(0, M, 0, 0);// still TLE\\n    // return ans;      \\n\\n    void DFS_Memoiz_Dic(int i, int m, int curSum, int maxSumSofar){\\n      var key = $\"{i}_{m}_{curSum}_{maxSumSofar}\";\\n      if (i == n && m == 0){\\n        cache[key] = ans = Math.Min(ans, maxSumSofar);\\n        return;\\n      }\\n      if (i == n || m == 0)\\n        return;\\n\\n      if(cache.ContainsKey(key)) return;\\n      \\n      curSum += nums[i];\\n      DFS_Memoiz_Dic(i + 1, m, curSum, maxSumSofar);\\n      DFS_Memoiz_Dic(i + 1, m - 1, 0, Math.Max(maxSumSofar, curSum));\\n    }\\n    \\n    var preSum = new int[n+1];\\n    preSum[0] = 0;\\n    for (var i = 1; i <= n; i++)\\n      preSum[i] += nums[i-1] + preSum[i-1];\\n    \\n    var memo = new int[n, M + 1];\\n    //return DFS_Memoize_Array(0, M); //29 / 30 test cases passed. TLE\\n    \\n    for(var i = 0; i < n; ++i)\\n      for(var j = 0; j < M + 1; ++j)\\n        memo[i, j] = -1;\\n    \\n    return DFS_Memoize_Array(0, M); //29 / 30 test cases passed. TLE\\n\\n    int DFS_Memoize_Array(int start, int m){\\n      if(m == 1){\\n        return memo[start, m] = preSum[n] - preSum[start];\\n      }\\n\\n      if (memo[start, m] != -1) return memo[start, m];\\n      \\n      var max = int.MaxValue;\\n      for(var i = start; i < n - 1; ++i){\\n        var curSum = preSum[i + 1] - preSum[start];\\n        var maxRightPartition = DFS_Memoize_Array(i + 1, m - 1);\\n        max = Math.Min(max, Math.Max(curSum, maxRightPartition));\\n      }\\n      return memo[start, m] = max;\\n    }        \\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/*\\n[7,2,5,10,8], m = 2\\n\\nbags: [7,10][2,5,8]\\nsum:  [17,15]\\nsubsequence or subbarray\\n\\n7,2,5,10,8\\nsum:?\\n[7,2,5][10,8]\\n\\n1,2,3,4,5 m = 2\\n[1,2,3,4][5] :max(10,5)=10\\n[1,2,3][4,5] :max(6,9)=9\\n\\n[1][2,3,4,5] :max(1,14)=14\\n[][1,2,3,4,5]: max(0,15)=15\\n\\ngenerate all possible partitions by taking and not taking nums\\nreturn DFS(1, m - 1, nums[0], nums[0])\\n\\nDFS(i, #remaing partition, curSum, maxSumSofar)\\n\\n  if i == n && m = 0;\\n    return maxSumSofar\\n\\n  if m == 1\\n    max(maxSumSofar, curSum + sum of remainings in array)\\n    \\n  curSum += nums[i];\\n  return min(DFS(i+1, m, curSum, maxSumSofar), DFS(i+1, m - 1, nums[1], max(maxSumSofar, curSum))\\n\\nT:O(2^N)\\nS:(N)\\n\\n1,2,3 m = 2\\n    i\\n[1,2][3]\\n\\nDFS(0,2,0,0)\\n  DFS(1,2,1,0)\\n    DFS(2,2,3,0)\\n      DFS(3,2,6,0)\\n        DFS(3,2,6,0)\\n    DFS(2,1,0,3)\\n  DFS(1,1,0,1)\\n    DFS(2,1,3,1)\\n      DFS(3,1,6,1)\\n      DFS(3,0,0,6)\\n    DFS(2,0,0,3)\\n\\n*/\\n\\npublic class Solution {\\n  public int SplitArray(int[] nums, int M) {\\n    var ans = int.MaxValue;\\n    var n = nums.Length;\\n    //DFS(0, M, 0, 0);\\n    //return ans;      \\n\\n    void DFS(int i, int m, int curSum, int maxSumSofar){\\n      if (i == n && m == 0){\\n        ans = Math.Min(ans, maxSumSofar);\\n        return;\\n      }\\n      if (i == n || m == 0)\\n        return;\\n\\n      curSum += nums[i];\\n      DFS(i + 1, m, curSum, maxSumSofar);\\n      DFS(i + 1, m - 1, 0, Math.Max(maxSumSofar, curSum));\\n    }\\n    \\n    var cache = new Dictionary<string, int>();\\n    // DFS_Memoiz_Dic(0, M, 0, 0);// still TLE\\n    // return ans;      \\n\\n    void DFS_Memoiz_Dic(int i, int m, int curSum, int maxSumSofar){\\n      var key = $\"{i}_{m}_{curSum}_{maxSumSofar}\";\\n      if (i == n && m == 0){\\n        cache[key] = ans = Math.Min(ans, maxSumSofar);\\n        return;\\n      }\\n      if (i == n || m == 0)\\n        return;\\n\\n      if(cache.ContainsKey(key)) return;\\n      \\n      curSum += nums[i];\\n      DFS_Memoiz_Dic(i + 1, m, curSum, maxSumSofar);\\n      DFS_Memoiz_Dic(i + 1, m - 1, 0, Math.Max(maxSumSofar, curSum));\\n    }\\n    \\n    var preSum = new int[n+1];\\n    preSum[0] = 0;\\n    for (var i = 1; i <= n; i++)\\n      preSum[i] += nums[i-1] + preSum[i-1];\\n    \\n    var memo = new int[n, M + 1];\\n    //return DFS_Memoize_Array(0, M); //29 / 30 test cases passed. TLE\\n    \\n    for(var i = 0; i < n; ++i)\\n      for(var j = 0; j < M + 1; ++j)\\n        memo[i, j] = -1;\\n    \\n    return DFS_Memoize_Array(0, M); //29 / 30 test cases passed. TLE\\n\\n    int DFS_Memoize_Array(int start, int m){\\n      if(m == 1){\\n        return memo[start, m] = preSum[n] - preSum[start];\\n      }\\n\\n      if (memo[start, m] != -1) return memo[start, m];\\n      \\n      var max = int.MaxValue;\\n      for(var i = start; i < n - 1; ++i){\\n        var curSum = preSum[i + 1] - preSum[start];\\n        var maxRightPartition = DFS_Memoize_Array(i + 1, m - 1);\\n        max = Math.Min(max, Math.Max(curSum, maxRightPartition));\\n      }\\n      return memo[start, m] = max;\\n    }        \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210939,
                "title": "java-100-binary-search-greedy",
                "content": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        // algorithm: binary search + greedy \\n        // the answer must be in range of [maximum nums[i], sum(nums)]\\n        // for each possible value mid, compute the minumum number of subarrays we can split nums into.\\n        // the minimum number of subarrays can be obtained by greedy algorithm: we add next elments into current subarray\\n        // until the sum of it is greater than mid.\\n        // if the minimum number of subarrays is larger than m, then mid is absolutely too small. so we check the right part\\n        // if the minimum number of subarrats is greater than or equal to m. then we need to check left part to make sure\\n        // it converges to a value that is a sum of some subarray in the split.\\n        int n = nums.length;\\n        int max = nums[0];\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            max = Math.max(max, nums[i]);\\n        }\\n        int left = max;\\n        int right = sum;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int count = split(nums, mid);\\n            if (count > m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left; // this return value must be a sum of a subarray bc this is the smallest value that satisfies the requirement that the whole array is split into m parts\\n    }\\n    \\n    private int split(int[] nums, int limit) {\\n        int n = nums.length;\\n        int count = 0;\\n        int subSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            subSum += nums[i];\\n            if (subSum > limit) {\\n                count++;\\n                subSum = nums[i];\\n            }\\n        }\\n        count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        // algorithm: binary search + greedy \\n        // the answer must be in range of [maximum nums[i], sum(nums)]\\n        // for each possible value mid, compute the minumum number of subarrays we can split nums into.\\n        // the minimum number of subarrays can be obtained by greedy algorithm: we add next elments into current subarray\\n        // until the sum of it is greater than mid.\\n        // if the minimum number of subarrays is larger than m, then mid is absolutely too small. so we check the right part\\n        // if the minimum number of subarrats is greater than or equal to m. then we need to check left part to make sure\\n        // it converges to a value that is a sum of some subarray in the split.\\n        int n = nums.length;\\n        int max = nums[0];\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            max = Math.max(max, nums[i]);\\n        }\\n        int left = max;\\n        int right = sum;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int count = split(nums, mid);\\n            if (count > m) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left; // this return value must be a sum of a subarray bc this is the smallest value that satisfies the requirement that the whole array is split into m parts\\n    }\\n    \\n    private int split(int[] nums, int limit) {\\n        int n = nums.length;\\n        int count = 0;\\n        int subSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            subSum += nums[i];\\n            if (subSum > limit) {\\n                count++;\\n                subSum = nums[i];\\n            }\\n        }\\n        count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022392,
                "title": "python-easy-explanation-by-binary-search-dhruv-vavliya",
                "content": "```\\nWritten by : Dhruv vavliya\\n\\'\\'\\'\\nstatement : algorithm to minimize the largest sum among these m subarrays.\\n\\n1.  set low and high limits of ( minimum largest sum)\\n2.  condition for reaching to possible answer\\n\\nif subarrays are more than m ,then we need large (min large sum) ,left = mid+1\\n\\n\\'\\'\\'\\n\\ndef isvalid(nums,m,possible):    # verify possible subarrays by given sum\\n    subarrays = 1\\n    running = 0\\n\\n    for num in nums:\\n        running += num\\n        if running > possible:\\n            subarrays += 1\\n            running = num\\n    return subarrays <= m\\n\\ndef largest_sum(nums,m):\\n    low = max(nums)\\n    high = sum(nums)\\n\\n    while low <= high:\\n        possible = (low+high)//2\\n\\n        if isvalid(nums,m,possible):\\n            high = possible-1          # subarrays are less\\n        else:\\n            low = possible+1           # subarrays are more\\n    return low\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nWritten by : Dhruv vavliya\\n\\'\\'\\'\\nstatement : algorithm to minimize the largest sum among these m subarrays.\\n\\n1.  set low and high limits of ( minimum largest sum)\\n2.  condition for reaching to possible answer\\n\\nif subarrays are more than m ,then we need large (min large sum) ,left = mid+1\\n\\n\\'\\'\\'\\n\\ndef isvalid(nums,m,possible):    # verify possible subarrays by given sum\\n    subarrays = 1\\n    running = 0\\n\\n    for num in nums:\\n        running += num\\n        if running > possible:\\n            subarrays += 1\\n            running = num\\n    return subarrays <= m\\n\\ndef largest_sum(nums,m):\\n    low = max(nums)\\n    high = sum(nums)\\n\\n    while low <= high:\\n        possible = (low+high)//2\\n\\n        if isvalid(nums,m,possible):\\n            high = possible-1          # subarrays are less\\n        else:\\n            low = possible+1           # subarrays are more\\n    return low\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 936685,
                "title": "two-concise-java-solutions-using-dp-and-binary-search-beats-100",
                "content": "**Solution 1: DP (Time: O(m*n^2); Space: O(m*n))**\\n\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        int n = nums.length;\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int j = 1; j <= n; j++)\\n            dp[1][j] = dp[1][j-1] + nums[j-1]; // Increasing sum array\\n        \\n        for (int i = 2; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++)\\n            {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                // Suppose the first k numbers have been splitted into i-1 subarrays\\n                // We just need to check if the sum of the ith subarray is larger than the former subarrays or not\\n                for (int k = 1; k < j; k++)\\n                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i-1][k], dp[1][j] - dp[1][k]));\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```\\n\\n\\n**Solution 2: Binary Search (Time: O(n*logk) where k equals (sum-max), beats 100%; Space: O(1))**\\n\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        int sum = 0, max = 0;\\n        \\n        for (int num : nums)\\n        {\\n            sum += num;\\n            max = Math.max(max, num);\\n        }\\n        \\n        int left = max, right = sum;\\n        \\n        while (left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (valid(nums, m, mid))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    // Check if the numbers can be splitted into m subarrays and each subarray subSum <= target\\n    private boolean valid(int[] nums, int m, int target)\\n    {\\n        int subSum = 0, count = 0;\\n        \\n        for (int num : nums)\\n        {\\n            subSum += num;\\n            \\n            if (subSum > target)\\n            {\\n                count++;\\n                subSum = num;\\n                \\n                if (count > m)\\n                    return false;\\n            }\\n        }\\n        \\n        return (subSum > 0 && count == m) ? false : true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        int n = nums.length;\\n        int[][] dp = new int[m+1][n+1];\\n        \\n        for (int j = 1; j <= n; j++)\\n            dp[1][j] = dp[1][j-1] + nums[j-1]; // Increasing sum array\\n        \\n        for (int i = 2; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++)\\n            {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                // Suppose the first k numbers have been splitted into i-1 subarrays\\n                // We just need to check if the sum of the ith subarray is larger than the former subarrays or not\\n                for (int k = 1; k < j; k++)\\n                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i-1][k], dp[1][j] - dp[1][k]));\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        \\n        int sum = 0, max = 0;\\n        \\n        for (int num : nums)\\n        {\\n            sum += num;\\n            max = Math.max(max, num);\\n        }\\n        \\n        int left = max, right = sum;\\n        \\n        while (left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (valid(nums, m, mid))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    // Check if the numbers can be splitted into m subarrays and each subarray subSum <= target\\n    private boolean valid(int[] nums, int m, int target)\\n    {\\n        int subSum = 0, count = 0;\\n        \\n        for (int num : nums)\\n        {\\n            subSum += num;\\n            \\n            if (subSum > target)\\n            {\\n                count++;\\n                subSum = num;\\n                \\n                if (count > m)\\n                    return false;\\n            }\\n        }\\n        \\n        return (subSum > 0 && count == m) ? false : true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915570,
                "title": "binary-search-clean-code",
                "content": "\\n**Binary search can be apply in two cases**\\n \\n 1. either input array is sorted\\n 2. or in Range \\nso in this case we can say our answer in between { max_val, sum_val}\\nmax_val -> if k>=size of array\\nsum_val ->if k =1\\n\\nNow we need to apply Binary search is respect to range ->{max_val,sum_val} and find out optimal solution according to given K**\\nif  conditions are hold for Certain values then cheak it is valid for bigger value/smaller values ,if it is possible then compress your range \\n\\n{max_val,intermediate_val} or {intermediate_val, sum_val}\\n\\n\\n```\\n\\'class Solution {\\npublic:\\nint sol(long val,vector<int> &nums , int m)\\n {\\n        int count=1;\\n        long sm=0;\\n        for( int i=0 ; i< nums.size() ; i++)\\n        {\\n            sm+=nums[i];\\n            if(sm>val)\\n            {\\n                count++;sm=nums[i];\\n                if(count > m)\\n\\t\\t\\t\\t\\t\\treturn 0;\\n            }\\n}\\n        return 1;\\n}\\nint splitArray(vector<int>& nums, int m) {\\n\\t\\t\\tint n=nums.size() ,  mx=0;\\n\\t\\t\\tlong  sm=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t sm+=nums[i];\\n\\t\\t\\t\\t\\t if(nums[i]>mx)\\n\\t\\t\\t\\t\\t\\t   mx=nums[i];\\n\\t\\t  }\\n\\t\\t  if(m == 1)\\n\\t\\t\\t\\treturn (int)sm;\\n\\t\\t long l=mx,r=sm;\\n\\t\\t while(l<=r)\\n\\t\\t {\\n\\t\\t long  mid=l+ (r-l)/2;\\n\\t\\t if(sol(mid,nums,m))\\n               r=mid-1;\\n\\t\\telse\\n               l=mid+1;   \\n        }\\n\\t\\t\\treturn (int)l;\\n }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\'class Solution {\\npublic:\\nint sol(long val,vector<int> &nums , int m)\\n {\\n        int count=1;\\n        long sm=0;\\n        for( int i=0 ; i< nums.size() ; i++)\\n        {\\n            sm+=nums[i];\\n            if(sm>val)\\n            {\\n                count++;sm=nums[i];\\n                if(count > m)\\n\\t\\t\\t\\t\\t\\treturn 0;\\n            }\\n}\\n        return 1;\\n}\\nint splitArray(vector<int>& nums, int m) {\\n\\t\\t\\tint n=nums.size() ,  mx=0;\\n\\t\\t\\tlong  sm=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t sm+=nums[i];\\n\\t\\t\\t\\t\\t if(nums[i]>mx)\\n\\t\\t\\t\\t\\t\\t   mx=nums[i];\\n\\t\\t  }\\n\\t\\t  if(m == 1)\\n\\t\\t\\t\\treturn (int)sm;\\n\\t\\t long l=mx,r=sm;\\n\\t\\t while(l<=r)\\n\\t\\t {\\n\\t\\t long  mid=l+ (r-l)/2;\\n\\t\\t if(sol(mid,nums,m))\\n               r=mid-1;\\n\\t\\telse\\n               l=mid+1;   \\n        }\\n\\t\\t\\treturn (int)l;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842948,
                "title": "my-java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int left = Arrays.stream(nums).max().getAsInt();\\n        int right = total(nums);\\n        while (left < right) {\\n            int middle = left + (right-left) / 2;\\n            if (isLargestSum(middle, nums, m))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n        \\n    }\\n    public boolean isLargestSum(int middle, int [] nums, int m) {\\n        int split = 1;\\n        int largest = 0;\\n        for (int num: nums) {\\n            largest += num;\\n            if (largest > middle) {\\n                largest = num;\\n                split += 1;\\n                if (split > m) \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int total(int [] array) {\\n        int totalSum = 0;\\n        for (int n: array)\\n            totalSum += n;\\n        return totalSum;\\n    }\\n    \\n    }\\n```\\n\\nThis is same as the leetcode 1011 Problem- COnveyor belt. It uses the same template for the workspace and all other stuffs from this problem.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int left = Arrays.stream(nums).max().getAsInt();\\n        int right = total(nums);\\n        while (left < right) {\\n            int middle = left + (right-left) / 2;\\n            if (isLargestSum(middle, nums, m))\\n                right = middle;\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n        \\n    }\\n    public boolean isLargestSum(int middle, int [] nums, int m) {\\n        int split = 1;\\n        int largest = 0;\\n        for (int num: nums) {\\n            largest += num;\\n            if (largest > middle) {\\n                largest = num;\\n                split += 1;\\n                if (split > m) \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int total(int [] array) {\\n        int totalSum = 0;\\n        for (int n: array)\\n            totalSum += n;\\n        return totalSum;\\n    }\\n    \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842312,
                "title": "binary-search-o-log-sum-n-vs-o-log-sum-m-log-n",
                "content": "# 1.Dynamic Programming\\nidea: calculate the subarray from 0 to i using the subarray from 0 to i-1\\n\\n**time**: O(m*n^2), space: O(n)\\n```\\npublic int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int[] prefixSum = new int[n];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n\\t\\t// this array store the min largest sum from 0 to i split by k subarray\\n        int[] minLargestSum = new int[n];\\n\\t\\t// this is when k = 1, so the min largest sum is the prefixSum\\n        System.arraycopy(prefixSum, 0, minLargestSum, 0, n);\\n\\t\\t// continue for (m-1) rounds, every round we add a subarray, so the minLargestSum can be smaller\\n        for (int i = 1; i < m; i++) {\\n            // avoid overriding, use rolling array, calculate from back to front, because when we calculate the later elements, we will use the previous elements.\\n            for (int j = n-1; j >= 0; j--) {\\n                int minLargest = minLargestSum[j];\\n                for (int k = 0; k < j; k++)\\n                    minLargest = Math.min(minLargest, Math.max(minLargestSum[k], prefixSum[j] - prefixSum[k]));\\n                minLargestSum[j] = minLargest;\\n            }\\n        }\\n        return minLargestSum[n-1];\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/289ce1c4-ad38-4d29-ba7d-2d2f6b1e86e1_1599878074.9129772.png)\\n\\n# 2.Binary Search: O(n) check\\nwhen we seen such a description that \"minimize the largest xxx\", we should always think about binary search. In this problem, apparently the result would be monotonic, because if a smaller result can work, the greater result should work too, because we can always add more element to the subarray which has the largest sum to make it greater than before.\\n\\nidea: check the range from max number of the array to the sum of the array. and every check will cost O(n), because we will check the whole array every time.\\n\\n**time**: O(log(sum)*n), space: O(1)\\n\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int maxNumber = 0, arraySum = 0;\\n        for (int i : nums) {\\n            maxNumber = Math.max(maxNumber, i);\\n            arraySum += i;\\n        }\\n        int l = maxNumber, r = arraySum;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(nums, m, mid))\\n                r = mid;\\n            else // if not satisfied, then mid is too small, we need enlarge our l\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    /**\\n     * check if satisfied, cost O(n)\\n     */\\n    private boolean check(int[] nums, int m, int s) {\\n        int i = 0, k = 0;\\n        while (i < nums.length && k < m) {\\n            int sum = 0;\\n            while (i < nums.length && sum + nums[i] <= s)\\n                sum += nums[i++];\\n            k++;\\n        }\\n        return i == nums.length;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ebd892d5-ad4d-4482-b7e7-7a533da403b7_1599878576.6938374.png)\\n\\n\\n# 3.Binary Search: O(mlog(n)) check\\n**Follow up**: now think about the question, \"what if n is much greater than m\"\\nDon\\'t forget the prefixSum is also a monotonic array, because the array consists of non-negative integers. So, we can also use binary search to check if the result is satisfied.\\n\\n**time**: O(log(sum)\\\\*m*log(n)), space: O(n)\\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int[] prefixSum = new int[nums.length + 1];\\n        int maxNumber = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            maxNumber = Math.max(maxNumber, nums[i]);\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n        int l = maxNumber, r = prefixSum[nums.length];\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(prefixSum, m, mid))\\n                r = mid;\\n            else // if not satisfied, then mid is too small, we need enlarge our l\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    /**\\n     * this check cost O(mlog(n))\\n     */\\n    private boolean check(int[] prefixSum, int m, int s) {\\n        int i = 1, k = 0;\\n        while (i < prefixSum.length && k < m) {\\n            i = getIndex(prefixSum, i, prefixSum[i-1] + s);\\n            k++;\\n        }\\n        return i == prefixSum.length;\\n    }\\n    /**\\n     * return the smallest index+1(next index) such that the sum of subarray is greater than s\\n     */\\n    private int getIndex(int[] prefixSum, int i, int s) {\\n        int l = i, r = prefixSum.length;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            // we want to find the smallest greater than s\\n            if (prefixSum[m] > s)\\n                r = m;\\n            else\\n                l = m + 1;\\n        }\\n        // l is the next index\\n        return l;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/aa4e18c9-08fd-4b5a-a581-238ea90fafb7_1599879122.7599998.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int[] prefixSum = new int[n];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n\\t\\t// this array store the min largest sum from 0 to i split by k subarray\\n        int[] minLargestSum = new int[n];\\n\\t\\t// this is when k = 1, so the min largest sum is the prefixSum\\n        System.arraycopy(prefixSum, 0, minLargestSum, 0, n);\\n\\t\\t// continue for (m-1) rounds, every round we add a subarray, so the minLargestSum can be smaller\\n        for (int i = 1; i < m; i++) {\\n            // avoid overriding, use rolling array, calculate from back to front, because when we calculate the later elements, we will use the previous elements.\\n            for (int j = n-1; j >= 0; j--) {\\n                int minLargest = minLargestSum[j];\\n                for (int k = 0; k < j; k++)\\n                    minLargest = Math.min(minLargest, Math.max(minLargestSum[k], prefixSum[j] - prefixSum[k]));\\n                minLargestSum[j] = minLargest;\\n            }\\n        }\\n        return minLargestSum[n-1];\\n    }\\n```\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int maxNumber = 0, arraySum = 0;\\n        for (int i : nums) {\\n            maxNumber = Math.max(maxNumber, i);\\n            arraySum += i;\\n        }\\n        int l = maxNumber, r = arraySum;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(nums, m, mid))\\n                r = mid;\\n            else // if not satisfied, then mid is too small, we need enlarge our l\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    /**\\n     * check if satisfied, cost O(n)\\n     */\\n    private boolean check(int[] nums, int m, int s) {\\n        int i = 0, k = 0;\\n        while (i < nums.length && k < m) {\\n            int sum = 0;\\n            while (i < nums.length && sum + nums[i] <= s)\\n                sum += nums[i++];\\n            k++;\\n        }\\n        return i == nums.length;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int[] prefixSum = new int[nums.length + 1];\\n        int maxNumber = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            maxNumber = Math.max(maxNumber, nums[i]);\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n        int l = maxNumber, r = prefixSum[nums.length];\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (check(prefixSum, m, mid))\\n                r = mid;\\n            else // if not satisfied, then mid is too small, we need enlarge our l\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    /**\\n     * this check cost O(mlog(n))\\n     */\\n    private boolean check(int[] prefixSum, int m, int s) {\\n        int i = 1, k = 0;\\n        while (i < prefixSum.length && k < m) {\\n            i = getIndex(prefixSum, i, prefixSum[i-1] + s);\\n            k++;\\n        }\\n        return i == prefixSum.length;\\n    }\\n    /**\\n     * return the smallest index+1(next index) such that the sum of subarray is greater than s\\n     */\\n    private int getIndex(int[] prefixSum, int i, int s) {\\n        int l = i, r = prefixSum.length;\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            // we want to find the smallest greater than s\\n            if (prefixSum[m] > s)\\n                r = m;\\n            else\\n                l = m + 1;\\n        }\\n        // l is the next index\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841275,
                "title": "java-easy-dp-solution-with-comment",
                "content": "class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int[] S = new int[n+1]; // for spliting array\\n        S[0] = 0; \\n        for (int i =0;i < n;i++)\\n        {\\n            S[i+1] = S[i] + nums[i]; // adding number in subarray S\\n        }\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        for (int i =0; i<=m;i++)\\n        {\\n            for (int j =0;j<=n;j++)\\n                dp[i][j] = Integer.MAX_VALUE;  // intialize with maxvalue\\n        }\\n        \\n      dp[0][0] = 0;  \\n        for (int i =1;i <= m ;i++)\\n        {\\n            for (int j=1; j<= n;j++)\\n            {\\n               for (int k = 0; k < j; ++k)\\n                dp[i][j] = Math.min(dp[i][j], Math.max(S[j] - S[k], dp[i - 1][k]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int[] S = new int[n+1]; // for spliting array\\n        S[0] = 0; \\n        for (int i =0;i < n;i++)\\n        {\\n            S[i+1] = S[i] + nums[i]; // adding number in subarray S\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 722500,
                "title": "0-ms-cpp-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int>& nums,int mid,int m){\\n        long long sum=0;\\n        int array = 1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum>mid){\\n                sum=nums[i];\\n                array++;\\n            }\\n        }\\n        if(array<=m)\\n            return true;\\n        else\\n            return false;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        long long sum = 0;\\n        for(auto i:nums)\\n            sum+=i;\\n        long long start = *max_element(nums.begin(),nums.end());\\n        long long end = sum;\\n        long long res = -1;\\n        while(start<=end){\\n            long long mid = start+(end-start)/2;\\n            \\n            if(isvalid(nums,mid,m)==true){\\n                res=mid;\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**credit :- Thanks to Aditya Verma**\\n**youtube :-** https://www.youtube.com/channel/UC5WO7o71wvxMxEtLRkPhiQQ",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int>& nums,int mid,int m){\\n        long long sum=0;\\n        int array = 1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum>mid){\\n                sum=nums[i];\\n                array++;\\n            }\\n        }\\n        if(array<=m)\\n            return true;\\n        else\\n            return false;\\n    }\\n    int splitArray(vector<int>& nums, int m) {\\n        long long sum = 0;\\n        for(auto i:nums)\\n            sum+=i;\\n        long long start = *max_element(nums.begin(),nums.end());\\n        long long end = sum;\\n        long long res = -1;\\n        while(start<=end){\\n            long long mid = start+(end-start)/2;\\n            \\n            if(isvalid(nums,mid,m)==true){\\n                res=mid;\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679778,
                "title": "c-o-nlogn-solution-with-simple-explanation",
                "content": "1. At first we will calculate the total sum of the elements.\\n2. We will binary search from 1 to sum in order to find the minimum sum that satisfies the result.\\n3. For every mid value we will count the number of contigeous subarrays which have the subarray sum <= mid.\\n4. remember, we cannot split the array less than count times to get mid as minized subarray sum.\\n5. if count greater than m, then we must need to split the array at least count times to get mid as maximum sum and we cannot do it as the upper bound of spliting is m. in this case we cannot split the array less count times.\\n6. if count is less than or equal to m then it satiesfies the condition. remeber we can split the the array into more than count parts, but not less than the counts parts.\\n\\n```\\nclass Solution {\\n    bool bs(vector<int>&nums, long long mid, long long n,int m)\\n    {\\n        long long sum=0;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>mid)\\n                return false;\\n            sum+=nums[i];\\n            if(sum>mid)\\n            {\\n                sum = nums[i];\\n                cnt++;\\n            }\\n        }\\n        cnt++;\\n        if(cnt<=m)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        long long sum=0, n= nums.size();\\n        for(auto it: nums)\\n            sum+=it;\\n        long long lo=1,hi = sum;\\n        int ans;\\n        while(lo<=hi)\\n        {\\n            long long mid = lo+(hi-lo)/2;\\n            if(bs(nums,mid,n,m))\\n            {\\n                ans =mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool bs(vector<int>&nums, long long mid, long long n,int m)\\n    {\\n        long long sum=0;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>mid)\\n                return false;\\n            sum+=nums[i];\\n            if(sum>mid)\\n            {\\n                sum = nums[i];\\n                cnt++;\\n            }\\n        }\\n        cnt++;\\n        if(cnt<=m)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        long long sum=0, n= nums.size();\\n        for(auto it: nums)\\n            sum+=it;\\n        long long lo=1,hi = sum;\\n        int ans;\\n        while(lo<=hi)\\n        {\\n            long long mid = lo+(hi-lo)/2;\\n            if(bs(nums,mid,n,m))\\n            {\\n                ans =mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574760,
                "title": "java-binary-search-solution-beats-100-runtime-with-explanation-example",
                "content": "```\\nclass Solution {\\n    long minSum = Integer.MIN_VALUE, maxSum = 0, len;\\n    public int splitArray(int[] nums, int m) {\\n        init(nums);\\n        while (minSum <= maxSum) {\\n            long mid = (minSum + maxSum)/2;\\n            if (isSetCountLesserOrEqualThanMid(mid, nums, m)) maxSum = mid-1;\\n            else minSum = mid+1;\\n        }\\n        return (int) minSum;\\n    }\\n    \\n    /* The function calculates number of sets in the array, such than each of them have sum <= mid.\\n    If the count is higher than \\'m\\', means the target sum (i.e. given mid) is too low. \\n    We need to increase the target sum by doing => minSum = mid+1. \\n    This is done so that each set would contain more numbers, which will reduce the number of sets.\\n    On the other hand, if the count is lower than \\'m\\', means the target sum is too high and we need to lower it by doing => maxSum = mid-1;\\n    */\\n    public boolean isSetCountLesserOrEqualThanMid(long mid, int[] nums, int m) {\\n        int count = 1;\\n        long sum = 0;\\n        for(int i=0; i<len; i++) {\\n            sum += nums[i];\\n            if (sum > mid) {\\n                sum = nums[i];\\n                count++;\\n                // If count is greater than given \\'m\\', means the mid is too low. Raise the minSum.\\n                // Else Lower the maxSum.\\n                if (count > m) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    /* Initialize min and max sum */\\n    void init(int[] nums) {\\n        len = nums.length;\\n        for (int i=0; i<len; i++) {\\n            maxSum += nums[i];\\n            minSum = nums[i] > minSum ? nums[i] : minSum;\\n        }\\n    }\\n    \\n    /* EXAMPLE: [7, 2, 5, 10, 8]. \\n    minSum = 10 (highest number in the set)\\n    maxSum = 32 (total of all the numbers)\\n    \\n    1) minSum = 10, maxSum = 32\\n    mid = (10 + 32)/2 = 21.\\n    Sets => [7, 2, 5], [10, 8]. Total count = 2.  (NOTE: each set has sum <= mid).\\n    Now, since the (count = 2) <= (m = 2) => maxSum = (mid = 21) -1 = 20.\\n    \\n    2) minSum = 10, maxSum = 20\\n    mid = 15.\\n    Sets => [7, 2, 5], [10], [8]. Total count = 3.\\n    Now, since the (count = 3) > (m = 2). => minSum = (mid = 15) + 1 = 16.\\n    \\n    3) minSum = 16, maxSum = 20\\n    mid = 18.\\n    Sets => [7, 2, 5], [10, 8]. Total count = 1.\\n    Now, since the (count = 2) <= (m = 2). => maxSum = (mid = 18) - 1 = 16.\\n    */\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    long minSum = Integer.MIN_VALUE, maxSum = 0, len;\\n    public int splitArray(int[] nums, int m) {\\n        init(nums);\\n        while (minSum <= maxSum) {\\n            long mid = (minSum + maxSum)/2;\\n            if (isSetCountLesserOrEqualThanMid(mid, nums, m)) maxSum = mid-1;\\n            else minSum = mid+1;\\n        }\\n        return (int) minSum;\\n    }\\n    \\n    /* The function calculates number of sets in the array, such than each of them have sum <= mid.\\n    If the count is higher than \\'m\\', means the target sum (i.e. given mid) is too low. \\n    We need to increase the target sum by doing => minSum = mid+1. \\n    This is done so that each set would contain more numbers, which will reduce the number of sets.\\n    On the other hand, if the count is lower than \\'m\\', means the target sum is too high and we need to lower it by doing => maxSum = mid-1;\\n    */\\n    public boolean isSetCountLesserOrEqualThanMid(long mid, int[] nums, int m) {\\n        int count = 1;\\n        long sum = 0;\\n        for(int i=0; i<len; i++) {\\n            sum += nums[i];\\n            if (sum > mid) {\\n                sum = nums[i];\\n                count++;\\n                // If count is greater than given \\'m\\', means the mid is too low. Raise the minSum.\\n                // Else Lower the maxSum.\\n                if (count > m) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    /* Initialize min and max sum */\\n    void init(int[] nums) {\\n        len = nums.length;\\n        for (int i=0; i<len; i++) {\\n            maxSum += nums[i];\\n            minSum = nums[i] > minSum ? nums[i] : minSum;\\n        }\\n    }\\n    \\n    /* EXAMPLE: [7, 2, 5, 10, 8]. \\n    minSum = 10 (highest number in the set)\\n    maxSum = 32 (total of all the numbers)\\n    \\n    1) minSum = 10, maxSum = 32\\n    mid = (10 + 32)/2 = 21.\\n    Sets => [7, 2, 5], [10, 8]. Total count = 2.  (NOTE: each set has sum <= mid).\\n    Now, since the (count = 2) <= (m = 2) => maxSum = (mid = 21) -1 = 20.\\n    \\n    2) minSum = 10, maxSum = 20\\n    mid = 15.\\n    Sets => [7, 2, 5], [10], [8]. Total count = 3.\\n    Now, since the (count = 3) > (m = 2). => minSum = (mid = 15) + 1 = 16.\\n    \\n    3) minSum = 16, maxSum = 20\\n    mid = 18.\\n    Sets => [7, 2, 5], [10, 8]. Total count = 1.\\n    Now, since the (count = 2) <= (m = 2). => maxSum = (mid = 18) - 1 = 16.\\n    */\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497833,
                "title": "python-3-7-lines-simplified-with-explanation",
                "content": "Solution with inline explaination\\n```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        lo, hi = max(nums), sum(nums)\\n        # We need to find low from max of the numbers and high from sum of the numbers\\n        # and we now try to search for the right sum for our partitions\\n        while lo < hi:\\n            mid, sm, cnt = lo + (hi-lo)//2, 0, 1\\n            # print(lo, mid, hi)\\n            for n in nums:\\n                sm, cnt = (n,cnt+1) if sm+n>mid else (sm+n,cnt)\\n                # Our goal for this loop is not to sum but to count how many partitions \\n                # we can make with subarrays which have sum less than mid.\\n                # If we are making more than m partitions that means our max sum should be higher\\n                # as we are making too many partitions,and vice versa.\\n                # With each step we get closer to our sum\\n                # print(\"->\", n, cnt, sm, mid)    \\n            \\n            lo, hi = (mid+1,hi) if cnt>m else (lo,mid)\\n        # print(lo, hi)\\n        # lo represents the max sum of subarray and hi represents total sum of subarray\\n        # eventually due to our exit condition we will end up with lo == hi to exit\\n        # So it would not matter even if your return hi\\n        return lo\\n```\\n\\n7 lines without explaination\\n```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        lo, hi = max(nums), sum(nums)\\n        while lo < hi:\\n            mid, sm, cnt = lo + (hi-lo)//2, 0, 1\\n            for n in nums:\\n                sm, cnt = (n,cnt+1) if sm+n>mid else (sm+n,cnt)\\n            lo, hi = (mid+1,hi) if cnt>m else (lo,mid)\\n        return lo\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        lo, hi = max(nums), sum(nums)\\n        # We need to find low from max of the numbers and high from sum of the numbers\\n        # and we now try to search for the right sum for our partitions\\n        while lo < hi:\\n            mid, sm, cnt = lo + (hi-lo)//2, 0, 1\\n            # print(lo, mid, hi)\\n            for n in nums:\\n                sm, cnt = (n,cnt+1) if sm+n>mid else (sm+n,cnt)\\n                # Our goal for this loop is not to sum but to count how many partitions \\n                # we can make with subarrays which have sum less than mid.\\n                # If we are making more than m partitions that means our max sum should be higher\\n                # as we are making too many partitions,and vice versa.\\n                # With each step we get closer to our sum\\n                # print(\"->\", n, cnt, sm, mid)    \\n            \\n            lo, hi = (mid+1,hi) if cnt>m else (lo,mid)\\n        # print(lo, hi)\\n        # lo represents the max sum of subarray and hi represents total sum of subarray\\n        # eventually due to our exit condition we will end up with lo == hi to exit\\n        # So it would not matter even if your return hi\\n        return lo\\n```\n```python\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        lo, hi = max(nums), sum(nums)\\n        while lo < hi:\\n            mid, sm, cnt = lo + (hi-lo)//2, 0, 1\\n            for n in nums:\\n                sm, cnt = (n,cnt+1) if sm+n>mid else (sm+n,cnt)\\n            lo, hi = (mid+1,hi) if cnt>m else (lo,mid)\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453026,
                "title": "binary-search-javascript-easy-to-understand",
                "content": "\\n```\\nvar splitArray = function(nums, m) {\\n    let min = 0; // the smallest element in the array\\n    let max = 0; // the total cumulative sum of array\\n    for (const num of nums) {\\n        min = Math.min(min, num);\\n        max += num;\\n    }\\n    let ans = max;\\n    while (min <= max) {\\n        let mid = Math.floor(min + (max - min) / 2);\\n        let tempRes = divideGroups(nums, mid);\\n        if (tempRes[0] <= m) {\\n            if (tempRes[0] === m) ans = Math.min(ans, tempRes[1])\\n            max = mid - 1;\\n        } else {\\n            min = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\n// divide into groups so that each contingous subarray sum does not exceed mid\\n// return [count, maxSum]\\nfunction divideGroups(nums, mid) {\\n    let cnt = 1;\\n    let maxSum = 0;\\n    let sum = 0;\\n    for (const num of nums) {\\n        if (sum + num > mid) {\\n            cnt++;\\n            maxSum = Math.max(maxSum, sum);\\n            sum = num;\\n        } else {\\n            sum += num;\\n        }\\n    }\\n    return [cnt, Math.max(maxSum, sum)];\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nvar splitArray = function(nums, m) {\\n    let min = 0; // the smallest element in the array\\n    let max = 0; // the total cumulative sum of array\\n    for (const num of nums) {\\n        min = Math.min(min, num);\\n        max += num;\\n    }\\n    let ans = max;\\n    while (min <= max) {\\n        let mid = Math.floor(min + (max - min) / 2);\\n        let tempRes = divideGroups(nums, mid);\\n        if (tempRes[0] <= m) {\\n            if (tempRes[0] === m) ans = Math.min(ans, tempRes[1])\\n            max = mid - 1;\\n        } else {\\n            min = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\n// divide into groups so that each contingous subarray sum does not exceed mid\\n// return [count, maxSum]\\nfunction divideGroups(nums, mid) {\\n    let cnt = 1;\\n    let maxSum = 0;\\n    let sum = 0;\\n    for (const num of nums) {\\n        if (sum + num > mid) {\\n            cnt++;\\n            maxSum = Math.max(maxSum, sum);\\n            sum = num;\\n        } else {\\n            sum += num;\\n        }\\n    }\\n    return [cnt, Math.max(maxSum, sum)];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451467,
                "title": "python-binary-search-method",
                "content": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        lo = max(nums) #the lowest possible maxsum of a subarray \\n        hi = sum(nums) #the highest possible maxsum of a subarray\\n        \\n        #binary search\\n        \\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            tmpsum = 0\\n            count = 1\\n            for num in nums:\\n                tmpsum += num\\n                if tmpsum > mid:\\n                    tmpsum = num\\n                    count += 1\\n            if count > m:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitArray(self, nums: List[int], m: int) -> int:\\n        lo = max(nums) #the lowest possible maxsum of a subarray \\n        hi = sum(nums) #the highest possible maxsum of a subarray\\n        \\n        #binary search\\n        \\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            tmpsum = 0\\n            count = 1\\n            for num in nums:\\n                tmpsum += num\\n                if tmpsum > mid:\\n                    tmpsum = num\\n                    count += 1\\n            if count > m:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo",
                "codeTag": "Java"
            },
            {
                "id": 373543,
                "title": "java-solution-concise-and-beat-100-with-comments",
                "content": "```Java\\npublic int splitArray(int[] nums, int m) {\\n\\t// binarySearch\\n\\tint l = 1, r = Integer.MAX_VALUE;\\n\\twhile (l < r) {\\n\\t\\t// mi: middle\\n\\t\\tint mi = (r - l) / 2 + l;\\n\\t\\t// if true, middle is acceptable, set right to middle;\\n\\t\\tif (possible(nums, m, mi))\\n\\t\\t\\tr = mi;\\n\\t\\t// if false, middle is unacceptable, set left to middle + 1;\\n\\t\\telse\\n\\t\\t\\tl = mi + 1;\\n\\t}\\n\\treturn l;\\n}\\n\\n// check whether suggested group sum is possible \\nprivate boolean possible(int[] nums, int targetCnt, int targetSum) {\\n\\t// curSum: current group sum\\n\\t// set initial current group sum to sum for concise code\\n\\tint curSum = targetSum, groupNum = 0;\\n\\tfor (int num :\\n\\t\\t\\tnums) {\\n\\t\\t// if current num is bigger than target sum, failed anyway\\n\\t\\tif (num > targetSum) return false;\\n\\t\\tcurSum += num;\\n\\t\\t// if curSum bigger than target sum, groupNumber++ and set current sum to num\\n\\t\\tif (curSum > targetSum) {\\n\\t\\t\\tcurSum = num;\\n\\t\\t\\tgroupNum++;\\n\\t\\t}\\n\\t\\t// fail if group number bigger than target group count\\n\\t\\tif (groupNum > targetCnt) return false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\npublic int splitArray(int[] nums, int m) {\\n\\t// binarySearch\\n\\tint l = 1, r = Integer.MAX_VALUE;\\n\\twhile (l < r) {\\n\\t\\t// mi: middle\\n\\t\\tint mi = (r - l) / 2 + l;\\n\\t\\t// if true, middle is acceptable, set right to middle;\\n\\t\\tif (possible(nums, m, mi))\\n\\t\\t\\tr = mi;\\n\\t\\t// if false, middle is unacceptable, set left to middle + 1;\\n\\t\\telse\\n\\t\\t\\tl = mi + 1;\\n\\t}\\n\\treturn l;\\n}\\n\\n// check whether suggested group sum is possible \\nprivate boolean possible(int[] nums, int targetCnt, int targetSum) {\\n\\t// curSum: current group sum\\n\\t// set initial current group sum to sum for concise code\\n\\tint curSum = targetSum, groupNum = 0;\\n\\tfor (int num :\\n\\t\\t\\tnums) {\\n\\t\\t// if current num is bigger than target sum, failed anyway\\n\\t\\tif (num > targetSum) return false;\\n\\t\\tcurSum += num;\\n\\t\\t// if curSum bigger than target sum, groupNumber++ and set current sum to num\\n\\t\\tif (curSum > targetSum) {\\n\\t\\t\\tcurSum = num;\\n\\t\\t\\tgroupNum++;\\n\\t\\t}\\n\\t\\t// fail if group number bigger than target group count\\n\\t\\tif (groupNum > targetCnt) return false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368174,
                "title": "go-binary-search-solution",
                "content": "```\\nfunc splitArray(nums []int, m int) int {\\n\\tvar max, sum int\\n\\tfor _, n := range nums {\\n\\t\\tsum += n\\n\\t\\tif n > max {\\n\\t\\t\\tmax = n\\n\\t\\t}\\n\\t}\\n\\tif m == 1 {\\n\\t\\treturn sum\\n\\t}\\n\\n\\tleft, right := max, sum\\n\\tfor left <= right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\tif helper(mid, m, nums) {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn left\\n}\\n\\nfunc helper(target, m int, nums []int) bool {\\n\\tvar sum int\\n\\tcount := 1\\n\\tfor _, n := range nums {\\n\\t\\tsum += n\\n\\t\\tif sum > target {\\n\\t\\t\\tsum = n\\n\\t\\t\\tcount++\\n\\t\\t\\tif count > m {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc splitArray(nums []int, m int) int {\\n\\tvar max, sum int\\n\\tfor _, n := range nums {\\n\\t\\tsum += n\\n\\t\\tif n > max {\\n\\t\\t\\tmax = n\\n\\t\\t}\\n\\t}\\n\\tif m == 1 {\\n\\t\\treturn sum\\n\\t}\\n\\n\\tleft, right := max, sum\\n\\tfor left <= right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\tif helper(mid, m, nums) {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn left\\n}\\n\\nfunc helper(target, m int, nums []int) bool {\\n\\tvar sum int\\n\\tcount := 1\\n\\tfor _, n := range nums {\\n\\t\\tsum += n\\n\\t\\tif sum > target {\\n\\t\\t\\tsum = n\\n\\t\\t\\tcount++\\n\\t\\t\\tif count > m {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353729,
                "title": "using-easy-understanding-dp-to-solve-this-problem-in-java",
                "content": "https://medium.com/@null00/leetcode-split-array-largest-sum-d993d7e72138\\n\\n```\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int[] S = new int[n + 1];\\n        S[0] = 0;\\n        for (int i = 1; i <= n; ++i)\\n            S[i] = S[i - 1] + nums[i - 1];\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = 0; i <= m; ++i)\\n            for (int j = 0; j <= n; ++j)\\n                dp[i][j] = Integer.MAX_VALUE;\\n\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= m; ++i)\\n            for (int j = 1; j <= n; ++j)\\n                for (int k = 0; k < j; ++k)\\n                    dp[i][j] = Math.min(dp[i][j], Math.max(S[j] - S[k], dp[i - 1][k]));\\n\\n        return dp[m][n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int splitArray(int[] nums, int m) {\\n        int n = nums.length;\\n        int[] S = new int[n + 1];\\n        S[0] = 0;\\n        for (int i = 1; i <= n; ++i)\\n            S[i] = S[i - 1] + nums[i - 1];\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = 0; i <= m; ++i)\\n            for (int j = 0; j <= n; ++j)\\n                dp[i][j] = Integer.MAX_VALUE;\\n\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= m; ++i)\\n            for (int j = 1; j <= n; ++j)\\n                for (int k = 0; k < j; ++k)\\n                    dp[i][j] = Math.min(dp[i][j], Math.max(S[j] - S[k], dp[i - 1][k]));\\n\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180585,
                "title": "python-binary-search-beat-100",
                "content": "\\n```\\n# -*- coding: utf-8 -*-\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        L, R = 0, sum(nums) + 1\\n\\n        ans = 0\\n        while L < R:\\n            mid = (L + R) / 2\\n            if self.guess(mid, nums, m):\\n                ans = mid\\n                R = mid\\n            else:\\n                L = mid + 1\\n        return ans\\n\\n    @staticmethod\\n    def guess(mid, nums, m):\\n        sum = 0\\n        for i in range(0, len(nums)):\\n            if sum + nums[i] > mid:\\n                m -= 1\\n                sum = nums[i]\\n                if nums[i] > mid:\\n                    return False\\n            else:\\n                sum += nums[i]\\n        return m >= 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# -*- coding: utf-8 -*-\\nclass Solution(object):\\n    def splitArray(self, nums, m):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type m: int\\n        :rtype: int\\n        \"\"\"\\n        L, R = 0, sum(nums) + 1\\n\\n        ans = 0\\n        while L < R:\\n            mid = (L + R) / 2\\n            if self.guess(mid, nums, m):\\n                ans = mid\\n                R = mid\\n            else:\\n                L = mid + 1\\n        return ans\\n\\n    @staticmethod\\n    def guess(mid, nums, m):\\n        sum = 0\\n        for i in range(0, len(nums)):\\n            if sum + nums[i] > mid:\\n                m -= 1\\n                sum = nums[i]\\n                if nums[i] > mid:\\n                    return False\\n            else:\\n                sum += nums[i]\\n        return m >= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 89843,
                "title": "clear-and-easy-method-using-dp-in-c",
                "content": "```\\n// The method, in DP idea, costs lots of time, but the logic is very eary and clear.\\n//\\u7528\\u65f6\\u86ee\\u957f\\u7684\\uff0c\\u4f46\\u601d\\u8def\\u6bd4\\u8f83\\u6e05\\u6670 \\n// f[m][i] means if we could split the array [0, i] in m subarray, the minimal value of the largest sum among these m subarrays we could get.\\n//f[m][i]\\u8868\\u793am\\u5200\\uff0c\\u5728[0, i]\\u7684\\u6700\\u5c0f\\u5316subarray\\u7684\\u6700\\u5927\\u503c\\n// Then, f[m][i] = min (maxf[m-1][j], sum(nums[from j + 1 to i])), where j = [0, i - 1];\\n//\\u9012\\u5f52\\u5f0f\\u5b50\\uff1af[m][i] = min(max(f[m-1][j], sum(nums[j+1 - i])) \\u5176\\u4e2d\\uff0cj = [0, i - 1];\\n// The complexity is O(n^3)\\n//\\u8fd9\\u6837\\u5904\\u7406\\u7684\\u8bdd\\uff0c\\u5c31\\u662f\\u4e09\\u91cd\\u5faa\\u73af\\u4e86\\n\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int len = nums.size();\\n        vector<vector<long>> arr(m, vector<long>(len, 0));\\n        arr[0][0] = nums[0];\\n        for(int i = 1; i<len; i++)\\n        {\\n            arr[0][i] = arr[0][i - 1] + nums[i];\\n        }\\n        \\n        for(int k = 1; k<m; k++)\\n        {\\n            for(int i = 0; i<len; i++)\\n            {\\n                long minVal = arr[0][i];\\n                for(int j = i-1; j>= 0; j--)\\n                {\\n                    long tmpVal = max(arr[0][i] - arr[0][j], arr[k - 1][j]);\\n                    minVal = min(minVal, tmpVal);\\n                }\\n                arr[k][i] = minVal;\\n            }\\n        }\\n        return arr[m-1][len - 1];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// The method, in DP idea, costs lots of time, but the logic is very eary and clear.\\n//\\u7528\\u65f6\\u86ee\\u957f\\u7684\\uff0c\\u4f46\\u601d\\u8def\\u6bd4\\u8f83\\u6e05\\u6670 \\n// f[m][i] means if we could split the array [0, i] in m subarray, the minimal value of the largest sum among these m subarrays we could get.\\n//f[m][i]\\u8868\\u793am\\u5200\\uff0c\\u5728[0, i]\\u7684\\u6700\\u5c0f\\u5316subarray\\u7684\\u6700\\u5927\\u503c\\n// Then, f[m][i] = min (maxf[m-1][j], sum(nums[from j + 1 to i])), where j = [0, i - 1];\\n//\\u9012\\u5f52\\u5f0f\\u5b50\\uff1af[m][i] = min(max(f[m-1][j], sum(nums[j+1 - i])) \\u5176\\u4e2d\\uff0cj = [0, i - 1];\\n// The complexity is O(n^3)\\n//\\u8fd9\\u6837\\u5904\\u7406\\u7684\\u8bdd\\uff0c\\u5c31\\u662f\\u4e09\\u91cd\\u5faa\\u73af\\u4e86\\n\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int m) {\\n        int len = nums.size();\\n        vector<vector<long>> arr(m, vector<long>(len, 0));\\n        arr[0][0] = nums[0];\\n        for(int i = 1; i<len; i++)\\n        {\\n            arr[0][i] = arr[0][i - 1] + nums[i];\\n        }\\n        \\n        for(int k = 1; k<m; k++)\\n        {\\n            for(int i = 0; i<len; i++)\\n            {\\n                long minVal = arr[0][i];\\n                for(int j = i-1; j>= 0; j--)\\n                {\\n                    long tmpVal = max(arr[0][i] - arr[0][j], arr[k - 1][j]);\\n                    minVal = min(minVal, tmpVal);\\n                }\\n                arr[k][i] = minVal;\\n            }\\n        }\\n        return arr[m-1][len - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1667920,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1574462,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1569599,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1567975,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1827057,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1567114,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1745873,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1574324,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1569951,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1571686,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1667920,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1574462,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1569599,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1567975,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1827057,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1567114,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1745873,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1574324,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1569951,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 1571686,
                "content": [
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/ to solve this problem."
                    },
                    {
                        "username": "0jaehunny0",
                        "content": "Yeah... the two problems are almost the same"
                    },
                    {
                        "username": "destroyer08",
                        "content": "I faced one question in an interview where problem statement was almost same but instead of taking sum of each partition you have to take maximum number from each partition and then minimize their sum.\\n\\nEx. nums = [7,2,5,10,8], m = 2\\n\\nIt may have 2 valid partitions [7,2,5] and [10,8] and answer would be 7+10=17 (which is minimum with m=2 partitions).\\n\\n[7] and [2,5,10,8] is also a valid partition because answer is still 17 in this case. \\n\\nPlease help if anyone knows the problem in leetcode or approach."
                    },
                    {
                        "username": "kentonkim1218",
                        "content": "There was literally one video that popped up when searching for this problem. It's kind of a brute force approach that you can optimize with DP. \n\nGiven an array of length n and number of subarrays k, we loop through all the possible places where the first partition can be made. This will be from the first index to index n-k. Any further and we will not be able to make k partitions.\n\nFor example,\narray = [7, 2, 5, 10, 8, 0, 4] n = 7, k = 3\n\nThe furthest place the first partition can be is after 8, index 4.\n\nFor each iteration, we will find the maximum value of the subarray on the left side of the partition and add it with the minimized sum of maximums of each subarray within the right side subarray. To clarify, we recursively call the function on the right subarray with one less partition (k - 1 subarrays within the right side). The base case is when k = 1 where you would just return the maximum value of the array/subarray. Then, we get return minimum of all possible sums from the iterations.\n\nVideo probably explains better, but thanks for reading anyways.\n\nYoutube link:\nhttps://www.youtube.com/watch?v=QQsyiNNEp1g&t=630s\n\nMy attempt:\n\ndef minSumMax(nums, k: int) -> int:\n    # Assume k <= len(nums)\n    # Call to max(array) can be optimized\n    # Slicing array can be optimized\n    def opt(start, parts):\n        if parts == 1:\n            return max(nums[start::])\n        ans = 10000 # Some arbitrarily high number\n        for i in range(start, len(nums) - parts + 1):\n            ans = min(ans, max(nums[start:i+1]) + opt(i+1, parts - 1))\n        return ans\n    return opt(0,k)\n\nI did not have to reverse the array and min both fxn calls like he did at the end"
                    },
                    {
                        "username": "msanthoshofficial",
                        "content": "If we can find min possible value and max possible value then this is just the same question\\n"
                    },
                    {
                        "username": "atharva598",
                        "content": "sounds like a nice twist on this problem. One heuristic is that we would try to group all large numbers in one partition, since this would reduce the sum taken."
                    },
                    {
                        "username": "rvpk",
                        "content": "\\nExample, if we split the array into 2 subarray like the below, then we can max sub array total as 25.\\n[7,2,5,10,8] ==> [7], [2,5,10,10,8]\\nSo, whta does \"minimize the largest sum among these m subarrays\"  mean ?"
                    },
                    {
                        "username": "Robin_Kumar_rk",
                        "content": "[@jo_yang](/jo_yang) Because of you, I understood the question. Before this I have read the problem on different platforms but I didn\\'t understand."
                    },
                    {
                        "username": "risingstar92",
                        "content": "[@AkhilPadmanaban123](/AkhilPadmanaban123)  yeah but it isn't continguous is it? You have to maintain the sequeunce  like if it is  7,2,5,10,8       you don't break the sequence while making partitions"
                    },
                    {
                        "username": "AkhilPadmanaban123",
                        "content": "[@jo_yang](/jo_yang)  Hey what about [2,5,10] and [8,7], which gives 17 no that is even minimum than 18."
                    },
                    {
                        "username": "jo_yang",
                        "content": "The way you split the array makes the \"largest sum among subarrays\" as 25. However, that is not the solution, because we want to minimize that value. We can split the array in different ways like:\\n[7, 2], [5,10,8] => which the answer is 23 (better than your split since 23 is smaller than 25)\\n[7, 2, 5, 10], [8] => 24\\nEventually you will find the minimum:\\n[7, 2, 5], [10, 8] => 18"
                    },
                    {
                        "username": "galster",
                        "content": "\"....you can split the array into m non-empty continuous subarrays\"\\nI understood this to be.. that the subarrays themselves have to be continues (e.g. 1,2,3,4...)\\nThe wording should be changed to prevent ambiguities."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "You can use the solution of 1011. Capacity To Ship Packages Within D Days to solve this problem."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": " i was searching for this haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/split-array-largest-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-Up Dynamic Programming\n\n  \n**Approach 3:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "devcodes9",
                        "content": "This question is same as famous book Allocation problem."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "[@code_coffeee](/code_coffeee) https://www.codingninjas.com/studio/problems/allocate-books_1090540"
                    },
                    {
                        "username": "Advarsh",
                        "content": "[@code_coffeee](/code_coffeee) the question\\'s name is \"book allocation\""
                    },
                    {
                        "username": "shubhamganvir31",
                        "content": "[@code_coffeee] The problem name is \"book allocation problem\" itself. u can find it in gfg"
                    },
                    {
                        "username": "code_coffeee",
                        "content": "Which book? Can you provide a page or algorithm name as well?"
                    },
                    {
                        "username": "ria_a",
                        "content": "How would you approach the problem if there were some negative values in the array?\\nI would be grateful if anyone could share their ideas for such a case."
                    },
                    {
                        "username": "geiman",
                        "content": "Dynamic programming... You can take a look at my solution here:\\nclass Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        // ideas dp[x][k] -> What is the answer considering elements from [0, x], using exactly k intervals\\n        // dp[j][k] -> min(  max(dp[i][k - 1], sum(i + 1, k)))..\\n        int len = static_cast<int>(nums.size());\\n        vector< int > prefix_sum(len, 0); prefix_sum[0] = nums[0];\\n        for(int i = 1; i < len; ++i) prefix_sum[i] = nums[i] + prefix_sum[i - 1];\\n\\n        vector< vector<int> > dp(len, vector<int>(k + 1, -1));\\n\\n        auto sum = [&] (int l, int r) {\\n            return prefix_sum[r] - (l > 0 ? prefix_sum[l - 1] : 0);\\n        };\\n\\n        // let\\'s set the base-case\\n        for(int i = 0; i < len; ++i) dp[i][1] = sum(0, i);\\n\\n        for(int tk = 2; tk <= k; ++tk) {\\n            for(int pos = tk - 1; pos < len; ++pos) {\\n                for(int previous_endpoint = tk - 2; previous_endpoint < pos; ++previous_endpoint) {\\n                    if(dp[previous_endpoint][tk - 1] != -1) {\\n                        if(dp[pos][tk] == -1) dp[pos][tk] = max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos));\\n                        else dp[pos][tk] = min(dp[pos][tk], max(dp[previous_endpoint][tk - 1], sum(previous_endpoint + 1, pos)));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[len - 1][k];\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haidermalik",
                        "content": "Dynamic Programming would work then."
                    },
                    {
                        "username": "Vassago",
                        "content": "Most answers use binary search + greedy approach. Why greedy is ok here?\\nFor example,  [2,4,1,4,1,3] use greedy cannot be cut into 3 subarrays (sum <= 5), but in fact, [2,3], [1,4], [1,4]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Array needs to be split into subarrays, not subsets."
                    },
                    {
                        "username": "zhipj",
                        "content": "Hi,\\n\\nCan any one help to explain why the answer for the test case below is `14`?\\n\\n> [7,6,5,4,3,2,1]\\n> 2\\n\\nShouldn't we split the array into `[7,6]` and `[5,4,3,2,1]` and get the answer `15`? How come it gets `14` instead?\\n\\nThanks!"
                    },
                    {
                        "username": "Shyamsunder12",
                        "content": "[@dipaKoder](/dipaKoder)  ans is 15 bro "
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "[@dipaKoder](/dipaKoder) Answer is 15."
                    },
                    {
                        "username": "dipaKoder",
                        "content": "Yes ,You are right .Here answer is 14."
                    }
                ]
            },
            {
                "id": 2013980,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 1967526,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 1815051,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 1573257,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 2050446,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 2014068,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 2011327,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 2009534,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 1998454,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 1991948,
                "content": [
                    {
                        "username": "Ixa8488",
                        "content": "Same as ,\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n"
                    },
                    {
                        "username": "drpepper07",
                        "content": "How does [2, 3, 1, 1, 1, 1, 1], with k = 5 return 3?\nDoesnt this use only 4 buckets  as opposed to 5?\n `--> [2], [3], [1,1,1], [1,1]`\nThe question specifies non empty buckets  as well.\n\n"
                    },
                    {
                        "username": "anilkrdahiya",
                        "content": "correct, looks like wrong test case. "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its classic book allocation problem based on binary search, just content is changed :)"
                    },
                    {
                        "username": "srinuk",
                        "content": "[2,3,1,2,4,3]\\nFor the test case above for m =5\\nit can be split into [2,3] ,[1],[2],[4],[3]. \\n\\nAnswer should be 5 [2,3] but why is the expected output 4"
                    },
                    {
                        "username": "aashi__70",
                        "content": "[@chinmay1596](/chinmay1596)  other split is also possible like [2], [3] [1,2] [4] [3] in which maximum is 4"
                    },
                    {
                        "username": "chinmay1596",
                        "content": "You can split it into [2], [3,1] [2] [4] [3] and the maximum sum is 4 which is the expected output"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "one of the best questions I\\'ve ever solved \\nTip: just to do the question Capacity To Ship Packages Within D Days and copy paste the same code without any changes "
                    },
                    {
                        "username": "rraj09102002",
                        "content": "The problem is actually okay to solve but what it requires is how to identify it will fit in the binary search frame and how to perform operations as such. I was able to do the ship capacity question in under 10 minutes which has exact same solution as this one but had the hard time understanding how does it works here. So what we are doing is we are taking all possible maximum subarray sum and then checking if its possible to have the desired no of partitions with a value of sum less than that max subarray sum."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "1011. Capacity To Ship Packages Within D Days \\n\\nis the exact same problem, but with a different descrition and slightly easier time constraints, so if you are done with this one, you get that one as a freebee. Or if you want a different description and hints, you can look there too"
                    },
                    {
                        "username": "suryanshhh28",
                        "content": "Really a good question, probably one of the best I have done in Binary Search. "
                    },
                    {
                        "username": "arturszogla",
                        "content": "Ran the exact same code twice in a row and got TLE the first time and Accepted the second time. Of course, it passed only barely in time even on the accepted try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I really have trouble to understand this sentence `Return the minimized largest sum of the split.` "
                    }
                ]
            },
            {
                "id": 1984379,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1971253,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1960943,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1939053,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1920174,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1902379,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1875893,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1857372,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1851281,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            },
            {
                "id": 1811126,
                "content": [
                    {
                        "username": "anilkrdahiya",
                        "content": "How is the answer 3 for this test case?\\nnums = [2,3,1,1,1,1,1] for k =5\\n\\ncan someone please explains?"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Similar Problem of this type: Book Allocation Problem, Painter\\'s Partition Problem."
                    },
                    {
                        "username": "shrey802",
                        "content": "Can someone tell me what's wrong with my code?\n\nclass Solution {\n    public int splitArray(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int sum = 0;\n        int ans = -1;\n        for(int maxnum: nums){\n            sum += maxnum;\n        }\n        right = sum;\n        while(left<=right){\n            int mid = (left + right) / 2;\n            int cntSub = 1;\n            int sumofsubarr = 0;\n            for(int i=0; i<nums.length; i++){\n                if(sumofsubarr + nums[i] <= mid){\n                    sumofsubarr += nums[i];\n                }else{\n                    cntSub ++;\n                    sumofsubarr = nums[i];\n                }\n            }\n            if(cntSub > k){\n                left = mid + 1;\n            }else{\n                ans = mid;\n                right = mid - 1;\n            }\n        }\n    return ans;\n    }\n} "
                    },
                    {
                        "username": "mastercode0001",
                        "content": "This problem same as .\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/"
                    },
                    {
                        "username": "siddhanttamgadge4",
                        "content": "what does the minimized the largest  sum means here?"
                    },
                    {
                        "username": "trashw1n",
                        "content": "i attempted #1011 first and originally formulated that exactly as the problem statement given in this problem. (not to mention i got stuck and had to look up the binary search solution lmao)"
                    },
                    {
                        "username": "mrcrood",
                        "content": "i dont know why this is in HARD"
                    },
                    {
                        "username": "girishbhargava9202",
                        "content": "In this question, do we need to split the array such that every element is in at least 1 subarray?"
                    },
                    {
                        "username": "preet_sojitra",
                        "content": "This is given in question:\\nInput: nums = [7,2,5,10,8], k = 2\\nOutput: 18\\nExplanation: There are four ways to split nums into two subarrays.\\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n\\nI can also split it like this know [2,5,8] and [7,10]. Then largest minimized sum among two subarrays will be 17. So this can also be answer? \\n\\nLanguage of this question is somewhat ambiguous in my opinion"
                    },
                    {
                        "username": "Mayank_s",
                        "content": "no it is clearly written in question that subarray should be contiguous and you splitting the array in non contiguous order."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Think binary search as the DP(brute force) will give TLE (as for me) \\nthink the array as whole ```sum(nums)``` \\nwhat is asking in question minimized sum of the max sum not the partioned array \\n```\\nself.maxx = inf\\ndef sol(nums, k, arr):\\n            if k == 1:\\n                k-=1\\n                arr=arr+[nums]\\n            if k == 0: \\n                maxx = 0\\n                # print(arr)\\n                for i in arr: maxx = max(sum(i), maxx)\\n                self.maxx = min(maxx, self.maxx)\\n                return \\n            for i in range(len(nums)-1):\\n                sol(nums[i+1:], k-1, arr+[nums[:i+1]])\\nsol(nums, k, [])\\nreturn self.maxx\\n```\\nmy DP or recursion solution which gives TLE"
                    }
                ]
            }
        ]
    }
]