[
    {
        "title": "Binary Tree Inorder Traversal",
        "question_content": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n&nbsp;\nExample 1:\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\nExample 3:\n\nInput: root = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100\n\n&nbsp;\nFollow up: Recursive solution is trivial, could you do it iteratively?",
        "solutions": [
            {
                "id": 283746,
                "title": "all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line",
                "content": "![image](https://assets.leetcode.com/users/andvary/image_1556551007.png)\\n\\n```\\ndef preorder(root):\\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []\\n```\\n\\n```\\ndef inorder(root):\\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []\\n```\\n\\n```\\ndef postorder(root):\\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef preorder(root):\\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []\\n```\n```\\ndef inorder(root):\\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []\\n```\n```\\ndef postorder(root):\\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31213,
                "title": "iterative-solution-in-java-simple-and-readable",
                "content": "    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root;\\n\\n        while(cur!=null || !stack.empty()){\\n            while(cur!=null){\\n                stack.add(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            list.add(cur.val);\\n            cur = cur.right;\\n        }\\n\\n        return list;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root;\\n\\n        while(cur!=null || !stack.empty()){\\n            while(cur!=null){\\n                stack.add(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            list.add(cur.val);\\n            cur = cur.right;\\n        }\\n\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31381,
                "title": "python-recursive-and-iterative-solutions",
                "content": "        \\n    # recursively\\n    def inorderTraversal1(self, root):\\n        res = []\\n        self.helper(root, res)\\n        return res\\n        \\n    def helper(self, root, res):\\n        if root:\\n            self.helper(root.left, res)\\n            res.append(root.val)\\n            self.helper(root.right, res)\\n     \\n    # iteratively       \\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    # recursively\\n    def inorderTraversal1(self, root):\\n        res = []\\n        self.helper(root, res)\\n        return res\\n        \\n    def helper(self, root, res):\\n        if root:\\n            self.helper(root.left, res)\\n            res.append(root.val)\\n            self.helper(root.right, res)\\n     \\n    # iteratively       \\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right",
                "codeTag": "Python3"
            },
            {
                "id": 3169549,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    vector<int> ans;\\n    if (root == NULL) return ans;\\n    vector<int> left = inorderTraversal(root->left);\\n    ans.insert(ans.end(), left.begin(), left.end());\\n    ans.push_back(root->val);\\n    vector<int> right = inorderTraversal(root->right);\\n    ans.insert(ans.end(), right.begin(), right.end());\\n    return ans;\\n}\\n\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        st = []\\n        res = []\\n\\n        while root or st:\\n            while root:\\n                st.append(root)\\n                root = root.left\\n            \\n            root = st.pop()\\n            res.append(root.val)\\n\\n            root = root.right\\n        \\n        return res   \\n```\\n\\n```Java []\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    vector<int> ans;\\n    if (root == NULL) return ans;\\n    vector<int> left = inorderTraversal(root->left);\\n    ans.insert(ans.end(), left.begin(), left.end());\\n    ans.push_back(root->val);\\n    vector<int> right = inorderTraversal(root->right);\\n    ans.insert(ans.end(), right.begin(), right.end());\\n    return ans;\\n}\\n\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        st = []\\n        res = []\\n\\n        while root or st:\\n            while root:\\n                st.append(root)\\n                root = root.left\\n            \\n            root = st.pop()\\n            res.append(root.val)\\n\\n            root = root.right\\n        \\n        return res   \\n```\n```Java []\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31231,
                "title": "c-iterative-recursive-and-morris",
                "content": "There are three solutions to this problem.\\n\\n 1. Iterative solution using stack: `O(n)` time and `O(n)` space;\\n 2. Recursive solution: `O(n)` time and `O(n)` space (function call stack);\\n 3. Morris traversal: `O(n)` time and `O(1)` space.\\n\\n**Iterative solution using stack**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            nodes.push_back(root -> val);\\n            root = root -> right;\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\n**Recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```\\n\\n**Morris traversal**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    nodes.push_back(root -> val);\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\t\\t",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            nodes.push_back(root -> val);\\n            root = root -> right;\\n        }\\n        return nodes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    nodes.push_back(root -> val);\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713539,
                "title": "python-3-all-iterative-traversals-inorder-preorder-postorder-similar-solutions",
                "content": "[Python3] Pre, In, Post Iteratively Summarization\\nIn preorder, the order should be\\n\\nroot -> left -> right\\n\\nBut when we use stack, the order should be reversed:\\n\\nright -> left -> root\\n\\nPre\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n```\\n\\n\\nIn inorder, the order should be\\nleft -> root -> right\\n\\nBut when we use stack, the order should be reversed:\\n\\nright -> root -> left\\n\\nIn\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n```\\t\\n\\n\\nIn postorder, the order should be\\nleft -> right -> root\\n\\nBut when we use stack, the order should be reversed:\\n\\nroot -> right -> left\\n\\nPost\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328601,
                "title": "all-dfs-traversals-preorder-postorder-inorder-in-java-in-5-lines",
                "content": "![image](https://assets.leetcode.com/users/andvary/image_1556551007.png)\\n\\nPreorder: Node -> Left -> Right\\n\\n```\\npublic void preorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  nums.add(root.val);\\n  preorder(root.left, nums);\\n  preorder(root.right, nums);\\n}\\n```\\n\\nInorder : Left -> Node -> Right\\n\\n```\\npublic void inorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  inorder(root.left, nums);\\n  nums.add(root.val);\\n  inorder(root.right, nums);\\n}\\n```\\n\\nPostorder : Left -> Right -> Node\\n\\n```\\npublic void postorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  postorder(root.left, nums);\\n  postorder(root.right, nums);\\n  nums.add(root.val);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic void preorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  nums.add(root.val);\\n  preorder(root.left, nums);\\n  preorder(root.right, nums);\\n}\\n```\n```\\npublic void inorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  inorder(root.left, nums);\\n  nums.add(root.val);\\n  inorder(root.right, nums);\\n}\\n```\n```\\npublic void postorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  postorder(root.left, nums);\\n  postorder(root.right, nums);\\n  nums.add(root.val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31232,
                "title": "three-methods-to-solve-c",
                "content": "Method 1: Using one stack and the binary tree node will be changed. Easy ,not Practical\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left)\\n                {\\n                    stack.push(pNode->left);\\n                    pNode->left = NULL;\\n                }\\n                else\\n                {\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    if(pNode->right)\\n                    stack.push(pNode->right);\\n                }\\n            }\\n            return vector;\\n        }\\n    };\\n\\nMethod 2: Using one stack and one unordered_map, this will not changed the node. Better\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left && !map[pNode])\\n                {\\n                    stack.push(pNode->left);\\n                    map[pNode] = true;\\n                }\\n                else\\n                {\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    if(pNode->right)\\n                    stack.push(pNode->right);\\n                }\\n            }\\n            return vector;\\n        }\\n    };\\n\\nMethod 3: Using one stack  and will not changed the node. Best(at least in this three solutions)\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            stack<TreeNode *> stack;\\n            TreeNode *pCurrent = root;\\n            \\n            while(!stack.empty() || pCurrent)\\n            {\\n                if(pCurrent)\\n                {\\n                    stack.push(pCurrent);\\n                    pCurrent = pCurrent->left;\\n                }\\n                else\\n                {\\n                    TreeNode *pNode = stack.top();\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    pCurrent = pNode->right;\\n                }\\n            }\\n            return vector;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left)\\n                {\\n                    stack.push(pNode->left);\\n                    pNode->left = NULL;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 31228,
                "title": "simple-python-iterative-solution-by-using-a-visited-flag-o-n-56ms",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def inorderTraversal(self, root):\\n            result, stack = [], [(root, False)]\\n    \\n            while stack:\\n                cur, visited = stack.pop()\\n                if cur:\\n                    if visited:\\n                        result.append(cur.val)\\n                    else:\\n                        stack.append((cur.right, False))\\n                        stack.append((cur, True))\\n                        stack.append((cur.left, False))\\n    \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 31394,
                "title": "javascript-solution-with-iteration",
                "content": "```js\\nfunction inorderTraversal(root) {\\n  const stack = [];\\n  const res = [];\\n\\n  while (root || stack.length) {\\n    if (root) {\\n      stack.push(root);\\n      root = root.left;\\n    } else {\\n      root = stack.pop();\\n      res.push(root.val);\\n      root = root.right;\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction inorderTraversal(root) {\\n  const stack = [];\\n  const res = [];\\n\\n  while (root || stack.length) {\\n    if (root) {\\n      stack.push(root);\\n      root = root.left;\\n    } else {\\n      root = stack.pop();\\n      res.push(root.val);\\n      root = root.right;\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1377500,
                "title": "3-solutions-1-recursive-2-iterative-o-1-space-complexity-morris-traversal-explained-code",
                "content": "We can solve this problem in three ways lets 1st talk about he recursive method :\\n\\n**1st approach recursive**\\n\\n```\\nvoid helper(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans;\\n            \\n    }\\n```\\n\\n\\nthis approach is pretty self explanitory and i don\\'t think it needs any explanation. \\n\\n\\n**2nd approach**\\n\\n\\nJust use a stack\\n\\n```\\n vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        while(root||!s.empty()){\\n            if(root!=NULL){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                root=s.top();\\n                s.pop();\\n                v.push_back(root->val);\\n                root=root->right;\\n            }\\n          }\\n         return v;\\n    }\\n```\\n\\nand keep the nodes in the stack and just perform the left and the right operation and then just pop the stack.\\n\\n\\n**3rd approach and the most optimised approach with T.C. O(n) and S.C O(1)**\\n\\nI have just used the morris-traversal technique.\\nIn this approach we don\\'t need to make any stack or vector we can just manipulate the leaf node and get the desired result.\\n\\nAfter a successful Morris approach your tree will look something like this\\n\\n**Before morris algorithm**\\n![image](https://assets.leetcode.com/users/images/92e256e9-9f11-42a8-bec7-5cfd020a5b7a_1627858941.954608.jpeg)\\n\\n**After morris algorithm**\\n![image](https://assets.leetcode.com/users/images/c91d5981-e57e-4cac-8a38-b8278b447f82_1627858986.5674217.jpeg)\\n\\n\\nso now we can just iterate our root which is at **4** and go till we get a null.\\n\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* temp;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n            }\\n            else\\n            {\\n                ans.push_back(root->val);\\n                root=root->right;\\n                \\n            }\\n        }\\n        return ans;\\n```\\n\\nThis is the code to implement this approach. Please comment down if you have any confusions.\\n\\n**Please consider upvoting if you liked my effort of explaining this problem this will give me motivation to upload more such solutions.**\\n\\n**#happy_coding**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvoid helper(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans;\\n            \\n    }\\n```\n```\\n vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        while(root||!s.empty()){\\n            if(root!=NULL){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                root=s.top();\\n                s.pop();\\n                v.push_back(root->val);\\n                root=root->right;\\n            }\\n          }\\n         return v;\\n    }\\n```\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* temp;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n            }\\n            else\\n            {\\n                ans.push_back(root->val);\\n                root=root->right;\\n                \\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148939,
                "title": "cpp-morris-traversal",
                "content": "# Morris Traversal ( Using Threaded Tree for Inorder Traversal)\\n> O(n) Time | O(1) Space\\n\\n## Definition Threaded Tree\\n\"A binary tree is threaded by making all right child pointers that would normally be null point to the inorder successor of the node (if it exists), and all left child pointers that would normally be null point to the inorder predecessor of the node.\\n\\n![Img](https://upload.wikimedia.org/wikipedia/commons/7/7a/Threaded_tree.svg)\\n\\n\\n## Links\\nMorris Traversal : https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\nThreaded Binary Tree: https://en.wikipedia.org/wiki/Threaded_binary_tree\\n\\n## Note\\nWe are not caring about the predecessor link (C -> B in diagram) here to print inorder. Hence not entirely a threaded tree is made\\n\\n## Pseudo Code\\n```\\n1. Initialize current as root \\n2. While current is not NULL\\n   If current hs a left child\\n      ifa) Make current as right child of the rightmost \\n         node in current\\'s left subtree\\n      ifb) Go to this left child, i.e., current = current->left\\n   Else\\n      ea) Print current\\u2019s data\\n      eb) Go to the right, i.e., current = current->right\\n```\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t\\t\\t   //Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\\n\\n## References \\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31231/Clear-C++-solutions-iterative-recursive-and-Morris-traversal-(3-different-solutions!)\\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31232/Three-Methods-to-Solve-(C++)\\n\\n\\n # Other Solutions\\n ## Recursive\\n \\n ```\\n class Solution {\\npublic:\\n    vector<int> v;\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        find(root);\\n        return v;\\n    }\\n    \\n    void find(TreeNode* root){\\n        if(!root) return;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n    }\\n};\\n```\\n\\n## Stack Based Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode *root) {\\n        vector<int> vector;\\n        if(!root)\\n        return vector;\\n        unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n        stack<TreeNode *> stack;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            TreeNode *pNode = stack.top();\\n            if(pNode->left && !map[pNode])\\n            {\\n                stack.push(pNode->left);\\n                map[pNode] = true;\\n            }\\n            else\\n            {\\n                vector.push_back(pNode->val);\\n                stack.pop();\\n                if(pNode->right)\\n                stack.push(pNode->right);\\n            }\\n        }\\n        return vector;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n1. Initialize current as root \\n2. While current is not NULL\\n   If current hs a left child\\n      ifa) Make current as right child of the rightmost \\n         node in current\\'s left subtree\\n      ifb) Go to this left child, i.e., current = current->left\\n   Else\\n      ea) Print current\\u2019s data\\n      eb) Go to the right, i.e., current = current->right\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t\\t\\t   //Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    vector<int> v;\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        find(root);\\n        return v;\\n    }\\n    \\n    void find(TreeNode* root){\\n        if(!root) return;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode *root) {\\n        vector<int> vector;\\n        if(!root)\\n        return vector;\\n        unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n        stack<TreeNode *> stack;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            TreeNode *pNode = stack.top();\\n            if(pNode->left && !map[pNode])\\n            {\\n                stack.push(pNode->left);\\n                map[pNode] = true;\\n            }\\n            else\\n            {\\n                vector.push_back(pNode->val);\\n                stack.pop();\\n                if(pNode->right)\\n                stack.push(pNode->right);\\n            }\\n        }\\n        return vector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31404,
                "title": "concise-java-solution-based-on-stack",
                "content": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: using stack to simulate the recursion procedure: for each node, travel to its left child until it's left leaf, then pop to left leaf's higher level node A, and switch to A's right branch. Keep the above steps until cur is null and stack is empty. As the following:\\n\\n**Runtime = O(n)**: As each node is visited once\\n\\n**Space = O(n)**\\n\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tList<Integer> res = new LinkedList<Integer>();\\n    \\tif (root == null) return res;\\n    \\t\\n    \\tStack<TreeNode> stack = new Stack<TreeNode>();\\n    \\tTreeNode cur = root;\\n    \\twhile (cur != null || !stack.isEmpty()) { \\n    \\t\\twhile (cur != null) {// Travel to each node's left child, till reach the left leaf\\n    \\t\\t\\tstack.push(cur);\\n    \\t\\t\\tcur = cur.left;\\t\\t\\t\\t\\n    \\t\\t}\\t\\t \\n    \\t\\tcur = stack.pop(); // Backtrack to higher level node A\\n    \\t\\tres.add(cur.val);  // Add the node to the result list\\n    \\t\\tcur = cur.right;   // Switch to A'right branch\\n    \\t}\\n    \\treturn res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/19765/iterative-solution-in-java-simple-and-readable",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: using stack to simulate the recursion procedure: for each node, travel to its left child until it's left leaf, then pop to left leaf's higher level node A, and switch to A's right branch. Keep the above steps until cur is null and stack is empty. As the following:\\n\\n**Runtime = O(n)**: As each node is visited once\\n\\n**Space = O(n)**\\n\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tList<Integer> res = new LinkedList<Integer>();\\n    \\tif (root == null) return res;\\n    \\t\\n    \\tStack<TreeNode> stack = new Stack<TreeNode>();\\n    \\tTreeNode cur = root;\\n    \\twhile (cur != null || !stack.isEmpty()) { \\n    \\t\\twhile (cur != null) {// Travel to each node's left child, till reach the left leaf\\n    \\t\\t\\tstack.push(cur);\\n    \\t\\t\\tcur = cur.left;\\t\\t\\t\\t\\n    \\t\\t}\\t\\t \\n    \\t\\tcur = stack.pop(); // Backtrack to higher level node A\\n    \\t\\tres.add(cur.val);  // Add the node to the result list\\n    \\t\\tcur = cur.right;   // Switch to A'right branch\\n    \\t}\\n    \\treturn res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/19765/iterative-solution-in-java-simple-and-readable",
                "codeTag": "Unknown"
            },
            {
                "id": 1374069,
                "title": "iterative-solution-stack-in-python-easy-and-fast-99-89",
                "content": "The rule of Inorder Traversal is simple : For each sub tree, you need **visit left child** of current root, then **save root value**, then **visit right child** of current root, for example:\\n![image](https://assets.leetcode.com/users/images/18b11daa-0a08-4215-9713-c59e5e507abb_1627725926.9611049.png)\\n\\nand you MUST always follow this order\\n\\nWhen you visit each children node (here is node 2 or node 4), \\n* if it\\'s a parent of others children, then apply our rule again\\n* if it\\'s empty- which mean it\\'s a leaf- then add it to the Result_list\\n\\nSo, when the tree is bigger, we can notice the pattern of the job and using Stack for our job:\\n* We always visit until the end of left tree, each time visit, you append children to stack. Why ? Imagine we are saving a checkpoint for later to visit the right part of each root\\n```\\n while root:\\n      stack.append(root)\\n      root = root.left\\n```\\n* Each time finish the loop,  comeback and visit parent value, which is the last value of the stack. So just pop it and add value to the Result_list \\n```\\nroot = stack.pop()\\nresult.append(root.val)\\n```\\nNow the last thing in our rule is visit the right \\n```\\nroot = root.right\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c602e413-e193-4710-9127-10c91c86f7e4_1627726325.61519.png)\\nSo here is the code:\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = []\\n        result = []\\n        \\n        while root or stack:\\n          while root:\\n            stack.append(root)\\n            root = root.left\\n          root = stack.pop()\\n          result.append(root.val)\\n          root = root.right\\n        return result\\n```\\nUpvote if you find it useful =))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n while root:\\n      stack.append(root)\\n      root = root.left\\n```\n```\\nroot = stack.pop()\\nresult.append(root.val)\\n```\n```\\nroot = root.right\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = []\\n        result = []\\n        \\n        while root or stack:\\n          while root:\\n            stack.append(root)\\n            root = root.left\\n          root = stack.pop()\\n          result.append(root.val)\\n          root = root.right\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31467,
                "title": "morris-traversal-no-recursion-no-stack",
                "content": "\\tpublic class TreeNode {\\n\\t    int val;\\n\\t    TreeNode left;\\n\\t    TreeNode right;\\n\\t    TreeNode(int x) { val = x; }\\n\\t}\\n\\t\\n\\tpublic class Solution {\\n\\t    public List<Integer> inorderTraversal(TreeNode root) {\\n\\t        if(root == null) return new ArrayList<Integer>();\\n\\t        List<Integer> res = new ArrayList<Integer>();\\n\\t        TreeNode pre = null;\\n\\t        while(root != null){\\n\\t        \\tif(root.left == null){\\n\\t        \\t\\tres.add(root.val);\\n\\t        \\t\\troot = root.right;\\n\\t        \\t}else{\\n\\t        \\t\\tpre = root.left;\\n\\t        \\t\\twhile(pre.right != null && pre.right != root){\\n\\t        \\t\\t\\tpre = pre.right;\\n\\t        \\t\\t}\\n\\t        \\t\\tif(pre.right == null){\\n\\t        \\t\\t\\tpre.right = root;\\n\\t        \\t\\t\\troot = root.left;\\n\\t        \\t\\t}else{\\n\\t        \\t\\t\\tpre.right = null;\\n\\t        \\t\\t\\tres.add(root.val);\\n\\t        \\t\\t\\troot = root.right;\\n\\t        \\t\\t}\\n\\t        \\t}\\n\\t        }\\n\\t        return res;\\n\\t    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t    public List<Integer> inorderTraversal(TreeNode root) {\\n\\t        if(root == null) return new ArrayList<Integer>();\\n\\t        List<Integer> res = new ArrayList<Integer>();\\n\\t        TreeNode pre = null;\\n\\t        while(root != null){\\n\\t        \\tif(root.left == null){\\n\\t        \\t\\tres.add(root.val);\\n\\t        \\t\\troot = root.right;\\n\\t        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 31372,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 1: recursion\\n\\n        helper(root, res);\\n        return res;\\n\\n        //helper function for method 1\\n        private void helper(TreeNode root, List<Integer> res) {\\n            if (root != null) {\\n                if (root.left != null) {\\n                    helper(root.left, res);\\n                }\\n                res.add(root.val);\\n                if (root.right != null) {\\n                    helper(root.right, res);\\n               }\\n           }\\n       }\\n\\n\\n----------\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 2: iteration\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            res.add(cur.val);\\n            cur = cur.right;\\n        }\\n        return res;        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 1: recursion\\n\\n        helper(root, res);\\n        return res;\\n\\n        //helper function for method 1\\n        private void helper(TreeNode root, List<Integer> res) {\\n            if (root != null) {\\n                if (root.left != null) {\\n                    helper(root.left, res);\\n                }\\n                res.add(root.val);\\n                if (root.right != null) {\\n                    helper(root.right, res);\\n               }\\n           }\\n       }\\n\\n\\n----------\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 2: iteration\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            res.add(cur.val);\\n            cur = cur.right;\\n        }\\n        return res;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 603442,
                "title": "intuitive-javascript-solution-with-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n  const output = [];\\n  \\n  if (root === null) {\\n    return output;\\n  }\\n  \\n  /**\\n   * The goal is to maintain a stack of nodes to visit as we traverse \\n   * down the tree. As we traverse down, We go left and push all the \\n   * left nodes first in the stack. Once we reach to the bottom, we \\n   * store the node value and traverse right.\\n   *           1\\n   *         /   \\\\\\n   *        2     3    preorder traversal: 4 -> 2 -> 5 -> 1 -> 6 -> 3\\n   *       / \\\\   /     (left -> root -> right)\\n   *      4   5 6\\n   */\\n  const stack = [];\\n  let curr = root;\\n  \\n  while (curr !== null || stack.length !== 0) {\\n    if (curr !== null) {\\n      stack.push(curr);\\n      curr = curr.left;\\n    } else {\\n      curr = stack.pop();\\n      output.push(curr.val);\\n      curr = curr.right;  \\n    }  \\n  }\\n  \\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n  const output = [];\\n  \\n  if (root === null) {\\n    return output;\\n  }\\n  \\n  /**\\n   * The goal is to maintain a stack of nodes to visit as we traverse \\n   * down the tree. As we traverse down, We go left and push all the \\n   * left nodes first in the stack. Once we reach to the bottom, we \\n   * store the node value and traverse right.\\n   *           1\\n   *         /   \\\\\\n   *        2     3    preorder traversal: 4 -> 2 -> 5 -> 1 -> 6 -> 3\\n   *       / \\\\   /     (left -> root -> right)\\n   *      4   5 6\\n   */\\n  const stack = [];\\n  let curr = root;\\n  \\n  while (curr !== null || stack.length !== 0) {\\n    if (curr !== null) {\\n      stack.push(curr);\\n      curr = curr.left;\\n    } else {\\n      curr = stack.pop();\\n      output.push(curr.val);\\n      curr = curr.right;  \\n    }  \\n  }\\n  \\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691488,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    \\n    function traverse(node) {\\n        if(!node) return;\\n        \\n        traverse(node.left);\\n        result.push(node.val);\\n        traverse(node.right);\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    \\n    function traverse(node) {\\n        if(!node) return;\\n        \\n        traverse(node.left);\\n        result.push(node.val);\\n        traverse(node.right);\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332283,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/332277/Python-recursive-and-iterative-solutions)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/332286/Python-recursive-and-iterative-solutions)\\n\\nRecursive solution:\\n```\\n    def inorderTraversal(self, root):\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            in_order.append(node.val)\\n            dfs(node.right)\\n        \\n        in_order = []\\n        dfs(root)\\n        return in_order\\n```\\n\\nIterative solution 1: use a stack and a hashset visited\\n```\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return []\\n        in_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_left = True\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_left = False\\n            if no_left:\\n                stack.pop()\\n                in_order.append(top.val)\\n                if top.right and top.right not in visited:\\n                    stack.append(top.right)\\n                    visited.add(top.right)\\n        return in_order\\n```\\n\\nIterative solution 2: use a stack and a pointer\\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def inorderTraversal(self, root):\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            in_order.append(node.val)\\n            dfs(node.right)\\n        \\n        in_order = []\\n        dfs(root)\\n        return in_order\\n```\n```\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return []\\n        in_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_left = True\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_left = False\\n            if no_left:\\n                stack.pop()\\n                in_order.append(top.val)\\n                if top.right and top.right not in visited:\\n                    stack.append(top.right)\\n                    visited.add(top.right)\\n        return in_order\\n```\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1319978,
                "title": "c-clean-concise-code-recursive-faster-than-100-0ms-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else{\\n            in(root->left,v);\\n            v.push_back(root->val);\\n            in(root->right,v);\\n        }\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        return v;\\n    }\\n};\\n```\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else{\\n            in(root->left,v);\\n            v.push_back(root->val);\\n            in(root->right,v);\\n        }\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702291,
                "title": "python-iterative-recursive-and-morris-traversal-o-1-space-and-o-n-time-complexity",
                "content": "**Iterative :**\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output, stack =[],[]\\n        while(stack or root):\\n            if root:\\n                # Go to the left most and push the parent into the stack\\n                # We need this parent node once we are done with left child and need to go to the right child\\n                stack.append(root)\\n                root = root.left\\n            elif stack and root == None:\\n                #We are done with left , so pop out the parent\\n                root = stack.pop()\\n                output.append(root.val)\\n                # Go to the right child\\n                root = root.right\\n        return output\\n```\\nSpace : O(n) , Time : O(n)\\n\\n**Recursive**: \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output =[]\\n        def inorderTraversalHelper(root):\\n            if not root:\\n                return None\\n            inorderTraversalHelper(root.left)\\n            output.append(root.val)\\n            inorderTraversalHelper(root.right)\\n        inorderTraversalHelper(root)\\n        return output\\n```\\n\\n**Morris Traversal** : This can be done in constant space using Morris Traversal. Main aim of using a stack is to be able to go to right child of node once you have traverse the left child of a node. Instead of using a stack for that we can create a link between the inorder predecessor of the node and the node. Inorder predecessor of a node is the rightmost child of a left subtree and when you do a inorder traversal the node will come immediately after its inorder predecessor. \\n![image](https://assets.leetcode.com/users/images/9586323c-3a72-4e7a-a23c-27aa97795520_1592941100.20095.png)\\n\\nIf not using stack , create a link between 5 and 1. Now we don\\'t need a stack , we can go to 1 directly via 5. \\n![image](https://assets.leetcode.com/users/images/1793fa7e-e90f-4c74-8a60-7cc04bef6788_1592941130.8812513.png)\\n\\n![image](https://assets.leetcode.com/users/images/daad333c-010d-4a23-a998-1eb1c1102a08_1593026461.844386.png)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        # Morris Traversal\\n        curr = root\\n        output =[]\\n        while(curr):\\n            #if no left child, we can directly go the right child\\n            if not curr.left:\\n                output.append(curr.val)\\n                curr = curr.right\\n            else:\\n            # find the inorder predecessor of the current node\\n                predecessor = curr.left\\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \\n                # and reached the curr via its predecessor link and now again checking this else condition.\\n                # We have to break out of this loop.\\n                while predecessor.right !=None and predecessor.right != curr:\\n                    predecessor = predecessor.right # go as right as possible\\n\\n                # Now check which out of 2 above condition it reached\\n                if predecessor.right == None:\\n                    # No link created till now, so create one and go to the left child of current.\\n                    predecessor.right = curr\\n                    curr = curr.left\\n                else:\\n                    # left subtree is already visited , so delete the link and then go to right subtree\\n                    predecessor.right = None\\n                    output.append(curr.val)\\n                    curr = curr.right\\n        return output \\n```\\n\\nCode Walk through with the example :\\n1. Curr is 1 and before moving to its left , you have to create a link between 1 and its predecessor.\\n2. Predecessor is 5. Before creating the link , check if the predecessor already contains the link or not. Create a link between 5 and 1 and go to the left of 1 . **It is like putting the curr value to the stack and going to its left.**\\n3. Repeat the same process for curr node 2.  Before moving to its left , create a link between 2 and its predecessor \"4\"\\n![image](https://assets.leetcode.com/users/images/8867ccd2-686b-4ba4-a88e-9de48e65089b_1593704192.85518.png)\\n4. Now there is no curr.left. Add it to the output. Usually in inorder traversal with stack => you pop out from the stack , get the parent , add it to the output and go to left.Here to get the parent , you go to the right and followed the parent using the link created before.\\n![image](https://assets.leetcode.com/users/images/1e30590a-4c94-4d1b-b0ca-5d79d9428e81_1593704211.958061.png)\\n5. Now you are at 2 and **you don\\'t know if you are coming to this 2 for the first time or you have already explored its left**. One way to find it out is to check its predecessor and if link already exist , it means you have already explored the left of 2 and have utlised the link created before to come to 2. Now you can safely delete this link as you will not need it again . Now go to the curr.right. ( Left is done , parent is done)\\n![image](https://assets.leetcode.com/users/images/7ad9a3e5-5a8c-4761-9d23-488b2989d88b_1593704218.4761784.png)\\n6. Now you are at 5. There is no left so append it to the output and go to its right. 5.right = 1(the link we created before). Now repeat the same process of deleting the link as we did before and go to curr right which is 3. ( left is explored , parent is explored)\\n![image](https://assets.leetcode.com/users/images/9c63e1ae-7d79-4f21-af05-4c385bd55443_1593704224.371424.png)\\n7. You are at 3 and there is no left , so add it to the output.\\n![image](https://assets.leetcode.com/users/images/e89a7026-4060-4d7c-a922-70c3f30dafc2_1593704228.9838285.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output, stack =[],[]\\n        while(stack or root):\\n            if root:\\n                # Go to the left most and push the parent into the stack\\n                # We need this parent node once we are done with left child and need to go to the right child\\n                stack.append(root)\\n                root = root.left\\n            elif stack and root == None:\\n                #We are done with left , so pop out the parent\\n                root = stack.pop()\\n                output.append(root.val)\\n                # Go to the right child\\n                root = root.right\\n        return output\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output =[]\\n        def inorderTraversalHelper(root):\\n            if not root:\\n                return None\\n            inorderTraversalHelper(root.left)\\n            output.append(root.val)\\n            inorderTraversalHelper(root.right)\\n        inorderTraversalHelper(root)\\n        return output\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        # Morris Traversal\\n        curr = root\\n        output =[]\\n        while(curr):\\n            #if no left child, we can directly go the right child\\n            if not curr.left:\\n                output.append(curr.val)\\n                curr = curr.right\\n            else:\\n            # find the inorder predecessor of the current node\\n                predecessor = curr.left\\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \\n                # and reached the curr via its predecessor link and now again checking this else condition.\\n                # We have to break out of this loop.\\n                while predecessor.right !=None and predecessor.right != curr:\\n                    predecessor = predecessor.right # go as right as possible\\n\\n                # Now check which out of 2 above condition it reached\\n                if predecessor.right == None:\\n                    # No link created till now, so create one and go to the left child of current.\\n                    predecessor.right = curr\\n                    curr = curr.left\\n                else:\\n                    # left subtree is already visited , so delete the link and then go to right subtree\\n                    predecessor.right = None\\n                    output.append(curr.val)\\n                    curr = curr.right\\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724058,
                "title": "recursive-and-iterative-approach",
                "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31463,
                "title": "non-recursive-python-solution",
                "content": "Simple, understandable solution. In the loop: If we get a node with flag false, we add children in correct order and set them to false. because they have to be processed (for their children). And we set flag of current node to true. \\n\\nIf we get node with flag set to true we simply print its value (add to acc).\\nCan be modified to do post and pre order too.\\n\\n    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = [ (False, root) ]\\n            acc = []\\n            \\n            while stack:\\n                flag, val = stack.pop()\\n                if val:\\n                    if not flag:\\n                        stack.append( (False, val.right) )\\n                        stack.append( (True, val) )\\n                        stack.append( (False, val.left) )\\n                    else:\\n                        acc.append( val.val )\\n            return acc",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simple, understandable solution. In the loop: If we get a node with flag false, we add children in correct order and set them to false. because they have to be processed (for their children). And we set flag of current node to true. \\n\\nIf we get node with flag set to true we simply print its value (add to acc).\\nCan be modified to do post and pre order too.\\n\\n    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = [ (False, root) ]\\n            acc = []\\n            \\n            while stack:\\n                flag, val = stack.pop()\\n                if val:\\n                    if not flag:\\n                        stack.append( (False, val.right) )\\n                        stack.append( (True, val) )\\n                        stack.append( (False, val.left) )\\n                    else:\\n                        acc.append( val.val )\\n            return acc",
                "codeTag": "Java"
            },
            {
                "id": 1860290,
                "title": "tree-traversal-algorithms-preorder-inorder-and-postorder-traverse-algorithms-all-in-one",
                "content": "[Leetcode](https://leetcode.com/) [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/).\\n\\n\\n***By Frank Luo***\\n\\nThe **Tree Traversal Algorithms** are used to traversal the tree including **Binary Tree** and **N-ary Tree**. \\n\\n1. Binary Tree Traversal\\n\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\\n\\n2. N-ary Tree Traversal\\n\\n[589. N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)\\n[590. N-ary Tree Postorder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/)\\n\\n\\n# Binary Tree\\n\\n## PreOrder\\n\\nAlgorithm Preorder(tree)\\n1. Visit the root;\\n2. Traverse the left subtree, i.e., call Preorder(left-subtree);\\n3. Traverse the right subtree, i.e., call Preorder(right-subtree). \\n\\n### Recursive\\n\\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        list.add(root.val);\\n        preOrder(root.left, list);\\n        preOrder(root.right, list);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                ans.add(root.val);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n<!-- more -->\\n\\n## InOrder\\n\\nAlgorithm Inorder(tree)\\n\\n1. Traverse the left subtree, i.e., call Inorder(left-subtree);\\n2. Visit the root;\\n3. Traverse the right subtree, i.e., call Inorder(right-subtree).\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> inorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void inOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.left != null) {\\n            inOrder(root.left, list);\\n        }\\n        list.add(root.val);\\n        if (root.right != null) {\\n            inOrder(root.right, list);\\n        }\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            ans.add(root.val);\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n## PostOrder\\n\\nAlgorithm Postorder(tree)\\n1. Traverse the left subtree, i.e., call Postorder(left-subtree);\\n2. Traverse the right subtree, i.e., call Postorder(right-subtree);\\n3. Visit the root.\\n\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> postorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        postOrder(root.left, list);\\n        postOrder(root.right, list);\\n        list.add(root.val);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        TreeNode prev = null;\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n            root = stack.pop();\\n            if (root.right == null || root.right == prev) {\\n                ans.add(root.val);\\n                prev = root;\\n                root = null;\\n            } else {\\n                stack.push(root);\\n                root = root.right;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# N-ary Tree Traversal\\n\\n## PreOrder\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        list.add(root.val);\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            preOrderTraversal(child, list);\\n        }\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = size - 1; i >= 0; i--) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n## PostOrder\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> postorder_rec(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            postOrderTraversal(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = 0; i < size; i++) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n-------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        list.add(root.val);\\n        preOrder(root.left, list);\\n        preOrder(root.right, list);\\n    }\\n```\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                ans.add(root.val);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> inorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void inOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.left != null) {\\n            inOrder(root.left, list);\\n        }\\n        list.add(root.val);\\n        if (root.right != null) {\\n            inOrder(root.right, list);\\n        }\\n    }\\n```\n```java\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            ans.add(root.val);\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> postorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        postOrder(root.left, list);\\n        postOrder(root.right, list);\\n        list.add(root.val);\\n    }\\n```\n```java\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        TreeNode prev = null;\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n            root = stack.pop();\\n            if (root.right == null || root.right == prev) {\\n                ans.add(root.val);\\n                prev = root;\\n                root = null;\\n            } else {\\n                stack.push(root);\\n                root = root.right;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        list.add(root.val);\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            preOrderTraversal(child, list);\\n        }\\n    }\\n```\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = size - 1; i >= 0; i--) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> postorder_rec(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            postOrderTraversal(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n```\n```java\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = 0; i < size; i++) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31407,
                "title": "my-3-solutions-in-c",
                "content": "\\n    // recursive, it's trivial...\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(!root) return v;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n    \\n    \\n    // iterate, use stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                s.push(temp);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n        return v;\\n    }\\n    \\n    \\n    // iterate, morris traversal, without stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    v.push_back(temp->val);\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    // recursive, it's trivial...\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(!root) return v;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n    \\n    \\n    // iterate, use stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                s.push(temp);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n        return v;\\n    }\\n    \\n    \\n    // iterate, morris traversal, without stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    v.push_back(temp->val);\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 434091,
                "title": "js-recursive-clean-code",
                "content": "```\\nconst inorderTraversal = root => {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst inorderTraversal = root => {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3348653,
                "title": "java-fastest-dfs-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) h is height of the tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/4501697a-bbba-4d67-89cb-f285873536ec_1679937247.5252385.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        // Check if the root is null\\n        if(root == null){\\n            // If the root is null, return an empty ArrayList\\n            return new ArrayList<Integer>();\\n        }\\n\\n        // Create a new ArrayList to store the values obtained in an in-order traversal\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.left));\\n\\n        // Add the value of the root to the ArrayList\\n        ans.add(root.val);\\n\\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.right));\\n\\n        // Return the ArrayList containing all the values obtained in the in-order traversal\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        // Check if the root is null\\n        if(root == null){\\n            // If the root is null, return an empty ArrayList\\n            return new ArrayList<Integer>();\\n        }\\n\\n        // Create a new ArrayList to store the values obtained in an in-order traversal\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.left));\\n\\n        // Add the value of the root to the ArrayList\\n        ans.add(root.val);\\n\\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.right));\\n\\n        // Return the ArrayList containing all the values obtained in the in-order traversal\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019265,
                "title": "stack-c-inorder-beginner-friendly",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions \\nMemory Usage: 9.4 MB, less than 11.18% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions \\nMemory Usage: 8.6 MB, less than 11.18% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root){ \\n        if(root==NULL)\\n           return {};\\n        vector<int> vec;\\n        stack<TreeNode*> s;\\n        while(true){\\n            if(root!=NULL){\\n               s.push(root);\\n               root=root->left; \\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                root=s.top();\\n                s.pop();\\n                vec.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root){ \\n        if(root==NULL)\\n           return {};\\n        vector<int> vec;\\n        stack<TreeNode*> s;\\n        while(true){\\n            if(root!=NULL){\\n               s.push(root);\\n               root=root->left; \\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                root=s.top();\\n                s.pop();\\n                vec.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158278,
                "title": "python-stack-dfs",
                "content": "### 94. Binary Tree Inorder Traversal\\n```\\n> \\u7C7B\\u578B\\uFF1A\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS Recursive\\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n        \\n    def dfs(self, root):\\n        if not root:\\n            return\\n        self.dfs(root.left)\\n        self.res.append(root.val)\\n        self.dfs(root.right)\\n```\\n\\n#### Stack\\n\\n\\u5148\\u628A\\u8FED\\u4EE3\\u5230\\u6700\\u5DE6\\u8FB9\\u7684\\u53F6\\u5B50\\u8282\\u70B9\\uFF0C\\u628A\\u6240\\u6709\\u9014\\u4E2D\\u7684`root`\\u653E\\u8FDBstack\\uFF0C\\u5F53\\u5DE6\\u8FB9\\u8D70\\u4E0D\\u901A\\u4E86\\uFF0C\\u5F00\\u59CB\\u5F80`res`\\u91CC\\u9762\\u5B58\\u6570\\uFF0C\\u5E76\\u5F80\\u53F3\\u8FB9\\u8D70\\u3002\\n\\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1A\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n        \\n    def dfs(self, root):\\n        if not root:\\n            return\\n        self.dfs(root.left)\\n        self.res.append(root.val)\\n        self.dfs(root.right)\\n```\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073216,
                "title": "python-3-solutions-recursive-iterative",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## recursive\\n        if not root: return []\\n        else: return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## iteration\\n        stack,res = [],[]\\n        node = root\\n        # why we need to judge the node or the stack at the same time?\\n        # Because we will stop the first while loop when it reach the far-right leaf.\\n        # However, the stack will be empty when the node reaches the root.\\n        # And the node will be None when we reach the left leaf.\\n        # To make sure the node reaches the far-right leaf, we need to check the node and stack\\n        # in the first while loop.\\n        while node or stack:\\n            while node: # put all left nodes in the stack\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val)\\n            # change the direction to the right direction after the left.children\\n            # and parent are taken care of, which the inorder means.\\n            node = node.right\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## recursive\\n        if not root: return []\\n        else: return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## iteration\\n        stack,res = [],[]\\n        node = root\\n        # why we need to judge the node or the stack at the same time?\\n        # Because we will stop the first while loop when it reach the far-right leaf.\\n        # However, the stack will be empty when the node reaches the root.\\n        # And the node will be None when we reach the left leaf.\\n        # To make sure the node reaches the far-right leaf, we need to check the node and stack\\n        # in the first while loop.\\n        while node or stack:\\n            while node: # put all left nodes in the stack\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val)\\n            # change the direction to the right direction after the left.children\\n            # and parent are taken care of, which the inorder means.\\n            node = node.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338663,
                "title": "python-inorder-iterative-stack-t-f-explanation",
                "content": "InOrder Traversal:\\n\\t- Traverse the left side\\n\\t- hit the root\\n\\t- traverse the right side \\n\\nW/ recursive go -> left,root,right\\nW/iterative stack go -> right,root,left\\n\\t - stack follows LIFO(last-in-first-out)\\n\\t - so you\\'ll iterate through the right side first, but you\\'ll pop OUT the left side first\\n\\t - aka its backwards traversal to get the proper answer \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n        # root starts out False because you haven\\'t visited it yet\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            # pop the last element\\n            node, visited = stack.pop() \\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  \\n                    # inorder: left -> root -> right\\n                    # switch because stacks work backwards\\n                    stack.append((node.right, False)) # has not been visited before\\n                    stack.append((node, True)) # has been visited before\\n                    stack.append((node.left, False)) # has not been visited before \\n        return res\\n```\\n\\nNow to the fun part... True or False?\\n- False = you have appended to stack once\\n- True = you have popped the False, second appending is True\\n\\n```\\n# True vs. False\\n\\n         1\\n        / \\\\\\n       2   3\\n      / \\\\\\n     4   5\\n\\nroot  = 1\\nstack = [(root,False)]\\nFalse = not yet visited \\n\\n\\n# While stack:\\n    node, visited = stack.pop([(1,False)])\\n    \\n    if node: node = (1)\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 3, False) # hasn\\'t been visited yet \\n                stack.append(node = 1, True) # has been visited once before\\n                stack.append(node = 2, False) # hasn\\'t been visited yet\\nstack = [(3,False),(1, True),(2,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,False)\\n    \\n    if node: node = 2\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 5, False) # hasn\\'t been visited yet   \\n                stack.append(node = 2, True) # has been visited once before\\n                stack.append(node = 4, False) # hasn\\'t been visited yet         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,False)\\n    \\n    if node: node = 4\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 4, True) # has been visited once before\\n                stack.append(NA) # leaf         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,True)\\n    \\n    if node: node = 4\\n        if visited: True\\n            res.append(node.4)\\nres = [4]\\nstack = [(3,False),(1, True),(5,False),(2,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,True)\\n    \\n    if node: node = 2\\n        if visited: True \\n            res.append(node.2)\\nres = [4,2]\\nstack = [(3,False),(1, True),(5,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(5,False)\\n    \\n    if node: node = 5\\n        if visited: False\\n            \\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 5, True) # has been visited once before\\n                stack.append(NA) # leaf              \\nres = [4,2]\\nstack = [(3,False),(1, True),(5,True)]        \\n\\n# while stack:\\n    node, visited = stack.pop(5,True)\\n    \\n    if node: node = 5\\n        if visited: True \\n            res.append(node.5)\\nres = [4,2,5]\\nstack = [(3,False),(1, True)]  \\n\\n# while stack:\\n    node, visited = stack.pop(1,True)\\n    \\n    if node: node = 1\\n        if visited: True \\n            res.append(node.1)\\nres = [4,2,5,1]\\nstack = [(3,False)]  \\n\\n# while stack:\\n    node, visited = stack.pop(3,False)\\n    \\n    if node: node = 3\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 3, True) # has been visited once before\\n                stack.append(NA) # leaf   \\nres = [4,2,5,1]\\nstack = [(3,True)] \\n\\n# while stack:\\n    node, visited = stack.pop(3,True)\\n    if node: node = 3\\n        if visited: True \\n            res.append(node.3)\\nres = [4,2,5,1,3]\\nstack = []  \\n```\\n\\nHope that helps :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n        # root starts out False because you haven\\'t visited it yet\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            # pop the last element\\n            node, visited = stack.pop() \\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  \\n                    # inorder: left -> root -> right\\n                    # switch because stacks work backwards\\n                    stack.append((node.right, False)) # has not been visited before\\n                    stack.append((node, True)) # has been visited before\\n                    stack.append((node.left, False)) # has not been visited before \\n        return res\\n```\n```\\n# True vs. False\\n\\n         1\\n        / \\\\\\n       2   3\\n      / \\\\\\n     4   5\\n\\nroot  = 1\\nstack = [(root,False)]\\nFalse = not yet visited \\n\\n\\n# While stack:\\n    node, visited = stack.pop([(1,False)])\\n    \\n    if node: node = (1)\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 3, False) # hasn\\'t been visited yet \\n                stack.append(node = 1, True) # has been visited once before\\n                stack.append(node = 2, False) # hasn\\'t been visited yet\\nstack = [(3,False),(1, True),(2,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,False)\\n    \\n    if node: node = 2\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 5, False) # hasn\\'t been visited yet   \\n                stack.append(node = 2, True) # has been visited once before\\n                stack.append(node = 4, False) # hasn\\'t been visited yet         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,False)\\n    \\n    if node: node = 4\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 4, True) # has been visited once before\\n                stack.append(NA) # leaf         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,True)\\n    \\n    if node: node = 4\\n        if visited: True\\n            res.append(node.4)\\nres = [4]\\nstack = [(3,False),(1, True),(5,False),(2,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,True)\\n    \\n    if node: node = 2\\n        if visited: True \\n            res.append(node.2)\\nres = [4,2]\\nstack = [(3,False),(1, True),(5,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(5,False)\\n    \\n    if node: node = 5\\n        if visited: False\\n            \\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 5, True) # has been visited once before\\n                stack.append(NA) # leaf              \\nres = [4,2]\\nstack = [(3,False),(1, True),(5,True)]        \\n\\n# while stack:\\n    node, visited = stack.pop(5,True)\\n    \\n    if node: node = 5\\n        if visited: True \\n            res.append(node.5)\\nres = [4,2,5]\\nstack = [(3,False),(1, True)]  \\n\\n# while stack:\\n    node, visited = stack.pop(1,True)\\n    \\n    if node: node = 1\\n        if visited: True \\n            res.append(node.1)\\nres = [4,2,5,1]\\nstack = [(3,False)]  \\n\\n# while stack:\\n    node, visited = stack.pop(3,False)\\n    \\n    if node: node = 3\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 3, True) # has been visited once before\\n                stack.append(NA) # leaf   \\nres = [4,2,5,1]\\nstack = [(3,True)] \\n\\n# while stack:\\n    node, visited = stack.pop(3,True)\\n    if node: node = 3\\n        if visited: True \\n            res.append(node.3)\\nres = [4,2,5,1,3]\\nstack = []  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287690,
                "title": "c-solution-100-faster-iterative-and-recursive-version",
                "content": "Both iterative and recursive solutions are equally fast(0ms, 100% faster).\\n\\n```\\n//iterative solution using stack\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*ans=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    struct TreeNode**stack=malloc(100*sizeof(struct TreeNode*));\\n    int top=0;\\n    while(top||root){\\n        if(root){\\n            stack[top++]=root;\\n            root=root->left;\\n        }\\n        else{\\n            root=stack[--top];\\n            ans[(*returnSize)++]=root->val;\\n            root=root->right;\\n        }\\n    }\\n    free(stack);\\n    ans=realloc(ans,(*returnSize)*sizeof(int));\\n    return ans;\\n}\\n```\\n\\n```\\n//recursive solution\\nvoid traverse(struct TreeNode* root, int* arr, int* returnSize){\\n    if(root->left)\\n        traverse(root->left,arr,returnSize);\\n    arr[(*returnSize)++]=root->val;\\n    if(root->right)\\n        traverse(root->right,arr,returnSize);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*arr=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    if(root)\\n        traverse(root,arr,returnSize);\\n    arr=realloc(arr,(*returnSize)*sizeof(int));\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//iterative solution using stack\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*ans=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    struct TreeNode**stack=malloc(100*sizeof(struct TreeNode*));\\n    int top=0;\\n    while(top||root){\\n        if(root){\\n            stack[top++]=root;\\n            root=root->left;\\n        }\\n        else{\\n            root=stack[--top];\\n            ans[(*returnSize)++]=root->val;\\n            root=root->right;\\n        }\\n    }\\n    free(stack);\\n    ans=realloc(ans,(*returnSize)*sizeof(int));\\n    return ans;\\n}\\n```\n```\\n//recursive solution\\nvoid traverse(struct TreeNode* root, int* arr, int* returnSize){\\n    if(root->left)\\n        traverse(root->left,arr,returnSize);\\n    arr[(*returnSize)++]=root->val;\\n    if(root->right)\\n        traverse(root->right,arr,returnSize);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*arr=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    if(root)\\n        traverse(root,arr,returnSize);\\n    arr=realloc(arr,(*returnSize)*sizeof(int));\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547065,
                "title": "leetcode-the-hard-way-dfs-in-order-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\nYou may also check out my recent DFS solutions on other tree problems.\\n\\n- [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/2527028/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/discuss/2511705/leetcode-the-hard-way-dfs-explained-line-by-line)\\n- [814. Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/discuss/2537510/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [606. Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/discuss/2542523/leetcode-the-hard-way-dfs-5-cases-explained-line-by-line)\\n\\nThe steps for in-order is \\n- traverse left subtree \\n- do something with root value\\n-  traverse right sub tree. \\n\\nFor example 1, starting the root node 1.\\n \\n- At node 1 now, traverse left node first, however, there is no left node, hence return.\\n- At node 1 now, add root value which is 1. answer = [1]\\n- At node 1 now, traverse right node.\\n- At node 2 now, traverse left node first.\\n- At node 3 now,  traverse left node first, however, there is no left node, hence return.\\n- At node 3 now, add root value which is 3. answer = [1, 3]\\n- At node 3 now,  traverse right node, however, there is no right node, hence return.\\n- At node 2 now, add root value which is 2. answer = [1, 3, 2]\\n- At node 2 now, traverse right node, however, there is no right node, hence return.\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // traverse the left node\\n        inorder(node->left);\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the right node\\n        inorder(node->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# left -> root -> right\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // traverse the left node\\n        inorder(node->left);\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the right node\\n        inorder(node->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return ans;\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# left -> root -> right\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508286,
                "title": "c-simple-recursive-solution",
                "content": "**C++ :**\\n\\n```\\nvoid inorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tif(root -> left)\\n\\t\\t\\tinorderTraversalHelper(root -> left, res);\\n\\n\\t\\tres.push_back(root -> val);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tinorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> inorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tinorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid inorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tif(root -> left)\\n\\t\\t\\tinorderTraversalHelper(root -> left, res);\\n\\n\\t\\tres.push_back(root -> val);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tinorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> inorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tinorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31313,
                "title": "three-ways-of-iterative-inorder-traversing-easy-explanation",
                "content": "Three types of Iterative Inorder Traversals. \\n\\n1) **Using 1 Stack.** O(n) Time & O(n) Space\\n\\t* Push all `left` nodes into the `stack` till it hits `NULL`.\\n\\t* Then `Pop` the top element from the stack, print it and make the `root` point to its `right`.\\n\\t* Keep iterating till `both` the below conditions are met -\\n\\t\\t* Stack is empty `and`\\n        * Root is NULL.\\n\\t\\n```\\n \\npublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\n2) **Using 2 Stacks.** O(n) Time & O(n) Space\\nWe use two stacks. Stack `s` is used to find and traverse the child nodes, and `path` stack keeps track of the path from the `root` to the current node. (This is usefull in certain problems like [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [Path Sum](https://leetcode.com/problems/path-sum/) ). \\nThe logic is similar to [Preorder using 2 Stacks](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation) . The difference is on every iteration we first pop `s`. Then push it back in when we push the children. Make sure the order of pushing is right child -> root -> left child. Also, we print the element only on our way back.\\n    * Initially we push the `root` into `s`.\\n\\t* Keep iterating with below logic till `s` is `empty`.\\n\\t\\t* `root` = `s.pop()`\\n\\t\\t* If the top elements of both the stacks are not the same :\\t\\t\\n\\t\\t\\t* Push `root` into `path`.\\n\\t\\t\\t* Push `right child` into `s` if it exists.\\n\\t\\t\\t* Push `root` back into `s`.\\n\\t\\t\\t* Now, push `left child` into `s` if it exists.\\n\\t\\t* When top elements of both stacks are equal. (Which means we hit a deadend, and need to turn back)\\n\\t\\t\\t* Pop from `path`.\\n\\t\\t\\t* Print the root.\\n\\t\\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.pop();\\n            if(!path.empty() && path.peek()==root){                \\n                path.pop();\\n\\t\\t    out.add(root.val);\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n\\t\\t    s.push(root);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\\n\\n3) **Using No Stacks (Morris Traversal).** O(n) Time & O(1) Space\\nInstead of using stacks to remember our way back up the tree, we are going to modify the tree to create upwards links. The idea is based on [Threaded Binary Tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). \\n\\t* Iterate till `root` is null.\\n\\t\\t* If `root` has a left child.\\n\\t\\t\\t* Find the `inorder predecessor`. (Inorder predecessor of root is the right most child of its left child)\\n\\t\\t\\t\\t* Make it point to root.\\n\\t\\t\\t\\t* `root` = `root.left`.\\n\\t\\t\\t* If its already pointing to root (which means we have traversed it already and are on our way up.)\\n\\t\\t\\t\\t* Make the `inorder predecessor` point to `null` (Reverting our structural changes)\\n\\t\\t\\t\\t* `root` = `root.right`.\\n\\t\\t* If left child is `null`\\n\\t\\t\\t* `root` = `root.right`. (We are climbing up our link.)\\n\\t\\t\\t\\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn out;\\n\\t\\t\\tTreeNode pre = null;\\n\\t\\t\\twhile(root!=null){\\n\\t\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\t\\tif(pre.right==null){\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn out;\\n\\t\\t}\\n\\t\\t\\n```\\n\\nAlso checkout [PostOrder](https://discuss.leetcode.com/topic/64689/three-ways-of-iterative-postorder-traversing-easy-explanation)  & [PreOrder](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation)  :))",
                "solutionTags": [],
                "code": "```\\n \\npublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.pop();\\n            if(!path.empty() && path.peek()==root){                \\n                path.pop();\\n\\t\\t    out.add(root.val);\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n\\t\\t    s.push(root);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn out;\\n\\t\\t\\tTreeNode pre = null;\\n\\t\\t\\twhile(root!=null){\\n\\t\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\t\\tif(pre.right==null){\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn out;\\n\\t\\t}\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890237,
                "title": "go-solution",
                "content": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc inorderTraversal(root *TreeNode) []int {\\n    \\n    ans := []int{}\\n    \\n    var inorder func(*TreeNode) \\n    \\n    inorder = func(root *TreeNode) {\\n        if root == nil {return}\\n        \\n        inorder(root.Left)\\n        ans = append(ans, root.Val)\\n        inorder(root.Right)\\n        \\n    }\\n    inorder(root)\\n    \\n    return ans;   \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc inorderTraversal(root *TreeNode) []int {\\n    \\n    ans := []int{}\\n    \\n    var inorder func(*TreeNode) \\n    \\n    inorder = func(root *TreeNode) {\\n        if root == nil {return}\\n        \\n        inorder(root.Left)\\n        ans = append(ans, root.Val)\\n        inorder(root.Right)\\n        \\n    }\\n    inorder(root)\\n    \\n    return ans;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31409,
                "title": "share-my-solution-in-c",
                "content": "///// iterative solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0, state = 1;\\n    //stack[length++] = root;\\n    \\n    while (length>0 || root != NULL) {\\n        if (root) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode *)*length+1);\\n            stack[length++] = root;\\n            root = root->left;\\n        }\\n        else {\\n            root = stack[--length];\\n            result = (int *)realloc(result, sizeof(int)*(*returnSize+1));\\n            result[*returnSize] = root->val;\\n            *returnSize += 1;\\n            root = root->right;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (!root)\\n        return result;\\n    \\n    int *leftarr=NULL, *rightarr=NULL, leftsize=0, rightsize=0;\\n    if (root->left)\\n        leftarr = inorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = inorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    result = (int *)malloc(sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i] = leftarr[i];\\n    result[i++] = root->val;\\n    for (j=0; j<rightsize; j++)\\n        result[i+j] = rightarr[j];\\n    free(leftarr); free(rightarr);\\n    \\n    return result;\\n}",
                "solutionTags": [],
                "code": "///// iterative solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0, state = 1;\\n    //stack[length++] = root;\\n    \\n    while (length>0 || root != NULL) {\\n        if (root) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode *)*length+1);\\n            stack[length++] = root;\\n            root = root->left;\\n        }\\n        else {\\n            root = stack[--length];\\n            result = (int *)realloc(result, sizeof(int)*(*returnSize+1));\\n            result[*returnSize] = root->val;\\n            *returnSize += 1;\\n            root = root->right;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (!root)\\n        return result;\\n    \\n    int *leftarr=NULL, *rightarr=NULL, leftsize=0, rightsize=0;\\n    if (root->left)\\n        leftarr = inorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = inorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    result = (int *)malloc(sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i] = leftarr[i];\\n    result[i++] = root->val;\\n    for (j=0; j<rightsize; j++)\\n        result[i+j] = rightarr[j];\\n    free(leftarr); free(rightarr);\\n    \\n    return result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 160386,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```\\nIterative:\\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        trav = root\\n        res = []\\n        stack = []\\n        while stack or trav:\\n            while trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            u = stack.pop()\\n            res.append(u.val)\\n            trav = u.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        trav = root\\n        res = []\\n        stack = []\\n        while stack or trav:\\n            while trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            u = stack.pop()\\n            res.append(u.val)\\n            trav = u.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107203,
                "title": "java-recursive-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS in order traversal\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547003,
                "title": "easy-python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418125,
                "title": "simple-python-solution-recursive",
                "content": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307460,
                "title": "c-simple-solution",
                "content": "```\\nvoid travel(struct TreeNode* root,int *ret,int *size)\\n{\\n    if(root==NULL)return;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n    return ret;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvoid travel(struct TreeNode* root,int *ret,int *size)\\n{\\n    if(root==NULL)return;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31375,
                "title": "java-two-solutions-recursive-1-ms-and-non-recursive-2-ms",
                "content": "Recursive:`\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList();\\n        addNode(list,root);\\n        return list;\\n    }\\n    public void addNode(List<Integer> list,TreeNode root){\\n        if(root==null) return;\\n        addNode(list,root.left);\\n        list.add(root.val);\\n        addNode(list,root.right); \\n    }\\n\\nNon-recursive :`\\n\\n        List<Integer> list =new ArrayList();\\n        Stack<TreeNode> stack=new Stack();\\n        if(root==null) return list;\\n        while(root!=null){\\n            stack.push(root);\\n            root=root.left;\\n            while(root==null){\\n                if(stack.empty()) return list;\\n                root=stack.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        return list;\\n `",
                "solutionTags": [],
                "code": "Recursive:`\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList();\\n        addNode(list,root);\\n        return list;\\n    }\\n    public void addNode(List<Integer> list,TreeNode root){\\n        if(root==null) return;\\n        addNode(list,root.left);\\n        list.add(root.val);\\n        addNode(list,root.right); \\n    }\\n\\nNon-recursive :`\\n\\n        List<Integer> list =new ArrayList();\\n        Stack<TreeNode> stack=new Stack();\\n        if(root==null) return list;\\n        while(root!=null){\\n            stack.push(root);\\n            root=root.left;\\n            while(root==null){\\n                if(stack.empty()) return list;\\n                root=stack.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        return list;\\n `",
                "codeTag": "Unknown"
            },
            {
                "id": 31464,
                "title": "4ms-iterative-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n            pushAllLeft(s, root);\\n            vector<int> result;\\n            while(!s.empty()) {\\n                TreeNode* p = s.top();\\n                s.pop();\\n                result.push_back(p->val);\\n                pushAllLeft(s,p->right);\\n            }\\n            return result;\\n        }\\n        \\n        void pushAllLeft(stack<TreeNode*>& s, TreeNode* root) {\\n            while(root) {\\n                s.push(root);\\n                root = root->left;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n            pushAllLeft(s, root);\\n            vector<int> result;\\n            while(!s.empty()) {\\n                TreeNode* p = s.top();\\n                s.pop();\\n                result.push_back(p->val);\\n                pushAllLeft(s,p->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3673822,
                "title": "simplest-3-line-sol-with-explaination",
                "content": "# Intuition\\nThis code performs a inorder traversal on a binary tree and returns a list of integers containing the values of the nodes visited in the traversal.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an instance variable `ans` of type `List<Integer>` to store the values of the nodes in the inorder traversal.\\n2. Define the `inorderTraversal` function that takes a `TreeNode` called `root` as input and returns a list of integers.\\n3. Check if the `root` is null. If it is, return the `ans` list.\\n4. Recursively call the `inorderTraversal` function on the left child of the current `root` node.\\n5. Add the value of the current `root` node to the `ans` list using the `add` method.\\n6. Recursively call the `inorderTraversal` function on the right child of the current `root` node.\\n7. Finally, return the `ans` list containing the values of the nodes visited in the inorder traversal.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n   if (root == null) return ans;\\n   inorderTraversal(root.left);\\n   ans.add(root.val);\\n   inorderTraversal(root.right);\\n   return ans;\\n}\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/34562f78-5f5b-4e2e-a154-2df98ad56ee8_1687528905.3259234.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n   if (root == null) return ans;\\n   inorderTraversal(root.left);\\n   ans.add(root.val);\\n   inorderTraversal(root.right);\\n   return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926144,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n    \\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var ans = [Int]()\\n        var stack = [TreeNode?]()\\n        var curr = root\\n\\n        while curr != nil || !stack.isEmpty {\\n            while curr != nil {\\n                stack.append(curr)\\n                curr = curr?.left\\n            }\\n            curr = stack.removeLast()\\n            if let val = curr?.val {\\n                ans.append(val)\\n            }\\n            curr = curr?.right\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n    \\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var ans = [Int]()\\n        var stack = [TreeNode?]()\\n        var curr = root\\n\\n        while curr != nil || !stack.isEmpty {\\n            while curr != nil {\\n                stack.append(curr)\\n                curr = curr?.left\\n            }\\n            curr = stack.removeLast()\\n            if let val = curr?.val {\\n                ans.append(val)\\n            }\\n            curr = curr?.right\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533303,
                "title": "iterative-inorder-traversal-with-full-explanation",
                "content": "**Inorder tree traversal** is a type of *depth first search* (DFS) where we explore tree nodes in a particular order: left, root, right. \\n\\nTypically DFS is done recursively but I could also implement it with a *stack* (an abstract data type). To solve this problem, I\\'m going to implement a stack with a Python `list`.\\n\\nA more thorough explanation can be found on my [GitHub](https://github.com/sanoke/leetcode/blob/master/tree%20traversal/0094-binary-tree-inorder-traversal.ipynb), where I also do an inorder traversal of an example tree to demonstrate some intuition behind the process.\\n\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode):\\n        # initialize the stack\\n        stack = []\\n        # initialize the traveral list\\n        traversal = []\\n        \\n        # while we\\'re at a valid node or there are\\n        # still nodes to traverse... \\n        while stack or root:\\n            \\n            if root:\\n                # if we\\'re at a valid node,\\n                # remember where we\\'ve been and keep moving left\\n                stack.append(root)\\n                root = root.left\\n            \\n            else:\\n                # otherwise we\\'ve hit a dead end so\\n                # -- pop the most recent value\\n                # -- report out\\n                # -- move right\\n                root = stack.pop()\\n                traversal.append(root.val)\\n                root = root.right\\n        \\n        return traversal\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode):\\n        # initialize the stack\\n        stack = []\\n        # initialize the traveral list\\n        traversal = []\\n        \\n        # while we\\'re at a valid node or there are\\n        # still nodes to traverse... \\n        while stack or root:\\n            \\n            if root:\\n                # if we\\'re at a valid node,\\n                # remember where we\\'ve been and keep moving left\\n                stack.append(root)\\n                root = root.left\\n            \\n            else:\\n                # otherwise we\\'ve hit a dead end so\\n                # -- pop the most recent value\\n                # -- report out\\n                # -- move right\\n                root = stack.pop()\\n                traversal.append(root.val)\\n                root = root.right\\n        \\n        return traversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527791,
                "title": "javascript-10-lines-iterative-and-recursive",
                "content": "### Iterative In-order Traverse\\n- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    let curr = root,  res = [], stack = [];\\n    while (curr || stack.length) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        res.push(curr.val);\\n        curr = curr.right;\\n    }\\n    return res;\\n};\\n```\\n### Recursive In-order Traverse\\n\\n- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        res.push(node.val);\\n        traverse(node.right);\\n    }\\n};\\n```\\n\\n- Time Complexity:\\n    - `an spread syntax takes linear time and it takes T(n/2) in this implementation`\\n    - average: O(N log N)\\n    - worst: O(N^2) `unbalanced tree`\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    if (!root) return [];\\n    const res = [];\\n    res.push(...inorderTraversal(root.left));\\n    res.push(root.val);\\n    res.push(...inorderTraversal(root.right));\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    let curr = root,  res = [], stack = [];\\n    while (curr || stack.length) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        res.push(curr.val);\\n        curr = curr.right;\\n    }\\n    return res;\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        res.push(node.val);\\n        traverse(node.right);\\n    }\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    if (!root) return [];\\n    const res = [];\\n    res.push(...inorderTraversal(root.left));\\n    res.push(root.val);\\n    res.push(...inorderTraversal(root.right));\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31364,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively\\n    public List<Integer> inorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode node, List<Integer> ret) {\\n        if (node != null) {\\n            dfs(node.left, ret);\\n            ret.add(node.val);\\n            dfs(node.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       Stack<TreeNode> stack = new Stack<>();\\n       List<Integer> ret = new ArrayList<>();\\n       while (true) {\\n           while (root != null) {\\n               stack.push(root);\\n               root = root.left;\\n           }\\n           if (stack.isEmpty()) {\\n               break;  // no node left\\n           }\\n           TreeNode node = stack.pop();\\n           ret.add(node.val);\\n           root = node.right;\\n       }\\n       return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively\\n    public List<Integer> inorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode node, List<Integer> ret) {\\n        if (node != null) {\\n            dfs(node.left, ret);\\n            ret.add(node.val);\\n            dfs(node.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       Stack<TreeNode> stack = new Stack<>();\\n       List<Integer> ret = new ArrayList<>();\\n       while (true) {\\n           while (root != null) {\\n               stack.push(root);\\n               root = root.left;\\n           }\\n           if (stack.isEmpty()) {\\n               break;  // no node left\\n           }\\n           TreeNode node = stack.pop();\\n           ret.add(node.val);\\n           root = node.right;\\n       }\\n       return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2967362,
                "title": "javascript-recursive-and-iterative-explained",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n\\n    /*\\n    RECURSIVE SOLUTION\\n\\n    function inorder(root) {\\n        // if node null, return back to the prenode (works like that with recursive functions)\\n        if (!root) {\\n            return;\\n        }\\n\\n        inorder(root.left);    // recursive call for left nodes\\n        result.push(root.val); // push to result   \\n        inorder(root.right);   // when its done with left, start right\\n\\n    }\\n    // call recursive function\\n    inorder(root);\\n    return result;\\n    */\\n\\n\\n    // ITERATIVE SOLUTION \\n\\n    // The call stack, which we can return to the parent node and decide if there is something to do left\\n    let stack = [];\\n    // The pointer on the current node\\n    let currentNode = root;\\n\\n    while (currentNode || stack.length) {\\n        // this loop is going down the left nodes and exits if there is no left node anymore. Also adds all nodes to Stack\\n        if(currentNode) {\\n            stack.push(currentNode);\\n            currentNode = currentNode.left;\\n        } else {\\n// finishing the above loop, it means we are at the deepest left node we could get and all ar added, so now we need to point the currentNode to the parentNode. We do this by popping the last item in our callstack, which was the parentNode. pop returns the last item, currentNode is now the last Item (Parent)\\n        currentNode = stack.pop()\\n// We add currentNode to the result, because inorder traversal is \"\"left-root-right\"-order\", so we always add the most left node which is left (and has no left children)\\n        result.push(currentNode.val);\\n// then we point the pointer to the right node (even if its null)\\n        currentNode = currentNode.right;\\n        \\n// After we were at the deepest left, a new outer while loop is started, where is checked if currentNode exists, if yes, add to stack, move left. if not, set currentNode/pointer to parent, push it to result and set to right child node.\\n        }\\n            \\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n\\n    /*\\n    RECURSIVE SOLUTION\\n\\n    function inorder(root) {\\n        // if node null, return back to the prenode (works like that with recursive functions)\\n        if (!root) {\\n            return;\\n        }\\n\\n        inorder(root.left);    // recursive call for left nodes\\n        result.push(root.val); // push to result   \\n        inorder(root.right);   // when its done with left, start right\\n\\n    }\\n    // call recursive function\\n    inorder(root);\\n    return result;\\n    */\\n\\n\\n    // ITERATIVE SOLUTION \\n\\n    // The call stack, which we can return to the parent node and decide if there is something to do left\\n    let stack = [];\\n    // The pointer on the current node\\n    let currentNode = root;\\n\\n    while (currentNode || stack.length) {\\n        // this loop is going down the left nodes and exits if there is no left node anymore. Also adds all nodes to Stack\\n        if(currentNode) {\\n            stack.push(currentNode);\\n            currentNode = currentNode.left;\\n        } else {\\n// finishing the above loop, it means we are at the deepest left node we could get and all ar added, so now we need to point the currentNode to the parentNode. We do this by popping the last item in our callstack, which was the parentNode. pop returns the last item, currentNode is now the last Item (Parent)\\n        currentNode = stack.pop()\\n// We add currentNode to the result, because inorder traversal is \"\"left-root-right\"-order\", so we always add the most left node which is left (and has no left children)\\n        result.push(currentNode.val);\\n// then we point the pointer to the right node (even if its null)\\n        currentNode = currentNode.right;\\n        \\n// After we were at the deepest left, a new outer while loop is started, where is checked if currentNode exists, if yes, add to stack, move left. if not, set currentNode/pointer to parent, push it to result and set to right child node.\\n        }\\n            \\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555429,
                "title": "binary-tree-inorder-traversal",
                "content": "1. ITERATIVE APPROACH\\nIn iterative approach, the stack data structure is used. We need to store the current or parent node so that after processing the left subtree we can process the node so we push the node in the stack data structure. After processing the node, we pop that respective node.\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        while(1){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()==true) break;\\n                root=st.top();\\n                st.pop();\\n                ans.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\t\\n2. RECURSIVE APPROACH\\nThe first call recursively left child node until getting NULL value then get node value and then call recursively right child node until getting NULL. So now print the value of all nodes inorder traversing.\\n\\n```\\n\\tclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        while(1){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()==true) break;\\n                root=st.top();\\n                st.pop();\\n                ans.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547292,
                "title": "c-recursive-morris-traversal-approach",
                "content": "**Please upvote if you like the post :)**\\n\\n**Intuition:**\\nSeeing tree problems, first thing that hit\\'s your brain is? what is it? Yessss its **Recursion.**\\n\\n**Approach: (DFS Traversal)**\\n* **Inorder** Traversal follows - **Left Root Right**\\n* If `root==NULL` we can simply return `{}`;\\n* we declare a vector **vec** and simply push all the `root->val` after every **left** traversal and after that **right** traversal happens.\\n \\n**Visualization: (DFS)**\\n![image](https://assets.leetcode.com/users/images/910dc845-947f-4f49-806c-dec5f90fd9f4_1662608198.1349866.gif)\\n\\n\\n\\n\\n\\n**C++:(DFS Traversal)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec; \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**, where N is the number of nodes in the Binary Tree.\\n**Space Complexity:** **O(N)**, where N is the number of node in the Binary Tree (Recursion stack space)\\n****\\n**Approach 2: (Optimized - Morris Traversal)**\\n* So the idea is that at a `node` whether we have to move `left` or `right` is determined whether the node has a **left** subtree. \\n* If it doesn\\u2019t we move to the **right**. \\n* If there is a `left` subtree then we see its `rightmost` child. If the `rightmost` child is pointing to `NULL`, we move the **current** node to its **left**. \\n* If the **rightmost** child is already pointing towards the **current** node, we remove that link and move to the **right** of the **current** node. \\n* We will **stop** the execution when the **current** points to `null` and we have traversed the whole tree.\\n \\n**Visualization: (Optimized - Morris Traversal)**\\n![image](https://assets.leetcode.com/users/images/27affd71-dfea-4a3f-9755-d5648c86ccf5_1662608543.0316582.png)\\n\\n\\n\\n**C++:(Optimized - Morris Traversal)** \\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> inOrder;\\n        TreeNode* cur = root;\\n        while(cur!=NULL){\\n            if(cur->left==NULL){\\n                inOrder.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n            else{\\n                TreeNode* prev = cur->left;\\n                while(prev->right!=NULL && prev->right!=cur){\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL){\\n                    prev->right=cur;\\n                    cur=cur->left;\\n                }\\n                else if(prev->right==cur){\\n                    prev->right=NULL;\\n                    inOrder.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**, where N is the number of nodes in the Binary Tree.\\n**Space Complexity:** **O(1)**, constant space\\n****",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec; \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> inOrder;\\n        TreeNode* cur = root;\\n        while(cur!=NULL){\\n            if(cur->left==NULL){\\n                inOrder.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n            else{\\n                TreeNode* prev = cur->left;\\n                while(prev->right!=NULL && prev->right!=cur){\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL){\\n                    prev->right=cur;\\n                    cur=cur->left;\\n                }\\n                else if(prev->right==cur){\\n                    prev->right=NULL;\\n                    inOrder.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385969,
                "title": "easiest-traversal-without-stack-queue-100-inorder",
                "content": "##  **Using This Solution We Can Make Inorder Traversal In Binary Tree Without Using Stack And Queue.**\\n\\n##### Global Declaration Of Ans Vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\\n\\n\\n##### Pass By Reference Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return ;\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n**Like & UpVote If You Get My Intuition Also Comment If You Have Any Query..**\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return ;\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294202,
                "title": "golang-recursive-100-faster-0-ms",
                "content": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n    var nums = []int{}\\n    if root == nil {\\n        return nums\\n    }\\n    \\n    nums = append(nums, inorderTraversal(root.Left)...)\\n    nums = append(nums, root.Val)\\n    nums = append(nums, inorderTraversal(root.Right)...)\\n    return nums\\n}\\nPlease upvote if you like\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n    var nums = []int{}\\n    if root == nil {\\n        return nums\\n    }\\n    \\n    nums = append(nums, inorderTraversal(root.Left)...)\\n    nums = append(nums, root.Val)\\n    nums = append(nums, inorderTraversal(root.Right)...)\\n    return nums\\n}\\nPlease upvote if you like\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1251231,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        ans.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        ans.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668448,
                "title": "morris-traversal",
                "content": "I wanted to share an example of in-place Morris traversal. Didn\\'t see many Python examples out there. This example is based off Tushar\\'s morris traversal video: https://youtu.be/wGXB9OWhPTg and various sources I found: \\n\\nhttps://www.***.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/148939/CPP-Morris-Traversal\\n\\n```python\\n\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n\\n        while root:\\n            if not root.left: # if we don\\'t have a left, this is our best in-order value at the moment. add it to the list and move right.\\n                res.append(root.val)\\n                root = root.right\\n            else:\\n                pred = self.findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\\n\\n\\t\\t\\t\\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we\\'re not ex\\n                if pred.right != root:\\n                    pred.right = root\\n                    root = root.left\\n                else: \\n\\t\\t\\t\\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\\n                    root.left = None\\n\\n        return res\\n\\n    def findPredecessor(self, root: TreeNode) -> TreeNode:\\n        curr = root.left\\n\\n        while curr.right and curr.right != root:\\n            curr = curr.right\\n\\n        return curr\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n\\n        while root:\\n            if not root.left: # if we don\\'t have a left, this is our best in-order value at the moment. add it to the list and move right.\\n                res.append(root.val)\\n                root = root.right\\n            else:\\n                pred = self.findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\\n\\n\\t\\t\\t\\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we\\'re not ex\\n                if pred.right != root:\\n                    pred.right = root\\n                    root = root.left\\n                else: \\n\\t\\t\\t\\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\\n                    root.left = None\\n\\n        return res\\n\\n    def findPredecessor(self, root: TreeNode) -> TreeNode:\\n        curr = root.left\\n\\n        while curr.right and curr.right != root:\\n            curr = curr.right\\n\\n        return curr\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31261,
                "title": "c-solution",
                "content": "```\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode currentNode = root;\\n\\n        while (currentNode != null || stack.Count != 0)\\n        {\\n            while (currentNode != null)\\n            {\\n                stack.Push(currentNode);\\n                currentNode = currentNode.left;\\n            }\\n            \\n            if (stack.Count != 0)\\n            {\\n                currentNode = stack.Pop();\\n                result.Add(currentNode.val);\\n                currentNode = currentNode.right;\\n            }\\n        }\\n            \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode currentNode = root;\\n\\n        while (currentNode != null || stack.Count != 0)\\n        {\\n            while (currentNode != null)\\n            {\\n                stack.Push(currentNode);\\n                currentNode = currentNode.left;\\n            }\\n            \\n            if (stack.Count != 0)\\n            {\\n                currentNode = stack.Pop();\\n                result.Add(currentNode.val);\\n                currentNode = currentNode.right;\\n            }\\n        }\\n            \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31422,
                "title": "java-simple-and-clean",
                "content": "No1:\\n\\n     List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       if (root == null) return ans;\\n       inorderTraversal(root.left);\\n       ans.add(root.val);\\n       return inorderTraversal(root.right);\\n    }\\n\\n\\nNo2:\\n\\n       public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tTreeNode cur = root;\\n    \\twhile (!stack.isEmpty() || cur != null) {\\n    \\t\\twhile (cur != null) {\\n        \\t\\tstack.push(cur);\\n        \\t\\tcur = cur.left;\\n        \\t}\\n    \\t\\tcur = stack.pop();\\n    \\t\\tans.add(cur.val);\\n    \\t\\tcur = cur.right;\\n     \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "No1:\\n\\n     List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       if (root == null) return ans;\\n       inorderTraversal(root.left);\\n       ans.add(root.val);\\n       return inorderTraversal(root.right);\\n    }\\n\\n\\nNo2:\\n\\n       public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tTreeNode cur = root;\\n    \\twhile (!stack.isEmpty() || cur != null) {\\n    \\t\\twhile (cur != null) {\\n        \\t\\tstack.push(cur);\\n        \\t\\tcur = cur.left;\\n        \\t}\\n    \\t\\tcur = stack.pop();\\n    \\t\\tans.add(cur.val);\\n    \\t\\tcur = cur.right;\\n     \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31411,
                "title": "iterative-0ms-c-solution-with-o-1-space",
                "content": "    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n    \\tTreeNode *buf;\\n    \\twhile (root) {\\n    \\t\\tif (root->left) {\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\twhile (buf->right){\\n    \\t\\t\\t\\tbuf = buf->right;\\n    \\t\\t\\t}\\n    \\t\\t\\tbuf->right = root;\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\troot->left = NULL;\\n    \\t\\t\\troot = buf;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans.push_back(root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n    \\tTreeNode *buf;\\n    \\twhile (root) {\\n    \\t\\tif (root->left) {\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\twhile (buf->right){\\n    \\t\\t\\t\\tbuf = buf->right;\\n    \\t\\t\\t}\\n    \\t\\t\\tbuf->right = root;\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\troot->left = NULL;\\n    \\t\\t\\troot = buf;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans.push_back(root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3198212,
                "title": "c-recursive-iterative-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple three steps in Inorder Traversal :\\n- Left Traversal\\n- Push The ROOT \\n- Right Traversal\\n<--------**LPR**------->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Recusrive : Do left recursion then push  then Do right recursion\\n- Iterative : Use a stack (just like recursion stack is internally used ,same is here) .So just start from root and go left upto left !=null and keep pushing them in stack and then  store the topof stack  in answer vector and pop that  and then  for that top go for its right . (L->P->R strategy)\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Recusrive INorder**\\n```\\nvector<int>ans;\\n    void Inorder(TreeNode * root){\\n        if(!root)return;\\n        Inorder(root->left);\\n        ans.push_back(root->val);\\n        Inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        Inorder(root);\\n        return ans;\\n    }\\n```\\n**Iterative Inorder**\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root)return {};\\n         stack<TreeNode*>st;\\n         TreeNode* temp=root;\\n         while(!st.empty() or temp){\\n             while(temp){\\n                 st.push(temp);\\n                 temp=temp->left;\\n             }\\n             temp=st.top();\\n             ans.push_back(st.top()->val);\\n             st.pop();\\n             temp=temp->right;\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int>ans;\\n    void Inorder(TreeNode * root){\\n        if(!root)return;\\n        Inorder(root->left);\\n        ans.push_back(root->val);\\n        Inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        Inorder(root);\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root)return {};\\n         stack<TreeNode*>st;\\n         TreeNode* temp=root;\\n         while(!st.empty() or temp){\\n             while(temp){\\n                 st.push(temp);\\n                 temp=temp->left;\\n             }\\n             temp=st.top();\\n             ans.push_back(st.top()->val);\\n             st.pop();\\n             temp=temp->right;\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547358,
                "title": "java-easy-solution-100-faster-code-minimum-lines-codes",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    in(root,res);\\n    return res;\\n}\\n\\npublic void in(TreeNode root,List<Integer> res){\\n    if(root==null)\\n        return;\\n    in(root.left,res);\\n    res.add(root.val);\\n    in(root.right,res);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    in(root,res);\\n    return res;\\n}\\n\\npublic void in(TreeNode root,List<Integer> res){\\n    if(root==null)\\n        return;\\n    in(root.left,res);\\n    res.add(root.val);\\n    in(root.right,res);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414598,
                "title": "rust-solution",
                "content": "```Rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res = vec![];\\n        \\n        fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                traversal(n.borrow().left.clone(), res);\\n                res.push(n.borrow().val);\\n                traversal(n.borrow().right.clone(), res);\\n            }\\n        }\\n        \\n        traversal(root, &mut res);\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res = vec![];\\n        \\n        fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                traversal(n.borrow().left.clone(), res);\\n                res.push(n.borrow().val);\\n                traversal(n.borrow().right.clone(), res);\\n            }\\n        }\\n        \\n        traversal(root, &mut res);\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1329494,
                "title": "0-ms-swift-binary-tree-inorder-traversal-test-cases",
                "content": "```swift\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var result = [Int](), array = [TreeNode](), head = root\\n        while head != nil || !(array.isEmpty) {\\n            switch head {\\n            case .some(let node):\\n                array.append(node)\\n                head = node.left\\n            default:\\n                let prev = array.removeLast()\\n                result.append(prev.val)\\n                head = prev.right\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.046 (0.048) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.inorderTraversal(.init([1,nil,2,3]))\\n        XCTAssertEqual(res, [1,3,2])\\n    }\\n    func test1() {\\n        let res = s.inorderTraversal(.init([]))\\n        XCTAssertEqual(res, [])\\n    }\\n    func test2() {\\n        let res = s.inorderTraversal(.init([1]))\\n        XCTAssertEqual(res, [1])\\n    }\\n    func test3() {\\n        let res = s.inorderTraversal(.init([1,2]))\\n        XCTAssertEqual(res, [2,1])\\n    }\\n    func test4() {\\n        let res = s.inorderTraversal(.init([1,nil,2]))\\n        XCTAssertEqual(res, [1,2])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var result = [Int](), array = [TreeNode](), head = root\\n        while head != nil || !(array.isEmpty) {\\n            switch head {\\n            case .some(let node):\\n                array.append(node)\\n                head = node.left\\n            default:\\n                let prev = array.removeLast()\\n                result.append(prev.val)\\n                head = prev.right\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.046 (0.048) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.inorderTraversal(.init([1,nil,2,3]))\\n        XCTAssertEqual(res, [1,3,2])\\n    }\\n    func test1() {\\n        let res = s.inorderTraversal(.init([]))\\n        XCTAssertEqual(res, [])\\n    }\\n    func test2() {\\n        let res = s.inorderTraversal(.init([1]))\\n        XCTAssertEqual(res, [1])\\n    }\\n    func test3() {\\n        let res = s.inorderTraversal(.init([1,2]))\\n        XCTAssertEqual(res, [2,1])\\n    }\\n    func test4() {\\n        let res = s.inorderTraversal(.init([1,nil,2]))\\n        XCTAssertEqual(res, [1,2])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197245,
                "title": "python3-31ms-easy-explanation",
                "content": "# Approach\\n- first traverse till last node in left branch of every next node.\\n- now return when None node found\\n- append current element to inorder list\\n- at this point this means we traversed all left possible nodes.\\n- now go to right branch and do the same.\\n- return inord.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        inord = []\\n        def inorder(curr=root):\\n            nonlocal inord\\n            if curr:\\n                inorder(curr.left)\\n                inord.append(curr.val)\\n                inorder(curr.right)\\n            return\\n        inorder()\\n        return inord\\n```\\n# Please like and comment below.\\n# ( \\u0361\\u1D54\\u202F\\u035C\\u0296 \\u0361\\u1D54)\\u270C",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        inord = []\\n        def inorder(curr=root):\\n            nonlocal inord\\n            if curr:\\n                inorder(curr.left)\\n                inord.append(curr.val)\\n                inorder(curr.right)\\n            return\\n        inorder()\\n        return inord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830795,
                "title": "c-easy-solution-100-fast",
                "content": "```\\nint i=0;\\nint arr[101]={0};\\nvoid inorder(struct TreeNode* s)\\n{\\n    if(s!=NULL)\\n    {\\n        inorder(s->left);\\n        arr[i++]=s->val;\\n        inorder(s->right);\\n    }\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint i=0;\\nint arr[101]={0};\\nvoid inorder(struct TreeNode* s)\\n{\\n    if(s!=NULL)\\n    {\\n        inorder(s->left);\\n        arr[i++]=s->val;\\n        inorder(s->right);\\n    }\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803478,
                "title": "python-simple-python-solution-using-recursion-faster-than-90-84",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 33 ms, faster than 90.84% of Python3 online submissions for Binary Tree Inorder Traversal.\\n# Memory Usage: 13.8 MB, less than 60.15% of Python3 online submissions for Binary Tree Inorder Traversal.\\n\\n\\tclass Solution:\\n\\t\\tdef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tself.result = []\\n\\n\\t\\t\\tdef InOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tInOrderTraversal(node.left)\\n\\t\\t\\t\\tself.result.append(node.val)\\n\\t\\t\\t\\tInOrderTraversal(node.right)\\n\\n\\t\\t\\tInOrderTraversal(root)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 33 ms, faster than 90.84% of Python3 online submissions for Binary Tree Inorder Traversal.\\n# Memory Usage: 13.8 MB, less than 60.15% of Python3 online submissions for Binary Tree Inorder Traversal.\\n\\n\\tclass Solution:\\n\\t\\tdef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tself.result = []\\n\\n\\t\\t\\tdef InOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tInOrderTraversal(node.left)\\n\\t\\t\\t\\tself.result.append(node.val)\\n\\t\\t\\t\\tInOrderTraversal(node.right)\\n\\n\\t\\t\\tInOrderTraversal(root)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 1743165,
                "title": "javascript-typescript-simple-2-line-recursive-solution-time-97-faster-memory-5-less",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    if (root === null) return [];\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    if (root === null) return [];\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486984,
                "title": "single-iterative-solution-for-preorder-inorder-and-postorder-traversals-in-one-go",
                "content": "```\\nclass Solution:\\n\\tdef inorderTraversal(self, root):\\n\\n\\t\\tpreo,ino,posto,stack=[],[],[],[[root,1]]\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\twhile stack:\\n\\t\\t\\tn=stack.pop()\\n\\n\\t\\t\\t#Preorder Traversal\\n\\t\\t\\tif n[1]==1:\\n\\t\\t\\t\\tpreo.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].left:\\n\\t\\t\\t\\t\\tstack.append([n[0].left,1])\\n\\n\\t\\t\\t#Inorder Traversal\\n\\t\\t\\telif n[1]==2:\\n\\t\\t\\t\\tino.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].right:\\n\\t\\t\\t\\t\\tstack.append([n[0].right,1])\\n\\n\\t\\t\\t#Postorder Traversal\\n\\t\\t\\telse:\\n\\t\\t\\t\\tposto.append(n[0].val)\\n\\t\\treturn ino",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef inorderTraversal(self, root):\\n\\n\\t\\tpreo,ino,posto,stack=[],[],[],[[root,1]]\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\twhile stack:\\n\\t\\t\\tn=stack.pop()\\n\\n\\t\\t\\t#Preorder Traversal\\n\\t\\t\\tif n[1]==1:\\n\\t\\t\\t\\tpreo.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].left:\\n\\t\\t\\t\\t\\tstack.append([n[0].left,1])\\n\\n\\t\\t\\t#Inorder Traversal\\n\\t\\t\\telif n[1]==2:\\n\\t\\t\\t\\tino.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].right:\\n\\t\\t\\t\\t\\tstack.append([n[0].right,1])\\n\\n\\t\\t\\t#Postorder Traversal\\n\\t\\t\\telse:\\n\\t\\t\\t\\tposto.append(n[0].val)\\n\\t\\treturn ino",
                "codeTag": "Java"
            },
            {
                "id": 286620,
                "title": "java-morris-traversal-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n\\t/**\\n\\t * Morris inorder traversal\\n\\t * \\n\\t * @param root\\n\\t * @return\\n\\t * @see <a href=\\n\\t *      \"https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\">Inorder\\n\\t *      Tree Traversal without recursion and without stack</a>\\n\\t * @see <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded\\n\\t *      binary tree</a>\\n\\t */\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> r = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn r;\\n\\n\\t\\t// Start from root\\n\\t\\tTreeNode cur = root;\\n\\n\\t\\t// Define a cursor that will be used to find predecessor, link and unlink nodes\\n\\t\\tTreeNode traverseCursor = null;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t/*\\n\\t\\t\\t * Check current node\\'s left child, if the left child node exist, then traverse\\n\\t\\t\\t * through left child\\'s right branch to the bottom, the rightmost leaf node will\\n\\t\\t\\t * be the predecessor of current node, once we find it, we \\'link\\' the\\n\\t\\t\\t * predecessor to current node, i.e., we make current node the right child of\\n\\t\\t\\t * the predecessor\\n\\t\\t\\t */\\n\\t\\t\\tif (cur.left != null) {\\n\\t\\t\\t\\ttraverseCursor = cur.left;\\n\\t\\t\\t\\twhile (traverseCursor.right != null && traverseCursor.right != cur) {\\n\\t\\t\\t\\t\\ttraverseCursor = traverseCursor.right;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == null) {\\n\\t\\t\\t\\t\\t// We found the leaf node, now create the link\\n\\t\\t\\t\\t\\ttraverseCursor.right = cur;\\n\\t\\t\\t\\t\\t// Now move the cursor of current node to its left child\\n\\t\\t\\t\\t\\tcur = cur.left;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == cur) {\\n\\t\\t\\t\\t\\t// This case is indicating we have already visited current node\\'s predecessor by\\n\\t\\t\\t\\t\\t// linking, we need to unlink the nodes to restore the original tree\\n\\t\\t\\t\\t\\ttraverseCursor.right = null;\\n\\t\\t\\t\\t\\t// This case is also indicating we are visiting the successor of the predecessor\\n\\t\\t\\t\\t\\t// i.e., the root\\n\\t\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t\\t// Now visit the right branch\\n\\t\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We reached the node we want to visit\\n\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t// Now we move the cursor to its \\'right\\' child, which was linked to its\\n\\t\\t\\t\\t// successor\\n\\t\\t\\t\\t// by traverseCursor\\n\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t/**\\n\\t * Morris inorder traversal\\n\\t * \\n\\t * @param root\\n\\t * @return\\n\\t * @see <a href=\\n\\t *      \"https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\">Inorder\\n\\t *      Tree Traversal without recursion and without stack</a>\\n\\t * @see <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded\\n\\t *      binary tree</a>\\n\\t */\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> r = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn r;\\n\\n\\t\\t// Start from root\\n\\t\\tTreeNode cur = root;\\n\\n\\t\\t// Define a cursor that will be used to find predecessor, link and unlink nodes\\n\\t\\tTreeNode traverseCursor = null;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t/*\\n\\t\\t\\t * Check current node\\'s left child, if the left child node exist, then traverse\\n\\t\\t\\t * through left child\\'s right branch to the bottom, the rightmost leaf node will\\n\\t\\t\\t * be the predecessor of current node, once we find it, we \\'link\\' the\\n\\t\\t\\t * predecessor to current node, i.e., we make current node the right child of\\n\\t\\t\\t * the predecessor\\n\\t\\t\\t */\\n\\t\\t\\tif (cur.left != null) {\\n\\t\\t\\t\\ttraverseCursor = cur.left;\\n\\t\\t\\t\\twhile (traverseCursor.right != null && traverseCursor.right != cur) {\\n\\t\\t\\t\\t\\ttraverseCursor = traverseCursor.right;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == null) {\\n\\t\\t\\t\\t\\t// We found the leaf node, now create the link\\n\\t\\t\\t\\t\\ttraverseCursor.right = cur;\\n\\t\\t\\t\\t\\t// Now move the cursor of current node to its left child\\n\\t\\t\\t\\t\\tcur = cur.left;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == cur) {\\n\\t\\t\\t\\t\\t// This case is indicating we have already visited current node\\'s predecessor by\\n\\t\\t\\t\\t\\t// linking, we need to unlink the nodes to restore the original tree\\n\\t\\t\\t\\t\\ttraverseCursor.right = null;\\n\\t\\t\\t\\t\\t// This case is also indicating we are visiting the successor of the predecessor\\n\\t\\t\\t\\t\\t// i.e., the root\\n\\t\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t\\t// Now visit the right branch\\n\\t\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We reached the node we want to visit\\n\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t// Now we move the cursor to its \\'right\\' child, which was linked to its\\n\\t\\t\\t\\t// successor\\n\\t\\t\\t\\t// by traverseCursor\\n\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548362,
                "title": "python-recursive-and-iterative-solutions",
                "content": "# Recursive Solution\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        def inorder(node):\\n            if not node: return\\n            inorder(node.left)\\n            A.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        return A\\n```\\n\\n# Iterative solution\\nSame idea, exhaust left sub trees, then pop the current, add to the answer and repeat the logic for right subtree (in order)\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            \\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                A.append(node.val)\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n        \\n        return A\\n```\\n\\n# Generator function\\nNote that you can turn the iterative solution into a generator function by yielding the result.\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                yield node.val\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n```\\n\\n# Appendix\\nOne could solve the problem in constant space O(1) using morris traversal.\\nRefer to this link for more info: https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        def inorder(node):\\n            if not node: return\\n            inorder(node.left)\\n            A.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        return A\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            \\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                A.append(node.val)\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n        \\n        return A\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                yield node.val\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547698,
                "title": "2-ways-of-0ms-java-solution",
                "content": "**Recursion**\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        solve(res,root);\\n        return res;\\n    }\\n    \\n    private void solve(List<Integer> res, TreeNode root){\\n        if(root == null) return;\\n        \\n\\t\\t// Traverse left node\\n        solve(res, root.left);\\n\\t\\t\\n\\t\\t// Traverse parent node\\n        res.add(root.val);\\n\\t\\t\\n\\t\\t// Traverse right node\\n        solve(res, root.right);\\n    }\\n}\\n```\\n\\n**Using Stack**\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(curr != null || stack.size() != 0){\\n            \\n            // Move to the left-most node of the tree and push them in stack for future traversal\\n            while(curr != null){\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Left node\\n            curr = stack.pop();\\n            \\n            // Parent node\\n            res.add(curr.val);\\n            \\n            // Right node\\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n<br/>\\n\\n**Kotlin Version**\\n\\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        inorder(root,res)\\n        return res\\n    }\\n    \\n    private fun inorder(node:TreeNode?, res : MutableList<Int>){\\n        node?.let{\\n            inorder(node.left,res)\\n            res.add(node.`val`)\\n            inorder(node.right,res)\\n        }\\n    }\\n}\\n```\\n\\n**Using Stack**\\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        \\n        var curr = root\\n        val stack = Stack<TreeNode>()\\n        \\n        while(curr != null || stack.size != 0){\\n            while(curr!=null){\\n                stack.push(curr)\\n                curr = curr.left\\n            }\\n            curr = stack.pop()\\n            res.add(curr.`val`)\\n            curr = curr.right\\n        }   \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        solve(res,root);\\n        return res;\\n    }\\n    \\n    private void solve(List<Integer> res, TreeNode root){\\n        if(root == null) return;\\n        \\n\\t\\t// Traverse left node\\n        solve(res, root.left);\\n\\t\\t\\n\\t\\t// Traverse parent node\\n        res.add(root.val);\\n\\t\\t\\n\\t\\t// Traverse right node\\n        solve(res, root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(curr != null || stack.size() != 0){\\n            \\n            // Move to the left-most node of the tree and push them in stack for future traversal\\n            while(curr != null){\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Left node\\n            curr = stack.pop();\\n            \\n            // Parent node\\n            res.add(curr.val);\\n            \\n            // Right node\\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        inorder(root,res)\\n        return res\\n    }\\n    \\n    private fun inorder(node:TreeNode?, res : MutableList<Int>){\\n        node?.let{\\n            inorder(node.left,res)\\n            res.add(node.`val`)\\n            inorder(node.right,res)\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        \\n        var curr = root\\n        val stack = Stack<TreeNode>()\\n        \\n        while(curr != null || stack.size != 0){\\n            while(curr!=null){\\n                stack.push(curr)\\n                curr = curr.left\\n            }\\n            curr = stack.pop()\\n            res.add(curr.`val`)\\n            curr = curr.right\\n        }   \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986517,
                "title": "swift-0-ms-2-lines-recursive",
                "content": "```\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969561,
                "title": "c-3-method-recursive-iterative-using-stack-morris-traversal-threaded-binary-tree",
                "content": "Recall: Inorder= Left, Root Node, Right\\n\\n**1st Approach:** Using recursion\\nWe use a helper function to traverse recursively \\n\\n```\\nclass Solution {\\npublic:\\n        void inorder(TreeNode* root, vector<int>& res){\\n        if (root){\\n            inorder (root->left, res);\\n            res.push_back(root->val);\\n            inorder (root->right, res);\\n        }\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> p;\\n        inorder (root, p);\\n        return p;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n**2nd Approach:** Iteratively using Stack\\nUnlike recursively which used the internal stack, we would explicitly use a stack to keep a track of nodes\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector < int > inOrder;\\n        stack < TreeNode* > s;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                s.push(curr);\\n                curr = curr -> left;\\n            } else\\n            {\\n                if (s.empty()) break;\\n                curr = s.top();\\n                inOrder.push_back(curr -> val);\\n                s.pop();\\n                curr = curr -> right;\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n**3rd Approach:** Using morris traversal i.e, applying the concept of threaded binary tree.\\n\\nExplanation: Here we are wisely creating a thread between the current node and its inorder predecessor so that we can visit back the current node, as there are no parent pointer in the binary tree strucure nor recursion stack which did this task in previous approaches.\\n\\n![image](https://assets.leetcode.com/users/images/0f962cd3-ceb9-43ef-91ec-b79acbe9394d_1650542250.3279028.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode *cur = root;\\n        vector<int> inorder;\\n        while (cur != NULL)\\n        {\\n            if (cur->left == NULL)//no left node then directly push in inorder and go right\\n            {\\n                inorder.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n            else//there is a left node\\n            {\\n                //find inorder predecessor\\n                TreeNode* predecessor = cur->left;//predecessor will be the rightmost of left until it reaches null or back to the current node (as we might have already created thread from it.\\n                while (predecessor->right != cur && predecessor->right != NULL)\\n                    predecessor = predecessor->right;\\n                if (predecessor->right == NULL)//thread creation as visiting first time\\n                {\\n                    predecessor->right = cur;\\n                    cur = cur-> left;\\n                }\\n                else//thread deletion to avoid cycle and pushing node in inorder\\n                {\\n                    predecessor->right = NULL;\\n                    inorder.push_back(cur->val);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return inorder;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: **O(1)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        void inorder(TreeNode* root, vector<int>& res){\\n        if (root){\\n            inorder (root->left, res);\\n            res.push_back(root->val);\\n            inorder (root->right, res);\\n        }\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> p;\\n        inorder (root, p);\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector < int > inOrder;\\n        stack < TreeNode* > s;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                s.push(curr);\\n                curr = curr -> left;\\n            } else\\n            {\\n                if (s.empty()) break;\\n                curr = s.top();\\n                inOrder.push_back(curr -> val);\\n                s.pop();\\n                curr = curr -> right;\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode *cur = root;\\n        vector<int> inorder;\\n        while (cur != NULL)\\n        {\\n            if (cur->left == NULL)//no left node then directly push in inorder and go right\\n            {\\n                inorder.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n            else//there is a left node\\n            {\\n                //find inorder predecessor\\n                TreeNode* predecessor = cur->left;//predecessor will be the rightmost of left until it reaches null or back to the current node (as we might have already created thread from it.\\n                while (predecessor->right != cur && predecessor->right != NULL)\\n                    predecessor = predecessor->right;\\n                if (predecessor->right == NULL)//thread creation as visiting first time\\n                {\\n                    predecessor->right = cur;\\n                    cur = cur-> left;\\n                }\\n                else//thread deletion to avoid cycle and pushing node in inorder\\n                {\\n                    predecessor->right = NULL;\\n                    inorder.push_back(cur->val);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return inorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548841,
                "title": "c-solution",
                "content": "****Runtime: 0 ms, faster than 100.00% of C online submissions for Binary Tree Inorder Traversal.\\nMemory Usage: 5.9 MB, less than 68.48% of C online submissions for Binary Tree Inorder Traversal.\\n```\\nvoid travel(struct TreeNode* root,int*ret,int*size){\\n    if(root==NULL)\\n        return 0 ;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n        return ret;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid travel(struct TreeNode* root,int*ret,int*size){\\n    if(root==NULL)\\n        return 0 ;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n        return ret;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359114,
                "title": "recursive-python-3-lines-of-code",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259828,
                "title": "2-line-javascript-solution-faster-than-81",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    if (!root) return []\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    if (!root) return []\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 960715,
                "title": "python-iterative",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        traversal = []\\n\\n        node = root\\n        stack = []\\n        while node or stack:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                traversal.append(node.val)\\n                node = node.right\\n                \\n        return traversal\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        traversal = []\\n\\n        node = root\\n        stack = []\\n        while node or stack:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                traversal.append(node.val)\\n                node = node.right\\n                \\n        return traversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31380,
                "title": "recommend-by-rainbow-morris-traversal-and-time-complexity-analysis-why-o-n",
                "content": "**Update : 2016/02/26**\\n\\nabout why the time complexity of the Morris traversal is O(n) maybe confusing !\\n\\nHere is the details you need to understand the time complexity is O(N) as each edge is traversed for 3 times at most.\\n\\n       Each edge is traversed at most 3 times and there are n-1 edges in a tree,\\n       hence the O(n).\\n\\nI think the part that is confusing you is the predecessor finding loop because it goes down the tree following the rightmost node.\\n\\n            /* Find the inorder predecessor of current */\\n          pre = current->left;\\n          while (pre->right != NULL && pre->right != current)\\n          pre = pre->right;\\n\\n\\nThis full path is only processed twice: \\nwhen the current pointer reaches the node\\nwhen we have processed its left subtree\\n\\nAlso, the key is that this path is not processed again while we're on the left subtree.\\n\\nYou can see a simple example here .\\n\\n[https://www.quora.com/Why-does-the-Morris-in-order-traversal-algorithm-have-O-n-time-complexity][1]\\n\\nMorris traversal is a cheap way to do the traversal of the tree with no Space cost and non-recursive way.\\n\\nBut at first, it may seem hard for you to understand.\\n\\nThe key idea is to traversal as in-order, when meet the node with left child, then we will\\n\\ntraverse to find the pre-node of the current node and link it to the current node. \\n\\nSo after push back the in-order first node,  it will back track by the previous setting \"right link\"!\\n\\nSo when we meet the \"right link\"  for the next time, we will reset it and push back the value.\\n\\nSo we link the tree value and get the final vector result.\\n\\n         1. Initialize current as root \\n         2. While current is not NULL\\n                   If current does not have left child\\n                         a) Print current\\u2019s data\\n                         b) Go to the right, i.e., current = current->right\\n                   Else\\n                         a) Make current as right child of the rightmost node in current's left subtree\\n                         b) Go to this left child, i.e., current = current->left\\n\\nAC C++  implementation .\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            TreeNode* cur, *pre;\\n            vector<int> result;\\n            if(!root)  return  result;\\n            \\n            cur=root;\\n            while(cur){\\n                /** move left **/\\n                if(cur->left){\\n                    /** find the previous node of the cur **/\\n                   pre=cur->left;\\n                   while(pre->right && pre->right!=cur)  pre=pre->right;\\n                   /** if not set, keep traversal **/\\n                   if(!pre->right){\\n                       pre->right=cur;\\n                       cur=cur->left;\\n                   }\\n                   /** if set, push back the value, and keep traversal **/\\n                   else{\\n                       pre->right=NULL;\\n                       result.push_back(cur->val);\\n                       cur=cur->right;\\n                   }\\n                }\\n                /** push_back the root value move right (previous set right link will point \\n                    to the in-order-next node)**/\\n                else{\\n                    result.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://www.quora.com/Why-does-the-Morris-in-order-traversal-algorithm-have-O-n-time-complexity",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            TreeNode* cur, *pre;\\n            vector<int> result;\\n            if(!root)  return  result;\\n            \\n            cur=root;\\n            while(cur){\\n                /** move left **/\\n                if(cur->left){\\n                    /** find the previous node of the cur **/\\n                   pre=cur->left;\\n                   while(pre->right && pre->right!=cur)  pre=pre->right;\\n                   /** if not set, keep traversal **/\\n                   if(!pre->right){\\n                       pre->right=cur;\\n                       cur=cur->left;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 3931235,
                "title": "easy-c-solution-dfs-bfs-and-morris-traversal-beats-100",
                "content": "# Code\\n```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *curr = root;\\n\\n        while(true){\\n            if(curr != NULL){\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else if(s.empty())\\n                break;\\n            else{\\n                ans.push_back(s.top()->val);\\n                curr = s.top()->right;\\n                s.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<int> ans;\\n        TreeNode *curr = root, *pre;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{   // pre->right == curr\\n                    pre->right = NULL;\\n                    ans.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *curr = root;\\n\\n        while(true){\\n            if(curr != NULL){\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else if(s.empty())\\n                break;\\n            else{\\n                ans.push_back(s.top()->val);\\n                curr = s.top()->right;\\n                s.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<int> ans;\\n        TreeNode *curr = root, *pre;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{   // pre->right == curr\\n                    pre->right = NULL;\\n                    ans.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431301,
                "title": "in-order-traversing-in-python-python3",
                "content": "# Approach\\nAs Inorder traversing a Binary tree, first we have to travse the left tree nodes than root node and than at the last right tree nodes.\\nUsing recursive model for this solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053456,
                "title": "c-short-simple-recursion",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==nullptr){return;}\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return v;    \\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==nullptr){return;}\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return v;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827145,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035548,
                "title": "java-script-solution-using-recursion",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    if(root === null) return [];\\n    return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)];\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    if(root === null) return [];\\n    return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1778180,
                "title": "python-recursive-one-liner",
                "content": "```\\nclass Solution:\\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437870,
                "title": "js-heavily-commented-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    // In-Order Traversal ->\\n    //  1. Recursively traverse through the left subtree\\n    //  2. Visit current node\\n    //  3. Recursively traverse through the right subtree\\n    \\n    // Initialize array of values\\n    let result = [];\\n    \\n    // Recursive function to traverse through subtrees\\n    inorder(root, result);\\n    \\n    return result;\\n};\\n\\nconst inorder = (node, result) => {\\n    if (!node) return null;\\n    inorder(node.left, result); // Traverse through left subtree\\n    result.push(node.val); // Visit node\\n    inorder(node.right, result); // Traverse through right subtree\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    // In-Order Traversal ->\\n    //  1. Recursively traverse through the left subtree\\n    //  2. Visit current node\\n    //  3. Recursively traverse through the right subtree\\n    \\n    // Initialize array of values\\n    let result = [];\\n    \\n    // Recursive function to traverse through subtrees\\n    inorder(root, result);\\n    \\n    return result;\\n};\\n\\nconst inorder = (node, result) => {\\n    if (!node) return null;\\n    inorder(node.left, result); // Traverse through left subtree\\n    result.push(node.val); // Visit node\\n    inorder(node.right, result); // Traverse through right subtree\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 706892,
                "title": "python-morris-traversal",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        curr = root\\n        res = []\\n        while curr:\\n            if curr.left:\\n                pre = curr.left\\n                while pre.right and pre.right!=curr:\\n                    pre = pre.right\\n                if pre.right == curr:\\n                    pre.right = None\\n                    res.append(curr.val)\\n                    curr = curr.right\\n                else:\\n                    pre.right = curr\\n                    curr = curr.left\\n            else:\\n                res.append(curr.val)\\n                curr = curr.right\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        curr = root\\n        res = []\\n        while curr:\\n            if curr.left:\\n                pre = curr.left\\n                while pre.right and pre.right!=curr:\\n                    pre = pre.right\\n                if pre.right == curr:\\n                    pre.right = None\\n                    res.append(curr.val)\\n                    curr = curr.right\\n                else:\\n                    pre.right = curr\\n                    curr = curr.left\\n            else:\\n                res.append(curr.val)\\n                curr = curr.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546002,
                "title": "easy-to-understand-iterative-and-recursive-faster-simple-python-solution",
                "content": "```\\ndef iterative(self, root):\\n        out = []\\n        stack = []\\n        top = root\\n        while top or len(stack):\\n            while top:\\n                stack.append(top)\\n                top = top.left\\n            top = stack.pop()\\n            out.append(top.val)\\n            top = top.right\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                rec(root.left)\\n                out.append(root.val)\\n                rec(root.right)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n```\\n\\n**I hope that you\\'ve found them useful.**\\n\\t*In that case, please do upvote. It motivates me to write more such post\\uD83D\\uDE03*",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef iterative(self, root):\\n        out = []\\n        stack = []\\n        top = root\\n        while top or len(stack):\\n            while top:\\n                stack.append(top)\\n                top = top.left\\n            top = stack.pop()\\n            out.append(top.val)\\n            top = top.right\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                rec(root.left)\\n                out.append(root.val)\\n                rec(root.right)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31386,
                "title": "c-0ms-stack-based-solution",
                "content": "    class Solution {\\n    public:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        vector<TreeNode*> stack;\\n        TreeNode *cur=root;\\n        while (cur!=NULL || !stack.empty()){\\n            if (cur){\\n                stack.push_back(cur);\\n                cur = cur->left;\\n            }\\n            else {\\n                cur = stack.back();\\n                stack.pop_back();\\n                res.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n        }\\n        return res;\\n    } \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        vector<TreeNode*> stack;\\n        TreeNode *cur=root;\\n        while (cur!=NULL || !stack.empty()){\\n            if (cur){\\n                stack.push_back(cur);\\n                cur = cur->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31402,
                "title": "java-1ms-both-iterative-and-recursive",
                "content": "The recursive solution is trivial, yet the iterative solution with an explicit stack helps us better understand what is going on with the stack in the recursive solution.\\n\\n    public class Solution {\\n        public List<Integer> inorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            inorderTraversalRecursive(root, result);\\n            //inorderTraversalIterative(root, result);\\n            return result;\\n        }\\n        \\n        private void inorderTraversalIterative(TreeNode root, List<Integer> result) {\\n            LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\\n            TreeNode curr = root;\\n            while (curr != null || !stack.isEmpty()) {\\n                if (curr != null) {\\n                    stack.offerLast(curr);\\n                    curr = curr.left;\\n                } else {\\n                    result.add(stack.getLast().val);\\n                    curr = stack.getLast().right;\\n                    stack.pollLast();\\n                }\\n            }\\n        }\\n        \\n        private void inorderTraversalRecursive(TreeNode root, List<Integer> result) {\\n            if (root == null) {\\n                return;\\n            }\\n            inorderTraversalRecursive(root.left, result);\\n            result.add(root.val);\\n            inorderTraversalRecursive(root.right, result);        \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> inorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            inorderTraversalRecursive(root, result);\\n            //inorderTraversalIterative(root, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31478,
                "title": "my-accepted-solution-in-python",
                "content": "    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = []\\n            output = []\\n            while True:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                if stack == []:\\n                    break\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n            return output",
                "solutionTags": [],
                "code": "    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = []\\n            output = []\\n            while True:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                if stack == []:\\n                    break\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n            return output",
                "codeTag": "Java"
            },
            {
                "id": 3202461,
                "title": "c-recursive-easy-solution-beats-100",
                "content": "# Intuition\\nRecursive Solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        inorder(root->left,vct);\\n        vct.push_back(root->val);\\n        inorder(root->right,vct);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        inorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        inorder(root->left,vct);\\n        vct.push_back(root->val);\\n        inorder(root->right,vct);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        inorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187656,
                "title": "91-35-binary-tree-inorder-traversal-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea is to traverse the binary tree in an inorder fashion using a stack. We start with the root node and keep going to the left child until we reach a leaf node. Then, we backtrack and process the node by popping it from the stack, appending its value to the result, and moving to its right child. We repeat this process until the stack is empty and we have processed all the nodes in the tree.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n91.35%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        # Initialize an empty stack to store the nodes\\n        stack = []\\n        # Initialize an empty list to store the result\\n        result = []\\n        # Start with the root node\\n        curr = root\\n        # Loop until the stack is empty or curr is None\\n        while stack or curr:\\n            # If curr is not None, push it onto the stack and move to its left child\\n            if curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            # If curr is None, pop a node from the stack, append its value to the result, and move to its right child\\n            else:\\n                curr = stack.pop()\\n                result.append(curr.val)\\n                curr = curr.right\\n        # Return the result\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        # Initialize an empty stack to store the nodes\\n        stack = []\\n        # Initialize an empty list to store the result\\n        result = []\\n        # Start with the root node\\n        curr = root\\n        # Loop until the stack is empty or curr is None\\n        while stack or curr:\\n            # If curr is not None, push it onto the stack and move to its left child\\n            if curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            # If curr is None, pop a node from the stack, append its value to the result, and move to its right child\\n            else:\\n                curr = stack.pop()\\n                result.append(curr.val)\\n                curr = curr.right\\n        # Return the result\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185647,
                "title": "c-easy-solution-using-recursion-explained",
                "content": "# Intuition\\nIn-Order Traversal is a Depth First Search Algorithm of traversal in Binary Trees. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# DFS Traversal Algorithms \\n- [In-Order Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/post-solution/3185647/) \\n- [Post-Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3185653/c-easy-solution-using-recursion-explained/)\\n- [Pre-Order Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3185665/c-easy-solution-using-recursion-explained/)\\n\\n# Approach\\nIn-Order Traversal -> L N R\\n1. Traverse the left subtree\\n2. Print/Store the node \\n3. Traverse the right subtree\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// InOrder Traversal -> L N R \\n// Traverse the left subtree till NULL (Base Case), print/store the node, traverse the right subtree(till NULL - Base Case)\\n    void inOrder (TreeNode *node, vector<int> &result)\\n    {\\n        if (node == NULL)\\n        {\\n            return ;\\n        }\\n\\n        inOrder (node -> left, result) ; \\n        result.push_back(node -> val) ; \\n        inOrder (node -> right, result) ;\\n\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result ; \\n\\n        inOrder (root, result) ; \\n        return result ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/a558e75a-a201-4602-887b-3d5314b6875f_1676391339.7404554.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// InOrder Traversal -> L N R \\n// Traverse the left subtree till NULL (Base Case), print/store the node, traverse the right subtree(till NULL - Base Case)\\n    void inOrder (TreeNode *node, vector<int> &result)\\n    {\\n        if (node == NULL)\\n        {\\n            return ;\\n        }\\n\\n        inOrder (node -> left, result) ; \\n        result.push_back(node -> val) ; \\n        inOrder (node -> right, result) ;\\n\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result ; \\n\\n        inOrder (root, result) ; \\n        return result ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163094,
                "title": "simple-java-100-easy-comments-readable-beginners-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976367,
                "title": "best-c-code-out-there-memory-100-optimized",
                "content": "class Solution {\\n     private : vector<int>res;\\n    void inorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        return;\\n    }\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n     private : vector<int>res;\\n    void inorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1724132,
                "title": "python-3-25ms-perfect-pythonic-recursive-one-liner-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return  self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return  self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588635,
                "title": "javascript-one-liner",
                "content": "```javascript\\nvar inorderTraversal = function(root) {\\n    return !root ? [] : [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nvar inorderTraversal = function(root) {\\n    return !root ? [] : [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348586,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300339,
                "title": "c-recursive-solution-in-o-n-time",
                "content": "#Trees - **Binary Tree Inorder Traversal**\\n\\n\\uD83D\\uDC49 Recursive solution: `O(n)` time and `O(n)` space (function call stack);\\n\\nHere, We just traverse in such a way that after making left call we push the value at that point in the the vector and then make the right call. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void traverse(TreeNode* root, vector<int> &ans)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->left) \\n            traverse(root->left, ans);\\n        \\n        ans.push_back(root->val);  \\n        \\n        if(root->right)\\n            traverse(root->right, ans);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n            traverse(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\u2728 Alternate Approach : Try solving Iteratively using stack: `O(n)` time and `O(n)` space",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void traverse(TreeNode* root, vector<int> &ans)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->left) \\n            traverse(root->left, ans);\\n        \\n        ans.push_back(root->val);  \\n        \\n        if(root->right)\\n            traverse(root->right, ans);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n            traverse(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048556,
                "title": "java-3-solutions-with-explanation-recursive-iterative-using-stack-iterative-without-stack",
                "content": "The idea is simple for in-order traversal -\\n1. traverse the left sub-tree\\n2. visit the node\\n3. traverse the right sub-tree\\n\\nThis process is done recursively for each node in the tree.\\n\\n#### Recursive\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> inOrderList = new ArrayList<>();\\n        inOrder(root, inOrderList);\\n        return inOrderList;\\n    }\\n    \\n    private void inOrder(TreeNode node, List<Integer> list){\\n        if(node != null){\\n            inOrder(node.left, list);\\n            list.add(node.val);\\n            inOrder(node.right, list);\\n        }\\n    }\\n}\\n```\\n\\nThe same idea of recursion can be implemented using stack as well.\\n\\n#### Iterative using Stack\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> listInOrder = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        \\n        while(curr != null || !stack.isEmpty()){\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else{\\n                curr = stack.pop();\\n                listInOrder.add(curr.val);\\n                curr = curr.right;                    \\n            }\\n        }\\n        return listInOrder;\\n    }\\n}\\n```\\n\\n#### Iterative (Without Stack) - Morris Traversal in Threaded BST\\n\\nThis idea is slightly different than the other two but is relatively simple. Instead of using a stack (or recursion) for revisiting the current node again to traverse the right subtree, we update the right pointer of the in-order predecessor to point to the current node even before we start doing the in-order traversal on a node. Later we get rid of this pointer when all nodes of the left sub-tree is completely visited to leave the tree back in its original state.\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            if(curr.left == null){\\n                list.add(curr.val);\\n                curr = curr.right;\\n            } else {\\n                TreeNode predecessor = curr.left;\\n                while(predecessor.right != null && predecessor.right != curr)\\n                    predecessor = predecessor.right;\\n                if(predecessor.right == null){\\n                    predecessor.right = curr;\\n                    curr = curr.left;\\n                } else {\\n                    predecessor.right = null;\\n                    list.add(curr.val);\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> inOrderList = new ArrayList<>();\\n        inOrder(root, inOrderList);\\n        return inOrderList;\\n    }\\n    \\n    private void inOrder(TreeNode node, List<Integer> list){\\n        if(node != null){\\n            inOrder(node.left, list);\\n            list.add(node.val);\\n            inOrder(node.right, list);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> listInOrder = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        \\n        while(curr != null || !stack.isEmpty()){\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else{\\n                curr = stack.pop();\\n                listInOrder.add(curr.val);\\n                curr = curr.right;                    \\n            }\\n        }\\n        return listInOrder;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            if(curr.left == null){\\n                list.add(curr.val);\\n                curr = curr.right;\\n            } else {\\n                TreeNode predecessor = curr.left;\\n                while(predecessor.right != null && predecessor.right != curr)\\n                    predecessor = predecessor.right;\\n                if(predecessor.right == null){\\n                    predecessor.right = curr;\\n                    curr = curr.left;\\n                } else {\\n                    predecessor.right = null;\\n                    list.add(curr.val);\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847780,
                "title": "c-recursive",
                "content": "```\\nint cnt(struct TreeNode* root)\\n{\\n    if(root)\\n        return 1 + cnt(root->left) + cnt(root->right);\\n    return 0;\\n}\\n\\nvoid inorder(struct TreeNode* root, int** res)\\n{\\n    if(root)\\n    {\\n        inorder(root->left, res);\\n        *((*res)++) = root->val;\\n        inorder(root->right, res);\\n    }\\n}\\n\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    \\n    *returnSize = cnt(root);\\n    int* res = (int*)malloc(((*returnSize)) * sizeof(int));\\n    memset(res, 0, (*returnSize) * sizeof(int));   \\n    int *cpy = res;\\n    inorder(root, &cpy);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cnt(struct TreeNode* root)\\n{\\n    if(root)\\n        return 1 + cnt(root->left) + cnt(root->right);\\n    return 0;\\n}\\n\\nvoid inorder(struct TreeNode* root, int** res)\\n{\\n    if(root)\\n    {\\n        inorder(root->left, res);\\n        *((*res)++) = root->val;\\n        inorder(root->right, res);\\n    }\\n}\\n\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    \\n    *returnSize = cnt(root);\\n    int* res = (int*)malloc(((*returnSize)) * sizeof(int));\\n    memset(res, 0, (*returnSize) * sizeof(int));   \\n    int *cpy = res;\\n    inorder(root, &cpy);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632114,
                "title": "c-easy-iterative-and-recurive-solution-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Recursive Method\\n    \\n    vector <int> ans;\\n    void inorder(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        inorder(root);\\n        return ans;\\n    }\\n    \\n    \\n    // Iterative method\\n    \\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        TreeNode *ptr = root;\\n        vector <int> ans;\\n        stack <TreeNode*> address;\\n        \\n        if(root == NULL)\\n            return ans;\\n        \\n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\\n        while( !address.empty() || ptr != NULL )\\n        {\\n            // if ptr points to a child\\n            if(ptr != NULL)\\n            {\\n                // pushing the address to the stack\\n                address.push(ptr);\\n                // moving left\\n                ptr = ptr->left;                    // LEFT\\n            }\\n            else\\n            {\\n                // popping the address and making ptr point to it, kinda backtrack a step\\n                ptr = address.top();\\n                address.pop();\\n                // printing or pushing the value of node to array\\n                ans.push_back(ptr->val);            // PRINT\\n                // movinf left\\n                ptr= ptr->right;                    // RIGHT\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Recursive Method\\n    \\n    vector <int> ans;\\n    void inorder(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        inorder(root);\\n        return ans;\\n    }\\n    \\n    \\n    // Iterative method\\n    \\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        TreeNode *ptr = root;\\n        vector <int> ans;\\n        stack <TreeNode*> address;\\n        \\n        if(root == NULL)\\n            return ans;\\n        \\n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\\n        while( !address.empty() || ptr != NULL )\\n        {\\n            // if ptr points to a child\\n            if(ptr != NULL)\\n            {\\n                // pushing the address to the stack\\n                address.push(ptr);\\n                // moving left\\n                ptr = ptr->left;                    // LEFT\\n            }\\n            else\\n            {\\n                // popping the address and making ptr point to it, kinda backtrack a step\\n                ptr = address.top();\\n                address.pop();\\n                // printing or pushing the value of node to array\\n                ans.push_back(ptr->val);            // PRINT\\n                // movinf left\\n                ptr= ptr->right;                    // RIGHT\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467789,
                "title": "one-code-pattern-for-3-leetcode-questions-c",
                "content": "**The In-Order code pattern below can be used to solve three different Leetcode problems. The othe**r **questions also require In-Order Traversal**\\n\\n**IN-ORDER TRAVERSAL - USING STACKS**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*TIME = O(N) \\nSPACE = O(N)*\\n\\n**VALIDATE A BINARY TREE**\\n\\n```class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root)\\n    {\\n        if(root==NULL) return true;\\n        stack<TreeNode*> s;\\n        TreeNode *prev=NULL;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();  s.pop();\\n            if(prev!=NULL && root->val <= prev->val) \\n                return false;\\n            prev=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\n*TIME = O(N)\\nWhen bad element is in the rightmost leaf*\\n*SPACE = O(N)*\\n\\n**FIND THE K-th SMALLEST ELEMENT IN A BT**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(); s.pop();\\n            if(--k ==0) \\n                break;\\n            root=root->right;\\n        }        \\n        return root->val;\\n    }\\n};\\n```\\n\\n*TIME = O(H+k)*\\n*where H is a tree height. This complexity is defined by the stack, which contains at least H + k elements, since* *before starting to pop out one has to go down to a leaf. This results in O(logN+k) for the balanced tree and O(N+k) for completely unbalanced tree with all the nodes in the left subtree.*\\n\\n*SPACE = O(H+k)\\nworst case (space) = O(N+k)\\nAverage case (space)= O(logn +k)*\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root)\\n    {\\n        if(root==NULL) return true;\\n        stack<TreeNode*> s;\\n        TreeNode *prev=NULL;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();  s.pop();\\n            if(prev!=NULL && root->val <= prev->val) \\n                return false;\\n            prev=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(); s.pop();\\n            if(--k ==0) \\n                break;\\n            root=root->right;\\n        }        \\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234471,
                "title": "python3-100-using-iteration-readable",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: \\'TreeNode\\') -> \\'List[int]\\':\\n        if not root:\\n            return []\\n        stack = list()\\n        output = list()\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: \\'TreeNode\\') -> \\'List[int]\\':\\n        if not root:\\n            return []\\n        stack = list()\\n        output = list()\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31332,
                "title": "why-every-solution-is-using-2-while-loops-the-standard-iterative-solution-shoule-only-has-one-while-loop",
                "content": "```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer> ();\\n        if (root == null) return res;\\n        \\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        TreeNode n = root;\\n        \\n        while (n != null || !s.isEmpty()) {\\n            if  (n != null) {\\n                s.push(n);\\n                n = n.left;\\n            }\\n            else {\\n                TreeNode l = s.pop();\\n                res.add(l.val);\\n                n = l.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer> ();\\n        if (root == null) return res;\\n        \\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        TreeNode n = root;\\n        \\n        while (n != null || !s.isEmpty()) {\\n            if  (n != null) {\\n                s.push(n);\\n                n = n.left;\\n            }\\n            else {\\n                TreeNode l = s.pop();\\n                res.add(l.val);\\n                n = l.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31344,
                "title": "javascript-solution",
                "content": "`````\\nvar inorderTraversal = function(root) {\\n    var stack = [],\\n        res = [];\\n    \\n    while(true){\\n        if(root !== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            if(stack.length === 0) break;\\n            root = stack.pop();\\n            res.push(root.val);\\n            root = root.right;\\n        }\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [],
                "code": "`````\\nvar inorderTraversal = function(root) {\\n    var stack = [],\\n        res = [];\\n    \\n    while(true){\\n        if(root !== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            if(stack.length === 0) break;\\n            root = stack.pop();\\n            res.push(root.val);\\n            root = root.right;\\n        }\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3626483,
                "title": "1-line-solution-python",
                "content": "# Approach\\n1. The function begins with a base case check: `[] if not root`. If the `root` node is `None` (i.e., there is no tree), an empty list `[]` is returned.\\n\\n2. If the `root` node is not `None`, the function recursively calls itself to perform an inorder traversal on the left subtree: `self.inorderTraversal(root.left)`. This step visits all the nodes in the left subtree in the inorder sequence.\\n\\n3. After the recursive call for the left subtree, the value of the `root` node is appended to the result list using `[root.val]`.\\n\\n4. Finally, the function recursively calls itself to perform an inorder traversal on the right subtree: `self.inorderTraversal(root.right)`. This step visits all the nodes in the right subtree in the inorder sequence.\\n\\n5. The function returns the concatenation of the left subtree traversal, the `root` value, and the right subtree traversal: `self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)`.\\n\\nThis approach utilizes the recursive nature of the inorder traversal. It recursively traverses the left subtree, visits the current node, and then recursively traverses the right subtree. The base case handles the empty tree, and the concatenation of the traversal results builds the final inorder traversal list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return [] if not root else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)                       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return [] if not root else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)                       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436598,
                "title": "simple-c-solution",
                "content": "# Inorder -> Left Node Right\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\\n# Iterative\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode *> st;\\n        while(true){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()){\\n                    break;\\n                }\\n                root=st.top();\\n                res.push_back(root->val);\\n                st.pop();\\n                root=root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Recursive\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &res, TreeNode *root){\\n        if(root==NULL){\\n            return ;\\n        }\\n        helper(res,root->left);\\n        res.push_back(root->val);\\n        helper(res,root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        helper(res,root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode *> st;\\n        while(true){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()){\\n                    break;\\n                }\\n                root=st.top();\\n                res.push_back(root->val);\\n                st.pop();\\n                root=root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &res, TreeNode *root){\\n        if(root==NULL){\\n            return ;\\n        }\\n        helper(res,root->left);\\n        res.push_back(root->val);\\n        helper(res,root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        helper(res,root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300936,
                "title": "easiest-solution-out-there-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up vote -> \\uD83D\\uDE2D\\n# Code\\n```\\n\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            inorderTraversal(root.left);\\n            list.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            inorderTraversal(root.left);\\n            list.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268031,
                "title": "beats-100-use-of-recursion-in-java",
                "content": "\\n\\n# Approach\\nThis is a Java program that solves the problem of traversing a binary tree in an inorder manner. The input to the program is a binary tree, represented using the TreeNode class. The TreeNode class has three fields: val, left, and right. The val field stores the value of the node, while the left and right fields store references to the left and right subtrees, respectively. The program returns a list of integers representing the inorder traversal of the binary tree.\\n\\nThe solution implements the inorder traversal recursively using the helper function func. The function takes two arguments: the current node being traversed (root) and the list to which the values are to be added (ans). The traversal is done as follows:\\n\\n1. If the current node is null, return.\\n2. Recursively traverse the left subtree.\\n3. Add the value of the current node to the list.\\n4. Recursively traverse the right subtree.\\n\\n\\n\\nThe main function, inorderTraversal, initializes an empty list ans and calls the helper function func with the root node and the list. Finally, the function returns the list containing the inorder traversal of the binary tree.\\n\\nOverall, the program is an implementation of the classic inorder traversal algorithm for binary trees\\n# Complexity\\n- Time complexity: \\nO(N), where N is the number of nodes in the binary tree. This is because the function visits each node exactly once.\\n\\n\\n- Space complexity:\\nO(N), where N is the number of nodes in the binary tree. This is because the maximum depth of the recursion is equal to the height of the binary tree, and in the worst case, the binary tree can be a degenerate tree, which means that it has N nodes and a height of N. In this case, the recursion would use O(N) space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        func(root,ans);\\n        return ans;\\n    }\\n    public void func(TreeNode root,List<Integer> ans){\\n        if(root==null){\\n            return;\\n        }\\n        func(root.left,ans);\\n        ans.add(root.val);\\n        func(root.right,ans);\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/2c79ad82-a411-4e0d-9b03-481e726b3c16_1678181469.338393.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        func(root,ans);\\n        return ans;\\n    }\\n    public void func(TreeNode root,List<Integer> ans){\\n        if(root==null){\\n            return;\\n        }\\n        func(root.left,ans);\\n        ans.add(root.val);\\n        func(root.right,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168608,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecurive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        inorder(root->left, nodes);\\n        nodes.push_back(root->val);\\n        inorder(root->right, nodes);    \\n    }    \\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> inorder;\\n        if (root == NULL)\\n            return inorder;\\n        stack <TreeNode* > st;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            } else {\\n                if (st.empty() == true)\\n                    break;\\n                curr = st.top();\\n                st.pop();\\n                inorder.push_back(curr->val);\\n                curr = curr->right;    \\n            }\\n        }    \\n        return inorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        inorder(root->left, nodes);\\n        nodes.push_back(root->val);\\n        inorder(root->right, nodes);    \\n    }    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> inorder;\\n        if (root == NULL)\\n            return inorder;\\n        stack <TreeNode* > st;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            } else {\\n                if (st.empty() == true)\\n                    break;\\n                curr = st.top();\\n                st.pop();\\n                inorder.push_back(curr->val);\\n                curr = curr->right;    \\n            }\\n        }    \\n        return inorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070108,
                "title": "morris-inorder-traversal",
                "content": "My Python approach for Morris Inorder Traversal.\\nBased on [this](https://www.youtube.com/watch?v=80Zug6D1_r4) video.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        cur = root\\n        while cur != None:\\n            #printing the leftmost node\\n            if not cur.left:\\n                ans.append(cur.val)\\n                cur = cur.right\\n            else:\\n                temp = cur\\n                temp = temp.left\\n                #going to the rightmost node in the left subtree (lets call it temp)\\n                while temp.right and temp.right != cur:\\n                    temp = temp.right\\n                \\n                #2 conditions arise:\\n                \\n                #i. the right child of temp doesn\\'t exist (The thread to the cur node has not been made)\\n                #in this case, point the right child of temp to cur and move cur to its left child\\n                if not temp.right:\\n                    temp.right = cur\\n                    cur = cur.left\\n\\n                #ii. the thread has already been created so we break the thread\\n                #(pointing the temp\\'s right child back to None)and print cur.\\n                #Finally, move cur to its right child      \\n                else:\\n                    ans.append(cur.val)\\n                    temp.right = None\\n                    cur = cur.right\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        cur = root\\n        while cur != None:\\n            #printing the leftmost node\\n            if not cur.left:\\n                ans.append(cur.val)\\n                cur = cur.right\\n            else:\\n                temp = cur\\n                temp = temp.left\\n                #going to the rightmost node in the left subtree (lets call it temp)\\n                while temp.right and temp.right != cur:\\n                    temp = temp.right\\n                \\n                #2 conditions arise:\\n                \\n                #i. the right child of temp doesn\\'t exist (The thread to the cur node has not been made)\\n                #in this case, point the right child of temp to cur and move cur to its left child\\n                if not temp.right:\\n                    temp.right = cur\\n                    cur = cur.left\\n\\n                #ii. the thread has already been created so we break the thread\\n                #(pointing the temp\\'s right child back to None)and print cur.\\n                #Finally, move cur to its right child      \\n                else:\\n                    ans.append(cur.val)\\n                    temp.right = None\\n                    cur = cur.right\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550488,
                "title": "96-05-senior-developer-javascript-js-2022",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let res = [];\\n    \\n    const fn = (node) => {\\n        if (!node) return;\\n        fn(node.left);  \\n        res.push(node.val)\\n        fn(node.right);\\n    }\\n    \\n    fn(root);\\n    \\n    return res;\\n    \\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let res = [];\\n    \\n    const fn = (node) => {\\n        if (!node) return;\\n        fn(node.left);  \\n        res.push(node.val)\\n        fn(node.right);\\n    }\\n    \\n    fn(root);\\n    \\n    return res;\\n    \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549705,
                "title": "simplest-approach-c-9ms-iterative-inorder-traversal",
                "content": "Just move to the left most node and then go on pushing the node values. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(TreeNode* node){\\n        if(!node)\\n            return;\\n        dfs(node->left);\\n        ans.push_back(node->val);\\n        dfs(node->right);        \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(TreeNode* node){\\n        if(!node)\\n            return;\\n        dfs(node->left);\\n        ans.push_back(node->val);\\n        dfs(node->right);        \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546965,
                "title": "daily-leetcoding-challenge-september-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterating method using Stack\n\n  \n**Approach 3:** Morris Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2286560,
                "title": "3-approach-in-c-recursive-iterative-morris-traversal",
                "content": "**Recursive Approach:**\\n````\\n void inordert(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL) return;\\n        inordert(root->left, ans);\\n        ans.push_back(root->val);\\n        inordert(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inordert(root, ans);\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Iterative Approach:**\\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* node = root;\\n        stack<TreeNode*> st;\\n        while(true)\\n        {\\n            if(node != NULL)\\n            {\\n                st.push(node);\\n                node = node->left;\\n            }\\n            else\\n            {\\n                if(st.empty() == true) break;\\n                else\\n                {\\n                    node = st.top();\\n                    st.pop();\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Morris Traversal:**\\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n**One Request: Please do upvote if you found these approaches helpful, as it motivates me to post such useful content to help our leetcode community. Thanks in Advance!**",
                "solutionTags": [],
                "code": "````\\n void inordert(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL) return;\\n        inordert(root->left, ans);\\n        ans.push_back(root->val);\\n        inordert(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inordert(root, ans);\\n        return ans;\\n    }\\n```\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* node = root;\\n        stack<TreeNode*> st;\\n        while(true)\\n        {\\n            if(node != NULL)\\n            {\\n                st.push(node);\\n                node = node->left;\\n            }\\n            else\\n            {\\n                if(st.empty() == true) break;\\n                else\\n                {\\n                    node = st.top();\\n                    st.pop();\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248076,
                "title": "java-easy-standard-solution-0ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n      \\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans; // base condition\\n      \\n      Stack<TreeNode> st = new Stack<>();\\n      \\n      TreeNode cur = root;\\n        while(cur != null || !st.isEmpty()) {\\n          while(cur != null) {\\n            st.add(cur);\\n            cur = cur.left;\\n          }\\n          cur = st.pop();\\n          ans.add(cur.val);\\n          cur = cur.right;\\n        }\\n      return ans;\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n      \\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans; // base condition\\n      \\n      Stack<TreeNode> st = new Stack<>();\\n      \\n      TreeNode cur = root;\\n        while(cur != null || !st.isEmpty()) {\\n          while(cur != null) {\\n            st.add(cur);\\n            cur = cur.left;\\n          }\\n          cur = st.pop();\\n          ans.add(cur.val);\\n          cur = cur.right;\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161133,
                "title": "python-simple-and-easy-solution-using-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        #Approach - Using Recursion\\n        in_list=[]\\n        if not root:\\n            return\\n        if root.left:\\n            in_list+=self.inorderTraversal(root.left)\\n        in_list.append(root.val)\\n        if root.right:\\n            in_list+=self.inorderTraversal(root.right)\\n        return in_list\\n        \\n```\\n**Please Upvote if it was Helpful. :)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        #Approach - Using Recursion\\n        in_list=[]\\n        if not root:\\n            return\\n        if root.left:\\n            in_list+=self.inorderTraversal(root.left)\\n        in_list.append(root.val)\\n        if root.right:\\n            in_list+=self.inorderTraversal(root.right)\\n        return in_list\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663643,
                "title": "c-iterative-and-recursive",
                "content": "Both recursive and iterative solutions use stack.\\nFor iterative solution it uses a user defined stack.\\n\\nIterative Solution\\n\\n1) Intitialize a stack.\\n2) While loop with OR conditions if stack is empty or node is null\\n3) First we traverse through all the left child. Push all the left child nodes in the stack to refer again.\\n4) If node is null, Pop the last element, print the value and visit its right child.\\n\\n```\\n\\t\\tstack <TreeNode*> S;\\n        vector <int> res;\\n        TreeNode* temp = root;\\n        \\n        while((!S.empty())||(temp != NULL)){\\n            if(temp != NULL){\\n                S.push(temp);\\n                temp = temp->left;                \\n            }\\n            else{\\n                temp = S.top();\\n                S.pop();\\n                res.push_back(temp->val);\\n                temp = temp->right;\\n            }\\n        }\\n        return res;        \\n```\\n\\n\\nIterative Solution\\n1) Visit and store All left child\\n2) Print the value\\n3) Visit all Right child\\n```\\n\\tvoid inorder(TreeNode* root,vector <int> &res){\\n        if(root){\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        }\\n        //return res\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> res;\\n        inorder(root,res);\\n        return res;\\n    }\\n```\\n\\nHope it helps!\\nPlease up vote.\\nFor more detailed explanation please refer https://www.techiedelight.com/inorder-tree-traversal-iterative-recursive/",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\t\\tstack <TreeNode*> S;\\n        vector <int> res;\\n        TreeNode* temp = root;\\n        \\n        while((!S.empty())||(temp != NULL)){\\n            if(temp != NULL){\\n                S.push(temp);\\n                temp = temp->left;                \\n            }\\n            else{\\n                temp = S.top();\\n                S.pop();\\n                res.push_back(temp->val);\\n                temp = temp->right;\\n            }\\n        }\\n        return res;        \\n```\n```\\n\\tvoid inorder(TreeNode* root,vector <int> &res){\\n        if(root){\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        }\\n        //return res\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> res;\\n        inorder(root,res);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570071,
                "title": "recursion-time-complexity-space-complexity-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n\\t\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n\\t\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540039,
                "title": "c-inorder-preorder-postorder-all-3-solution-0ms-faster-than-100",
                "content": "You can observe there is just a minimal diffrence in all 3 ,i.e, it\\'s just the way of filling vector while calling fill function.  \\n***Inorder Traversal :*** \\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Preorder Traversal :***\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Postorder Traversal :***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907247,
                "title": "simple-javascript-solution-recursive",
                "content": "Simple Javascript solution using spread operator:\\n\\n```javascript \\nvar inorderTraversal = function(root) {\\n    if (!root) {\\n      return [];\\n    }\\n    let left = inorderTraversal(root.left);\\n    let mid = root.val;\\n    let right = inorderTraversal(root.right);\\n    return [...left, mid, ...right];\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```javascript \\nvar inorderTraversal = function(root) {\\n    if (!root) {\\n      return [];\\n    }\\n    let left = inorderTraversal(root.left);\\n    let mid = root.val;\\n    let right = inorderTraversal(root.right);\\n    return [...left, mid, ...right];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600732,
                "title": "javascript-iterative-solution-stack-93-56",
                "content": "Very simpe iterative solution which uses stack.\\n\\nRuntime: 48 ms, faster than 93.31% of JavaScript online submissions for Binary Tree Inorder Traversal.\\nMemory Usage: 33.8 MB, less than 56.25% of JavaScript online submissions for Binary Tree Inorder Traversal.\\n\\n```\\nfunction inorderTraversal(root) {\\n  const stack = [], ret = [];\\n  root && stack.push(root);\\n  while (stack.length) {\\n    const item = stack.pop();\\n    if (item.left) {\\n      stack.push(item);\\n      stack.push(item.left);\\n      item.left = null;\\n    }\\n    else {\\n      ret.push(item.val);\\n      item.right && stack.push(item.right);\\n    }\\n  }\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nfunction inorderTraversal(root) {\\n  const stack = [], ret = [];\\n  root && stack.push(root);\\n  while (stack.length) {\\n    const item = stack.pop();\\n    if (item.left) {\\n      stack.push(item);\\n      stack.push(item.left);\\n      item.left = null;\\n    }\\n    else {\\n      ret.push(item.val);\\n      item.right && stack.push(item.right);\\n    }\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516768,
                "title": "c-iterative-lnr-using-stack",
                "content": "```\\npublic class Solution {\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        while (stack.Count != 0 || root != null) {\\n            if (root != null) {\\n                stack.Push(root);\\n                root = root.left;\\n            } else {\\n                root = stack.Pop();\\n                result.Add(root.val);\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        while (stack.Count != 0 || root != null) {\\n            if (root != null) {\\n                stack.Push(root);\\n                root = root.left;\\n            } else {\\n                root = stack.Pop();\\n                result.Add(root.val);\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458464,
                "title": "python-simple-iterative-and-recursive-solutions-98-faster-100-less-memory",
                "content": "```\\n\\n#recursive\\nclass Solution:\\n    def __init__(self):\\n        self.return_list = []\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        \\n        if root:\\n            self.inorderTraversal(root.left)\\n            \\n            self.return_list.append(root.val)\\n            \\n            self.inorderTraversal(root.right)\\n            \\n        return self.return_list\\n```\\n```\\n#ITERATIVE\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:        \\n        return_list = []\\n        stack = []\\n        node = root\\n        \\n        while True:\\n            \\n            if node is not None:\\n                stack.append(node)\\n                node = node.left\\n                \\n            elif(stack):\\n                node = stack.pop()\\n                return_list.append(node.val)\\n                node = node.right\\n            else:\\n                break\\n        return return_list",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n#recursive\\nclass Solution:\\n    def __init__(self):\\n        self.return_list = []\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        \\n        if root:\\n            self.inorderTraversal(root.left)\\n            \\n            self.return_list.append(root.val)\\n            \\n            self.inorderTraversal(root.right)\\n            \\n        return self.return_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455535,
                "title": "javascript-1-line-solution",
                "content": "```js\\nconst inorderTraversal = root => root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst inorderTraversal = root => root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];",
                "codeTag": "Unknown"
            },
            {
                "id": 180116,
                "title": "javascript",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null) {\\n            dfs(root.left);\\n            result.push(root.val);\\n            dfs(root.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null) {\\n            dfs(root.left);\\n            result.push(root.val);\\n            dfs(root.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166659,
                "title": "javascript-100-iterative-and-recursive",
                "content": "Recursive:\\n\\n```js\\nconst inorderTraversal = root => {\\n  if (!root) return [];\\n  \\n  return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n};\\n```\\n\\nIterative (using a stack):\\n```js\\nconst inorderTraversal = root => {\\n  const traversed = [];\\n  \\n  if (!root) {\\n    return traversed;\\n  }\\n  \\n  const nodes = [root];\\n  let currentNode = root.left;\\n  \\n  while (currentNode || nodes.length) {\\n    while (currentNode) {\\n      nodes.push(currentNode);\\n      currentNode = currentNode.left;\\n    }\\n    \\n    currentNode = nodes.pop();\\n    traversed.push(currentNode.val);\\n    currentNode = currentNode.right;\\n  }\\n  \\n  return traversed;\\n}\\n```\\n\\nBoth have 52ms runtime.",
                "solutionTags": [],
                "code": "```js\\nconst inorderTraversal = root => {\\n  if (!root) return [];\\n  \\n  return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n};\\n```\n```js\\nconst inorderTraversal = root => {\\n  const traversed = [];\\n  \\n  if (!root) {\\n    return traversed;\\n  }\\n  \\n  const nodes = [root];\\n  let currentNode = root.left;\\n  \\n  while (currentNode || nodes.length) {\\n    while (currentNode) {\\n      nodes.push(currentNode);\\n      currentNode = currentNode.left;\\n    }\\n    \\n    currentNode = nodes.pop();\\n    traversed.push(currentNode.val);\\n    currentNode = currentNode.right;\\n  }\\n  \\n  return traversed;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152061,
                "title": "recursive-and-iterative-approaches-using-ruby",
                "content": "### Recursive approach\\n```ruby\\ndef inorder_traversal_recursive(root)\\n  response = []\\n  traverse(root, response)\\n  return response\\nend\\n\\ndef traverse(node, response)\\n  return if node.nil?\\n  \\n  traverse(node.left, response) if node.left\\n  response << node.val\\n  traverse(node.right, response) if node.right\\nend\\n```\\n\\n### Iterative approach\\n```ruby\\ndef inorder_traversal(root)\\n  curr = root\\n  stack, res = [], []\\n  \\n  while !(curr.nil? and stack.empty?)\\n    while curr\\n      stack.push(curr)\\n      curr = curr.left\\n    end\\n    curr = stack.pop\\n    res << curr.val\\n    curr = curr.right\\n  end\\n  \\n  return res\\nend\\n````\\n",
                "solutionTags": [],
                "code": "```ruby\\ndef inorder_traversal_recursive(root)\\n  response = []\\n  traverse(root, response)\\n  return response\\nend\\n\\ndef traverse(node, response)\\n  return if node.nil?\\n  \\n  traverse(node.left, response) if node.left\\n  response << node.val\\n  traverse(node.right, response) if node.right\\nend\\n```\n```ruby\\ndef inorder_traversal(root)\\n  curr = root\\n  stack, res = [], []\\n  \\n  while !(curr.nil? and stack.empty?)\\n    while curr\\n      stack.push(curr)\\n      curr = curr.left\\n    end\\n    curr = stack.pop\\n    res << curr.val\\n    curr = curr.right\\n  end\\n  \\n  return res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31378,
                "title": "share-my-c-solution-very-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            TreeNode *temp = root;\\n            \\n            while (!s.empty() || temp != NULL)\\n            {\\n                while (temp != NULL)\\n                {\\n                    s.push(temp);\\n                    temp = temp->left;\\n                }\\n                \\n                temp = s.top();\\n                ret.push_back(temp->val);\\n                s.pop();\\n                temp = temp->right;\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            TreeNode *temp = root;\\n            \\n            while (!s.empty() || temp != NULL)\\n            {\\n                while (temp != NULL)\\n                {\\n                    s.push(temp);\\n                    temp = temp->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3509959,
                "title": "python-easy-recursive-iterative-both-solutions",
                "content": "**Iterative Solution:**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return\\n        t=root\\n        a=[]\\n        ans=[]\\n        while True:\\n            if t:\\n                a.append(t)\\n                t=t.left\\n            else:\\n                if len(a)==0:\\n                    break\\n                t=a.pop()\\n                ans.append(t.val)\\n                t=t.right \\n        return ans\\n```\\n**Recursive Solution:**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.ans.append(root.val)\\n        self.Traversal(root.right)\\n```\\n**An  upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return\\n        t=root\\n        a=[]\\n        ans=[]\\n        while True:\\n            if t:\\n                a.append(t)\\n                t=t.left\\n            else:\\n                if len(a)==0:\\n                    break\\n                t=a.pop()\\n                ans.append(t.val)\\n                t=t.right \\n        return ans\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.ans.append(root.val)\\n        self.Traversal(root.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3408869,
                "title": "very-easy-o-n-intutive-recursive-code-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nVery Easy and understandable c++ code\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root,vector<int>&v){\\n        if(!root)\\n        return;\\n\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        \\n        solve(root,v);\\n        return v;\\n        \\n    }\\n};         \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root,vector<int>&v){\\n        if(!root)\\n        return;\\n\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        \\n        solve(root,v);\\n        return v;\\n        \\n    }\\n};         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399456,
                "title": "simple-go-solution",
                "content": "\\n```\\n\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tres := make([]int, 0, 101)\\n\\tif root != nil {\\n\\t\\tres = help(root, res)\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc help(root *TreeNode, res []int) []int {\\n\\tif root.Left != nil {\\n\\t\\tres = help(root.Left, res)\\n\\t}\\n\\tres = append(res, root.Val)\\n\\tif root.Right != nil {\\n\\t\\tres = help(root.Right, res)\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tres := make([]int, 0, 101)\\n\\tif root != nil {\\n\\t\\tres = help(root, res)\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc help(root *TreeNode, res []int) []int {\\n\\tif root.Left != nil {\\n\\t\\tres = help(root.Left, res)\\n\\t}\\n\\tres = append(res, root.Val)\\n\\tif root.Right != nil {\\n\\t\\tres = help(root.Right, res)\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203062,
                "title": "java-easy-iterative-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null)  return list;\\n        TreeNode curr = root;\\n        Stack<TreeNode> st = new Stack<>();\\n        while(!st.isEmpty() || curr!=null){\\n            while(curr!=null){\\n                st.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = st.pop();\\n            list.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null)  return list;\\n        TreeNode curr = root;\\n        Stack<TreeNode> st = new Stack<>();\\n        while(!st.isEmpty() || curr!=null){\\n            while(curr!=null){\\n                st.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = st.pop();\\n            list.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195780,
                "title": "python-4-solutions-dfs-bfs-morris-1-morris-2",
                "content": "# Approach 1: DFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            yield from chain(inorder(root.left), (root,), inorder(root.right)) if root else tuple()\\n        \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: BFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                if not node.left and not node.right: yield node; continue\\n                \\n                if node.right: stack.append(node.right)\\n                stack.append(TreeNode(node.val))\\n                if node.left: stack.append(node.left)\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: Morris traversal. (Destroys the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right: last = last.right\\n                    \\n                    last.right = node\\n                    node = node.left\\n                    last.right.left = None\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 4: Morris traversal. (Destroys and recovers the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right and last.right != node:\\n                        last = last.right\\n                    \\n                    if last.right:\\n                        last.right = None\\n                        yield node\\n                        node = node.right\\n                    else:\\n                        last.right = node\\n                        node = node.left\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            yield from chain(inorder(root.left), (root,), inorder(root.right)) if root else tuple()\\n        \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                if not node.left and not node.right: yield node; continue\\n                \\n                if node.right: stack.append(node.right)\\n                stack.append(TreeNode(node.val))\\n                if node.left: stack.append(node.left)\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right: last = last.right\\n                    \\n                    last.right = node\\n                    node = node.left\\n                    last.right.left = None\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right and last.right != node:\\n                        last = last.right\\n                    \\n                    if last.right:\\n                        last.right = None\\n                        yield node\\n                        node = node.right\\n                    else:\\n                        last.right = node\\n                        node = node.left\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087159,
                "title": "java-recursive-way-easy-solution-with-comments",
                "content": "# Approach\\nUsing recursive way, travsere the tree and keep adding the value to the list. Another way is by using the stack\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    //creating an instance\\n    List<Integer> list = new ArrayList<Integer>();\\n\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        //if empty tree\\n        if(root == null)\\n            return list;\\n\\n        TreeNode ptr = root;\\n\\n        traversal(ptr);\\n\\n        return list;\\n    }\\n\\n    //inorder traversal\\n    public void traversal (TreeNode root)\\n    {\\n        //return on reaching end\\n        if(root == null)\\n            return;\\n\\n        // recur on the left node\\n        traversal(root.left);\\n\\n        //get the data of the node\\n        list.add(root.val);\\n\\n        //now recur on the right node\\n        traversal(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    //creating an instance\\n    List<Integer> list = new ArrayList<Integer>();\\n\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        //if empty tree\\n        if(root == null)\\n            return list;\\n\\n        TreeNode ptr = root;\\n\\n        traversal(ptr);\\n\\n        return list;\\n    }\\n\\n    //inorder traversal\\n    public void traversal (TreeNode root)\\n    {\\n        //return on reaching end\\n        if(root == null)\\n            return;\\n\\n        // recur on the left node\\n        traversal(root.left);\\n\\n        //get the data of the node\\n        list.add(root.val);\\n\\n        //now recur on the right node\\n        traversal(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026386,
                "title": "beats-100-3-methods-morris-iterative-recursion-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using simple recursion.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (recursive call stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorderHelper(TreeNode* root, vector<int>& ans){\\n        if(root==NULL)return;\\n        inorderHelper(root->left,ans); \\n        ans.push_back(root->val);\\n        inorderHelper(root->right,ans);      \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorderHelper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# Method #2 : Morris Traversal\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf current does not have left child\\n\\n    a. Add current\\u2019s value\\n\\n    b. Go to the right, i.e., current = current.right\\n\\nElse\\n\\n    a. In current\\'s left subtree, make current the right child of the rightmost node\\n\\n    b. Go to this left child, i.e., current = current.left\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t//Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\\n---\\n# Method #3 : Iterative(Important)\\n\\n# Intution \\n- we\\'ll use a stack for that , to store addresses of elements and there state.\\n- state 0 = inorder(root->left);\\n- state 1 = cout<<data;\\n- state 2 = inorder(root->right);\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<pair<TreeNode*,int>> st;\\n        vector<int> v;\\n        if(root == NULL) return {};\\n        st.push({root,0});\\n        while(!st.empty()){\\n            TreeNode* cur = st.top().first;\\n            int state = st.top().second;\\n            st.pop();\\n            \\n            if(cur == NULL){\\n                continue;\\n            }\\n            if(state == 0){\\n                st.push({cur,1});\\n                st.push({cur->left,0});\\n            }else if(state == 1){\\n                v.push_back(cur->val);\\n                st.push({cur,2});\\n            }else{\\n                st.push({cur->right,0});\\n            }\\n        }\\n        return v;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorderHelper(TreeNode* root, vector<int>& ans){\\n        if(root==NULL)return;\\n        inorderHelper(root->left,ans); \\n        ans.push_back(root->val);\\n        inorderHelper(root->right,ans);      \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorderHelper(root,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t//Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<pair<TreeNode*,int>> st;\\n        vector<int> v;\\n        if(root == NULL) return {};\\n        st.push({root,0});\\n        while(!st.empty()){\\n            TreeNode* cur = st.top().first;\\n            int state = st.top().second;\\n            st.pop();\\n            \\n            if(cur == NULL){\\n                continue;\\n            }\\n            if(state == 0){\\n                st.push({cur,1});\\n                st.push({cur->left,0});\\n            }else if(state == 1){\\n                v.push_back(cur->val);\\n                st.push({cur,2});\\n            }else{\\n                st.push({cur->right,0});\\n            }\\n        }\\n        return v;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024178,
                "title": "94-fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ll=[]\\n        def tr(root):\\n            if root==None:\\n                return \\n            \\n            tr(root.left)\\n            ll.append(root.val)\\n            tr(root.right)\\n            return ll\\n        return tr(root)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ll=[]\\n        def tr(root):\\n            if root==None:\\n                return \\n            \\n            tr(root.left)\\n            ll.append(root.val)\\n            tr(root.right)\\n            return ll\\n        return tr(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006595,
                "title": "beats-100-golang",
                "content": "\\n\\n# Code\\n```\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar values []int\\n\\tvalues = append(values, inorderTraversal(root.Left)...)\\n\\tvalues = append(values, root.Val)\\n\\tvalues = append(values, inorderTraversal(root.Right)...)\\n\\n\\treturn values\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar values []int\\n\\tvalues = append(values, inorderTraversal(root.Left)...)\\n\\tvalues = append(values, root.Val)\\n\\tvalues = append(values, inorderTraversal(root.Right)...)\\n\\n\\treturn values\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927089,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        f(root->left, ans);\\n        ans.push_back(root->val);\\n        f(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        f(root->left, ans);\\n        ans.push_back(root->val);\\n        f(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765181,
                "title": "c-traversal",
                "content": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2628733,
                "title": "typescript-javascript-solution-that-doesn-t-push-arrays-around",
                "content": "If you simply use an array outer to the function, subsequent test cases will fail, because Leetcode will run your function repeatedly but won\\'t clear the array. So the array needs to be cleared on the first invocation of the function, but the function is called recursively, so you don\\'t know when the first invocation is.\\nOne solution would be to return the arrays of numbers and concatenate them, but that needlessly moved data in the stack.\\nA faster solution is to use a closure, and initialize the array in it.\\n```\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    const result = [];\\n    function traverse(root: TreeNode | null): number[] {\\n        if (root) {\\n            traverse(root.left);\\n            result.push(root.val);\\n            traverse(root.right);\\n        }\\n        return result;\\n    }\\n    return traverse(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    const result = [];\\n    function traverse(root: TreeNode | null): number[] {\\n        if (root) {\\n            traverse(root.left);\\n            result.push(root.val);\\n            traverse(root.right);\\n        }\\n        return result;\\n    }\\n    return traverse(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564385,
                "title": "python-all-in-one-morris-with-notes-iterative-recursive-solutions",
                "content": "**Morris Traversal**\\nEven Recursive takes Auxiliary stack space so Time O(n) and sapce O(n) , But Morris takes O(n) and O(1)\\nMorris Uses treaded BT (Contains predecessor and successor information in NULL pointers)\\n**Algorithm Cases:**\\n\\t1. If left null, print curr and move right\\n\\t2. before going left, make right most node on left subtree connected to current node, then go left\\n\\t3. if thread is already pointed to current node, then remove the thread\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\t\\t\\tcurr = root\\n\\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\t# If left null, print curr and move right\\n\\t\\t\\t\\tif not curr.left:\\n\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\t\\t# before going left, make right most node on left subtree connected to current node, then go left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev = curr.left\\n\\t\\t\\t\\t\\twhile prev.right and prev.right!=curr:\\n\\t\\t\\t\\t\\t\\tprev = prev.right\\n\\t\\t\\t\\t\\t# make thread\\n\\t\\t\\t\\t\\tif not prev.right:\\n\\t\\t\\t\\t\\t\\tprev.right = curr\\n\\t\\t\\t\\t\\t\\tcurr = curr.left\\n\\t\\t\\t\\t\\t# if thread is already pointed to current node, means You have visited the node, cut the thread, print the root and  move to the right\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprev.right = None\\n\\t\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\treturn res\\n```\\n\\n**Iterative**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tstack, res = [], []      \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root=root.left\\n            if not stack: return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root=node.right\\n```\\n**Recursive**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\treturn self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKED!**\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\t\\t\\tcurr = root\\n\\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\t# If left null, print curr and move right\\n\\t\\t\\t\\tif not curr.left:\\n\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\t\\t# before going left, make right most node on left subtree connected to current node, then go left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev = curr.left\\n\\t\\t\\t\\t\\twhile prev.right and prev.right!=curr:\\n\\t\\t\\t\\t\\t\\tprev = prev.right\\n\\t\\t\\t\\t\\t# make thread\\n\\t\\t\\t\\t\\tif not prev.right:\\n\\t\\t\\t\\t\\t\\tprev.right = curr\\n\\t\\t\\t\\t\\t\\tcurr = curr.left\\n\\t\\t\\t\\t\\t# if thread is already pointed to current node, means You have visited the node, cut the thread, print the root and  move to the right\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprev.right = None\\n\\t\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\treturn res\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tstack, res = [], []      \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root=root.left\\n            if not stack: return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root=node.right\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\treturn self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2547396,
                "title": "c-0ms-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n**TC** = O(N)\\n\\t\\n\\tvoid solve(TreeNode *root, vector<int>&v){\\n        if(!root) return;\\n        \\n        solve(root->left,v);         //root->left\\n        v.push_back(root->val);      //store root->val\\n        solve(root->right,v);        //root->right\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n**TC** = O(N)\\n\\t\\n\\tvoid solve(TreeNode *root, vector<int>&v){\\n        if(!root) return;\\n        \\n        solve(root->left,v);         //root->left\\n        v.push_back(root->val);      //store root->val\\n        solve(root->right,v);        //root->right\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2229713,
                "title": "c-solution-faster-than-100-solutions-currently",
                "content": "**The below code is faster than 100% of the solutions currently on LeetCode. Happy Leetcoding !!\\nDo Upvote \\u270C\\uD83C\\uDFFB**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorder (TreeNode* root,vector<int>&v)\\n    {\\n       if(root!=NULL)\\n       {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n       }\\n        return v;\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        \\n        inorder(root,v);\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorder (TreeNode* root,vector<int>&v)\\n    {\\n       if(root!=NULL)\\n       {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n       }\\n        return v;\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        \\n        inorder(root,v);\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147819,
                "title": "two-lines-solution-in-kotlin",
                "content": "Simple solution using recursion in Kotlin\\n\\n```\\nclass Solution {\\n    \\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n       root ?: return listOf<Int>()\\n       return  inorderTraversal(root.left) + listOf(root.`val`) + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n       root ?: return listOf<Int>()\\n       return  inorderTraversal(root.left) + listOf(root.`val`) + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050074,
                "title": "python-100-easy-solution",
                "content": "\\n\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            res.append(node.val)\\n            self.dfs(node.right, res)\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            res.append(node.val)\\n            self.dfs(node.right, res)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1978409,
                "title": "c-iterative-solution-stack-with-comments",
                "content": "```\\nclass Solution {\\n\\t// Inorder - Left Subtree -> Root -> Right Subtree\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        vector<int> ans;\\n        \\n\\t\\t// 1. Make root as the starting node, that is currNode\\n        TreeNode* currNode = root;\\n        while (currNode or !st.empty()) {\\n\\t\\t// 2. Now add all the left subtree nodes to the stack\\n            while (currNode) {\\n                st.push(currNode);\\n                currNode = currNode->left;\\n            }   \\n        // 3. Pick out the top node, put it in answer array\\n            currNode = st.top();\\n            st.pop();\\n            \\n            ans.push_back(currNode->val);\\n\\t\\t// 4. Update currNode as below, this will take care of the right subtree\\n            currNode = currNode->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n\\t// Inorder - Left Subtree -> Root -> Right Subtree\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        vector<int> ans;\\n        \\n\\t\\t// 1. Make root as the starting node, that is currNode\\n        TreeNode* currNode = root;\\n        while (currNode or !st.empty()) {\\n\\t\\t// 2. Now add all the left subtree nodes to the stack\\n            while (currNode) {\\n                st.push(currNode);\\n                currNode = currNode->left;\\n            }   \\n        // 3. Pick out the top node, put it in answer array\\n            currNode = st.top();\\n            st.pop();\\n            \\n            ans.push_back(currNode->val);\\n\\t\\t// 4. Update currNode as below, this will take care of the right subtree\\n            currNode = currNode->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958957,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n    def inorderTraversal(root: TreeNode): List[Int] = {\\n        if(root == null) List()\\n        else inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def inorderTraversal(root: TreeNode): List[Int] = {\\n        if(root == null) List()\\n        else inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1777345,
                "title": "python-solution-iterative-recursive-easy-to-understand",
                "content": "```python\\n# Recursive and Iterative Solutions to inOrder, preOrder, and postOrder traversal\\n# ------------------------------------------- recursive\\n# recursive\\ndef BSTTraversal(root):\\n    res = []\\n    def inOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            res.append(root.val)\\n            inOrder(root.right)\\n    \\n    def preOrder(root):\\n        if root:\\n            res.append(root.val)\\n            inOrder(root.left)\\n            inOrder(root.right)\\n    \\n    def postOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            inOrder(root.right)\\n            res.append(root.val)\\n    \\n    inOrder(root)\\n    return res\\n\\n# one-liner recursive\\ndef traverse(root):\\n    return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] #post order\\n    # return self.postorderTraversal(root.left)+[root.val]+self.postorderTraversal(root.right) if root else [] #in order\\n    # return [root.val]+self.postorderTraversal(root.left)+self.postorderTraversal(root.right) if root else [] #pre order\\n\\n# ------------------------------------------- Iterative\\ndef inorderTraversal(self, root):\\n    stack, result = [], []   \\n    curr = root\\n    while curr or stack:\\n        while curr:\\n            stack.append(curr)\\n            curr = curr.left\\n        node = stack.pop()\\n        result.append(node.val)\\n        curr = node.right\\n        \\n    return result\\n\\ndef preorderTraversal(self, root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.right)\\n            stack.append(curr.left)\\n        \\n    return result\\n\\ndef postorderTraversal(root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.left)\\n            stack.append(curr.right)\\n    return result[::-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n# Recursive and Iterative Solutions to inOrder, preOrder, and postOrder traversal\\n# ------------------------------------------- recursive\\n# recursive\\ndef BSTTraversal(root):\\n    res = []\\n    def inOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            res.append(root.val)\\n            inOrder(root.right)\\n    \\n    def preOrder(root):\\n        if root:\\n            res.append(root.val)\\n            inOrder(root.left)\\n            inOrder(root.right)\\n    \\n    def postOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            inOrder(root.right)\\n            res.append(root.val)\\n    \\n    inOrder(root)\\n    return res\\n\\n# one-liner recursive\\ndef traverse(root):\\n    return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] #post order\\n    # return self.postorderTraversal(root.left)+[root.val]+self.postorderTraversal(root.right) if root else [] #in order\\n    # return [root.val]+self.postorderTraversal(root.left)+self.postorderTraversal(root.right) if root else [] #pre order\\n\\n# ------------------------------------------- Iterative\\ndef inorderTraversal(self, root):\\n    stack, result = [], []   \\n    curr = root\\n    while curr or stack:\\n        while curr:\\n            stack.append(curr)\\n            curr = curr.left\\n        node = stack.pop()\\n        result.append(node.val)\\n        curr = node.right\\n        \\n    return result\\n\\ndef preorderTraversal(self, root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.right)\\n            stack.append(curr.left)\\n        \\n    return result\\n\\ndef postorderTraversal(root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.left)\\n            stack.append(curr.right)\\n    return result[::-1]",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1567642,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567706,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1576752,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1571206,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1862741,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1750273,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1820685,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1566744,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1569462,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1565404,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567642,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567706,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1576752,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1571206,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1862741,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1750273,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1820685,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1566744,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1569462,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1565404,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1570174,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1905416,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1816158,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1574193,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1572684,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1869599,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1869367,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1570515,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 2026019,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1949066,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1809614,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1751467,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1574233,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1572593,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1574123,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1573707,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2068958,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2049898,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2033340,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2013454,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2007717,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1997329,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1977346,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1940711,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1919780,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1886680,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1879007,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1873868,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1863953,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1833518,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1799574,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1783048,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1767924,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1767523,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1762359,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1758368,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1757633,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1739648,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1735530,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1733493,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1728201,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1725903,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1719384,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1708956,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1706983,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691789,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691788,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691142,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1672383,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1669371,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Transpose File",
        "question_content": "<p>Given a text file <code>file.txt</code>, transpose its content.</p>\n\n<p>You may assume that each row has the same number of columns, and each field is separated by the <code>&#39; &#39;</code> character.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>If <code>file.txt</code> has the following content:</p>\n\n<pre>\nname age\nalice 21\nryan 30\n</pre>\n\n<p>Output the following:</p>\n\n<pre>\nname alice ryan\nage 21 30\n</pre>\n",
        "solutions": [
            {
                "id": 55502,
                "title": "ac-solution-using-awk-and-statement-just-like-c",
                "content": "Just feel free to use `for` and `if`.  \\nYou can append string easily, for example, `s = s a` to append `a` with `s`. \\n\\n\\n    awk '\\n    {\\n        for (i = 1; i <= NF; i++) {\\n            if(NR == 1) {\\n                s[i] = $i;\\n            } else {\\n                s[i] = s[i] \" \" $i;\\n            }\\n        }\\n    }\\n    END {\\n        for (i = 1; s[i] != \"\"; i++) {\\n            print s[i];\\n        }\\n    }' file.txt",
                "solutionTags": [],
                "code": "Just feel free to use `for` and `if`.  \\nYou can append string easily, for example, `s = s a` to append `a` with `s`. \\n\\n\\n    awk '\\n    {\\n        for (i = 1; i <= NF; i++) {\\n            if(NR == 1) {\\n                s[i] = $i;\\n            } else {\\n                s[i] = s[i] \" \" $i;\\n            }\\n        }\\n    }\\n    END {\\n        for (i = 1; s[i] != \"\"; i++) {\\n            print s[i];\\n        }\\n    }' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 111382,
                "title": "solution-using-awk-with-explanations",
                "content": "I would definitely recommend this tutorial: http://www.grymoire.com/Unix/Awk.html if you'd like to know more about GAWK/NAWK. Similar to `sed`, `awk` is used to perform complex editing tasks to streams of text. The main difference is that `awk` is more suitable for larger editing tasks (those that may need some programming language features).\\n\\nYou may have already seen `awk` solutions similar to the one presented below:\\n\\n```bash\\nawk '\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n' file.txt\\n```\\n\\nHere're some quick notes to help you understand:\\n\\n1. The code block with an \"END\" prefix is only executed after the last line is read; similarly, a code block with a \"BEGIN\" prefix will be executed before any line reads.\\n\\n2. AWK is line-based: the main code block (the code block without prefix) processes one line of input at a time.\\n\\n3. `NR`: a variable indicating the number of records (i.e. current line number) that's accumulated across multiple files read. `FNR` is similar to `NR`, but is reset for each file read. Since we only need to deal with one file in this question, either is fine to use.\\n\\n4. `NF`: a variable indicating the number of fields (i.e. number of \"columns\") on an input line.\\n\\n5. `$i`: the i-th field of the input line.\\n\\n6. `t[]`: an array for saving the transposed table. More on awk arrays here: http://www.grymoire.com/Unix/Awk.html#uh-22",
                "solutionTags": [],
                "code": "```bash\\nawk '\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657470,
                "title": "simple-0ms-no-awk-no-scripting-in-bash",
                "content": "```bash\\nhead -1 file.txt | wc -w | xargs seq 1 | xargs -I{} -n 1 sh -c \"cut -d \\' \\' -f{} file.txt | paste -sd \\' \\' -\"\\n```",
                "solutionTags": [],
                "code": "```bash\\nhead -1 file.txt | wc -w | xargs seq 1 | xargs -I{} -n 1 sh -c \"cut -d \\' \\' -f{} file.txt | paste -sd \\' \\' -\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607685,
                "title": "the-real-intended-solution-using-pure-bash",
                "content": "```\\n#!/bin/bash\\npython3 -c \\'print(\"\\\\n\".join(map(\" \".join, zip(*(l.split() for l in open(\"file.txt\"))))))\\'",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\npython3 -c \\'print(\"\\\\n\".join(map(\" \".join, zip(*(l.split() for l in open(\"file.txt\"))))))\\'",
                "codeTag": "Python3"
            },
            {
                "id": 55501,
                "title": "simple-bash-solution-that-oj-hates",
                "content": "My solution in BASH. It works fine on my computer and I think it's conceptually straightforward. OJ complains exceeding memory.\\n\\n    ncol=`head -n1 file.txt | wc -w`\\n    \\n    for i in `seq 1 $ncol`\\n    do\\n        echo `cut -d' ' -f$i file.txt`\\n    done",
                "solutionTags": [],
                "code": "My solution in BASH. It works fine on my computer and I think it's conceptually straightforward. OJ complains exceeding memory.\\n\\n    ncol=`head -n1 file.txt | wc -w`\\n    \\n    for i in `seq 1 $ncol`\\n    do\\n        echo `cut -d' ' -f$i file.txt`\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 373961,
                "title": "beat-99-4ms-single-line-awk-with-explain-pure-shell-ver-no-cat-awk-sed-etc",
                "content": "```\\nawk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\' file.txt\\n```\\n\\nExplain:\\n```\\nfor(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i\\n```\\n\\nLet\\'s talk it in C\\'s perspective.\\n* In `awk` ,`$i` is the i-th column of the line segmented by `Field Separator`(`FS`), \\n\\t\\twhich is internally defined as `FS=\" \"`.\\n\\t\\t`NF` = Number of Fields, how many pieces of the line we got after segmentation\\n* the expression in first `for` statement: \\n\\t\\t1) `?` is ternary operator as it does in C.\\n\\t\\t2) `a[i] FS $i` concatenates string `a[i]` and `FS` and `$i`\\n\\t\\t3) strings in array `a` *DO NOT* need to be declared, they\\'re `NULL` by default.\\n\\t\\t4) `NULL` logically equals to `FALSE`\\n\\t\\t5) obviously ternary operator has higher priority than variable assignment/concatenation\\n* So the whole expresion just transposed the content of input.\\n\\n`END` tells what to do after previous expression. As you see, `{for(i=0;i++<NF;)print a[i]}` just print them out.\\n\\nPure shell version:\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nfile=\"file.txt\"\\ndeclare -a tranctx\\nwhile read line; do\\n        IFS=\" \"\\n        j=0\\n        p=($line)\\n        while [ ! -z \"${p[$j]}\" ]; do\\n                tranctx[$j]=${tranctx[$j]}${p[$j]}$\\'\\\\n\\'\\n                ((++j))\\n        done\\n        IFS=$\\'\\\\n\\'\\ndone <$file\\n\\ni=0\\nwhile [ ! -z \"${tranctx[${i}]}\" ]; do\\n        echo ${tranctx[${i}]}\\n        ((++i))\\ndone\\n```\\nIt basically does same thing, but much more slower (**150ms**).",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\' file.txt\\n```\n```\\nfor(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i\\n```\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nfile=\"file.txt\"\\ndeclare -a tranctx\\nwhile read line; do\\n        IFS=\" \"\\n        j=0\\n        p=($line)\\n        while [ ! -z \"${p[$j]}\" ]; do\\n                tranctx[$j]=${tranctx[$j]}${p[$j]}$\\'\\\\n\\'\\n                ((++j))\\n        done\\n        IFS=$\\'\\\\n\\'\\ndone <$file\\n\\ni=0\\nwhile [ ! -z \"${tranctx[${i}]}\" ]; do\\n        echo ${tranctx[${i}]}\\n        ((++i))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55510,
                "title": "bash-sort-no-array-matrix",
                "content": "I print the words with coordinates `i` and `j`, then sort by `j` and `i`, then print in that order.\\n\\nInput:\\n```\\nname age\\nalice 21\\nryan 30\\n```\\nThe words with coordinates:\\n```\\n1 1 name\\n1 2 age\\n2 1 alice\\n2 2 21\\n3 1 ryan\\n3 2 30\\n```\\nSorted by `j` and `i`:\\n```\\n1 1 name\\n2 1 alice\\n3 1 ryan\\n1 2 age\\n2 2 21\\n3 2 30\\n```\\nFinal output:\\n```\\nname alice ryan\\nage 21 30\\n```\\nThe code:\\n```\\nm=`wc -l file.txt | cut -d' ' -f1`\\ni=0\\nwhile read line\\ndo\\n    let i++\\n    j=0\\n    for a in $line\\n    do\\n        let j++\\n        echo $i $j $a\\n    done\\ndone < file.txt | sort -n -k2 -k1 | while read i j a\\ndo\\n    if [ \"$i\" == \"$m\" ]\\n    then\\n        echo $a\\n    else\\n        echo -n \"$a \"\\n    fi\\ndone\\n```\\nIt's very slow, though, takes about 750 ms.",
                "solutionTags": [],
                "code": "```\\nname age\\nalice 21\\nryan 30\\n```\n```\\n1 1 name\\n1 2 age\\n2 1 alice\\n2 2 21\\n3 1 ryan\\n3 2 30\\n```\n```\\n1 1 name\\n2 1 alice\\n3 1 ryan\\n1 2 age\\n2 2 21\\n3 2 30\\n```\n```\\nname alice ryan\\nage 21 30\\n```\n```\\nm=`wc -l file.txt | cut -d' ' -f1`\\ni=0\\nwhile read line\\ndo\\n    let i++\\n    j=0\\n    for a in $line\\n    do\\n        let j++\\n        echo $i $j $a\\n    done\\ndone < file.txt | sort -n -k2 -k1 | while read i j a\\ndo\\n    if [ \"$i\" == \"$m\" ]\\n    then\\n        echo $a\\n    else\\n        echo -n \"$a \"\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55514,
                "title": "my-28ms-awk-solution",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    \\n    # using awk for this purpose\\n    awk '\\n        {\\n            for(i=1; i<=NF; i++)\\n            {   \\n                if(line[i] == \"\")\\n                {\\n                    line[i] = $i\\n                }\\n                else\\n                {\\n                    line[i] = line[i]\" \"$i\\n                }\\n            }\\n        }\\n        END{\\n             for(i=1; i<=NF; i++)\\n             {\\n                 print line[i]\\n             }\\n           }\\n        ' file.txt",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    \\n    # using awk for this purpose\\n    awk '\\n        {\\n            for(i=1; i<=NF; i++)\\n            {   \\n                if(line[i] == \"\")\\n                {\\n                    line[i] = $i\\n                }\\n                else\\n                {\\n                    line[i] = line[i]\" \"$i\\n                }\\n            }\\n        }\\n        END{\\n             for(i=1; i<=NF; i++)\\n             {\\n                 print line[i]\\n             }\\n           }\\n        ' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 3218902,
                "title": "194-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem is asking to transpose the content of a text file. The transpose operation is performed by converting rows to columns. For example, if we have a matrix, the transpose of the matrix is the operation of changing the rows of the matrix to columns.\\n\\nIn this case, we need to transpose the content of a text file, which means to swap the rows with columns, and print the resulting output.\\n\\nTo solve this problem, we can use the awk command in Unix. The awk command is a powerful tool for text processing, and it can be used to perform various operations on text files.\\n\\nLet\\'s break down the solution step by step:\\n\\n1. awk is a command for text processing, and it is used to extract and manipulate data from text files. We are using awk to perform the transpose operation on the content of a text file.\\n\\n2. We start with a for loop that reads the input file and stores the data in an array a. The NF variable in awk is the number of fields in the current record (or row), and the NR variable is the number of records (or rows) in the input file. The for loop reads each field in the row and stores it in the array a. The array a has two dimensions, where the first dimension is the column number, and the second dimension is the row number.\\n\\n3. After storing the data in the array a, we use another for loop to print the transposed data. We use the printf function to print the data in a formatted way. The printf function prints the data without adding a newline at the end, which is important for printing the transposed data.\\n\\n4. In the second for loop, we print the data in the transposed form. The loop iterates over each column first and then over each row. The printf function prints the data from the array a in a transposed form.\\n\\n5. The output of the one-liner is the transposed data of the input file.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf a[i,j]; if (j<NR) printf \" \"} printf \"\\\\n\"}}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf a[i,j]; if (j<NR) printf \" \"} printf \"\\\\n\"}}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55522,
                "title": "ac-solution-8-lines-only-in-pure-bash",
                "content": "    while read -a line; do\\n        for ((i=0; i < \"${#line[@]}\"; i++)); do\\n            a[$i]=\"${a[$i]} ${line[$i]}\"\\n        done\\n    done < file.txt\\n    for ((i=0; i < ${#a[@]}; i++)); do\\n        echo ${a[i]}\\n    done",
                "solutionTags": [],
                "code": "    while read -a line; do\\n        for ((i=0; i < \"${#line[@]}\"; i++)); do\\n            a[$i]=\"${a[$i]} ${line[$i]}\"\\n        done\\n    done < file.txt\\n    for ((i=0; i < ${#a[@]}; i++)); do\\n        echo ${a[i]}\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55520,
                "title": "simple-solution-with-awk",
                "content": "Simple solution with awk using associative array\\n\\nawk '{ for(i=1; i<=NF; ++i) {if (word[i] == \"\") {word[i] = $i} else{word[i] = word[i]\" \"$i}}} END{for(i=1; i<=NF; ++i) {print word[i]}}' file.txt",
                "solutionTags": [],
                "code": "Simple solution with awk using associative array\\n\\nawk '{ for(i=1; i<=NF; ++i) {if (word[i] == \"\") {word[i] = $i} else{word[i] = word[i]\" \"$i}}} END{for(i=1; i<=NF; ++i) {print word[i]}}' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 55511,
                "title": "memory-limit-exceeded",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    A=$(head -1 file.txt | tr ' ' '\\\\n' | wc -l)\\n    COUNTER=1\\n    while [  $COUNTER -le $A ]; do\\n    \\tawk -v temp=$COUNTER '{ printf(\"%s \", $temp) }' file.txt\\n    \\techo \"\"\\n    \\tlet COUNTER=COUNTER+1 \\n    done",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    A=$(head -1 file.txt | tr ' ' '\\\\n' | wc -l)\\n    COUNTER=1\\n    while [  $COUNTER -le $A ]; do\\n    \\tawk -v temp=$COUNTER '{ printf(\"%s \", $temp) }' file.txt\\n    \\techo \"\"\\n    \\tlet COUNTER=COUNTER+1 \\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55524,
                "title": "building-matrix-with-awk",
                "content": "\\nI had to use \\n\\n - NF!=0 to remove any blank lines and  save rows and \\n - cols=NF to be used in END{} block.\\n\\n    awk 'NF!=0 {for(c=1;c<=NF;c++) mtx[NR,c]=$c; rows++; cols=NF;} END{for(c=1;c<=cols;c++) { line=mtx[1,c]; for(r=2;r<=rows;r++) { line=line\" \"mtx[r,c]}; print line; }}' file.txt",
                "solutionTags": [],
                "code": "\\nI had to use \\n\\n - NF!=0 to remove any blank lines and  save rows and \\n - cols=NF to be used in END{} block.\\n\\n    awk 'NF!=0 {for(c=1;c<=NF;c++) mtx[NR,c]=$c; rows++; cols=NF;} END{for(c=1;c<=cols;c++) { line=mtx[1,c]; for(r=2;r<=rows;r++) { line=line\" \"mtx[r,c]}; print line; }}' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 2722028,
                "title": "easy-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (FNR == 1) {\\n            t[i] = $i;\\n        } else {\\n            t[i] = t[i] \" \" $i\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; t[i] != \"\"; i++) {\\n        print t[i]\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399773,
                "title": "one-simple-solution",
                "content": "```\\nfor ((i = 1; ; i++)); do\\n    line=$(awk -vn=$i \\'{print $n}\\' file.txt)\\n    [[ $line ]] || break\\n    echo $line\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfor ((i = 1; ; i++)); do\\n    line=$(awk -vn=$i \\'{print $n}\\' file.txt)\\n    [[ $line ]] || break\\n    echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261053,
                "title": "16ms-use-2-dimensions-array-of-awk-so-easy-to-understand",
                "content": "awk \\'{for(j=1;j<=NF;j++){data[NR,j]=$j;}} END {for(ii=1;ii<=NF;ii++){for(jj=1;jj<=NR;jj++){printf \"%s%c\", data[jj,ii],jj==NR?\"\\\\n\":\" \";}}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'{for(j=1;j<=NF;j++){data[NR,j]=$j;}} END {for(ii=1;ii<=NF;ii++){for(jj=1;jj<=NR;jj++){printf \"%s%c\", data[jj,ii],jj==NR?\"\\\\n\":\" \";}}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 1482122,
                "title": "one-liner-4ms",
                "content": "Using xargs, one liner (kinda),\\n**awk**ward shell substitution to avoid creating a variable.\\n\\n```\\nseq \"$(awk \\'{print NF}\\' file.txt | head -n 1)\" |\\n\\txargs -r -I {} sh -c \"awk \\'{print \\\\${}}\\' file.txt | xargs -r\"\\n```",
                "solutionTags": [],
                "code": "```\\nseq \"$(awk \\'{print NF}\\' file.txt | head -n 1)\" |\\n\\txargs -r -I {} sh -c \"awk \\'{print \\\\${}}\\' file.txt | xargs -r\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185158,
                "title": "solution-using-awk-beats-100-of-submissions-0ms-solution",
                "content": "I would definitely recommend this tutorial: http://www.grymoire.com/Unix/Awk.html if you\\'d like to know more about GAWK/NAWK. Similar to sed, awk is used to perform complex editing tasks to streams of text. The main difference is that awk is more suitable for larger editing tasks (those that may need some programming language features).\\n\\nSolution :\\n```\\nwordcount=$(head -1 file.txt | wc -w)\\ncol_n=1\\nwhile [[ $col_n -le $wordcount ]]; do\\n\\tawk \"{ print \\\\$$col_n }\" file.txt | paste -sd \" \"\\n\\tcol_n=$((col_n + 1))\\ndone\\n```\\n\\nHere\\'re some quick notes to help you understand:\\n\\nThe code block with an \"END\" prefix is only executed after the last line is read; similarly, a code block with a \"BEGIN\" prefix will be executed before any line reads.\\n\\nAWK is line-based: the main code block (the code block without prefix) processes one line of input at a time.",
                "solutionTags": [],
                "code": "```\\nwordcount=$(head -1 file.txt | wc -w)\\ncol_n=1\\nwhile [[ $col_n -le $wordcount ]]; do\\n\\tawk \"{ print \\\\$$col_n }\" file.txt | paste -sd \" \"\\n\\tcol_n=$((col_n + 1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014550,
                "title": "here-is-my-simple-solution",
                "content": "```\\nnum_row=$(head -1 file.txt | wc -w)\\ni=1;\\nwhile [[ $i -le $num_row ]] ; do\\n#Print the ith column of each row and join together\\nawk \"{print \\\\$$i}\" file.txt | paste -s -d \\' \\';\\n((i=$i+1))\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnum_row=$(head -1 file.txt | wc -w)\\ni=1;\\nwhile [[ $i -le $num_row ]] ; do\\n#Print the ith column of each row and join together\\nawk \"{print \\\\$$i}\" file.txt | paste -s -d \\' \\';\\n((i=$i+1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816087,
                "title": "simple-4-line-answer",
                "content": "```\\nncols=`head -n1 file.txt | wc -w`\\nfor i in `seq 1 $ncols`; do\\n    cat file.txt | awk \"{ print \\\\$$i }\" | xargs\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nncols=`head -n1 file.txt | wc -w`\\nfor i in `seq 1 $ncols`; do\\n    cat file.txt | awk \"{ print \\\\$$i }\" | xargs\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55512,
                "title": "solution-using-associative-array-transpose-file",
                "content": "    # Read from the file file.txt and print its transposed content to stdout.\\n    #!/bin/bash\\n    \\n    declare -A matrix\\n    col=1\\n    row=1\\n    \\n    while read line; do\\n        col=1\\n        for word in $line; do\\n                matrix[$row,$col]=$word\\n                ((col++))\\n        done\\n        ((row++))\\n    done < file.txt\\n    \\n    for ((i=1;i<col;i++)) do\\n        echo -n ${matrix[1,$i]} \\n        for((j=2;j<row;j++)) do\\n                echo -n ' '${matrix[$j,$i]}\\n        done\\n        echo\\n    done",
                "solutionTags": [],
                "code": "    # Read from the file file.txt and print its transposed content to stdout.\\n    #!/bin/bash\\n    \\n    declare -A matrix\\n    col=1\\n    row=1\\n    \\n    while read line; do\\n        col=1\\n        for word in $line; do\\n                matrix[$row,$col]=$word\\n                ((col++))\\n        done\\n        ((row++))\\n    done < file.txt\\n    \\n    for ((i=1;i<col;i++)) do\\n        echo -n ${matrix[1,$i]} \\n        for((j=2;j<row;j++)) do\\n                echo -n ' '${matrix[$j,$i]}\\n        done\\n        echo\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 2729918,
                "title": "cut-tr",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll lines have same number of columns. So we may iterate  by columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet number of columns and itterate over it, by getting coumn via `cut`\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfor i in $(seq $(head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l) ); do\\n  line=$(cut -f $i -d \\' \\' file.txt | tr \\'\\\\n\\' \\' \\')\\n  echo ${line%% }\\ndone \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nfor i in $(seq $(head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l) ); do\\n  line=$(cut -f $i -d \\' \\' file.txt | tr \\'\\\\n\\' \\' \\')\\n  echo ${line%% }\\ndone \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2184394,
                "title": "for-loop-one-liner-with-cut",
                "content": "Using word count to return number of columns, and printing each column with cut.\\n```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747876,
                "title": "very-simple-count-columns-and-awk-4-lines",
                "content": "```\\nnum_columns=$(head -n 1 file.txt | wc | awk \\'{print $2}\\')\\nfor i in `seq 1 $num_columns`; do\\n  awk -v i=$i \\'{print $i}\\' file.txt | xargs echo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnum_columns=$(head -n 1 file.txt | wc | awk \\'{print $2}\\')\\nfor i in `seq 1 $num_columns`; do\\n  awk -v i=$i \\'{print $i}\\' file.txt | xargs echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559802,
                "title": "bash-two-solutions-awk-bash",
                "content": "The first solution is to use `awk` in which we define an arrary whose `i`th element represents the `i`th column of the input. \\n\\nImplementation (8ms, 81.24%): \\n```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        s[i] = s[i]?s[i] FS $i:$i\\n    }\\n}\\nEND {\\n    for (i in s) {\\n        print s[i]\\n    }\\n}\\' file.txt\\n```\\n\\nThe 2nd solution is to use pure bash in which we define array `arr` whose `i`th element stores the `i`th column of input. \\n\\nImplementation (144ms, 5.16%): \\n```\\ndeclare -a arr\\n\\nwhile IFS= read -r line\\ndo\\n    i=0\\n    for word in $line\\n    do\\n        [[ ${arr[$i]} ]] && arr[$i]=\"${arr[$i]} $word\" || arr[$i]=$word\\n        ((i++))\\n    done\\ndone < file.txt\\n\\nfor ((i=0; i < ${#arr[@]}; i++))\\ndo\\n    echo ${arr[i]}\\ndone\\n```\\n\\nClearly the 1st solution is superior since it is dramtically faster and shorter. Here, bash has an unpleasant fact that in range-based for loop an element with more than one word would be displayed in many lines, e.g.  \\n\\n```\\narr=(apple \"passion fruit\" banana)\\n\\nfor ele in ${arr[@]}\\ndo\\n    echo $ele\\ndone\\n```\\noutputs below in which `passion` and `fruit` are on two lines. \\n```\\napple\\npassion\\nfruit\\nbanana\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        s[i] = s[i]?s[i] FS $i:$i\\n    }\\n}\\nEND {\\n    for (i in s) {\\n        print s[i]\\n    }\\n}\\' file.txt\\n```\n```\\ndeclare -a arr\\n\\nwhile IFS= read -r line\\ndo\\n    i=0\\n    for word in $line\\n    do\\n        [[ ${arr[$i]} ]] && arr[$i]=\"${arr[$i]} $word\" || arr[$i]=$word\\n        ((i++))\\n    done\\ndone < file.txt\\n\\nfor ((i=0; i < ${#arr[@]}; i++))\\ndo\\n    echo ${arr[i]}\\ndone\\n```\n```\\narr=(apple \"passion fruit\" banana)\\n\\nfor ele in ${arr[@]}\\ndo\\n    echo $ele\\ndone\\n```\n```\\napple\\npassion\\nfruit\\nbanana\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 257710,
                "title": "one-line-ac-bash-but-runs-slow",
                "content": "\\n```\\ni=0 && for item in `head -1 file.txt `; do let i++; cut -d \\' \\' -f $i file.txt | xargs; done\\n```",
                "solutionTags": [],
                "code": "```\\ni=0 && for item in `head -1 file.txt `; do let i++; cut -d \\' \\' -f $i file.txt | xargs; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55515,
                "title": "my-24ms-unreadable-solution",
                "content": "    #! /bin/bash\\n    export LC_ALL=C\\n    col_num=$(awk -F' ' 'NR==1{print NF}' file.txt)\\n    awk -F' ' -v n_col=$col_num 'BEGIN{for(i=1;i<=n_col;++i) line[i]=\"\"}{for(i=1;i<=NF;++i){line[i]=sprintf(\"%s %s\", line[i], $i)}}END{for(i=1;i<=n_col;++i) print line[i]}'  file.txt | sed \"s;^ ;;g\"",
                "solutionTags": [],
                "code": "    #! /bin/bash\\n    export LC_ALL=C\\n    col_num=$(awk -F' ' 'NR==1{print NF}' file.txt)\\n    awk -F' ' -v n_col=$col_num 'BEGIN{for(i=1;i<=n_col;++i) line[i]=\"\"}{for(i=1;i<=NF;++i){line[i]=sprintf(\"%s %s\", line[i], $i)}}END{for(i=1;i<=n_col;++i) print line[i]}'  file.txt | sed \"s;^ ;;g\"",
                "codeTag": "Unknown"
            },
            {
                "id": 3006832,
                "title": "awk-command",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved by reading the input file line by line, and storing the values in each column in an array. Then, the transposed content can be printed by iterating through the array and printing the values stored in each element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to this problem is to use the awk command to read the input file and store the values in an array. awk is a programming language designed for text processing, which makes it well-suited for this task.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis will depend on the implementation of awk and the size of the file. In general, the time complexity of awk is linear with respect to the size of the input.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis will also depend on the implementation of awk and the size of the file. In general, the space complexity of awk is linear with respect to the size of the input.\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1363331,
                "title": "easy-solution-use-awk-and-cut",
                "content": "```\\n#!/bin/bash\\n\\nc=$(cat file.txt | awk -F\\' \\' END\\'{print NF}\\');\\n\\nfor i in $(seq 1 $c);\\ndo\\n        k=$(cut -d\\' \\' -f $i file.txt);\\n        echo $k;\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\nc=$(cat file.txt | awk -F\\' \\' END\\'{print NF}\\');\\n\\nfor i in $(seq 1 $c);\\ndo\\n        k=$(cut -d\\' \\' -f $i file.txt);\\n        echo $k;\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269297,
                "title": "pure-bash-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\ndeclare -A transposed\\nnrows=0\\nncols=0\\nwhile read -r -a row; do\\n    for ((i = 0; i < ${#row[@]}; i++)); do\\n        transposed[$i,$nrows]=${row[i]}\\n    done\\n    ((nrows++))\\n    ncols=${#row[@]}\\ndone < file.txt\\n\\nfor ((r = 0; r < ncols; r++)); do\\n    sep=\\n    for ((c = 0; c < nrows; c++)); do\\n        printf \\'%s%s\\' \"$sep\" \"${transposed[$r,$c]}\"\\n        sep=\" \"\\n    done\\n    printf \\'\\\\n\\'\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\ndeclare -A transposed\\nnrows=0\\nncols=0\\nwhile read -r -a row; do\\n    for ((i = 0; i < ${#row[@]}; i++)); do\\n        transposed[$i,$nrows]=${row[i]}\\n    done\\n    ((nrows++))\\n    ncols=${#row[@]}\\ndone < file.txt\\n\\nfor ((r = 0; r < ncols; r++)); do\\n    sep=\\n    for ((c = 0; c < nrows; c++)); do\\n        printf \\'%s%s\\' \"$sep\" \"${transposed[$r,$c]}\"\\n        sep=\" \"\\n    done\\n    printf \\'\\\\n\\'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187882,
                "title": "awk-using-nf-and-nr",
                "content": "```\\nawk \\'{\\n    for (i=1; i<=NF; ++i) {\\n        if (NR==1) s[i] = $i;\\n        else s[i] = s[i] \" \" $i;}\\n} \\nEND {\\n    for (i=1; i<=NF ; ++i)\\n        print s[i];\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{\\n    for (i=1; i<=NF; ++i) {\\n        if (NR==1) s[i] = $i;\\n        else s[i] = s[i] \" \" $i;}\\n} \\nEND {\\n    for (i=1; i<=NF ; ++i)\\n        print s[i];\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699640,
                "title": "awk-simple-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nNUM_FIELDS=`cat file.txt | head -1 | awk \\'{ print NF}\\'`\\n\\nlet count=1\\nwhile [ $count -le $NUM_FIELDS ]; do\\n    result=`cat file.txt | awk -v x=$count \\'{print $x}\\'`\\n    echo $result\\n\\nlet count+=1\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nNUM_FIELDS=`cat file.txt | head -1 | awk \\'{ print NF}\\'`\\n\\nlet count=1\\nwhile [ $count -le $NUM_FIELDS ]; do\\n    result=`cat file.txt | awk -v x=$count \\'{print $x}\\'`\\n    echo $result\\n\\nlet count+=1\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697637,
                "title": "horrible-perl-solution-nice-ruby-solution",
                "content": "I originally tried to solve this with a ruby oneliner, but ruby\\'s not on the system. Here\\'s my perl solution (I am not a perl coder, this is basically my best attempt to translate my ruby version below):\\n\\n```\\ncat file.txt | perl -ne \\'\\n    BEGIN {\\n        use strict;\\n        use warnings;\\n        my @in_lines = [];\\n    };\\n    push(@in_lines, [split(\" \", $_)]);\\n    END {\\n        $outer_len = @in_lines;\\n        $inner_len = @{$in_lines[0]};\\n        for (my $inner_index = 0; $inner_index < $inner_len; $inner_index++) {\\n            $first = 1;\\n            for (my $outer_index = 0; $outer_index < $outer_len; $outer_index++) {\\n                if ($first) { $first = 0; } else { print(\" \"); }\\n                print($in_lines[$outer_index]->[$inner_index]);\\n            }\\n            print(\"\\\\n\");\\n        }\\n    }\\'\\n```\\n\\nHere\\'s my ruby solution (which I think is nice):\\n```\\ncat file.txt | ruby -ne \\'\\n    BEGIN { lines = []; }\\n    lines << $_.split(\" \");\\n    END { puts lines.transpose.map { |sub| sub.join(\" \")}; }\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | perl -ne \\'\\n    BEGIN {\\n        use strict;\\n        use warnings;\\n        my @in_lines = [];\\n    };\\n    push(@in_lines, [split(\" \", $_)]);\\n    END {\\n        $outer_len = @in_lines;\\n        $inner_len = @{$in_lines[0]};\\n        for (my $inner_index = 0; $inner_index < $inner_len; $inner_index++) {\\n            $first = 1;\\n            for (my $outer_index = 0; $outer_index < $outer_len; $outer_index++) {\\n                if ($first) { $first = 0; } else { print(\" \"); }\\n                print($in_lines[$outer_index]->[$inner_index]);\\n            }\\n            print(\"\\\\n\");\\n        }\\n    }\\'\\n```\n```\\ncat file.txt | ruby -ne \\'\\n    BEGIN { lines = []; }\\n    lines << $_.split(\" \");\\n    END { puts lines.transpose.map { |sub| sub.join(\" \")}; }\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 634826,
                "title": "similar-to-solution-using-awk-jut-the-for-loop-is-simple",
                "content": "```\\nawk \\'{ for (i=1; i<=NF; i++) {\\n            if (NR==1) s[i]=$i; \\n            else s[i] = s[i] \" \" $i;\\n        }\\n     } END { for (i in s) print s[i] }\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{ for (i=1; i<=NF; i++) {\\n            if (NR==1) s[i]=$i; \\n            else s[i] = s[i] \" \" $i;\\n        }\\n     } END { for (i in s) print s[i] }\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 604975,
                "title": "script-using-awk",
                "content": "```\\nnumColumns=`head -1 file.txt | awk \\'{print NF}\\'`\\ni=1\\nwhile [ $i -le $numColumns ]\\ndo\\nawk -v ind=$i \\'{print $ind}\\' file.txt | xargs\\ni=`expr $i + 1`\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nnumColumns=`head -1 file.txt | awk \\'{print NF}\\'`\\ni=1\\nwhile [ $i -le $numColumns ]\\ndo\\nawk -v ind=$i \\'{print $ind}\\' file.txt | xargs\\ni=`expr $i + 1`\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561434,
                "title": "simple-fast-readable-awk-solution-4ms-3-5mb",
                "content": "I spent way too long getting the hang of `awk` to make this happen.\\n\\nopted for concatenating each column into its own string, separated by a space.\\n\\n```\\ncat file.txt | awk \\'\\n{\\n    for(i=1; i <= NF; i++){\\n        data[i] = ((i in data) ? data[i] \" \" : \"\") $i\\n    }\\n} END {\\n    for(i in data){\\n        print data[i]\\n    }\\n}\\'\\n```\\n\\nI think this should work even on variable number of columns.",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'\\n{\\n    for(i=1; i <= NF; i++){\\n        data[i] = ((i in data) ? data[i] \" \" : \"\") $i\\n    }\\n} END {\\n    for(i in data){\\n        print data[i]\\n    }\\n}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520760,
                "title": "awk-solution-use-array",
                "content": "```\\ncat file.txt | awk \\'BEGIN{fs=ofs=\" \";dic[0] = 0;count=0}{for(i=1;i<=NF;i+=1){if(length(dic[i])==0){dic[i]=$i}else{dic[i]=dic[i]\" \"$i}}; count=NF}END{for(i=1;i<=count;i+=1){print dic[i]}}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'BEGIN{fs=ofs=\" \";dic[0] = 0;count=0}{for(i=1;i<=NF;i+=1){if(length(dic[i])==0){dic[i]=$i}else{dic[i]=dic[i]\" \"$i}}; count=NF}END{for(i=1;i<=count;i+=1){print dic[i]}}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417403,
                "title": "nice-and-easy",
                "content": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "solutionTags": [],
                "code": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 316934,
                "title": "simple-awk-solution",
                "content": "```\\nawk \\' { for (i = 1; i <= NF; ++i)  if (NR == 1) cols[i] = $i;  else  cols[i] =  cols[i] \" \" $i } END { for (i in cols) print cols[i]}\\' file.txt \\n```",
                "solutionTags": [],
                "code": "```\\nawk \\' { for (i = 1; i <= NF; ++i)  if (NR == 1) cols[i] = $i;  else  cols[i] =  cols[i] \" \" $i } END { for (i in cols) print cols[i]}\\' file.txt \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227458,
                "title": "using-awk",
                "content": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193762,
                "title": "solution-with-perl",
                "content": "Actually Perl is allowed.\\n```\\nperl -e \\'$i=0;while(<>){$j=0;foreach(split){$file[$i][$j]=$_;$j++;}$i++;}foreach $jj (0..$j-1){\\nforeach $ii (0..$i-1){$output.=$file[$ii][$jj];$output.=$ii==$i-1?\"\":\" \";}$output.=\"\\\\n\";}\\nprint $output;\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nperl -e \\'$i=0;while(<>){$j=0;foreach(split){$file[$i][$j]=$_;$j++;}$i++;}foreach $jj (0..$j-1){\\nforeach $ii (0..$i-1){$output.=$file[$ii][$jj];$output.=$ii==$i-1?\"\":\" \";}$output.=\"\\\\n\";}\\nprint $output;\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55504,
                "title": "ac-solution-using-python3",
                "content": "just share my simple solution\\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(' ') for line in open('file.txt')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```\\n`<<EOF` is really a helpful syntax",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(' ') for line in open('file.txt')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4092401,
                "title": "jidejj",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\n# Define the input file\\ninput_file=\"file.txt\"\\n\\n# Check if the file exists\\nif [ ! -f \"$input_file\" ]; then\\n    echo \"File not found: $input_file\"\\n    exit 1\\nfi\\n\\n# Use awk to transpose the file content\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            rows[i] = $i;\\n        } else {\\n            rows[i] = rows[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print rows[i];\\n    }\\n}\\n\\' \"$input_file\"\\n                                \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\n# Define the input file\\ninput_file=\"file.txt\"\\n\\n# Check if the file exists\\nif [ ! -f \"$input_file\" ]; then\\n    echo \"File not found: $input_file\"\\n    exit 1\\nfi\\n\\n# Use awk to transpose the file content\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (NR == 1) {\\n            rows[i] = $i;\\n        } else {\\n            rows[i] = rows[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print rows[i];\\n    }\\n}\\n\\' \"$input_file\"\\n                                \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017176,
                "title": "awk-gets-the-job-done",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen approaching this problem, the first thing that comes to mind is finding a way to swap the rows and columns of the file content. To achieve this, we need to think about how to read the file and store its content in a way that allows for easy transposition. We can then output the transposed content to the console or another file.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we will use the `awk` command-line utility, which is a powerful tool for text processing.\\n\\nIn the code, we start by defining an awk script enclosed in single quotes. The script consists of two parts: the main code block and the `END` block.\\n\\nIn the main code block, we iterate over each line of the input file using the default behavior of awk. For each line, we use a for loop to iterate over the fields `$i` separated by whitespace. We then store each field in the array `a` with the column index `i` and the row index `NR`, which represents the current line number.\\n\\nAfter processing all the lines, we move to the `END` block. Here, we iterate over the array `a` by nested for loops. The outer loop iterates over the columns `i`, and the inner loop iterates over the rows `j`. We use the `printf` statement to print the transposed content by accessing the elements of the array with the indices `a[i, j]`. We add the appropriate separators (`RS` for the end of a row and `FS` for the space between elements) to format the output correctly.\\n\\nFinally, we execute the `awk` command by passing the input file `file.txt` as an argument. The transposed content is then printed to the standard output `stdout`.\\n\\nUsing `awk` allows us to efficiently read and process the file, store the content in an array, and print the transposed result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where $$n$$ represents the total number of elements in the input file. This is because we need to iterate over each line and each field in the file to store them in the array. The nested loops in the `END` block also contribute to the linear time complexity.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ because we need to store the content of the input file in the array `a`. The size of the array depends on the number of elements in the file, which is directly proportional to the space complexity. The additional space used by variables and temporary storage is negligible compared to the size of the input file.\\n# Runtime & Memory\\n![Screenshot 2023-09-08 at 11.52.36.png](https://assets.leetcode.com/users/images/f72741b1-5778-47f3-b2f9-eebced5848af_1694156608.758566.png)\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        a[i, NR] = $i\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        for (j = 1; j <= NR; j++) {\\n            printf \"%s%s\", a[i, j], (j == NR ? RS : FS)\\n        }\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        a[i, NR] = $i\\n    }\\n}\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        for (j = 1; j <= NR; j++) {\\n            printf \"%s%s\", a[i, j], (j == NR ? RS : FS)\\n        }\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938515,
                "title": "perl-solution",
                "content": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nperl <<\\'EOF\\' - file.txt\\n    my @rows;\\n    while (<>) {\\n        my @words = split /\\\\s+/;\\n        foreach my $i (0 .. $#words) {\\n            push @{$rows[$i]}, $words[$i];\\n        }\\n    }\\n    print join(\\' \\' => @$_), \"\\\\n\" for (@rows)\\nEOF\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nperl <<\\'EOF\\' - file.txt\\n    my @rows;\\n    while (<>) {\\n        my @words = split /\\\\s+/;\\n        foreach my $i (0 .. $#words) {\\n            push @{$rows[$i]}, $words[$i];\\n        }\\n    }\\n    print join(\\' \\' => @$_), \"\\\\n\" for (@rows)\\nEOF\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919684,
                "title": "bash-no-awk-just-bash-arrays",
                "content": "The best performimg solution to this problem use `awk`, but I wanted to see if I could to this using bash arrays instead.\\n\\nIt possible, but it\\'s not pretty...\\n\\n# Code\\n```\\ninput=\"file.txt\"\\ndeclare -a lines=()\\n\\nrows=$((0))\\n\\n# Read the input into an array\\n# bash does not seem to support 2D arrays\\n# so it\\'s just 1D\\nwhile IFS=\\' \\' read -a line\\ndo\\n  columns=${#line[@]}\\n  rows=$(($rows + 1))\\n  lines=(${lines[@]} ${line[@]})\\ndone < \"$input\"\\n\\n\\n# Index into the array to transpose it\\n# building output line by line\\nfor ((c = 0; c < $columns; c++ ))\\ndo\\n  line=${lines[$c]}\\n  for ((r = 1; r < $rows; r++)) do\\n    line=\"$line ${lines[$(($c + $r * $columns))]}\"\\n  done\\n  echo $line\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ninput=\"file.txt\"\\ndeclare -a lines=()\\n\\nrows=$((0))\\n\\n# Read the input into an array\\n# bash does not seem to support 2D arrays\\n# so it\\'s just 1D\\nwhile IFS=\\' \\' read -a line\\ndo\\n  columns=${#line[@]}\\n  rows=$(($rows + 1))\\n  lines=(${lines[@]} ${line[@]})\\ndone < \"$input\"\\n\\n\\n# Index into the array to transpose it\\n# building output line by line\\nfor ((c = 0; c < $columns; c++ ))\\ndo\\n  line=${lines[$c]}\\n  for ((r = 1; r < $rows; r++)) do\\n    line=\"$line ${lines[$(($c + $r * $columns))]}\"\\n  done\\n  echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807270,
                "title": "bash-awk",
                "content": "```\\n#!/bin/bash\\n\\nawk \\'\\n{\\n    # loop over words in curr line\\n    for (i = 1; i <= NF; i++) {\\n        # if first line\\n        if(NR == 1) {\\n            # init array ans[i] with first word of each line\\n            ans[i] = $i;\\n        } else {\\n            # append words to ans[i]\\n            ans[i] = ans[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    # print ans array\\n    for (i = 1; ans[i] != \"\"; i++) {\\n        print ans[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/bash\\n\\nawk \\'\\n{\\n    # loop over words in curr line\\n    for (i = 1; i <= NF; i++) {\\n        # if first line\\n        if(NR == 1) {\\n            # init array ans[i] with first word of each line\\n            ans[i] = $i;\\n        } else {\\n            # append words to ans[i]\\n            ans[i] = ans[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    # print ans array\\n    for (i = 1; ans[i] != \"\"; i++) {\\n        print ans[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713407,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nseq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nseq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3598971,
                "title": "solution-using-loop-bash-hyder-nabi",
                "content": "# Complexity \\nM: No of Lines\\nN: No of Words in each Line\\n- Time complexity: $$O(M*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M*N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nfile=\"file.txt\"\\nwhile read line; do\\n\\tIFS=\\' \\' read -ra Arr <<< \"$line\";\\n\\tfor j in ${!Arr[@]}; do\\n\\t\\tmat[j]+=\" ${Arr[j]}\";\\n\\tdone\\t\\ndone < $file;\\n\\nfor i in ${!mat[@]}; do\\n\\techo ${mat[i]};\\ndone;\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\nfile=\"file.txt\"\\nwhile read line; do\\n\\tIFS=\\' \\' read -ra Arr <<< \"$line\";\\n\\tfor j in ${!Arr[@]}; do\\n\\t\\tmat[j]+=\" ${Arr[j]}\";\\n\\tdone\\t\\ndone < $file;\\n\\nfor i in ${!mat[@]}; do\\n\\techo ${mat[i]};\\ndone;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514033,
                "title": "awk-please-don-t-roast-my-bash-i-am-python-noob-arch-linux-sheesh",
                "content": "# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nThis script uses awk to read the input file and transpose its content. It maintains an array transposed where each element represents a column in the transposed output. For each row, it appends the corresponding fields to the respective column in the transposed array. Finally, it prints the transposed content.\\r\\n\\r\\nThis approach is more efficient for larger inputs compared to reading the file into an array in Bash. It leverages the power of awk for handling large datasets efficiently.\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(NM)$$\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(N)$$\\r\\n# Code\\r\\n```\\r\\n#!/bin/bash\\r\\n\\r\\n# Use awk to transpose the content\\r\\nawk \\'\\r\\n{\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        if (NR == 1) {\\r\\n            # For the first row, create an array with the fields as columns\\r\\n            transposed[i] = $i\\r\\n        } else {\\r\\n            # For subsequent rows, append the fields to the corresponding column\\r\\n            transposed[i] = transposed[i] \" \" $i\\r\\n        }\\r\\n    }\\r\\n}\\r\\nEND {\\r\\n    # Print the transposed content\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        print transposed[i]\\r\\n    }\\r\\n}\\' file.txt\\r\\n\\r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\r\\n#!/bin/bash\\r\\n\\r\\n# Use awk to transpose the content\\r\\nawk \\'\\r\\n{\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        if (NR == 1) {\\r\\n            # For the first row, create an array with the fields as columns\\r\\n            transposed[i] = $i\\r\\n        } else {\\r\\n            # For subsequent rows, append the fields to the corresponding column\\r\\n            transposed[i] = transposed[i] \" \" $i\\r\\n        }\\r\\n    }\\r\\n}\\r\\nEND {\\r\\n    # Print the transposed content\\r\\n    for (i=1; i<=NF; i++) {\\r\\n        print transposed[i]\\r\\n    }\\r\\n}\\' file.txt\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420456,
                "title": "bash-command-concise-code-steps-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. This script uses awk, a text processing tool, to read the contents of the file and transpose them. Here\\'s how it works:\\n\\n2. For each field in each row of the input file, it stores the field in an array a with indices i (column) and NR (row number).\\n\\n3. After reading the entire file, it loops over the columns and rows of the array a, printing each element separated by a space. When it reaches the end of a row, it prints a newline character.\\n\\n\\n# Complexity\\n\\n1. Reading the file into a 2D array takes O(NM) time and O(NM) space, where N is the number of rows in the file, M is the number of columns in the file, and we assume that each field is of constant length.\\n\\n2. Transposing the array takes O(NM) time and O(NM) space, since we are constructing a new 2D array with dimensions M x N.\\n\\n3. Printing the transposed array takes O(N*M) time and O(1) space, since we are just printing each element once.\\n- Time complexity: O(NM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NM)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf(\"%s\",a[i,j]); if (j!=NR) printf(\" \");} printf(\"\\\\n\")}}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{for (i=1; i<=NF; i++) {a[i,NR]=$i}} END {for (i=1; i<=NF; i++) {for (j=1; j<=NR; j++) {printf(\"%s\",a[i,j]); if (j!=NR) printf(\" \");} printf(\"\\\\n\")}}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389186,
                "title": "transpose-file-bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370714,
                "title": "194-transpose-file",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe task is to transpose the given text file, which means we need to convert the rows of the file to columns and vice versa.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne way to approach this problem is to use a bash script that reads the text file line by line, splits each line using the space delimiter, and stores the values in an array. Then, we can use another loop to iterate over the columns and store them in a separate array. Finally, we can print the transposed content of the file by iterating over the columns and printing each row.\\n\\n# Algorithm\\nRead the text file line by line using a loop\\nFor each line, split the line using the space delimiter and store the values in an array\\nUse another loop to iterate over the columns and store them in a separate array\\nFinally, print the transposed content of the file by iterating over the columns and printing each row\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(m*n), where m is the number of rows and n is the number of columns in the text file. This is because we need to read each line of the file and split it into an array of n elements\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is also O(m*n) because we need to store the entire contents of the file in an array of m rows and n columns. However, since we are transposing the content of the file, we only need to store the transpose of the file, which means we can optimize the space complexity by storing only n rows and m columns.\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{ for(i=1; i<=NF; i++) { a[i,NR]=$i; } } END { for(i=1; i<=NF; i++) { printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\"); } }\\' file.txt\\n\\n```\\nThis command reads the content of file.txt and creates an array a to store the values. The first loop for(i=1; i<=NF; i++) iterates over the columns and rows of the file, and assigns the value of each field to the corresponding position in the array (a[i,NR]=$i). The second loop for(i=1; i<=NF; i++) iterates over the columns of the array, and prints the values of each row in transposed order (printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\");).\\n\\nThe time complexity of this solution is O(mn), where m is the number of rows and n is the number of columns in the file. The space complexity is also O(mn), since the entire file is stored in the a array.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{ for(i=1; i<=NF; i++) { a[i,NR]=$i; } } END { for(i=1; i<=NF; i++) { printf(\"%s\", a[i,1]); for(j=2; j<=NR; j++) { printf(\" %s\", a[i,j]); } printf(\"\\\\n\"); } }\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368166,
                "title": "solution-using-awk",
                "content": "# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{\\n    for(i=1;i<=NF;++i)columns[i][NR]=$i;\\n}\\nEND {\\n    for(c in columns) {\\n        has_elem=0;\\n        for(l in columns[c]) {\\n            if(has_elem==1) printf(\" \");\\n            has_elem=1;\\n            printf(\"%s\", columns[c][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'{\\n    for(i=1;i<=NF;++i)columns[i][NR]=$i;\\n}\\nEND {\\n    for(c in columns) {\\n        has_elem=0;\\n        for(l in columns[c]) {\\n            if(has_elem==1) printf(\" \");\\n            has_elem=1;\\n            printf(\"%s\", columns[c][l]);\\n        }\\n        printf(\"\\\\n\");\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3360683,
                "title": "concise-and-easy-solution-using-temporary-files",
                "content": "# Intuition\\nRead file line by line, transform each line into a column (multiple lines) and save column somewhere for later. At the end combine all columns.\\n\\n# Approach\\nEach line from file is piped to `tr`, which transforms the line to a column by replacing spaces with line breaks. These lines are saved to a temporary file, whose name is remembered in `columnFiles` variable.\\nAfter reading all lines from input file, `paste` combines column-files side-by-side.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + m)$$, where `n` is the number of lines in input file (for reading input); `m` is the number of columns in input file (for combining columns).\\n\\n- Space complexity:\\n$$O(n)$$ memory space, where `n` is a number of lines in input file. The variable holding names of column-files grows with the number of lines (lines are transformed to columns).\\n$$O(n)$$ disk space, where `n` is the size of input file. Solution effectively makes a copy of input file, but splitted to chunks.\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\n# The idea is to transform each line in to a column (multiple lines)\\n# and save it to a separate file. Then combine all columns using `paste`\\n# command, which reads lines from multiple sources and outputs all\\n# that lines joined.\\n\\ncolumnFiles=\"\"\\n\\nwhile read -r line\\ndo\\n    columnFileName=\"$(mktemp)\"\\n    # I use `tee` to save output to file because testing environment forbids output\\n    # redirections. \\n    # The \\'while read\\' cycle after `tee` suppresses tee\\'s output, because, again,\\n    # no output redirections are allowed and 2>/dev/null is not available.\\n    echo \"$line\" | tr -s \\' \\' \\'\\\\n\\' | tee  \"$columnFileName\" | while read -r suppressed; do true; done\\n    columnFiles=\"$columnFiles $columnFileName\"\\ndone <file.txt\\n\\npaste -d \\' \\' $columnFiles\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n\\n# The idea is to transform each line in to a column (multiple lines)\\n# and save it to a separate file. Then combine all columns using `paste`\\n# command, which reads lines from multiple sources and outputs all\\n# that lines joined.\\n\\ncolumnFiles=\"\"\\n\\nwhile read -r line\\ndo\\n    columnFileName=\"$(mktemp)\"\\n    # I use `tee` to save output to file because testing environment forbids output\\n    # redirections. \\n    # The \\'while read\\' cycle after `tee` suppresses tee\\'s output, because, again,\\n    # no output redirections are allowed and 2>/dev/null is not available.\\n    echo \"$line\" | tr -s \\' \\' \\'\\\\n\\' | tee  \"$columnFileName\" | while read -r suppressed; do true; done\\n    columnFiles=\"$columnFiles $columnFileName\"\\ndone <file.txt\\n\\npaste -d \\' \\' $columnFiles\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3349525,
                "title": "really-simple-solution-using-bash-script",
                "content": "Just iterate over each column and print the corresponding row.\\n\\n# Code\\n```\\n#!/bin/sh\\ncols=$(awk \\'{print NF}\\' file.txt | sort -nu | tail -n 1)\\nfor (( c=1; c<=$cols; c++ ))\\ndo  \\n    cat file.txt | awk -v x=$c \\'{print $x}\\' | paste -s -d \\' \\'\\ndone\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/sh\\ncols=$(awk \\'{print NF}\\' file.txt | sort -nu | tail -n 1)\\nfor (( c=1; c<=$cols; c++ ))\\ndo  \\n    cat file.txt | awk -v x=$c \\'{print $x}\\' | paste -s -d \\' \\'\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266001,
                "title": "just-builtins-one-file-pass",
                "content": "Loop over lines, gather line items into successive array elements.  Dump the array afterwards.\\n\\nPure in-memory (filter-like) program: memory consumption is proportional to the file size.\\n\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n# Bash version, uses arrays.  One pass over the input file.\\n\\nexec < file.txt\\n\\nread -r z\\nl=($z)\\n\\nwhile read -r z; do\\n    i=0\\n    for v in $z; do\\n            l[$i]+=\" $v\"\\n            ((i++))\\n    done\\ndone\\n\\nz=${#l[@]}\\nfor ((i=0; i < $z; i++)); do\\n    echo \"${l[$i]}\"\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n# Bash version, uses arrays.  One pass over the input file.\\n\\nexec < file.txt\\n\\nread -r z\\nl=($z)\\n\\nwhile read -r z; do\\n    i=0\\n    for v in $z; do\\n            l[$i]+=\" $v\"\\n            ((i++))\\n    done\\ndone\\n\\nz=${#l[@]}\\nfor ((i=0; i < $z; i++)); do\\n    echo \"${l[$i]}\"\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143221,
                "title": "transpose-file-using-cut-and-awk-explanation",
                "content": "# Approach\\n1. With the help of awk count amount of columns in file\\n2. Make iterator i equal to amount of columns in file\\n3. In for-loop cut columns in file one by one\\n4. Send column to the output\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\ncolumns=$(cat \"file.txt\" | awk -F \\' \\' END\\'{print NF}\\')\\nfor i in $(seq 1 $columns)\\ndo\\noutput=$(cut -f $i -d \\' \\' \"file.txt\")\\necho $output\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\n#!/bin/bash\\n\\ncolumns=$(cat \"file.txt\" | awk -F \\' \\' END\\'{print NF}\\')\\nfor i in $(seq 1 $columns)\\ndo\\noutput=$(cut -f $i -d \\' \\' \"file.txt\")\\necho $output\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3134897,
                "title": "transpose-file-solution",
                "content": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```\n```\\npython3 <<EOF\\nmatrix = [line[:-1].split(\\' \\') for line in open(\\'file.txt\\')]\\nfor column in range(len(matrix[0])):\\n    print(*(matrix[row][column] for row in range(len(matrix))))\\nEOF\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3125300,
                "title": "clean-bash-code-high-speed-beats-98-9",
                "content": "\\n# Code\\n```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3046056,
                "title": "very-detailed-solution-easy-to-understande",
                "content": "# Intuition\\nFirst you need to know what\\'s the number of columns?\\n\\n# Approach\\n1) Using `wc` word count to count the number of lines and the number of words.\\n2) Given that the number of columns is the same in every line you can get the number of columns by `columns = words / lines`.\\n3) Iterate over each column to using `cut` with a `space` as delimiter with specifying the field number.\\n4) Using `tr` you can print the output in a single line by replacing the `newline` with the  `space`. \\n\\n# Code\\n```\\n#!/bin/bash\\nlines=$(cat file.txt |wc -l)\\nwords=$(cat file.txt |wc -w)\\ncolumns=$(($words/$lines))\\n\\nfor (( i=1;i<=$columns;i++ ));\\ndo\\n        echo $(cat file.txt | cut -d \" \" -f $i | tr \\'\\\\n\\' \\' \\') \\ndone  \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\nlines=$(cat file.txt |wc -l)\\nwords=$(cat file.txt |wc -w)\\ncolumns=$(($words/$lines))\\n\\nfor (( i=1;i<=$columns;i++ ));\\ndo\\n        echo $(cat file.txt | cut -d \" \" -f $i | tr \\'\\\\n\\' \\' \\') \\ndone  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989965,
                "title": "my-try",
                "content": "I count the number of columns (as specified they\\'ll be always the same on each line), Then use that number for specify the column to get with awk, then it\\'s easy to convert end lines to spaces and print that line. Doing this for every column will invert the matrix.\\n\\n# Code\\n```\\nNUM=\"$(sed \\'1q;d\\' file.txt | wc -w)\"; for ((i = 1; i <= $NUM; i++));do awk \"{ print \\\\${i} }\" < file.txt | tr \\'\\\\n\\' \\' \\' | xargs; done\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nNUM=\"$(sed \\'1q;d\\' file.txt | wc -w)\"; for ((i = 1; i <= $NUM; i++));do awk \"{ print \\\\${i} }\" < file.txt | tr \\'\\\\n\\' \\' \\' | xargs; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950901,
                "title": "transpose-a-file-without-using-awk-simple-soln",
                "content": "# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nword_count=$(cat file.txt | head -n 1 | wc -w)\\nfor (( i=1; i<=word_count; i++ ));do\\n  cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' |  sed \\'s/.$//\\'\\n  echo\\ndone\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nword_count=$(cat file.txt | head -n 1 | wc -w)\\nfor (( i=1; i<=word_count; i++ ));do\\n  cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' |  sed \\'s/.$//\\'\\n  echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923860,
                "title": "194-transpose-file-by-boolean-autocrats",
                "content": "# Intuition\\nTo transpose the content of a text file, we can read the lines of the file and store each field in an array, with the array index representing the column number. Then, we can iterate over the array and print each element, which represents a transposed row of the file.\\n\\nIn this solution, I used the awk command to read the lines of the file and transpose the content. The awk command is a powerful text-processing utility that can be used to perform complex operations on text files. It reads the input line by line and allows you to specify actions to be taken based on the contents of the input.\\n\\nTo transpose the content of the file, I used the NF variable, which represents the number of fields in the current line, and the NR variable, which represents the current line number. I iterated over the fields of each line and stored them in an array s, with the array index representing the column number. If the current line was the first line of the file, I stored the field in the corresponding array index. If the current line was not the first line, I appended the field to the value stored in the corresponding array index, separated by a space character.\\n\\nFinally, after all the lines of the file had been processed, I iterated over the array and printed each element, which represented a transposed row of the file.\\n\\nI hope this helps to clarify the intuition behind the Bash solution I provided. Let me know if you have any problem in this questions.\\n\\n# Approach\\nThe approach I used to solve this problem was to use the awk command to read the lines of the file and transpose the content.\\n\\nTo do this, I used the NF variable, which represents the number of fields in the current line, and the NR variable, which represents the current line number. I iterated over the fields of each line and stored them in an array s, with the array index representing the column number. If the current line was the first line of the file, I stored the field in the corresponding array index. If the current line was not the first line, I appended the field to the value stored in the corresponding array index, separated by a space character.\\n\\nFinally, after all the lines of the file had been processed, I iterated over the array and printed each element, which represented a transposed row of the file.\\n\\nI hope this helps to clarify the approach I took to solve this problem. Let me know if you have any problem in this questions.\\n# Complexity\\n- Time complexity:The time complexity of the Bash solution I provided for this problem is O(n), where n is the number of lines in the input file.\\n\\nThe awk command reads the input line by line and processes each line in constant time. Therefore, the time complexity of the solution is determined by the number of lines in the input file.\\n\\nIn this solution, I used a loop to iterate over the fields of each line and store them in an array. I also used another loop to iterate over the array and print each element. Both of these loops execute in O(n) time, since they iterate over all the lines of the input file.\\n\\nTherefore, the overall time complexity of this solution is O(n), since it involves two loops that each execute in O(n) time.\\n\\nI hope this helps! Let me know if you have any problem in this questions.\\n\\n\\n- Space complexity:The space complexity of the Bash solution I provided for this problem is O(n), where n is the number of lines in the input file.\\n\\nThis solution stores each field of the input file in an array, with the array index representing the column number. Therefore, the space complexity is determined by the size of the array, which is equal to the number of lines in the input file.\\n\\nIn addition to the array, this solution also uses a few variables to store intermediate results and control the execution of the loops. However, these variables have a constant size and do not contribute significantly to the space complexity of the solution.\\n\\nTherefore, the overall space complexity of this solution is O(n), since it involves storing all the fields of the input file in an array of size n.\\n\\n\\n# Code\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n  for (i=1; i<=NF; i++) {\\n    if(NR == 1) {\\n      s[i] = $i;\\n    } else {\\n      s[i] = s[i] \" \" $i;\\n    }\\n  }\\n}\\nEND {\\n  for (i=1; s[i] != \"\"; i++) {\\n    print s[i];\\n  }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file file.txt and print its transposed content to stdout.\\nawk \\'\\n{\\n  for (i=1; i<=NF; i++) {\\n    if(NR == 1) {\\n      s[i] = $i;\\n    } else {\\n      s[i] = s[i] \" \" $i;\\n    }\\n  }\\n}\\nEND {\\n  for (i=1; s[i] != \"\"; i++) {\\n    print s[i];\\n  }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887070,
                "title": "bash-script-pipes-and-redirections",
                "content": "# Intuition\\nUsing pipes and redirections \\nUsing cut -f to select column by column\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, count the number of columns.\\nThen, start a while with a variabile counter i to cut column by column the input file.\\nFor each column, command tr transpose it to a row, but it adds a \\' \\' (space) at the end of the row. \\nTo overcome this issue (believe me, I failed a submission due to it), the last cut command eliminates the last char of the row. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N), N number of columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\ncolumn=$(cat file.txt | head -n 1 | wc -w)\\n\\ni=1\\nwhile [ $i -le $column ]\\ndo\\n    cat file.txt | cut -d \\' \\' -f $i | tr \\'\\\\n\\' \\' \\' | rev | cut -c2- | rev\\n    let i=i+1\\ndone\\n\\nexit 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2805116,
                "title": "my-not-quick-but-dirty-solution-using-awk",
                "content": "```bash\\nCOLS=$(awk \\'NR == 1 {print NF}\\' file.txt) # Get the number of columns from awk\\nfor ((field=1; field <=$COLS; field++)) # For each column i\\ndo\\n    #For each row j, get element in position (i,j), print it and append space\\n\\tline=$(awk -v field_num=\"$field\" \\'{ORS=\" \"; print $field_num}\\' file.txt)\\n    \\n\\techo \"${line%% }\" #remove trailing space\\ndone\\n```\\nThis code above works but it is not really perfomant (Runtime: 520ms; faster than 30%) since awk has to re-read the whole file for each iteration. I came up with it by skimming through the manual of awk and stumbling upon the ORS variable definition. I just got into Shell Scripting so for a beginner, I think I did pretty alright.",
                "solutionTags": [],
                "code": "```bash\\nCOLS=$(awk \\'NR == 1 {print NF}\\' file.txt) # Get the number of columns from awk\\nfor ((field=1; field <=$COLS; field++)) # For each column i\\ndo\\n    #For each row j, get element in position (i,j), print it and append space\\n\\tline=$(awk -v field_num=\"$field\" \\'{ORS=\" \"; print $field_num}\\' file.txt)\\n    \\n\\techo \"${line%% }\" #remove trailing space\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2624921,
                "title": "my-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if(NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if(NR == 1) {\\n            s[i] = $i;\\n        } else {\\n            s[i] = s[i] \" \" $i;\\n        }\\n    }\\n}\\nEND {\\n    for (i = 1; s[i] != \"\"; i++) {\\n        print s[i];\\n    }\\n}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472406,
                "title": "a-few-short-solutions-on-awk-perl",
                "content": "Perl_#1\\n```\\nperl \\'-alne$r=@F;push@f,@F}{for$a(0..$r-1){print\"@f[map{$_*$r+$a}0..$.-1]\"}\\' < file.txt\\n```\\nPerl_#2\\n```\\nperl \\'-alne$a[$k].=\" $v\"while($k,$v)=each@F}{$,=$\\\\;print@a\\' < file.txt\\n```\\nawk\\n```\\nawk \\'{for(i=1;NF>=i;i++)w[i][NR]=$i}END{for(j=1;i>=j;j++){for(k=1;NR>=k;k++)printf\"%s \",w[j][k];print\"\"}}\\' < file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nperl \\'-alne$r=@F;push@f,@F}{for$a(0..$r-1){print\"@f[map{$_*$r+$a}0..$.-1]\"}\\' < file.txt\\n```\n```\\nperl \\'-alne$a[$k].=\" $v\"while($k,$v)=each@F}{$,=$\\\\;print@a\\' < file.txt\\n```\n```\\nawk \\'{for(i=1;NF>=i;i++)w[i][NR]=$i}END{for(j=1;i>=j;j++){for(k=1;NR>=k;k++)printf\"%s \",w[j][k];print\"\"}}\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256789,
                "title": "for-loop-simple-solution",
                "content": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 $(head -n1 file.txt | wc -w)); do echo $(cut -d\\' \\' -f$i file.txt); done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236632,
                "title": "very-obvious-and-simple-solution-with-awk",
                "content": "It seems very obvious just to do simple cycle `column_count` times each times print specific column\\nxargs used to trim whitespaces and newlines (900 ms, 3.9 MB)\\n\\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    awk \"{printf \\\\\"%s \\\\\",\\\\$$i }\" file.txt | xargs \\ndone\\n```\\n\\nor with cut (273 ms, 3.5 MB)\\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    echo $(cut -d\\' \\' -f$i file.txt); \\ndone\\n```\\n\\nnot obvious but beautifull one (529 ms,  3.9 MB):\\n```bash\\nfor ((i = 1; ; i++)); do \\n\\tline=$(awk \"{print \\\\$$i}\" file.txt); \\n    [[ $line ]] || break && echo $line\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    awk \"{printf \\\\\"%s \\\\\",\\\\$$i }\" file.txt | xargs \\ndone\\n```\n```bash\\ncolumn_count=$(head -n 1 file.txt | wc -w) # get column count\\nfor i in $(seq $column_count); do \\n    echo $(cut -d\\' \\' -f$i file.txt); \\ndone\\n```\n```bash\\nfor ((i = 1; ; i++)); do \\n\\tline=$(awk \"{print \\\\$$i}\" file.txt); \\n    [[ $line ]] || break && echo $line\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2154248,
                "title": "leetcode-problem",
                "content": "Hello.\\nI have a sultion that works on my computer and online bash compiler and the output is fine - as expacted,\\nbut when i submit my solution to Leetcode its says error..  anyone have an idea ??\\n\\n```\\nnames=\\'\\'\\nages=\\'\\'\\n\\nwhile read line || [ -n \"$line\" ]\\ndo\\n\\n\\tnames=\"$names $(echo $line | cut -d \\' \\' -f 1)\"\\n\\tages=\"$ages $(echo $line | cut -d \\' \\' -f 2)\"\\n\\ndone < file.txt\\n\\necho $names\\necho $ages\\n```\\n",
                "solutionTags": [],
                "code": "```\\nnames=\\'\\'\\nages=\\'\\'\\n\\nwhile read line || [ -n \"$line\" ]\\ndo\\n\\n\\tnames=\"$names $(echo $line | cut -d \\' \\' -f 1)\"\\n\\tages=\"$ages $(echo $line | cut -d \\' \\' -f 2)\"\\n\\ndone < file.txt\\n\\necho $names\\necho $ages\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111393,
                "title": "another-while-loop-with-awk",
                "content": "count the numner of columns and loop thru them with an awk\\n| xargs is just to trim the white space that was messing up my tests\\n\\n```\\nnumber_of_columns=$(head -n 1 file.txt | wc -w)\\ncolumn_counter=1\\n\\nwhile [ $column_counter -le $number_of_columns ]\\ndo\\n   awk -v x=$column_counter \\'{print $x}\\' file.txt | tr \"\\\\n\" \" \" | xargs\\n   column_counter=$((column_counter+1))\\ndone\\n```\\n\\ni\\'m embarassed at how long this took me, but better late than never.",
                "solutionTags": [],
                "code": "```\\nnumber_of_columns=$(head -n 1 file.txt | wc -w)\\ncolumn_counter=1\\n\\nwhile [ $column_counter -le $number_of_columns ]\\ndo\\n   awk -v x=$column_counter \\'{print $x}\\' file.txt | tr \"\\\\n\" \" \" | xargs\\n   column_counter=$((column_counter+1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057914,
                "title": "is-using-python-fine",
                "content": "You have to read the whole content to memory, right?\\nI decided to use python for that.\\n\\n```bash\\npython3 -c \\'\\nfrom collections import defaultdict\\ndata = defaultdict(list)\\nwith open(\"file.txt\") as f:\\n   for line in f:\\n       for i, word in enumerate(line.split()):\\n           data[i].append(word)\\nfor line in data.values():\\n    print(\" \".join(line))\\n\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```bash\\npython3 -c \\'\\nfrom collections import defaultdict\\ndata = defaultdict(list)\\nwith open(\"file.txt\") as f:\\n   for line in f:\\n       for i, word in enumerate(line.split()):\\n           data[i].append(word)\\nfor line in data.values():\\n    print(\" \".join(line))\\n\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2052137,
                "title": "yet-another-awk-one-line-solution",
                "content": "awk \\'NR==1{for (i=1;i<=NF;i++){s[i]=$i}}NR>1{for (i=1;i<=NF;i++){s[i]=s[i] \" \" $i}}END{for (i=1;i<=NF;i++){print s[i]}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'NR==1{for (i=1;i<=NF;i++){s[i]=$i}}NR>1{for (i=1;i<=NF;i++){s[i]=s[i] \" \" $i}}END{for (i=1;i<=NF;i++){print s[i]}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 1994989,
                "title": "awk-naive-solution",
                "content": "```\\ncat file.txt | awk \\'\\n(NR==1){ncols = NF}\\n{for(col=1;col<=ncols;col++) a[NR,col] = $col}\\nEND {\\n    for(i=1;i<=NR;i++) {\\n        if(i==1) {for(j=1;j<=ncols;j++) {b[j] = a[i,j]}}\\n        else {for(j=1;j<=ncols;j++) b[j] = b[j] \" \" a[i,j]}\\n    }\\n    for(j=1;j<=ncols;j++) print b[j]\\n}\\n\\'```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'\\n(NR==1){ncols = NF}\\n{for(col=1;col<=ncols;col++) a[NR,col] = $col}\\nEND {\\n    for(i=1;i<=NR;i++) {\\n        if(i==1) {for(j=1;j<=ncols;j++) {b[j] = a[i,j]}}\\n        else {for(j=1;j<=ncols;j++) b[j] = b[j] \" \" a[i,j]}\\n    }\\n    for(j=1;j<=ncols;j++) print b[j]\\n}\\n\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713075,
                "title": "runtime-400-ms-memory-usage-3-5-mb-bash-shell",
                "content": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "solutionTags": [],
                "code": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1533609,
                "title": "split-tr-paste-rm-simple-but-slow",
                "content": "In a sense it isn\\'t trully a Bash script, but one may appreciate a different approach :)\\n```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "solutionTags": [],
                "code": "```\\nsplit -l 1 file.txt _A\\nls _A* | xargs -I % sh -c \"tr <% \\' \\' \\'\\\\n\\' >_%\" \\npaste -d \" \" __A* \\nrm _*\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479122,
                "title": "pure-awk-solution-use-2d-array-like-c",
                "content": "```\\nawk \\'{ \\nfor (i = 1; i <= NF; i++) { num[NR][i] = $i } \\n}\\nEND {\\n\\tfor (i = 1; i <= NF; i++) {\\n\\t\\tfor (j = 1; j <= NR; j++) {\\n\\t\\t\\tprintf \"%s\", num[j][i]\\n\\t\\t\\tif (j < NR) { printf \"%s\", \" \"}\\n\\t\\t}\\n\\t\\tif (i < NF) { print \\'\\\\n\\' }\\n\\t}\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{ \\nfor (i = 1; i <= NF; i++) { num[NR][i] = $i } \\n}\\nEND {\\n\\tfor (i = 1; i <= NF; i++) {\\n\\t\\tfor (j = 1; j <= NR; j++) {\\n\\t\\t\\tprintf \"%s\", num[j][i]\\n\\t\\t\\tif (j < NR) { printf \"%s\", \" \"}\\n\\t\\t}\\n\\t\\tif (i < NF) { print \\'\\\\n\\' }\\n\\t}\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470039,
                "title": "a-simple-solution-awk-sed",
                "content": "```bash\\nCOL=$(awk -F \" \" \\'END{printf NF}\\' file.txt)\\nfor ((i=0; i<$COL; i++));\\ndo\\n        awk \\'{printf $\\'\"$(($i+1))\"\\'\" \"}\\' file.txt | sed \\'s/.$/\\\\n/g\\'\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\nCOL=$(awk -F \" \" \\'END{printf NF}\\' file.txt)\\nfor ((i=0; i<$COL; i++));\\ndo\\n        awk \\'{printf $\\'\"$(($i+1))\"\\'\" \"}\\' file.txt | sed \\'s/.$/\\\\n/g\\'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428262,
                "title": "one-awk-sed-solution",
                "content": "Treat file.txt as a table. firstly use awk to split tables by columns, for a centain colume, using sed to replace \\\\n with a space (this action compare to altering a column of data to a row of data), then use sed to remove the trailing space. column by column.\\n\\n```\\n#!/bin/bash\\n\\ndeclare -i column\\ndeclare -i i\\n\\ncolumn=$(cat file.txt | awk \\'NR==1 {print NF}\\')\\ni=1\\n\\nwhile [[ $i -le $column ]] \\ndo \\n    cat file.txt | awk \\'{print $\\'$i\\'}\\' | sed \\'s/\\\\n/\" \"/\\' | sed \\'s/ $/\\\\n/\\'\\n    let i+=1\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ndeclare -i column\\ndeclare -i i\\n\\ncolumn=$(cat file.txt | awk \\'NR==1 {print NF}\\')\\ni=1\\n\\nwhile [[ $i -le $column ]] \\ndo \\n    cat file.txt | awk \\'{print $\\'$i\\'}\\' | sed \\'s/\\\\n/\" \"/\\' | sed \\'s/ $/\\\\n/\\'\\n    let i+=1\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400251,
                "title": "pure-bash-solution-newline-problems-passed-but-still-weird",
                "content": "Here\\'s a pure bash solution, but I had to mess with the newlines during the output phase to pass this test case\\n```\\na\\n```\\nIf I use echo instead of printf (program below), I get :\\n```\\na\\\\n\\n```\\nwhich makes the test fail ... very picky judge ... Can anyone explain why it makes a difference to not print a newline for the last output line?\\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nallLists=()\\n\\nwhile IFS=\\' \\' read -a LINE;\\ndo\\n    for (( i=0; i<=${#LINE[@]}; i++ ))\\n    do\\n        if [[ -z \"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\" ]]; then\\n            continue\\n        fi\\n        if [ -v allLists[i] ]; then\\n            allLists[$i]=\"${allLists[i]} ${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        else\\n            allLists[$i]=\"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        fi\\n    done\\ndone <\"file.txt\"\\n\\nfor (( i=0; i<=${#allLists[@]}; i++ ))\\ndo\\n    # Can\\'t just use echo ${allLists[i]}, but this mess instead:\\n    printf \\'%s\\' \"${allLists[i]//[$\\'\\\\t\\\\r\\\\n\\']}\"\\n    if (( i < ${#allLists[@]} )); then\\n        printf \\'\\\\n\\'\\n    fi\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\na\\n```\n```\\na\\\\n\\n```\n```\\n# Read from the file file.txt and print its transposed content to stdout.\\nallLists=()\\n\\nwhile IFS=\\' \\' read -a LINE;\\ndo\\n    for (( i=0; i<=${#LINE[@]}; i++ ))\\n    do\\n        if [[ -z \"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\" ]]; then\\n            continue\\n        fi\\n        if [ -v allLists[i] ]; then\\n            allLists[$i]=\"${allLists[i]} ${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        else\\n            allLists[$i]=\"${LINE[i]//[$\\'\\\\t\\\\r\\\\n \\']}\"\\n        fi\\n    done\\ndone <\"file.txt\"\\n\\nfor (( i=0; i<=${#allLists[@]}; i++ ))\\ndo\\n    # Can\\'t just use echo ${allLists[i]}, but this mess instead:\\n    printf \\'%s\\' \"${allLists[i]//[$\\'\\\\t\\\\r\\\\n\\']}\"\\n    if (( i < ${#allLists[@]} )); then\\n        printf \\'\\\\n\\'\\n    fi\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378260,
                "title": "solution-with-cut-pure-bash-no-awk",
                "content": "```\\ndelimiter=\\' \\'\\ncount=`head -n1 file.txt|grep -o \"$delimiter\" |wc -l`\\nfor (( line = 1; line <= $((count+1)); line++ ))\\ndo\\n        outLine=`cat file.txt|cut -d\"$delimiter\" -f$line |tr \\'\\\\n\\' \"$delimiter\"`\\n        lineLen=`echo $outLine|wc --chars`\\n        echo $outLine |cut -c 1-$(($lineLen-1))\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndelimiter=\\' \\'\\ncount=`head -n1 file.txt|grep -o \"$delimiter\" |wc -l`\\nfor (( line = 1; line <= $((count+1)); line++ ))\\ndo\\n        outLine=`cat file.txt|cut -d\"$delimiter\" -f$line |tr \\'\\\\n\\' \"$delimiter\"`\\n        lineLen=`echo $outLine|wc --chars`\\n        echo $outLine |cut -c 1-$(($lineLen-1))\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344331,
                "title": "another-perl-solution",
                "content": "\\n```\\n#!/usr/bin/env perl\\nuse strict;\\nuse warnings;\\nuse Data::Dumper;\\n\\nmy (@words, @a, @b);\\n\\nwhile (<DATA>) {\\n    chomp( my $line = $_ );\\n    @words = split / /,$line;\\n    push @a, $words[0];\\n    push @b, $words[1];\\n}\\n\\nprint Dumper @a;\\nprint \"====\\\\n\";\\nprint Dumper @b;\\n\\n__DATA__\\nname age\\nalice 21\\nryan 30\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/env perl\\nuse strict;\\nuse warnings;\\nuse Data::Dumper;\\n\\nmy (@words, @a, @b);\\n\\nwhile (<DATA>) {\\n    chomp( my $line = $_ );\\n    @words = split / /,$line;\\n    push @a, $words[0];\\n    push @b, $words[1];\\n}\\n\\nprint Dumper @a;\\nprint \"====\\\\n\";\\nprint Dumper @b;\\n\\n__DATA__\\nname age\\nalice 21\\nryan 30\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276318,
                "title": "bash",
                "content": "```\\n#!/usr/bin/bash\\nwhile IFS=\\' \\' read -a l; do\\n        for i in ${!l[@]}; do\\n                a[i]=\"${a[i]} ${l[i]}\"\\n        done\\ndone < file.txt\\nfor i in ${!a[@]}; do\\n        echo ${a[i]}\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/usr/bin/bash\\nwhile IFS=\\' \\' read -a l; do\\n        for i in ${!l[@]}; do\\n                a[i]=\"${a[i]} ${l[i]}\"\\n        done\\ndone < file.txt\\nfor i in ${!a[@]}; do\\n        echo ${a[i]}\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174920,
                "title": "average-awk-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        arr[i] = arr[i] \" \" $i;\\n    }\\n}\\n\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print gensub(/^[ \\\\t]*|[ \\\\t]*$/, \"\", \"g\", arr[i]);\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        arr[i] = arr[i] \" \" $i;\\n    }\\n}\\n\\nEND {\\n    for (i = 1; i <= NF; i++) {\\n        print gensub(/^[ \\\\t]*|[ \\\\t]*$/, \"\", \"g\", arr[i]);\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162707,
                "title": "awk-associative-array-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        transposed[NR, i] = $i \\n    }\\n}\\n\\nEND {\\n    for (r = 1; r <= NF; r++) {\\n        sep = \"\"\\n        for (c = 1; c <= NR; c++) {\\n            printf(\"%s%s\", sep, transposed[c, r])\\n            sep = \" \"\\n        }\\n        printf(\"\\\\n\")\\n    }\\n}\\n\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++) {\\n        transposed[NR, i] = $i \\n    }\\n}\\n\\nEND {\\n    for (r = 1; r <= NF; r++) {\\n        sep = \"\"\\n        for (c = 1; c <= NR; c++) {\\n            printf(\"%s%s\", sep, transposed[c, r])\\n            sep = \" \"\\n        }\\n        printf(\"\\\\n\")\\n    }\\n}\\n\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074958,
                "title": "awk-reading-into-two-dimentional-array-and-printing-it",
                "content": "```\\nawk \\'{for (i=1;i<=NF;i++) {m[i,NR]=$i; a=NR;}}END{i--; for (j=1;j<=i;j++){for (k=1;k<=a;k++){printf(\"%s \",m[j,k])}printf\"\\\\n\"}}\\' file.txt |  sed \\'s/^ *//;s/ *$//;s/  */ /;\\'\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for (i=1;i<=NF;i++) {m[i,NR]=$i; a=NR;}}END{i--; for (j=1;j<=i;j++){for (k=1;k<=a;k++){printf(\"%s \",m[j,k])}printf\"\\\\n\"}}\\' file.txt |  sed \\'s/^ *//;s/ *$//;s/  */ /;\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1073957,
                "title": "this-works-on-my-computer-usr-bin-bash-not-on-leetcode-strange",
                "content": "```\\ncl1=\"\"; cl2=\"\"; i=0; cat file.txt | while read line; do cl1=\"$cl1 `echo $line| awk \\'{print $1}\\'`\"; cl2=\"$cl2 `echo $line | awk \\'{print $2\\'}`\"; i=`expr $i + 1`; if [ $i -eq 3 ]; then echo $cl1; echo $cl2; fi; done;\\n```",
                "solutionTags": [],
                "code": "```\\ncl1=\"\"; cl2=\"\"; i=0; cat file.txt | while read line; do cl1=\"$cl1 `echo $line| awk \\'{print $1}\\'`\"; cl2=\"$cl2 `echo $line | awk \\'{print $2\\'}`\"; i=`expr $i + 1`; if [ $i -eq 3 ]; then echo $cl1; echo $cl2; fi; done;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1058674,
                "title": "awk-and-sed-awk-and-remove-leading-blank-with-sed",
                "content": "\\ncat file.txt |\\n  awk -F\" \" \\'{for (f=1;f<=NF;f++) str[f] = str[f] FS $f}END{for (f=1;f<=NF;f++) print str[f]}\\' |\\n  sed \\'s/^ //g\\'",
                "solutionTags": [],
                "code": "\\ncat file.txt |\\n  awk -F\" \" \\'{for (f=1;f<=NF;f++) str[f] = str[f] FS $f}END{for (f=1;f<=NF;f++) print str[f]}\\' |\\n  sed \\'s/^ //g\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1001883,
                "title": "why-is-this-wrong",
                "content": "Why is this wrong?\\n\\nWhen I run the test cases on my local machine, I get the expected output\\n\\'\\'\\'\\n#!/bin/bash\\n\\nNO_OF_COLUMNS=$(head -n 1 file.txt | awk \\'{print NF}\\')\\n\\nfor (( i=1 ; i<=${NO_OF_COLUMNS} ; i++ ))\\ndo\\n  awk -v j=$i \\'{print $j}\\' file.txt | while read ITEM\\n  do\\n\\n    echo -n \"${ITEM} \"\\n\\n  done\\n  echo\\n\\ndone\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Why is this wrong?\\n\\nWhen I run the test cases on my local machine, I get the expected output\\n\\'\\'\\'\\n#!/bin/bash\\n\\nNO_OF_COLUMNS=$(head -n 1 file.txt | awk \\'{print NF}\\')\\n\\nfor (( i=1 ; i<=${NO_OF_COLUMNS} ; i++ ))\\ndo\\n  awk -v j=$i \\'{print $j}\\' file.txt | while read ITEM\\n  do\\n\\n    echo -n \"${ITEM} \"\\n\\n  done\\n  echo\\n\\ndone\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 967824,
                "title": "can-someone-explain-this-test-case",
                "content": "Input: a b c\\n\\nExpected: a\\\\nb\\\\nc\\n\\nI don\\'t understand why that is the expected output for this testcase.\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 966848,
                "title": "simple-solution",
                "content": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{ \\n    for (i=1; i<=NF; i++)  {\\n        a[NR,i] = $i\\n    }\\n}\\nNF>p { p = NF }\\nEND {    \\n    for(j=1; j<=p; j++) {\\n        str=a[1,j]\\n        for(i=2; i<=NR; i++){\\n            str=str\" \"a[i,j];\\n        }\\n        print str\\n    }\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935870,
                "title": "huh-computer-says-no",
                "content": "input: a\\noutput: a\\nexpected: a\\n*wrong answer*\\n lolwtf",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 871358,
                "title": "very-simple-hashmap-ish-style-solution",
                "content": "```\\nfile=\"file.txt\"\\n\\nIFS=$\\'\\\\n\\'\\narr=()\\n\\nfor line in $(cat $file); do\\n    i=0\\n    for word in $(echo \"$line\" | tr \\' \\' \\'\\\\n\\'); do \\n        [[ -z ${arr[i]} ]] && arr[i]=\"$word\" || arr[i]=\"${arr[i]} $word\" \\n        (( i++ ))\\n    done \\ndone\\n\\nfor line in ${arr[@]}; do echo $line; done \\n```",
                "solutionTags": [],
                "code": "```\\nfile=\"file.txt\"\\n\\nIFS=$\\'\\\\n\\'\\narr=()\\n\\nfor line in $(cat $file); do\\n    i=0\\n    for word in $(echo \"$line\" | tr \\' \\' \\'\\\\n\\'); do \\n        [[ -z ${arr[i]} ]] && arr[i]=\"$word\" || arr[i]=\"${arr[i]} $word\" \\n        (( i++ ))\\n    done \\ndone\\n\\nfor line in ${arr[@]}; do echo $line; done \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 818362,
                "title": "bug-failing-test-case-a-nb",
                "content": "Test case 5 of 17 has the input \\'a\\\\nb\\' (with a literal \\'\\\\n\\' not an actual new line) and it expects \\'a b\\'.\\nMy code below outputs \\'a\\\\nb\\' because it isn\\'t interpreting the newline and thus treating the input as one column and one row.\\nRunning on my Mac (GNU bash, version 5.0.18-release (x86_64-apple-darwin17.7.0)), none of the accepted solutions here appear to work but some of them will be accepted by the website. Is any one else seeing this?\\n\\n```bash\\nn_cols=$(head -n 1 file.txt | wc -w)\\nfor c in $(seq $n_cols); do\\n    echo \"$(cut -d \\' \\' -f \"${c}\" file.txt)\" | xargs\\ndone\\n```",
                "solutionTags": [],
                "code": "```bash\\nn_cols=$(head -n 1 file.txt | wc -w)\\nfor c in $(seq $n_cols); do\\n    echo \"$(cut -d \\' \\' -f \"${c}\" file.txt)\" | xargs\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705247,
                "title": "why-is-this-getting-wrong-answer",
                "content": "Input is `a`, output is `a`, expected is `a`.\\nWhy does this not work? I don\\'t see any `\\\\n`s in there.\\n\\n```\\nfor i in $(seq 1 \"$(awk \\'{print NF; exit}\\' file.txt)\"); do\\n    awk -v col=$i \\'BEGIN {ORS=\" \"}; {print $col}\\' file.txt\\n\\techo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in $(seq 1 \"$(awk \\'{print NF; exit}\\' file.txt)\"); do\\n    awk -v col=$i \\'BEGIN {ORS=\" \"}; {print $col}\\' file.txt\\n\\techo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673853,
                "title": "why-does-this-get-permission-denied",
                "content": "```\\nncol=$(head -n1 file.txt | wc -w)\\nfor i in $(seq 1 $ncol); do\\n    echo $(cut -d \\' \\' -f $i file.txt)\\ndone\\n```\\nI submitted this same code several times. Some times it got accepted, sometimes the same code got permission denied.\\n\\nGot error:\\n```\\nrbash: ./prog.sh: Permission denied\\n```",
                "solutionTags": [],
                "code": "```\\nncol=$(head -n1 file.txt | wc -w)\\nfor i in $(seq 1 $ncol); do\\n    echo $(cut -d \\' \\' -f $i file.txt)\\ndone\\n```\n```\\nrbash: ./prog.sh: Permission denied\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615067,
                "title": "simple-bash-solution",
                "content": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "solutionTags": [],
                "code": "```\\ncol=\"$(head -1 file.txt | wc -w)\"\\n\\nfor i in $(seq 1 $col);do awk \\'{ print $\\'$i\\' }\\' file.txt | paste -s -d\" \";done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574865,
                "title": "solution-slower-but-better-memory-perf",
                "content": "```\\nfor i in {1..500}\\ndo\\n  cmd=\"cat file.txt | awk \\'{print \\\\$${i}}\\' | tr -s \\\\\"\\\\\\\\\\\\n\\\\\" \\\\\"\\\\ \\\\\"\"\\n  output=$( eval $cmd )\\n  [[ $output == \" \" ]] && exit 0\\n  echo $output\\ndone\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in {1..500}\\ndo\\n  cmd=\"cat file.txt | awk \\'{print \\\\$${i}}\\' | tr -s \\\\\"\\\\\\\\\\\\n\\\\\" \\\\\"\\\\ \\\\\"\"\\n  output=$( eval $cmd )\\n  [[ $output == \" \" ]] && exit 0\\n  echo $output\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568814,
                "title": "a-short-one-liner-awk",
                "content": "awk \\'{a=a\" \"$1; b=b\" \"$2}; END {print a\"\\\\n\"b}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'{a=a\" \"$1; b=b\" \"$2}; END {print a\"\\\\n\"b}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 553829,
                "title": "script-solution",
                "content": "```\\n#!/bin/bash\\n\\ntarget=\\'file.txt\\';\\n\\nfields=$(head -n 1 $target);\\nvalues=$(tail -n +2 $target | tr \"\\\\n\" \" \");\\n\\nlet count=0;\\nfor i in $fields\\ndo\\n    tarr[$count]=$i;\\n    let count++;\\ndone\\n\\nlet s=0;\\nfor value in $values\\ndo\\n    let index=s%count;\\n    let s++;\\n    tarr[$index]=\"${tarr[index]} $value\";\\ndone\\n\\ni=0;\\nwhile [ $i -lt ${#tarr[*]} ]\\ndo\\n    echo ${tarr[$i]};\\n    let i++;\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ntarget=\\'file.txt\\';\\n\\nfields=$(head -n 1 $target);\\nvalues=$(tail -n +2 $target | tr \"\\\\n\" \" \");\\n\\nlet count=0;\\nfor i in $fields\\ndo\\n    tarr[$count]=$i;\\n    let count++;\\ndone\\n\\nlet s=0;\\nfor value in $values\\ndo\\n    let index=s%count;\\n    let s++;\\n    tarr[$index]=\"${tarr[index]} $value\";\\ndone\\n\\ni=0;\\nwhile [ $i -lt ${#tarr[*]} ]\\ndo\\n    echo ${tarr[$i]};\\n    let i++;\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540453,
                "title": "my-solution-using-cut-awk-and-while-loop",
                "content": "```\\nfile=file.txt\\ncols=`cat $file | awk \\'{print NF}\\'`\\nfCol=`echo $cols | awk \\'{print $1}\\'`\\nindex=1\\nwhile [ $index -le $fCol ];\\ndo\\ncut -d\\' \\' -f$index $file | xargs\\nindex=$((index + 1))\\ndone\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfile=file.txt\\ncols=`cat $file | awk \\'{print NF}\\'`\\nfCol=`echo $cols | awk \\'{print $1}\\'`\\nindex=1\\nwhile [ $index -le $fCol ];\\ndo\\ncut -d\\' \\' -f$index $file | xargs\\nindex=$((index + 1))\\ndone\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538800,
                "title": "my-simple-one-liner",
                "content": "```\\nfor i in `seq \\\\`head -n1 file.txt | wc -w\\\\``; do awk -v c=$i \\'{print $c}\\' file.txt | tr \\'\\\\n\\' \\' \\' | awk \\'{$1=$1};1\\';   done\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in `seq \\\\`head -n1 file.txt | wc -w\\\\``; do awk -v c=$i \\'{print $c}\\' file.txt | tr \\'\\\\n\\' \\' \\' | awk \\'{$1=$1};1\\';   done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521116,
                "title": "cut-columns-one-by-one",
                "content": "\\nCOLS=\\\\`head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l\\\\`\\nfor i in \\\\`seq 1 $COLS\\\\`\\ndo\\n    COL=\\\\`cut -d \\' \\' -f $i file.txt | tr \\'\\\\n\\' \\' \\'\\\\`\\n    echo $COL\\ndone",
                "solutionTags": [],
                "code": "\\nCOLS=\\\\`head -1 file.txt | tr \\' \\' \\'\\\\n\\' | wc -l\\\\`\\nfor i in \\\\`seq 1 $COLS\\\\`\\ndo\\n    COL=\\\\`cut -d \\' \\' -f $i file.txt | tr \\'\\\\n\\' \\' \\'\\\\`\\n    echo $COL\\ndone",
                "codeTag": "Unknown"
            },
            {
                "id": 491321,
                "title": "awk-solution-why-permission-denied",
                "content": "can anyone help me clarify why permission denied?\\n\\n```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++){\\n        #printf \"[%d,%d] %s\\\\n\", NR, i, $i\\n        line[NR][i] = $i\\n    }\\n}\\nEND {\\n#printf \"lines %d \\\\n\", lines\\n#printf \"NR %d \\\\n\", NR\\n#printf \"NF %d \\\\n\", NF\\n    for (j = 1; j <= NF; j++){\\n        for (i = 1; i <= NR; i++){\\n            #printf \"[%d,%d] %s \", j, i, line[i][j]\\n            printf \"%s \", line[i][j]\\n        }\\n        printf \"\\\\n\"\\n    }\\n}\\n\\' < file.txt\\n```\\n\\nthanks in advance",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++){\\n        #printf \"[%d,%d] %s\\\\n\", NR, i, $i\\n        line[NR][i] = $i\\n    }\\n}\\nEND {\\n#printf \"lines %d \\\\n\", lines\\n#printf \"NR %d \\\\n\", NR\\n#printf \"NF %d \\\\n\", NF\\n    for (j = 1; j <= NF; j++){\\n        for (i = 1; i <= NR; i++){\\n            #printf \"[%d,%d] %s \", j, i, line[i][j]\\n            printf \"%s \", line[i][j]\\n        }\\n        printf \"\\\\n\"\\n    }\\n}\\n\\' < file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 472807,
                "title": "nothing-fancy-but-very-readable",
                "content": "Looks like a lot of submissions here are focused on trying to make things shorter but the filp side it makes it obscure.\\n\\nSo here is a somewhat opposite approach - keep it readable.\\n\\nThe idea:\\n\\n1. Calculate number of fields\\n2. in a for loop read the file and extract all values from column i into a line \\n\\nA couple notes:\\n\\n1. awk adds a new line at the end, so the \\'tr\\' command will replace new lines with spaces and the \\'sed\\' command will remove the last space in each line.\\n2. the echo command will insert a new line between the lines.\\n\\n\\n\\n\\n```\\nfields=`head -1 file.txt | wc -w`\\nfor i in `seq 1 $fields`\\ndo \\n    cat file.txt | awk \"{print $\"$i\"}\"  |tr \\'\\\\r\\\\n\\' \\' \\' |sed \\'s/ $//g\\'\\n    echo\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\nfields=`head -1 file.txt | wc -w`\\nfor i in `seq 1 $fields`\\ndo \\n    cat file.txt | awk \"{print $\"$i\"}\"  |tr \\'\\\\r\\\\n\\' \\' \\' |sed \\'s/ $//g\\'\\n    echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454464,
                "title": "perl-solution",
                "content": "```perl\\nopen(my $fh, \"<\", \"file.txt\");\\nmy @file;\\nwhile(<$fh>) {\\n\\tmy @sp = split;\\n\\tpush(@file, \\\\@sp);\\n}\\n\\nfor my $i (0 .. @{$file[0]}-1) {\\n\\tfor my $j (0 .. @file-1) {\\n\\t\\tprint($file[$j][$i]);\\n\\t\\tprint(\" \") if $j != @file-1;\\n\\t}\\n\\tprint(\"\\\\n\");\\n}\\n```",
                "solutionTags": [],
                "code": "```perl\\nopen(my $fh, \"<\", \"file.txt\");\\nmy @file;\\nwhile(<$fh>) {\\n\\tmy @sp = split;\\n\\tpush(@file, \\\\@sp);\\n}\\n\\nfor my $i (0 .. @{$file[0]}-1) {\\n\\tfor my $j (0 .. @file-1) {\\n\\t\\tprint($file[$j][$i]);\\n\\t\\tprint(\" \") if $j != @file-1;\\n\\t}\\n\\tprint(\"\\\\n\");\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 400244,
                "title": "no-awk",
                "content": "This bash sciprt works  (tested on Ubuntu on WSL) and works perfectly.  But leet fails it with of the field being passed to ```cut -f```.\\n\\t\\t\\tWhile not as efficient in time or memory as other solutions,  it is easier to understand without having to know ```awk``` syntax.\\n\\n```\\ncols=`head -1 file.txt | wc -w `\\n\\nfor x in $(seq 0 $cols)\\ndo\\n  cat file.txt | while read foo; do echo $foo; done | cut -f$x -d\" \" | xargs echo\\ndone\\n```\\n",
                "solutionTags": [],
                "code": "```cut -f```\n```awk```\n```\\ncols=`head -1 file.txt | wc -w `\\n\\nfor x in $(seq 0 $cols)\\ndo\\n  cat file.txt | while read foo; do echo $foo; done | cut -f$x -d\" \" | xargs echo\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369851,
                "title": "beat-99-single-line",
                "content": "```\\ncat file.txt | awk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | awk \\'{for(i=0;++i<=NF;)a[i]=a[i]?a[i] FS $i:$i}END{for(i=0;i++<NF;)print a[i]}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353080,
                "title": "awk-single-line",
                "content": "awk \\'NR == 1 {for (i = 1; i <= NF; i++) {cols[i] = $i}} NR > 1 {for(i = 1; i <= NF; i++) {cols[i] = cols[i]\" \"$i}} END {for (k in cols) {print cols[k]}}\\' file.txt",
                "solutionTags": [],
                "code": "awk \\'NR == 1 {for (i = 1; i <= NF; i++) {cols[i] = $i}} NR > 1 {for(i = 1; i <= NF; i++) {cols[i] = cols[i]\" \"$i}} END {for (k in cols) {print cols[k]}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 338464,
                "title": "trailing-whitespace",
                "content": "Heads up: if your answer contains trailing whitespace, an otherwise correct solution may not be accepted. Worth noting if you use awk with `ORS=\\' \\'`.",
                "solutionTags": [],
                "code": "Heads up: if your answer contains trailing whitespace, an otherwise correct solution may not be accepted. Worth noting if you use awk with `ORS=\\' \\'`.",
                "codeTag": "Unknown"
            },
            {
                "id": 337764,
                "title": "as-most-others-sulotion-with-awk",
                "content": "```\\nawk \\'{for(i=1;i<=NF;i++){array[NR][i]=$i;}} END{for (col=1; col <=NF; col++) {for (row=1; row <= NR; row++) {if (row==NR){printf(\"%s\", array[row][col]);}else {printf (\"%s \",array[row][col])}}printf \"\\\\n\";}}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++){array[NR][i]=$i;}} END{for (col=1; col <=NF; col++) {for (row=1; row <= NR; row++) {if (row==NR){printf(\"%s\", array[row][col]);}else {printf (\"%s \",array[row][col])}}printf \"\\\\n\";}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335023,
                "title": "faster-than-99-5-with-simple-awks",
                "content": "```\\ncat file.txt | head -n1 | awk \\'{print NF}\\' | xargs seq 1 \\\\\\n  | xargs -I {} sh -c \\\\\\n  \"cat file.txt | awk \\'{print \\\\${}}\\' | tr \\'\\\\n\\' \\' \\'  | sed -E \\'s/\\\\ +$//g\\' && echo\"\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt | head -n1 | awk \\'{print NF}\\' | xargs seq 1 \\\\\\n  | xargs -I {} sh -c \\\\\\n  \"cat file.txt | awk \\'{print \\\\${}}\\' | tr \\'\\\\n\\' \\' \\'  | sed -E \\'s/\\\\ +$//g\\' && echo\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331425,
                "title": "memory-usage-3-5-mb-less-than-99-28",
                "content": "```\\nfor ((i=1; i<=$(head -n 1 file.txt | wc -w);i++)){\\n echo $(cut -d \\' \\' -f $i file.txt)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfor ((i=1; i<=$(head -n 1 file.txt | wc -w);i++)){\\n echo $(cut -d \\' \\' -f $i file.txt)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330250,
                "title": "awk-bash-8ms",
                "content": "```\\nnum_words=$((`cat file.txt | head -n 1 | wc -w`))  # 2\\nfor a in `seq 1 ${num_words}`; do\\n    awk -v col=\"$a\" \\'{\\n        printf \"%s \",$col; \\n    }\\n    END {\\n        print \"\"\\n    }\\' file.txt | sed -e \\'s/ $//\\'; done\\n```\\n\\nPretty simple solution. Had trouble with trailing whitespace so solved it with the sed call at the end.",
                "solutionTags": [],
                "code": "```\\nnum_words=$((`cat file.txt | head -n 1 | wc -w`))  # 2\\nfor a in `seq 1 ${num_words}`; do\\n    awk -v col=\"$a\" \\'{\\n        printf \"%s \",$col; \\n    }\\n    END {\\n        print \"\"\\n    }\\' file.txt | sed -e \\'s/ $//\\'; done\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330024,
                "title": "awk-easy",
                "content": "```\\nawk \\'\\n{\\n\\tfor (i=1;i<=NF;i++) {\\n\\t\\tarr[i] = arr[i]\" \"$i;\\n\\t}\\n}\\nEND {\\n\\tfor (key in arr) {\\n\\t\\tsub(\" \",\"\",arr[key]);\\n\\t\\tprint arr[key]\\n\\t}\\n}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n\\tfor (i=1;i<=NF;i++) {\\n\\t\\tarr[i] = arr[i]\" \"$i;\\n\\t}\\n}\\nEND {\\n\\tfor (key in arr) {\\n\\t\\tsub(\" \",\"\",arr[key]);\\n\\t\\tprint arr[key]\\n\\t}\\n}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 302757,
                "title": "awk-4ms",
                "content": "cat file.txt |awk \\'BEGIN {Col_num=0} {if(NR==1) {for (i=1;i<=NF;++i) {a[i]=$i}; Col_num=NF} else if(NF==Col_num) {for (i=1;i<=NF;++i){a[i]=a[i]\" \"$i}} }   END{ for(i=1;i<=Col_num;++i){ print a[i] }  }\\'",
                "solutionTags": [],
                "code": "cat file.txt |awk \\'BEGIN {Col_num=0} {if(NR==1) {for (i=1;i<=NF;++i) {a[i]=$i}; Col_num=NF} else if(NF==Col_num) {for (i=1;i<=NF;++i){a[i]=a[i]\" \"$i}} }   END{ for(i=1;i<=Col_num;++i){ print a[i] }  }\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 249408,
                "title": "why-can-t-pass",
                "content": "A=`cat file.txt  |awk \\'{print $1}\\' |tr -t \\'\\\\n\\' \\' \\'`;\\necho $A\\nB=`cat file.txt  |awk \\'{print $2}\\' |tr -t  \\'\\\\n\\' \\' \\'`;\\necho $B",
                "solutionTags": [],
                "code": "A=`cat file.txt  |awk \\'{print $1}\\' |tr -t \\'\\\\n\\' \\' \\'`;\\necho $A\\nB=`cat file.txt  |awk \\'{print $2}\\' |tr -t  \\'\\\\n\\' \\' \\'`;\\necho $B",
                "codeTag": "Unknown"
            },
            {
                "id": 240226,
                "title": "one-line-awk",
                "content": "```\\ncat file.txt |awk \\'BEGIN{i=1;}{if(i == 1){for(x=1;x <= NF;x++){a[x-1]=$x}}else{for(x=1;x <= NF;x++){a[x-1]=a[x-1]\" \"$x}};i++}END{for(i=0;i<NF;i++)print a[i]}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat file.txt |awk \\'BEGIN{i=1;}{if(i == 1){for(x=1;x <= NF;x++){a[x-1]=$x}}else{for(x=1;x <= NF;x++){a[x-1]=a[x-1]\" \"$x}};i++}END{for(i=0;i<NF;i++)print a[i]}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235778,
                "title": "use-awk-nf-for-solution",
                "content": "##### first get column number\\ncolnum=`awk \\'END{print NF}\\' file.txt`\\n##### then use for loop print the anwser\\nfor i in $(seq 1 $colnum); \\n    do \\n    awk -v b=$i \\'{print $b}\\' file.txt|xargs; \\n    done",
                "solutionTags": [],
                "code": "##### first get column number\\ncolnum=`awk \\'END{print NF}\\' file.txt`\\n##### then use for loop print the anwser\\nfor i in $(seq 1 $colnum); \\n    do \\n    awk -v b=$i \\'{print $b}\\' file.txt|xargs; \\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 219569,
                "title": "12ms-awk-solution",
                "content": "awk -F\\' \\' \\'BEGIN{nb=0} {nb=NF;i=1;while(i<=NF){m[i]=m[i]\" \"$i;i=i+1}} END{i=1;while(i<=nb){print substr(m[i],2);i++}}\\' file.txt",
                "solutionTags": [],
                "code": "awk -F\\' \\' \\'BEGIN{nb=0} {nb=NF;i=1;while(i<=NF){m[i]=m[i]\" \"$i;i=i+1}} END{i=1;while(i<=nb){print substr(m[i],2);i++}}\\' file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 219457,
                "title": "20ms-awk",
                "content": "```\\nawk \\'{\\n    for(i=1;i<=NF;i++) \\n        a[NR][i]=$i\\n}END{\\n    for (i=1;i<=NF;i++) {\\n        for(j=1;j<=NR;j++)\\n            printf(\"%s \",a[j][i])\\n        print \"\\\\n\"\\n    }\\n}\\' file.txt|sed \\'/^$/d\\'|sed \\'s/ $//g\\'\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{\\n    for(i=1;i<=NF;i++) \\n        a[NR][i]=$i\\n}END{\\n    for (i=1;i<=NF;i++) {\\n        for(j=1;j<=NR;j++)\\n            printf(\"%s \",a[j][i])\\n        print \"\\\\n\"\\n    }\\n}\\' file.txt|sed \\'/^$/d\\'|sed \\'s/ $//g\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211802,
                "title": "using-bash-arrays",
                "content": "Adding a separator conditionally has added some ugliness, bit otherwise it is relatively clean:\\n```\\ndeclare -a result\\nwhile read p; do \\n\\ti=0\\n\\tfor w in $p; do\\n\\t\\tif [ \"x${result[$i]}\" != \"x\" ]; then\\n\\t\\t\\tresult[$i]+=\" \"\\n\\t\\tfi\\n\\t\\tresult[$i]+=$w\\n\\t\\ti=$(($i+1))\\n\\tdone\\t\\ndone < file.txt\\n\\nfor l in \"${result[@]}\"; do\\n\\techo \"$l\"\\ndone\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndeclare -a result\\nwhile read p; do \\n\\ti=0\\n\\tfor w in $p; do\\n\\t\\tif [ \"x${result[$i]}\" != \"x\" ]; then\\n\\t\\t\\tresult[$i]+=\" \"\\n\\t\\tfi\\n\\t\\tresult[$i]+=$w\\n\\t\\ti=$(($i+1))\\n\\tdone\\t\\ndone < file.txt\\n\\nfor l in \"${result[@]}\"; do\\n\\techo \"$l\"\\ndone\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204945,
                "title": "supposed-to-work-but-file-doesn-t-exist",
                "content": "My shortest solution:\\n```cat file.txt | awk \\'{line[1]=line[1]\" \"$1;line[2]=line[2]\" \"$2}END{print line[1]; print line[2]}\\'```",
                "solutionTags": [],
                "code": "```cat file.txt | awk \\'{line[1]=line[1]\" \"$1;line[2]=line[2]\" \"$2}END{print line[1]; print line[2]}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 204461,
                "title": "awk-why-this-do-not-ok-please-help-me",
                "content": "```\\nawk \\'{for(i=1;i<=NF;i++)file[i][NR]=$i}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf(\"%s \",file[i][j])};printf(\"\\\\n\")}}\\' file.txt\\n```\\n\\nwhy this do not ok?",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++)file[i][NR]=$i}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf(\"%s \",file[i][j])};printf(\"\\\\n\")}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 202440,
                "title": "memory-limit-exceeded",
                "content": "This is a simple solution.  I need some help to figure out why this generates a \"memory limit exceeded\" on this problem.  Any tips from anyone?\\n```\\nwords=$(wc -w file.txt | awk {\\'print $1\\'})\\nlines=$(wc -l file.txt | awk {\\'print $1\\'})\\ncolumns=$(( $words / $lines ))\\nif [ $columns -eq 1 ]\\nthen\\n    cut -f 1 -d \" \" file.txt | paste -sd \" \" -\\nelse\\n    for i in `seq 1 $columns`; do cut -f $i -sd \" \" file.txt | paste -sd \" \" -; done\\nfi\\n```",
                "solutionTags": [],
                "code": "```\\nwords=$(wc -w file.txt | awk {\\'print $1\\'})\\nlines=$(wc -l file.txt | awk {\\'print $1\\'})\\ncolumns=$(( $words / $lines ))\\nif [ $columns -eq 1 ]\\nthen\\n    cut -f 1 -d \" \" file.txt | paste -sd \" \" -\\nelse\\n    for i in `seq 1 $columns`; do cut -f $i -sd \" \" file.txt | paste -sd \" \" -; done\\nfi\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196656,
                "title": "a-very-slow-solution",
                "content": "```\\ntext=`cat file.txt`\\nIFS=$\\'\\\\n\\'\\nlines=($text)\\ndeclare -a array\\narray=()\\nfor line in ${lines[@]}\\ndo\\n    IFS=\\' \\'\\n    words=($line)\\n    for w in ${!words[@]}\\n    do\\n        array[$w]=\"${array[$w]} ${words[$w]}\"\\n    done\\ndone\\nfor i in ${!array[@]}\\ndo\\n    echo ${array[$i]}\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\ntext=`cat file.txt`\\nIFS=$\\'\\\\n\\'\\nlines=($text)\\ndeclare -a array\\narray=()\\nfor line in ${lines[@]}\\ndo\\n    IFS=\\' \\'\\n    words=($line)\\n    for w in ${!words[@]}\\n    do\\n        array[$w]=\"${array[$w]} ${words[$w]}\"\\n    done\\ndone\\nfor i in ${!array[@]}\\ndo\\n    echo ${array[$i]}\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183456,
                "title": "bash-transpose-file",
                "content": "Why the site says following bash code is wrong to transpose a file, file.txt:\\na 1\\nb 2\\nc 3\\n\\n```#!/bin/bash\\ncut -d \" \" -f1 file.txt|paste -d \" \" -s\\ncut -d \" \" -f2 file.txt|paste -d \" \" -s\\n```",
                "solutionTags": [],
                "code": "```#!/bin/bash\\ncut -d \" \" -f1 file.txt|paste -d \" \" -s\\ncut -d \" \" -f2 file.txt|paste -d \" \" -s\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173533,
                "title": "solution-that-actually-uses-bash-as-opposed-to-awk-cut-sort-etc",
                "content": "Unlike many others I tried to come up with a solution that actually uses bash (as opposed to awk, cut, sort, etc) However it won\\'t pass and I can\\'t figure out why, here it is:\\n\\n```\\n#!/bin/bash\\n\\ndeclare -a names\\ndeclare -a ages\\n\\nwhile read line\\ndo \\n\\twords=($line)\\n\\tnames+=(${words[0]})\\n\\tages+=(${words[1]})\\ndone < file.txt\\n\\nfor name in ${names[@]}\\ndo \\n\\tprintf \"%s \" $name\\ndone\\n\\nprintf \"\\\\n\"\\n\\nfor age in ${ages[@]}\\ndo \\n\\tprintf \"%s \" $age\\ndone\\n```\\n\\nIt says wrong answer:\\n\\nInput:\\na\\nOutput:\\na \\nExpected:\\na\\n\\nWTF?",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n\\ndeclare -a names\\ndeclare -a ages\\n\\nwhile read line\\ndo \\n\\twords=($line)\\n\\tnames+=(${words[0]})\\n\\tages+=(${words[1]})\\ndone < file.txt\\n\\nfor name in ${names[@]}\\ndo \\n\\tprintf \"%s \" $name\\ndone\\n\\nprintf \"\\\\n\"\\n\\nfor age in ${ages[@]}\\ndo \\n\\tprintf \"%s \" $age\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168510,
                "title": "what-format-does-it-want-for-bash",
                "content": "A simple stupid solution like..\\n\\n```bash\\nN=$(awk \\'{print $1}\\'< file.txt)\\nA=$(awk \\'{print $2}\\'< file.txt)\\necho $N\\necho $A\\n```\\n\\nGets marked as wrong and says it outputs just \\'a\\'. I assume I\\'m not writing the script the way the site wants it somehow..\\n",
                "solutionTags": [],
                "code": "```bash\\nN=$(awk \\'{print $1}\\'< file.txt)\\nA=$(awk \\'{print $2}\\'< file.txt)\\necho $N\\necho $A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163881,
                "title": "my-simple-solution-with-awk",
                "content": "cat  file.txt | awk \\'BEGIN {col=NF;NR=0;} { for (i=1;i<=NF;i++) {a[NR,i]=$i;} }  END { for (i=1;i<=NF;i++) { str=a[1,i]; for (j=2;j<=NR;j++) {str=str\" \"a[j,i];} print str;}}\\'",
                "solutionTags": [],
                "code": "cat  file.txt | awk \\'BEGIN {col=NF;NR=0;} { for (i=1;i<=NF;i++) {a[NR,i]=$i;} }  END { for (i=1;i<=NF;i++) { str=a[1,i]; for (j=2;j<=NR;j++) {str=str\" \"a[j,i];} print str;}}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 151469,
                "title": "please-help-me-runtime-error",
                "content": "```\\nnum=`cat file.txt | awk \\'END{print NF}\\'`\\nfor ((i=1;i<=$num;i++));do\\n\\trow=`cut -d \" \" -f $i file.txt|tr \\'\\\\n\\' \\' \\'|sed \\'s/ $//g\\'`\\n\\techo $row\\ndone\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/marcsea/image_1531985514.png)\\nI got the runtime error when I met the input above.",
                "solutionTags": [],
                "code": "```\\nnum=`cat file.txt | awk \\'END{print NF}\\'`\\nfor ((i=1;i<=$num;i++));do\\n\\trow=`cut -d \" \" -f $i file.txt|tr \\'\\\\n\\' \\' \\'|sed \\'s/ $//g\\'`\\n\\techo $row\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140791,
                "title": "this-is-general-awk-piece-to-convert-from-line-to-col-or-reverse",
                "content": "{\\n    for (i=1;i<=NF;i++) {\\n        arr[i, NR]=$i;\\n        if (nf<=NF) {\\n            nf=NF\\n            }\\n    }\\n}\\nEND {\\n    for (j=1;j<=nf;j++){\\n        for (i=1;i<=NR;i++){\\n            printf(\"%s \", arr[j,i]);\\n            }\\n        printf(\"\\\\n\");\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "{\\n    for (i=1;i<=NF;i++) {\\n        arr[i, NR]=$i;\\n        if (nf<=NF) {\\n            nf=NF\\n            }\\n    }\\n}\\nEND {\\n    for (j=1;j<=nf;j++){\\n        for (i=1;i<=NR;i++){\\n            printf(\"%s \", arr[j,i]);\\n            }\\n        printf(\"\\\\n\");\\n        }\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 130990,
                "title": "two-solution",
                "content": "first: 16ms\\n```\\nawk \\'{for(i=1;i<=NF;i++){if(NR==1){arr[i]=$i}else{arr[i]=arr[i]\" \"$i}}}END{for(i=1;i<=NF;i++){printf arr[i];if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```\\nsecond: 40ms\\n```\\n awk \\'{for(i=1;i<=NF;i++){arr[i,NR]=$i;}}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf arr[i,j];if(j!=NR){printf \" \"}}if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++){if(NR==1){arr[i]=$i}else{arr[i]=arr[i]\" \"$i}}}END{for(i=1;i<=NF;i++){printf arr[i];if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```\n```\\n awk \\'{for(i=1;i<=NF;i++){arr[i,NR]=$i;}}END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++){printf arr[i,j];if(j!=NR){printf \" \"}}if(i!=NF){printf \"\\\\n\"}}}\\' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130022,
                "title": "simple-oneliner-solution",
                "content": "\\n```for i in `seq 1 $(head -1 file.txt | wc -w)`; do awk -v I=$i \\'{print $I}\\' file.txt | tr \\'\\\\n\\' \\' \\'; echo; done;```",
                "solutionTags": [],
                "code": "```for i in `seq 1 $(head -1 file.txt | wc -w)`; do awk -v I=$i \\'{print $I}\\' file.txt | tr \\'\\\\n\\' \\' \\'; echo; done;```",
                "codeTag": "Unknown"
            },
            {
                "id": 114344,
                "title": "awk-with-2-d-array",
                "content": "```\\nawk '{for(i=1; i<=NF; i++) a[i,NR]=$i} END {for(i=1; a[i,1]!=\"\"; i++) {for(j=1; j<NR; j++) printf a[i,j] \" \"; print a[i,NR]}}' file.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk '{for(i=1; i<=NF; i++) a[i,NR]=$i} END {for(i=1; a[i,1]!=\"\"; i++) {for(j=1; j<NR; j++) printf a[i,j] \" \"; print a[i,NR]}}' file.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55505,
                "title": "memory-limit",
                "content": "I've got memory limit with this code but 17/17 passed\\n...\\ncounter=1\\nwhile (( $(head -n1 file.txt | wc -w) >= $counter ))\\ndo \\n    cut -d\" \" -f$counter file.txt | paste -s -d\" \"\\n    counter=$(($counter+1))\\ndone\\n...",
                "solutionTags": [],
                "code": "I've got memory limit with this code but 17/17 passed\\n...\\ncounter=1\\nwhile (( $(head -n1 file.txt | wc -w) >= $counter ))\\ndo \\n    cut -d\" \" -f$counter file.txt | paste -s -d\" \"\\n    counter=$(($counter+1))\\ndone\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 55506,
                "title": "my-solution-with-awk-and-sed-faster-than-only-awk",
                "content": "awk '{for(i=1; i<=NF;i++){line[i] = line[i]\" \"$i}} END{for(i=1;i<=NF;i++){print line[i]}}' file.txt |sed 's/^\\\\ //g'",
                "solutionTags": [],
                "code": "awk '{for(i=1; i<=NF;i++){line[i] = line[i]\" \"$i}} END{for(i=1;i<=NF;i++){print line[i]}}' file.txt |sed 's/^\\\\ //g'",
                "codeTag": "Unknown"
            },
            {
                "id": 55507,
                "title": "what-is-wrong-with-this-bash-solution",
                "content": "What is wrong with this solution?\\n\\n```\\ncount=`head -1 file.txt | egrep -c \" \"`\\ncount=$(expr $count + 1)\\nfor i in $(seq 1 $count); do\\n   cat file.txt  | cut -f$i -d \" \" | tr \"\\\\n\" \" \" | sed -e 's/ $//g'\\ndone\\n```",
                "solutionTags": [],
                "code": "```\\ncount=`head -1 file.txt | egrep -c \" \"`\\ncount=$(expr $count + 1)\\nfor i in $(seq 1 $count); do\\n   cat file.txt  | cut -f$i -d \" \" | tr \"\\\\n\" \" \" | sed -e 's/ $//g'\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55508,
                "title": "what-is-wrong-with-my-solution",
                "content": "The test seems to be too picky about newlines!\\n\\n```\\ngname=()\\ngage=()\\nwhile read name age; do\\n    gname+=( $name )\\n    gage+=( $age )\\ndone < file.txt\\n\\necho \"${gname[@]}\"\\n#echo \"${gage[@]}\"\\n[[ -n $gage ]] && echo \"${gage[@]}\" #fix first test\\n```",
                "solutionTags": [],
                "code": "```\\ngname=()\\ngage=()\\nwhile read name age; do\\n    gname+=( $name )\\n    gage+=( $age )\\ndone < file.txt\\n\\necho \"${gname[@]}\"\\n#echo \"${gage[@]}\"\\n[[ -n $gage ]] && echo \"${gage[@]}\" #fix first test\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55509,
                "title": "why-i-use-awk-in-my-system-is-right-but-in-leetcode-is-wrong",
                "content": "awk 'BEGIN {ORS=\" \";count=0} {name[count]=$1; age[count]=$2; count++} END {for(i=0;i<NR;i++) print name[i];print \"\\\\n\";for(i=0;i<NR;i++) print age[i]}'",
                "solutionTags": [],
                "code": "awk 'BEGIN {ORS=\" \";count=0} {name[count]=$1; age[count]=$2; count++} END {for(i=0;i<NR;i++) print name[i];print \"\\\\n\";for(i=0;i<NR;i++) print age[i]}'",
                "codeTag": "Unknown"
            },
            {
                "id": 55519,
                "title": "it-gives-me-the-expected-answer-but-does-not-pass-the-test-anything-wrong",
                "content": "NLINES=$(wc -l < \"file.txt\")\\nawk '{printf \"%s \", $1}' file.txt\\nif [ $NLINES -ge 2 ]; then\\n    echo\\nfi\\nawk '{printf \"%s \", $2}' file.txt\\necho",
                "solutionTags": [],
                "code": "NLINES=$(wc -l < \"file.txt\")\\nawk '{printf \"%s \", $1}' file.txt\\nif [ $NLINES -ge 2 ]; then\\n    echo\\nfi\\nawk '{printf \"%s \", $2}' file.txt\\necho",
                "codeTag": "Unknown"
            },
            {
                "id": 55518,
                "title": "my-solution-not-being-accepted",
                "content": "    #!bin/bash\\n    \\n    i=0\\n    while read p; do\\n    \\tj=0\\n    \\tfor word in $p\\n    \\t\\tdo\\n    \\t\\t\\t#echo \"i value:\" $i \"j value:\" $j \"word value:\" $word\\n    \\t\\t\\tif [ $j -eq 0 ];\\n    \\t\\t\\tthen\\n    \\t\\t\\t\\t#echo \"inside name\"\\n    \\t\\t\\t\\tname[$i]=$word\\n    \\t\\t\\t\\t((j++))\\n    \\t\\t\\t\\t#echo \" name value\" ${name[$i]}\\n    \\t\\t\\telse\\n    \\t\\t\\t\\t#echo \"inside age\"\\n    \\t\\t\\t\\tage[$i]=$word\\n    \\t\\t\\t\\t#echo \" age value\" ${age[$i]}\\n    \\t\\t\\tfi\\n    \\t\\tdone\\n    \\t((i++))\\n    done < file.txt\\n    \\n    printf \"%s \" ${name[@]}\\n    echo\\n    printf \"%s \" ${age[@]}",
                "solutionTags": [],
                "code": "    #!bin/bash\\n    \\n    i=0\\n    while read p; do\\n    \\tj=0\\n    \\tfor word in $p\\n    \\t\\tdo\\n    \\t\\t\\t#echo \"i value:\" $i \"j value:\" $j \"word value:\" $word\\n    \\t\\t\\tif [ $j -eq 0 ];\\n    \\t\\t\\tthen\\n    \\t\\t\\t\\t#echo \"inside name\"\\n    \\t\\t\\t\\tname[$i]=$word\\n    \\t\\t\\t\\t((j++))\\n    \\t\\t\\t\\t#echo \" name value\" ${name[$i]}\\n    \\t\\t\\telse\\n    \\t\\t\\t\\t#echo \"inside age\"\\n    \\t\\t\\t\\tage[$i]=$word\\n    \\t\\t\\t\\t#echo \" age value\" ${age[$i]}\\n    \\t\\t\\tfi\\n    \\t\\tdone\\n    \\t((i++))\\n    done < file.txt\\n    \\n    printf \"%s \" ${name[@]}\\n    echo\\n    printf \"%s \" ${age[@]}",
                "codeTag": "Unknown"
            },
            {
                "id": 55521,
                "title": "why-can-t-i-pass-this-problem-by-using-awk",
                "content": "Code is as follows, please give me a suggestion\\uff1a\\nawk -F ' ' '{for (i=1; i <= NF; i++){s[i] = (s[i]\"\"$i\"\"\" \")}} END{for (a in s)print s[a]}'  file.txt",
                "solutionTags": [],
                "code": "Code is as follows, please give me a suggestion\\uff1a\\nawk -F ' ' '{for (i=1; i <= NF; i++){s[i] = (s[i]\"\"$i\"\"\" \")}} END{for (a in s)print s[a]}'  file.txt",
                "codeTag": "Unknown"
            },
            {
                "id": 55503,
                "title": "my-solution-written-only-in-bash",
                "content": "    array=()\\n    \\n    while read -a columns; do\\n        for (( i = 0; i < ${#columns[@]}; i++ )); do\\n            array[i]=\"${array[i]} ${columns[i]}\"\\n        done\\n    done < file.txt\\n    \\n    for (( i = 0; i < ${#array[@]}; i++ )); do\\n        echo ${array[i]}\\n    done\\n\\nTaught by @yongjhih",
                "solutionTags": [],
                "code": "    array=()\\n    \\n    while read -a columns; do\\n        for (( i = 0; i < ${#columns[@]}; i++ )); do\\n            array[i]=\"${array[i]} ${columns[i]}\"\\n        done\\n    done < file.txt\\n    \\n    for (( i = 0; i < ${#array[@]}; i++ )); do\\n        echo ${array[i]}\\n    done\\n\\nTaught by @yongjhih",
                "codeTag": "Unknown"
            },
            {
                "id": 55525,
                "title": "my-ac-code-just-use-bash-array",
                "content": "    empty=\" \"\\n    i=0\\n    while read line\\n    do \\n    \\tif [ $i -eq 0 ]; then\\n    \\t\\tarray=($line)\\n    \\telse\\n    \\t\\ttmp=($line)\\n    \\t\\tlen=${#tmp[@]}\\n    \\t\\tk=0\\n    \\t\\twhile [ $k -lt $len ]\\n    \\t\\tdo \\n    \\t\\t\\tarray[$k]=${array[$k]}$empty${tmp[$k]}\\n    \\t\\t\\tlet k++\\n    \\t\\tdone\\n    \\tfi\\n    \\tlet i++\\n    done < file.txt\\n    \\n    #print result\\n    for ((i=0;i<${#array[@]};i++));\\n    do\\n    \\techo ${array[$i]}\\n    done",
                "solutionTags": [],
                "code": "    empty=\" \"\\n    i=0\\n    while read line\\n    do \\n    \\tif [ $i -eq 0 ]; then\\n    \\t\\tarray=($line)\\n    \\telse\\n    \\t\\ttmp=($line)\\n    \\t\\tlen=${#tmp[@]}\\n    \\t\\tk=0\\n    \\t\\twhile [ $k -lt $len ]\\n    \\t\\tdo \\n    \\t\\t\\tarray[$k]=${array[$k]}$empty${tmp[$k]}\\n    \\t\\t\\tlet k++\\n    \\t\\tdone\\n    \\tfi\\n    \\tlet i++\\n    done < file.txt\\n    \\n    #print result\\n    for ((i=0;i<${#array[@]};i++));\\n    do\\n    \\techo ${array[$i]}\\n    done",
                "codeTag": "Unknown"
            },
            {
                "id": 55513,
                "title": "wrong-answer-with-input-a-for-transpose-file-in-bash-oj-s-mistake",
                "content": "I have submitted the following code as an answer to \"transpose file with bash\", and LeetCode OJ decides it spits wrong answer for input 'a' while both the output and the expected values are 'a'. I am confused...\\n\\n    #!/bin/bash\\n    fname='file.txt'\\n    #fname=$1\\n    nlines=$(wc -l < \"$fname\")\\n    ncol=$(awk '{print NF; exit}' $fname)\\n    #echo nlines $nlines ncol $ncol\\n    row_id=0\\n    {![enter image description here][1]\\n      while read -a line; do\\n        row_id=$((row_id+1))\\n        #echo read row $row_id\\n        for j in \"${!line[@]}\"; do\\n          i=$((j+1))\\n          #echo row $row_id column $i\\n          #echo $(( (row_id-1) * (ncol) + i))\\n          r[$(( (row_id-1) * ncol + i))]=${line[$j]}\\n          #echo '####' element ${r[$(( (row_id-1) * (ncol) + i))]} '####'\\n        done\\n      done\\n    } < $fname\\n    \\n    for(( j=1; j<=$ncol; j++)) do\\n      for(( k=1; k<=$((nlines)); k++)) do\\n      if [ -n \"${r[$(( (k-1) * ncol + j))]}\" ]; then\\n          echo -n \"${r[$(( (k-1) * ncol + j))]}\"' '\\n        fi\\n      done\\n      echo\\n    done\\n\\n\\n![Screenshot of the OJ's output][1]\\n\\n\\n  [1]: https://dl.dropboxusercontent.com/u/83334653/LeetCodeOJ_transposeFile.png",
                "solutionTags": [],
                "code": "I have submitted the following code as an answer to \"transpose file with bash\", and LeetCode OJ decides it spits wrong answer for input 'a' while both the output and the expected values are 'a'. I am confused...\\n\\n    #!/bin/bash\\n    fname='file.txt'\\n    #fname=$1\\n    nlines=$(wc -l < \"$fname\")\\n    ncol=$(awk '{print NF; exit}' $fname)\\n    #echo nlines $nlines ncol $ncol\\n    row_id=0\\n    {![enter image description here][1]\\n      while read -a line; do\\n        row_id=$((row_id+1))\\n        #echo read row $row_id\\n        for j in \"${!line[@]}\"; do\\n          i=$((j+1))\\n          #echo row $row_id column $i\\n          #echo $(( (row_id-1) * (ncol) + i))\\n          r[$(( (row_id-1) * ncol + i))]=${line[$j]}\\n          #echo '####' element ${r[$(( (row_id-1) * (ncol) + i))]} '####'\\n        done\\n      done\\n    } < $fname\\n    \\n    for(( j=1; j<=$ncol; j++)) do\\n      for(( k=1; k<=$((nlines)); k++)) do\\n      if [ -n \"${r[$(( (k-1) * ncol + j))]}\" ]; then\\n          echo -n \"${r[$(( (k-1) * ncol + j))]}\"' '\\n        fi\\n      done\\n      echo\\n    done\\n\\n\\n![Screenshot of the OJ's output][1]\\n\\n\\n  [1]: https://dl.dropboxusercontent.com/u/83334653/LeetCodeOJ_transposeFile.png",
                "codeTag": "Unknown"
            },
            {
                "id": 55527,
                "title": "ac-solution-with-question",
                "content": "This is the AC solution using a big array to store all elements from stack exchange\\n\\n    awk '\\n    { \\n        for (i=1; i<=NF; i++)  {\\n            a[NR,i] = $i\\n        }\\n    }\\n    NF>p { p = NF }\\n    END {    \\n        for(j=1; j<=p; j++) {\\n            str=a[1,j]\\n            for(i=2; i<=NR; i++){\\n                str=str\" \"a[i,j];\\n            }\\n            print str\\n        }\\n    }' file.txt\\n\\n\\nThen I tried to improve it somehow by using \"attaching\" idea and got the following code which \"should\" be better I think:\\n\\n\\n     col=`head -1 \"file.txt\"|awk '{print NF'}`\\n     echo $col\\n        \\n        \\n     for((i=1;i<=$col;i++))\\n     do\\n         awk '{printf \"%s %s\",$'\"$i\"',\" \"}END{print \"\"}' file.txt\\n     done\\n\\n\\n\\nthen I got Memory exceed result. Would someone please enlighten me on this?",
                "solutionTags": [],
                "code": "This is the AC solution using a big array to store all elements from stack exchange\\n\\n    awk '\\n    { \\n        for (i=1; i<=NF; i++)  {\\n            a[NR,i] = $i\\n        }\\n    }\\n    NF>p { p = NF }\\n    END {    \\n        for(j=1; j<=p; j++) {\\n            str=a[1,j]\\n            for(i=2; i<=NR; i++){\\n                str=str\" \"a[i,j];\\n            }\\n            print str\\n        }\\n    }' file.txt\\n\\n\\nThen I tried to improve it somehow by using \"attaching\" idea and got the following code which \"should\" be better I think:\\n\\n\\n     col=`head -1 \"file.txt\"|awk '{print NF'}`\\n     echo $col\\n        \\n        \\n     for((i=1;i<=$col;i++))\\n     do\\n         awk '{printf \"%s %s\",$'\"$i\"',\" \"}END{print \"\"}' file.txt\\n     done\\n\\n\\n\\nthen I got Memory exceed result. Would someone please enlighten me on this?",
                "codeTag": "Unknown"
            },
            {
                "id": 3985001,
                "title": "efficient-matrix-transposition-with-awk",
                "content": "# Intuition\\nWhen presented with the problem of transposing a matrix in the form of a file, one might first think of using nested loops: an outer loop for columns and an inner loop for rows. But with AWK, a powerful pattern scanning and processing language, we can perform the transposition in a more elegant manner.\\n\\n# Approach\\nThe script uses the power of associative arrays in AWK:\\n    We loop through each field in the input rows using for (i=1; i<=NF; i++). Here, NF represents the number of fields in the current record, essentially giving us the column count.\\n    Within this loop, we\\'re building our associative array a. The key to this array is the column number i, and we\\'re appending the current field value $i to this key. If a[i] already has a value, we append the new value with a space, otherwise, we simply set the new value.\\n    Once all rows have been processed, we enter the END block where we print out each value of our associative array a using for (i in a). This gives us the transposed matrix.\\n\\n# Complexity\\n- Time complexity:\\n O(n\\xD7m)O(n\\xD7m) where nn is the number of rows and mm is the number of columns. We are effectively visiting each cell of the matrix once.\\n\\n- Space complexity:\\nO(n\\xD7m)O(n\\xD7m) as we need to store the entire transposed matrix in memory.\\n\\n# Code\\n```\\nawk \\'{for (i=1; i<=NF; i++) a[i]=a[i] ? a[i] \" \" $i : $i} END {for (i in a) print a[i]}\\' file.txt\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\nawk \\'{for (i=1; i<=NF; i++) a[i]=a[i] ? a[i] \" \" $i : $i} END {for (i in a) print a[i]}\\' file.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392995,
                "title": "map-reduce-type-solution-with-awk",
                "content": "A simple awk-heavy solution which first outputs every field with its field number, e.g.\\n\\n```\\n1   name\\n2   age\\n1   alice\\n2   21\\n1   ryan\\n2   30\\n```\\n\\nthen does a stable sort (`sort -s`) on the field numbers, then combines them with awk again:\\n\\n```\\nawk \\'{for (i=1;i<=NF;i++) print i, \" \", $i}\\' file.txt \\\\\\n   | sort -snk 1 \\\\\\n   | awk \\'BEGIN {i=1; start=1} {\\n\\t   if ($1 != i) {i = $1; printf \"\\\\n\"; start=1}; \\n\\t   if (start != 1) printf \" \"; \\n\\t   printf \"%s\", $2; start=0}\\'\\n```",
                "solutionTags": [],
                "code": "```\\n1   name\\n2   age\\n1   alice\\n2   21\\n1   ryan\\n2   30\\n```\n```\\nawk \\'{for (i=1;i<=NF;i++) print i, \" \", $i}\\' file.txt \\\\\\n   | sort -snk 1 \\\\\\n   | awk \\'BEGIN {i=1; start=1} {\\n\\t   if ($1 != i) {i = $1; printf \"\\\\n\"; start=1}; \\n\\t   if (start != 1) printf \" \"; \\n\\t   printf \"%s\", $2; start=0}\\'\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569014,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1573207,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1572415,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1571882,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            },
            {
                "id": 1973625,
                "content": [
                    {
                        "username": "illuz",
                        "content": "Is O(n) or O(nlogn) space can solve this problem?  \\n\\nI have a idea:  \\n**Record the \"current position\" of every line and loop.**  \\n\\nBut I don't know how to implement it.  \\n\\nIs there an implement or other ideas?"
                    },
                    {
                        "username": "gemtra",
                        "content": "num=`awk \\'END{print NF}\\' file.txt`\\nfor i in `seq 1 $num`;do cut -d \\' \\' -f $i file.txt|xargs; done"
                    },
                    {
                        "username": "firejox",
                        "content": "seq 1 $(head -1 file.txt | wc -w) | xargs -I \\'{}\\' bash -c \"cut -d \\'\"\\' \\'\"\\' -f {} file.txt| xargs\""
                    },
                    {
                        "username": "caspergao",
                        "content": "# awk \\'{print $1;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\';awk \\'{print $2;}\\' file.txt |tr -s \\'\\\\n\\' \\' \\';echo \\'\\'\\nname alice ryan \\nage 21 30 "
                    },
                    {
                        "username": "patrickfung",
                        "content": "echo $(cat file.txt|cut -d \\' \\' -f 1) && echo $(cat file.txt|cut -d \\' \\' -f 2)\\n\\nname alice ryan\\nage 21 30\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flip Game II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565434,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1568060,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1567949,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1569260,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1569057,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            },
            {
                "id": 1707575,
                "content": [
                    {
                        "username": "SylvanasWindrunner",
                        "content": "I'm not sure why the simple recursive algorithm would work. It replaces every pair of \"++\" in the original string with \"--\" and ask the questions: can my opponent win? \\n\\nHowever, the canWin() function returns true if the current player is \"guarantee a win\", and it returns false if the current player cannot guarantee a win - meaning the current player might win or lose depending on the action of the opponent. If this is the case, why algorithm like [this][1] works?\\n\\n\\n\\n \\n\\n\\n  [1]: https://leetcode.com/discuss/64291/share-my-java-backtracking-solution"
                    },
                    {
                        "username": "n_leetcode",
                        "content": "\"+++++++++\"\\n\\nPlayer a plays: \"+--++++++\"\\nPlayer b plays: \"+--+--+++\"\\nPlayer a plays: \"+--+--+--\"\\nPlayer b\\'s turn, he has no move to play. So (starting) player A wins.\\n\\nwhy does this testcase return false?\\n"
                    },
                    {
                        "username": "sachinppuranik",
                        "content": "Player a plays: \"+--++++++\"\\nPlayer b plays: \"+--++--++\"\\nPlayer a plays: \"+------++\"\\nPlayer b plays: \"+--------\"\\nNow player a has no move."
                    },
                    {
                        "username": "dilit",
                        "content": "You have to account for turn switching.  \nIf A plays +++--++++, B can play in ++++ half to lose in that half, but grab the turn to play first on the +++ side where it wins."
                    },
                    {
                        "username": "Zhuzeng",
                        "content": "Can anyone please confirm why the expected result for the following test case is TRUE?\\n\"++++-++++++\"\\n\\nMy code failed because my alg is giving 'false', but I am a little confused why the OJ gives 'TRUE'. No matter what the first player does, the second player can find a way to eventually win the game. Am I missing some critical info here?"
                    },
                    {
                        "username": "dilit",
                        "content": "On both sides 1st player can make the 2nd player win or lose depending on the 1st player\\'s strategy.  Losing on one side gives an opportunity to win on the other one..."
                    },
                    {
                        "username": "xuankushuocai2",
                        "content": "I\\'m also confused about it. I think this case is false. \"Garanteed to win\" means as long as the first person did the first move, no matter what moves were done after it, the first person will win, right? I don\\'t think it\\'s true for this case. Could anyone tell me the reason to be true? Thank you."
                    },
                    {
                        "username": "yoursyj",
                        "content": "Update:\\n\\nThanks  bravejia for pointing out one case which was missing in my original post.\\n\\nthe winning strategy is that after flip, two strings are still both can-win-or-lose strings. Basically, starting player can choose not to make decision in his first turn.\\n\\nTake \"++++-++++++\" as an example again:\\n\\nA: ++++---++++\\n\\nThis will leave B with two both can-win-or-lose strings. And there will be no further subset can-win-or-lose strings. \\n\\n-----------------------------------------------------------------------\\nOrignal Post:\\n\\nI think  \"++++-++++++\" is a lose. And here is why.\\n\\nBoth ++++ and ++++++ are can-win-or-lose strings. A can-win-or-lose string is a case where first player can choose if he wants to win or lose. \\nFor example, in case of ++++, first player can choose flip middle two to win, or to flip first two to lose.\\n\\nSo in case of two can-win-or-lose strings, or even number of can-win-or-lose strings, second player can always adjust his strategy based on first player's move. \\n\\nTake \"++++-++++++\" as an example, \\n\\nIf A choose to win \"++++\", B can win by winning\"++++++\".\\n\\nA: +--+-++++++\\n\\nB: +--+-++--++\\n\\nIf A choose to lose \"++++\", B can win by losing\"++++++\".\\n\\nA: --++-++++++\\n\\nB: --++-+--+++\\n\\nB can have same strategy If A choose to flip second  can-win-or-lose strings first.\\n\\nSo  \"++++-++++++\" is a lose. Feel free to correct me if I am wrong."
                    },
                    {
                        "username": "harperjiang",
                        "content": "I was using Java and replaced StringBuilder with char array and reduce the running time from 137ms to 11ms. But I don\\'t think StringBuilder is that slow"
                    }
                ]
            }
        ]
    }
]