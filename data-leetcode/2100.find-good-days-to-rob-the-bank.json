[
    {
        "title": "Find Good Days to Rob the Bank",
        "question_content": "You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.\nThe ith day is a good day to rob the bank if:\n\n\tThere are at least time days before and after the ith day,\n\tThe number of guards at the bank for the time days before i are non-increasing, and\n\tThe number of guards at the bank for the time days after i are non-decreasing.\n\nMore formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].\nReturn a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.\n&nbsp;\nExample 1:\n\nInput: security = [5,3,3,3,5,6,2], time = 2\nOutput: [2,3]\nExplanation:\nOn day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].\nOn day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.\n\nExample 2:\n\nInput: security = [1,1,1,1,1], time = 0\nOutput: [0,1,2,3,4]\nExplanation:\nSince time equals 0, every day is a good day to rob the bank, so return every day.\n\nExample 3:\n\nInput: security = [1,2,3,4,5,6], time = 2\nOutput: []\nExplanation:\nNo day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list.\n\n&nbsp;\nConstraints:\n\n\t1 <= security.length <= 105\n\t0 <= security[i], time <= 105",
        "solutions": [
            {
                "id": 1623329,
                "title": "c-prefix-suffix-array-with-explanation",
                "content": "**Explanation:-**\\n1. For every index we will find number of ```previous elements``` that follows this pattern ```security[i - time] >= security[i - time + 1]```  and it\\'s easy to find you can see in the code and we store this info in ```prefix array```.\\n2.  For every index we will find number of ``` elements that are ahead of current element``` which follows this pattern ```security[i + time - 1] <= security[i + time]```  and it\\'s easy to find you can see in the code and we store this info in ```suffix array```.\\n3.  To find ```good days``` just traverse the array and check this condition ```pre[i]-1>=time && suf[i]-1>=time```.\\n4.  **Note:-** I am subtracting 1 in above line because i have included current element in ```cnt```.\\n5.  If you want, you can avoid to use ```prefix array``` and can calculate when you are calculating answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n        int size=s.size(),cnt=1;\\n        vector<int>pre(size,0),suf(size,0);\\n        pre[0]=1;\\n        for(int i=1;i<size;i++){\\n            if(s[i]<=s[i-1])\\n                cnt++;\\n            else\\n                cnt=1;\\n             pre[i]=cnt;\\n        }\\n        suf[size-1]=1;cnt=1;\\n        for(int i=size-2;i>=0;i--){\\n            if(s[i]<=s[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            suf[i]=cnt; \\n        }\\n        vector<int>ans;\\n        for(int i=0;i<size;i++)\\n            if(pre[i]-1>=time && suf[i]-1>=time)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**As people are asking about intuition behind this,so i am adding the same here.**\\n1. Let\\'s say i am looking at index =2 and time =2 so to be a good day it should follow this pattern ```security[0] >= security[1] >= security[2] <= security[3] <= security[4]```.\\n2. So i thought for i=3  to be a good day it should follow ```security[1] >= security[2] >= security[3] <= security[4] <= security[5]```\\n3. So you can see above we are recalculating ```security[1] >= security[2] >= security[3] <= security[4] ``` this. so i got the intuition that if for every ```index``` ,if i store the ```cnt``` of previous elements and ```cnt``` of ahead elements  that follow this pattern then i can know in ```O(1)``` whether this day is good or not.\\nThis is what i thought during contest.\\nI hope it will help.\\n\\n\\nDo **UPVOTE** if it helps:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```previous elements```\n```security[i - time] >= security[i - time + 1]```\n```prefix array```\n``` elements that are ahead of current element```\n```security[i + time - 1] <= security[i + time]```\n```suffix array```\n```good days```\n```pre[i]-1>=time && suf[i]-1>=time```\n```cnt```\n```prefix array```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n        int size=s.size(),cnt=1;\\n        vector<int>pre(size,0),suf(size,0);\\n        pre[0]=1;\\n        for(int i=1;i<size;i++){\\n            if(s[i]<=s[i-1])\\n                cnt++;\\n            else\\n                cnt=1;\\n             pre[i]=cnt;\\n        }\\n        suf[size-1]=1;cnt=1;\\n        for(int i=size-2;i>=0;i--){\\n            if(s[i]<=s[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            suf[i]=cnt; \\n        }\\n        vector<int>ans;\\n        for(int i=0;i<size;i++)\\n            if(pre[i]-1>=time && suf[i]-1>=time)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```security[0] >= security[1] >= security[2] <= security[3] <= security[4]```\n```security[1] >= security[2] >= security[3] <= security[4] <= security[5]```\n```security[1] >= security[2] >= security[3] <= security[4] ```\n```index```\n```cnt```\n```cnt```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1623415,
                "title": "python-explanation-with-pictures-prefix-sum",
                "content": "For each day, we get the largest number of non-increasing days on its left (inclusive), and the largest number of non-decreasing days on its right (inclusive).\\n![image](https://assets.leetcode.com/users/images/5bf21c72-3bea-4eaa-a348-3bd04d78b0ce_1639238926.3916717.png)\\n\\nBuild `lft` for days on the left.\\n![image](https://assets.leetcode.com/users/images/324fde2a-b12f-41f6-a9db-1c71e6cb9315_1639238926.3997068.png)\\n![image](https://assets.leetcode.com/users/images/b808a1f1-b0c2-42bf-a973-875e688543f1_1639238926.418414.png)\\n\\nday[3] <= day[2], so lft[3] (1-indexed) is day[2] + 1.\\n![image](https://assets.leetcode.com/users/images/de61ecb6-e317-4eee-821f-0aa3746a8e6e_1639238926.3962533.png)\\n\\nSince day[4] > day[2], lft[4] = 1.\\n![image](https://assets.leetcode.com/users/images/a94ee074-9152-47bd-b1d5-bdbe0cf57f07_1639238926.4542453.png)\\n\\nSimilarily, we build the right prefix (or left suffix) array.\\n![image](https://assets.leetcode.com/users/images/a13678ed-2ec1-427f-8cec-8df03eb81168_1639440010.506081.png)\\n\\n\\nFinally, we iterate over all days, if a day has more than `time + 1` non-inc days on its left and `time + 1` non-dec days on its right, its a good day and we add it to the answer. \\n![image](https://assets.leetcode.com/users/images/50df72cc-aa58-40e7-8399-e26ccc54a162_1639440035.532295.png)\\n\\n\\n```\\ndef goodDaysToRobBank(self, A: List[int], t: int) -> List[int]:\\n        if t == 0: return list(range(len(A)))\\n        lft, rgt, n = [1], [1], len(A)\\n        \\n        # Build non-increasing on the left side (inclusive).\\n        curr = 1\\n        for i in range(1, n):\\n            if A[i] <= A[i - 1]: curr += 1\\n            else: curr = 1\\n            lft.append(curr)\\n        \\n        # Build non-decreasing on the right side (inclusive).\\n        curr = 1\\n        for i in range(n - 2, -1, -1):\\n            if A[i] <= A[i + 1]: curr += 1\\n            else: curr = 1\\n            rgt.append(curr)\\n        rgt.reverse()\\n        \\n        return [i for i in range(n) if lft[i] >= t + 1 and rgt[i] >= t + 1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef goodDaysToRobBank(self, A: List[int], t: int) -> List[int]:\\n        if t == 0: return list(range(len(A)))\\n        lft, rgt, n = [1], [1], len(A)\\n        \\n        # Build non-increasing on the left side (inclusive).\\n        curr = 1\\n        for i in range(1, n):\\n            if A[i] <= A[i - 1]: curr += 1\\n            else: curr = 1\\n            lft.append(curr)\\n        \\n        # Build non-decreasing on the right side (inclusive).\\n        curr = 1\\n        for i in range(n - 2, -1, -1):\\n            if A[i] <= A[i + 1]: curr += 1\\n            else: curr = 1\\n            rgt.append(curr)\\n        rgt.reverse()\\n        \\n        return [i for i in range(n) if lft[i] >= t + 1 and rgt[i] >= t + 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1623335,
                "title": "c-o-n-prefix-suffix",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int> &a, int time) {\\n        int n=a.size();\\n        \\n        vector<int> left(n,0), right(n,0);\\n        \\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                left[i]=1+left[i-1]; // count of elements from [0,i-1] >= a[i]\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                right[i]=1+right[i+1]; // count of elements from [i+1,n-1] >= a[i]\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=time;i<n-time;i++){\\n            if(left[i]>=time && right[i]>=time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int> &a, int time) {\\n        int n=a.size();\\n        \\n        vector<int> left(n,0), right(n,0);\\n        \\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                left[i]=1+left[i-1]; // count of elements from [0,i-1] >= a[i]\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                right[i]=1+right[i+1]; // count of elements from [i+1,n-1] >= a[i]\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=time;i<n-time;i++){\\n            if(left[i]>=time && right[i]>=time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623435,
                "title": "o-n-java-solution-easy-understanding",
                "content": "We will construct two arrays:\\nnonincrease will store the consecutive non-increase count until current index\\nnondecrease will store the consecutive non-decrease count until curernt index\\nThen we find index whose nonincrease count and nondecrease count are both larger than time.\\n\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] nonincrease = new int[security.length];\\n        for(int i = 1; i < security.length - time; i++){\\n            if(security[i]>security[i-1]){\\n                nonincrease[i] = 0;\\n            } else {\\n                nonincrease[i] = nonincrease[i-1] + 1;\\n            }\\n        }\\n\\n        int[] nondecrease = new int[security.length];\\n        for(int i = security.length - 2; i >= time; i--) {\\n            if(security[i] > security[i + 1]){\\n                nondecrease[i] = 0;\\n            } else {\\n                nondecrease[i] = nondecrease[i + 1] + 1;\\n            }\\n        }\\n\\n        ArrayList<Integer> result = new ArrayList<>();\\n        for(int i = time; i < security.length - time; i++) {\\n            if(nonincrease[i] >= time && nondecrease[i] >= time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] nonincrease = new int[security.length];\\n        for(int i = 1; i < security.length - time; i++){\\n            if(security[i]>security[i-1]){\\n                nonincrease[i] = 0;\\n            } else {\\n                nonincrease[i] = nonincrease[i-1] + 1;\\n            }\\n        }\\n\\n        int[] nondecrease = new int[security.length];\\n        for(int i = security.length - 2; i >= time; i--) {\\n            if(security[i] > security[i + 1]){\\n                nondecrease[i] = 0;\\n            } else {\\n                nondecrease[i] = nondecrease[i + 1] + 1;\\n            }\\n        }\\n\\n        ArrayList<Integer> result = new ArrayList<>();\\n        for(int i = time; i < security.length - time; i++) {\\n            if(nonincrease[i] >= time && nondecrease[i] >= time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623321,
                "title": "python-short-dp-solution-explained",
                "content": "Let `dp(i, dr)` be the maximum length of decreasing sentence, ending with element `i` and going from left or right, depending on `dr = 1` or `dr = -1`.\\n\\nIn the end we check if we have both answers for left and right more or equal than `T`.\\n\\n\\n#### Complexity\\nIt is `O(n)` for time and space\\n\\n#### Code\\n```python\\nclass Solution:\\n    def goodDaysToRobBank(self, s, T):\\n        n = len(s)\\n        \\n        @lru_cache(None)\\n        def dp(i, dr):\\n            if 0 <= i+dr < n and s[i + dr] >= s[i]: return dp(i + dr, dr) + 1\\n            return 0\\n        \\n        return [i for i in range(n) if dp(i, 1) >= T and dp(i, -1) >= T]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def goodDaysToRobBank(self, s, T):\\n        n = len(s)\\n        \\n        @lru_cache(None)\\n        def dp(i, dr):\\n            if 0 <= i+dr < n and s[i + dr] >= s[i]: return dp(i + dr, dr) + 1\\n            return 0\\n        \\n        return [i for i in range(n) if dp(i, 1) >= T and dp(i, -1) >= T]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900530,
                "title": "o-1-space-complexity-two-pointers",
                "content": "Algorithm:-\\n1.Place two pointers p1 and p2 at 1 and time steps ahead of p1.\\n2.check non-increasing and non-decreasing condition for p1 and p2 respectively. If condition is satisfied increment by 1 else reduce to 0.\\n3.check if p1 and p2 both are greater than equal to time. If True then append the index to result.\\nnums=[5,4,4,3,3,4,5,7,8]  , time=3\\n![image](https://assets.leetcode.com/users/images/7cfdb68f-2e45-4670-95bc-d4738f6247c4_1648732411.1373506.jpeg)\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, nums: List[int], time: int) -> List[int]:  \\n        n=len(nums)\\n        if time==0:return range(n)\\n        res=[]\\n        p1,p2=0,0\\n        for i in range(1,n-time):\\n            p1+=1 if nums[i-1]>=nums[i] else -p1\\n            p2+=1 if nums[i+time-1]<=nums[i+time] else -p2\\n            \\n            if p1>=time and p2>=time:res.append(i)\\n        return res\\n```\\nTime Complexity- O(N)\\nSpace Complexity-O(1)   (Ignoring the space required for result.\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, nums: List[int], time: int) -> List[int]:  \\n        n=len(nums)\\n        if time==0:return range(n)\\n        res=[]\\n        p1,p2=0,0\\n        for i in range(1,n-time):\\n            p1+=1 if nums[i-1]>=nums[i] else -p1\\n            p2+=1 if nums[i+time-1]<=nums[i+time] else -p2\\n            \\n            if p1>=time and p2>=time:res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623330,
                "title": "python3-time-o-n",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        \\n        left = [0 for _ in range(n)]\\n        right = [0 for _ in range(n)]\\n        \\n        for i in range(1, n):\\n            if security[i] <= security[i - 1]:\\n                left[i] += left[i - 1] + 1\\n            else: \\n                left[i] = 0 \\n        \\n        for i in range(n - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                right[i] += right[i + 1] + 1\\n            else: \\n                right[i] = 0 \\n        \\n        ans = []\\n        for i in range(time, n - time):\\n            if left[i] >= time and right[i] >= time:\\n                ans.append(i)\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        \\n        left = [0 for _ in range(n)]\\n        right = [0 for _ in range(n)]\\n        \\n        for i in range(1, n):\\n            if security[i] <= security[i - 1]:\\n                left[i] += left[i - 1] + 1\\n            else: \\n                left[i] = 0 \\n        \\n        for i in range(n - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                right[i] += right[i + 1] + 1\\n            else: \\n                right[i] = 0 \\n        \\n        ans = []\\n        for i in range(time, n - time):\\n            if left[i] >= time and right[i] >= time:\\n                ans.append(i)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623404,
                "title": "array-pre-processing-easy-understanding",
                "content": "make two array pre and post to preprocess the array \\npre array store the length of subarray ending it index which is decreasing\\npost array store the length of subarry ending at index which is increasing\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    5,3,3,3,5,6,2\\n    0 1 2 3 0 0 1 \\n    0 4 3 2 1 0 0 \\n\\n\\n    \\n    */\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size();\\n        vector<int> pre(n),post(n);\\n        \\n        pre[0] = 0;\\n        for(int i = 1; i < pre.size(); ++i){\\n            if(arr[i] <= arr[i-1]){\\n                pre[i] = pre[i-1]+1; // if it is decreasing add one\\n            }\\n            else{\\n                pre[i] = 0; // otherwise reset to zero\\n            }\\n        }\\n        \\n        post[n-1] = 0;\\n        \\n        for(int i = n-2; i>= 0; --i){\\n            if(arr[i] <= arr[i+1]){\\n                post[i] = post[i+1]+1; // if it is increasing add one\\n            }\\n            else{\\n                post[i] = 0; // otherwise reset to zero\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(int i = time; i < n-time; ++i){\\n            if(pre[i]>=time && post[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    5,3,3,3,5,6,2\\n    0 1 2 3 0 0 1 \\n    0 4 3 2 1 0 0 \\n\\n\\n    \\n    */\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size();\\n        vector<int> pre(n),post(n);\\n        \\n        pre[0] = 0;\\n        for(int i = 1; i < pre.size(); ++i){\\n            if(arr[i] <= arr[i-1]){\\n                pre[i] = pre[i-1]+1; // if it is decreasing add one\\n            }\\n            else{\\n                pre[i] = 0; // otherwise reset to zero\\n            }\\n        }\\n        \\n        post[n-1] = 0;\\n        \\n        for(int i = n-2; i>= 0; --i){\\n            if(arr[i] <= arr[i+1]){\\n                post[i] = post[i+1]+1; // if it is increasing add one\\n            }\\n            else{\\n                post[i] = 0; // otherwise reset to zero\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(int i = time; i < n-time; ++i){\\n            if(pre[i]>=time && post[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623352,
                "title": "c-mono-deques-o-n-time-o-t-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Monotonic Deque\\n\\nFor a window `[i - time, i + time]`, use two monotonic deques `a` and `b` to track the numbers in the first half `[i - time, i]` and second half `[i, i + time]` of the window.\\n\\nKeep `a` monotonic non-increasing and `b` monotonic non-decreasing.\\n\\nIf both `a.size()` and `b.size()` equal `time + 1`, we add the current index `i` into the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-67/problems/find-good-days-to-rob-the-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(T)\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& A, int time) {\\n        deque<int> a, b;\\n        vector<int> ans;\\n        for (int i = 0; i + time < A.size(); ++i) {\\n            while (a.size() && A[a.back()] < A[i]) a.pop_back(); // Before pushing `i`, pop the indexes at the back of the deque whose corresponding value `< A[i]`\\n            a.push_back(i);\\n            if (a.front() < i - time) a.pop_front(); // Pop index if it\\'s out of window\\n            while (b.size() && A[b.back()] > A[i + time]) b.pop_back(); // Before pusing `i+time`, pop the indexes at the back of the deque whose corresponding value `> A[i+time]`\\n            b.push_back(i + time);\\n            if (b.front() < i) b.pop_front(); // Pop index if it\\'s out of window\\n            if (a.size() == time + 1 && b.size() == time + 1) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. DP\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-good-days-to-rob-the-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& A, int time) {\\n        int N = A.size(), left = 1;\\n        vector<int> right(N, 1), ans;\\n        for (int i = N - 2; i >= 0; --i) {\\n            if (A[i] <= A[i + 1]) right[i] += right[i + 1];\\n        }\\n        for (int i = 0; i + time < N; ++i) {\\n            if (i - 1 >= 0 && A[i] <= A[i - 1]) left++;\\n            else left = 1;\\n            if (left > time && right[i] > time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-67/problems/find-good-days-to-rob-the-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(T)\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& A, int time) {\\n        deque<int> a, b;\\n        vector<int> ans;\\n        for (int i = 0; i + time < A.size(); ++i) {\\n            while (a.size() && A[a.back()] < A[i]) a.pop_back(); // Before pushing `i`, pop the indexes at the back of the deque whose corresponding value `< A[i]`\\n            a.push_back(i);\\n            if (a.front() < i - time) a.pop_front(); // Pop index if it\\'s out of window\\n            while (b.size() && A[b.back()] > A[i + time]) b.pop_back(); // Before pusing `i+time`, pop the indexes at the back of the deque whose corresponding value `> A[i+time]`\\n            b.push_back(i + time);\\n            if (b.front() < i) b.pop_front(); // Pop index if it\\'s out of window\\n            if (a.size() == time + 1 && b.size() == time + 1) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/find-good-days-to-rob-the-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& A, int time) {\\n        int N = A.size(), left = 1;\\n        vector<int> right(N, 1), ans;\\n        for (int i = N - 2; i >= 0; --i) {\\n            if (A[i] <= A[i + 1]) right[i] += right[i + 1];\\n        }\\n        for (int i = 0; i + time < N; ++i) {\\n            if (i - 1 >= 0 && A[i] <= A[i - 1]) left++;\\n            else left = 1;\\n            if (left > time && right[i] > time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664740,
                "title": "c-simple-prefix-suffix-calculation-tc-o-n-sc-o-n",
                "content": "I am explaining the solution with the help of example :-\\n\\n```\\nInput: security = [5,3,3,3,5,6,2], time = 2\\nOutput: [2,3]\\n```\\n\\nWe can simply find the solution by simply performing the following steps :-\\n\\nStep -1 -> Form the **prefix** array where prefix[i] represents number of days before i which obeys non-increasing which can be calculated in following manner :-\\n```\\nprefix[0] = 0;\\nfor(int i=1;i<n;i++) {\\n\\tif(security[i] <= security[i-1]) prefix[i] = prefix[i-1]+1;\\n\\telse prefix[i] = 0;\\n}\\n```\\n\\nStep -2 -> Form the **suffix** array where suffix[i] represents number of days after i which obeys non-decreasing which can be calculated in following manner :-\\n```\\nsuffix[n-1] = 0;\\nfor(int i=(n-2);i>=0;i--) {\\n\\tif(security[i] <= security[i+1]) suffix[i] = suffix[i+1]+1;\\n\\telse suffix[i] = 0;\\n}\\n```\\nStep -3 -> Now only that indexes should be included in our answer for which, both prefix[i] and suffix[i] are greater than or equal to the given integer **time**.\\n\\nFor our example, \\n```\\nprefix = [0, 1, 2, 3, 0, 0, 1]\\nsuffix = [0, 4, 3, 2, 1, 0, 0]\\nresult = [2, 3]\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> prefix(n), suffix(n);\\n        vector<int> ans;\\n        \\n        prefix[0] = 0;\\n        for(int i=1;i<n;i++) {\\n            if(security[i] <= security[i-1]) prefix[i] = prefix[i-1]+1;\\n            else prefix[i] = 0;\\n        }\\n        \\n        suffix[n-1] = 0;\\n        for(int i=(n-2);i>=0;i--) {\\n            if(security[i] <= security[i+1]) suffix[i] = suffix[i+1]+1;\\n            else suffix[i] = 0;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(prefix[i]>=time && suffix[i]>=time) ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nInput: security = [5,3,3,3,5,6,2], time = 2\\nOutput: [2,3]\\n```\n```\\nprefix[0] = 0;\\nfor(int i=1;i<n;i++) {\\n\\tif(security[i] <= security[i-1]) prefix[i] = prefix[i-1]+1;\\n\\telse prefix[i] = 0;\\n}\\n```\n```\\nsuffix[n-1] = 0;\\nfor(int i=(n-2);i>=0;i--) {\\n\\tif(security[i] <= security[i+1]) suffix[i] = suffix[i+1]+1;\\n\\telse suffix[i] = 0;\\n}\\n```\n```\\nprefix = [0, 1, 2, 3, 0, 0, 1]\\nsuffix = [0, 4, 3, 2, 1, 0, 0]\\nresult = [2, 3]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> prefix(n), suffix(n);\\n        vector<int> ans;\\n        \\n        prefix[0] = 0;\\n        for(int i=1;i<n;i++) {\\n            if(security[i] <= security[i-1]) prefix[i] = prefix[i-1]+1;\\n            else prefix[i] = 0;\\n        }\\n        \\n        suffix[n-1] = 0;\\n        for(int i=(n-2);i>=0;i--) {\\n            if(security[i] <= security[i+1]) suffix[i] = suffix[i+1]+1;\\n            else suffix[i] = 0;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(prefix[i]>=time && suffix[i]>=time) ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646239,
                "title": "idea-explained-prefix-suffix-array-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is really straight forward. \\n* For each element we need to get the length of *non-increasing* subarray to its left,\\n* And get the length of *non-decreasing* subarray to its right.\\n* This can be done easily using prefix and suffix array. \\n* Prefix array stores the length of *non-increasing* subarray, \\n* Suffix array stores the length of *non-decreasing* subarray.\\n\\n\\t\\tEx: security = {5, 3, 3, 3, 5, 6, 2}\\n\\t\\t\\n\\t\\ti    ->  0 1 2 3 4 5 6\\n\\t\\tsec  ->  5 3 3 3 5 6 2\\n\\t\\tpref ->  0 1 2 3 0 0 1\\n\\t\\tsuff ->  5 4 3 2 1 0 0\\n\\t\\t\\n* Now, that we have prefix and suffix array ready. For each element we need to check if \\n\\t* `pref[i] >= time` and `suff[i] >= time` \\n\\t* i.e length of *non-increasing* and *non-decreasing* subarray must be greater than `time`.\\n\\n--------------------------\\n# Code : \\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n = security.size();\\n        vector<int> pref(n, 0), suff(n, 0);\\n        for(int i=1; i<n-1; i++) {\\n            if(security[i] <= security[i-1])\\n                pref[i] = pref[i-1] + 1;\\n        }\\n        \\n        for(int i=n-2; i>=0; i--) {\\n            if(security[i] <= security[i+1])\\n                suff[i] = suff[i+1] + 1;\\n        }\\n        \\n        vector<int> goodDays;\\n        for(int i=0; i<n; i++) {\\n            if(pref[i] >= time && suff[i] >= time) \\n                goodDays.push_back(i);\\n        }\\n        \\n        return goodDays;\\n    }\\n};\\n```\\n\\n--------------------------\\n\\n**Complexity :**\\n\\n* Time : `O(N)`, N is size of security array.\\n\\t* O(2* N) -> precompute `pref` and `suff` array\\n\\t* O(N) -> calculate `goodDays` array\\n\\n* Space : `O(N)`, to store `pref` and `suff` results.\\n--------------------------\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n = security.size();\\n        vector<int> pref(n, 0), suff(n, 0);\\n        for(int i=1; i<n-1; i++) {\\n            if(security[i] <= security[i-1])\\n                pref[i] = pref[i-1] + 1;\\n        }\\n        \\n        for(int i=n-2; i>=0; i--) {\\n            if(security[i] <= security[i+1])\\n                suff[i] = suff[i+1] + 1;\\n        }\\n        \\n        vector<int> goodDays;\\n        for(int i=0; i<n; i++) {\\n            if(pref[i] >= time && suff[i] >= time) \\n                goodDays.push_back(i);\\n        }\\n        \\n        return goodDays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623440,
                "title": "java-simple-solution-track-left-right-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int []left = new int[n];\\n        int []right = new int[n];\\n        \\n        for(int i = 1;i<n;i++){\\n            left[i] = security[i] <= security[i-1] ? left[i-1] + 1 : 0;\\n        }\\n        for(int i = n-2;i>=0;i--){\\n            right[i] = security[i] <= security[i+1] ? right[i+1] + 1 : 0;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i = time;i<security.length-time;i++){\\n            if(left[i] >= time && right[i] >= time){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int []left = new int[n];\\n        int []right = new int[n];\\n        \\n        for(int i = 1;i<n;i++){\\n            left[i] = security[i] <= security[i-1] ? left[i-1] + 1 : 0;\\n        }\\n        for(int i = n-2;i>=0;i--){\\n            right[i] = security[i] <= security[i+1] ? right[i+1] + 1 : 0;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i = time;i<security.length-time;i++){\\n            if(left[i] >= time && right[i] >= time){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623325,
                "title": "python3-prefix-suffix",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b553623546e2799477b8bca6b5c89f22c83a4d08) for solutions of weekly 67. \\n\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        suffix = [0]*len(security)\\n        for i in range(len(security)-2, 0, -1): \\n            if security[i] <= security[i+1]: suffix[i] = suffix[i+1] + 1\\n        \\n        ans = []\\n        prefix = 0\\n        for i in range(len(security)-time): \\n            if i and security[i-1] >= security[i]: prefix += 1\\n            else: prefix = 0\\n            if prefix >= time and suffix[i] >= time: ans.append(i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        suffix = [0]*len(security)\\n        for i in range(len(security)-2, 0, -1): \\n            if security[i] <= security[i+1]: suffix[i] = suffix[i+1] + 1\\n        \\n        ans = []\\n        prefix = 0\\n        for i in range(len(security)-time): \\n            if i and security[i-1] >= security[i]: prefix += 1\\n            else: prefix = 0\\n            if prefix >= time and suffix[i] >= time: ans.append(i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885137,
                "title": "easy-c-solution-using-prefix-and-suffix-array",
                "content": "# Intuition\\n\\n\\n# Approach\\nWe will find previous and next greater elements for each index and will store them in two vector ---prefix and ---suffix respectively and finally will traverse through the security array and check if values at that particular index in prefix and sufix array are greater than time then we will push that index in our ans vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nO(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\n        int n=security.size();\\n        vector<int>prefix(n,0);\\n        vector<int>sufix(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        \\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i]){\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n        }\\n        \\n        vector<int>ans;\\n\\n        for(int i=time;i<n-time;i++){\\n            if(prefix[i]>=time && sufix[i]>=time){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\n        int n=security.size();\\n        vector<int>prefix(n,0);\\n        vector<int>sufix(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        \\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i]){\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n        }\\n        \\n        vector<int>ans;\\n\\n        for(int i=time;i<n-time;i++){\\n            if(prefix[i]>=time && sufix[i]>=time){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886272,
                "title": "c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> robDays;\\n        int len = security.size();\\n\\n        // arrays to store number of non-increasing day before ith day, initialising with 0\\n        vector<int> numDaysBefore(len, 0);\\n        // arrays to store number of non-decreasing day after ith day\\n        vector<int> numDaysAfter(len, 0);\\n        \\n        // iterate from left to right, to find non-increasing pattern and storing number of non-inc days before each particular day\\n        for(int i=1; i<len; i++){\\n            if(security[i-1] >= security[i]){\\n                numDaysBefore[i] = 1 + numDaysBefore[i-1];\\n            }\\n        }\\n        \\n        // the above step for number of non-decreasing days before each particular day\\n        for(int j=len-2; j>=0; j--){\\n            if(security[j+1] >= security[j]){\\n                numDaysAfter[j] = 1 + numDaysAfter[j+1];\\n            }\\n        }\\n        \\n        // check if the condition 2 & 3 given in Q. are satisfy\\n        for(int k = time; k < (len - time); k++){\\n            if(numDaysBefore[k] >= time && numDaysAfter[k] >= time)\\n                robDays.push_back(k);\\n        }\\n        \\n        return robDays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> robDays;\\n        int len = security.size();\\n\\n        // arrays to store number of non-increasing day before ith day, initialising with 0\\n        vector<int> numDaysBefore(len, 0);\\n        // arrays to store number of non-decreasing day after ith day\\n        vector<int> numDaysAfter(len, 0);\\n        \\n        // iterate from left to right, to find non-increasing pattern and storing number of non-inc days before each particular day\\n        for(int i=1; i<len; i++){\\n            if(security[i-1] >= security[i]){\\n                numDaysBefore[i] = 1 + numDaysBefore[i-1];\\n            }\\n        }\\n        \\n        // the above step for number of non-decreasing days before each particular day\\n        for(int j=len-2; j>=0; j--){\\n            if(security[j+1] >= security[j]){\\n                numDaysAfter[j] = 1 + numDaysAfter[j+1];\\n            }\\n        }\\n        \\n        // check if the condition 2 & 3 given in Q. are satisfy\\n        for(int k = time; k < (len - time); k++){\\n            if(numDaysBefore[k] >= time && numDaysAfter[k] >= time)\\n                robDays.push_back(k);\\n        }\\n        \\n        return robDays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646354,
                "title": "python-o-n-by-prefix-postfix-table-w-example",
                "content": "**Hint**:\\n\\nThink of **prefix table**/**postfix table** to record the length of continuous security guard weakening as well as strengthening. \\n\\nThen we can rewrite good day, Day_i, with the condition that \\n\\nContSecurity**WeakenLength( Day_i ) \\u2265 time threshold**, and \\nContSecurity**StrengthenLength( Day_i ) \\u2265 tIme threshold**.\\n\\n---\\n\\n**Example**:\\n\\nGiven input security \\n= [5, 3, 3, 3, 5, 6, 2] with **time = 2**\\n\\nWe can know\\nlength of continuous security guard weakening ( on **backward direction \\u2190**)\\n= [0, 1, **2**, **3**, 0, 0, 1]\\n\\nlength of continuous security guard strengthening ( on **forward direction \\u2192**)\\n= [0, 4, **3**, **2**, 1, 0, 0]\\n\\n---\\n\\nFor index 2, **index 2** has security weakening of length **2** and security strengthening of length **3**.\\n\\nFor index 3, **index 3** has security weakening of length **3** and security strengthening of length **2**.\\n\\n\\nOnly index 2 and index 3 have length of security weakening \\u2265 time, \\nand length of security strengthening \\u2265 time.\\n\\nTherefore, return [2, 3] as final answer.\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # total length of security on duty days\\n        days = len(security)\\n        \\n        ## Base case\\n        if time == 0:\\n            \\n            # Threshold is too small, every day is good day.\\n            return [ day_i for day_i in range(days) ]\\n        \\n        \\n        elif time > days // 2:\\n            \\n            # Threshold is too large, impossible to have good days.\\n            return []\\n        \\n        \\n        ## General case\\n        \\n        # Prefix table, record of length of continuous security guard weakening on index i\\n        weakenDays = [0] * days\\n        # Postfix table, record of length of continuous security guard strengthening on index i\\n        strengthenDays = [0] * days\\n        \\n        # Update prefix table and postfix table\\n        for i in range(1, days):\\n            \\n            if security[i] <= security[i-1]:\\n                weakenDays[i] = weakenDays[i-1] + 1\\n\\n            if security[-i-1] <= security[-i]:\\n                strengthenDays[-i-1] =  strengthenDays[-i] + 1\\n\\n        \\n        # helper lambda function to judege good day by definition\\n        is_good_day = lambda i: ( weakenDays[i] >= time ) and ( strengthenDays[i] >= time )\\n\\n        return [ day_i for day_i in range( days ) if is_good_day(day_i) ]\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # total length of security on duty days\\n        days = len(security)\\n        \\n        ## Base case\\n        if time == 0:\\n            \\n            # Threshold is too small, every day is good day.\\n            return [ day_i for day_i in range(days) ]\\n        \\n        \\n        elif time > days // 2:\\n            \\n            # Threshold is too large, impossible to have good days.\\n            return []\\n        \\n        \\n        ## General case\\n        \\n        # Prefix table, record of length of continuous security guard weakening on index i\\n        weakenDays = [0] * days\\n        # Postfix table, record of length of continuous security guard strengthening on index i\\n        strengthenDays = [0] * days\\n        \\n        # Update prefix table and postfix table\\n        for i in range(1, days):\\n            \\n            if security[i] <= security[i-1]:\\n                weakenDays[i] = weakenDays[i-1] + 1\\n\\n            if security[-i-1] <= security[-i]:\\n                strengthenDays[-i-1] =  strengthenDays[-i] + 1\\n\\n        \\n        # helper lambda function to judege good day by definition\\n        is_good_day = lambda i: ( weakenDays[i] >= time ) and ( strengthenDays[i] >= time )\\n\\n        return [ day_i for day_i in range( days ) if is_good_day(day_i) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624133,
                "title": "c-map-inc-dec-index-storage",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION AND EXPLANATION**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& a, int time) \\n    {\\n        //as we need to check criteria for i-time to i+time so this condition is necessary\\n        if(2*time>a.size())return {};\\n        vector<int>res;\\n        //edge case here we do not have to check for the given condition \\n        //as time is 0 :)\\n        if(time==0)\\n        {\\n            for(int i=0;i<a.size();i++)res.push_back(i);\\n            return res;\\n        }\\n        //create two maps one for storing the indices(0th based)(start,end) of non-increasing subarray\\n        //one for storing (end,start) of non-decreasing subarray \\n        //storing in this way helps in better implementation \\n        map<int,int>dec,inc;\\n        int start=0,end=-1;\\n        \\n        //store the non-increasing subarray indices\\n        for(int i=1;i<a.size();)\\n        {\\n            if(a[i]<=a[i-1])\\n            {start=i-1;\\n               while(i<a.size()&&a[i]<=a[i-1])\\n            {end=i;i++;}\\n            dec[start]=end;  \\n            }\\n            else\\n                i++;\\n        }\\n        //store the non-decreasing subarray indices\\n         for(int i=1;i<a.size();)\\n        {\\n            if(a[i]>=a[i-1])\\n            {start=i-1;\\n               while(i<a.size()&&a[i]>=a[i-1])\\n            {end=i;i++;}\\n            inc[end]=start;  \\n            }\\n            else\\n                i++;\\n        }\\n        //we start from time and end at length-time for obvious reasons :\\')\\n        for(int i=time;i<a.size()-time;i++)\\n        {\\n            //here we find the start index of a non-increasing subarray just greater than\\n            //required criteria and check if the previous iterator\\'s end index is \\n            //greater thanor equal to (i)th value so we get a non-increasing subarray till i\\n            //from front\\n            auto it=dec.upper_bound(i-time);\\n            \\n            //here we find the end index of a non-decreasing subarray eual or greater than\\n            //required criteria and check if this iterator\\'s start index is lesser than or equal to\\n            //(i)th value so we get a non-decreasing subarray till i from back\\n            auto it1=inc.lower_bound(i+time);\\n            //cases where the criteria is not possible\\n            //u will get it by urself ik :)\\n           if(it==dec.begin())continue;\\n           if(it1==inc.end())continue;\\n            \\n            it--;//this is for decrementing the non-increasing iterator as mentioned above\\n            \\n            //this is the required condition\\n                if((*it).second>=i&&(*it1).second<=i)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& a, int time) \\n    {\\n        //as we need to check criteria for i-time to i+time so this condition is necessary\\n        if(2*time>a.size())return {};\\n        vector<int>res;\\n        //edge case here we do not have to check for the given condition \\n        //as time is 0 :)\\n        if(time==0)\\n        {\\n            for(int i=0;i<a.size();i++)res.push_back(i);\\n            return res;\\n        }\\n        //create two maps one for storing the indices(0th based)(start,end) of non-increasing subarray\\n        //one for storing (end,start) of non-decreasing subarray \\n        //storing in this way helps in better implementation \\n        map<int,int>dec,inc;\\n        int start=0,end=-1;\\n        \\n        //store the non-increasing subarray indices\\n        for(int i=1;i<a.size();)\\n        {\\n            if(a[i]<=a[i-1])\\n            {start=i-1;\\n               while(i<a.size()&&a[i]<=a[i-1])\\n            {end=i;i++;}\\n            dec[start]=end;  \\n            }\\n            else\\n                i++;\\n        }\\n        //store the non-decreasing subarray indices\\n         for(int i=1;i<a.size();)\\n        {\\n            if(a[i]>=a[i-1])\\n            {start=i-1;\\n               while(i<a.size()&&a[i]>=a[i-1])\\n            {end=i;i++;}\\n            inc[end]=start;  \\n            }\\n            else\\n                i++;\\n        }\\n        //we start from time and end at length-time for obvious reasons :\\')\\n        for(int i=time;i<a.size()-time;i++)\\n        {\\n            //here we find the start index of a non-increasing subarray just greater than\\n            //required criteria and check if the previous iterator\\'s end index is \\n            //greater thanor equal to (i)th value so we get a non-increasing subarray till i\\n            //from front\\n            auto it=dec.upper_bound(i-time);\\n            \\n            //here we find the end index of a non-decreasing subarray eual or greater than\\n            //required criteria and check if this iterator\\'s start index is lesser than or equal to\\n            //(i)th value so we get a non-decreasing subarray till i from back\\n            auto it1=inc.lower_bound(i+time);\\n            //cases where the criteria is not possible\\n            //u will get it by urself ik :)\\n           if(it==dec.begin())continue;\\n           if(it1==inc.end())continue;\\n            \\n            it--;//this is for decrementing the non-increasing iterator as mentioned above\\n            \\n            //this is the required condition\\n                if((*it).second>=i&&(*it1).second<=i)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623399,
                "title": "c-2100-find-good-days-to-rob-the-bank",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size(); \\n        vector<int> suffix(n); \\n        for (int i = n-2; i >= 0; --i) \\n            if (security[i] <= security[i+1]) suffix[i] = suffix[i+1] + 1; \\n        \\n        vector<int> ans; \\n        int prefix = 0; \\n        for (int i = 0; i < n-time; ++i) {\\n            if (i && security[i-1] >= security[i]) ++prefix; \\n            else prefix = 0; \\n            if (prefix >= time && suffix[i] >= time) ans.push_back(i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size(); \\n        vector<int> suffix(n); \\n        for (int i = n-2; i >= 0; --i) \\n            if (security[i] <= security[i+1]) suffix[i] = suffix[i+1] + 1; \\n        \\n        vector<int> ans; \\n        int prefix = 0; \\n        for (int i = 0; i < n-time; ++i) {\\n            if (i && security[i-1] >= security[i]) ++prefix; \\n            else prefix = 0; \\n            if (prefix >= time && suffix[i] >= time) ans.push_back(i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611404,
                "title": "simple-python-easy-to-understand-solution-o-n",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        pre = [0]*n\\n        post = [0]*n\\n        for i in range(1, n):\\n            if security[i-1] >= security[i]:\\n                pre[i] = pre[i-1] + 1\\n            else:\\n                pre[i] = 0\\n        for i in range(n-2, -1, -1):\\n            if security[i+1] >= security[i]:\\n                post[i] = post[i+1] + 1\\n            else:\\n                post[i] = 0\\n        res = []\\n        for i in range(n):\\n            if pre[i] >= time and post[i] >= time:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        pre = [0]*n\\n        post = [0]*n\\n        for i in range(1, n):\\n            if security[i-1] >= security[i]:\\n                pre[i] = pre[i-1] + 1\\n            else:\\n                pre[i] = 0\\n        for i in range(n-2, -1, -1):\\n            if security[i+1] >= security[i]:\\n                post[i] = post[i+1] + 1\\n            else:\\n                post[i] = 0\\n        res = []\\n        for i in range(n):\\n            if pre[i] >= time and post[i] >= time:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301932,
                "title": "c-tc-o-n-constant-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& st, int time) {\\n        int cnt = 0; // count no increasing element and decreasing element at same time \\n        int i = 0; // pointing to decreasing element\\n        int j = time; // pointing to increasing element\\n        vector<int> ans;\\n        while(j<st.size()){ //start traversing\\n            if(cnt==time){ // if we found cnt == time means no of decreasing && increasing  elements at left and right position are now target times then push current index into ans and cnt-- because current element is previous for next element \\n                ans.push_back(i);\\n                cnt--;\\n            }\\n            if(j!=st.size()-1 && st[i]>=st[i+1] && st[j]<=st[j+1]) {  // if array is  decreasing && increasing at same time at i and j then cnt++\\n                i++;\\n                j++;\\n                cnt++;\\n            } \\n            else{ // if any array in either non-decreasing in left and non-increasing in right or both then start a new count = 0\\n                i++;\\n                j++;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf You Like Solution Please Upvote:)\\nHappy Coding:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& st, int time) {\\n        int cnt = 0; // count no increasing element and decreasing element at same time \\n        int i = 0; // pointing to decreasing element\\n        int j = time; // pointing to increasing element\\n        vector<int> ans;\\n        while(j<st.size()){ //start traversing\\n            if(cnt==time){ // if we found cnt == time means no of decreasing && increasing  elements at left and right position are now target times then push current index into ans and cnt-- because current element is previous for next element \\n                ans.push_back(i);\\n                cnt--;\\n            }\\n            if(j!=st.size()-1 && st[i]>=st[i+1] && st[j]<=st[j+1]) {  // if array is  decreasing && increasing at same time at i and j then cnt++\\n                i++;\\n                j++;\\n                cnt++;\\n            } \\n            else{ // if any array in either non-decreasing in left and non-increasing in right or both then start a new count = 0\\n                i++;\\n                j++;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786102,
                "title": "python-c-single-pass-o-n-time-o-1-space",
                "content": "The idea is to have two pointers seperated by `time`. The leading pointer (`p1`) counts how many days before it are non-decreasing, and the trailing pointer (`p0`) the number of days before it that are non-increasing. It\\'s a good day to rob the bank whenever both `p0` and `p1` are greater than `time`.\\n\\n**Python**\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\t    n = len(security)\\n        if not time: return range(n)\\n        sols = []\\n        p0 = p1 = 0         \\n\\t\\tif n < 2*time: return sols\\n        for i in range(1, n-time):\\n            p0 += 1 if security[i-1] >= security[i] else -p0\\n            p1 += 1 if security[i+time-1] <= security[i+time] else -p1\\n            if p0 >= time and p1 >= time: sols.append(i)\\n        return sols\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\t    int n = security.size();\\n        int p0 = 0;\\n        int p1 = 0;\\n        vector<int> sols;\\n        \\n        if (time*2>n) return sols;\\n        if (time==0){\\n            sols.resize(n);\\n            iota(sols.begin(), sols.end(), 0);\\n            return sols;\\n        }\\n        \\n        for (int i=1; i < n-time; i++) {\\n            if (security[i-1]>=security[i]) p0++;\\n            else p0 = 0;\\n            if (security[i+time-1] <= security[i+time]) p1++;\\n            else p1 = 0;\\n            if (p0 >= time && p1 >= time) sols.push_back(i);   \\n        }\\n        return sols;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\t    n = len(security)\\n        if not time: return range(n)\\n        sols = []\\n        p0 = p1 = 0         \\n\\t\\tif n < 2*time: return sols\\n        for i in range(1, n-time):\\n            p0 += 1 if security[i-1] >= security[i] else -p0\\n            p1 += 1 if security[i+time-1] <= security[i+time] else -p1\\n            if p0 >= time and p1 >= time: sols.append(i)\\n        return sols\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\t    int n = security.size();\\n        int p0 = 0;\\n        int p1 = 0;\\n        vector<int> sols;\\n        \\n        if (time*2>n) return sols;\\n        if (time==0){\\n            sols.resize(n);\\n            iota(sols.begin(), sols.end(), 0);\\n            return sols;\\n        }\\n        \\n        for (int i=1; i < n-time; i++) {\\n            if (security[i-1]>=security[i]) p0++;\\n            else p0 = 0;\\n            if (security[i+time-1] <= security[i+time]) p1++;\\n            else p1 = 0;\\n            if (p0 >= time && p1 >= time) sols.push_back(i);   \\n        }\\n        return sols;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666007,
                "title": "c-simple-2-pointer-precomputing-longest-increasing-decreasing-subarray-length",
                "content": "The core logic is simple. We somehow need to compute the longest increasing/decreasing subarray length. Then for each day, we can check if that day is suitable for robbery or not, using the condition given in the problem. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size(), i = 0, j = 0; \\n        vector<int> nonDec(n, 1), nonInc(n, 0), res; \\n        \\n        while(j < n){\\n            nonInc[j] = j-i+1; \\n            if (j+1 < n && security[j] < security[j+1]) i = j+1; \\n            j++; \\n            \\n        }\\n        i = n-1, j = n-1; \\n        \\n        while(j >= 0){\\n            nonDec[j] = i-j + 1; \\n            if (j > 0 && security[j] < security[j-1]) i = j-1; \\n            j--; \\n            \\n        }\\n        \\n        for(int i=0; i<n ; i++){\\n            if(nonDec[i] > time && nonInc[i] > time) res.push_back(i); \\n        }\\n        return res ;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size(), i = 0, j = 0; \\n        vector<int> nonDec(n, 1), nonInc(n, 0), res; \\n        \\n        while(j < n){\\n            nonInc[j] = j-i+1; \\n            if (j+1 < n && security[j] < security[j+1]) i = j+1; \\n            j++; \\n            \\n        }\\n        i = n-1, j = n-1; \\n        \\n        while(j >= 0){\\n            nonDec[j] = i-j + 1; \\n            if (j > 0 && security[j] < security[j-1]) i = j-1; \\n            j--; \\n            \\n        }\\n        \\n        for(int i=0; i<n ; i++){\\n            if(nonDec[i] > time && nonInc[i] > time) res.push_back(i); \\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623719,
                "title": "simple-o-n-explained-javascript-solution",
                "content": "Let build to arrays `left[i]`and `right[i]`.\\nFor `left[i]=left[i-1]+1` if `security[i-1] >= security[i]` - not increasing order, or 0 otherwise.\\nFor `right[i] = right[i+1] +1` if `security[i+1] >= security[i]` - not decreasing order, or 0 otherwise.\\nThe day i is a good day to robe if `left[i] >= time && right[i] >= time`\\n\\n```\\nvar goodDaysToRobBank = function(security, time) {\\n    const n = security.length\\n    const left = buildLeftValidArray(security)\\n    const right = buildRightValidArray(security)\\n    \\n    const result = []\\n    for(let i = 0; i < security.length; i++){\\n        // The day i is good day to rob if left[i] and right[i] >= time\\n        if(left[i] >= time && right[i] >= time){\\n            result.push(i)\\n        }\\n    }\\n    \\n    return result\\n};\\n\\nfunction buildRightValidArray(security){\\n    const n = security.length\\n    const right = new Array(n)\\n    \\n    right[n-1] = 0\\n    \\n    for(let i = n-2; i >= 0; i--){\\n        if(security[i+1] >= security[i]){\\n            right[i] = right[i+1] +1\\n        }\\n        else{\\n            right[i] = 0\\n        }\\n    }\\n    \\n    return right\\n}\\n\\nfunction buildLeftValidArray(security){\\n    const n = security.length\\n    const left = new Array(n)\\n    left[0] = 0\\n    for(let i = 1; i < n; i++){\\n        if(security[i-1] >= security[i]){\\n            left[i] = left[i-1] + 1\\n        }else\\n        {\\n            left[i] = 0\\n        }\\n    }\\n    \\n    return left\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    const n = security.length\\n    const left = buildLeftValidArray(security)\\n    const right = buildRightValidArray(security)\\n    \\n    const result = []\\n    for(let i = 0; i < security.length; i++){\\n        // The day i is good day to rob if left[i] and right[i] >= time\\n        if(left[i] >= time && right[i] >= time){\\n            result.push(i)\\n        }\\n    }\\n    \\n    return result\\n};\\n\\nfunction buildRightValidArray(security){\\n    const n = security.length\\n    const right = new Array(n)\\n    \\n    right[n-1] = 0\\n    \\n    for(let i = n-2; i >= 0; i--){\\n        if(security[i+1] >= security[i]){\\n            right[i] = right[i+1] +1\\n        }\\n        else{\\n            right[i] = 0\\n        }\\n    }\\n    \\n    return right\\n}\\n\\nfunction buildLeftValidArray(security){\\n    const n = security.length\\n    const left = new Array(n)\\n    left[0] = 0\\n    for(let i = 1; i < n; i++){\\n        if(security[i-1] >= security[i]){\\n            left[i] = left[i-1] + 1\\n        }else\\n        {\\n            left[i] = 0\\n        }\\n    }\\n    \\n    return left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623331,
                "title": "java-prefix-arrays",
                "content": "```\\npublic List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        \\n        \\n        List<Integer> list = new ArrayList();\\n        \\n        int inc[] = new int[security.length];\\n        int dcr[] = new int[security.length];\\n        \\n        int count = 0;\\n        for(int i = 0;i<security.length-1;i++){\\n            if(security[i] >= security[i+1]){\\n                inc[i+1] = ++count;\\n            }else{\\n                count= 0;\\n                inc[i+1] = count;\\n            }\\n        }\\n        \\n         count = 0;\\n         for(int i=security.length-2; i>= 0;i--){\\n            if(security[i] <= security[i+1]){\\n                dcr[i] = ++count;\\n            }else{\\n                count= 0;\\n                dcr[i] = count;\\n            }\\n        }\\n        \\n        \\n        for(int i = 0;i<security.length;i++){\\n            if(inc[i] >= time && dcr[i] >= time){\\n                list.add(i);\\n            }\\n        }\\n \\n        return list;\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        \\n        \\n        List<Integer> list = new ArrayList();\\n        \\n        int inc[] = new int[security.length];\\n        int dcr[] = new int[security.length];\\n        \\n        int count = 0;\\n        for(int i = 0;i<security.length-1;i++){\\n            if(security[i] >= security[i+1]){\\n                inc[i+1] = ++count;\\n            }else{\\n                count= 0;\\n                inc[i+1] = count;\\n            }\\n        }\\n        \\n         count = 0;\\n         for(int i=security.length-2; i>= 0;i--){\\n            if(security[i] <= security[i+1]){\\n                dcr[i] = ++count;\\n            }else{\\n                count= 0;\\n                dcr[i] = count;\\n            }\\n        }\\n        \\n        \\n        for(int i = 0;i<security.length;i++){\\n            if(inc[i] >= time && dcr[i] >= time){\\n                list.add(i);\\n            }\\n        }\\n \\n        return list;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1623302,
                "title": "left-to-right-and-right-to-left",
                "content": "We first go left-to-right, and collect `i` that has `time` non-increasing guards. We track those indices in `before`.\\n\\nThen, we go right-to-left and do the same for non-decreasing guards. If `i` is also in `before` - it\\'s a good day to rob a bank.\\n\\n(though, any day to rob a bank is a bad day)\\n\\n**C++**\\n```cpp\\nvector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n    vector<int> before, res;\\n    int cnt = 0, sz = s.size();\\n    for (int i = 0; i < sz; ++i) {\\n        cnt = i > 0 && s[i - 1] >= s[i] ? cnt + 1 : 0;\\n        if (cnt >= time)\\n            before.push_back(i);\\n    }\\n    for (int i = sz - 1; !before.empty() && i >= 0; --i) {\\n        cnt = i < sz - 1 && s[i] <= s[i + 1] ? cnt + 1 : 0;\\n        if (cnt >= time && i == before.back())\\n            res.push_back(i);\\n        if (i <= before.back())\\n            before.pop_back();\\n    }        \\n    return vector<int>(rbegin(res), rend(res));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n    vector<int> before, res;\\n    int cnt = 0, sz = s.size();\\n    for (int i = 0; i < sz; ++i) {\\n        cnt = i > 0 && s[i - 1] >= s[i] ? cnt + 1 : 0;\\n        if (cnt >= time)\\n            before.push_back(i);\\n    }\\n    for (int i = sz - 1; !before.empty() && i >= 0; --i) {\\n        cnt = i < sz - 1 && s[i] <= s[i + 1] ? cnt + 1 : 0;\\n        if (cnt >= time && i == before.back())\\n            res.push_back(i);\\n        if (i <= before.back())\\n            before.pop_back();\\n    }        \\n    return vector<int>(rbegin(res), rend(res));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871097,
                "title": "prefix-sum-no-dp-easy-c-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple just count the number of **decreasing and increasing days** for each day and check whether this day is **good or not**.\\nHere I used **two vectors** to **store** the number of **decreasing and increasing** days for each ith day.\\n\\n```\\nFor example:- Security = [6,5,5,4,7,8,9,2] and Time = 2\\nFirst of all we will calculate the number of decreasing days for every ith day:-\\nDay 0:- 0\\nDay 1:- 1 ( [6] )\\nDay 2: -2 ( [6,5] )\\nDay 3:- 3 ( [6,5,5])\\nDay 4:- 0\\nDay 5:- 0\\nDay 6:- 0\\nDay 7:- 1 ( [9] )\\n\\nNow we will calculate the number of increasing days for every ith day:-\\nDay:-\\nDay 7:- 0\\nDay 6:- 0\\nDay 5:- 1 ( [9] )\\nDay 4: -2 ([8,9])\\nDay 3:- 3 ( [7,8,9] )\\nDay 2:- 0\\nDay 1:- 1 ( [5] )\\nDay 0:- 0\\n\\nWe can see that only the day-3 is a good day because there are three increasing and three decreasing days on this day.\\n```\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        vector<int> dec(n,0),inc(n,0),ans;\\n        for(int i = 1;i<n;i++) if(arr[i]<=arr[i-1]) dec[i]+=dec[i-1]+1;\\n        for(int i = n-2;i>=0;i--) if(arr[i]<=arr[i+1]) inc[i]+=inc[i+1]+1;\\n        for(int i = 0;i<n;i++)\\n        if(dec[i]>=t && inc[i]>=t) ans.push_back(i);\\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/8735c631-fefc-432d-82d9-0c60688c73b1_1691308823.9191308.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nFor example:- Security = [6,5,5,4,7,8,9,2] and Time = 2\\nFirst of all we will calculate the number of decreasing days for every ith day:-\\nDay 0:- 0\\nDay 1:- 1 ( [6] )\\nDay 2: -2 ( [6,5] )\\nDay 3:- 3 ( [6,5,5])\\nDay 4:- 0\\nDay 5:- 0\\nDay 6:- 0\\nDay 7:- 1 ( [9] )\\n\\nNow we will calculate the number of increasing days for every ith day:-\\nDay:-\\nDay 7:- 0\\nDay 6:- 0\\nDay 5:- 1 ( [9] )\\nDay 4: -2 ([8,9])\\nDay 3:- 3 ( [7,8,9] )\\nDay 2:- 0\\nDay 1:- 1 ( [5] )\\nDay 0:- 0\\n\\nWe can see that only the day-3 is a good day because there are three increasing and three decreasing days on this day.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        vector<int> dec(n,0),inc(n,0),ans;\\n        for(int i = 1;i<n;i++) if(arr[i]<=arr[i-1]) dec[i]+=dec[i-1]+1;\\n        for(int i = n-2;i>=0;i--) if(arr[i]<=arr[i+1]) inc[i]+=inc[i+1]+1;\\n        for(int i = 0;i<n;i++)\\n        if(dec[i]>=t && inc[i]>=t) ans.push_back(i);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119827,
                "title": "simple-java-o-n-two-iteration-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList<>();\\n        if (time == 0) {\\n            for (int i = 0; i < security.length; i++) res.add(i);\\n            return res;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        int count = 1;\\n        for (int i = 1; i < security.length; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (count > time) {\\n                set.add(i);\\n            }\\n        }\\n        \\n        count = 1;\\n        for (int i = security.length - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (count > time && set.contains(i)) res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList<>();\\n        if (time == 0) {\\n            for (int i = 0; i < security.length; i++) res.add(i);\\n            return res;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        int count = 1;\\n        for (int i = 1; i < security.length; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (count > time) {\\n                set.add(i);\\n            }\\n        }\\n        \\n        count = 1;\\n        for (int i = security.length - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (count > time && set.contains(i)) res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107182,
                "title": "c-prefix-suffix-consecutive-streaks-o-n-time-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int len = security.size();\\n        \\n        vector<int> leftCount(len, 0);\\n        for (int i = 1; i < len; i++) {\\n            if (security[i - 1] >= security[i]) {\\n                leftCount[i] += leftCount[i - 1] + 1;\\n            }\\n        }\\n        \\n        vector<int> rightCount(len);\\n        for (int i = len - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                rightCount[i] += rightCount[i + 1] + 1;\\n            }\\n        }\\n        \\n        vector<int> goodDayIndexes;\\n        for (int i = 0; i < len; i++) {\\n            if (leftCount[i] >= time && rightCount[i] >= time) {\\n                goodDayIndexes.push_back(i);\\n            }\\n        }\\n        \\n        return goodDayIndexes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int len = security.size();\\n        \\n        vector<int> leftCount(len, 0);\\n        for (int i = 1; i < len; i++) {\\n            if (security[i - 1] >= security[i]) {\\n                leftCount[i] += leftCount[i - 1] + 1;\\n            }\\n        }\\n        \\n        vector<int> rightCount(len);\\n        for (int i = len - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                rightCount[i] += rightCount[i + 1] + 1;\\n            }\\n        }\\n        \\n        vector<int> goodDayIndexes;\\n        for (int i = 0; i < len; i++) {\\n            if (leftCount[i] >= time && rightCount[i] >= time) {\\n                goodDayIndexes.push_back(i);\\n            }\\n        }\\n        \\n        return goodDayIndexes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981073,
                "title": "c-prefix-and-suffix-o-n-time-and-space",
                "content": "```\\n/* \\n    Time: O(n)\\n    Space: O(n)\\n    Tag: Array Manipulation, Prefix, Sufix manipilation\\n    Difficulty: MH\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int> &security, int time) {\\n        int n = security.size();\\n        vector<int> leftSide(n), righSide(n);\\n        leftSide[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (security[i - 1] >= security[i])\\n                leftSide[i] = leftSide[i - 1];\\n            else\\n                leftSide[i] = i;\\n        }\\n        righSide[n - 1] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i + 1] < security[i])\\n                righSide[i] = i;\\n            else\\n                righSide[i] = righSide[i + 1];\\n        }\\n        vector<int> res;\\n        for (int i = 0; i < n; i++) {\\n            if (leftSide[i] <= i - time && righSide[i] >= i + time) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\n/* \\n    Time: O(n)\\n    Space: O(n)\\n    Tag: Array Manipulation, Prefix, Sufix manipilation\\n    Difficulty: MH\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int> &security, int time) {\\n        int n = security.size();\\n        vector<int> leftSide(n), righSide(n);\\n        leftSide[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (security[i - 1] >= security[i])\\n                leftSide[i] = leftSide[i - 1];\\n            else\\n                leftSide[i] = i;\\n        }\\n        righSide[n - 1] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i + 1] < security[i])\\n                righSide[i] = i;\\n            else\\n                righSide[i] = righSide[i + 1];\\n        }\\n        vector<int> res;\\n        for (int i = 0; i < n; i++) {\\n            if (leftSide[i] <= i - time && righSide[i] >= i + time) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961522,
                "title": "javascript-iterative-o-n-time-o-n-space-91-time-54-space",
                "content": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    let decrease = [0];\\n    let increase = Array(security.length).fill(0);\\n    \\n    // Prefix\\n    for (let i = 1; i < security.length; i++) {\\n        if (security[i] <= security[i - 1]) decrease[i] = decrease[i - 1] + 1;\\n        else decrease[i] = 0;\\n    }\\n\\t\\n    // Suffix\\n    for (let j = security.length - 2; j >= 0; j--) {\\n        if (security[j] <= security[j + 1]) increase[j] = increase[j + 1] + 1;\\n        else increase[j] = 0;\\n    }\\n    \\n    let output = [];\\n    for (let k = 0; k < security.length; k++) {\\n        let left = decrease[k];\\n        let right = increase[k];\\n        if (left >= time && right >= time) output.push(k);\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    let decrease = [0];\\n    let increase = Array(security.length).fill(0);\\n    \\n    // Prefix\\n    for (let i = 1; i < security.length; i++) {\\n        if (security[i] <= security[i - 1]) decrease[i] = decrease[i - 1] + 1;\\n        else decrease[i] = 0;\\n    }\\n\\t\\n    // Suffix\\n    for (let j = security.length - 2; j >= 0; j--) {\\n        if (security[j] <= security[j + 1]) increase[j] = increase[j + 1] + 1;\\n        else increase[j] = 0;\\n    }\\n    \\n    let output = [];\\n    for (let k = 0; k < security.length; k++) {\\n        let left = decrease[k];\\n        let right = increase[k];\\n        if (left >= time && right >= time) output.push(k);\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842503,
                "title": "java-prefix-and-suffix-method-easy-to-read-code",
                "content": "![image](https://assets.leetcode.com/users/images/4d52bbc9-42ba-4595-831c-1f6bb9f099e2_1647090498.2979236.png)\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int n = arr.length;\\n// keep two arrays pre and post\\n// pre[i] and post[i] will have the start index of the streak uptill i\\n// streak for pre is until arr[i]<=arr[i-1] is followed\\n// streak for post is until arr[i]<=arr[i+1] is followed\\n        \\n// a day will be good day to rob the bank if\\n//1. pre[i-1]<=i-time i.e. streak is followed for i-time days.\\n//2. post[i+1]>=i+timr i.e. streak is followed for i+time days.\\n//3. arr[i]<=arr[i-1]&&arr[i]<=arr[i+1]\\n        \\n        \\n        int[]pre = new int[n];\\n        int[] post = new int[n];\\n        pre[0] = 0;\\n        \\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n                res.add(i);\\n            return res;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]<=arr[i-1])\\n                pre[i] = pre[i-1]; // prev streak continue\\n            else\\n            {\\n                // new streak start\\n                pre[i] = i;\\n            }\\n        }\\n        post[n-1] = n-1;\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]<=arr[i+1])\\n                post[i] = post[i+1]; // prev streak continue\\n            else\\n            {\\n                // new streak start\\n                post[i] = i;\\n            }\\n        }\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if((pre[i-1]<=i-time)&&(post[i+1]>=(i+time)&&(arr[i]<=arr[i-1])&&(arr[i]<=arr[i+1])))\\n                res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int n = arr.length;\\n// keep two arrays pre and post\\n// pre[i] and post[i] will have the start index of the streak uptill i\\n// streak for pre is until arr[i]<=arr[i-1] is followed\\n// streak for post is until arr[i]<=arr[i+1] is followed\\n        \\n// a day will be good day to rob the bank if\\n//1. pre[i-1]<=i-time i.e. streak is followed for i-time days.\\n//2. post[i+1]>=i+timr i.e. streak is followed for i+time days.\\n//3. arr[i]<=arr[i-1]&&arr[i]<=arr[i+1]\\n        \\n        \\n        int[]pre = new int[n];\\n        int[] post = new int[n];\\n        pre[0] = 0;\\n        \\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n                res.add(i);\\n            return res;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]<=arr[i-1])\\n                pre[i] = pre[i-1]; // prev streak continue\\n            else\\n            {\\n                // new streak start\\n                pre[i] = i;\\n            }\\n        }\\n        post[n-1] = n-1;\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]<=arr[i+1])\\n                post[i] = post[i+1]; // prev streak continue\\n            else\\n            {\\n                // new streak start\\n                post[i] = i;\\n            }\\n        }\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if((pre[i-1]<=i-time)&&(post[i+1]>=(i+time)&&(arr[i]<=arr[i-1])&&(arr[i]<=arr[i+1])))\\n                res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648599,
                "title": "20-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n=security.length;\\n        int prefix[]=new int[n],suffix[]=new int[n];\\n        prefix[0]=0;suffix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n            if(security[i-1]>=security[i])prefix[i]=prefix[i-1]+1;\\n            else prefix[i]=0;\\n        \\n        for(int i=n-2;i>=0;i--)\\n            if(security[i+1]>=security[i])suffix[i]=suffix[i+1]+1;\\n            else suffix[i]=0;\\n        \\n        List<Integer> res=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            if(prefix[i]>=time && suffix[i]>=time)res.add(i);\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n=security.length;\\n        int prefix[]=new int[n],suffix[]=new int[n];\\n        prefix[0]=0;suffix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n            if(security[i-1]>=security[i])prefix[i]=prefix[i-1]+1;\\n            else prefix[i]=0;\\n        \\n        for(int i=n-2;i>=0;i--)\\n            if(security[i+1]>=security[i])suffix[i]=suffix[i+1]+1;\\n            else suffix[i]=0;\\n        \\n        List<Integer> res=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            if(prefix[i]>=time && suffix[i]>=time)res.add(i);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1627838,
                "title": "java-easy-and-concise-sliding-window-o-n",
                "content": "Just find if there are two fixed sliding windows [i-time, i] and [i, i + time]\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList();\\n        int n = security.length, slow = 0;\\n        boolean[] left = new boolean[n]; // if there is a non-increasing sliding window start from [i - time, i]\\n        for(int i = 0; i < n; i++) {\\n            if(i == 0 || security[i] > security[i-1]) {  \\n                slow = i;\\n            } \\n            if(i - slow >= time) {\\n                left[i] = true;                \\n            }  \\n        }\\n        slow = n-1;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(i == n-1 || security[i] > security[i+1]) {  \\n                slow = i;\\n            } \\n            if(slow - i >= time && left[i]) {\\n                res.add(i);           \\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList();\\n        int n = security.length, slow = 0;\\n        boolean[] left = new boolean[n]; // if there is a non-increasing sliding window start from [i - time, i]\\n        for(int i = 0; i < n; i++) {\\n            if(i == 0 || security[i] > security[i-1]) {  \\n                slow = i;\\n            } \\n            if(i - slow >= time) {\\n                left[i] = true;                \\n            }  \\n        }\\n        slow = n-1;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(i == n-1 || security[i] > security[i+1]) {  \\n                slow = i;\\n            } \\n            if(slow - i >= time && left[i]) {\\n                res.add(i);           \\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625986,
                "title": "c-queue-vs-single-pass-4-pointers-vs-dp-solutions-compared-64ms-81mb",
                "content": "My first approach was to think of a queue before and one after our scanned day that in turn would reveal to us if the day was auspicious for a robbery or not.\\n\\nAnd thus I proceeded, first of all cutting a few edge cases out:\\n* if the time `t` is `0`, then each single element is valid and we can just overwrite `sec` with `iota` to be a succession of `sec.size()` elements starting from `0`, right before `return`ing it;\\n* conversely, if `t` was less than half `sec.size()`, no point in proceeding either, since we know already that no valid day can match our condition in terms of valid range, so we can just `return` an empty vector.\\n\\nWith that out of the table, we can focus on our core, general logic, declaring a few support variables:\\n* `len` will store the how many days we need to parse;\\n* `before` and `after` are aptly named queues which will store all the matching days as we progress;\\n* `res` is our accumulator variable where we will store our final result.\\n\\nTime to parse `sec`, using two pointers, `l` set to `0` and `m` set to `t` (that we increase now for convenience later); going on until `m < len`, and increasing them at each iteration, we will:\\n* reset `before` if it has at least one element and its last element is less then the one currently pointed by `l`;\\n* push said element (`sec[l]`) into `before`;\\n* specularly, reset `after` if it has at least one element and its last element is less then the one currently pointed by `m`;\\n* push said element (`sec[m]`) into `after`;\\n* check if the length of both `before` or `after` matches the current value of `t` (the original one, increased by `1`) and in case store the current index `m` into `res`, since we now know it\\'s a valid one;\\n* pop the front of `before` if its length is nw `t`;\\n* pop the front of `after` if its length is nw `t`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        queue<int> before, after;\\n        vector<int> res;\\n        // preparing before and after\\n        for (int l = 0, m = t++; m < len; l++, m++) {\\n            if (before.size() && before.back() < sec[l]) {\\n                before = queue<int> ();\\n            }\\n            before.push(sec[l]);\\n            if (after.size() && after.back() > sec[m]) {\\n                after = queue<int> ();\\n            }\\n            after.push(sec[m]);\\n            if (before.size() == t && after.size() == t) res.push_back(l);\\n            if (before.size() == t) before.pop();\\n            if (after.size() == t) after.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nDo we actually care if we have more than the minimum amount of valid days in front of us? Not at all, so we might risk sacrificing a bit more memory (but it does not seem to be the case, running a few test cases) and avoid popping altogether from either queue, in this slightly quicker version:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        queue<int> before, after;\\n        vector<int> res;\\n        // building before and after\\n        for (int l = 0, m = t++; m < len; l++, m++) {\\n            if (before.size() && before.back() < sec[l]) {\\n                before = queue<int> ();\\n            }\\n            before.push(sec[l]);\\n            if (after.size() && after.back() > sec[m]) {\\n                after = queue<int> ();\\n            }\\n            after.push(sec[m]);\\n            if (before.size() >= t && after.size() >= t) res.push_back(l);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, hey! Now that we put it this way, we do not even need to proceed with queues, since we would be just inserting elements in following the same order they have in `sec`; it might be much leaner and memory efficient if instead we rely on 4 pointers now, a pair each to delimit our `before` and `after` range, modifying the code like this and getting a crazy improvement (half the time, less than half the space!):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        vector<int> res;\\n        // updating before and after range pointers\\n        for (int i = 0, l = 0, j = t, m = t; m < len; l++, m++) {\\n            if (l && sec[l - 1] < sec[l]) {\\n                i = l;\\n            }\\n            if (sec[m - 1] > sec[m]) {\\n                j = m;\\n            }\\n            if (l - i >= t && m - j >= t) res.push_back(l);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNotice that this runs in just one pass, whereas we need at least two passes for a typical DP here; I tried to run it just for the sake of it and it was definitely a bit slower, since computing everything in advance and storing it was really not necessary.\\n\\nTo my surprise, the performance is basically the same as the solution above:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t >= sec.size()) return {};\\n        // support variables\\n        int len = sec.size() - 2 * t;\\n        bool before[len], after[len];\\n        fill(before, before + len, false);\\n        fill(after, after + len, false);\\n        vector<int> res;\\n        // preparing before and after\\n        for (int i = 0, currL = 0, j = sec.size() - 1, currR = 0; j >= t; i++, j--) {\\n            if (i && sec[i - 1] < sec[i]) currL = 0;\\n            if (currL++ >= t) before[i - t] = true;\\n            if (i && sec[j + 1] < sec[j]) currR = 0;\\n            if (currR++ >= t) after[j -  t] = true;\\n        }\\n        // populating res\\n        for (int i = 0, j = t; i < len; i++, j++) {\\n            if (before[i] && after[i]) res.push_back(j);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        queue<int> before, after;\\n        vector<int> res;\\n        // preparing before and after\\n        for (int l = 0, m = t++; m < len; l++, m++) {\\n            if (before.size() && before.back() < sec[l]) {\\n                before = queue<int> ();\\n            }\\n            before.push(sec[l]);\\n            if (after.size() && after.back() > sec[m]) {\\n                after = queue<int> ();\\n            }\\n            after.push(sec[m]);\\n            if (before.size() == t && after.size() == t) res.push_back(l);\\n            if (before.size() == t) before.pop();\\n            if (after.size() == t) after.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        queue<int> before, after;\\n        vector<int> res;\\n        // building before and after\\n        for (int l = 0, m = t++; m < len; l++, m++) {\\n            if (before.size() && before.back() < sec[l]) {\\n                before = queue<int> ();\\n            }\\n            before.push(sec[l]);\\n            if (after.size() && after.back() > sec[m]) {\\n                after = queue<int> ();\\n            }\\n            after.push(sec[m]);\\n            if (before.size() >= t && after.size() >= t) res.push_back(l);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        vector<int> res;\\n        // updating before and after range pointers\\n        for (int i = 0, l = 0, j = t, m = t; m < len; l++, m++) {\\n            if (l && sec[l - 1] < sec[l]) {\\n                i = l;\\n            }\\n            if (sec[m - 1] > sec[m]) {\\n                j = m;\\n            }\\n            if (l - i >= t && m - j >= t) res.push_back(l);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t >= sec.size()) return {};\\n        // support variables\\n        int len = sec.size() - 2 * t;\\n        bool before[len], after[len];\\n        fill(before, before + len, false);\\n        fill(after, after + len, false);\\n        vector<int> res;\\n        // preparing before and after\\n        for (int i = 0, currL = 0, j = sec.size() - 1, currR = 0; j >= t; i++, j--) {\\n            if (i && sec[i - 1] < sec[i]) currL = 0;\\n            if (currL++ >= t) before[i - t] = true;\\n            if (i && sec[j + 1] < sec[j]) currR = 0;\\n            if (currR++ >= t) after[j -  t] = true;\\n        }\\n        // populating res\\n        for (int i = 0, j = t; i < len; i++, j++) {\\n            if (before[i] && after[i]) res.push_back(j);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623966,
                "title": "java-soluton-with-explanation-easy-to-understand-happycoding",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer>  res = new ArrayList<>();\\n        if(security == null || security.length == 0) return res;\\n        int n = security.length;\\n        \\n        // do preparations to save checking time\\n        // Store how many numbers larger than current number on the left side\\n        int[] largerCountOnLeft = new int[n];        \\n        int leftCount = 0;        \\n        for(int i = 1; i < n; i++){\\n             if(security[i] <= security[i-1]){\\n                  leftCount++;\\n                  largerCountOnLeft[i] = leftCount;\\n             }else{\\n                 leftCount = 0;\\n             }\\n        }\\n        \\n        // Store how many numbers larger than current number on the right side\\n        int[] largerCountOnRight = new int[n];\\n        int rightCount = 0;\\n        for(int i = n-2; i >= 0; i--){\\n             if(security[i] <= security[i+1]){\\n                  rightCount++;\\n                  largerCountOnRight[i] = rightCount;\\n             }else{\\n                  rightCount = 0;\\n             }\\n        }\\n        \\n        \\n        // check if current number is lowest than right and left and both sides has time+ numbers larger than current number\\n        for(int i = time; i < n - time; i++){\\n            if(largerCountOnLeft[i] >= time && largerCountOnRight[i] >= time){\\n                res.add(i);\\n            }             \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer>  res = new ArrayList<>();\\n        if(security == null || security.length == 0) return res;\\n        int n = security.length;\\n        \\n        // do preparations to save checking time\\n        // Store how many numbers larger than current number on the left side\\n        int[] largerCountOnLeft = new int[n];        \\n        int leftCount = 0;        \\n        for(int i = 1; i < n; i++){\\n             if(security[i] <= security[i-1]){\\n                  leftCount++;\\n                  largerCountOnLeft[i] = leftCount;\\n             }else{\\n                 leftCount = 0;\\n             }\\n        }\\n        \\n        // Store how many numbers larger than current number on the right side\\n        int[] largerCountOnRight = new int[n];\\n        int rightCount = 0;\\n        for(int i = n-2; i >= 0; i--){\\n             if(security[i] <= security[i+1]){\\n                  rightCount++;\\n                  largerCountOnRight[i] = rightCount;\\n             }else{\\n                  rightCount = 0;\\n             }\\n        }\\n        \\n        \\n        // check if current number is lowest than right and left and both sides has time+ numbers larger than current number\\n        for(int i = time; i < n - time; i++){\\n            if(largerCountOnLeft[i] >= time && largerCountOnRight[i] >= time){\\n                res.add(i);\\n            }             \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623636,
                "title": "c-prefix-suffix-array-self-explanatory-0-n-solution",
                "content": "```\\n`vector<int> goodDaysToRobBank(vector<int>& a, int t) {\\n        int n=a.size();\\n        int b[n],c[n];\\n        b[0]=0;\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                b[i]=b[i-1]+1;\\n            }\\n            else{\\n                b[i]=0;\\n            }\\n        }\\n        c[0]=0;\\n        for(int i=1;i<n;i++){\\n            if(a[i]>=a[i-1]){\\n                c[i]=c[i-1]+1;\\n            }\\n            else{\\n                c[i]=0;\\n            }\\n        }\\n        vector<int> v;\\n        for(int i=t;i<n-t;i++){\\n            if(b[i]>=t&&c[i+t]>=t){\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n\\n``",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n`vector<int> goodDaysToRobBank(vector<int>& a, int t) {\\n        int n=a.size();\\n        int b[n],c[n];\\n        b[0]=0;\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                b[i]=b[i-1]+1;\\n            }\\n            else{\\n                b[i]=0;\\n            }\\n        }\\n        c[0]=0;\\n        for(int i=1;i<n;i++){\\n            if(a[i]>=a[i-1]){\\n                c[i]=c[i-1]+1;\\n            }\\n            else{\\n                c[i]=0;\\n            }\\n        }\\n        vector<int> v;\\n        for(int i=t;i<n-t;i++){\\n            if(b[i]>=t&&c[i+t]>=t){\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1623367,
                "title": "sliding-window-c",
                "content": "The idea is:\\n1 if the last day is a good day, only two day need to be checked\\n2 if the last day is not a good day, calculate it by check the decrease and increase condition\\n\\n    bool isGoodDay(vector<int>& security, int time, int day)\\n    {\\n        for(int i = day - time + 1; i <= day; i++)\\n        {\\n            if(security[i] > security[i-1]) return false;\\n        }\\n        for(int i = day + 1; i <= day + time; i++)\\n        {\\n            if(security[i] < security[i-1]) return false;\\n        }\\n        return true;\\n    }\\n\\t\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> ans;\\n        int n = security.size();\\n        if(time == 0) \\n        {\\n            for(int i = 0; i < n; i++) ans.push_back(i);\\n            return ans;\\n        }\\n        if(n < 3) return ans;\\n        bool isPreGoodDay = false;\\n        for(int i = time; i < n - time; i++){\\n            if(!isPreGoodDay){\\n                if(isGoodDay(security,time,i)){\\n                   ans.push_back(i);\\n                   isPreGoodDay = true;\\n               }\\n            }\\n            else {\\n               if(security[i] <= security[i-1]  && security[i + time] >= security[i + time - 1] ){\\n                   ans.push_back(i);\\n               }\\n                else isPreGoodDay = false;\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "The idea is:\\n1 if the last day is a good day, only two day need to be checked\\n2 if the last day is not a good day, calculate it by check the decrease and increase condition\\n\\n    bool isGoodDay(vector<int>& security, int time, int day)\\n    {\\n        for(int i = day - time + 1; i <= day; i++)\\n        {\\n            if(security[i] > security[i-1]) return false;\\n        }\\n        for(int i = day + 1; i <= day + time; i++)\\n        {\\n            if(security[i] < security[i-1]) return false;\\n        }\\n        return true;\\n    }\\n\\t\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> ans;\\n        int n = security.size();\\n        if(time == 0) \\n        {\\n            for(int i = 0; i < n; i++) ans.push_back(i);\\n            return ans;\\n        }\\n        if(n < 3) return ans;\\n        bool isPreGoodDay = false;\\n        for(int i = time; i < n - time; i++){\\n            if(!isPreGoodDay){\\n                if(isGoodDay(security,time,i)){\\n                   ans.push_back(i);\\n                   isPreGoodDay = true;\\n               }\\n            }\\n            else {\\n               if(security[i] <= security[i-1]  && security[i + time] >= security[i + time - 1] ){\\n                   ans.push_back(i);\\n               }\\n                else isPreGoodDay = false;\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3931272,
                "title": "sliding-window-approach-in-java",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) [Though queue size is TIME but the arrays of size N is used to store valid days index]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int n = security.length;\\n        List<Integer> arr = new ArrayList<>();\\n        if(time>=n) {return arr;}\\n        // add the window of size time elements in deque which are in decreased form\\n        for(int i=0;i<(time);i++) {\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        // get the valid days whose left side elements are in decreased form in size time\\n        int left[] = getLeftValidDays(security, time, deque);\\n    \\n        deque = new ArrayDeque<>();\\n        //add the window of size time elements in deque which are in increased form\\n        for(int i=n-1;i>n-1-time;i--) {\\n             while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        // get the valid days whose right side elements are in increased form in size time\\n        int right[] = getRightValidDays(security, time, deque);\\n\\n        // check if both left days & right days of that element are valid . If yes then add in list\\n        for(int i=time;i<=n-1-time;i++) {\\n            if((left[i]*right[i])==1) {\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    private int[] getLeftValidDays(int security[], int time, Deque<Integer> deque) {\\n        int n = security.length;\\n        int left[] = new int[n];\\n        Arrays.fill(left, 0);\\n        \\n        for(int i=time;i<=(n-1-time);i++) {\\n            int validIndexRange = i-time;\\n            while(deque.size()>0 && deque.peekFirst()<validIndexRange) {\\n                deque.removeFirst();\\n            }\\n            if((time==0) || (deque.size()==time && security[deque.peekLast()]>=security[i])) {\\n                left[i] = 1;\\n            }\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        return left;\\n    }\\n\\n    private int[] getRightValidDays(int security[], int time, Deque<Integer> deque) {\\n\\n        int n = security.length;\\n        int right[] = new int[n];\\n        Arrays.fill(right, 0);\\n\\n        for(int i= n-1-time; i>=time;i--) {\\n            int validIndexRange = i+time;\\n            while(deque.size()>0 && deque.peekFirst()>validIndexRange) {\\n                deque.removeFirst();\\n            }\\n            if((time==0 ) || (security[deque.peekLast()]>=security[i] && deque.size()==time) ){\\n                right[i] = 1;\\n            }\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        return right;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int n = security.length;\\n        List<Integer> arr = new ArrayList<>();\\n        if(time>=n) {return arr;}\\n        // add the window of size time elements in deque which are in decreased form\\n        for(int i=0;i<(time);i++) {\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        // get the valid days whose left side elements are in decreased form in size time\\n        int left[] = getLeftValidDays(security, time, deque);\\n    \\n        deque = new ArrayDeque<>();\\n        //add the window of size time elements in deque which are in increased form\\n        for(int i=n-1;i>n-1-time;i--) {\\n             while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        // get the valid days whose right side elements are in increased form in size time\\n        int right[] = getRightValidDays(security, time, deque);\\n\\n        // check if both left days & right days of that element are valid . If yes then add in list\\n        for(int i=time;i<=n-1-time;i++) {\\n            if((left[i]*right[i])==1) {\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    private int[] getLeftValidDays(int security[], int time, Deque<Integer> deque) {\\n        int n = security.length;\\n        int left[] = new int[n];\\n        Arrays.fill(left, 0);\\n        \\n        for(int i=time;i<=(n-1-time);i++) {\\n            int validIndexRange = i-time;\\n            while(deque.size()>0 && deque.peekFirst()<validIndexRange) {\\n                deque.removeFirst();\\n            }\\n            if((time==0) || (deque.size()==time && security[deque.peekLast()]>=security[i])) {\\n                left[i] = 1;\\n            }\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        return left;\\n    }\\n\\n    private int[] getRightValidDays(int security[], int time, Deque<Integer> deque) {\\n\\n        int n = security.length;\\n        int right[] = new int[n];\\n        Arrays.fill(right, 0);\\n\\n        for(int i= n-1-time; i>=time;i--) {\\n            int validIndexRange = i+time;\\n            while(deque.size()>0 && deque.peekFirst()>validIndexRange) {\\n                deque.removeFirst();\\n            }\\n            if((time==0 ) || (security[deque.peekLast()]>=security[i] && deque.size()==time) ){\\n                right[i] = 1;\\n            }\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        return right;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833331,
                "title": "java-5ms-solution-o-n-time-complexity-and-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> list = new ArrayList<>();\\n        int n=security.length;\\n        int dpbef[]=new int[n];\\n        int dpaft[]=new int[n];\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n               dpbef[i]=dpbef[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n               dpaft[i]=dpaft[i+1]+1;\\n            }\\n        }\\n        for(int i=time;i<=n-time && i<n;i++){\\n            if(dpbef[i]>=time && dpaft[i]>=time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> list = new ArrayList<>();\\n        int n=security.length;\\n        int dpbef[]=new int[n];\\n        int dpaft[]=new int[n];\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n               dpbef[i]=dpbef[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n               dpaft[i]=dpaft[i+1]+1;\\n            }\\n        }\\n        for(int i=time;i<=n-time && i<n;i++){\\n            if(dpbef[i]>=time && dpaft[i]>=time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613520,
                "title": "java-solution-with-explanation",
                "content": "# Intuition\\nIn this type of questions, we need to think what is happening at every index and what is repeating.\\nAt every index we need to find whether in left their is decreasing and in right there is increasing or not.\\nSo instead of calculating every time we store the length of decreasing and increasing in 2 auxilliary array, and using this 2 array as lookup to find which index is safe.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for(int i = 1; i < n; i++){\\n            if(security[i-1] >= security[i]){\\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            if(security[i] <= security[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for(int i = 1; i < n; i++){\\n            if(security[i-1] >= security[i]){\\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            if(security[i] <= security[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087204,
                "title": "python-straightforward-o-n-solution-beats-80",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        N = len(security)\\n        if time == 0:\\n            return [i for i in range(N)]\\n        \\n        \"\"\"\\n        example: [5,3,3,3,5,6,2]\\n        non_increasing_counts = [0, 1, 2, 3, 0, 0, 1]\\n        non_decreasing_counts = [0, 4, 3, 2, 1, 0, 0]\\n        \"\"\"\\n\\n        non_increasing_counts = [0] * N\\n        non_decreasing_counts = [0] * N\\n        # recording the days **before**, so we accumulate the count from the start\\n        for i in range(1, N):\\n            if security[i] <= security[i - 1]:\\n                non_increasing_counts[i] = non_increasing_counts[i - 1] + 1\\n\\n        # recording the days **after**, so we accumulate the count from the end\\n        for i in range(N - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                non_decreasing_counts[i] = non_decreasing_counts[i + 1] + 1\\n        \\n        res = []\\n        for i in range(N):\\n            if non_increasing_counts[i] >= time and non_decreasing_counts[i] >= time:\\n                res.append(i)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        N = len(security)\\n        if time == 0:\\n            return [i for i in range(N)]\\n        \\n        \"\"\"\\n        example: [5,3,3,3,5,6,2]\\n        non_increasing_counts = [0, 1, 2, 3, 0, 0, 1]\\n        non_decreasing_counts = [0, 4, 3, 2, 1, 0, 0]\\n        \"\"\"\\n\\n        non_increasing_counts = [0] * N\\n        non_decreasing_counts = [0] * N\\n        # recording the days **before**, so we accumulate the count from the start\\n        for i in range(1, N):\\n            if security[i] <= security[i - 1]:\\n                non_increasing_counts[i] = non_increasing_counts[i - 1] + 1\\n\\n        # recording the days **after**, so we accumulate the count from the end\\n        for i in range(N - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                non_decreasing_counts[i] = non_decreasing_counts[i + 1] + 1\\n        \\n        res = []\\n        for i in range(N):\\n            if non_increasing_counts[i] >= time and non_decreasing_counts[i] >= time:\\n                res.append(i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638063,
                "title": "95-time-beats-80-space-beats-c-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size(),i;\\n        vector<int> in(n,1),de(n,1),ans;\\n        for(i = 1; i < n; i++){\\n            if(arr[i]<=arr[i-1]){\\n                in[i] += in[i-1];\\n            }\\n        }\\n        for(i = n-2; i >= 0; i--){\\n            if(arr[i]<=arr[i+1]){\\n                de[i] += de[i+1];\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(in[i]>time && de[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        // for(auto &i: in)cout<<i<<\" \";\\n        // cout<<endl;\\n        // for(auto &i: de)cout<<i<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size(),i;\\n        vector<int> in(n,1),de(n,1),ans;\\n        for(i = 1; i < n; i++){\\n            if(arr[i]<=arr[i-1]){\\n                in[i] += in[i-1];\\n            }\\n        }\\n        for(i = n-2; i >= 0; i--){\\n            if(arr[i]<=arr[i+1]){\\n                de[i] += de[i+1];\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(in[i]>time && de[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        // for(auto &i: in)cout<<i<<\" \";\\n        // cout<<endl;\\n        // for(auto &i: de)cout<<i<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2627392,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Precalculate***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // left[i] will store the length of increasing subarray including arr[i] on left side\\n        \\n        vector<int> left(n, 1);\\n        \\n        // fill left array\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i] <= arr[i - 1])\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        \\n        // right[i] will store the length of increasing subarray including arr[i] on right side\\n        \\n        vector<int> right(n, 1);\\n        \\n        // fill right array\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(arr[i] <= arr[i + 1])\\n            {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        \\n        // push the possible index into res\\n        \\n        vector<int> res;\\n        \\n        for(int i = k; i <= n - k - 1; i++)\\n        {\\n            if(left[i] >= k + 1 && right[i] >= k + 1)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // left[i] will store the length of increasing subarray including arr[i] on left side\\n        \\n        vector<int> left(n, 1);\\n        \\n        // fill left array\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i] <= arr[i - 1])\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        \\n        // right[i] will store the length of increasing subarray including arr[i] on right side\\n        \\n        vector<int> right(n, 1);\\n        \\n        // fill right array\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(arr[i] <= arr[i + 1])\\n            {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        \\n        // push the possible index into res\\n        \\n        vector<int> res;\\n        \\n        for(int i = k; i <= n - k - 1; i++)\\n        {\\n            if(left[i] >= k + 1 && right[i] >= k + 1)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615886,
                "title": "python-prefix",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        decreasing = [1] * len(security)\\n        \\n        count = 0\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i - 1]:\\n                count += 1\\n            else:\\n                count = 0\\n            decreasing[i] = count\\n        \\n        increasing = [0] * len(security)\\n        increasing[-1] = 1\\n        count = 0\\n        for i in range(len(security) - 2 , -1, -1):\\n            if security[i] <= security[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n            increasing[i] = count\\n        res = []\\n        \\n        for i in range(time, len(security) - time):\\n            if increasing[i] >= time and decreasing[i] >= time:\\n                res.append(i)\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        decreasing = [1] * len(security)\\n        \\n        count = 0\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i - 1]:\\n                count += 1\\n            else:\\n                count = 0\\n            decreasing[i] = count\\n        \\n        increasing = [0] * len(security)\\n        increasing[-1] = 1\\n        count = 0\\n        for i in range(len(security) - 2 , -1, -1):\\n            if security[i] <= security[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n            increasing[i] = count\\n        res = []\\n        \\n        for i in range(time, len(security) - time):\\n            if increasing[i] >= time and decreasing[i] >= time:\\n                res.append(i)\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2598528,
                "title": "python-o-n-compact-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if not security or time < 0:\\n            return []\\n        \\n        n = len(security)\\n        left, right = [0] * n, [0] * n\\n        left[0], right[-1] = 0, 0\\n        \\n        # build 2 arrays where:\\n        # left contains the count of non-increasing elements for certain idx\\n        # right count of non-decreasing for certain idx\\n        for i, j in zip(range(1, n), reversed(range(0, n-1))):\\n            left[i] = left[i-1] + 1 if security[i] <= security[i - 1] else 0\\n            right[j] = right[j+1] + 1 if security[j] <= security[j + 1] else 0\\n               \\n        # filter out those days which match the requirement\\n        return [day for day in range(n) if left[day] >= time and right[day] >= time]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if not security or time < 0:\\n            return []\\n        \\n        n = len(security)\\n        left, right = [0] * n, [0] * n\\n        left[0], right[-1] = 0, 0\\n        \\n        # build 2 arrays where:\\n        # left contains the count of non-increasing elements for certain idx\\n        # right count of non-decreasing for certain idx\\n        for i, j in zip(range(1, n), reversed(range(0, n-1))):\\n            left[i] = left[i-1] + 1 if security[i] <= security[i - 1] else 0\\n            right[j] = right[j+1] + 1 if security[j] <= security[j + 1] else 0\\n               \\n        # filter out those days which match the requirement\\n        return [day for day in range(n) if left[day] >= time and right[day] >= time]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514965,
                "title": "c-prefix-suffix-easy-o-n-dynamic-programming-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        //jai shri ram\\n        int n=security.size();\\n        vector<int>pre(n,0),suff(n,0),ans;\\n        for(int i=0;i<n;i++){\\n            if(i!=0 && security[i]<=security[i-1]) pre[i]+=pre[i-1]+1;\\n            else pre[i]=1;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i!=n-1 && security[i]<=security[i+1]) suff[i]+=suff[i+1]+1;\\n            else suff[i]=1;\\n        }\\n        if(time==0) ans.push_back(0);\\n        for(int i=1;i<n-1;i++){\\n            if(pre[i]>time && suff[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        if(n>1 && time==0) ans.push_back(n-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        //jai shri ram\\n        int n=security.size();\\n        vector<int>pre(n,0),suff(n,0),ans;\\n        for(int i=0;i<n;i++){\\n            if(i!=0 && security[i]<=security[i-1]) pre[i]+=pre[i-1]+1;\\n            else pre[i]=1;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i!=n-1 && security[i]<=security[i+1]) suff[i]+=suff[i+1]+1;\\n            else suff[i]=1;\\n        }\\n        if(time==0) ans.push_back(0);\\n        for(int i=1;i<n-1;i++){\\n            if(pre[i]>time && suff[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        if(n>1 && time==0) ans.push_back(n-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421202,
                "title": "two-pass-solution-with-prefix-and-suffix-array",
                "content": "First pass store the prefix and suffix count of continuous increasing/decresing elements. \\nSecond pass check for the time condition and fill the indexes to result array\\n```\\n    vector<int> goodDaysToRobBank(vector<int>& S, int T) {\\n        int n = S.size();\\n        vector<int> res, L(n, 0), R(n, 0);\\n        for(int i=1 ; i < n-1; i++) {\\n            int j = n - (i + 1);\\n            if (S[i-1] >= S[i])  L[i] = L[i-1]+1;\\n            if (S[j] <= S[j+1]) R[j] = R[j+1]+1;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(L[i] >= T && R[i] >= T) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> goodDaysToRobBank(vector<int>& S, int T) {\\n        int n = S.size();\\n        vector<int> res, L(n, 0), R(n, 0);\\n        for(int i=1 ; i < n-1; i++) {\\n            int j = n - (i + 1);\\n            if (S[i-1] >= S[i])  L[i] = L[i-1]+1;\\n            if (S[j] <= S[j+1]) R[j] = R[j+1]+1;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(L[i] >= T && R[i] >= T) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346021,
                "title": "c-prefix-suffix-sum-easy-to-understand-fast",
                "content": "```\\n vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n= security.size();\\n        vector<int> st(n),end(n),ans;\\n        st[0]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                st[i]=st[i-1]+1;\\n            }\\n            else{\\n                st[i]=0;\\n            }\\n        }\\n        \\n        end[n-1]=0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                end[i]=end[i+1]+1;\\n            }\\n            else{\\n                end[i]=0;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(st[i]>= time && end[i]>= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\n vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n= security.size();\\n        vector<int> st(n),end(n),ans;\\n        st[0]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                st[i]=st[i-1]+1;\\n            }\\n            else{\\n                st[i]=0;\\n            }\\n        }\\n        \\n        end[n-1]=0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                end[i]=end[i+1]+1;\\n            }\\n            else{\\n                end[i]=0;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(st[i]>= time && end[i]>= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2340246,
                "title": "c-prefix-sum-very-easy-code-80-faster",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> left(n,0),right(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i-1]>=security[i])\\n                left[i]=left[i-1]+1;// stores number of good days before the current day\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i+1]>=security[i])\\n                right[i]=right[i+1]+1;// stores number of good days before the current day\\n        }\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]>=time && right[i]>=time)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> left(n,0),right(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i-1]>=security[i])\\n                left[i]=left[i-1]+1;// stores number of good days before the current day\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i+1]>=security[i])\\n                right[i]=right[i+1]+1;// stores number of good days before the current day\\n        }\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]>=time && right[i]>=time)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305339,
                "title": "c-easy-to-understand-prefix-suffix",
                "content": "```\\n    vector<int> goodDaysToRobBank(vector<int>& security, int t) {\\n        int n=security.size();\\n        vector<int>prefix(n),suffix(n);\\n        prefix[0]=0;\\n        suffix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                prefix[i]=prefix[i-1]+1; \\n            }\\n            else{\\n                prefix[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1]){\\n                suffix[i]=suffix[i+1]+1;\\n            }\\n            else{\\n                suffix[i]=0;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(suffix[i]>=t && prefix[i]>=t){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n    vector<int> goodDaysToRobBank(vector<int>& security, int t) {\\n        int n=security.size();\\n        vector<int>prefix(n),suffix(n);\\n        prefix[0]=0;\\n        suffix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                prefix[i]=prefix[i-1]+1; \\n            }\\n            else{\\n                prefix[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1]){\\n                suffix[i]=suffix[i+1]+1;\\n            }\\n            else{\\n                suffix[i]=0;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(suffix[i]>=t && prefix[i]>=t){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264664,
                "title": "c-array-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        int cnt = 0;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        \\n        for(int i = 1; i < n; i++){\\n            if(security[i] <= security[i - 1])\\n                cnt++;\\n            else\\n                cnt = 0;\\n            \\n            left[i] = cnt;\\n        }\\n        \\n        cnt = 0;\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            if(security[i] <= security[i+1])\\n                cnt++;\\n            else\\n                cnt = 0;\\n            \\n            right[i] = cnt;\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0;i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        int cnt = 0;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        \\n        for(int i = 1; i < n; i++){\\n            if(security[i] <= security[i - 1])\\n                cnt++;\\n            else\\n                cnt = 0;\\n            \\n            left[i] = cnt;\\n        }\\n        \\n        cnt = 0;\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            if(security[i] <= security[i+1])\\n                cnt++;\\n            else\\n                cnt = 0;\\n            \\n            right[i] = cnt;\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0;i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201798,
                "title": "java-easy-explaination-prefix-suffix-appoach-solved",
                "content": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] s, int time) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int n = s.length;\\n        \\n        int[] a = new int[n];\\n        int[] b = new int[n];\\n        for(int i=1;i<n;i++){\\n            if(s[i]<=s[i-1]){\\n                a[i] = 1 + a[i-1] ;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]<=s[i+1]){\\n                b[i] = 1 + b[i+1];\\n            }\\n        }\\n        \\n        for(int i=time;i<n-time;i++){\\n            if(a[i]>=time && b[i]>=time){\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] s, int time) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int n = s.length;\\n        \\n        int[] a = new int[n];\\n        int[] b = new int[n];\\n        for(int i=1;i<n;i++){\\n            if(s[i]<=s[i-1]){\\n                a[i] = 1 + a[i-1] ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2194732,
                "title": "c-simple-prefix-and-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int>res;\\n        int n=security.size();\\n        vector<int>left(n,0),right(n,0);\\n        for(int i=1;i<n;i++){\\n            if(security[i]<=security[i-1])left[i]=1+left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i])right[i]=1+right[i+1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(left[i]>=time && right[i]>=time)res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int>res;\\n        int n=security.size();\\n        vector<int>left(n,0),right(n,0);\\n        for(int i=1;i<n;i++){\\n            if(security[i]<=security[i-1])left[i]=1+left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i])right[i]=1+right[i+1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(left[i]>=time && right[i]>=time)res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193544,
                "title": "java-easy-solution-prefix-array",
                "content": "\\tclass Solution {\\n\\t\\t/*\\n\\t\\tStore A Prefix Array With The Following Condition\\n\\t\\tsecurity[i - time] >= security[i - time + 1] >= ...\\n\\t\\t>= security[i]\\n\\t\\t<= ... <= security[i + time - 1] <= security[i + time]\\n\\t\\t */\\n\\t\\tpublic static List<Integer> goodDaysToRobBank(int[] security, int time) {\\n\\t\\t\\tint n = security.length;\\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tint[] prefLeft = new int[n];\\n\\t\\t\\tint[] prefRight = new int[n];\\n\\n\\t\\t\\t// Count the length of non-increasing elements to the left\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tif (security[i] <= security[i - 1])\\n\\t\\t\\t\\t\\tprefLeft[i] = prefLeft[i - 1] + 1;\\n\\t\\t\\t}\\n\\t\\t\\t// Count the length of non-decreasing elements to the right\\n\\t\\t\\tfor (int i = n - 2; i >= 0; --i) {\\n\\t\\t\\t\\tif (security[i] <= security[i + 1])\\n\\t\\t\\t\\t\\tprefRight[i] = prefRight[i + 1] + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Insert all the indexes that satisfy the condition\\n\\t\\t\\tfor (int i = time; i < n - time; i++) {\\n\\t\\t\\t\\tif (prefLeft[i] >= time && prefRight[i] >= time)\\n\\t\\t\\t\\t\\tans.add(i);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t/*\\n\\t\\tStore A Prefix Array With The Following Condition\\n\\t\\tsecurity[i - time] >= security[i - time + 1] >= ...\\n\\t\\t>= security[i]\\n\\t\\t<= ... <= security[i + time - 1] <= security[i + time]\\n\\t\\t */\\n\\t\\tpublic static List<Integer> goodDaysToRobBank(int[] security, int time) {\\n\\t\\t\\tint n = security.length;\\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tint[] prefLeft = new int[n];\\n\\t\\t\\tint[] prefRight = new int[n];\\n\\n\\t\\t\\t// Count the length of non-increasing elements to the left\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tif (security[i] <= security[i - 1])\\n\\t\\t\\t\\t\\tprefLeft[i] = prefLeft[i - 1] + 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2161847,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, A, t):\\n        n = len(A)\\n        def incGaurd(A):\\n            arr = [0] * n\\n            for i in range(1,n):\\n                if A[i-1] >= A[i]:\\n                    arr[i] = arr[i-1] + 1\\n            return arr\\n        _inc,_dec = incGaurd(A),incGaurd(A[::-1])[::-1]\\n        ans = []\\n        for i in range(n):\\n            if _inc[i] >= t and _dec[i] >= t:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, A, t):\\n        n = len(A)\\n        def incGaurd(A):\\n            arr = [0] * n\\n            for i in range(1,n):\\n                if A[i-1] >= A[i]:\\n                    arr[i] = arr[i-1] + 1\\n            return arr\\n        _inc,_dec = incGaurd(A),incGaurd(A[::-1])[::-1]\\n        ans = []\\n        for i in range(n):\\n            if _inc[i] >= t and _dec[i] >= t:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057968,
                "title": "python-linear-with-keeping-track-of-sequence-length-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\n        # cover edge cases to simplify algorithm\\n        if time == 0:\\n            return [i for i in range(len(security))]\\n        \\n        if 2*time >= len(security):\\n            return []\\n        \\n        # go days one by one while keeping track of the days sequence length before and after current days\\n        before = 0\\n        after = 0\\n        good_days = []\\n        for idx in range(1, len(security) - time):\\n            # count good days sequence lenght before the current day\\n            before = before + 1 if security[idx-1] >= security[idx] else 0\\n            # count good days sequence lenght after the current day\\n            after = after + 1 if security[idx+time-1] <= security[idx+time] else 0\\n                \\n            if idx >= time and before >= time and after >= time:\\n                good_days.append(idx)\\n            \\n        return good_days\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\n        # cover edge cases to simplify algorithm\\n        if time == 0:\\n            return [i for i in range(len(security))]\\n        \\n        if 2*time >= len(security):\\n            return []\\n        \\n        # go days one by one while keeping track of the days sequence length before and after current days\\n        before = 0\\n        after = 0\\n        good_days = []\\n        for idx in range(1, len(security) - time):\\n            # count good days sequence lenght before the current day\\n            before = before + 1 if security[idx-1] >= security[idx] else 0\\n            # count good days sequence lenght after the current day\\n            after = after + 1 if security[idx+time-1] <= security[idx+time] else 0\\n                \\n            if idx >= time and before >= time and after >= time:\\n                good_days.append(idx)\\n            \\n        return good_days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971538,
                "title": "c-simple-very-easy-solution",
                "content": "\\tpublic:\\n\\t\\tvector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n = security.size();\\n        vector<int>lft_non_inc(n, 0);\\n        vector<int>rht_non_dec(n, 0);\\n        vector<int>ans;\\n        \\n        for(int i=1;i<n;i++)\\n            if(security[i] <= security[i-1])\\n                lft_non_inc[i] = 1 + lft_non_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(security[i] <= security[i+1])\\n                rht_non_dec[i] = 1 + rht_non_dec[i+1];\\n        \\n        for(int i=time;i<n-time;i++)\\n            if(rht_non_dec[i] >= time && lft_non_inc[i] >= time)\\n                ans.push_back(i);\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tpublic:\\n\\t\\tvector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n = security.size();\\n        vector<int>lft_non_inc(n, 0);\\n        vector<int>rht_non_dec(n, 0);\\n        vector<int>ans;\\n        \\n        for(int i=1;i<n;i++)\\n            if(security[i] <= security[i-1])\\n                lft_non_inc[i] = 1 + lft_non_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(security[i] <= security[i+1])\\n                rht_non_dec[i] = 1 + rht_non_dec[i+1];\\n        \\n        for(int i=time;i<n-time;i++)\\n            if(rht_non_dec[i] >= time && lft_non_inc[i] >= time)\\n                ans.push_back(i);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1967736,
                "title": "python-o-n-solution-beats-90-pre-computation",
                "content": "\\tclass Solution:\\n\\t\\tdef goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\t\\t\\tif time == 0:\\n\\t\\t\\t\\treturn [i for i in range(len(security))]\\n\\t\\t\\tn = len(security)\\n\\t\\t\\tleft = [0 for i in range(n)]\\n\\t\\t\\tright = [0 for i in range(n)]\\n\\t\\t\\tfor i in range(n-2, -1, -1):\\n\\t\\t\\t\\tif security[i] >= security[i+1]:\\n\\t\\t\\t\\t\\tleft[i] = 1 + left[i+1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft[i] = 0\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tif security[i] >= security[i-1]:\\n\\t\\t\\t\\t\\tright[i] = 1 + right[i-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tright[i] = 0\\n\\t\\t\\tans = []\\n\\t\\t\\tfor i in range(time, n-time):\\n\\t\\t\\t\\tif left[i-time] >= time and right[i+time] >= time:\\n\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\t\\t\\tif time == 0:\\n\\t\\t\\t\\treturn [i for i in range(len(security))]\\n\\t\\t\\tn = len(security)\\n\\t\\t\\tleft = [0 for i in range(n)]\\n\\t\\t\\tright = [0 for i in range(n)]\\n\\t\\t\\tfor i in range(n-2, -1, -1):\\n\\t\\t\\t\\tif security[i] >= security[i+1]:\\n\\t\\t\\t\\t\\tleft[i] = 1 + left[i+1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft[i] = 0\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tif security[i] >= security[i-1]:\\n\\t\\t\\t\\t\\tright[i] = 1 + right[i-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tright[i] = 0\\n\\t\\t\\tans = []\\n\\t\\t\\tfor i in range(time, n-time):\\n\\t\\t\\t\\tif left[i-time] >= time and right[i+time] >= time:\\n\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 1765635,
                "title": "c-o-n-using-pre-computation-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        // [5,3,3,3,5,6,2]\\n        // [0,1,2,3,0,0,1] --> count of contiguous no greater than current no to left\\n        // [0,4,3,2,1,0,0] --> count of contiguous no greater than current no to right\\n        int n = security.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        left[0] = 0, right[n - 1] = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            } else {\\n                left[i] = 0;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            } else {\\n                right[i] = 0;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            if(left[i] >= time && right[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        // [5,3,3,3,5,6,2]\\n        // [0,1,2,3,0,0,1] --> count of contiguous no greater than current no to left\\n        // [0,4,3,2,1,0,0] --> count of contiguous no greater than current no to right\\n        int n = security.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        left[0] = 0, right[n - 1] = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            } else {\\n                left[i] = 0;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            } else {\\n                right[i] = 0;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            if(left[i] >= time && right[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734643,
                "title": "python3-short-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        decreasing = [0] * len(security)\\n        increasing = [0] * len(security)\\n        for i in range(len(security)):\\n            if i > 0 and security[i - 1] >= security[i]:\\n                decreasing[i] = decreasing[i - 1] + 1\\n        for i in reversed(range(len(security))):\\n            if i < len(security) - 1 and security[i] <= security[i + 1]:\\n                increasing[i] = increasing[i + 1] + 1\\n        return [i for i in range(len(security)) if increasing[i] >= time and decreasing[i] >= time]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        decreasing = [0] * len(security)\\n        increasing = [0] * len(security)\\n        for i in range(len(security)):\\n            if i > 0 and security[i - 1] >= security[i]:\\n                decreasing[i] = decreasing[i - 1] + 1\\n        for i in reversed(range(len(security))):\\n            if i < len(security) - 1 and security[i] <= security[i + 1]:\\n                increasing[i] = increasing[i + 1] + 1\\n        return [i for i in range(len(security)) if increasing[i] >= time and decreasing[i] >= time]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676417,
                "title": "c-prefix-sufix-sum-clear-code",
                "content": "**Short Explaination after the code**\\n```\\nvector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n  = security.size();\\n        vector<int> ans;\\n        if(time == 0){\\n            for(int i = 0 ;i < n ; i++) ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> l(n) , r(n) , prel(n+2) , prer(n+2);\\n        for(int i = 0 ;i < n-1; i++){\\n            l[i] = security[i] < security[i+1];\\n        }\\n        for(int i = n-1 ;i > 0; i--){\\n            r[i] = security[i] < security[i-1];\\n        }\\n        prel[1] = l[0] , prer[n] = r[n-1];\\n        for(int i = 2 ;i <= n ; i++){\\n            prel[i] = l[i-1]+prel[i-1];\\n        }\\n        for(int i = n-1 ; i >0 ; i--){\\n            prer[i] = prer[i+1] + r[i-1];\\n        }\\n       \\n        for(int i = 1 ;i <= n ; i++){\\n            if(i-time > 0 and i + time <= n){\\n                if(prel[i-1] - prel[i-time-1] == 0 and prer[i+time+1] - prer[i+1] == 0) ans.push_back(i-1);\\n            } \\n        }\\n        return ans;\\n    }```\\nNote : \\n//Faling case / Break Down Case (Left / Right side - Decreasing order break down)\\nif(security[i] < security[i+1]) l[i] = 1;\\nif(security[i-1] > security[i]) r[i] = 1;\\nPut 1 in left (l) and right(r) Array.\\nMake PreFix sum from left to right and right to left with the failing case;\\nthen check\\nif(prel[i-1] - prel[i-time-1] == 0 and prer[i+time+1] - prer[i+1] == 0) ans.push_back(i-1);\\n== 0 , means no faliling case in the range [i-time , i+time] excluding i;\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n  = security.size();\\n        vector<int> ans;\\n        if(time == 0){\\n            for(int i = 0 ;i < n ; i++) ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> l(n) , r(n) , prel(n+2) , prer(n+2);\\n        for(int i = 0 ;i < n-1; i++){\\n            l[i] = security[i] < security[i+1];\\n        }\\n        for(int i = n-1 ;i > 0; i--){\\n            r[i] = security[i] < security[i-1];\\n        }\\n        prel[1] = l[0] , prer[n] = r[n-1];\\n        for(int i = 2 ;i <= n ; i++){\\n            prel[i] = l[i-1]+prel[i-1];\\n        }\\n        for(int i = n-1 ; i >0 ; i--){\\n            prer[i] = prer[i+1] + r[i-1];\\n        }\\n       \\n        for(int i = 1 ;i <= n ; i++){\\n            if(i-time > 0 and i + time <= n){\\n                if(prel[i-1] - prel[i-time-1] == 0 and prer[i+time+1] - prer[i+1] == 0) ans.push_back(i-1);\\n            } \\n        }\\n        return ans;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673190,
                "title": "c-find-longest-valley-in-the-array-very-simple",
                "content": "This problem is similar to the question: https://leetcode.com/problems/longest-mountain-in-array/\\n\\nIn this problem, it is required to find the longest valley in the array and check if the downward slope on the either side of the valley is longer than the value given as \"time\".\\n\\nThe vector \"forward\" records the decreasing phenomenon(i.e., the leftside downward slope of the valley) and the vector \"backward\" records the increasing phenomenon(i.e., the rightside downslope of the valley).\\n\\n```\\nclass Solution {\\npublic:\\n    void forwardUtility(vector<int>& security, vector<int>& forward, int n){\\n        forward[0] = 0;\\n        int downcount = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (security[i] <= security[i-1]){\\n                downcount++;\\n                forward[i] = downcount;\\n            }\\n            else{\\n                downcount = 0;\\n                forward[i] = downcount;\\n            }\\n        }\\n    }\\n    void backwardUtility(vector<int>& security, vector<int>& backward, int n){\\n        backward[n] = 0;\\n        int upcount = 0;\\n        for (int i = n-1; i >= 0; i--){\\n            if (security[i] <= security[i+1]){\\n                upcount++;\\n                backward[i] = upcount;\\n            }\\n            else{\\n                upcount = 0;\\n                backward[i] = upcount;\\n            }\\n        }\\n    }\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int l = security.size();\\n        vector<int> ans;\\n        if (time > l)\\n            return ans;\\n        vector<int> forward(l, -1);\\n        vector<int> backward(l, -1);\\n        forward[0] = 0;\\n        backward[l-1] = 0;\\n        forwardUtility(security, forward, l-1);\\n        backwardUtility(security, backward, l-1);\\n        int rlimit = l-1-time;\\n        for (int i = time; i <= rlimit; i++){\\n            if (forward[i] >= time && backward[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn the above approach the use of the vector backward can be avoided by doing in-place updating in the security vector as below:\\nThis will not reduce space complexity but the space utilized will be less compared to the above code.\\n\\n```\\nclass Solution {\\npublic:\\n    void forwardUtility(vector<int>& security, vector<int>& forward, int n){\\n        forward[0] = 0;\\n        int downcount = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (security[i] <= security[i-1]){\\n                downcount++;\\n                forward[i] = downcount;\\n            }\\n            else{\\n                downcount = 0;\\n                forward[i] = downcount;\\n            }\\n        }\\n    }\\n    void backwardUtility(vector<int>& security, int n){\\n        int temp = security[n];\\n        security[n] = 0;\\n        for (int i = n-1; i >= 0; i--){\\n            if (security[i] <= temp){\\n                temp = security[i];\\n                security[i] = security[i+1] + 1;\\n            }\\n            else{\\n                temp = security[i];\\n                security[i] = 0;\\n            }\\n        }\\n    }\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int l = security.size();\\n        vector<int> ans;\\n        if (time > l)\\n            return ans;\\n        vector<int> forward(l, -1);\\n        forwardUtility(security, forward, l-1);\\n        backwardUtility(security, l-1);\\n        int rlimit = l-1-time;\\n        for (int i = time; i <= rlimit; i++){\\n            if (forward[i] >= time && security[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void forwardUtility(vector<int>& security, vector<int>& forward, int n){\\n        forward[0] = 0;\\n        int downcount = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (security[i] <= security[i-1]){\\n                downcount++;\\n                forward[i] = downcount;\\n            }\\n            else{\\n                downcount = 0;\\n                forward[i] = downcount;\\n            }\\n        }\\n    }\\n    void backwardUtility(vector<int>& security, vector<int>& backward, int n){\\n        backward[n] = 0;\\n        int upcount = 0;\\n        for (int i = n-1; i >= 0; i--){\\n            if (security[i] <= security[i+1]){\\n                upcount++;\\n                backward[i] = upcount;\\n            }\\n            else{\\n                upcount = 0;\\n                backward[i] = upcount;\\n            }\\n        }\\n    }\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int l = security.size();\\n        vector<int> ans;\\n        if (time > l)\\n            return ans;\\n        vector<int> forward(l, -1);\\n        vector<int> backward(l, -1);\\n        forward[0] = 0;\\n        backward[l-1] = 0;\\n        forwardUtility(security, forward, l-1);\\n        backwardUtility(security, backward, l-1);\\n        int rlimit = l-1-time;\\n        for (int i = time; i <= rlimit; i++){\\n            if (forward[i] >= time && backward[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void forwardUtility(vector<int>& security, vector<int>& forward, int n){\\n        forward[0] = 0;\\n        int downcount = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (security[i] <= security[i-1]){\\n                downcount++;\\n                forward[i] = downcount;\\n            }\\n            else{\\n                downcount = 0;\\n                forward[i] = downcount;\\n            }\\n        }\\n    }\\n    void backwardUtility(vector<int>& security, int n){\\n        int temp = security[n];\\n        security[n] = 0;\\n        for (int i = n-1; i >= 0; i--){\\n            if (security[i] <= temp){\\n                temp = security[i];\\n                security[i] = security[i+1] + 1;\\n            }\\n            else{\\n                temp = security[i];\\n                security[i] = 0;\\n            }\\n        }\\n    }\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int l = security.size();\\n        vector<int> ans;\\n        if (time > l)\\n            return ans;\\n        vector<int> forward(l, -1);\\n        forwardUtility(security, forward, l-1);\\n        backwardUtility(security, l-1);\\n        int rlimit = l-1-time;\\n        for (int i = time; i <= rlimit; i++){\\n            if (forward[i] >= time && security[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655311,
                "title": "python-o-n-prefix-suffix-type",
                "content": "Pre-Calculate for left and for right and then take intersection ,simple!!\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n=len(security)\\n        if time==0: return [i for i in range(n)]\\n        ans=set()\\n        valid_l,valid_r=set(),set()\\n        left,right=0,0\\n        for i in range(1,n):\\n            if security[i-1]>=security[i]: \\n                left+=1\\n            else:\\n                left=0\\n            if left>=time: \\n                valid_l.add(i)\\n        for i in range(n-2,-1,-1):\\n            if security[i]<=security[i+1]: \\n                right+=1\\n            else:\\n                right=0\\n            if right>=time: \\n                valid_r.add(i)\\n        ans=valid_l.intersection(valid_r)\\n        return list(ans)\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n=len(security)\\n        if time==0: return [i for i in range(n)]\\n        ans=set()\\n        valid_l,valid_r=set(),set()\\n        left,right=0,0\\n        for i in range(1,n):\\n            if security[i-1]>=security[i]: \\n                left+=1\\n            else:\\n                left=0\\n            if left>=time: \\n                valid_l.add(i)\\n        for i in range(n-2,-1,-1):\\n            if security[i]<=security[i+1]: \\n                right+=1\\n            else:\\n                right=0\\n            if right>=time: \\n                valid_r.add(i)\\n        ans=valid_l.intersection(valid_r)\\n        return list(ans)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632593,
                "title": "c-using-prefix-suffix-array",
                "content": "**Time: *O(n)***\\n**Space: *O(n)***\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        int prefix[n], suffix[n];\\n        prefix[0]=1;\\n        suffix[n-1]=1;\\n        \\n        for(int i=1; i<n; ++i){\\n            if(security[i-1]>=security[i]) prefix[i] = 1+prefix[i-1];\\n            else prefix[i] = 1;\\n        }\\n        \\n        for(int j=n-2; j>=0; --j){\\n            if(security[j+1]>=security[j]) suffix[j] = 1+suffix[j+1];\\n            else suffix[j] = 1;\\n        }\\n        \\n        vector<int> ans;\\n        for(int k=0; k<n; ++k){\\n            if(prefix[k] > time && suffix[k] > time) ans.push_back(k);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        int prefix[n], suffix[n];\\n        prefix[0]=1;\\n        suffix[n-1]=1;\\n        \\n        for(int i=1; i<n; ++i){\\n            if(security[i-1]>=security[i]) prefix[i] = 1+prefix[i-1];\\n            else prefix[i] = 1;\\n        }\\n        \\n        for(int j=n-2; j>=0; --j){\\n            if(security[j+1]>=security[j]) suffix[j] = 1+suffix[j+1];\\n            else suffix[j] = 1;\\n        }\\n        \\n        vector<int> ans;\\n        for(int k=0; k<n; ++k){\\n            if(prefix[k] > time && suffix[k] > time) ans.push_back(k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627871,
                "title": "java-prefix-sum-linear-extra-array-explained",
                "content": "for each day we need to know how many day to it\\'s left and to it\\'s right have security >=. This can be done if we do two sweeps on array and check if every next (and prior) day is less secure => it security value is less than a previous value.  Otherwise the chain is broken we can reset our counting. So we actually only care about immidiate neighbour and not all previous days.\\n\\nWe this information finding a good day is a matter of checking if for this day number of more secure days to the left and to the right are both >= than a time. This again can be done in one scan.\\n\\nWe can optimize initial two scans and two arrays into one scan and one 2d array.\\n\\nO(n) time - scan security array once to collect number of more secure days left-to-right and right-to-left, another scan to find good days\\nO(n) space - need [N][2] array to store number of more secure neighbouring days\\n\\n```\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList();\\n        int N = security.length;\\n        int[][] counts = new int[N][2];\\n        for (int i = 1; i < N; i++) {\\n            //fill right to left part\\n            if (security[i - 1] >= security[i]) {\\n                counts[i][0] = counts[i - 1][0] + 1; \\n            } \\n            //fill left to right part\\n            int ltorIdx = N - i - 1;\\n            if (security[ltorIdx] <= security[ltorIdx + 1]) {\\n                counts[ltorIdx][1] = counts[ltorIdx + 1][1] + 1; \\n            } \\n        }\\n        //i represents the potential day for robbery\\n        for (int i = time; i < N - time; i++) {\\n            if (counts[i][0] >= time && counts[i][1] >= time) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList();\\n        int N = security.length;\\n        int[][] counts = new int[N][2];\\n        for (int i = 1; i < N; i++) {\\n            //fill right to left part\\n            if (security[i - 1] >= security[i]) {\\n                counts[i][0] = counts[i - 1][0] + 1; \\n            } \\n            //fill left to right part\\n            int ltorIdx = N - i - 1;\\n            if (security[ltorIdx] <= security[ltorIdx + 1]) {\\n                counts[ltorIdx][1] = counts[ltorIdx + 1][1] + 1; \\n            } \\n        }\\n        //i represents the potential day for robbery\\n        for (int i = time; i < N - time; i++) {\\n            if (counts[i][0] >= time && counts[i][1] >= time) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1625921,
                "title": "sliding-windows-o-n-time-o-1-space",
                "content": "This kind of problem is usually solved by sliding window or prefix sum/count. Sliding window usually wins on space usage.\\nIn this case, we use 2 sliding windows: non-increasing `[deci..decj]` and non-decreasing `[inci..incj]`.\\nBoth have fixed size `time`, and it always has `decj = incj - time`. We just need to shrink the left.\\nCodes are straight forward:\\n```\\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\\n        var res = new List<int>();\\n        // sliding window [deci..decj] and [inci..incj], decj == incj - time\\n        int deci = 0, decj = -time, inci = 0, incj = 0;\\n        for (; incj < security.Length; decj++, incj++) {\\n            if (decj > 0 && security[decj-1] < security[decj]) // against dec\\n                deci = decj;\\n            if (deci + time < decj)  // window too large\\n                deci++;\\n            \\n            if (incj > 0 && security[incj-1] > security[incj]) // against inc\\n                inci = incj;\\n            if (inci + time < incj)  // window too large\\n                inci++;\\n            \\n            if (deci + time == decj && decj == inci)\\n                res.Add(decj);\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nPlease upvote if it helps.\\n\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\\n        var res = new List<int>();\\n        // sliding window [deci..decj] and [inci..incj], decj == incj - time\\n        int deci = 0, decj = -time, inci = 0, incj = 0;\\n        for (; incj < security.Length; decj++, incj++) {\\n            if (decj > 0 && security[decj-1] < security[decj]) // against dec\\n                deci = decj;\\n            if (deci + time < decj)  // window too large\\n                deci++;\\n            \\n            if (incj > 0 && security[incj-1] > security[incj]) // against inc\\n                inci = incj;\\n            if (inci + time < incj)  // window too large\\n                inci++;\\n            \\n            if (deci + time == decj && decj == inci)\\n                res.Add(decj);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624923,
                "title": "javascript-very-easy-to-understand-solution",
                "content": "Runtime: 172 ms, faster than 100.00% of JavaScript online submissions for Find Good Days to Rob the Bank.\\nMemory Usage: 64.1 MB, less than 100.00% of JavaScript online submissions for Find Good Days to Rob the Bank.\\n```\\nvar goodDaysToRobBank = function(security, time) {\\n    let res = [];\\n    if(!time){\\n       let i = 0;\\n        while(i<security.length) res.push(i), i++;\\n        return res;\\n    }\\n    let increasing = 0;\\n    let decreasing = 0;\\n    let set = new Set();\\n    for(let i = 1; i < security.length; i++){\\n        if(security[i]>security[i-1]) decreasing = 0;\\n        else decreasing++;\\n        if(security[i]<security[i-1]) increasing = 0;\\n        else increasing++;\\n        if(decreasing>=time) set.add(i);\\n        if(increasing>=time&&set.has(i-time)) res.push(i-time);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    let res = [];\\n    if(!time){\\n       let i = 0;\\n        while(i<security.length) res.push(i), i++;\\n        return res;\\n    }\\n    let increasing = 0;\\n    let decreasing = 0;\\n    let set = new Set();\\n    for(let i = 1; i < security.length; i++){\\n        if(security[i]>security[i-1]) decreasing = 0;\\n        else decreasing++;\\n        if(security[i]<security[i-1]) increasing = 0;\\n        else increasing++;\\n        if(decreasing>=time) set.add(i);\\n        if(increasing>=time&&set.has(i-time)) res.push(i-time);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624190,
                "title": "simple-c-solution-optimal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int>prefix(n);\\n        \\n        prefix[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n                prefix[i]=prefix[i-1]+1;\\n            else\\n                prefix[i]=1;\\n        }\\n        vector<int>suffix(n);\\n         suffix[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n                suffix[i]=suffix[i+1]+1;\\n            else\\n                suffix[i]=1;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]>=time+1 && suffix[i]>=time+1)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int>prefix(n);\\n        \\n        prefix[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n                prefix[i]=prefix[i-1]+1;\\n            else\\n                prefix[i]=1;\\n        }\\n        vector<int>suffix(n);\\n         suffix[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n                suffix[i]=suffix[i+1]+1;\\n            else\\n                suffix[i]=1;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]>=time+1 && suffix[i]>=time+1)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623629,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> goodDaysToRobBank(vector<int>& vec, int time) {\\n\\t\\tint n=vec.size();\\n        vector<int>ans;\\n        if(n<(2*time+1))return ans;\\n        \\n        vector<int>dec(n,1);\\n        vector<int>inc(n,1);\\n\\t\\t\\n        for(int i=1;i<n;i++)\\n            if(vec[i-1]>=vec[i])\\n\\t\\t\\t\\tdec[i]=dec[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n            if(vec[i]<=vec[i+1])\\n\\t\\t\\t\\tinc[i]=inc[i+1]+1;\\n        \\n        \\n        for(int i=time;i<n-time;i++)\\n            if(dec[i]>=time+1 and inc[i]>=time+1)\\n\\t\\t\\t\\tans.push_back(i);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> goodDaysToRobBank(vector<int>& vec, int time) {\\n\\t\\tint n=vec.size();\\n        vector<int>ans;\\n        if(n<(2*time+1))return ans;\\n        \\n        vector<int>dec(n,1);\\n        vector<int>inc(n,1);\\n\\t\\t\\n        for(int i=1;i<n;i++)\\n            if(vec[i-1]>=vec[i])\\n\\t\\t\\t\\tdec[i]=dec[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n            if(vec[i]<=vec[i+1])\\n\\t\\t\\t\\tinc[i]=inc[i+1]+1;\\n        \\n        \\n        for(int i=time;i<n-time;i++)\\n            if(dec[i]>=time+1 and inc[i]>=time+1)\\n\\t\\t\\t\\tans.push_back(i);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1623617,
                "title": "c-prefix",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n      int n=nums.size();  \\n      \\n      vector<int>bDiff(n,0);\\n     vector<int>fDiff(n,0);\\n\\n      int count=0;\\n      for(int i=1;i<n;i++){\\n        if(nums[i]-nums[i-1]<=0){\\n          count++;\\n          bDiff[i]=count;\\n        }\\n        else{\\n          count=0;\\n          bDiff[i]=0;\\n        }\\n      }\\n      \\n       count=0;\\n      for(int i=n-2;i>=0;i--){\\n        if(nums[i+1]-nums[i]>=0){\\n          count++;\\n          fDiff[i]=count;\\n        }\\n        else{\\n          count=0;\\n          fDiff[i]=0;\\n        }\\n      }\\n      \\n      vector<int>ans;\\n      for(int i=time;i<n-time;i++){\\n        if(bDiff[i]>=time && fDiff[i]>=time)\\n          ans.push_back(i);\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n      int n=nums.size();  \\n      \\n      vector<int>bDiff(n,0);\\n     vector<int>fDiff(n,0);\\n\\n      int count=0;\\n      for(int i=1;i<n;i++){\\n        if(nums[i]-nums[i-1]<=0){\\n          count++;\\n          bDiff[i]=count;\\n        }\\n        else{\\n          count=0;\\n          bDiff[i]=0;\\n        }\\n      }\\n      \\n       count=0;\\n      for(int i=n-2;i>=0;i--){\\n        if(nums[i+1]-nums[i]>=0){\\n          count++;\\n          fDiff[i]=count;\\n        }\\n        else{\\n          count=0;\\n          fDiff[i]=0;\\n        }\\n      }\\n      \\n      vector<int>ans;\\n      for(int i=time;i<n-time;i++){\\n        if(bDiff[i]>=time && fDiff[i]>=time)\\n          ans.push_back(i);\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623511,
                "title": "javascript-js-simple",
                "content": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    const res = [];\\n    const len = security.length;\\n    const left = new Array(len).fill(len);\\n    const right = new Array(len).fill(len);\\n    \\n    for (let i = 1; i < len; i++) {\\n        left[i] = security[i] <= security[i - 1] ? left[i - 1] + 1 : 0;\\n    }\\n    for (let i = len - 2; i >= 0; i--) {\\n        right[i] = security[i] <= security[i + 1] ? right[i + 1] + 1 : 0;\\n    }\\n    for (let i = time; i < len - time; i++) {\\n        if (left[i] >= time && right[i] >= time) res.push(i);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    const res = [];\\n    const len = security.length;\\n    const left = new Array(len).fill(len);\\n    const right = new Array(len).fill(len);\\n    \\n    for (let i = 1; i < len; i++) {\\n        left[i] = security[i] <= security[i - 1] ? left[i - 1] + 1 : 0;\\n    }\\n    for (let i = len - 2; i >= 0; i--) {\\n        right[i] = security[i] <= security[i + 1] ? right[i + 1] + 1 : 0;\\n    }\\n    for (let i = time; i < len - time; i++) {\\n        if (left[i] >= time && right[i] >= time) res.push(i);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623504,
                "title": "go-dp-solution",
                "content": "We can use two dp array to store how many sequential nums larger or less than current num\\ndp1 for decreasing\\ndp2 for increasing \\nFor example:\\n[5,3,3,3,5,6,2]\\ndp1[0,1,2,3,0,0,1]\\ndp2[0,5,4,3,2,1,0]\\n\\nIf you have any improvement suggestion, please add comments. Thanks \\n\\n```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    n := len(security)\\n    var ans []int\\n    \\n    if n < 2*time+1{\\n        return ans\\n    }\\n    \\n    dp1 := make([]int,n)\\n    dp2 := make([]int,n)\\n    \\n    for i:=1;i<n-time;i++{\\n        if security[i-1] >= security[i]{\\n            dp1[i] = dp1[i-1] + 1\\n        }else{\\n            dp1[i] = 0\\n        }\\n    }\\n    \\n    for j:=n-2;j>=time;j--{\\n        if security[j+1] >= security[j]{\\n            dp2[j] = dp2[j+1] + 1 \\n        }else{\\n            dp2[j] = 0\\n        }\\n    }\\n    \\n    for i:=time;i<n-time;i++{\\n        if dp1[i]>= time && dp2[i] >= time{\\n            ans = append(ans,i)\\n        }   \\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    n := len(security)\\n    var ans []int\\n    \\n    if n < 2*time+1{\\n        return ans\\n    }\\n    \\n    dp1 := make([]int,n)\\n    dp2 := make([]int,n)\\n    \\n    for i:=1;i<n-time;i++{\\n        if security[i-1] >= security[i]{\\n            dp1[i] = dp1[i-1] + 1\\n        }else{\\n            dp1[i] = 0\\n        }\\n    }\\n    \\n    for j:=n-2;j>=time;j--{\\n        if security[j+1] >= security[j]{\\n            dp2[j] = dp2[j+1] + 1 \\n        }else{\\n            dp2[j] = 0\\n        }\\n    }\\n    \\n    for i:=time;i<n-time;i++{\\n        if dp1[i]>= time && dp2[i] >= time{\\n            ans = append(ans,i)\\n        }   \\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623353,
                "title": "prefix-sum-and-suffix-sum",
                "content": "We only have to see previous time by prefix array and past time by suffix array and if union of both pre and suff is greater than equal to time than it will satisfy the condition and include this in ans\\nUsing prefixx sum and suffix sum\\n![image](https://assets.leetcode.com/users/images/4975dbde-ecdd-4220-a133-2a0d652f7b66_1639238557.7127664.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n     \\n        int n=s.size(),temp=time;\\n        vector<int>pre(n,0),suff(n,0),v;\\n        for(int i=1;i<n;i++)\\n          {\\n           if(s[i-1]>=s[i]) pre[i]=pre[i-1]+1;\\n           else\\n               pre[i]=0;\\n          }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]<=s[i+1]) \\n                suff[i]=suff[i+1]+1;\\n            else\\n                suff[i]=0;\\n        }\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(suff[i]>=time and pre[i]>=time)\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n     \\n        int n=s.size(),temp=time;\\n        vector<int>pre(n,0),suff(n,0),v;\\n        for(int i=1;i<n;i++)\\n          {\\n           if(s[i-1]>=s[i]) pre[i]=pre[i-1]+1;\\n           else\\n               pre[i]=0;\\n          }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]<=s[i+1]) \\n                suff[i]=suff[i+1]+1;\\n            else\\n                suff[i]=0;\\n        }\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(suff[i]>=time and pre[i]>=time)\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623340,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) precompute monotonically increasing/decreasing lengths from left-to-right and from right-to-left to reduce asymptotic bounds to validate each `i`<sup>th</sup> index is `ok`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun goodDaysToRobBank(A: IntArray, K: Int): List<Int> {\\n        var N = A.size\\n        var L = IntArray(N) { 0 }\\n        var R = IntArray(N) { 0 }\\n        for (i in 1 until N) {\\n            var j = N - 1 - i\\n            L[i] = if (A[i - 1] >= A[i]) 1 + L[i - 1] else 0\\n            R[j] = if (A[j] <= A[j + 1]) 1 + R[j + 1] else 0\\n        }\\n        fun ok(i: Int): Boolean {\\n            if (i - K < 0 || N <= i + K)\\n                return false\\n            var l = L[i] - L[i - K]\\n            var r = R[i] - R[i + K]\\n            return l == K && r == K\\n        }\\n        return IntArray(N){ it }.filter{ ok(it) }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet goodDaysToRobBank = (A, K) => {\\n    let N = A.length;\\n    let L = Array(N).fill(0),\\n        R = Array(N).fill(0);\\n    for (let i = 1; i < N; ++i) {\\n        let j = N - 1 - i;\\n        L[i] = A[i - 1] >= A[i] ? 1 + L[i - 1] : 0;\\n        R[j] = A[j] <= A[j + 1] ? 1 + R[j + 1] : 0;\\n    }\\n    let ok = i => {\\n        if (i - K < 0 || N <= i + K)\\n            return false;\\n        let l = L[i] - L[i - K],\\n            r = R[i] - R[i + K];\\n        return l == K && r == K;\\n    };\\n    return [...Array(N).keys()].filter(i => ok(i));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        L = [0] * N\\n        R = [0] * N\\n        for i in range(1, N):\\n            j = N - 1 - i\\n            L[i] = 1 + L[i - 1] if A[i - 1] >= A[i] else 0\\n            R[j] = 1 + R[j + 1] if A[j] <= A[j + 1] else 0\\n        def ok(i):\\n            if i - K < 0 or N <= i + K:\\n                return False\\n            l = L[i] - L[i - K]\\n            r = R[i] - R[i + K]\\n            return l == K == r\\n        return [i for i in range(N) if ok(i)]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI goodDaysToRobBank(VI& A, int K, VI good = {}) {\\n        int N = A.size();\\n        VI L(N),\\n           R(N);\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            L[i] = A[i - 1] >= A[i] ? 1 + L[i - 1] : 0;\\n            R[j] = A[j] <= A[j + 1] ? 1 + R[j + 1] : 0;\\n        }\\n        auto ok = [&](auto i) {\\n            auto l = L[i] - L[i - K],\\n                 r = R[i] - R[i + K];\\n            return K == l && K == r;\\n        };\\n        for (auto i{ K }; i + K < N; ++i)\\n            if (ok(i))\\n                good.push_back(i);\\n        return good;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun goodDaysToRobBank(A: IntArray, K: Int): List<Int> {\\n        var N = A.size\\n        var L = IntArray(N) { 0 }\\n        var R = IntArray(N) { 0 }\\n        for (i in 1 until N) {\\n            var j = N - 1 - i\\n            L[i] = if (A[i - 1] >= A[i]) 1 + L[i - 1] else 0\\n            R[j] = if (A[j] <= A[j + 1]) 1 + R[j + 1] else 0\\n        }\\n        fun ok(i: Int): Boolean {\\n            if (i - K < 0 || N <= i + K)\\n                return false\\n            var l = L[i] - L[i - K]\\n            var r = R[i] - R[i + K]\\n            return l == K && r == K\\n        }\\n        return IntArray(N){ it }.filter{ ok(it) }\\n    }\\n}\\n```\n```\\nlet goodDaysToRobBank = (A, K) => {\\n    let N = A.length;\\n    let L = Array(N).fill(0),\\n        R = Array(N).fill(0);\\n    for (let i = 1; i < N; ++i) {\\n        let j = N - 1 - i;\\n        L[i] = A[i - 1] >= A[i] ? 1 + L[i - 1] : 0;\\n        R[j] = A[j] <= A[j + 1] ? 1 + R[j + 1] : 0;\\n    }\\n    let ok = i => {\\n        if (i - K < 0 || N <= i + K)\\n            return false;\\n        let l = L[i] - L[i - K],\\n            r = R[i] - R[i + K];\\n        return l == K && r == K;\\n    };\\n    return [...Array(N).keys()].filter(i => ok(i));\\n};\\n```\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        L = [0] * N\\n        R = [0] * N\\n        for i in range(1, N):\\n            j = N - 1 - i\\n            L[i] = 1 + L[i - 1] if A[i - 1] >= A[i] else 0\\n            R[j] = 1 + R[j + 1] if A[j] <= A[j + 1] else 0\\n        def ok(i):\\n            if i - K < 0 or N <= i + K:\\n                return False\\n            l = L[i] - L[i - K]\\n            r = R[i] - R[i + K]\\n            return l == K == r\\n        return [i for i in range(N) if ok(i)]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI goodDaysToRobBank(VI& A, int K, VI good = {}) {\\n        int N = A.size();\\n        VI L(N),\\n           R(N);\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            L[i] = A[i - 1] >= A[i] ? 1 + L[i - 1] : 0;\\n            R[j] = A[j] <= A[j + 1] ? 1 + R[j + 1] : 0;\\n        }\\n        auto ok = [&](auto i) {\\n            auto l = L[i] - L[i - K],\\n                 r = R[i] - R[i + K];\\n            return K == l && K == r;\\n        };\\n        for (auto i{ K }; i + K < N; ++i)\\n            if (ok(i))\\n                good.push_back(i);\\n        return good;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623324,
                "title": "c-solution-left-right",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int t)\\n    {\\n        int n=nums.size();\\n        vector<int>left(n,0),right(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]>=t&&right[i]>=t)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int t)\\n    {\\n        int n=nums.size();\\n        vector<int>left(n,0),right(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]>=t&&right[i]>=t)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082233,
                "title": "c-straight-forward-solution",
                "content": "# Intuition\\nMy first thought was that this seems similar to the popular trapping rain water problem (#42)\\n\\n# Approach\\n- Fill an array, going from start (left) to end (right), record for each day how many previous days had same amount same or more guards ($$security[i-1]>=security[i] $$)\\n- Calculate the same by going from end (right) to start (left) - $$security[i]<=security[i+1]$$\\n- Pick the good days for robbery since you know for each day how many days before and after fit the criteria.\\n\\n# Complexity\\n- Time complexity:\\nO(N) - we do 2 passes from left to right\\n\\n- Space complexity:\\nO(N) - need to store the \\n\\n# Code\\n```\\n/* Could write this shorter and more elegant, but this is simple */\\npublic class Solution {\\n\\n    int[] LR;    \\n    int N;\\n\\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\\n        N = security.Length;\\n        LR = new int[N];\\n//Counter for days that fulfil the critera when moving L->R\\n        int counter = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            if (i > 0)\\n            {\\n// This day has same or less guards than previos one\\n                if (security[i-1]>=security[i])\\n                    counter++;\\n                else\\n                    counter = 0; // Reset\\n            }\\n            LR[i] = counter;\\n        }\\n\\n        counter = 0;\\n\\n        var answer = new List<int>(N);\\n// Same approach, we move from R->L in this case no need to store\\n// results - we can just calculate answers rights away.\\n        for (int i = N-1; i>=0; i--)\\n        {\\n            if (i != N-1 )\\n            {\\n                if (security[i]<=security[i+1])\\n                    counter++;\\n                else\\n                    counter = 0;\\n            }\\n// This is a good day for robbery\\n            if (counter >=time && LR[i] >= time)\\n            {\\n                answer.Add(i);\\n            }\\n        }\\n        return answer;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/* Could write this shorter and more elegant, but this is simple */\\npublic class Solution {\\n\\n    int[] LR;    \\n    int N;\\n\\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\\n        N = security.Length;\\n        LR = new int[N];\\n//Counter for days that fulfil the critera when moving L->R\\n        int counter = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            if (i > 0)\\n            {\\n// This day has same or less guards than previos one\\n                if (security[i-1]>=security[i])\\n                    counter++;\\n                else\\n                    counter = 0; // Reset\\n            }\\n            LR[i] = counter;\\n        }\\n\\n        counter = 0;\\n\\n        var answer = new List<int>(N);\\n// Same approach, we move from R->L in this case no need to store\\n// results - we can just calculate answers rights away.\\n        for (int i = N-1; i>=0; i--)\\n        {\\n            if (i != N-1 )\\n            {\\n                if (security[i]<=security[i+1])\\n                    counter++;\\n                else\\n                    counter = 0;\\n            }\\n// This is a good day for robbery\\n            if (counter >=time && LR[i] >= time)\\n            {\\n                answer.Add(i);\\n            }\\n        }\\n        return answer;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075143,
                "title": "using-prefix-sum-approch-and-precise-optiminal-solution-i-could-think-off-92-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(3n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int [] cntIn = new int[security.length];\\n        for(int i=1; i<security.length-time; i++){\\n            if(security[i] > security[i-1]) cntIn[i]=0;\\n            else cntIn[i] = cntIn[i-1]+1;\\n        }\\n\\n        int [] cntDe = new int[security.length];\\n        for(int i=security.length-2; i>=time; i--){\\n            if(security[i] > security[i+1]) cntDe[i]=0;\\n            else cntDe[i] = cntDe[i+1]+1;\\n        }\\n\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=time; i<security.length; i++){\\n            if(cntIn[i]>=time && cntDe[i]>=time) list.add(i);\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int [] cntIn = new int[security.length];\\n        for(int i=1; i<security.length-time; i++){\\n            if(security[i] > security[i-1]) cntIn[i]=0;\\n            else cntIn[i] = cntIn[i-1]+1;\\n        }\\n\\n        int [] cntDe = new int[security.length];\\n        for(int i=security.length-2; i>=time; i--){\\n            if(security[i] > security[i+1]) cntDe[i]=0;\\n            else cntDe[i] = cntDe[i+1]+1;\\n        }\\n\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=time; i<security.length; i++){\\n            if(cntIn[i]>=time && cntDe[i]>=time) list.add(i);\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060884,
                "title": "c-prefix-and-suffix-array",
                "content": "# Intuition\\nJust we have to build the prefix and suffix array and have to re-scan the arrays we have builded and check whether that day is good to rob or not!\\n\\n# Complexity\\n- Time complexity:\\n2*O(N) ~ O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n2*O(N) for prefix and suffix array!\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> before(security.size()+1, 0), after(security.size()+1, 0);\\n        for(int i=1;i<n;i++) {\\n            if(i==(n-1)) {\\n                if(security[i] <= security[i-1]) {\\n                    before[i] += before[i-1]+1;\\n                }\\n            }\\n            else {\\n                if(security[i] <= security[i-1]) {\\n                    before[i] += before[i-1]+1;\\n                }\\n                if((n-i-1) >= 0 && security[n-i-1] <= security[n-i]) {\\n                    after[n-i-1] += after[n-i]+1;\\n                }\\n            }\\n        }  \\n        vector<int> ans;  \\n        for(int i=max(0,time);i<(n-time);i++) {\\n            if(before[i] >= time && after[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> before(security.size()+1, 0), after(security.size()+1, 0);\\n        for(int i=1;i<n;i++) {\\n            if(i==(n-1)) {\\n                if(security[i] <= security[i-1]) {\\n                    before[i] += before[i-1]+1;\\n                }\\n            }\\n            else {\\n                if(security[i] <= security[i-1]) {\\n                    before[i] += before[i-1]+1;\\n                }\\n                if((n-i-1) >= 0 && security[n-i-1] <= security[n-i]) {\\n                    after[n-i-1] += after[n-i]+1;\\n                }\\n            }\\n        }  \\n        vector<int> ans;  \\n        for(int i=max(0,time);i<(n-time);i++) {\\n            if(before[i] >= time && after[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045021,
                "title": "easy-dp-cpp",
                "content": "# Intuition\\nTo determine the good days to rob the bank, we need to find days where the number of guards on duty is non-increasing for at least `time` days before and non-decreasing for at least `time` days after the current day. This implies that we should keep track of two things for each day:\\n\\n1. The number of consecutive days before the current day where the number of guards is non-increasing.\\n2. The number of consecutive days after the current day where the number of guards is non-decreasing.\\n\\nIf both of these values are greater than or equal to `time`, then the current day is a good day to rob the bank.\\n\\n# Approach\\n- Initialize two arrays, `dp` and `dp1`, both of size `n` (where `n` is the length of the `security` array) to keep track of the consecutive non-increasing and non-decreasing days, respectively.\\n- Loop through the `security` array from left to right to fill the `dp` array. For each day `i`, if `security[i]` is less than or equal to `security[i-1]`, increment `dp[i]` by 1; otherwise, reset `dp[i]` to 0.\\n- Loop through the `security` array from right to left to fill the `dp1` array. For each day `i`, if `security[i]` is less than or equal to `security[i+1]`, increment `dp1[i]` by 1; otherwise, reset `dp1[i]` to 0.\\n- Finally, loop through the `security` array again and check if both `dp[i]` and `dp1[i]` are greater than or equal to `time`. If they are, add `i` to the list of good days to rob the bank.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the `security` array. We loop through the array three times, each taking O(n) time.\\n- Space complexity: O(n), as we use two additional arrays of size `n` (`dp` and `dp1`) to store the consecutive non-increasing and non-decreasing days.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> dp(n, 0), dp1(n, 0), ans;\\n\\n        // Calculate consecutive non-increasing days using dp array\\n        for (int i = 1; i < n; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n        }\\n\\n        // Calculate consecutive non-decreasing days using dp1 array\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                dp1[i] = dp1[i + 1] + 1;\\n            }\\n        }\\n\\n        // Check for good days to rob the bank\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] >= time && dp1[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nThis code should correctly find and return the good days to rob the bank based on the given conditions.\\nPls Upvote If you Like.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> dp(n, 0), dp1(n, 0), ans;\\n\\n        // Calculate consecutive non-increasing days using dp array\\n        for (int i = 1; i < n; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n        }\\n\\n        // Calculate consecutive non-decreasing days using dp1 array\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                dp1[i] = dp1[i + 1] + 1;\\n            }\\n        }\\n\\n        // Check for good days to rob the bank\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] >= time && dp1[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992520,
                "title": "simple-c-prefix-and-suffix-check-clean-code-easy-to-understand",
                "content": "# Intuition\\nSimple prefix and suffix check\\n\\n# Approach\\nLine sweep \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int>ans;\\n        vector<int>before(security.size());\\n        vector<int>after(security.size());\\n        \\n        int currsize = 1;\\n        //filling the before array\\n        for(int i = 1; i<security.size() ;i++){\\n            \\n            if(security[i]<=security[i-1]){\\n                before[i] = currsize;\\n                currsize++;\\n            }\\n            else{\\n                before[i] = 0;\\n                currsize = 1;\\n            }\\n        }\\n\\n        //filling the after array\\n        currsize = 1;\\n        for(int i = security.size()-2; i>=0; i--){\\n            if(security[i]<=security[i+1]){\\n                after[i] = currsize;\\n                currsize++;\\n            }\\n\\n            else{\\n                after[i] = 0;\\n                currsize = 1;\\n            }\\n        }\\n\\n        for(int i = 0; i<security.size(); i++){\\n            if(i-time>=0 and i+time<security.size()){\\n                if(before[i]>=time and after[i]>=time){\\n                    ans.push_back(i);\\n                }\\n            }\\n\\n            else{\\n                continue;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int>ans;\\n        vector<int>before(security.size());\\n        vector<int>after(security.size());\\n        \\n        int currsize = 1;\\n        //filling the before array\\n        for(int i = 1; i<security.size() ;i++){\\n            \\n            if(security[i]<=security[i-1]){\\n                before[i] = currsize;\\n                currsize++;\\n            }\\n            else{\\n                before[i] = 0;\\n                currsize = 1;\\n            }\\n        }\\n\\n        //filling the after array\\n        currsize = 1;\\n        for(int i = security.size()-2; i>=0; i--){\\n            if(security[i]<=security[i+1]){\\n                after[i] = currsize;\\n                currsize++;\\n            }\\n\\n            else{\\n                after[i] = 0;\\n                currsize = 1;\\n            }\\n        }\\n\\n        for(int i = 0; i<security.size(); i++){\\n            if(i-time>=0 and i+time<security.size()){\\n                if(before[i]>=time and after[i]>=time){\\n                    ans.push_back(i);\\n                }\\n            }\\n\\n            else{\\n                continue;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968644,
                "title": "java-dp-2-array",
                "content": "Use two arrays, one count from left, on count from right;\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for (int i = 1; i < n; i++) {\\n            left[i] = security[i] <= security[i - 1] ? left[i] = left[i - 1] + 1 : 0;\\n        }\\n        for (int i = security.length - 2; i >= 0; i--) {\\n            right[i] = security[i] <= security[i + 1] ? right[i + 1] + 1 : 0;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < security.length; i++) {\\n            if (left[i] >= time && right[i] >= time) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for (int i = 1; i < n; i++) {\\n            left[i] = security[i] <= security[i - 1] ? left[i] = left[i - 1] + 1 : 0;\\n        }\\n        for (int i = security.length - 2; i >= 0; i--) {\\n            right[i] = security[i] <= security[i + 1] ? right[i + 1] + 1 : 0;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < security.length; i++) {\\n            if (left[i] >= time && right[i] >= time) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918725,
                "title": "best-solution-using-longest-increasing-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n=security.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        if(n==1)\\n        {\\n            if(time==0)return {0};\\n            return {};\\n        }\\n\\n        //longest increaing securityay from end\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                dp1[i]=1+dp1[i+1];\\n            }\\n        }\\n\\n        //longest decreasing subsecurityay form start\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                dp2[i]=1+dp2[i-1];\\n            }\\n        }\\n\\n        security.clear();\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if(i==0 && dp1[i]>=(time+1))\\n            {\\n                security.push_back(i);\\n            }\\n            else if(i==n-1 && dp2[i]>=(1+time))\\n            {\\n                security.push_back(i);\\n            }\\n            else if(dp2[i]>=(time+1) && dp1[i]>=(1+time))\\n            {\\n                security.push_back(i);\\n            }\\n        }\\n        return security;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n=security.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        if(n==1)\\n        {\\n            if(time==0)return {0};\\n            return {};\\n        }\\n\\n        //longest increaing securityay from end\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                dp1[i]=1+dp1[i+1];\\n            }\\n        }\\n\\n        //longest decreasing subsecurityay form start\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                dp2[i]=1+dp2[i-1];\\n            }\\n        }\\n\\n        security.clear();\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if(i==0 && dp1[i]>=(time+1))\\n            {\\n                security.push_back(i);\\n            }\\n            else if(i==n-1 && dp2[i]>=(1+time))\\n            {\\n                security.push_back(i);\\n            }\\n            else if(dp2[i]>=(time+1) && dp1[i]>=(1+time))\\n            {\\n                security.push_back(i);\\n            }\\n        }\\n        return security;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855010,
                "title": "a-single-cycle-o-n-space-runtime-c",
                "content": "# Approach\\n\\nWe create a vector of per-day analyse and for each day we store whether in the original array there\\'s enough left and right days. We default-initialize days with \"Ok\", and then only update a day when it turns out not to be \"ok\".\\n\\nSince we need to consider days both on the left and right sides, we do that simultaneously in the same cycle.\\n\\nThe obvious optimization here is that each cycle instead of cycling through `time` elements on the left and right side we simply store/update the index of the last found \"bad\" day, then we calculate the distance to it from the current day.\\n\\nAfter we did that for every day, it is only a matter of gathering all \"okayish\" days from the vector and returning the result. The easiest way would be to do that in a separate cycle *(this wouldn\\'t influence $$O()$$ anyway)*, but for just for the sake of exercise I put it in the same cycle where calculation is done.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(const vector<int>& security, int time) {\\n        enum State {Ok, Bad};\\n        vector<State> days_analysis(security.size());\\n        int i_left_bad_days = -1, i_mirrored_right_bad_days = -1;\\n        vector<int> ret;\\n        const size_t i_indices_meet_location = (security.size() + 2) / 2 -1;\\n        for (int i = 0; i < security.size(); ++i) {\\n            if (i > 0 && security[i-1] < security[i]) {\\n                i_left_bad_days = i-1;\\n            }\\n            if (i - i_left_bad_days -1 < time)\\n                days_analysis[i] = Bad;\\n\\n            size_t i_right = security.size() - 1 - i;\\n            if (i > 0 && security[i_right] > security[i_right+1]) {\\n                i_mirrored_right_bad_days = i-1;\\n            }\\n            if (i - i_mirrored_right_bad_days -1 < time)\\n                days_analysis[i_right] = Bad;\\n\\n            if (i >= i_indices_meet_location) {\\n                if (days_analysis[i] == Ok)\\n                    ret.push_back(i);\\n                if (days_analysis[i_right] == Ok && i != i_right)\\n                    ret.push_back(i_right);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(const vector<int>& security, int time) {\\n        enum State {Ok, Bad};\\n        vector<State> days_analysis(security.size());\\n        int i_left_bad_days = -1, i_mirrored_right_bad_days = -1;\\n        vector<int> ret;\\n        const size_t i_indices_meet_location = (security.size() + 2) / 2 -1;\\n        for (int i = 0; i < security.size(); ++i) {\\n            if (i > 0 && security[i-1] < security[i]) {\\n                i_left_bad_days = i-1;\\n            }\\n            if (i - i_left_bad_days -1 < time)\\n                days_analysis[i] = Bad;\\n\\n            size_t i_right = security.size() - 1 - i;\\n            if (i > 0 && security[i_right] > security[i_right+1]) {\\n                i_mirrored_right_bad_days = i-1;\\n            }\\n            if (i - i_mirrored_right_bad_days -1 < time)\\n                days_analysis[i_right] = Bad;\\n\\n            if (i >= i_indices_meet_location) {\\n                if (days_analysis[i] == Ok)\\n                    ret.push_back(i);\\n                if (days_analysis[i_right] == Ok && i != i_right)\\n                    ret.push_back(i_right);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852286,
                "title": "c-o-n-beats-100",
                "content": "# Intuition\\nA given index is valid if there are a atleast `time` number of indices before it that are non-increasing and atleast a `time` number of indices that are non-decreasing.\\n\\nFor a given index we keep track 2 arrays: \\n\\n**Array1:**  Keeps track of the number of elements that are non increasing before the `ith` element\\n\\n**Array2:** Keeps track of the number of elements that are non decreasing after the `ith` element\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // if prev <= cur then dp[cur] = dp[prev] + 1 else 0\\n    // reverse the arr, run the same, reverse the dp2 => gives increasing\\n    void getNonIncreasingCntAtIdx(vector<int>&nums, vector<int>&dp)\\n    {\\n        dp[0] = 0;\\n        int prev = nums[0];\\n        for (int i = 1; i < nums.size();i++)\\n        {\\n            dp[i] = prev >= nums[i]\\n                ? 1 + dp[i-1]\\n                : 0;\\n            prev = nums[i];\\n        }\\n\\n        return;\\n    }\\n\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> dp1(security.size(), 0);\\n        getNonIncreasingCntAtIdx(security, dp1);\\n\\n        vector<int> dp2(security.size(), 0);\\n        reverse(security.begin(), security.end());\\n        getNonIncreasingCntAtIdx(security, dp2);\\n        reverse(dp2.begin(), dp2.end());\\n\\n        vector<int> resArr;\\n        for (int i = 0; i < dp1.size(); i++)\\n        {\\n            if (time <= dp1[i] && time <= dp2[i])\\n                resArr.push_back(i);\\n        }\\n            \\n        return resArr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // if prev <= cur then dp[cur] = dp[prev] + 1 else 0\\n    // reverse the arr, run the same, reverse the dp2 => gives increasing\\n    void getNonIncreasingCntAtIdx(vector<int>&nums, vector<int>&dp)\\n    {\\n        dp[0] = 0;\\n        int prev = nums[0];\\n        for (int i = 1; i < nums.size();i++)\\n        {\\n            dp[i] = prev >= nums[i]\\n                ? 1 + dp[i-1]\\n                : 0;\\n            prev = nums[i];\\n        }\\n\\n        return;\\n    }\\n\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> dp1(security.size(), 0);\\n        getNonIncreasingCntAtIdx(security, dp1);\\n\\n        vector<int> dp2(security.size(), 0);\\n        reverse(security.begin(), security.end());\\n        getNonIncreasingCntAtIdx(security, dp2);\\n        reverse(dp2.begin(), dp2.end());\\n\\n        vector<int> resArr;\\n        for (int i = 0; i < dp1.size(); i++)\\n        {\\n            if (time <= dp1[i] && time <= dp2[i])\\n                resArr.push_back(i);\\n        }\\n            \\n        return resArr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849366,
                "title": "c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> left(n);\\n        left[0]=0;\\n        for(int i=1;i<n;i++)\\n            left[i]=(security[i-1]>=security[i]) ? left[i-1]+1 : 0 ; \\n\\n        vector<int> right(n);\\n        right[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=(security[i+1]>=security[i]) ? right[i+1]+1 : 0;\\n\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n            if(left[i]>=time &&  right[i]>=time)\\n                ans.push_back(i);\\n\\n        return ans;           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> left(n);\\n        left[0]=0;\\n        for(int i=1;i<n;i++)\\n            left[i]=(security[i-1]>=security[i]) ? left[i-1]+1 : 0 ; \\n\\n        vector<int> right(n);\\n        right[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=(security[i+1]>=security[i]) ? right[i+1]+1 : 0;\\n\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n            if(left[i]>=time &&  right[i]>=time)\\n                ans.push_back(i);\\n\\n        return ans;           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832765,
                "title": "most-optimized-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        \\n        int n = nums.size();\\n        int l = 0;\\n        int r = 0;\\n\\n        vector<int>ans;\\n\\n        for(int i = 0; i < n; i++) {\\n\\n            //left pointer\\n            if((i - 1) >= 0 && nums[i] > nums[i - 1]) {\\n                l = i;\\n            }\\n\\n            \\n            //right pointer\\n            if(r <= i) {\\n                r = i;\\n                while(r + 1 < n && nums[r] <= nums[r + 1]){\\n                    r++;\\n                }\\n            }\\n\\n\\n            cout<<l<<\" \"<<r<<endl;\\n\\n\\n            if(r - l + 1 >= time && l <= i - time && r >= i + time) ans.push_back(i);\\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        \\n        int n = nums.size();\\n        int l = 0;\\n        int r = 0;\\n\\n        vector<int>ans;\\n\\n        for(int i = 0; i < n; i++) {\\n\\n            //left pointer\\n            if((i - 1) >= 0 && nums[i] > nums[i - 1]) {\\n                l = i;\\n            }\\n\\n            \\n            //right pointer\\n            if(r <= i) {\\n                r = i;\\n                while(r + 1 < n && nums[r] <= nums[r + 1]){\\n                    r++;\\n                }\\n            }\\n\\n\\n            cout<<l<<\" \"<<r<<endl;\\n\\n\\n            if(r - l + 1 >= time && l <= i - time && r >= i + time) ans.push_back(i);\\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3822801,
                "title": "easy-to-understand-c-prefix-suffix-array-approach",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n        int n=s.size();\\n        vector<int>prefix(n, 1), suffix(n, 1);\\n        for(int i=1; i<n; i++){\\n            if(s[i]<=s[i-1]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(s[i]<=s[i+1]){\\n                suffix[i]=1+suffix[i+1];\\n            }\\n        }\\n        vector<int>res;\\n        for(int i=0; i<n; i++){\\n            if(prefix[i]>time && suffix[i]>time){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n        int n=s.size();\\n        vector<int>prefix(n, 1), suffix(n, 1);\\n        for(int i=1; i<n; i++){\\n            if(s[i]<=s[i-1]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(s[i]<=s[i+1]){\\n                suffix[i]=1+suffix[i+1];\\n            }\\n        }\\n        vector<int>res;\\n        for(int i=0; i<n; i++){\\n            if(prefix[i]>time && suffix[i]>time){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791326,
                "title": "ho-gya-bas-asan-h-ek-baar-click-ho-jaye-to",
                "content": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] nums, int k) {\\n        int n=nums.length ;\\n        ArrayList<Integer>list = new ArrayList<>() ;\\n        int right[]=new int[nums.length] ;\\n        int left[]=new int[nums.length] ;\\n        right[nums.length-1]=0 ;\\n        left[0]=0 ;\\n        for(int i=n-2; i>=0; i--) {\\n            if(nums[i]<=nums[i+1]) {\\n                right[i]=right[i+1]+1 ;\\n            }\\n            else {\\n                right[i]=0 ;\\n            }\\n        }\\n        for(int i=1; i<n; i++) {\\n            if(nums[i]<=nums[i-1]) {\\n                left[i]=left[i-1]+1 ;\\n            }\\n            else {\\n                left[i]=0; \\n            }\\n        }\\n        for(int i=k; i<n-k; i++) {\\n            if(left[i]>=k && right[i]>=k) {\\n                list.add(i) ;\\n            }\\n        }\\n        return list ;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] nums, int k) {\\n        int n=nums.length ;\\n        ArrayList<Integer>list = new ArrayList<>() ;\\n        int right[]=new int[nums.length] ;\\n        int left[]=new int[nums.length] ;\\n        right[nums.length-1]=0 ;\\n        left[0]=0 ;\\n        for(int i=n-2; i>=0; i--) {\\n            if(nums[i]<=nums[i+1]) {\\n                right[i]=right[i+1]+1 ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3789480,
                "title": "nonincrearese-nondecrease-slices",
                "content": "\\n# Code\\n```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n\\tnonInc := make([]int, len(security)+1)\\n\\tnonDec := make([]int, len(security)+1)\\n\\tfor i := 1; i < len(security); i++ {\\n\\t\\tif security[i] <= security[i-1] {\\n\\t\\t\\tnonInc[i] += nonInc[i-1]+1\\n\\t\\t}\\n\\n\\t\\tif security[i] >= security[i-1] {\\n\\t\\t\\tnonDec[i] += nonDec[i-1]+1\\n\\t\\t}\\n\\t}\\n\\n\\tout := make([]int, 0)\\n\\tfor i := time; i < len(security)-time; i++ {\\n\\t\\tif nonInc[i] >= time && nonDec[i+time] >= time {\\n\\t\\t\\tout = append(out, i)\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n\\tnonInc := make([]int, len(security)+1)\\n\\tnonDec := make([]int, len(security)+1)\\n\\tfor i := 1; i < len(security); i++ {\\n\\t\\tif security[i] <= security[i-1] {\\n\\t\\t\\tnonInc[i] += nonInc[i-1]+1\\n\\t\\t}\\n\\n\\t\\tif security[i] >= security[i-1] {\\n\\t\\t\\tnonDec[i] += nonDec[i-1]+1\\n\\t\\t}\\n\\t}\\n\\n\\tout := make([]int, 0)\\n\\tfor i := time; i < len(security)-time; i++ {\\n\\t\\tif nonInc[i] >= time && nonDec[i+time] >= time {\\n\\t\\t\\tout = append(out, i)\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729156,
                "title": "python-easy-solution-prefix-suffix-in-o-n",
                "content": "# Intuition\\r\\nAt every index, if we can somehow find the number of decreasing days from its left, and the number of increasing days to its right, we can check if today is a good day to rob by simply checking if ```(number of decreasing days from left >= time) and (number of increasing days to right >= k)```\\r\\n# Approach\\r\\nThis questions requires us to generate prefix and suffix arrays for what we want to do. For the array ```decreasing```, we start by iterating through ```security``` one by one, each time calculating if ```security``` has been consecutively decreasing or not. If we find an element that increases, we reset the consecutive counter to 0.\\r\\n\\r\\nWe do a similar thing for the increasing array, except here, we start moving from the right side down to the left.\\r\\n\\r\\nI\\'ve expanded the code to make it more readable, though you may have clearly observed some opportunities to do the same with lesser lines of code and more compact loops.\\r\\n\\r\\nThe final loop runs between ``` [time, n - time)```, which is ```[time, n-time-1]``` in mathematical bounds.\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(N) to make the prefix array, O(N) to make the suffix array, and O(N) to compute the solution.\\r\\n=> O(3N), which is O(N).\\r\\n- Space complexity:\\r\\nO(2N) to store the prefix and the suffix arrays, though this can be reduced to O(N) by combining them into a single array (try this as an exercise!)\\r\\n=> O(2N), which is O(N).\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\r\\n        n = len(security)\\r\\n\\r\\n        decreasing = [0] * n\\r\\n        consec = 0\\r\\n        for i in range(1, n):\\r\\n            if security[i] <= security[i - 1]:\\r\\n                consec += 1\\r\\n                decreasing[i] = consec\\r\\n            else:\\r\\n                consec = 0\\r\\n                decreasing[i] = consec\\r\\n\\r\\n        increasing = [0] * n\\r\\n        consec = 0\\r\\n        for i in range(n - 2, -1, -1):\\r\\n            if security[i + 1] >= security[i]:\\r\\n                consec += 1\\r\\n                increasing[i] = consec\\r\\n            else:\\r\\n                consec = 0\\r\\n                increasing[i] = consec\\r\\n\\r\\n        ans = []\\r\\n        for i in range(time, n - time):\\r\\n            if increasing[i] >= time and decreasing[i] >= time:\\r\\n                ans.append(i)\\r\\n        return ans\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```(number of decreasing days from left >= time) and (number of increasing days to right >= k)```\n```decreasing```\n```security```\n```security```\n``` [time, n - time)```\n```[time, n-time-1]```\n```\\r\\nclass Solution:\\r\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\r\\n        n = len(security)\\r\\n\\r\\n        decreasing = [0] * n\\r\\n        consec = 0\\r\\n        for i in range(1, n):\\r\\n            if security[i] <= security[i - 1]:\\r\\n                consec += 1\\r\\n                decreasing[i] = consec\\r\\n            else:\\r\\n                consec = 0\\r\\n                decreasing[i] = consec\\r\\n\\r\\n        increasing = [0] * n\\r\\n        consec = 0\\r\\n        for i in range(n - 2, -1, -1):\\r\\n            if security[i + 1] >= security[i]:\\r\\n                consec += 1\\r\\n                increasing[i] = consec\\r\\n            else:\\r\\n                consec = 0\\r\\n                increasing[i] = consec\\r\\n\\r\\n        ans = []\\r\\n        for i in range(time, n - time):\\r\\n            if increasing[i] >= time and decreasing[i] >= time:\\r\\n                ans.append(i)\\r\\n        return ans\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698386,
                "title": "set",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf there are at least time adjacent pairs that is non-incresing, then the last index of the element could be a candidate.\\n\\nSimilarly, we could find all indices satisfying the non-decreasing condition.\\n\\nSince the for loop doesn\\'t consider the first and last element if time = 0, return all indices, else return intersection of the two sets.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if time == 0:\\n            return [i for i in range(len(security))]\\n\\n        ni = set()\\n        nd = set()\\n        count = 0\\n\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i-1]:\\n                count += 1\\n            else:\\n                count = 0\\n            \\n            if count >= time:\\n                ni.add(i)\\n\\n        count = 0\\n\\n        for i in range(len(security)-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n            \\n            if count >= time:\\n                nd.add(i)\\n\\n        return list(ni&nd)     \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if time == 0:\\n            return [i for i in range(len(security))]\\n\\n        ni = set()\\n        nd = set()\\n        count = 0\\n\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i-1]:\\n                count += 1\\n            else:\\n                count = 0\\n            \\n            if count >= time:\\n                ni.add(i)\\n\\n        count = 0\\n\\n        for i in range(len(security)-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n            \\n            if count >= time:\\n                nd.add(i)\\n\\n        return list(ni&nd)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696838,
                "title": "two-arrays-right-to-left-and-left-to-right-for-maintaining-the-incresing-and-decreasing-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] nums, int time) {\\n        int []ltr=new int [nums.length];\\n        for(int i=1;i<ltr.length;i++){\\n            if(nums[i]<=nums[i-1]){\\n                ltr[i]=ltr[i-1]+1;\\n            }\\n        }\\n        int []rtl=new int[nums.length];\\n        rtl[nums.length-1]=0;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                rtl[i]=rtl[i+1]+1;\\n            }\\n        }\\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<rtl.length;i++){\\n            if(ltr[i]>=time && rtl[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] nums, int time) {\\n        int []ltr=new int [nums.length];\\n        for(int i=1;i<ltr.length;i++){\\n            if(nums[i]<=nums[i-1]){\\n                ltr[i]=ltr[i-1]+1;\\n            }\\n        }\\n        int []rtl=new int[nums.length];\\n        rtl[nums.length-1]=0;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                rtl[i]=rtl[i+1]+1;\\n            }\\n        }\\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<rtl.length;i++){\\n            if(ltr[i]>=time && rtl[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686968,
                "title": "javascript-2100-find-good-days-to-rob-the-bank",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// a[i - t] >= a[i - t + 1] >= ... >=                 (decreasing)\\n//        a[i]\\n//               <= ... <= a[i + t - 1] <= a[i + t]   (increasing)\\nvar goodDaysToRobBank = function (a, t) {\\n  let an = [];\\n  for (let i = t; i + t < a.length; i++) {\\n    let bad = 0\\n    for (let j = i - t + 1; j <= i; j++)\\n      if (a[j - 1] < a[j]) {\\n        bad = 1; // increasing\\n        break\\n      }\\n    for (let j = i + 1; j <= i + t; j++)\\n      if (a[j - 1] > a[j]) {\\n        bad = 1; // decreasing\\n        break\\n      }\\n    if (!bad) {\\n      an.push(i)\\n    }\\n  }\\n  return an;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// a[i - t] >= a[i - t + 1] >= ... >=                 (decreasing)\\n//        a[i]\\n//               <= ... <= a[i + t - 1] <= a[i + t]   (increasing)\\nvar goodDaysToRobBank = function (a, t) {\\n  let an = [];\\n  for (let i = t; i + t < a.length; i++) {\\n    let bad = 0\\n    for (let j = i - t + 1; j <= i; j++)\\n      if (a[j - 1] < a[j]) {\\n        bad = 1; // increasing\\n        break\\n      }\\n    for (let j = i + 1; j <= i + t; j++)\\n      if (a[j - 1] > a[j]) {\\n        bad = 1; // decreasing\\n        break\\n      }\\n    if (!bad) {\\n      an.push(i)\\n    }\\n  }\\n  return an;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3672046,
                "title": "python3-simple-prefix-suffix-array",
                "content": "# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        N = len(security)\\n        prefix = [0]*N\\n        cnt = 0\\n        for i in range(1, N):\\n            if security[i-1]>=security[i]:\\n                cnt+=1\\n            else:\\n                cnt = 0\\n            prefix[i] = cnt\\n\\n        suffix = [0]*N\\n        cnt = 0\\n        for i in range(N-2, -1, -1):\\n            if security[i]<=security[i+1]:\\n                cnt+=1\\n            else:\\n                cnt = 0\\n            suffix[i] = cnt\\n\\n        ansArr = []\\n        for i in range(N):\\n            if prefix[i]>=time and suffix[i]>=time:\\n                ansArr.append(i)\\n            \\n        return ansArr\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        N = len(security)\\n        prefix = [0]*N\\n        cnt = 0\\n        for i in range(1, N):\\n            if security[i-1]>=security[i]:\\n                cnt+=1\\n            else:\\n                cnt = 0\\n            prefix[i] = cnt\\n\\n        suffix = [0]*N\\n        cnt = 0\\n        for i in range(N-2, -1, -1):\\n            if security[i]<=security[i+1]:\\n                cnt+=1\\n            else:\\n                cnt = 0\\n            suffix[i] = cnt\\n\\n        ansArr = []\\n        for i in range(N):\\n            if prefix[i]>=time and suffix[i]>=time:\\n                ansArr.append(i)\\n            \\n        return ansArr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654874,
                "title": "cpp-prefix-suffix-array-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size();\\n        vector<int> pre(n,0),post(n,0),ans;\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]) pre[i]=pre[i-1]+1;\\n            if(arr[n-i-1]<=arr[n-i]) post[n-i-1]=post[n-i]+1;\\n        }\\n        \\n        for(int i=0+time;i<n-time;i++){\\n            if(pre[i]>=time and post[i]>=time) ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size();\\n        vector<int> pre(n,0),post(n,0),ans;\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]) pre[i]=pre[i-1]+1;\\n            if(arr[n-i-1]<=arr[n-i]) post[n-i-1]=post[n-i]+1;\\n        }\\n        \\n        for(int i=0+time;i<n-time;i++){\\n            if(pre[i]>=time and post[i]>=time) ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652176,
                "title": "easy-dp-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = arr.length;\\n        int[] r = new int[n];\\n        int[] l = new int[n];\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]){\\n                l[i] = l[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i+1]>=arr[i]){\\n                r[i] = r[i+1] + 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(l[i]>=time && r[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = arr.length;\\n        int[] r = new int[n];\\n        int[] l = new int[n];\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]){\\n                l[i] = l[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i+1]>=arr[i]){\\n                r[i] = r[i+1] + 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(l[i]>=time && r[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652175,
                "title": "easy-dp-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = arr.length;\\n        int[] r = new int[n];\\n        int[] l = new int[n];\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]){\\n                l[i] = l[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i+1]>=arr[i]){\\n                r[i] = r[i+1] + 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(l[i]>=time && r[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = arr.length;\\n        int[] r = new int[n];\\n        int[] l = new int[n];\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]){\\n                l[i] = l[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i+1]>=arr[i]){\\n                r[i] = r[i+1] + 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(l[i]>=time && r[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648264,
                "title": "rust-prefix-arrays-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        let mut p1 = vec![0; security.len()];\\n        for i in 1..p1.len() {\\n            if security[i - 1] >= security[i] {\\n                p1[i] = 1 + p1[i - 1];\\n            }\\n        }\\n        // println!(\"{:?}\", p1);\\n\\n        let mut p2 = vec![0; security.len()];\\n        for i in (0..p2.len()-1).rev() {\\n            if security[i + 1] >= security[i] {\\n                p2[i] = 1 + p2[i + 1];\\n            }\\n        }\\n        // println!(\"{:?}\", p2);\\n\\n        let mut ans = vec![];\\n\\n        for i in 0..security.len() {\\n            if p1[i] >= time && p2[i] >= time {\\n                ans.push(i as i32);\\n            }\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        let mut p1 = vec![0; security.len()];\\n        for i in 1..p1.len() {\\n            if security[i - 1] >= security[i] {\\n                p1[i] = 1 + p1[i - 1];\\n            }\\n        }\\n        // println!(\"{:?}\", p1);\\n\\n        let mut p2 = vec![0; security.len()];\\n        for i in (0..p2.len()-1).rev() {\\n            if security[i + 1] >= security[i] {\\n                p2[i] = 1 + p2[i + 1];\\n            }\\n        }\\n        // println!(\"{:?}\", p2);\\n\\n        let mut ans = vec![];\\n\\n        for i in 0..security.len() {\\n            if p1[i] >= time && p2[i] >= time {\\n                ans.push(i as i32);\\n            }\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640549,
                "title": "easy-clean-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<pair<int,int>> dp(n,{0,0});\\n        for(int i=0; i<n-1; i++) {\\n              dp[i+1].first = security[i] >= security[i+1] ? 1 + dp[i].first : 0;\\n        }\\n        for(int i=n-2; i>=0; i--) {\\n             dp[i].second = security[i] <= security[i+1] ? 1 + dp[i+1].second : 0; \\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n              if(min(dp[i].first,dp[i].second)>=time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<pair<int,int>> dp(n,{0,0});\\n        for(int i=0; i<n-1; i++) {\\n              dp[i+1].first = security[i] >= security[i+1] ? 1 + dp[i].first : 0;\\n        }\\n        for(int i=n-2; i>=0; i--) {\\n             dp[i].second = security[i] <= security[i+1] ? 1 + dp[i+1].second : 0; \\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n              if(min(dp[i].first,dp[i].second)>=time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580007,
                "title": "very-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int>pre(n,0);\\n        vector<int>suf(n,0);\\n        for(int i=1;i<n;i++){\\n            if(security[i]<=security[i-1]){\\n                pre[i]=pre[i-1]+1;\\n            }\\n            else{\\n                pre[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                suf[i]=suf[i+1]+1;\\n            }\\n            else{\\n                suf[i]=0;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(pre[i]>=time && suf[i]>=time)ans.push_back(i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int>pre(n,0);\\n        vector<int>suf(n,0);\\n        for(int i=1;i<n;i++){\\n            if(security[i]<=security[i-1]){\\n                pre[i]=pre[i-1]+1;\\n            }\\n            else{\\n                pre[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                suf[i]=suf[i+1]+1;\\n            }\\n            else{\\n                suf[i]=0;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(pre[i]>=time && suf[i]>=time)ans.push_back(i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524810,
                "title": "c-3-iterations-to-find-collect-v-shape",
                "content": "- Need to find `V-shape` indices with left/right V size `>= time`\\n- Iterate left to right, and right to left, to generate the `V size`\\n- A 3rd iterate to collect all `valid indices`\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> decs(n), incs(n);\\n        for(int i = 1;   i < n;  ++i) decs[i] = (security[i] <= security[i-1] ? decs[i-1] + 1 : 0);\\n        for(int i = n-2; i >= 0; --i) incs[i] = (security[i] <= security[i+1] ? incs[i+1] + 1 : 0);\\n            \\n        vector<int> ans;\\n        for(int i = time; i < n - time; ++i) {\\n            if(decs[i]>= time && incs[i] >= time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> decs(n), incs(n);\\n        for(int i = 1;   i < n;  ++i) decs[i] = (security[i] <= security[i-1] ? decs[i-1] + 1 : 0);\\n        for(int i = n-2; i >= 0; --i) incs[i] = (security[i] <= security[i+1] ? incs[i+1] + 1 : 0);\\n            \\n        vector<int> ans;\\n        for(int i = time; i < n - time; ++i) {\\n            if(decs[i]>= time && incs[i] >= time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511082,
                "title": "c-1-boolean-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int t) {\\n        int c = 0, prev = INT_MAX;\\n        vector<bool> h(s.size());\\n        for (int i = 0; i < s.size(); ++i){\\n            c = s[i] <= prev ? ++c : 1;\\n            prev = s[i];\\n            h[i] = c > t;\\n        }\\n        vector<int> ans;\\n        for (int i = s.size() - 1, c = 0, prev = INT_MAX; i >= 0; --i) {\\n            c = abs(s[i] <= prev) ? ++c : 1;\\n            prev = abs(s[i]);\\n            if (c > t && h[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int t) {\\n        int c = 0, prev = INT_MAX;\\n        vector<bool> h(s.size());\\n        for (int i = 0; i < s.size(); ++i){\\n            c = s[i] <= prev ? ++c : 1;\\n            prev = s[i];\\n            h[i] = c > t;\\n        }\\n        vector<int> ans;\\n        for (int i = s.size() - 1, c = 0, prev = INT_MAX; i >= 0; --i) {\\n            c = abs(s[i] <= prev) ? ++c : 1;\\n            prev = abs(s[i]);\\n            if (c > t && h[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493053,
                "title": "python3-clean-prefix-and-suffix-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        n=len(security)\\n        prefix=[0]\\n        \\n        for i in range(1,n):\\n            if security[i-1]>=security[i]:\\n                prefix.append(prefix[-1]+1)\\n            \\n            else:\\n                prefix.append(0)\\n        \\n        suffix=[0]\\n        \\n        for i in range(n-2,-1,-1):\\n            if security[i]<=security[i+1]:\\n                suffix.append(suffix[-1]+1)\\n            else:\\n                suffix.append(0)\\n        \\n        \\n        suffix.reverse()\\n        \\n        \\n        ans=[]\\n        \\n        for i in range(time,n-time):\\n            if prefix[i]>=time and suffix[i]>=time:\\n                ans.append(i)\\n    \\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        n=len(security)\\n        prefix=[0]\\n        \\n        for i in range(1,n):\\n            if security[i-1]>=security[i]:\\n                prefix.append(prefix[-1]+1)\\n            \\n            else:\\n                prefix.append(0)\\n        \\n        suffix=[0]\\n        \\n        for i in range(n-2,-1,-1):\\n            if security[i]<=security[i+1]:\\n                suffix.append(suffix[-1]+1)\\n            else:\\n                suffix.append(0)\\n        \\n        \\n        suffix.reverse()\\n        \\n        \\n        ans=[]\\n        \\n        for i in range(time,n-time):\\n            if prefix[i]>=time and suffix[i]>=time:\\n                ans.append(i)\\n    \\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482767,
                "title": "create-new-prefix-and-suffix-vector-and-comparing-w-given-vector",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\n        int n=security.size();\\n        vector<int>prefix(n,0);\\n        vector<int>sufix(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        \\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i]){\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n        }\\n        \\n        vector<int>ans;\\n\\n        for(int i=time;i<n-time;i++){\\n            if(prefix[i]>=time && sufix[i]>=time){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\n        int n=security.size();\\n        vector<int>prefix(n,0);\\n        vector<int>sufix(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        \\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i]){\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n        }\\n        \\n        vector<int>ans;\\n\\n        for(int i=time;i<n-time;i++){\\n            if(prefix[i]>=time && sufix[i]>=time){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449814,
                "title": "c-o-n-beats-97-commented-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        int n=nums.size();\\n        if(n<=2*time) return {};\\n        vector<int> n_inc(n); // inc[i] stores the maximum size of subarray ending at i and is in non-incresing order; something like prefix \\n        vector<int> n_dec(n); // dec[i] stores the maximum size of subarray starting at i and is in non-decreasing order; something like suffixes\\n        vector<int> ans;\\n        int s=1;\\n        n_inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n                s=1;\\n                n_inc[i]=1;\\n            }\\n            else{\\n                n_inc[i]=++s;\\n            }\\n        }\\n        s=1;\\n        n_dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1]){\\n                s=1;\\n                n_dec[i]=1;\\n            }\\n            else{\\n                n_dec[i]=++s;\\n            }\\n        }\\n        for(int i=time;i<n-time;i++){\\n            if(n_inc[i]>time && n_dec[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        int n=nums.size();\\n        if(n<=2*time) return {};\\n        vector<int> n_inc(n); // inc[i] stores the maximum size of subarray ending at i and is in non-incresing order; something like prefix \\n        vector<int> n_dec(n); // dec[i] stores the maximum size of subarray starting at i and is in non-decreasing order; something like suffixes\\n        vector<int> ans;\\n        int s=1;\\n        n_inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n                s=1;\\n                n_inc[i]=1;\\n            }\\n            else{\\n                n_inc[i]=++s;\\n            }\\n        }\\n        s=1;\\n        n_dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1]){\\n                s=1;\\n                n_dec[i]=1;\\n            }\\n            else{\\n                n_dec[i]=++s;\\n            }\\n        }\\n        for(int i=time;i<n-time;i++){\\n            if(n_inc[i]>time && n_dec[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436060,
                "title": "c-1d-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& x, int time) {\\n        int n = int(x.size());\\n        int dp1[n];\\n        dp1[0] = 1;\\n        for(int i = 1 ; i < n ; ++i){\\n            if(x[i] <= x[i-1]) dp1[i] = 1 + dp1[i-1];\\n            else dp1[i] = 1;\\n        }\\n        int dp2[n];\\n        dp2[n-1] = 1;\\n        for(int i = n - 2;  i >= 0 ; --i){\\n            if(x[i] <= x[i+1]) dp2[i] = 1 + dp2[i+1];\\n            else dp2[i] = 1;\\n        }\\n        vector<int> res;\\n        for(int i = 0 ; i < n ; ++i){\\n            if(i - time < 0 ) continue;\\n            if(i + time > (n-1)) continue;\\n            int a = dp1[i];\\n            int b = dp2[i];\\n            int want = time + 1 ;\\n            if(a >= want and b >= want) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& x, int time) {\\n        int n = int(x.size());\\n        int dp1[n];\\n        dp1[0] = 1;\\n        for(int i = 1 ; i < n ; ++i){\\n            if(x[i] <= x[i-1]) dp1[i] = 1 + dp1[i-1];\\n            else dp1[i] = 1;\\n        }\\n        int dp2[n];\\n        dp2[n-1] = 1;\\n        for(int i = n - 2;  i >= 0 ; --i){\\n            if(x[i] <= x[i+1]) dp2[i] = 1 + dp2[i+1];\\n            else dp2[i] = 1;\\n        }\\n        vector<int> res;\\n        for(int i = 0 ; i < n ; ++i){\\n            if(i - time < 0 ) continue;\\n            if(i + time > (n-1)) continue;\\n            int a = dp1[i];\\n            int b = dp2[i];\\n            int want = time + 1 ;\\n            if(a >= want and b >= want) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418344,
                "title": "c-complexity-time-space-o-n-o-1-without-additional-vectors",
                "content": "1. Using precalculations for the first day\\n2. For each next day, the number of days that do not increase and the number of days that do not decrease can be calculated by knowing them for the current day and the difference between them.\\n\\n# Complexity\\n- Time complexity: *O(n)*\\n- Space complexity: *O(1)*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> res;\\n        auto size = security.size();\\n\\n        // no day is good if the time is more than half of the entire range\\n        if (time >= (size + 1) / 2) return res;\\n\\n        // we count the number of descents before and\\n        // ascents after first of the potential days\\n        int before = time;\\n        for (size_t i = time; i > 0; i--)\\n            if (security[i] > security[i - 1]) {\\n                before = time - i;\\n                break;\\n            }\\n        int after = time;\\n        for (int i = time * 2; i > time; i--)\\n            if (security[i] < security[i - 1]) {\\n                after = time * 2 - i;\\n                break;\\n            }\\n        \\n        // cycle from the first to the penultimate of the potential days\\n        int end = size - time - 1;\\n        for (int l = time, r = time * 2; l < end; l++, r++) {\\n            // check the main condition\\n            if ((before >= time) and (after >= time)) res.push_back(l);\\n\\n            // we count the number of descents before and\\n            // ascents after for the next day\\n            if (security[r] > security[r+1]) after = 0;\\n            else                             after++;\\n\\n            if (security[l] < security[l + 1]) before = 0;\\n            else                               before++;\\n        }\\n        //check the condition for the last potential day\\n        if (before >= time and after >= time)\\n            res.push_back(size - time - 1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> res;\\n        auto size = security.size();\\n\\n        // no day is good if the time is more than half of the entire range\\n        if (time >= (size + 1) / 2) return res;\\n\\n        // we count the number of descents before and\\n        // ascents after first of the potential days\\n        int before = time;\\n        for (size_t i = time; i > 0; i--)\\n            if (security[i] > security[i - 1]) {\\n                before = time - i;\\n                break;\\n            }\\n        int after = time;\\n        for (int i = time * 2; i > time; i--)\\n            if (security[i] < security[i - 1]) {\\n                after = time * 2 - i;\\n                break;\\n            }\\n        \\n        // cycle from the first to the penultimate of the potential days\\n        int end = size - time - 1;\\n        for (int l = time, r = time * 2; l < end; l++, r++) {\\n            // check the main condition\\n            if ((before >= time) and (after >= time)) res.push_back(l);\\n\\n            // we count the number of descents before and\\n            // ascents after for the next day\\n            if (security[r] > security[r+1]) after = 0;\\n            else                             after++;\\n\\n            if (security[l] < security[l + 1]) before = 0;\\n            else                               before++;\\n        }\\n        //check the condition for the last potential day\\n        if (before >= time and after >= time)\\n            res.push_back(size - time - 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336351,
                "title": "c-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> pref(n);\\n        vector<int> suff(n);\\n        pref[0] = 1;\\n        suff[n-1] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            pref[i] = pref[i-1]+1;\\n            else\\n            pref[i] = 1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            suff[i] = suff[i+1]+1;\\n            else\\n            suff[i] = 1;\\n        }\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if(nums[i]<=nums[i-1] && nums[i]<=nums[i+1])\\n            {\\n                if(pref[i-1]>=time && suff[i+1]>=time)\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> pref(n);\\n        vector<int> suff(n);\\n        pref[0] = 1;\\n        suff[n-1] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            pref[i] = pref[i-1]+1;\\n            else\\n            pref[i] = 1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            suff[i] = suff[i+1]+1;\\n            else\\n            suff[i] = 1;\\n        }\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if(nums[i]<=nums[i-1] && nums[i]<=nums[i+1])\\n            {\\n                if(pref[i-1]>=time && suff[i+1]>=time)\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332420,
                "title": "python3-decreasing-and-increasing-stack-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrimer: I know there are other solution which solve this problem, by going through the stack two times from left and from right in order to count the increasing and decreasing days at a current point in time. That is totally valid and even better than my approach (less memory). I just wanted to present another approach to solving this problem.\\n\\nFrom the description we know that we need a non-increasing stack on the left and a non decreasing stack on the right side.\\n\\nwe update these stacks with every step in the array and check whether they have the expected length.\\n\\nOnce we introduce an element that does not adhere to the property (is increasing to the left and decreasing to the right), we clear the stacks and start new.\\n\\nas long as both stacks have the expected length of time+1 (with the element in the middle), we can add the index to the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMonotonic Stacks\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(time+1)\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # trivial case for a too short array\\n        result = []\\n        if len(security) < 2*time+1:\\n            return result\\n        if not time:\\n            return list(range(len(security)))\\n        \\n        # make a sliding window with decreasing stack at the left\\n        # and increasing stack at the right\\n        left = collections.deque()\\n        right = collections.deque()\\n        for idx in range(time+1):\\n            while right and right[-1] < security[idx]:\\n                right.pop()\\n            right.append(security[idx])\\n        # go through the elements\\n        for idx, ele in enumerate(security[:-time]):\\n\\n            # check pop from the stack as long as the left element\\n            # is smaller\\n            while left and len(left) >= time+1:\\n                left.popleft()\\n            if left and ele > left[-1]:\\n                left.clear()\\n            left.append(ele)\\n            \\n            # check whether both stacks have length time\\n            if len(left) == time+1 and len(right) == time+1:\\n                result.append(idx)\\n            if idx == len(security)-time-1:\\n                break\\n\\n            # steal from the right side\\n            while right and len(right) >= time+1:\\n                right.popleft()\\n            if right and security[idx+time+1] < right[-1]:\\n                right.clear()\\n            right.append(security[idx+time+1])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # trivial case for a too short array\\n        result = []\\n        if len(security) < 2*time+1:\\n            return result\\n        if not time:\\n            return list(range(len(security)))\\n        \\n        # make a sliding window with decreasing stack at the left\\n        # and increasing stack at the right\\n        left = collections.deque()\\n        right = collections.deque()\\n        for idx in range(time+1):\\n            while right and right[-1] < security[idx]:\\n                right.pop()\\n            right.append(security[idx])\\n        # go through the elements\\n        for idx, ele in enumerate(security[:-time]):\\n\\n            # check pop from the stack as long as the left element\\n            # is smaller\\n            while left and len(left) >= time+1:\\n                left.popleft()\\n            if left and ele > left[-1]:\\n                left.clear()\\n            left.append(ele)\\n            \\n            # check whether both stacks have length time\\n            if len(left) == time+1 and len(right) == time+1:\\n                result.append(idx)\\n            if idx == len(security)-time-1:\\n                break\\n\\n            # steal from the right side\\n            while right and len(right) >= time+1:\\n                right.popleft()\\n            if right and security[idx+time+1] < right[-1]:\\n                right.clear()\\n            right.append(security[idx+time+1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327168,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> ans;\\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> left(n,0);\\n        vector<int> right(n,0);\\n        \\n        left[0]=1;\\n        int curr=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                curr++;\\n                left[i]=curr;\\n            }\\n            else\\n            {\\n                curr=1;\\n                left[i]=curr;\\n            }\\n        }\\n\\n        right[n-1]=1;\\n        curr=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                curr++;\\n                right[i]=curr;\\n            }\\n            else\\n            {\\n                curr=1;\\n                right[i]=curr;\\n            }\\n        }\\n        \\n        for(int i=time;i<n-time;i++)\\n        {\\n            if((left[i]-left[i-time]>=time) and (right[i]-right[i+time]>=time))\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> ans;\\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> left(n,0);\\n        vector<int> right(n,0);\\n        \\n        left[0]=1;\\n        int curr=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                curr++;\\n                left[i]=curr;\\n            }\\n            else\\n            {\\n                curr=1;\\n                left[i]=curr;\\n            }\\n        }\\n\\n        right[n-1]=1;\\n        curr=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                curr++;\\n                right[i]=curr;\\n            }\\n            else\\n            {\\n                curr=1;\\n                right[i]=curr;\\n            }\\n        }\\n        \\n        for(int i=time;i<n-time;i++)\\n        {\\n            if((left[i]-left[i-time]>=time) and (right[i]-right[i+time]>=time))\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316551,
                "title": "rust-elixir-with-2-counters",
                "content": "No extra space used for Rust. O(n) space for Elixir due to Enum functions.\\n# Code\\n```rust []\\nimpl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        if time == 0 {\\n            return (0..security.len() as i32).collect();\\n        }\\n        let time = time as usize;\\n        let mut incr = 0;\\n        let mut decr = 0;\\n        let mut ans = Vec::new();\\n        for i in 1 + time..security.len() {\\n            if security[i - time] <= security[i - time - 1] {\\n                decr += 1;\\n            }\\n            else {\\n                decr = 0;\\n            }\\n            if security[i] >= security[i - 1] {\\n                incr += 1;\\n            }\\n            else {\\n                incr = 0;\\n            }\\n            if incr >= time && decr >= time {\\n                ans.push((i - time) as i32);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec good_days_to_rob_bank(security :: [integer], time :: integer) :: [integer]\\n  def good_days_to_rob_bank(security, 0), do: Enum.to_list(0..length(security) - 1)\\n  def good_days_to_rob_bank(security, time) do\\n    Enum.drop(security, time)\\n    |> count_order(&Kernel.<=/2)\\n    |> Enum.zip(\\n      count_order(security, &Kernel.>=/2)\\n    )\\n    |> Enum.with_index(1)\\n    |> Enum.flat_map(fn {{incr, decr}, i} ->\\n      if incr >= time and decr >= time, do: [i], else: []\\n    end)\\n  end\\n\\n  defp count_order(list, fun) do\\n    Enum.chunk_every(list, 2, 1, :discard)\\n    |> Enum.map_reduce(0, fn [x, y], acc ->\\n      if fun.(x, y) do\\n        {acc + 1, acc + 1}\\n      else\\n        {0, 0}\\n      end\\n    end)\\n    |> elem(0)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir"
                ],
                "code": "```rust []\\nimpl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        if time == 0 {\\n            return (0..security.len() as i32).collect();\\n        }\\n        let time = time as usize;\\n        let mut incr = 0;\\n        let mut decr = 0;\\n        let mut ans = Vec::new();\\n        for i in 1 + time..security.len() {\\n            if security[i - time] <= security[i - time - 1] {\\n                decr += 1;\\n            }\\n            else {\\n                decr = 0;\\n            }\\n            if security[i] >= security[i - 1] {\\n                incr += 1;\\n            }\\n            else {\\n                incr = 0;\\n            }\\n            if incr >= time && decr >= time {\\n                ans.push((i - time) as i32);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec good_days_to_rob_bank(security :: [integer], time :: integer) :: [integer]\\n  def good_days_to_rob_bank(security, 0), do: Enum.to_list(0..length(security) - 1)\\n  def good_days_to_rob_bank(security, time) do\\n    Enum.drop(security, time)\\n    |> count_order(&Kernel.<=/2)\\n    |> Enum.zip(\\n      count_order(security, &Kernel.>=/2)\\n    )\\n    |> Enum.with_index(1)\\n    |> Enum.flat_map(fn {{incr, decr}, i} ->\\n      if incr >= time and decr >= time, do: [i], else: []\\n    end)\\n  end\\n\\n  defp count_order(list, fun) do\\n    Enum.chunk_every(list, 2, 1, :discard)\\n    |> Enum.map_reduce(0, fn [x, y], acc ->\\n      if fun.(x, y) do\\n        {acc + 1, acc + 1}\\n      else\\n        {0, 0}\\n      end\\n    end)\\n    |> elem(0)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3315355,
                "title": "java-dp-prefix-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        prefix[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1])\\n                prefix[i] = 1 + prefix[i - 1];\\n            else\\n                prefix[i] = 0;\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1])\\n                suffix[i] = 1 + suffix[i + 1];\\n            else \\n                suffix[i] = 0;\\n        }\\n        List<Integer> list = new ArrayList();\\n        for(int i = time; i < n - time; i++) {\\n            if(prefix[i] >= time && suffix[i] >= time)\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        prefix[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1])\\n                prefix[i] = 1 + prefix[i - 1];\\n            else\\n                prefix[i] = 0;\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1])\\n                suffix[i] = 1 + suffix[i + 1];\\n            else \\n                suffix[i] = 0;\\n        }\\n        List<Integer> list = new ArrayList();\\n        for(int i = time; i < n - time; i++) {\\n            if(prefix[i] >= time && suffix[i] >= time)\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293867,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        auto vl = leftGood(security, time);\\n        reverse(security.begin(), security.end());\\n        auto vr = leftGood(security, time);\\n        reverse(vr.begin(), vr.end());\\n        vector<int> res;\\n        for(int i=0;i<vr.size();i++){\\n            if(vl[i] && vr[i]) res.push_back(i);\\n        }\\n        return res;\\n    }\\n\\n    vector<bool> leftGood(vector<int>& v, int t){\\n        int cnt = 0;\\n        vector<bool> res;\\n        for(int i=0;i<v.size();i++){\\n            if(i>0){\\n                if(v[i] <= v[i-1]) cnt++;\\n                else cnt = 0; \\n            }\\n            res.push_back(cnt >= t);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        auto vl = leftGood(security, time);\\n        reverse(security.begin(), security.end());\\n        auto vr = leftGood(security, time);\\n        reverse(vr.begin(), vr.end());\\n        vector<int> res;\\n        for(int i=0;i<vr.size();i++){\\n            if(vl[i] && vr[i]) res.push_back(i);\\n        }\\n        return res;\\n    }\\n\\n    vector<bool> leftGood(vector<int>& v, int t){\\n        int cnt = 0;\\n        vector<bool> res;\\n        for(int i=0;i<v.size();i++){\\n            if(i>0){\\n                if(v[i] <= v[i-1]) cnt++;\\n                else cnt = 0; \\n            }\\n            res.push_back(cnt >= t);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291667,
                "title": "java-dp-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n     public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] leftToRightDecreasing=new int[security.length];\\n        int[] rightToLeftIncreasing=new int[security.length];\\n        for (int i=1;i<security.length;i++){\\n            if(security[i]<=security[i-1]){\\n                leftToRightDecreasing[i]=leftToRightDecreasing[i-1]+1;\\n            }\\n        }\\n        for (int i=security.length-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                rightToLeftIncreasing[i]=rightToLeftIncreasing[i+1]+1;\\n            }\\n        }\\n        List<Integer> list=new ArrayList<>();\\n        for (int i=time;i<security.length-time;i++){\\n            if(rightToLeftIncreasing[i]>=time && leftToRightDecreasing[i]>=time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n     public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] leftToRightDecreasing=new int[security.length];\\n        int[] rightToLeftIncreasing=new int[security.length];\\n        for (int i=1;i<security.length;i++){\\n            if(security[i]<=security[i-1]){\\n                leftToRightDecreasing[i]=leftToRightDecreasing[i-1]+1;\\n            }\\n        }\\n        for (int i=security.length-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                rightToLeftIncreasing[i]=rightToLeftIncreasing[i+1]+1;\\n            }\\n        }\\n        List<Integer> list=new ArrayList<>();\\n        for (int i=time;i<security.length-time;i++){\\n            if(rightToLeftIncreasing[i]>=time && leftToRightDecreasing[i]>=time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278074,
                "title": "javascript-beats-100",
                "content": "# Code\\n```\\nvar goodDaysToRobBank = function(security, time) {\\n    let days=[];\\n    let check=true;\\n        for(let i=time;i<security.length-time;i++){\\n            for(let j=i-time;j<i;j++){\\n                if(security[j]<security[j+1]){\\n                    check=false;break\\n                }\\n            }\\n            if(check){\\n            for(let j=i;j<time+i;j++){\\n                if(security[j]>security[j+1]){\\n                    check=false;break\\n                }\\n            } \\n            if(check){days.push(i)}\\n            }\\n            check=true\\n        }\\n    return days\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    let days=[];\\n    let check=true;\\n        for(let i=time;i<security.length-time;i++){\\n            for(let j=i-time;j<i;j++){\\n                if(security[j]<security[j+1]){\\n                    check=false;break\\n                }\\n            }\\n            if(check){\\n            for(let j=i;j<time+i;j++){\\n                if(security[j]>security[j+1]){\\n                    check=false;break\\n                }\\n            } \\n            if(check){days.push(i)}\\n            }\\n            check=true\\n        }\\n    return days\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3275886,
                "title": "o-n-single-scan-single-dp-array-scala-explained",
                "content": "# Intuition\\nThis problem can be solved with prefix and suffix arrays: just scan left to right and right to left annotating the positions where the previous *time* values in security were monotonically increasing / decreasing.\\nThen match the positions where both prefix and suffix arrays satisfy the requirements.\\nThis solution has linear complexity O(3n).\\nThere\\'s no need, though to do it in three passages: it can be done in a single one.\\n\\n\\n# Approach\\nThe algorithm goes as this:\\n* if the security array is not large enough to account for pre and post observations, then it\\'s a trivial empty answer\\n* otherwise, allocate an array *dp* where we\\'ll store how many favourable conditions have we measured: this will be 0 for no conditions, 1 for either pre or post and 2 for both of them.\\n* keep the head of the result list in *result*. We\\'ll prepend each day to it to keep complexity O(1)\\n* scan left to right on i and keep count of the consecutive non-increasing days: if an increase is detected, reset the counter. Do the same from the right end.\\n* if days from left are greater or equal than the *time* threshold, increase the count in *dp*. If the count has reached 2, it means this day is a good one: add it to the result\\n* do the same for the right side\\n* return the *result* list\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nobject Solution {\\n    def goodDaysToRobBank(security: Array[Int], time: Int): List[Int] = {\\n        if (security.length < time * 2 + 1) {\\n            List.empty\\n        } else {\\n            val dp = Array.ofDim[Int](security.length) \\n            var pre = 0\\n            var post = 0\\n            var result = List.empty[Int]\\n            (0 until security.length).foreach { i =>\\n                if (i > 0 && security(i) <= security(i - 1)) {\\n                    pre += 1\\n                } else {\\n                    pre = 0\\n                }\\n                if (i > 0 && security(security.length - i - 1) <= security(security.length - i)) {\\n                    post += 1\\n                } else {\\n                    post = 0\\n                }\\n                if (pre >= time) {\\n                    dp(i) += 1\\n                    if (dp(i) == 2) {\\n                        result = i :: result\\n                    }\\n                }\\n                if (post >= time) {\\n                    dp(security.length - 1 - i) += 1\\n                    if (dp(security.length - 1 - i) == 2) {\\n                        result = (security.length - 1 - i) :: result\\n                    }\\n                }\\n            }\\n            result\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def goodDaysToRobBank(security: Array[Int], time: Int): List[Int] = {\\n        if (security.length < time * 2 + 1) {\\n            List.empty\\n        } else {\\n            val dp = Array.ofDim[Int](security.length) \\n            var pre = 0\\n            var post = 0\\n            var result = List.empty[Int]\\n            (0 until security.length).foreach { i =>\\n                if (i > 0 && security(i) <= security(i - 1)) {\\n                    pre += 1\\n                } else {\\n                    pre = 0\\n                }\\n                if (i > 0 && security(security.length - i - 1) <= security(security.length - i)) {\\n                    post += 1\\n                } else {\\n                    post = 0\\n                }\\n                if (pre >= time) {\\n                    dp(i) += 1\\n                    if (dp(i) == 2) {\\n                        result = i :: result\\n                    }\\n                }\\n                if (post >= time) {\\n                    dp(security.length - 1 - i) += 1\\n                    if (dp(security.length - 1 - i) == 2) {\\n                        result = (security.length - 1 - i) :: result\\n                    }\\n                }\\n            }\\n            result\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3269493,
                "title": "simple-java-solution-o-n",
                "content": "# Approach\\nUse extra space to store increasing order of left->right and right->left\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] a, int time) {\\n        \\n        int n = a.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                left[i]=1+left[i-1]; \\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                right[i]=1+right[i+1];\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int i=time;i<n-time;i++){\\n            if(left[i]>=time && right[i]>=time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] a, int time) {\\n        \\n        int n = a.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                left[i]=1+left[i-1]; \\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                right[i]=1+right[i+1];\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int i=time;i<n-time;i++){\\n            if(left[i]>=time && right[i]>=time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224582,
                "title": "python-o-n-with-only-1-loop-through-the-security-list-speed-95-3-times-submits-values",
                "content": "Idea is quite similar to https://leetcode.com/problems/find-good-days-to-rob-the-bank/discuss/1623415/Python-Explanation-with-pictures-prefix-sum. but instead of 2 x loop, this solution is using 1 x loop hence better speed result.\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if len(security)<2*time+1:\\n            return []\\n        \\n        l=0\\n        for i in range(time-1,-1,-1):\\n            if security[i+1]<=security[i]:\\n                l+=1\\n            else:\\n                break\\n        r=0\\n        for i in range(time-1,-1,-1):\\n            if security[time+i+1]>=security[time+i]:\\n                r+=1\\n            else:\\n                break\\n        ans=[]\\n        if l==time and r==time:\\n            ans.append(time)\\n            \\n        for p in range(time+1,len(security)-time):\\n            if security[p]<=security[p-1]:\\n                l=min(time, l+1)\\n            else:\\n                l=0\\n            if security[p+time]>=security[p+time-1]:\\n                r=min(time, r+1)\\n            else:\\n                r=0\\n            if l==time and r==time:\\n                ans.append(p)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if len(security)<2*time+1:\\n            return []\\n        \\n        l=0\\n        for i in range(time-1,-1,-1):\\n            if security[i+1]<=security[i]:\\n                l+=1\\n            else:\\n                break\\n        r=0\\n        for i in range(time-1,-1,-1):\\n            if security[time+i+1]>=security[time+i]:\\n                r+=1\\n            else:\\n                break\\n        ans=[]\\n        if l==time and r==time:\\n            ans.append(time)\\n            \\n        for p in range(time+1,len(security)-time):\\n            if security[p]<=security[p-1]:\\n                l=min(time, l+1)\\n            else:\\n                l=0\\n            if security[p+time]>=security[p+time-1]:\\n                r=min(time, r+1)\\n            else:\\n                r=0\\n            if l==time and r==time:\\n                ans.append(p)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210056,
                "title": "easy-solution-in-c-prefix-suffix",
                "content": "# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n### **Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size(),j=0;\\n        vector<int> ans,prefix(n),suffix(n);\\n        for(int i=1;i<n;i++){\\n            j++;\\n            if(security[i]<=security[i-1])\\n                prefix[i]=j;\\n            else{\\n                j=0;\\n                prefix[i]=j;\\n            } \\n        }\\n        j=0;\\n        for(int i=n-2;i>=0;i--){\\n            j++;\\n            if(security[i]<=security[i+1])\\n                suffix[i]=j;\\n            else{\\n                j=0;\\n                suffix[i]=j;\\n            } \\n        }\\n        for(int i=0;i<n;i++)\\n            if(prefix[i]>=time && suffix[i]>=time)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size(),j=0;\\n        vector<int> ans,prefix(n),suffix(n);\\n        for(int i=1;i<n;i++){\\n            j++;\\n            if(security[i]<=security[i-1])\\n                prefix[i]=j;\\n            else{\\n                j=0;\\n                prefix[i]=j;\\n            } \\n        }\\n        j=0;\\n        for(int i=n-2;i>=0;i--){\\n            j++;\\n            if(security[i]<=security[i+1])\\n                suffix[i]=j;\\n            else{\\n                j=0;\\n                suffix[i]=j;\\n            } \\n        }\\n        for(int i=0;i<n;i++)\\n            if(prefix[i]>=time && suffix[i]>=time)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207634,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int [] left = new int[n];\\n        int [] right = new int[n];\\n        left[0] = 0;\\n        for(int i = 1; i < n; i++){\\n            if(security[i - 1] >= security[i]){\\n                left[i] = left[i - 1] + 1;\\n            } else {\\n                left[i] = 0;\\n            }\\n        }\\n        right[n - 1] = 0;\\n        for(int i = n - 2; i >= 0; i--){\\n            if(security[i + 1] >= security[i]){\\n                right[i] = right[i + 1] + 1;\\n            } else{\\n                right[i] = 0;\\n            }\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int [] left = new int[n];\\n        int [] right = new int[n];\\n        left[0] = 0;\\n        for(int i = 1; i < n; i++){\\n            if(security[i - 1] >= security[i]){\\n                left[i] = left[i - 1] + 1;\\n            } else {\\n                left[i] = 0;\\n            }\\n        }\\n        right[n - 1] = 0;\\n        for(int i = n - 2; i >= 0; i--){\\n            if(security[i + 1] >= security[i]){\\n                right[i] = right[i + 1] + 1;\\n            } else{\\n                right[i] = 0;\\n            }\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179552,
                "title": "prefix-suffix-array-very-simple-c",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        vector<int> before(n,0), after(n,0);\\n        for(int x=1; x<n; x++)\\n        {\\n            if(security[x-1]>=security[x])\\n            {\\n                before[x]=1+before[x-1];\\n            }\\n        }\\n        for(int x=n-2; x>=0; x--)\\n        {\\n            if(security[x]<=security[x+1])\\n            {\\n                after[x]=1+after[x+1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(after[x]>=time && before[x]>=time) ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        vector<int> before(n,0), after(n,0);\\n        for(int x=1; x<n; x++)\\n        {\\n            if(security[x-1]>=security[x])\\n            {\\n                before[x]=1+before[x-1];\\n            }\\n        }\\n        for(int x=n-2; x>=0; x--)\\n        {\\n            if(security[x]<=security[x+1])\\n            {\\n                after[x]=1+after[x+1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(after[x]>=time && before[x]>=time) ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122452,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        vector<int>pre(n,0);\\n        vector<int>after(n,0);\\n        int prev=INT_MIN;\\n        int cnt=0;\\n        for (int i=0;i<n;i++)\\n        {\\n           if (security[i]<=prev)\\n           {\\n               cnt++;\\n               pre[i]=cnt;\\n           }\\n           else{\\n               cnt=0;\\n               pre[i]=cnt;\\n           }\\n           prev=security[i];\\n        }\\n        prev=INT_MIN;\\n        for (int i=n-1;i>=0;i--)\\n        {\\n           if(security[i]<=prev)\\n           {\\n               cnt++;\\n               after[i]=cnt;\\n           }\\n           else{\\n               cnt=0;;\\n               after[i]=cnt;\\n           }\\n           prev=security[i];\\n        }\\n        vector<int>ans;\\n        for (int i=0;i<n;i++)\\n        {\\n            if (pre[i]>=time && after[i]>=time)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        vector<int>pre(n,0);\\n        vector<int>after(n,0);\\n        int prev=INT_MIN;\\n        int cnt=0;\\n        for (int i=0;i<n;i++)\\n        {\\n           if (security[i]<=prev)\\n           {\\n               cnt++;\\n               pre[i]=cnt;\\n           }\\n           else{\\n               cnt=0;\\n               pre[i]=cnt;\\n           }\\n           prev=security[i];\\n        }\\n        prev=INT_MIN;\\n        for (int i=n-1;i>=0;i--)\\n        {\\n           if(security[i]<=prev)\\n           {\\n               cnt++;\\n               after[i]=cnt;\\n           }\\n           else{\\n               cnt=0;;\\n               after[i]=cnt;\\n           }\\n           prev=security[i];\\n        }\\n        vector<int>ans;\\n        for (int i=0;i<n;i++)\\n        {\\n            if (pre[i]>=time && after[i]>=time)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114561,
                "title": "c-easy-dp-solution",
                "content": "We use to DP vector.\\nOne vector to keep the number of days that is non-increasing  before ith day.\\nThe other one keep the number of days that is non-decreasing after the ith day.\\nThen we check from [time, N-time]\\n\\n\\'\\'\\'\\n\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> res;\\n        int N = security.size();\\n        vector<int> nonInc(N,0);\\n        vector<int> nonDec(N,0);\\n        for (int i=1; i<N; i++) {\\n            if (security[i-1]>=security[i]) {\\n                nonInc[i] = nonInc[i-1]+1;\\n            }\\n        }\\n        for (int i=N-1; i>0; i--) {\\n            if (security[i]>=security[i-1]) {\\n                nonDec[i-1] = nonDec[i]+1;\\n            }\\n        }\\n        \\n        for (int i=time; i<N-time; i++) {\\n            if (nonInc[i]>=time && nonDec[i]>=time) {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "We use to DP vector.\\nOne vector to keep the number of days that is non-increasing  before ith day.\\nThe other one keep the number of days that is non-decreasing after the ith day.\\nThen we check from [time, N-time]\\n\\n\\'\\'\\'\\n\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> res;\\n        int N = security.size();\\n        vector<int> nonInc(N,0);\\n        vector<int> nonDec(N,0);\\n        for (int i=1; i<N; i++) {\\n            if (security[i-1]>=security[i]) {\\n                nonInc[i] = nonInc[i-1]+1;\\n            }\\n        }\\n        for (int i=N-1; i>0; i--) {\\n            if (security[i]>=security[i-1]) {\\n                nonDec[i-1] = nonDec[i]+1;\\n            }\\n        }\\n        \\n        for (int i=time; i<N-time; i++) {\\n            if (nonInc[i]>=time && nonDec[i]>=time) {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3106410,
                "title": "python-greedy-method-easy-code-and-solution-3-pass",
                "content": "# Intuition\\nbased on the requirement. Loop the array from left to right to see the increasement sequence length. and do the similar from right to left.\\nThen loop the sequence position, find the position meet min(left,right)>=time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if time ==0:\\n            return list(range(len(security)))\\n        left =[0]*len(security)\\n        right =[0]*len(security)\\n        for i in range(1,len(security)):\\n            if security[i]<=security[i-1]:\\n                left[i]=left[i-1]+1\\n        for i in range(len(security)-2,0,-1):\\n            if security[i]<=security[i+1]:\\n                right[i]=right[i+1]+1\\n        res = []\\n        for i,j in enumerate(security):\\n            if min(left[i],right[i])>=time:\\n                res.append(i)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if time ==0:\\n            return list(range(len(security)))\\n        left =[0]*len(security)\\n        right =[0]*len(security)\\n        for i in range(1,len(security)):\\n            if security[i]<=security[i-1]:\\n                left[i]=left[i-1]+1\\n        for i in range(len(security)-2,0,-1):\\n            if security[i]<=security[i+1]:\\n                right[i]=right[i+1]+1\\n        res = []\\n        for i,j in enumerate(security):\\n            if min(left[i],right[i])>=time:\\n                res.append(i)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090798,
                "title": "python-o-n-pre-caching-data",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, s: List[int], time: int) -> List[int]:\\n        @cache\\n        def count_left(cur):\\n            if cur == 0:\\n                return 0\\n\\n            if s[cur-1] >= s[cur]:\\n                return 1 + count_left(cur-1)\\n\\n            return 0\\n\\n        @cache\\n        def count_right(cur):\\n            if cur == len(s) - 1:\\n                return 0\\n\\n            if s[cur+1] >= s[cur]:\\n                return 1 + count_right(cur+1)\\n\\n            return 0\\n\\n        # precaching data\\n        count_left(0) # O(n)\\n        count_right(len(s)-1) # O(n)\\n\\n        ans = []\\n        for i in range(len(s)):\\n            left = count_left(i) # O(1)\\n            right = count_right(i) # O(1)\\n            if left >= time and right >= time:\\n                ans.append(i)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, s: List[int], time: int) -> List[int]:\\n        @cache\\n        def count_left(cur):\\n            if cur == 0:\\n                return 0\\n\\n            if s[cur-1] >= s[cur]:\\n                return 1 + count_left(cur-1)\\n\\n            return 0\\n\\n        @cache\\n        def count_right(cur):\\n            if cur == len(s) - 1:\\n                return 0\\n\\n            if s[cur+1] >= s[cur]:\\n                return 1 + count_right(cur+1)\\n\\n            return 0\\n\\n        # precaching data\\n        count_left(0) # O(n)\\n        count_right(len(s)-1) # O(n)\\n\\n        ans = []\\n        for i in range(len(s)):\\n            left = count_left(i) # O(1)\\n            right = count_right(i) # O(1)\\n            if left >= time and right >= time:\\n                ans.append(i)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090349,
                "title": "java-o-n-easy-solution-with-explanation",
                "content": "Thoughts:\\n* use a 2D array to store: days before and days after\\n* We only care about the neighboring elements security[i-1] and security[i+1] because when i = i-1, we also check security[i-2] and security[i]\\n\\tExample: If we want to know how many non-increasing days before ith day\\n\\t\\t\\t\\t\\tWe will check security[i-1] ... security[0]\\n\\t\\t\\t\\t\\tBut for security[i-1], we also checked security[i-2] ... security[0]\\n\\t\\t\\t\\t\\tThus, for security[i]  = security[i-1] (The num of non-increasing days at i-1th day) +1\\n* Finally, check if the **non-increasing days before ith day** and **non-decreasing days after ith day** is >= time.\\n\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> result = new ArrayList<>();\\n        int[][] prePost = new int[security.length][2];\\n        int daysBefore = 0;\\n        //get the num of days before i days\\n        for(int i = 1; i < security.length ; i++){\\n            if(security[i-1] >= security[i]){\\n                daysBefore++;\\n            }else{\\n                daysBefore = 0;\\n            }\\n            prePost[i][0] = daysBefore;\\n        }\\n        \\n        //get the num of days after i days\\n        int daysAfter = 0;\\n        for(int i = security.length-2; i>=0 ; i--){\\n            if(security[i] <= security[i+1]){\\n                daysAfter++;\\n            }else{\\n                daysAfter = 0;\\n            }\\n            prePost[i][1] = daysAfter;\\n        }\\n        \\n        for(int i = 0 ; i < prePost.length ; i++){\\n            if(prePost[i][0] >= time && prePost[i][1] >= time){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> result = new ArrayList<>();\\n        int[][] prePost = new int[security.length][2];\\n        int daysBefore = 0;\\n        //get the num of days before i days\\n        for(int i = 1; i < security.length ; i++){\\n            if(security[i-1] >= security[i]){\\n                daysBefore++;\\n            }else{\\n                daysBefore = 0;\\n            }\\n            prePost[i][0] = daysBefore;\\n        }\\n        \\n        //get the num of days after i days\\n        int daysAfter = 0;\\n        for(int i = security.length-2; i>=0 ; i--){\\n            if(security[i] <= security[i+1]){\\n                daysAfter++;\\n            }else{\\n                daysAfter = 0;\\n            }\\n            prePost[i][1] = daysAfter;\\n        }\\n        \\n        for(int i = 0 ; i < prePost.length ; i++){\\n            if(prePost[i][0] >= time && prePost[i][1] >= time){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077247,
                "title": "simple-java-solution-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int len = security.length;\\n        int left[] = new int[len];\\n        int right[] = new int[len];\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 1; i < len; i++){\\n            if(security[i] <= security[i-1]){\\n                left[i] = left[i-1]+1;\\n            }\\n        }\\n\\n        for(int i = len - 2; i >= 0; i--){\\n            if(security[i] <= security[i+1]){\\n                right[i] = right[i+1]+1;\\n            }\\n        }\\n        for(int i = 0; i < len; i++){\\n            if(left[i] >= time && right[i]>=time){\\n                res.add(i);\\n            }    \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int len = security.length;\\n        int left[] = new int[len];\\n        int right[] = new int[len];\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 1; i < len; i++){\\n            if(security[i] <= security[i-1]){\\n                left[i] = left[i-1]+1;\\n            }\\n        }\\n\\n        for(int i = len - 2; i >= 0; i--){\\n            if(security[i] <= security[i+1]){\\n                right[i] = right[i+1]+1;\\n            }\\n        }\\n        for(int i = 0; i < len; i++){\\n            if(left[i] >= time && right[i]>=time){\\n                res.add(i);\\n            }    \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077150,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        right = [False] * n\\n        left = [False] * n\\n        res = []\\n\\n        cur_False = [True] * n\\n        total_False = 0\\n        for i in range(1,n):\\n            if security[i] > security[i-1]:\\n                if i <= time:\\n                    total_False += 1\\n                cur_False[i] = False\\n                \\n        for i in range(time,n):\\n            if total_False == 0:left[i] = True\\n            \\n            if i == n-1:continue\\n            if cur_False[i-(time-1)] == False:total_False -= 1\\n            if cur_False[i+1] == False: total_False += 1\\n            \\n        cur_False = [True] * n\\n        total_False = 0\\n        for i in range(n-2,-1,-1):\\n            if security[i] > security[i+1]:\\n                if n-1-time <= i:total_False += 1\\n                cur_False[i] = False\\n                \\n        for i in range(n-1-time,-1,-1):\\n            if total_False == 0:right[i] = True\\n            \\n            if i == 1:continue\\n            if cur_False[i+(time-1)] == False:total_False -= 1\\n            if cur_False[i-1] == False: total_False += 1\\n            \\n        for i in range(n):\\n            if left[i] and right[i]:\\n                res.append(i)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        right = [False] * n\\n        left = [False] * n\\n        res = []\\n\\n        cur_False = [True] * n\\n        total_False = 0\\n        for i in range(1,n):\\n            if security[i] > security[i-1]:\\n                if i <= time:\\n                    total_False += 1\\n                cur_False[i] = False\\n                \\n        for i in range(time,n):\\n            if total_False == 0:left[i] = True\\n            \\n            if i == n-1:continue\\n            if cur_False[i-(time-1)] == False:total_False -= 1\\n            if cur_False[i+1] == False: total_False += 1\\n            \\n        cur_False = [True] * n\\n        total_False = 0\\n        for i in range(n-2,-1,-1):\\n            if security[i] > security[i+1]:\\n                if n-1-time <= i:total_False += 1\\n                cur_False[i] = False\\n                \\n        for i in range(n-1-time,-1,-1):\\n            if total_False == 0:right[i] = True\\n            \\n            if i == 1:continue\\n            if cur_False[i+(time-1)] == False:total_False -= 1\\n            if cur_False[i-1] == False: total_False += 1\\n            \\n        for i in range(n):\\n            if left[i] and right[i]:\\n                res.append(i)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042856,
                "title": "simple-python-solution-with-prefix-sum-and-also-a-simple-tle-solution-for-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        # Time limit Exceeded\\n        # ans = []\\n        # if time >= len(security):\\n        #     return []\\n        # print(len(security), time)   \\n        # for i in range(time, len(security) - time):\\n        #     left, right, flag = i, i, True\\n        #     for j in range(time):\\n        #         if security[left] > security[left-1] or security[right] > security[right+1]:\\n        #             flag = False\\n        #             break\\n        #         left -= 1\\n        #         right += 1    \\n        #     if flag:\\n        #         ans.append(i)\\n        # return ans   \\n        \\n        n = len(security)\\n        pre = [0] * (n+1)\\n        post = [0] * (n+1)\\n\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i-1]:\\n                pre[i] = pre[i-1] + 1\\n        for i in range(n-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                post[i] = post[i+1] + 1        \\n\\n        # post = post[::-1]\\n\\n        ans = []\\n        for i in range(time, n- time):\\n            if pre[i] >= time and post[i] >= time:\\n                ans.append(i)\\n        return ans            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        # Time limit Exceeded\\n        # ans = []\\n        # if time >= len(security):\\n        #     return []\\n        # print(len(security), time)   \\n        # for i in range(time, len(security) - time):\\n        #     left, right, flag = i, i, True\\n        #     for j in range(time):\\n        #         if security[left] > security[left-1] or security[right] > security[right+1]:\\n        #             flag = False\\n        #             break\\n        #         left -= 1\\n        #         right += 1    \\n        #     if flag:\\n        #         ans.append(i)\\n        # return ans   \\n        \\n        n = len(security)\\n        pre = [0] * (n+1)\\n        post = [0] * (n+1)\\n\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i-1]:\\n                pre[i] = pre[i-1] + 1\\n        for i in range(n-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                post[i] = post[i+1] + 1        \\n\\n        # post = post[::-1]\\n\\n        ans = []\\n        for i in range(time, n- time):\\n            if pre[i] >= time and post[i] >= time:\\n                ans.append(i)\\n        return ans            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012669,
                "title": "longest-chain-on-both-sides",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        mdec = [1] * n\\n        minc = [1] * n\\n        for i in range(1, n):\\n            if security[i] <= security[i - 1]:\\n                mdec[i] = 1 + mdec[i - 1]\\n        for i in range(n - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                minc[i] = 1 + minc[i + 1]\\n        res = []\\n        for i in range(time, n - time):\\n            if mdec[i] >= time + 1 and minc[i] >= time + 1:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        mdec = [1] * n\\n        minc = [1] * n\\n        for i in range(1, n):\\n            if security[i] <= security[i - 1]:\\n                mdec[i] = 1 + mdec[i - 1]\\n        for i in range(n - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                minc[i] = 1 + minc[i + 1]\\n        res = []\\n        for i in range(time, n - time):\\n            if mdec[i] >= time + 1 and minc[i] >= time + 1:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998829,
                "title": "java-one-of-the-easiest-solution-with-prefix-and-suffix-array-with-explanation",
                "content": "```\\npublic static List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        List<Integer> result = new ArrayList<>();\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        for (int i = time; i < n - time; i++) {\\n            if (left[i] >= time && right[i] >= time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\npublic static List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        List<Integer> result = new ArrayList<>();\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        for (int i = time; i < n - time; i++) {\\n            if (left[i] >= time && right[i] >= time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998582,
                "title": "java-single-pass-sliding-window-o-n-solution-easy-to-understand",
                "content": "Look at left increment and increment **leftCounter** if below condtion :\\n```\\nsecurity[i - time] >= security[i - time + 1] >= ... >= security[i]\\n\\n```\\nIncrement **rightCounter** if below\\n```\\nsecurity[i] <= ... <= security[i + time - 1] <= security[i + time].\\n\\n```\\n\\nFinally check if both array elements greater than or equal to **time**\\n\\n# Code\\n```\\n//5,3,3,3,5,6,2 \\n//0,1,2,2,0,0,1  = leftMin\\n//0,2,2,2,1,0,0  = rightMin\\n\\n//1,1,1,1,1\\n//1,1,1,1,1 = leftMin\\n//1,1,1,1,1 = rightMin\\n\\n\\n//7,7,7,7,7,7,7,7,7,7,7,7,7\\n//0,1,2,3,4,5,5,5,5,5,5,5,5 = leftMin\\n\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer>  result = new ArrayList<>(); \\n        if(time == 0){\\n            for(int i = 0 ; i <  security.length ;i++){\\n                result.add(i);\\n            }\\n            return result;\\n        }\\n        int[] leftMin = new int[security.length] ,  rightMin = new int[security.length];\\n        leftMin[0] = 0;\\n        rightMin[security.length - 1] = 0;\\n        int rightCounter = 0;\\n        int leftCounter = 0;\\n        int n =  security.length ;\\n        for(int i =  1 ;   i < security.length ; i++){\\n            if(security[i-1] >= security[i]){\\n                leftCounter++;\\n                leftMin[i]  = leftCounter;\\n            }\\n            else{\\n                leftMin[i] = 0;\\n                leftCounter = 0;\\n            }\\n            if(leftCounter >= time ){\\n                leftMin[i] = leftCounter;\\n                leftCounter--;\\n            }            \\n            if(security[n - i] >= security[n - i - 1]){\\n                rightCounter++;\\n                rightMin[n - i - 1]  = rightCounter;\\n            }\\n            else{\\n                rightMin[n - i - 1] = 0;\\n                rightCounter = 0;\\n            }\\n            if(rightCounter >= time ){\\n                rightMin[n - i - 1] = rightCounter;\\n                rightCounter--;\\n            } \\n        }\\n        for(int  i = 0 ; i < leftMin.length ; i++){\\n            if(leftMin[i] >= time  && leftMin[i] == rightMin[i]){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nsecurity[i - time] >= security[i - time + 1] >= ... >= security[i]\\n\\n```\n```\\nsecurity[i] <= ... <= security[i + time - 1] <= security[i + time].\\n\\n```\n```\\n//5,3,3,3,5,6,2 \\n//0,1,2,2,0,0,1  = leftMin\\n//0,2,2,2,1,0,0  = rightMin\\n\\n//1,1,1,1,1\\n//1,1,1,1,1 = leftMin\\n//1,1,1,1,1 = rightMin\\n\\n\\n//7,7,7,7,7,7,7,7,7,7,7,7,7\\n//0,1,2,3,4,5,5,5,5,5,5,5,5 = leftMin\\n\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer>  result = new ArrayList<>(); \\n        if(time == 0){\\n            for(int i = 0 ; i <  security.length ;i++){\\n                result.add(i);\\n            }\\n            return result;\\n        }\\n        int[] leftMin = new int[security.length] ,  rightMin = new int[security.length];\\n        leftMin[0] = 0;\\n        rightMin[security.length - 1] = 0;\\n        int rightCounter = 0;\\n        int leftCounter = 0;\\n        int n =  security.length ;\\n        for(int i =  1 ;   i < security.length ; i++){\\n            if(security[i-1] >= security[i]){\\n                leftCounter++;\\n                leftMin[i]  = leftCounter;\\n            }\\n            else{\\n                leftMin[i] = 0;\\n                leftCounter = 0;\\n            }\\n            if(leftCounter >= time ){\\n                leftMin[i] = leftCounter;\\n                leftCounter--;\\n            }            \\n            if(security[n - i] >= security[n - i - 1]){\\n                rightCounter++;\\n                rightMin[n - i - 1]  = rightCounter;\\n            }\\n            else{\\n                rightMin[n - i - 1] = 0;\\n                rightCounter = 0;\\n            }\\n            if(rightCounter >= time ){\\n                rightMin[n - i - 1] = rightCounter;\\n                rightCounter--;\\n            } \\n        }\\n        for(int  i = 0 ; i < leftMin.length ; i++){\\n            if(leftMin[i] >= time  && leftMin[i] == rightMin[i]){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957642,
                "title": "easy-c-solution-o-n-faster",
                "content": "\\n# Approach: 2 vectors(prefix and suff), one to store the number of days before the ith day that is non-increasing, and another array to store the number of days after the ith day that is non-decreasing.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 3O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& a, int time) {\\n        int n=a.size();\\n        vector<int>v;\\n        int cnt=0;\\n        vector<int>pref(n,1),suff(n,1);\\n        for(int i=0;i<n;i++){\\n            if(i==0)continue;\\n            if(a[i]<=a[i-1]){\\n                cnt++;\\n                pref[i]+=cnt;\\n            }else{\\n                cnt=0;\\n            }\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i==n-1)continue;\\n            if(a[i]<=a[i+1]){\\n                cnt++;\\n                suff[i]+=cnt;\\n            }else{\\n                cnt=0;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(pref[i]>=time+1&&suff[i]>=time+1){\\n                v.push_back(i);\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& a, int time) {\\n        int n=a.size();\\n        vector<int>v;\\n        int cnt=0;\\n        vector<int>pref(n,1),suff(n,1);\\n        for(int i=0;i<n;i++){\\n            if(i==0)continue;\\n            if(a[i]<=a[i-1]){\\n                cnt++;\\n                pref[i]+=cnt;\\n            }else{\\n                cnt=0;\\n            }\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i==n-1)continue;\\n            if(a[i]<=a[i+1]){\\n                cnt++;\\n                suff[i]+=cnt;\\n            }else{\\n                cnt=0;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(pref[i]>=time+1&&suff[i]>=time+1){\\n                v.push_back(i);\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936811,
                "title": "solution-in-rust",
                "content": "# Code\\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n impl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        let mut pl = i32::MIN;\\n        let mut pr = i32::MIN;\\n\\n        let mut cl = 0;\\n        let mut cr = 0;\\n\\n        let mut a: HashSet<i32> = HashSet::new();\\n        let mut b: HashSet<i32> = HashSet::new();\\n        for i in 0..security.len() {\\n            if security[i] <= pl {\\n                cl += 1;\\n            } else {\\n                cl = 0;\\n            }\\n            if security[security.len() - 1 - i] <= pr {\\n                cr += 1;\\n            } else {\\n                cr = 0;\\n            }\\n\\n            if cl >= time {\\n                a.insert(i as i32);\\n            }\\n            if cr >= time {\\n                b.insert((security.len() - 1 - i) as i32);\\n            }\\n            pl = security[i];\\n            pr = security[security.len() - 1 - i];\\n        }\\n        let x = Vec::from_iter(HashSet::from(&a & &b).iter().cloned());\\n        x\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n impl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        let mut pl = i32::MIN;\\n        let mut pr = i32::MIN;\\n\\n        let mut cl = 0;\\n        let mut cr = 0;\\n\\n        let mut a: HashSet<i32> = HashSet::new();\\n        let mut b: HashSet<i32> = HashSet::new();\\n        for i in 0..security.len() {\\n            if security[i] <= pl {\\n                cl += 1;\\n            } else {\\n                cl = 0;\\n            }\\n            if security[security.len() - 1 - i] <= pr {\\n                cr += 1;\\n            } else {\\n                cr = 0;\\n            }\\n\\n            if cl >= time {\\n                a.insert(i as i32);\\n            }\\n            if cr >= time {\\n                b.insert((security.len() - 1 - i) as i32);\\n            }\\n            pl = security[i];\\n            pr = security[security.len() - 1 - i];\\n        }\\n        let x = Vec::from_iter(HashSet::from(&a & &b).iter().cloned());\\n        x\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930091,
                "title": "java-o-n-count-decreasing-days-on-left-and-increasing-on-right-of-each-day",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int ddays = 0;\\n        int[][] before_after = new int[security.length][2];\\n        for (int i = 1; i < security.length; i++) {\\n            if (security[i - 1] >= security[i]) {\\n                ddays++;\\n            } else {\\n                ddays = 0;\\n            }\\n            before_after[i][0]= ddays;\\n        }\\n        ddays = 0;\\n        for (int i = security.length - 1; i > 0; i--) {\\n            if (security[i - 1] <= security[i]) {\\n                ddays++;\\n            } else {\\n                ddays = 0;\\n            }\\n            before_after[i - 1][1]= ddays;\\n        }\\n        List<Integer> res = new LinkedList<>();\\n        for (int i = 0; i < before_after.length; i++) {\\n            if (before_after[i][0] >= time && before_after[i][1] >= time) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int ddays = 0;\\n        int[][] before_after = new int[security.length][2];\\n        for (int i = 1; i < security.length; i++) {\\n            if (security[i - 1] >= security[i]) {\\n                ddays++;\\n            } else {\\n                ddays = 0;\\n            }\\n            before_after[i][0]= ddays;\\n        }\\n        ddays = 0;\\n        for (int i = security.length - 1; i > 0; i--) {\\n            if (security[i - 1] <= security[i]) {\\n                ddays++;\\n            } else {\\n                ddays = 0;\\n            }\\n            before_after[i - 1][1]= ddays;\\n        }\\n        List<Integer> res = new LinkedList<>();\\n        for (int i = 0; i < before_after.length; i++) {\\n            if (before_after[i][0] >= time && before_after[i][1] >= time) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913384,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> right = {0};\\n        for (int i = size(security) - 1; i >= 1; --i) {\\n            right.emplace_back(security[i] >= security[i - 1] ? right.back() + 1 : 0);\\n        }\\n        reverse(begin(right), end(right));\\n        vector<int> result;\\n        for (int i = 0, left = 0; i < size(security); ++i) {\\n            if (left >= time && right[i] >= time) {\\n                result.emplace_back(i);\\n            }\\n            if (i + 1 < size(security)) {\\n                left = (security[i] >= security[i + 1]) ? left + 1 : 0;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> right = {0};\\n        for (int i = size(security) - 1; i >= 1; --i) {\\n            right.emplace_back(security[i] >= security[i - 1] ? right.back() + 1 : 0);\\n        }\\n        reverse(begin(right), end(right));\\n        vector<int> result;\\n        for (int i = 0, left = 0; i < size(security); ++i) {\\n            if (left >= time && right[i] >= time) {\\n                result.emplace_back(i);\\n            }\\n            if (i + 1 < size(security)) {\\n                left = (security[i] >= security[i + 1]) ? left + 1 : 0;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908396,
                "title": "golang-dp",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    var ans []int\\n    var n int = len(security)\\n    right := make([]int, n)\\n    left := make([]int, n)\\n    for i := n - 2; i >= 0; i-- {\\n        if security[i] <= security[i + 1] {\\n            right[i] = right[i + 1] + 1\\n        }\\n    }\\n    for i := 1; i < n; i++ {\\n        if security[i] <= security[i - 1] {\\n            left[i] = left[i - 1] + 1\\n        }\\n    }\\n    for i := n - time - 1; i >= time; i-- {\\n        if left[i] - left[i - time] == time && right[i] - right[i + time] == time {\\n            ans = append(ans, i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    var ans []int\\n    var n int = len(security)\\n    right := make([]int, n)\\n    left := make([]int, n)\\n    for i := n - 2; i >= 0; i-- {\\n        if security[i] <= security[i + 1] {\\n            right[i] = right[i + 1] + 1\\n        }\\n    }\\n    for i := 1; i < n; i++ {\\n        if security[i] <= security[i - 1] {\\n            left[i] = left[i - 1] + 1\\n        }\\n    }\\n    for i := n - time - 1; i >= time; i-- {\\n        if left[i] - left[i - time] == time && right[i] - right[i + time] == time {\\n            ans = append(ans, i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908355,
                "title": "c-dp",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> ans;\\n        int n = security.size();\\n        vector<int> right(n, 1), left(n, 1);\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1])\\n                right[i] = right[i + 1] + 1;\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1])\\n                left[i] = left[i - 1] + 1;\\n        }\\n        for(int i = n - time - 1; i >= time; i--) {\\n            if(left[i] - left[i - time] == time && right[i] - right[i + time] == time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> ans;\\n        int n = security.size();\\n        vector<int> right(n, 1), left(n, 1);\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1])\\n                right[i] = right[i + 1] + 1;\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1])\\n                left[i] = left[i - 1] + 1;\\n        }\\n        for(int i = n - time - 1; i >= time; i--) {\\n            if(left[i] - left[i - time] == time && right[i] - right[i + time] == time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908283,
                "title": "easy-to-read-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        good_days = []\\n\\n        prefix = [0]*len(security)\\n        suffix = [0]*len(security)\\n\\n        # prefix or suffix at ith index represents how many elements excluding current element is increasing or decreasing. \\n        prefix[0] = 0\\n        suffix[len(security)-1] = 0\\n\\n        # non-increasing 9 8 7 6\\n        for i in range(1, len(prefix)):\\n            if security[i-1] >= security[i]:\\n                prefix[i] = prefix[i-1] + 1\\n            else:\\n                prefix[i] = 0\\n        \\n        # non-decreasing 1 2 3 4\\n        for i in range(len(suffix)-2,-1,-1):\\n            if security[i] <= security[i+1]:\\n                suffix[i] = suffix[i+1] + 1\\n            else:\\n                suffix[i] = 0\\n        # print (prefix)\\n        # print (suffix)\\n        for i in range(time, len(security)-time):\\n            if time != 0 and prefix[i] >= time and suffix[i] >= time:\\n                good_days.append(i)\\n            elif time == 0: # Dont forget to miss this edge case.\\n                good_days.append(i)\\n        return good_days\\n\\n\\'\\'\\'\\nMissed [1,2,3,4] time = 1 expected ans is [] check failed code in submission.\\n\\'\\'\\'\\n\\n \\n\\n\\'\\'\\'\\nBrute force approach \\n\\n        1. traverse start from time days end loop at end days\\n        2. check time days before i - non increasing\\n        3. check time days after i - non decreasing\\n        4. add to answer. \\n\\n        TC: (N* time)\\n    \\n        You can reduce TC of step 2 and 3 by creating suffix and prefix array.\\n\\n\\n        # 5 3 3 3 5 6 2\\n        # + - - - + + -\\n        #   1 2 3 4 5 6 1\\n        #   1 5 4 3 2 1 1\\n\\n        # Does sum help ? No\\n\\'\\'\\'\\n\\n```",
                "solutionTags": [
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        good_days = []\\n\\n        prefix = [0]*len(security)\\n        suffix = [0]*len(security)\\n\\n        # prefix or suffix at ith index represents how many elements excluding current element is increasing or decreasing. \\n        prefix[0] = 0\\n        suffix[len(security)-1] = 0\\n\\n        # non-increasing 9 8 7 6\\n        for i in range(1, len(prefix)):\\n            if security[i-1] >= security[i]:\\n                prefix[i] = prefix[i-1] + 1\\n            else:\\n                prefix[i] = 0\\n        \\n        # non-decreasing 1 2 3 4\\n        for i in range(len(suffix)-2,-1,-1):\\n            if security[i] <= security[i+1]:\\n                suffix[i] = suffix[i+1] + 1\\n            else:\\n                suffix[i] = 0\\n        # print (prefix)\\n        # print (suffix)\\n        for i in range(time, len(security)-time):\\n            if time != 0 and prefix[i] >= time and suffix[i] >= time:\\n                good_days.append(i)\\n            elif time == 0: # Dont forget to miss this edge case.\\n                good_days.append(i)\\n        return good_days\\n\\n\\'\\'\\'\\nMissed [1,2,3,4] time = 1 expected ans is [] check failed code in submission.\\n\\'\\'\\'\\n\\n \\n\\n\\'\\'\\'\\nBrute force approach \\n\\n        1. traverse start from time days end loop at end days\\n        2. check time days before i - non increasing\\n        3. check time days after i - non decreasing\\n        4. add to answer. \\n\\n        TC: (N* time)\\n    \\n        You can reduce TC of step 2 and 3 by creating suffix and prefix array.\\n\\n\\n        # 5 3 3 3 5 6 2\\n        # + - - - + + -\\n        #   1 2 3 4 5 6 1\\n        #   1 5 4 3 2 1 1\\n\\n        # Does sum help ? No\\n\\'\\'\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891526,
                "title": "java-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPreparing the metadata required to solve the each index of security array.\\n\\nPattern : Decrease <-> Day <-> Increase\\n\\n```\\nCode block\\n\\n    // Pattern:  Decrease <-> Day <-> Increase\\n    // Index:    0, 1, 2, 3, 4, 5, 6\\n    // Input:    5, 3, 3, 3, 5, 6, 2\\n    \\n    //left:     -1, 0, 0, 0, 0,-1, 5\\n    //right:    -1, 5, 5, 5, 5,-1,-1\\n\\n    //Ans:      -1,-1, 2, 3,-1,-1,-1\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList<>();\\n        int n = security.length;\\n        if(time == 0) {\\n           for(int i=0; i<n; i++) {\\n               res.add(i);\\n           }\\n           return res; \\n        }\\n        \\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        left[0] = -1;\\n        int prevHigh = 0;\\n        for(int i=1; i<n; i++) {\\n            if(security[i] <= security[i-1]) {\\n                left[i] = prevHigh;\\n            } else {\\n                left[i] = -1;\\n                prevHigh = i;\\n            }\\n        }\\n\\n        right[n-1] = -1;\\n        int nextHigh = n-1;\\n        for(int i=n-2; i>=0; i--) {\\n            if(security[i] <= security[i+1]) {\\n                right[i] = nextHigh;\\n            } else {\\n                right[i] = -1;\\n                nextHigh = i;\\n            }\\n        }\\n\\n        System.out.println(Arrays.toString(left));\\n        System.out.println(Arrays.toString(right));\\n\\n        for(int i=1; i<n-1;i++) {\\n            if(left[i] != -1 && right[i] != -1 && i- left[i] >= time && right[i] - i >= time) {\\n                res.add(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nCode block\\n\\n    // Pattern:  Decrease <-> Day <-> Increase\\n    // Index:    0, 1, 2, 3, 4, 5, 6\\n    // Input:    5, 3, 3, 3, 5, 6, 2\\n    \\n    //left:     -1, 0, 0, 0, 0,-1, 5\\n    //right:    -1, 5, 5, 5, 5,-1,-1\\n\\n    //Ans:      -1,-1, 2, 3,-1,-1,-1\\n```\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList<>();\\n        int n = security.length;\\n        if(time == 0) {\\n           for(int i=0; i<n; i++) {\\n               res.add(i);\\n           }\\n           return res; \\n        }\\n        \\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        left[0] = -1;\\n        int prevHigh = 0;\\n        for(int i=1; i<n; i++) {\\n            if(security[i] <= security[i-1]) {\\n                left[i] = prevHigh;\\n            } else {\\n                left[i] = -1;\\n                prevHigh = i;\\n            }\\n        }\\n\\n        right[n-1] = -1;\\n        int nextHigh = n-1;\\n        for(int i=n-2; i>=0; i--) {\\n            if(security[i] <= security[i+1]) {\\n                right[i] = nextHigh;\\n            } else {\\n                right[i] = -1;\\n                nextHigh = i;\\n            }\\n        }\\n\\n        System.out.println(Arrays.toString(left));\\n        System.out.println(Arrays.toString(right));\\n\\n        for(int i=1; i<n-1;i++) {\\n            if(left[i] != -1 && right[i] != -1 && i- left[i] >= time && right[i] - i >= time) {\\n                res.add(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888890,
                "title": "o-n-complexity-solution-using-sliding-windows",
                "content": "# Intuition\\nScan from left to right with index `i`\\n\\nKeep two sliding widows. One window - `beforeWindow` extends backwards from `i` and contains a sequence of non-increasing numbers. If i is larger than `i-1` then the window size is 0\\n\\nThe `afterWindow` keeps track of elements from `i + times` and extends backwards towards i. if `i + times + 1` is less than `i + times`, then this element size is also reset to 0\\n\\nWhenever the number of elements in both of these sliding windows equals `times`, then `i` is a good day.\\n\\n# Approach\\nBoth of these sliding widows can be maintained O(1), because we only need to compare the leading end of the window to the next element. If that \\nelement violates the condition for the window, the widow must be reset to 0. If it satisfies, then the window length increased by one element.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    beforeWindowLen := 0\\n    afterWindownLen := 0\\n\\n    res := []int{}\\n\\n    i := 0\\n    for i < len(security) {\\n        if beforeWindowLen >= time && afterWindownLen >= time {\\n            res = append(res, i)\\n        }\\n\\n        if i + time + 1 == len(security) {\\n            break\\n        }\\n\\n        if i + 1 < len(security) && security[i] >= security[i+1] {\\n            beforeWindowLen ++\\n        } else {\\n            beforeWindowLen = 0\\n        }\\n\\n        if i + time + 1 < len(security) && security[i + time] <= security[i + time + 1 ] {\\n            afterWindownLen ++\\n        } else {\\n            afterWindownLen = 0\\n        }\\n\\n        i ++\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    beforeWindowLen := 0\\n    afterWindownLen := 0\\n\\n    res := []int{}\\n\\n    i := 0\\n    for i < len(security) {\\n        if beforeWindowLen >= time && afterWindownLen >= time {\\n            res = append(res, i)\\n        }\\n\\n        if i + time + 1 == len(security) {\\n            break\\n        }\\n\\n        if i + 1 < len(security) && security[i] >= security[i+1] {\\n            beforeWindowLen ++\\n        } else {\\n            beforeWindowLen = 0\\n        }\\n\\n        if i + time + 1 < len(security) && security[i + time] <= security[i + time + 1 ] {\\n            afterWindownLen ++\\n        } else {\\n            afterWindownLen = 0\\n        }\\n\\n        i ++\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887399,
                "title": "java-easy-java-easy-to-understand-buteforce-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust bruteforce with on e edge case\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbruteforce\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean isDecreasing(int[] security,int start,int end){\\n        for(int i=start+1;i<=end;i++){\\n            if(security[i]>security[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n     public boolean isIncreasing(int[] security,int start,int end){\\n        for(int i=start+1;i<=end;i++){\\n            if(security[i]<security[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isGood(int[] security,int time,int idx){\\n\\n    if(!isDecreasing(security,idx-time,idx) || !isIncreasing(security,idx,idx+time) ){\\n        return false;\\n    }\\n    return true;\\n\\n    }\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        HashSet<Integer> set  = new HashSet<>();\\n    \\n\\n        for(int i=time;i<security.length-time;i++){\\n            if(set.contains(i-1) && (security[i] == security[i-1])){\\n               \\n                    if(security[i+time-1] <= security[i+time]){\\n                        \\n                        ans.add(i);\\n                        set.add(i);\\n                    }\\n\\n            }\\n            else if(i<security.length-time && isGood(security,time,i)){\\n             //   System.out.println(i);\\n                ans.add(i);\\n                set.add(i);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isDecreasing(int[] security,int start,int end){\\n        for(int i=start+1;i<=end;i++){\\n            if(security[i]>security[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n     public boolean isIncreasing(int[] security,int start,int end){\\n        for(int i=start+1;i<=end;i++){\\n            if(security[i]<security[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isGood(int[] security,int time,int idx){\\n\\n    if(!isDecreasing(security,idx-time,idx) || !isIncreasing(security,idx,idx+time) ){\\n        return false;\\n    }\\n    return true;\\n\\n    }\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        HashSet<Integer> set  = new HashSet<>();\\n    \\n\\n        for(int i=time;i<security.length-time;i++){\\n            if(set.contains(i-1) && (security[i] == security[i-1])){\\n               \\n                    if(security[i+time-1] <= security[i+time]){\\n                        \\n                        ans.add(i);\\n                        set.add(i);\\n                    }\\n\\n            }\\n            else if(i<security.length-time && isGood(security,time,i)){\\n             //   System.out.println(i);\\n                ans.add(i);\\n                set.add(i);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862747,
                "title": "c-prefix-sum-suffix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        int prefix[n],sufix[n];\\n        prefix[0]=0;sufix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n            else\\n            {\\n                prefix[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n            else\\n            {\\n                sufix[i]=0;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]>=time&&sufix[i]>=time)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        int prefix[n],sufix[n];\\n        prefix[0]=0;sufix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                prefix[i]=prefix[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2860961,
                "title": "java-simple-two-pass-forward-backward-solution",
                "content": "# Complexity\\n- Time complexity: O(n). O(n) for the forward pass, and O(n) for the backward pass.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) to store the forward pass result `nonIncr`.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        Boolean[] nonIncr = new Boolean[n];\\n        int prev = Integer.MAX_VALUE;\\n        int cnt = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (security[i] <= prev) {\\n                cnt += 1;\\n            }\\n            else {\\n                cnt = 0;\\n            }\\n            nonIncr[i] = cnt >= time ? true : false;\\n            prev = security[i];\\n        }\\n        int next = Integer.MAX_VALUE;\\n        cnt = -1;\\n        List<Integer> rst = new ArrayList<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (security[i] <= next) {\\n                cnt += 1;\\n            }\\n            else {\\n                cnt = 0;\\n            }\\n            if (cnt >= time && nonIncr[i]) {\\n                rst.add(i);\\n            }\\n            next = security[i];\\n        }\\n        return rst;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        Boolean[] nonIncr = new Boolean[n];\\n        int prev = Integer.MAX_VALUE;\\n        int cnt = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (security[i] <= prev) {\\n                cnt += 1;\\n            }\\n            else {\\n                cnt = 0;\\n            }\\n            nonIncr[i] = cnt >= time ? true : false;\\n            prev = security[i];\\n        }\\n        int next = Integer.MAX_VALUE;\\n        cnt = -1;\\n        List<Integer> rst = new ArrayList<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (security[i] <= next) {\\n                cnt += 1;\\n            }\\n            else {\\n                cnt = 0;\\n            }\\n            if (cnt >= time && nonIncr[i]) {\\n                rst.add(i);\\n            }\\n            next = security[i];\\n        }\\n        return rst;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860960,
                "title": "python-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        nums = security\\n        prevs = []\\n        posts = []\\n        pos = 0\\n        for i, v in enumerate(nums):\\n            if i == 0 or nums[i] > nums[i - 1]:\\n                pos = i\\n            prevs.append(i - pos)\\n        for i in range(len(nums) - 1, -1, -1):\\n            if i == len(nums) - 1 or nums[i + 1] < nums[i]:\\n                pos = i\\n            posts.append(pos - i)\\n        posts = posts[::-1]\\n            \\n        res = []\\n        for i, (v1, v2) in enumerate(zip(posts, prevs)):\\n            if v1 >= time and v2 >= time:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        nums = security\\n        prevs = []\\n        posts = []\\n        pos = 0\\n        for i, v in enumerate(nums):\\n            if i == 0 or nums[i] > nums[i - 1]:\\n                pos = i\\n            prevs.append(i - pos)\\n        for i in range(len(nums) - 1, -1, -1):\\n            if i == len(nums) - 1 or nums[i + 1] < nums[i]:\\n                pos = i\\n            posts.append(pos - i)\\n        posts = posts[::-1]\\n            \\n        res = []\\n        for i, (v1, v2) in enumerate(zip(posts, prevs)):\\n            if v1 >= time and v2 >= time:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854311,
                "title": "easy-and-clean-solution-with-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int [] nonInc = new int[security.length];\\n        int [] nonDec = new int[security.length];\\n        for(int i = 1; i < security.length;i++)\\n        {\\n            if(security[i] <= security[i-1])\\n            nonInc[i] = 1 + nonInc[i-1];\\n        }\\n        for(int i = security.length - 2; i >= 0;i--)\\n        {\\n            if(security[i] <= security[i+1])\\n            nonDec[i] = 1 + nonDec[i+1];\\n        }\\n        List<Integer> goodDays = new ArrayList<>();\\n        for(int i = time; i < security.length-time;i++)\\n        {\\n            if(nonInc[i] >= time && nonDec[i] >= time)\\n            goodDays.add(i);\\n        }\\n        return goodDays;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int [] nonInc = new int[security.length];\\n        int [] nonDec = new int[security.length];\\n        for(int i = 1; i < security.length;i++)\\n        {\\n            if(security[i] <= security[i-1])\\n            nonInc[i] = 1 + nonInc[i-1];\\n        }\\n        for(int i = security.length - 2; i >= 0;i--)\\n        {\\n            if(security[i] <= security[i+1])\\n            nonDec[i] = 1 + nonDec[i+1];\\n        }\\n        List<Integer> goodDays = new ArrayList<>();\\n        for(int i = time; i < security.length-time;i++)\\n        {\\n            if(nonInc[i] >= time && nonDec[i] >= time)\\n            goodDays.add(i);\\n        }\\n        return goodDays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825439,
                "title": "c-prefix-array-and-suffix-array-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> fromLeft(security.size(),0);\\n        vector<int> fromRight(security.size(),0);\\n        for(int i = 1; i < security.size(); i++) {\\n            if(security[i] <= security[i-1]) {\\n                fromLeft[i] = 1 + fromLeft[i-1];\\n            }\\n        }\\n        for(int i =  security.size() - 2; i >= 0; i--) {\\n            if(security[i] <= security[i+1]) {\\n                fromRight[i] = 1 + fromRight[i+1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i =0; i < security.size(); i++) {\\n            if(fromRight[i] >= time && fromLeft[i] >= time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> fromLeft(security.size(),0);\\n        vector<int> fromRight(security.size(),0);\\n        for(int i = 1; i < security.size(); i++) {\\n            if(security[i] <= security[i-1]) {\\n                fromLeft[i] = 1 + fromLeft[i-1];\\n            }\\n        }\\n        for(int i =  security.size() - 2; i >= 0; i--) {\\n            if(security[i] <= security[i+1]) {\\n                fromRight[i] = 1 + fromRight[i+1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i =0; i < security.size(); i++) {\\n            if(fromRight[i] >= time && fromLeft[i] >= time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801128,
                "title": "python3-prefix-sum-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\n      grid1 = [0, 1]\\n      grid2 = [0, 1]\\n\\n      for i in range(len(security)-1):\\n        if security[i] >= security[i+1]: grid1.append(1)\\n        else: grid1.append(0)\\n        if security[i] <= security[i+1]: grid2.append(1)\\n        else: grid2.append(0)\\n\\n      start = 0\\n      for i in range(len(grid1)):\\n        start += grid1[i]\\n        grid1[i] = start\\n\\n      start = 0\\n      for i in range(len(grid2)):\\n        start += grid2[i]\\n        grid2[i] = start\\n\\n      res = []\\n\\n      for t in range(time+1, len(grid1)-time):\\n        if grid1[t] - grid1[t-time] == time and grid2[t+time] - grid2[t] == time:\\n          res.append(t-1)\\n\\n      return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\n      grid1 = [0, 1]\\n      grid2 = [0, 1]\\n\\n      for i in range(len(security)-1):\\n        if security[i] >= security[i+1]: grid1.append(1)\\n        else: grid1.append(0)\\n        if security[i] <= security[i+1]: grid2.append(1)\\n        else: grid2.append(0)\\n\\n      start = 0\\n      for i in range(len(grid1)):\\n        start += grid1[i]\\n        grid1[i] = start\\n\\n      start = 0\\n      for i in range(len(grid2)):\\n        start += grid2[i]\\n        grid2[i] = start\\n\\n      res = []\\n\\n      for t in range(time+1, len(grid1)-time):\\n        if grid1[t] - grid1[t-time] == time and grid2[t+time] - grid2[t] == time:\\n          res.append(t-1)\\n\\n      return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792790,
                "title": "decreasing-sequence-o-n-explained-python",
                "content": "let element i be the last element of decreasing sequence from both left and right\\nif the length of both right and left sequence >= time+1, then ith element is valid\\n\\nYou can find the length of decreasing sequence using simple iteration and store them in an array.\\n\\nthen go through each element and validate using length of sequences\\n\\n**Time: O(n)\\nSpace:O(n)**\\n```\\ndef goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n    n = len(security)\\n    \\n    right = [1]*n\\n    for i in range(n-2, -1, -1):\\n        if security[i] <= security[i+1]:\\n            right[i] = right[i+1] + 1\\n    \\n    seq = 1\\n    ans = []\\n    for i in range(n):\\n        if i and security[i] <= security[i-1]:\\n            seq += 1\\n        else:\\n            seq = 1\\n        if min(seq, right[i]) >= time + 1:\\n            ans.append(i)\\n    \\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\ndef goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n    n = len(security)\\n    \\n    right = [1]*n\\n    for i in range(n-2, -1, -1):\\n        if security[i] <= security[i+1]:\\n            right[i] = right[i+1] + 1\\n    \\n    seq = 1\\n    ans = []\\n    for i in range(n):\\n        if i and security[i] <= security[i-1]:\\n            seq += 1\\n        else:\\n            seq = 1\\n        if min(seq, right[i]) >= time + 1:\\n            ans.append(i)\\n    \\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2789777,
                "title": "python-prefix-sum-o-n-time",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # O(n) time and space\\n        \\n        n = len(security)\\n        # number of non-increasing days before i-th day\\n        before = [0] * n\\n        # number of non-decreasing days after i-th day\\n        after = [0] * n\\n        \\n        count_before, count_after = 0, 0\\n        \\n        # fill arrays before and after in one pass\\n        for i in range(1, n):\\n            if security[i - 1] >= security[i]:\\n                count_before += 1\\n                before[i] = count_before\\n            else:\\n                count_before = 0\\n                \\n            if security[n - i - 1] <= security[n - i]:\\n                count_after += 1\\n                after[n - i - 1] = count_after\\n            else:\\n                count_after = 0\\n                \\n        result = []\\n        \\n        # the i-th day is considered good if before[i] and after[i] are greater than time\\n        for i in range(n):\\n            if before[i] >= time and after[i] >= time:\\n                result.append(i)\\n                \\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # O(n) time and space\\n        \\n        n = len(security)\\n        # number of non-increasing days before i-th day\\n        before = [0] * n\\n        # number of non-decreasing days after i-th day\\n        after = [0] * n\\n        \\n        count_before, count_after = 0, 0\\n        \\n        # fill arrays before and after in one pass\\n        for i in range(1, n):\\n            if security[i - 1] >= security[i]:\\n                count_before += 1\\n                before[i] = count_before\\n            else:\\n                count_before = 0\\n                \\n            if security[n - i - 1] <= security[n - i]:\\n                count_after += 1\\n                after[n - i - 1] = count_after\\n            else:\\n                count_after = 0\\n                \\n        result = []\\n        \\n        # the i-th day is considered good if before[i] and after[i] are greater than time\\n        for i in range(n):\\n            if before[i] >= time and after[i] >= time:\\n                result.append(i)\\n                \\n        return result\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1933112,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 2038564,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 2001092,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 2057754,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 2004577,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 1865398,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            }
        ]
    }
]