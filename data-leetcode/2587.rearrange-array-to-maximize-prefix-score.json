[
    {
        "title": "Rearrange Array to Maximize Prefix Score",
        "question_content": "You are given a 0-indexed integer array nums. You can rearrange the elements of nums to any order (including the given order).\nLet prefix be the array containing the prefix sums of nums after rearranging it. In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it. The score of nums is the number of positive integers in the array prefix.\nReturn the maximum score you can achieve.\n&nbsp;\nExample 1:\n\nInput: nums = [2,-1,0,1,-3,3,-3]\nOutput: 6\nExplanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].\nprefix = [2,5,6,5,2,2,-1], so the score is 6.\nIt can be shown that 6 is the maximum score we can obtain.\n\nExample 2:\n\nInput: nums = [-2,-3,0]\nOutput: 0\nExplanation: Any rearrangement of the array will result in a score of 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-106 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 3286459,
                "title": "explained-sort-positive-sum-count-very-simple-easy-to-understand-solution",
                "content": "# Approach \\nHere we need to check for the total prefix sum > 0.\\nTo do this all the positive number should be at the begining\\nso that the total possible sum must be maximum and after that we need to remove the -ve numbers from the smaller ones. \\n\\nSo we need to just sort it and start adding the elements and counting it \\nuntill we get the sum as -ve or zero.\\n\\n# Code\\n```\\n    int maxScore(vector<int>& nums) {\\n        long long ans = 0, sum = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = nums.size()-1; i >= 0; --i){\\n            sum += nums[i];\\n            if(sum > 0) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int maxScore(vector<int>& nums) {\\n        long long ans = 0, sum = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = nums.size()-1; i >= 0; --i){\\n            sum += nums[i];\\n            if(sum > 0) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286272,
                "title": "prefix-sum-of-sorted-array",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return sum(n > 0 for n in accumulate(sorted(nums, reverse=True)))\\n```\\n**C++**\\n```cpp\\nint maxScore(vector<int>& n) {\\n    sort(begin(n), end(n), greater<>());\\n    for (long long sum = 0, i = 0; i <= n.size(); sum += n[i++])\\n        if (i == n.size() || sum + n[i] <= 0)\\n            return i;\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return sum(n > 0 for n in accumulate(sorted(nums, reverse=True)))\\n```\n```cpp\\nint maxScore(vector<int>& n) {\\n    sort(begin(n), end(n), greater<>());\\n    for (long long sum = 0, i = 0; i <= n.size(); sum += n[i++])\\n        if (i == n.size() || sum + n[i] <= 0)\\n            return i;\\n    return 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286416,
                "title": "2587-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function maxScore that takes a list of integers nums as input and returns an integer.\\n2. Sort the input list nums in descending order.\\n3. Initialize a list prefix_sums with a single element 0.\\n4. Loop through the sorted list nums and compute the prefix sums, appending each sum to the list prefix_sums.\\n5. Initialize a variable max_score to 0.\\n6. Loop through the indices from 1 to the length of prefix_sums:\\na. If the current prefix sum is greater than 0, update max_score to the current index.\\n7. Return max_score.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(n),\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        prefix_sums = [0]\\n        for num in nums:\\n            prefix_sums.append(prefix_sums[-1] + num)\\n        max_score = 0\\n        for i in range(1, len(prefix_sums)):\\n            if prefix_sums[i] > 0:\\n                max_score = i\\n        return max_score\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        prefix_sums = [0]\\n        for num in nums:\\n            prefix_sums.append(prefix_sums[-1] + num)\\n        max_score = 0\\n        for i in range(1, len(prefix_sums)):\\n            if prefix_sums[i] > 0:\\n                max_score = i\\n        return max_score\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286854,
                "title": "c-easy-sorting",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        long long sum=0;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            sum+=nums[i];\\n            if(sum>0)\\n                cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        long long sum=0;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            sum+=nums[i];\\n            if(sum>0)\\n                cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286514,
                "title": "image-explanation-sort-positive-sum-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/_RzI3dDSdZA\\n\\n# Approach & Intuition\\n![image.png](https://assets.leetcode.com/users/images/3d221e11-8289-4bb2-9caf-1100bf9867e0_1678594617.1362967.png)\\n![image.png](https://assets.leetcode.com/users/images/076aa7ae-85b7-4b75-86c9-db7378d09de9_1678594624.92394.png)\\n\\n\\n# Code\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int n = nums.size();\\n        \\n        vector<ll> prefix(n);\\n        prefix[0] = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(prefix[i]>0ll)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int n = nums.size();\\n        \\n        vector<ll> prefix(n);\\n        prefix[0] = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(prefix[i]>0ll)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286263,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n log n)$$ \\n\\n- Space complexity: $$O(n)$$ where n is the size of the array\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] num) {\\n        Integer[] boxedArr = Arrays.stream(num).boxed().toArray(Integer[]::new);\\n        Arrays.sort(boxedArr, Comparator.reverseOrder());\\n        int[] nums = Arrays.stream(boxedArr).mapToInt(Integer::intValue).toArray();\\n        int sum=0;\\n        long p=0;\\n        for(int i:nums)\\n        {\\n            p+=(long)i;\\n            if(p>0)\\n            {\\n                sum++;\\n            }\\n            else\\n            {\\n                p=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] num) {\\n        Integer[] boxedArr = Arrays.stream(num).boxed().toArray(Integer[]::new);\\n        Arrays.sort(boxedArr, Comparator.reverseOrder());\\n        int[] nums = Arrays.stream(boxedArr).mapToInt(Integer::intValue).toArray();\\n        int sum=0;\\n        long p=0;\\n        for(int i:nums)\\n        {\\n            p+=(long)i;\\n            if(p>0)\\n            {\\n                sum++;\\n            }\\n            else\\n            {\\n                p=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287705,
                "title": "c-sorting",
                "content": "# Complexity\\n- Time complexity: **O(nlogn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        long long a=0;\\n        long long c=0;\\n        for(int i=0;i<v.size();i++){\\n            a+=v[i];\\n            if(a>0)c++;\\n        }\\n        return c;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/6dcba395-77ed-4d5e-a0a9-268614e8fdb8_1678612922.6857502.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        long long a=0;\\n        long long c=0;\\n        for(int i=0;i<v.size();i++){\\n            a+=v[i];\\n            if(a>0)c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286804,
                "title": "python-3-2-lines-t-m-100-46",
                "content": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse=True)\\n        \\n        return sum(n > 0 for n in accumulate(nums)) \\n```\\n[https://leetcode.com/problems/rearrange-array-to-maximize-prefix-score/submissions/1007225500/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse=True)\\n        \\n        return sum(n > 0 for n in accumulate(nums)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286419,
                "title": "full-explanation-sorting-and-prefix-sum-simple-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to first sort the numbers in the array in descending order (from largest to smallest) so that we can pick the biggest numbers first to maximize our score.\\n\\nThen create a new array that will store the cumulative sum of the numbers in the sorted array. This means that each element in the new array will be the sum of all the elements before it in the sorted array.\\n\\nThen loop through the sorted array, starting from the second element. For each element, it calculates the cumulative sum up to that element and stores it in the new array. If the sum is greater than 0, the code increments a counter variable.\\n\\nFinally, return the value of the counter variable, which represents the maximum score that can be obtained.\\n\\n# Complexity\\n- Time complexity: O(nlogn) for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<long long>prefix_sum(nums.size());\\n        \\n        prefix_sum[0]=nums[0];\\n        long long count=0;\\n        \\n        if(prefix_sum[0]>0) ++count;\\n        for(int i=1;i<nums.size();++i){\\n            prefix_sum[i] = prefix_sum[i-1]+nums[i];\\n            if(prefix_sum[i]>0) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<long long>prefix_sum(nums.size());\\n        \\n        prefix_sum[0]=nums[0];\\n        long long count=0;\\n        \\n        if(prefix_sum[0]>0) ++count;\\n        for(int i=1;i<nums.size();++i){\\n            prefix_sum[i] = prefix_sum[i-1]+nums[i];\\n            if(prefix_sum[i]>0) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286357,
                "title": "c-o-1-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n\\n        long long sum=0,ans=0;\\n        int n=nums.size(),i;\\n\\n        //positive values\\n        for(i=0;i<n;i++){\\n            if(nums[i]<=0)\\n                break;\\n            sum += nums[i];\\n        }\\n        ans = i;\\n        //non-positive values\\n        while(i<n ){\\n            sum += nums[i++];\\n            if(sum > 0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n\\n        long long sum=0,ans=0;\\n        int n=nums.size(),i;\\n\\n        //positive values\\n        for(i=0;i<n;i++){\\n            if(nums[i]<=0)\\n                break;\\n            sum += nums[i];\\n        }\\n        ans = i;\\n        //non-positive values\\n        while(i<n ){\\n            sum += nums[i++];\\n            if(sum > 0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286368,
                "title": "c-greedy-sorting-easy-code-with-logic",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*app 1: greedy way ==> rearrange numbers in descending order.\\n    T.c: O(N*logN)\\n    \\n    Intuition::\\n    \\n    to get max. no. of +ve integers, we should have max. no. of positive numbers\\n    in the beginning of array and then the negative numbers.\\n    \\n    bcos, doing so ensures that we have maximum possible +ve prefix sum.\\n    It\\'s like a greedy way of rearranging numbers.\\n    \\n    */\\n    int maxScore(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<long long> prefix(n);\\n        \\n        //sort the array in desc order\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        \\n        prefix[0]=nums[0];\\n        \\n        int score=0;\\n        if(prefix[0] > 0) score++;\\n        \\n        //count the no. of +ve numbers in prefix sum array\\n        for(int i=1; i<n; i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n            \\n            if(prefix[i] > 0) score++;\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*app 1: greedy way ==> rearrange numbers in descending order.\\n    T.c: O(N*logN)\\n    \\n    Intuition::\\n    \\n    to get max. no. of +ve integers, we should have max. no. of positive numbers\\n    in the beginning of array and then the negative numbers.\\n    \\n    bcos, doing so ensures that we have maximum possible +ve prefix sum.\\n    It\\'s like a greedy way of rearranging numbers.\\n    \\n    */\\n    int maxScore(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<long long> prefix(n);\\n        \\n        //sort the array in desc order\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        \\n        prefix[0]=nums[0];\\n        \\n        int score=0;\\n        if(prefix[0] > 0) score++;\\n        \\n        //count the no. of +ve numbers in prefix sum array\\n        for(int i=1; i<n; i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n            \\n            if(prefix[i] > 0) score++;\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286316,
                "title": "sort-then-prefix",
                "content": "# Complexity\\nTime `O(N * log N)`\\nSpace `O(N) #for sorting`\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, nums):\\n        nums.sort()\\n        res = prefix = 0\\n        while nums:\\n            prefix += nums.pop()\\n            if prefix > 0: \\n                res += 1\\n        return res\\n```\\n**UpVote**, if you like it :)",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, nums):\\n        nums.sort()\\n        res = prefix = 0\\n        while nums:\\n            prefix += nums.pop()\\n            if prefix > 0: \\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527200,
                "title": "c-simple-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(int &a,int &b){\\n        return a>b;\\n    }\\n    int maxScore(vector<int>& nums) {\\n        long long int x = 0;\\n        int y = 0;\\n        sort(nums.begin(),nums.end(),cmp);\\n        if(nums[0]<=0)return 0;\\n        for(auto &i: nums){\\n            x += i;\\n            if(x<=0){\\n                return y;\\n            }\\n            y++;\\n        }\\n        return y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(int &a,int &b){\\n        return a>b;\\n    }\\n    int maxScore(vector<int>& nums) {\\n        long long int x = 0;\\n        int y = 0;\\n        sort(nums.begin(),nums.end(),cmp);\\n        if(nums[0]<=0)return 0;\\n        for(auto &i: nums){\\n            x += i;\\n            if(x<=0){\\n                return y;\\n            }\\n            y++;\\n        }\\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288120,
                "title": "simple-js",
                "content": "ma# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxScore = function(nums) {\\n    nums.sort((a,b)=>{return b-a})\\n    let n = 0\\n    let c = nums[n]\\n    while(c > 0){\\n        n++\\n        c += nums[n]\\n    }\\n    return n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxScore = function(nums) {\\n    nums.sort((a,b)=>{return b-a})\\n    let n = 0\\n    let c = nums[n]\\n    while(c > 0){\\n        n++\\n        c += nums[n]\\n    }\\n    return n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3287085,
                "title": "simple-greedy-sorting-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we have to find maximum score.It mean we have to think greedily and we can even allow to change order to get maximum score.Sorting in reverse order would be perfect choice to get optimal order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the vector in Decending order.\\n2. Initialise sum and ans with value of 0.\\n3. Traverse through the vector and start adding element to sum.\\n4. If sum is greater then 0 the increase the count of ans by 1 else break the loop\\n5. Return the ans\\n\\n# Complexity\\n- Time complexity:O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        sort(nums.rbegin(),nums.rend());\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(sum>0) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        sort(nums.rbegin(),nums.rend());\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(sum>0) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286438,
                "title": "c-beginner-friendly-easy-code-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/c4cd943b-c116-401d-9f58-39727e476e9e_1678594063.466264.png)\\n\\n**T->O(n logn) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxScore(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\tlong long sum = 0;\\n\\t\\t\\t\\tsort(nums.begin(),nums.end(),greater<int>());\\n\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\t\\tif(sum > 0) ans++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxScore(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\tlong long sum = 0;\\n\\t\\t\\t\\tsort(nums.begin(),nums.end(),greater<int>());\\n\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\t\\tif(sum > 0) ans++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3286411,
                "title": "java-sorting-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxScore(int[] nums) {\\n    var n = nums.length;\\n    Arrays.sort(nums);\\n    \\n    var sum = 0L;\\n    var i = n-1;\\n    for (; i >= 0; i--) {\\n      sum += nums[i];\\n      if (sum <= 0) break;\\n    }\\n    return n-1-i;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  public int maxScore(int[] nums) {\\n    var n = nums.length;\\n    Arrays.sort(nums);\\n    \\n    var sum = 0L;\\n    var i = n-1;\\n    for (; i >= 0; i--) {\\n      sum += nums[i];\\n      if (sum <= 0) break;\\n    }\\n    return n-1-i;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286391,
                "title": "short-clean-java",
                "content": "```java []\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        long sum = 0;\\n        int i=nums.length-1;\\n        Arrays.sort(nums);\\n        if(nums[nums.length-1] == 0)    return 0;\\n        while(i >= 0){\\n            sum += nums[i--];\\n            if(sum <= 0) return nums.length-i-2;\\n        }\\n        return nums.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        long sum = 0;\\n        int i=nums.length-1;\\n        Arrays.sort(nums);\\n        if(nums[nums.length-1] == 0)    return 0;\\n        while(i >= 0){\\n            sum += nums[i--];\\n            if(sum <= 0) return nums.length-i-2;\\n        }\\n        return nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286323,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        <!-- sorting array is descending order by swapping -->\\n        for(int i=0;i<nums.length/2;i++){\\n            int ref=nums[i];\\n            nums[i]=nums[nums.length-i-1];\\n            nums[nums.length-i-1]=ref;\\n        }\\n        long sum=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(sum>0)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        <!-- sorting array is descending order by swapping -->\\n        for(int i=0;i<nums.length/2;i++){\\n            int ref=nums[i];\\n            nums[i]=nums[nums.length-i-1];\\n            nums[nums.length-i-1]=ref;\\n        }\\n        long sum=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(sum>0)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832549,
                "title": "python-3-greedy-with-optimisation-beats-100-594ms",
                "content": "```python3 []\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        res, s, negative = 0, 0, []\\n        for n in nums:\\n            if n > 0:\\n                s += n\\n                res += 1\\n            else:\\n                negative.append(n)\\n        negative.sort(reverse = True)\\n\\n        for n in negative:\\n           s += n # subtract negative n\\n           if s <= 0: break\\n           res += 1\\n\\n        return res\\n```\\n![Screenshot 2023-07-28 at 22.57.09.png](https://assets.leetcode.com/users/images/4c777287-e1ca-4442-a7ee-93b0c79fe80f_1690574360.4966478.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sort",
                    "Prefix Sum"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        res, s, negative = 0, 0, []\\n        for n in nums:\\n            if n > 0:\\n                s += n\\n                res += 1\\n            else:\\n                negative.append(n)\\n        negative.sort(reverse = True)\\n\\n        for n in negative:\\n           s += n # subtract negative n\\n           if s <= 0: break\\n           res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808309,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Sorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        long long sum = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (sum > 0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        long long sum = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (sum > 0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300396,
                "title": "easy-java-solution-intuition-sort-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**First of all sort the array and then Get the prefix sums of the array and then just count the total number of positive integer in the prefix array**\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        long sum = 0;\\n        for(int i = nums.length - 1; i >= 0; i --){\\n            sum += nums[i];\\n            if(sum > 0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        long sum = 0;\\n        for(int i = nums.length - 1; i >= 0; i --){\\n            sum += nums[i];\\n            if(sum > 0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292753,
                "title": "prefix-sum-of-sorted-array-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(int &a,int &b){\\n        return a>b;\\n    }\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),cmp);\\n        if(nums[0]<=0)return 0;\\n        long long int ans = 0;\\n        int i = 0,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            ans += nums[i];\\n            if(ans<=0)break;\\n        }\\n        return min(i,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(int &a,int &b){\\n        return a>b;\\n    }\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),cmp);\\n        if(nums[0]<=0)return 0;\\n        long long int ans = 0;\\n        int i = 0,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            ans += nums[i];\\n            if(ans<=0)break;\\n        }\\n        return min(i,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292151,
                "title": "easy-python-solution-runtime-100-memory-100",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        sm=sum(nums)\\n        cnt=0\\n        for i in nums:\\n            if sm>0:cnt+=1\\n            sm-=i\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        sm=sum(nums)\\n        cnt=0\\n        for i in nums:\\n            if sm>0:cnt+=1\\n            sm-=i\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291524,
                "title": "python-elegant-short-itertools-1-line",
                "content": "```\\nfrom itertools import accumulate\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return sum(p > 0 for p in accumulate(sorted(nums, reverse=True)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return sum(p > 0 for p in accumulate(sorted(nums, reverse=True)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288141,
                "title": "sort-pre-sum-faster-100-2-lines",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums, int res = 0, long long pre = 0) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for (auto num: nums) pre += num, res += pre > 0;\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums, int res = 0, long long pre = 0) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for (auto num: nums) pre += num, res += pre > 0;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287276,
                "title": "beginner-friendly-easy-to-understand-c-100-beats",
                "content": "# Intuition\\nAs it is clearly mentioned in the question  we have to arrange the given array in such a way that no of positive elements in the prefix of the array is maximum.\\n\\n# Approach\\nSort the array(so that all elements having highest value are at the end) and maintain the sum variable and a count variable c and keep on calculation the sum till it is greater than 0,return the count.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n//Greatest element at the end\\n        sort(nums.begin(),nums.end());\\n int c=0;\\n//To avoid integer overflow\\n       long long int sum=0;\\n        \\nfor(int i=nums.size()-1;i>=0;i--){\\nsum+=nums[i];\\n    if(sum>0){\\nc++;\\n    }\\n    else{\\nbreak;\\n    }\\n\\n}\\n        return c;\\n        \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n//Greatest element at the end\\n        sort(nums.begin(),nums.end());\\n int c=0;\\n//To avoid integer overflow\\n       long long int sum=0;\\n        \\nfor(int i=nums.size()-1;i>=0;i--){\\nsum+=nums[i];\\n    if(sum>0){\\nc++;\\n    }\\n    else{\\nbreak;\\n    }\\n\\n}\\n        return c;\\n        \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286427,
                "title": "go-c-sort-descending",
                "content": "# Approach\\n - Sort **nums** is descending.\\n - Sum **prefix**\\n - If **prefix** > 0, increase **res**, else return.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n- Space complexity: O(1)\\n\\n```Go []\\nfunc maxScore(nums []int) int {\\n\\tvar res int = 0\\n\\tvar prefix int64 = 0\\n\\tsort.SliceStable(nums, func(i, j int) bool {\\n\\t\\treturn nums[i] > nums[j]\\n\\t})\\n\\tfor _, num := range nums {\\n\\t\\tprefix += int64(num)\\n\\t\\tif prefix > 0 {\\n\\t\\t\\tres++\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\\n```C# []\\npublic class Solution {\\n    public int MaxScore(int[] nums)\\n    {\\n        int res = 0;\\n        long predix = 0;\\n        Array.Sort(nums, (a, b) => b - a);\\n        foreach (int num in nums)\\n        {\\n            predix += num;\\n            if (predix > 0)\\n                res++;\\n            else\\n                return res; ;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```Go []\\nfunc maxScore(nums []int) int {\\n\\tvar res int = 0\\n\\tvar prefix int64 = 0\\n\\tsort.SliceStable(nums, func(i, j int) bool {\\n\\t\\treturn nums[i] > nums[j]\\n\\t})\\n\\tfor _, num := range nums {\\n\\t\\tprefix += int64(num)\\n\\t\\tif prefix > 0 {\\n\\t\\t\\tres++\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\n```C# []\\npublic class Solution {\\n    public int MaxScore(int[] nums)\\n    {\\n        int res = 0;\\n        long predix = 0;\\n        Array.Sort(nums, (a, b) => b - a);\\n        foreach (int num in nums)\\n        {\\n            predix += num;\\n            if (predix > 0)\\n                res++;\\n            else\\n                return res; ;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286350,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        long long ans=0, sum=0;\\n        for(auto it=crbegin(nums);it!=crend(nums);++it){ // iterate from right(+ve)  to left (-ve)\\n            sum = sum + *it;\\n            if(sum<1){\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        long long ans=0, sum=0;\\n        for(auto it=crbegin(nums);it!=crend(nums);++it){ // iterate from right(+ve)  to left (-ve)\\n            sum = sum + *it;\\n            if(sum<1){\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286340,
                "title": "kadanes-algo-simple",
                "content": "Intuition: KADANE\\u2019S Algorithm \\nAs the question state we can arrange in any order. So Sort the given array and find all the Prefixsum which is greater than 0 and then increase count and when ever we encounter PrefixSum<0 we have to make it 0.\\nAs we can see in the explanation also 0 is not counted in the examples. So we have to discard and take all the Prefixsum >0 and based on this our count will be increased.\\nThe time complexity is O(nlogn) bcoz of sorting. Overall time complexity due to our for loop is O(N).\\nThank You.\\n\\nPlease Upvote if you like the approach.\\n\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        \\n       long sum=0;\\n        int count=0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum+=nums[i];\\n            \\n            if(sum>0){\\n                count++;\\n            }else{\\n                sum=0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        \\n       long sum=0;\\n        int count=0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum+=nums[i];\\n            \\n            if(sum>0){\\n                count++;\\n            }else{\\n                sum=0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382689,
                "title": "easy-c-o-n-just-count-the-positive-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        vector<int> neg;\\n        long int sum=0;\\n        int count=0;\\n        for(auto x:nums){\\n            if(x>0){\\n                sum=sum+x;\\n                count++;\\n            }\\n            else{\\n                neg.push_back(x);\\n            }\\n        }\\n        sort(neg.begin(),neg.end());\\n        reverse(neg.begin(),neg.end());\\n        for(auto x:neg){\\n            sum=sum+x;\\n            if(sum > 0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        vector<int> neg;\\n        long int sum=0;\\n        int count=0;\\n        for(auto x:nums){\\n            if(x>0){\\n                sum=sum+x;\\n                count++;\\n            }\\n            else{\\n                neg.push_back(x);\\n            }\\n        }\\n        sort(neg.begin(),neg.end());\\n        reverse(neg.begin(),neg.end());\\n        for(auto x:neg){\\n            sum=sum+x;\\n            if(sum > 0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322726,
                "title": "c-sorting-prefix-sum-faster-easy-to-understand",
                "content": "* ***Using Sorting && Prefix Sum***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        long long score = 0;\\n        \\n        int ans = 0;\\n        \\n        // sort the array in ascending order\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // traverse over the nums from right side\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            score += nums[i];\\n            \\n            if(score > 0)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        long long score = 0;\\n        \\n        int ans = 0;\\n        \\n        // sort the array in ascending order\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // traverse over the nums from right side\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            score += nums[i];\\n            \\n            if(score > 0)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312632,
                "title": "c-beginner-friendly-easy-code-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long int sum=0;\\n        int n=nums.size(),count=0;\\n        sort(nums.rbegin(),nums.rend());\\n        for(int i=0;i<n;i++)\\n        {\\n            sum += nums[i];\\n            if(sum>0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long int sum=0;\\n        int n=nums.size(),count=0;\\n        sort(nums.rbegin(),nums.rend());\\n        for(int i=0;i<n;i++)\\n        {\\n            sum += nums[i];\\n            if(sum>0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306159,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func maxScore(_ nums: [Int]) -> Int {\\n        let sorted = nums.sorted(by: >)\\n        var ans = 0\\n        var sum = 0\\n        \\n        for i in 0..<sorted.count{\\n            sum += sorted[i]\\n            if sum > 0{\\n                ans += 1\\n            }\\n        }\\n        \\n        return ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxScore(_ nums: [Int]) -> Int {\\n        let sorted = nums.sorted(by: >)\\n        var ans = 0\\n        var sum = 0\\n        \\n        for i in 0..<sorted.count{\\n            sum += sorted[i]\\n            if sum > 0{\\n                ans += 1\\n            }\\n        }\\n        \\n        return ans\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296634,
                "title": "cpp-sort-and-count-easy-solution-no-runtime-error",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        int c=0;\\n        long long int ans=0;     //use long long to avoid runtime error\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=nums[i];\\n            if(ans>0)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        int c=0;\\n        long long int ans=0;     //use long long to avoid runtime error\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=nums[i];\\n            if(ans>0)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296484,
                "title": "greedy-sorting-very-easy-to-understand-must-see",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        //to count the numbe of positive integers in the nums\\n        int count = 0;\\n\\n        //making the prefix vector to hold the final ans\\n        vector<long long int>prefix(nums.size());    \\n\\n        //sorting the nums in greater<int>()\\n        sort(nums.begin(),nums.end(),greater<int>());\\n\\n        if(nums[0] <= 0)\\n        return 0;\\n\\n        count++;\\n        prefix[0] = nums[0];\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            prefix[i] = prefix[i-1] + nums[i];\\n            if(prefix[i] > 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        //to count the numbe of positive integers in the nums\\n        int count = 0;\\n\\n        //making the prefix vector to hold the final ans\\n        vector<long long int>prefix(nums.size());    \\n\\n        //sorting the nums in greater<int>()\\n        sort(nums.begin(),nums.end(),greater<int>());\\n\\n        if(nums[0] <= 0)\\n        return 0;\\n\\n        count++;\\n        prefix[0] = nums[0];\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            prefix[i] = prefix[i-1] + nums[i];\\n            if(prefix[i] > 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3292004,
                "title": "simple-java-solution-10-lines",
                "content": "# Approach\\nWe can follow the Greedy approach, and sort the array. Then we will find the sum of elements till it becomes negative and the index before that will be our answer.\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic int maxScore(int[] nums) {\\n    Arrays.sort(nums);\\n    long sum = 0;\\n    for(int i = nums.length - 1; i >= 0; i--) {\\n        sum += nums[i];\\n        if(sum <= 0)\\n            return nums.length - i - 1;\\n    }\\n    return nums.length;\\n}\\n```\\nPlease upvote, if you found it useful.",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic int maxScore(int[] nums) {\\n    Arrays.sort(nums);\\n    long sum = 0;\\n    for(int i = nums.length - 1; i >= 0; i--) {\\n        sum += nums[i];\\n        if(sum <= 0)\\n            return nums.length - i - 1;\\n    }\\n    return nums.length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3289449,
                "title": "sorting",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just need to sort the array in Decsesing order after that \\nWe will add all elements to the sum now we just need to check \\nWhen the sum becomes 0 or less than zero after that there is no need to check beccause it can never become maximum soln \\nwe return count\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        sum=count=0\\n        for i in nums:\\n            sum+=i\\n            if(sum<=0):\\n                return count\\n            else:\\n                count+=1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        sum=count=0\\n        for i in nums:\\n            sum+=i\\n            if(sum<=0):\\n                return count\\n            else:\\n                count+=1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288246,
                "title": "python-1-line-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe must first put the positive numbers then zeros then negative numbers to get the most positives numbers in the accumulation\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst reverse sort the nums\\nthen accumulate\\nthen count the number of positive ones\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return sum(x > 0 for x in accumulate(sorted(nums, reverse=True)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return sum(x > 0 for x in accumulate(sorted(nums, reverse=True)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288199,
                "title": "sort-easy-c-solution",
                "content": "# Intuition\\nFor maximum no of prefixes to be positive :-\\n- Large positive numbers should be at beginning(if any).\\n- If Positive numbers are absent , then no positive prefix exist.\\n\\n# Approach\\n- Check if any postive number is present in vector, if not return 0.\\n- Sort the vector in descending order and find the prefix sum of the vector.Increase the variable if prefix sum is positive.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int n = nums.size();\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > 0) cnt++;\\n        }\\n        if(!cnt) return 0;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<long long> prefix;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            prefix.push_back(sum);\\n        }\\n        cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(prefix[i] > 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int n = nums.size();\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > 0) cnt++;\\n        }\\n        if(!cnt) return 0;\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        vector<long long> prefix;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            prefix.push_back(sum);\\n        }\\n        cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(prefix[i] > 0) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287987,
                "title": "easy-python3-solution-o-nlogn",
                "content": "Simple use the sort function or use the 2 pointer approach to bring all the positive elements of the array in the front and pushing all the negative elementsof the array to the back.\\n\\n```\\ndef maxScore(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse =True)\\n        \\n        prefix = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            prefix.append(prefix[-1] + nums[i])\\n        \\n        count  = 0\\n        \\n        for i in prefix:\\n            if i > 0:\\n                count +=1\\n        \\n        return count\\n```\\n\\nediting the solution a bit and decreasing one for loop:\\n```\\n\\t\\tnums.sort(reverse =True)\\n        \\n\\t\\tprefix = [nums[0]]\\n        count = 0\\n        count +=1 if prefix[-1] > 0 else 0\\n        \\n        for i in range(1,len(nums)):\\n            prefix.append(prefix[-1] + nums[i])\\n            if prefix[-1] > 0:\\n                count +=1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\ndef maxScore(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse =True)\\n        \\n        prefix = [nums[0]]\\n        \\n        for i in range(1,len(nums)):\\n            prefix.append(prefix[-1] + nums[i])\\n        \\n        count  = 0\\n        \\n        for i in prefix:\\n            if i > 0:\\n                count +=1\\n        \\n        return count\\n```\n```\\n\\t\\tnums.sort(reverse =True)\\n        \\n\\t\\tprefix = [nums[0]]\\n        count = 0\\n        count +=1 if prefix[-1] > 0 else 0\\n        \\n        for i in range(1,len(nums)):\\n            prefix.append(prefix[-1] + nums[i])\\n            if prefix[-1] > 0:\\n                count +=1\\n                \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3287718,
                "title": "swift-solution-in-sorted-array-o-nlogn",
                "content": "# Code\\n```\\nclass Solution {\\n    func maxScore(_ nums: [Int]) -> Int {\\n        let nums = nums.sorted(by: >)\\n        var subsum = 0\\n        var res = 0\\n\\n        for num in nums {\\n            subsum += num\\n            if subsum > 0 {\\n                res += 1\\n            } else {\\n                break\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxScore(_ nums: [Int]) -> Int {\\n        let nums = nums.sorted(by: >)\\n        var subsum = 0\\n        var res = 0\\n\\n        for num in nums {\\n            subsum += num\\n            if subsum > 0 {\\n                res += 1\\n            } else {\\n                break\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287039,
                "title": "python-count-the-number-of-negative-numbers-and-zeros-explained",
                "content": "We can count the number of negative numbers and zeros in the list.\\n\\nIf the sum of all the positive numbers is larger than 0 (i.e., we have positive prefix sum), we can first append zeros to the arranged list starting with all the positive numbers. After that, we append the negative numbers from the smallest so that we can get the longest prefix sum list.\\n\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        negative_nums = []\\n        score, psum, zeros = 0, 0, 0\\n        for num in nums:\\n            if num > 0:\\n                score += 1\\n                psum += num\\n            elif num == 0:\\n                zeros += 1\\n            else:\\n                heapq.heappush(negative_nums, -num)\\n        \\n        if psum > 0:\\n            score += zeros\\n        \\n        while negative_nums:\\n            n = heapq.heappop(negative_nums)\\n            psum = psum - n\\n            if psum > 0:\\n                score += 1\\n            else:\\n                break\\n        return score\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        negative_nums = []\\n        score, psum, zeros = 0, 0, 0\\n        for num in nums:\\n            if num > 0:\\n                score += 1\\n                psum += num\\n            elif num == 0:\\n                zeros += 1\\n            else:\\n                heapq.heappush(negative_nums, -num)\\n        \\n        if psum > 0:\\n            score += zeros\\n        \\n        while negative_nums:\\n            n = heapq.heappop(negative_nums)\\n            psum = psum - n\\n            if psum > 0:\\n                score += 1\\n            else:\\n                break\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286702,
                "title": "easy-java-solution",
                "content": "\\n\\n# Approach\\nsort the array and start from last index add that value in sum if sum is greater than 0 then count++ else break\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: NlogN+N\\n NlogN - > sorting Array\\n N -> for loop\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n       \\n        int ans=0;\\n        long sum=0;\\n        Arrays.sort(nums);\\n        \\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n           sum+=nums[i];\\n            if(sum>0)\\n            {\\n                ans++;\\n            }\\n            else{\\n                break;\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\uD83D\\uDC46 vote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n       \\n        int ans=0;\\n        long sum=0;\\n        Arrays.sort(nums);\\n        \\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n           sum+=nums[i];\\n            if(sum>0)\\n            {\\n                ans++;\\n            }\\n            else{\\n                break;\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286686,
                "title": "c-easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        sort(begin(nums),end(nums),greater<>());\\n        \\n        long long sum = 0, res = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            if(sum > 0)\\n                res++;\\n            else\\n                break;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        sort(begin(nums),end(nums),greater<>());\\n        \\n        long long sum = 0, res = 0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            if(sum > 0)\\n                res++;\\n            else\\n                break;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286655,
                "title": "fastest-and-easiest-java-solution",
                "content": "If you like then upvote it and if you don\\'t understand then comment it.\\nTime complexity = O(nlogn) for sorting\\nSpace complexity = O(1) because we didn\\'t use any extra space.\\n\\n```\\n   \\nclass Solution {\\n   void swap(int[] nums, int i, int j)\\n   {\\n       int temp = nums[i];\\n       nums[i]= nums[j];\\n       nums[j]=temp;\\n   }\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int i=0,j=n-1;\\n        //Reversing the sorted array\\n        while(i<j)\\n        {\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n       \\n        int count=0;\\n        // Making prefixSum long for managing overflow situation\\n        long prefixSum = 0;\\n        for(i=0;i<nums.length;i++)\\n        {\\n            prefixSum += nums[i];\\n            if(prefixSum>0)\\n                count++;\\n\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   \\nclass Solution {\\n   void swap(int[] nums, int i, int j)\\n   {\\n       int temp = nums[i];\\n       nums[i]= nums[j];\\n       nums[j]=temp;\\n   }\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int i=0,j=n-1;\\n        //Reversing the sorted array\\n        while(i<j)\\n        {\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n       \\n        int count=0;\\n        // Making prefixSum long for managing overflow situation\\n        long prefixSum = 0;\\n        for(i=0;i<nums.length;i++)\\n        {\\n            prefixSum += nums[i];\\n            if(prefixSum>0)\\n                count++;\\n\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286516,
                "title": "simple-c-soln-sort-fn-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing sort function and iterating aproach \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        long long sum = 0;\\n        int score = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (sum > 0) {\\n                score++;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        long long sum = 0;\\n        int score = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            if (sum > 0) {\\n                score++;\\n            }\\n        }\\n        return score;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286500,
                "title": "4-line-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst sort array and then doing prefix sum from end of array, as i have sorted array in ascending order. While taking sum also count number of prefix sum which are greater than 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        <!-- sorting array -->\\n        Arrays.sort(nums);\\n        <!-- counting and taking sum from end of list-->\\n        int count=0;\\n        long sum=0;\\n        for(int i=nums.length-1; i>=0; i--){\\n            sum+=nums[i];\\n            if(sum>0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        <!-- sorting array -->\\n        Arrays.sort(nums);\\n        <!-- counting and taking sum from end of list-->\\n        int count=0;\\n        long sum=0;\\n        for(int i=nums.length-1; i>=0; i--){\\n            sum+=nums[i];\\n            if(sum>0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286490,
                "title": "simple-python3-o-nlog-n-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        s = 0\\n        for i, n in enumerate(nums):\\n            s += n\\n            if s <= 0:\\n                return i\\n        return len(nums)\\n        \\n```\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        s = 0\\n        for i, n in enumerate(nums):\\n            s += n\\n            if s <= 0:\\n                return i\\n        return len(nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286374,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n      sort(nums.begin(),nums.end(),greater<int>());\\n        int n=nums.size();\\n        vector<long long>pre(n);\\n        int ans=0;\\n        pre[0]=nums[0];\\n        if(pre[0]>0) ans++;\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n            if(pre[i]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n      sort(nums.begin(),nums.end(),greater<int>());\\n        int n=nums.size();\\n        vector<long long>pre(n);\\n        int ans=0;\\n        pre[0]=nums[0];\\n        if(pre[0]>0) ans++;\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n            if(pre[i]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286341,
                "title": "sort-descending-and-create-prefix-check-positive-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        long long positiveSum = 0, ans = 0, n = nums.size();\\n        vector<long long> prefSum(n);\\n        prefSum[0] = nums[0];\\n        for(int i = 1; i < n; ++i)  prefSum[i] = prefSum[i - 1] + nums[i];\\n        for(int i = 0; i < n; ++i){\\n            if(prefSum[i] <= 0) return i;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nCan also instead use single variable to keep track of prefix Sum, will reduce the space complexity to O(1)",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Simulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        long long positiveSum = 0, ans = 0, n = nums.size();\\n        vector<long long> prefSum(n);\\n        prefSum[0] = nums[0];\\n        for(int i = 1; i < n; ++i)  prefSum[i] = prefSum[i - 1] + nums[i];\\n        for(int i = 0; i < n; ++i){\\n            if(prefSum[i] <= 0) return i;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286332,
                "title": "c-solution-sorting-prefix-java",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   static bool cmp(int a,int b){\\n        return a>b;\\n    }\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),cmp);\\n        \\n        if(nums[nums.size()-1]>0)return nums.size();\\n        \\n        int ans=0;\\n        long long int prefix=0;\\n        for(auto i:nums){\\n            prefix+=i;\\n            if(prefix>0)ans++;\\n            }        \\n        \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   static bool cmp(int a,int b){\\n        return a>b;\\n    }\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),cmp);\\n        \\n        if(nums[nums.size()-1]>0)return nums.size();\\n        \\n        int ans=0;\\n        long long int prefix=0;\\n        for(auto i:nums){\\n            prefix+=i;\\n            if(prefix>0)ans++;\\n            }        \\n        \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286321,
                "title": "steps-explained-beginner-friendly-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs given in the question, we need to find no of positives after performing prefix sum.\\nWe can also do this without using prefix array but, as we are performing prefix sum they are the chances of integer overflow so we need to declare prefix array with long datatype.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Sort the Array nums\\n2. Reverse the Array nums\\n3. Prefix sum\\n4. Count no. of positives\\n\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![upvotecat.jpg](https://assets.leetcode.com/users/images/e00937a5-6059-4d87-8762-f0b297f14ef4_1678593464.2677944.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        \\n        Arrays.sort(nums);// 1. Sort array\\n\\n        int n=nums.length;\\n        int lastindex=n-1;\\n        for(int i=0;i<n/2;i++)//2. Reverse array\\n        {\\n            int t= nums[i];\\n            nums[i]=nums[lastindex];\\n            nums[lastindex]=t;\\n            lastindex--;\\n        }\\n        \\n        long[] prefarray=new long[nums.length];// declaring with long datatype\\n        prefarray[0]=nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)//3. performing prefix sum\\n        {\\n            prefarray[i]=prefarray[i-1]+nums[i];\\n        }\\n        int count=0;\\n        \\n        //System.out.println(Arrays.toString(prefarray));\\n        \\n        for(long i:prefarray)//4. counting no. of positives\\n            if(i>0)\\n                count++;\\n\\n        return count;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        \\n        Arrays.sort(nums);// 1. Sort array\\n\\n        int n=nums.length;\\n        int lastindex=n-1;\\n        for(int i=0;i<n/2;i++)//2. Reverse array\\n        {\\n            int t= nums[i];\\n            nums[i]=nums[lastindex];\\n            nums[lastindex]=t;\\n            lastindex--;\\n        }\\n        \\n        long[] prefarray=new long[nums.length];// declaring with long datatype\\n        prefarray[0]=nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)//3. performing prefix sum\\n        {\\n            prefarray[i]=prefarray[i-1]+nums[i];\\n        }\\n        int count=0;\\n        \\n        //System.out.println(Arrays.toString(prefarray));\\n        \\n        for(long i:prefarray)//4. counting no. of positives\\n            if(i>0)\\n                count++;\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286320,
                "title": "java-accepted-solution-sorting-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; i--){\\n            sum += nums[i];\\n            prefix[i] = sum;\\n            if(prefix[i] > 0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i = n - 1; i >= 0; i--){\\n            sum += nums[i];\\n            prefix[i] = sum;\\n            if(prefix[i] > 0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286300,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int maxScore(vector<int>& nums1) {\\n        \\n        int cnt=0;\\n        int n=nums1.size();\\n        sort(nums1.begin(),nums1.end());\\n        reverse(nums1.begin(),nums1.end());\\n        vector<long long>nums(n+1);\\n        nums[0]=nums1[0];\\n       for(long long i=1;i<n;i++){\\n           nums[i]=(nums[i-1]+nums1[i]);\\n       }\\n        for(long long i=0;i<n;i++){\\n           if(nums[i]>0)cnt++;\\n       }\\n       return cnt;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int maxScore(vector<int>& nums1) {\\n        \\n        int cnt=0;\\n        int n=nums1.size();\\n        sort(nums1.begin(),nums1.end());\\n        reverse(nums1.begin(),nums1.end());\\n        vector<long long>nums(n+1);\\n        nums[0]=nums1[0];\\n       for(long long i=1;i<n;i++){\\n           nums[i]=(nums[i-1]+nums1[i]);\\n       }\\n        for(long long i=0;i<n;i++){\\n           if(nums[i]>0)cnt++;\\n       }\\n       return cnt;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286297,
                "title": "easiest-java-solution-step-by-step-deatailed-expalined",
                "content": "# Intuition\\nSince question is to count the maximum number of score you can achieve . \\nAnd the score of nums is the number of positive integers in the array prefix and prefix is the array containing the prefix sums of nums after rearranging it.\\n In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it.\\n\\n In order to maximize the score we need to keep all the positive element continuously. **We can do it by sorting the given array.**\\n Here no need to take extra space for prefix sum, since we just have to count the number of positive sum we can store it in variable and carry through the whole array.\\n\\n**One more catch** is that we need to take sum variable long because of the constraint given ***(-106 <= nums[i] <= 106)*** . If we will store sum in integer varaible it might give you wrong sum due to integer overflow.\\n Then iterate throught the array, add arr[i] to sum, If at the current index sum>0 add 1 to answer.\\n\\n# Approach\\n> Step 1: Sort the given array.\\n\\n**You can sort it in descending order as well but I have sorted int ascending order.**\\n\\n> Step 2: Intialize a variable sum(long) = 0;\\n\\n> Step 3: Intialize a variable max(int) = 0, in which we will store answer.\\n\\n> step 4: Traverse the array from right to left (if array is sorted in ascending order) and left to right (if array is sorted in descending order), add current index element to sum and check if it is greater than 0, if it is add 1 to answer.\\n\\n> step 5: Return answer.\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        long sum=0;\\n        int ans=0;\\n        int n=nums.length-1;\\n        \\n        for(int i=n;i>=0;i--){\\n            sum+=nums[i];\\n            if(sum>0)ans++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n``` []\\nThanks for viewing the solution.\\nHope it helps, if it does, please leave a comment below \\uD83D\\uDE4F\\nAnd do consider UPVOTING \\u2B06\\uFE0F Because it motivates me,\\nwriting such solution.\\n```\\n \\n![please_upvote.jpeg](https://assets.leetcode.com/users/images/7349644a-8b47-4bc8-a9e0-5d39aa224036_1678591128.170461.jpeg)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        long sum=0;\\n        int ans=0;\\n        int n=nums.length-1;\\n        \\n        for(int i=n;i>=0;i--){\\n            sum+=nums[i];\\n            if(sum>0)ans++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n``` []\\nThanks for viewing the solution.\\nHope it helps, if it does, please leave a comment below \\uD83D\\uDE4F\\nAnd do consider UPVOTING \\u2B06\\uFE0F Because it motivates me,\\nwriting such solution.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286290,
                "title": "c-sort-then-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),[](int a,int b){\\n           return a>b; \\n        });\\n        long long ans=0,cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans += nums[i];\\n            if(ans > 0) cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),[](int a,int b){\\n           return a>b; \\n        });\\n        long long ans=0,cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans += nums[i];\\n            if(ans > 0) cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286277,
                "title": "java-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        desc(nums);\\n        int n=nums.length;\\n        long[]pre=new long[n];\\n        int maxScore=0;\\n        pre[0]=nums[0];\\n        if(pre[0]>0) maxScore++;\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n            if(pre[i]>0){\\n                maxScore++;\\n            }\\n        }\\n        return maxScore;\\n    }\\n    \\n    public void desc(int[]nums){\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        for(int i=0;i<n/2;i++){\\n            int temp=nums[i];\\n            nums[i]=nums[n-i-1];\\n            nums[n-1-i]=temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        desc(nums);\\n        int n=nums.length;\\n        long[]pre=new long[n];\\n        int maxScore=0;\\n        pre[0]=nums[0];\\n        if(pre[0]>0) maxScore++;\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n            if(pre[i]>0){\\n                maxScore++;\\n            }\\n        }\\n        return maxScore;\\n    }\\n    \\n    public void desc(int[]nums){\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        for(int i=0;i<n/2;i++){\\n            int temp=nums[i];\\n            nums[i]=nums[n-i-1];\\n            nums[n-1-i]=temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286258,
                "title": "best-solution-in-c-sorting-o-1-sc",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long ps=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            ps+=nums[i];\\n            if(ps>0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long ps=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            ps+=nums[i];\\n            if(ps>0)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286254,
                "title": "python-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        pre = 0\\n        output = 0\\n        for i in range(len(nums)):\\n            pre += nums[i]\\n            if pre > 0:\\n                output += 1\\n            else:\\n                break\\n                \\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        pre = 0\\n        output = 0\\n        for i in range(len(nums)):\\n            pre += nums[i]\\n            if pre > 0:\\n                output += 1\\n            else:\\n                break\\n                \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057618,
                "title": "java-27ms-beats-100-clean-code",
                "content": "# Approach\\n1. As the problem states, it wants you to carefully build an array of prefix sums and count how many positive elements does this array have\\n2. EG: -5,-6,4,3,1,2,4\\n    - Its prefix sum is [-5,-11,-7,-4,-3,-1,3]. This has only 1 positive sum/element\\n3. What is you sort this the input array?\\n    - 4,4,3,2,1,-5,-6 => prefix sum array: [4,8,11,13,14,9,3]\\n4. As you can see, ordering it and traversing it from max to min would give a better count of positive sum\\n5. Sort the array (Arrays.sort sorts it in increasing order)\\n6. From max to min, calculate the prefixSum. Stop when prefixSum reaches 0 or below\\n    - Keep a counter of how many steps you have made with a positive prefixSum.\\n7. Return number of steps.  \\n\\n# Complexity\\n- Time complexity:$$O(n * log(n) + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        int maxScore = 0;\\n        long currentSum = 0;\\n        Arrays.sort(nums);\\n        for (int i = nums.length -1; i >= 0; i--) {\\n            currentSum += (long)nums[i];\\n            if (currentSum > 0) {\\n                maxScore++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        int maxScore = 0;\\n        long currentSum = 0;\\n        Arrays.sort(nums);\\n        for (int i = nums.length -1; i >= 0; i--) {\\n            currentSum += (long)nums[i];\\n            if (currentSum > 0) {\\n                maxScore++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034701,
                "title": "swift-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    func maxScore(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted { $0 > $1 } // just sort in decreasing order! (reduce the chances for getting negative numbers early, as we are always computing presum from left to right)\\n        var sum = 0\\n        var count = 0\\n        for n in nums {\\n            sum += n\\n            if sum <= 0 {\\n                break // no need to compute further, rest all the element will negative from here on ( as its decreasing)\\n            }\\n            count += sum > 0 ? 1 : 0\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    func maxScore(_ nums: [Int]) -> Int {\\n        var nums = nums.sorted { $0 > $1 } // just sort in decreasing order! (reduce the chances for getting negative numbers early, as we are always computing presum from left to right)\\n        var sum = 0\\n        var count = 0\\n        for n in nums {\\n            sum += n\\n            if sum <= 0 {\\n                break // no need to compute further, rest all the element will negative from here on ( as its decreasing)\\n            }\\n            count += sum > 0 ? 1 : 0\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001855,
                "title": "greedy-sort-in-descending-and-then-return-index-till-prefix-sum-is-positive",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int i = 0;\\n        long long prefixSum = 0;\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        \\n        while(i < nums.size())\\n        {\\n         prefixSum += nums[i];\\n         if(prefixSum <= 0) break;\\n         i++;\\n        }   \\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int i = 0;\\n        long long prefixSum = 0;\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        \\n        while(i < nums.size())\\n        {\\n         prefixSum += nums[i];\\n         if(prefixSum <= 0) break;\\n         i++;\\n        }   \\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947881,
                "title": "c-easy-sorting-time-0-n-logn-space-0-1-positive-sum-sorting-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long long  sum=0,counter=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0){\\n                sum+=nums[i];\\n                counter++;\\n                nums[i]=INT_MIN;\\n            }\\n        }\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int j=0;\\n        while(sum>0 && nums[j]!=INT_MIN && j<nums.size())\\n        {\\n            if((sum+nums[j])>0)sum+=nums[j];\\n            else break;\\n            j++;\\n        }\\n        return counter+j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long long  sum=0,counter=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0){\\n                sum+=nums[i];\\n                counter++;\\n                nums[i]=INT_MIN;\\n            }\\n        }\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int j=0;\\n        while(sum>0 && nums[j]!=INT_MIN && j<nums.size())\\n        {\\n            if((sum+nums[j])>0)sum+=nums[j];\\n            else break;\\n            j++;\\n        }\\n        return counter+j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938399,
                "title": "ruby-o-nlogn-in-5-lines",
                "content": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef max_score(nums)\\n  nums.sort! { | a, b | b <=> a }\\n  nums.inject([0, 0]) { | (res, prefix_sum), num |\\n    prefix_sum += num\\n    [prefix_sum > 0 ? res+1 : res, prefix_sum]\\n  }[0]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef max_score(nums)\\n  nums.sort! { | a, b | b <=> a }\\n  nums.inject([0, 0]) { | (res, prefix_sum), num |\\n    prefix_sum += num\\n    [prefix_sum > 0 ? res+1 : res, prefix_sum]\\n  }[0]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3902651,
                "title": "c-sorting-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        int score= 0;\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(sum<=0 && i!=0)\\n            {\\n                break;\\n            }\\n            sum+=(long long)nums[i];\\n            if(sum>0)score++;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        int score= 0;\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(sum<=0 && i!=0)\\n            {\\n                break;\\n            }\\n            sum+=(long long)nums[i];\\n            if(sum>0)score++;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885336,
                "title": "c-clean-easy-code-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& a) {\\n        sort(a.begin(),a.end(),greater<int> ());\\n        long long int s=0,c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s+=a[i];\\n            if(s>0) c++;\\n        }\\n       return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& a) {\\n        sort(a.begin(),a.end(),greater<int> ());\\n        long long int s=0,c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            s+=a[i];\\n            if(s>0) c++;\\n        }\\n       return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838538,
                "title": "improvement-on-the-simple-sort-and-accumulate",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    # Sorting first makes sense. but notice that the inner-order \\n    # of the *positive* part of the array is not important\\n    # Instead of sorting, we use a heap to store and sort only the negative numbers.\\n    # Time complexity is O(nlogk), where k is the number of negative numbers in the array\\n\\n    def maxScore(self, nums: List[int]) -> int:\\n        negatives = []  \\n        sum = 0         \\n        score = 0  \\n\\n        for num in nums:          \\n            if num > 0:\\n                # sum up positive numbers\\n                sum += num\\n\\n                # score +1 for each positive number\\n                score += 1\\n            else:\\n                # store negative numbers\\n                heappush(negatives, -num)\\n\\n        # score +1 for each negative number\\n        # that can be reduced from sum and keep sum positive\\n        while negatives and sum > 0:\\n            score += 1\\n            sum -= heappop(negatives)\\n\\n        return max(0, score - (sum <= 0))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Sorting first makes sense. but notice that the inner-order \\n    # of the *positive* part of the array is not important\\n    # Instead of sorting, we use a heap to store and sort only the negative numbers.\\n    # Time complexity is O(nlogk), where k is the number of negative numbers in the array\\n\\n    def maxScore(self, nums: List[int]) -> int:\\n        negatives = []  \\n        sum = 0         \\n        score = 0  \\n\\n        for num in nums:          \\n            if num > 0:\\n                # sum up positive numbers\\n                sum += num\\n\\n                # score +1 for each positive number\\n                score += 1\\n            else:\\n                # store negative numbers\\n                heappush(negatives, -num)\\n\\n        # score +1 for each negative number\\n        # that can be reduced from sum and keep sum positive\\n        while negatives and sum > 0:\\n            score += 1\\n            sum -= heappop(negatives)\\n\\n        return max(0, score - (sum <= 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792529,
                "title": "prefix-array-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        int len = nums.length;\\n        long sum = 0;\\n        int max = 0;\\n        Arrays.sort(nums);\\n        for(int i = len-1;i>=0;i--)\\n        {\\n          sum += nums[i];\\n          if(sum > 0)\\n          { \\n                max++;\\n          }\\n          else\\n          {\\n              break;\\n          }  \\n        }\\n        return max;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        int len = nums.length;\\n        long sum = 0;\\n        int max = 0;\\n        Arrays.sort(nums);\\n        for(int i = len-1;i>=0;i--)\\n        {\\n          sum += nums[i];\\n          if(sum > 0)\\n          { \\n                max++;\\n          }\\n          else\\n          {\\n              break;\\n          }  \\n        }\\n        return max;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774848,
                "title": "python-easy-5-lines-code",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        s = 0\\n        for i, num in enumerate(nums):\\n            s += num\\n            if s <= 0:\\n                return i\\n        return len(nums)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        s = 0\\n        for i, num in enumerate(nums):\\n            s += num\\n            if s <= 0:\\n                return i\\n        return len(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773470,
                "title": "easy-c-solution-100-faster-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long s=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            s+=nums[i];\\n            if(s>0)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long s=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            s+=nums[i];\\n            if(s>0)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759717,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        long sum = 0;\\n        int i=nums.length-1;\\n        Arrays.sort(nums);\\n        if(nums[nums.length-1] == 0)    return 0;\\n        while(i >= 0){\\n            sum += nums[i--];\\n            if(sum <= 0) return nums.length-i-2;\\n        }\\n        return nums.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        long sum = 0;\\n        int i=nums.length-1;\\n        Arrays.sort(nums);\\n        if(nums[nums.length-1] == 0)    return 0;\\n        while(i >= 0){\\n            sum += nums[i--];\\n            if(sum <= 0) return nums.length-i-2;\\n        }\\n        return nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725149,
                "title": "java-prefix-sum-easiest-solution",
                "content": "**Please Upvote :\")**\\n\\n# Approach\\nSort the array in decreasing order and count the number of positive values in the prefix sum array. \\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int count = 0;\\n        long sum = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum += nums[i];\\n            if(sum>0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int count = 0;\\n        long sum = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum += nums[i];\\n            if(sum>0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721827,
                "title": "100-speed-javascript-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a sorting problem but looking at the example where 0 is out of place. I noticed that 0 is a wide card where if you add to +ve integer, it will remain a +ve integer. This make me think of separating the arrays into different sections.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*most optimal way is to get the highest sum and slowly reduce this sum with neg numbers\\n*zero is a wild card becasue adding 0 does not make a diff\\n\\n1. seperate the array into +ve and -ve and 0\\n2. get sum of pos Arr = posSum\\n3. sort -ve array \\n4. iterate -ve array and add to posSum until posSum is negative\\n5. add count of zero\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxScore = function(nums) {\\n    // we want to get most number of positive prefix sum\\n    // most optimal way is to get the highest sum and slowly reduce this sum with neg numbers\\n    // zero is a wide card becasue adding 0 does not make a diff\\n    // 1. seperate the array into +ve and -ve and 0\\n    // 2. get sum of pos Arr = posSum\\n    // 3. sort -ve array \\n    // 4. iterate -ve array and add to posSum until posSum is negative\\n    // 5. add count of zero\\n\\n    let posArr = []\\n    let zeroArr = []\\n    let negArr = []\\n    nums.forEach((n) => {\\n        if (n > 0) {\\n            posArr.push(n)\\n        } else if (n === 0) {\\n            zeroArr.push(n)\\n        } else {\\n            negArr.push(n)\\n        }\\n    })\\n    let count = posArr.length\\n    if (count === 0) return 0\\n    let posSum = posArr.reduce((a,b) => a+b, 0);\\n    negArr = negArr.sort((a,b) => {\\n        if (a < b) {\\n            return -1;\\n        }\\n        if (a > b) {\\n            return 1;\\n        }\\n        return 0;\\n    })\\n    while (negArr.length > 0) {\\n        posSum += negArr.pop()\\n        if (posSum > 0) {\\n            count +=1\\n        } else {\\n            break\\n        }\\n    }\\n    return count + zeroArr.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxScore = function(nums) {\\n    // we want to get most number of positive prefix sum\\n    // most optimal way is to get the highest sum and slowly reduce this sum with neg numbers\\n    // zero is a wide card becasue adding 0 does not make a diff\\n    // 1. seperate the array into +ve and -ve and 0\\n    // 2. get sum of pos Arr = posSum\\n    // 3. sort -ve array \\n    // 4. iterate -ve array and add to posSum until posSum is negative\\n    // 5. add count of zero\\n\\n    let posArr = []\\n    let zeroArr = []\\n    let negArr = []\\n    nums.forEach((n) => {\\n        if (n > 0) {\\n            posArr.push(n)\\n        } else if (n === 0) {\\n            zeroArr.push(n)\\n        } else {\\n            negArr.push(n)\\n        }\\n    })\\n    let count = posArr.length\\n    if (count === 0) return 0\\n    let posSum = posArr.reduce((a,b) => a+b, 0);\\n    negArr = negArr.sort((a,b) => {\\n        if (a < b) {\\n            return -1;\\n        }\\n        if (a > b) {\\n            return 1;\\n        }\\n        return 0;\\n    })\\n    while (negArr.length > 0) {\\n        posSum += negArr.pop()\\n        if (posSum > 0) {\\n            count +=1\\n        } else {\\n            break\\n        }\\n    }\\n    return count + zeroArr.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3709204,
                "title": "prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog n)\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n       vector<int>v;\\n       long long maxi=0;\\n       long long sum=0;\\n    //    so that we can get max number +ve\\n        sort(nums.begin(),nums.end(), greater<long long>());\\n        \\n  \\n\\n\\n        for(int i=0;i<nums.size();i++){\\n         sum+=nums[i];\\n         if(sum>0){\\n             maxi++;\\n         }\\n        }\\n    return maxi;    \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n       vector<int>v;\\n       long long maxi=0;\\n       long long sum=0;\\n    //    so that we can get max number +ve\\n        sort(nums.begin(),nums.end(), greater<long long>());\\n        \\n  \\n\\n\\n        for(int i=0;i<nums.size();i++){\\n         sum+=nums[i];\\n         if(sum>0){\\n             maxi++;\\n         }\\n        }\\n    return maxi;    \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707566,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        count=0\\n        nums.sort(reverse=True)\\n        pfsum=[0]*len(nums)\\n        pfsum[0]=nums[0]\\n        for i in range(0,len(nums)):\\n            pfsum[i]=pfsum[i-1]+nums[i]\\n            if pfsum[i]>0:\\n                count+=1\\n\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        count=0\\n        nums.sort(reverse=True)\\n        pfsum=[0]*len(nums)\\n        pfsum[0]=nums[0]\\n        for i in range(0,len(nums)):\\n            pfsum[i]=pfsum[i-1]+nums[i]\\n            if pfsum[i]>0:\\n                count+=1\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678167,
                "title": "rearrange-array-to-maximize-prefix-score-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        sort(nums.rbegin(),nums.rend());\\n        int ans = 1;\\n\\n        if(nums[0]<=0)\\n        {\\n            return 0;\\n        }\\n        long long sum = nums[0];\\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            if(sum<=0)\\n            {\\n                return ans;\\n            }\\n            else\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        sort(nums.rbegin(),nums.rend());\\n        int ans = 1;\\n\\n        if(nums[0]<=0)\\n        {\\n            return 0;\\n        }\\n        long long sum = nums[0];\\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            if(sum<=0)\\n            {\\n                return ans;\\n            }\\n            else\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628108,
                "title": "python-3-single-line",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(nlgn)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return functools.reduce(lambda tmp, x: (tmp[0]+x, tmp[1] + int(tmp[0]+x > 0)), sorted(nums, reverse=True), (0, 0))[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return functools.reduce(lambda tmp, x: (tmp[0]+x, tmp[1] + int(tmp[0]+x > 0)), sorted(nums, reverse=True), (0, 0))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617270,
                "title": "java-sorting-prefix-sum-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        long prefixSum = 0;\\n\\n        int countPositive = 0;\\n\\n        for(int i = n - 1; i >= 0; i--){\\n\\n            prefixSum += nums[i];\\n\\n            countPositive += prefixSum > 0 ? 1 : 0;\\n        }\\n        return countPositive;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        long prefixSum = 0;\\n\\n        int countPositive = 0;\\n\\n        for(int i = n - 1; i >= 0; i--){\\n\\n            prefixSum += nums[i];\\n\\n            countPositive += prefixSum > 0 ? 1 : 0;\\n        }\\n        return countPositive;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608313,
                "title": "the-effective-way-to-solve-and-remember",
                "content": "# Intuition\\n\\n\\uD83C\\uDF61 We want to rearrange the input values to have as many strictly positive prefix sums as possible.\\nSay there are ``n`` input values, out of which ``k`` are strictly positive.\\nThen, we should put the strictly positive values at the front.\\nThis way, we\\'ll have ``k`` strictly positive prefix sums.\\n\\nAfter that, we add the most number of strictly positive prefix sums if we reduce the current prefix sum by as little as possible at each position.\\nThen, let\\'s subtract each remaining negative value closest to zero at each step.\\nCount how many negative values still keep the prefix sum strictly positive, say that number is ``m``.\\nThe answer is ``k + m``\\n\\n# \\u2696\\uFE0F Notes\\n\\n1. The problem asks us to find as many prefixes as possible with a positive sum (which means ``sum >= 0``), but it actually wants a strictly positive sum (``sum > 0``)\\n1. The order in which we put the strictly positive values at the beginning of the input doesn\\'t change the number of strictly positive prefixes, so we can just count how many there are (find the ``k``) and add them up, to find the prefix sum\\n1. Instead of sorting, we can also use a max-heap to repeatedly find and extract the negative value closest to zero.\\n\\n# Approach\\n1. Count and add up all the strictly positive values to form the number of strictly positive prefix sums so far, and the prefix sum before negatives.\\nAlso extract all the negative values at the same time.\\n1. Sort those negative values from the smallest in absolute value to the largest.\\n1. Count how many negative values you can add to the prefix sum still keep the prefix sum strictly positive\\n\\n# Complexity\\nLike above, $$n$$ is the number of input values, and $$k$$ is the number of strictly positive values.\\n- Time complexity: $$\\u0398((n-k)*log(n-k)) = \\u0398(n) + \\u0398((n-k)*log(n-k)) + \\u0398(n-k)$$ in the worst case, when we can form all strictly positive  prefix sums.\\n    -  $$\\u0398(n)$$ for counting and adding up the strictly positive values, and extracting the $$n-k$$ negative values\\n    -  $$\\u0398((n-k)*log(n-k))$$ for sorting the $$n-k$$ negative values\\n    -  $$\\u0398(n-k)$$ for counting how many negative values added to the prefix sum keep it strictly positive\\nScenario: a\\n- Space complexity: $$\\u0398(n-k) = \\u0398(n-k) + \\u0398(log(n-k)$$\\n    - $$\\u0398(n-k)$$ for a copy of the negative values\\n    - $$\\u0398(log(n-k))$$ for sorting the negative values\\n\\n# Code\\n```Go []\\nfunc maxScore(nums []int) int {\\n    var negativeValues []int\\n    prefixSum := 0\\n    for _, value := range nums {\\n        if value > 0 {\\n            prefixSum += value\\n        } else {\\n            negativeValues = append(negativeValues, value)\\n        }\\n    }\\n\\n    positivePrefixesCount := len(nums) - len(negativeValues)\\n    sort.Sort(sort.Reverse(sort.IntSlice(negativeValues)))\\n    for _, value := range negativeValues {\\n        prefixSum += value\\n        if prefixSum <= 0 {\\n            break\\n        }\\n        positivePrefixesCount++\\n    }\\n\\n    return positivePrefixesCount\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```Go []\\nfunc maxScore(nums []int) int {\\n    var negativeValues []int\\n    prefixSum := 0\\n    for _, value := range nums {\\n        if value > 0 {\\n            prefixSum += value\\n        } else {\\n            negativeValues = append(negativeValues, value)\\n        }\\n    }\\n\\n    positivePrefixesCount := len(nums) - len(negativeValues)\\n    sort.Sort(sort.Reverse(sort.IntSlice(negativeValues)))\\n    for _, value := range negativeValues {\\n        prefixSum += value\\n        if prefixSum <= 0 {\\n            break\\n        }\\n        positivePrefixesCount++\\n    }\\n\\n    return positivePrefixesCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3535061,
                "title": "doesn-t-look-like-medium",
                "content": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        long sum = 0;\\n        int res = 0;\\n        Arrays.sort(nums);\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            sum += nums[i];\\n            if (sum <= 0) break;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        long sum = 0;\\n        int res = 0;\\n        Arrays.sort(nums);\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            sum += nums[i];\\n            if (sum <= 0) break;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512289,
                "title": "simple-solution-easy-approach-o-n-sort",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long sum=0,ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(sum>0)ans++;\\n        } \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long sum=0,ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(sum>0)ans++;\\n        } \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493313,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        arr=sorted(nums, reverse=True)\\n        c=0\\n        if arr[0]>0:\\n            c+=1\\n        for i in range(1,len(arr)):\\n            arr[i]+=arr[i-1]\\n            if arr[i]>0:\\n                c+=1\\n        print(arr)\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        arr=sorted(nums, reverse=True)\\n        c=0\\n        if arr[0]>0:\\n            c+=1\\n        for i in range(1,len(arr)):\\n            arr[i]+=arr[i-1]\\n            if arr[i]>0:\\n                c+=1\\n        print(arr)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482878,
                "title": "python-short-solution",
                "content": "# Approach\\nMy first thought was that all the prefixes would be positive at the start of the list if you put all positive numbers at the start of the list. Basically [-1, 2, -2, 3] would best be sorted to be [3, 2, -1, -3] or in reverse sorting order. Then you traverse through the list and keep a running total of the amount of elements until you encounter enough negatives to reach a negative total\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        nums.sort(reverse=True)\\n\\n        currentSum = 0\\n        returnValue = 0\\n        \\n        for item in nums:\\n            currentSum += item\\n\\n            if currentSum > 0:\\n                returnValue += 1\\n            else:\\n                break\\n        \\n        return returnValue\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        nums.sort(reverse=True)\\n\\n        currentSum = 0\\n        returnValue = 0\\n        \\n        for item in nums:\\n            currentSum += item\\n\\n            if currentSum > 0:\\n                returnValue += 1\\n            else:\\n                break\\n        \\n        return returnValue\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482571,
                "title": "rearrange-array-to-maximize-prefix-score",
                "content": "----------------- Easy C++ Solution ----------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n    sort(begin(nums), end(nums), greater<>());\\n    long long prefix = 0;\\n\\n    for (int i = 0; i < nums.size(); ++i) {\\n      prefix += nums[i];\\n      if (prefix <= 0)\\n        return i;\\n    }\\n\\n    return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n    sort(begin(nums), end(nums), greater<>());\\n    long long prefix = 0;\\n\\n    for (int i = 0; i < nums.size(); ++i) {\\n      prefix += nums[i];\\n      if (prefix <= 0)\\n        return i;\\n    }\\n\\n    return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456293,
                "title": "c-sum-positives-and-iterate-negatives-after-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        vector<int> pos, neg;\\n        for (auto& n : nums)\\n            if (n > 0) pos.push_back(n);\\n            else neg.push_back(n);\\n        long sum = 0;\\n        for (auto& n : pos) sum += n;\\n        sort(neg.begin(), neg.end());\\n        int ans = pos.size();\\n        for (int i = neg.size() - 1; i > -1 && sum > 0; --i){\\n            sum += neg[i];\\n            ans += sum > 0;\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        vector<int> pos, neg;\\n        for (auto& n : nums)\\n            if (n > 0) pos.push_back(n);\\n            else neg.push_back(n);\\n        long sum = 0;\\n        for (auto& n : pos) sum += n;\\n        sort(neg.begin(), neg.end());\\n        int ans = pos.size();\\n        for (int i = neg.size() - 1; i > -1 && sum > 0; --i){\\n            sum += neg[i];\\n            ans += sum > 0;\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437748,
                "title": "c-beginner-friendly-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        long long sum=0,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum>0)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        long long sum=0,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum>0)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430179,
                "title": "5-lines-super-easy-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n.logn)$$ -->\\n\\n- Space complexity:\\n $$O(1)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int> ());\\n        int c=0;\\n        long s=0;\\n        for(int x : nums){\\n            s += x;\\n            if(s>0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int> ());\\n        int c=0;\\n        long s=0;\\n        for(int x : nums){\\n            s += x;\\n            if(s>0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423957,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxScore(int[] nums)\\n    {\\n        Array.Sort(nums);\\n        int ans =0; long sum =0;\\n        for(int i = nums.Length-1; i>=0;i--)\\n        {\\n            sum += nums[i];\\n            if(sum >0)\\n            ans ++;\\n            else\\n            break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxScore(int[] nums)\\n    {\\n        Array.Sort(nums);\\n        int ans =0; long sum =0;\\n        for(int i = nums.Length-1; i>=0;i--)\\n        {\\n            sum += nums[i];\\n            if(sum >0)\\n            ans ++;\\n            else\\n            break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422872,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int a[]=new int[nums.length],k=0;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            a[k]=nums[i];\\n            k+=1;\\n        }\\n        long pre[]=new long[nums.length];\\n        pre[0]=(long)a[0];\\n        int c=0;\\n        if(pre[0]>0)c+=1;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            pre[i]=(long)a[i]+pre[i-1];\\n            if(pre[i]>0)c+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int a[]=new int[nums.length],k=0;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            a[k]=nums[i];\\n            k+=1;\\n        }\\n        long pre[]=new long[nums.length];\\n        pre[0]=(long)a[0];\\n        int c=0;\\n        if(pre[0]>0)c+=1;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            pre[i]=(long)a[i]+pre[i-1];\\n            if(pre[i]>0)c+=1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418208,
                "title": "java-solution-using-reverse-array-order",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) { \\n        long temp =0;\\n        \\n        int count =0;\\n       \\n        Integer[] conv = Arrays.stream(nums).boxed().toArray(Integer[]::new);\\n         Arrays.sort(conv, new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                return b.compareTo(a);\\n            }\\n        });\\n\\n        int[] sortedArr = Arrays.stream(conv).mapToInt(Integer::intValue).toArray();\\n\\n        for(int i =0; i< sortedArr.length; i++){\\n             temp = temp + (long)sortedArr[i];\\n             \\n             if(temp > 0){\\n                 count++;\\n             }\\n        }\\n\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) { \\n        long temp =0;\\n        \\n        int count =0;\\n       \\n        Integer[] conv = Arrays.stream(nums).boxed().toArray(Integer[]::new);\\n         Arrays.sort(conv, new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                return b.compareTo(a);\\n            }\\n        });\\n\\n        int[] sortedArr = Arrays.stream(conv).mapToInt(Integer::intValue).toArray();\\n\\n        for(int i =0; i< sortedArr.length; i++){\\n             temp = temp + (long)sortedArr[i];\\n             \\n             if(temp > 0){\\n                 count++;\\n             }\\n        }\\n\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417072,
                "title": "beats-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end(),greater<>());\\n        vector<long long > v( nums.begin(),nums.end());\\n         \\n     int res = 0; \\n       long long  int sum = 0; \\n        for(int i = 0; i<v.size();i++)\\n        {\\n             v[i] +=sum;\\n            sum = v[i] ; \\n            if(v[i]>0)\\n            res++; \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end(),greater<>());\\n        vector<long long > v( nums.begin(),nums.end());\\n         \\n     int res = 0; \\n       long long  int sum = 0; \\n        for(int i = 0; i<v.size();i++)\\n        {\\n             v[i] +=sum;\\n            sum = v[i] ; \\n            if(v[i]>0)\\n            res++; \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397546,
                "title": "reverse-sort-easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    get the largest prefix possible first to absorb any negitives\\n\\n    b/c sorted in reverse we can stop if prefix is <= 0 because we know\\n    from there on the numners in nums will be negitive so we wont ever go \\n    postive again\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n\\n\\n\\n\\n        nums = sorted(nums,reverse = True)\\n\\n        ans = 0\\n        prefix =0\\n\\n        for n in nums:\\n            prefix+=n\\n            if prefix<=0:\\n                break\\n            \\n            ans+=1\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n\\n\\n\\n\\n        nums = sorted(nums,reverse = True)\\n\\n        ans = 0\\n        prefix =0\\n\\n        for n in nums:\\n            prefix+=n\\n            if prefix<=0:\\n                break\\n            \\n            ans+=1\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391887,
                "title": "c-sorting-easy-understanding-o-nlogn",
                "content": "````\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        long long sum=0;\\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum=sum+nums[i];\\n            if(sum>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        long long sum=0;\\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum=sum+nums[i];\\n            if(sum>0){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3387307,
                "title": "simple-java-solution-with-explanation-sort-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array\\nstart traversing from last element(max to min) \\nkeep calculating prefix sum\\nif sum is positive then increase ans\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(long n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        long ans= 0;\\n        long sum= 0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1; i>=0; i--){\\n            sum += nums[i];\\n            if(sum>0)ans++;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        long ans= 0;\\n        long sum= 0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1; i>=0; i--){\\n            sum += nums[i];\\n            if(sum>0)ans++;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380347,
                "title": "c-beats-87-sorting-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n    long long sum=0;\\n    int count =0;\\n    sort(nums.begin(), nums.end());\\n    for(int i=nums.size()-1; i>=0; --i){\\n        sum+=nums[i];\\n        if(sum>0){\\n        count++;\\n        }\\n        else{\\n            break;\\n        }\\n        \\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n    long long sum=0;\\n    int count =0;\\n    sort(nums.begin(), nums.end());\\n    for(int i=nums.size()-1; i>=0; --i){\\n        sum+=nums[i];\\n        if(sum>0){\\n        count++;\\n        }\\n        else{\\n            break;\\n        }\\n        \\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368948,
                "title": "99-91-python",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def maxScore(self, nums):\\n        k = j = 0 \\n        n = []\\n        for num in nums:\\n            if 0 < num:\\n                k += num\\n                j += 1\\n            else:\\n                n.append(num)\\n        n.sort(reverse=True)\\n        for num in n:\\n            k += num\\n            if k < 1:\\n                break\\n            j += 1\\n        return j\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxScore(self, nums):\\n        k = j = 0 \\n        n = []\\n        for num in nums:\\n            if 0 < num:\\n                k += num\\n                j += 1\\n            else:\\n                n.append(num)\\n        n.sort(reverse=True)\\n        for num in n:\\n            k += num\\n            if k < 1:\\n                break\\n            j += 1\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367766,
                "title": "sort",
                "content": "**time: `O(NlogN)`; space: `O(1)`**\\n```\\nint maxScore(vector<int>& n)\\n{\\n\\tint out{};\\n\\tsort(begin(n), end(n), greater{});\\n\\tfor(long long s{}; const auto & n : n)\\n\\t\\tout += (s+=n)>0;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxScore(vector<int>& n)\\n{\\n\\tint out{};\\n\\tsort(begin(n), end(n), greater{});\\n\\tfor(long long s{}; const auto & n : n)\\n\\t\\tout += (s+=n)>0;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3362212,
                "title": "java-solution-by-maintaing-prefixandsuffix-array-o-n-time",
                "content": "```\\nclass Solution {\\n    public int maxScore(int[] arr1) {\\n       Arrays.sort(arr1);\\n       int low=0;\\n       int high=arr1.length-1;\\n       while(low<high)\\n       {\\n           int temp=arr1[low];\\n           arr1[low]=arr1[high];\\n           arr1[high]=temp;\\n           low++;\\n           high--;           \\n       }\\n       int count=0; \\n       long []prefix=new long[arr1.length];\\n       prefix[0]=Long.valueOf(arr1[0]);\\n       for(int i=1;i<arr1.length;i++)\\n       {\\n           prefix[i]=prefix[i-1]+arr1[i];\\n       }       \\n        \\n       for(Long x1:prefix)\\n       {\\n           if(x1>0)\\n           {\\n               count++;\\n           }\\n       }\\n            \\n        return count;        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxScore(int[] arr1) {\\n       Arrays.sort(arr1);\\n       int low=0;\\n       int high=arr1.length-1;\\n       while(low<high)\\n       {\\n           int temp=arr1[low];\\n           arr1[low]=arr1[high];\\n           arr1[high]=temp;\\n           low++;\\n           high--;           \\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3343791,
                "title": "java-simple-solution-using-arrays-sort",
                "content": "# Intuition\\nFirst sort the given array then keep adding the array elements to the sum variable as the sum becomes 0 or negative the return the number of element had a positive prefix. \\n# Code\\n```Java\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n      Arrays.sort(nums);\\n       long sum=0;\\n       int ans=0;\\n       for(int i=nums.length-1;i>=0;i--){\\n           sum+=nums[i];\\n           if(sum<=0)\\n           break;\\n           ans++;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n      Arrays.sort(nums);\\n       long sum=0;\\n       int ans=0;\\n       for(int i=nums.length-1;i>=0;i--){\\n           sum+=nums[i];\\n           if(sum<=0)\\n           break;\\n           ans++;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342589,
                "title": "greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 0;\\n        long long sum = 0;\\n        for(int i=nums.size()-1; i>=0; i--){\\n            sum+=nums[i];\\n            if(sum>0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 0;\\n        long long sum = 0;\\n        for(int i=nums.size()-1; i>=0; i--){\\n            sum+=nums[i];\\n            if(sum>0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337381,
                "title": "python-3-fast-comprehensive-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n\\n        nums.sort(reverse = True)\\n        \\n        prefix_sum, sum_ = [nums[0]], nums[0]\\n\\n        for num in nums[1:]:\\n            sum_ += num\\n            prefix_sum.append(sum_)\\n\\n        for i in range(len(prefix_sum)):\\n            if prefix_sum[i] <= 0:\\n                return i\\n        \\n        return len(nums)\\n\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n\\n        nums.sort(reverse = True)\\n        \\n        prefix_sum, sum_ = [nums[0]], nums[0]\\n\\n        for num in nums[1:]:\\n            sum_ += num\\n            prefix_sum.append(sum_)\\n\\n        for i in range(len(prefix_sum)):\\n            if prefix_sum[i] <= 0:\\n                return i\\n        \\n        return len(nums)\\n\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337101,
                "title": "python3-sum-x-0-for-x-in-accumulate-sorted-nums-reverse-true",
                "content": "```python\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return sum(x > 0 for x in accumulate(sorted(nums, reverse=True)))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        return sum(x > 0 for x in accumulate(sorted(nums, reverse=True)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334706,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        sort(nums.rbegin(),nums.rend());\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(sum>0)\\n                ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) \\n    {\\n        sort(nums.rbegin(),nums.rend());\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(sum>0)\\n                ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333087,
                "title": "use-partition-and-sort-for-maxscore",
                "content": "# Intuition\\nTo get the max score, we need to arrange the numbers such that we maximize the initial sums.\\nSo we need to have all the positive numbers in the beginning. It doesn\\'t matter what order the positive numbers are in since, their sum will be positive.\\nWe want the negative numbers and zero in descending order so that they contribute the least to the sum in the beginning\\n\\n# Approach\\nHere are the steps:\\n1. Partition the nums list into positive number and non-positive numbers\\n2. Sort the non-positive numbers into descending order\\n3. Loop through nums list until the sum is negative\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n      auto it_pos = std::partition(nums.begin(), nums.end(), [](const auto& iter)\\n                               {\\n                                 return iter > 0;\\n                               });\\n      std::sort(it_pos,nums.end(),std::greater<int>());\\n      // std::sort(nums.begin(),nums.end(),std::greater<int>());\\n      long int sum = 0;\\n      auto iter = std::find_if(nums.begin(), nums.end(), [&sum] (const auto& iter) mutable\\n                              {\\n                                sum+=static_cast<long int>(iter);\\n                                return sum <= 0;\\n                              });\\n      \\n      return iter == nums.end() ? nums.size() : (iter - nums.begin());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n      auto it_pos = std::partition(nums.begin(), nums.end(), [](const auto& iter)\\n                               {\\n                                 return iter > 0;\\n                               });\\n      std::sort(it_pos,nums.end(),std::greater<int>());\\n      // std::sort(nums.begin(),nums.end(),std::greater<int>());\\n      long int sum = 0;\\n      auto iter = std::find_if(nums.begin(), nums.end(), [&sum] (const auto& iter) mutable\\n                              {\\n                                sum+=static_cast<long int>(iter);\\n                                return sum <= 0;\\n                              });\\n      \\n      return iter == nums.end() ? nums.size() : (iter - nums.begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330827,
                "title": "5-lines-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the array reverse the array loop till positive prefix \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        long long int prefix=0;\\n        for(auto x:nums)\\n        {\\n            prefix+=x;\\n            if(prefix>0)\\n            {\\n                count++;\\n            }\\n            if(prefix<0)\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        long long int prefix=0;\\n        for(auto x:nums)\\n        {\\n            prefix+=x;\\n            if(prefix>0)\\n            {\\n                count++;\\n            }\\n            if(prefix<0)\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330552,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array.\\n2. Reverse the array for descending order.\\n3. Calculate Prefix Sum array.\\n4. Count Positve values in Prefix Sum array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n    int maxScore(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        reverse (v.begin(), v.end());\\n\\n        // calculate prefix sum.\\n        vector<ll> prefix(v.size(), 0);\\n        for(int i=0; i<v.size(); ++i){\\n            if(i==0)\\n                prefix[i] = v[i];\\n            else\\n                prefix[i] = prefix[i-1]+v[i];\\n        }\\n\\n\\n        // count positive values in prefix sum array;\\n        int ans = 0;\\n        for(int i=0; i<prefix.size(); ++i)\\n            if(prefix[i]>0)++ans;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n    int maxScore(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        reverse (v.begin(), v.end());\\n\\n        // calculate prefix sum.\\n        vector<ll> prefix(v.size(), 0);\\n        for(int i=0; i<v.size(); ++i){\\n            if(i==0)\\n                prefix[i] = v[i];\\n            else\\n                prefix[i] = prefix[i-1]+v[i];\\n        }\\n\\n\\n        // count positive values in prefix sum array;\\n        int ans = 0;\\n        for(int i=0; i<prefix.size(); ++i)\\n            if(prefix[i]>0)++ans;\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326945,
                "title": "java-o-n-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n//Dev Bhayani\\n//22/03/2023 09:06\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        long sum=0;\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[nums.length-1-i];\\n            nums[nums.length-1-i]=temp;\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            if(sum<=0)\\n            {\\n                return i;\\n            }\\n        }\\n        return nums.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n//Dev Bhayani\\n//22/03/2023 09:06\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        long sum=0;\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[nums.length-1-i];\\n            nums[nums.length-1-i]=temp;\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            if(sum<=0)\\n            {\\n                return i;\\n            }\\n        }\\n        return nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326127,
                "title": "basic-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.rbegin(),nums.rend());\\n        long long sum=0;\\n        for(auto x:nums){\\n            sum+=x;\\n            if(sum>0)ans++;\\n            else return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.rbegin(),nums.rend());\\n        long long sum=0;\\n        for(auto x:nums){\\n            sum+=x;\\n            if(sum>0)ans++;\\n            else return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325969,
                "title": "simple-c-solution-by-sorting-array",
                "content": "C++  code\\n\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        \\n        int ans=0;\\n        vector<long long> v;\\n        v.push_back(nums[0]);\\n        if(v[0]>0)\\n            ans++;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            v.push_back(nums[i]+v[i-1]);\\n            if(v[i]>0)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\nusing space O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        \\n        int ans=0;\\n        long long previous=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            previous+=nums[i];\\n            if(previous>0)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        \\n        int ans=0;\\n        vector<long long> v;\\n        v.push_back(nums[0]);\\n        if(v[0]>0)\\n            ans++;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            v.push_back(nums[i]+v[i-1]);\\n            if(v[i]>0)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        \\n        int ans=0;\\n        long long previous=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            previous+=nums[i];\\n            if(previous>0)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325925,
                "title": "c-easy-question-simple-approach-o-n",
                "content": "# Approach\\n- Sorting and Reversing The Array \\n- Creating A Long Long As Creating A Prefix Array , When Adding Value It Can Go Above 10^9 \\n- Making A Prefix Sum Vector\\n- After Making Prefix Vector , We\\'ll Just Check The Number Of Elements Greather Than 0\\n\\n# Complexity\\n- Time complexity:$$O(n logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int  maxi = 0;\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n\\n        long long int sum = 0;\\n        vector<long long int> pre(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum += nums[i];\\n            pre[i]=sum;\\n        }\\n\\n        for(auto x : pre)\\n        {\\n            if(x>0)\\n            maxi++;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int  maxi = 0;\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n\\n        long long int sum = 0;\\n        vector<long long int> pre(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum += nums[i];\\n            pre[i]=sum;\\n        }\\n\\n        for(auto x : pre)\\n        {\\n            if(x>0)\\n            maxi++;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319260,
                "title": "reverse-sorting-and-then-prefix-sum-o-nlogn-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort in descending order and then you can maintina a prefix sum of the entire array and then you can reurn the answer at the point in which the sum turn negative\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        int count = 0;\\n        long sum = 0;\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n            if(sum > 0)count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        int count = 0;\\n        long sum = 0;\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n            if(sum > 0)count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316630,
                "title": "java-solution-using-sorting",
                "content": "# Intuition\\nUsing soring\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAfter sorting count the positive value of prefix sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N(log(N)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i = nums.length-1;i>=0;i--){\\n            sum += nums[i];\\n            if(sum>0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i = nums.length-1;i>=0;i--){\\n            sum += nums[i];\\n            if(sum>0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316155,
                "title": "91-69-python3-sorting",
                "content": "```\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        return len([x for x in accumulate(nums) if x > 0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        return len([x for x in accumulate(nums) if x > 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312554,
                "title": "java-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxScore(int[] nums) {\\n    Arrays.sort(nums);\\n    long sum = 0;\\n    for(int i = nums.length - 1; i >= 0; i--)\\n      if( (sum += nums[i]) <= 0) return nums.length - i - 1;\\n    return nums.length;     \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxScore(int[] nums) {\\n    Arrays.sort(nums);\\n    long sum = 0;\\n    for(int i = nums.length - 1; i >= 0; i--)\\n      if( (sum += nums[i]) <= 0) return nums.length - i - 1;\\n    return nums.length;     \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311781,
                "title": "prefix-sum-clean-java",
                "content": "# Intuition\\nSort an array and start adding the largest numbers from the end. As we run out of the positive numbers, if we have negative numbers, the prefix sum will keep decreasing until it goes below 0.\\n\\n# Caveat\\nThe prefix sum has to be a long number. With an integer sum the solution fails.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maxScore(int[] nums) {\\n        long res=0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--){\\n            res+=nums[i];\\n            if(res<=0) return nums.length-i-1;\\n        }\\n        return nums.length;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxScore(int[] nums) {\\n        long res=0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--){\\n            res+=nums[i];\\n            if(res<=0) return nums.length-i-1;\\n        }\\n        return nums.length;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311765,
                "title": "easy-python-solution-with-nlogn-time-and-linear-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf given a sorted descending array, we can track the prefix sum and count number of elements that result in it being positive.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first sort the array ``nums`` in descending order. Then parse each element and update our variables ``res`` and ``prefSum``. We add each element of ``nums`` to ``prefSum`` and if ``prefSum`` is positive, we update ``res`` by adding ``1``, i.e., the last element of ``nums`` resulted in positive prefix sum ``prefSum``. \\n\\n# Complexity\\n- Time complexity:$$O(n*log(n))$$\\nsorting takes $$O(n*log(n))$$ and parsing the ``nums``  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\nsorting takes  $$O(n)$$ space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse =True)\\n        res = 0\\n        prefSum = 0\\n        for i in range(len(nums)):\\n            prefSum += nums[i]\\n            if prefSum > 0:\\n                res += 1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse =True)\\n        res = 0\\n        prefSum = 0\\n        for i in range(len(nums)):\\n            prefSum += nums[i]\\n            if prefSum > 0:\\n                res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310887,
                "title": "prefix-sum-easy-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        if(nums[0]<=0)return 0; \\n        long long ans=0, k=0;\\n        for(int i=0; i<nums.size(); i++){\\n            ans+=nums[i];\\n            k++;\\n            if(ans<=0)return --k;\\n            }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        if(nums[0]<=0)return 0; \\n        long long ans=0, k=0;\\n        for(int i=0; i<nums.size(); i++){\\n            ans+=nums[i];\\n            k++;\\n            if(ans<=0)return --k;\\n            }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308780,
                "title": "java-easy-solution-100-beats",
                "content": "\\n# Code\\n```\\nclass Solution {\\n        public int maxScore(int[] nums) {\\n        int ans=0;\\n        long sum=0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--){\\n           sum+=nums[i];\\n            if(sum>0)\\n                ans++;\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int maxScore(int[] nums) {\\n        int ans=0;\\n        long sum=0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--){\\n           sum+=nums[i];\\n            if(sum>0)\\n                ans++;\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308779,
                "title": "java-easy-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public int maxScore(int[] nums) {\\n        int ans=0;\\n        long sum=0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--){\\n           sum+=nums[i];\\n            if(sum>0)\\n                ans++;\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int maxScore(int[] nums) {\\n        int ans=0;\\n        long sum=0;\\n        Arrays.sort(nums);\\n        for(int i=nums.length-1;i>=0;i--){\\n           sum+=nums[i];\\n            if(sum>0)\\n                ans++;\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308151,
                "title": "simplest-solution-using-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c=0\\n        for i in accumulate(nums):\\n            if i>0:\\n                #print(i)\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        c=0\\n        for i in accumulate(nums):\\n            if i>0:\\n                #print(i)\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308026,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHaving the largest sum in the beginning will give us the max number of positives in prefix array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long long int ans=0, sum=0;\\n        sort(nums.begin(),nums.end(),greater<>());\\n        for(auto i:nums){\\n            sum+=i;\\n            sum>0?ans++:ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long long int ans=0, sum=0;\\n        sort(nums.begin(),nums.end(),greater<>());\\n        for(auto i:nums){\\n            sum+=i;\\n            sum>0?ans++:ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306520,
                "title": "step-by-step-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static void rev(int[] nums){\\n        int n=nums.length;\\n        for(int i=0;i<n/2;i++){\\n            int t=nums[i];\\n            nums[i]=nums[n-i-1];\\n            nums[n-i-1]=t;\\n        }\\n    }\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums); //sorts in ascending\\n        rev(nums); //reverse to get descending\\n        long pref[]=new long[nums.length];\\n        pref[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n             pref[i]=pref[i-1]+nums[i];\\n        }\\n        int score=0;\\n        for(int i=0;i<pref.length;i++){\\n            if(pref[i]>0){\\n                score++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return score;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void rev(int[] nums){\\n        int n=nums.length;\\n        for(int i=0;i<n/2;i++){\\n            int t=nums[i];\\n            nums[i]=nums[n-i-1];\\n            nums[n-i-1]=t;\\n        }\\n    }\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums); //sorts in ascending\\n        rev(nums); //reverse to get descending\\n        long pref[]=new long[nums.length];\\n        pref[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n             pref[i]=pref[i-1]+nums[i];\\n        }\\n        int score=0;\\n        for(int i=0;i<pref.length;i++){\\n            if(pref[i]>0){\\n                score++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return score;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306465,
                "title": "simple-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long long ans = 0, sum = 0;\\n        \\n        sort(nums.begin(), nums.end(), greater<>());\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            if(sum > 0){\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long long ans = 0, sum = 0;\\n        \\n        sort(nums.begin(), nums.end(), greater<>());\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            if(sum > 0){\\n                ans++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305460,
                "title": "sorting-way-o-1-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### the below thing is possible only if u sort in DESC\\n- [2,-1,0,1,-3,3,-3]\\n- sort asc\\n- then -3 -3 -1 0 1 2 3 \\n- -3 -6 -7 -7 -6 -4 -1 => max is -1\\n- So what happens is that negs all sumup and reduce the max pos achiveable at the end\\n- So SORT DESC\\n- 3 2 1 0 -1 -3 -3\\n- 3 5 6 6 5 2 -1 => max is 6\\n\\n# Complexity\\n- Time complexity: $$O(NLogN + N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int ctr = 0; //no of pos prefix sums vals\\n        long pre = 0;\\n        for(int no : nums){\\n            pre+=no;\\n            if(pre > 0) ctr++;\\n        }\\n\\n        return ctr;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int ctr = 0; //no of pos prefix sums vals\\n        long pre = 0;\\n        for(int no : nums){\\n            pre+=no;\\n            if(pre > 0) ctr++;\\n        }\\n\\n        return ctr;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304592,
                "title": "java-solution-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverse(int[] nums){\\n        int x = 0,y = nums.length-1;\\n        while(x<y){\\n            int t = nums[x];\\n            nums[x] = nums[y];\\n            nums[y] = t;\\n            x++;\\n            y--;\\n        }\\n    }\\n    public int maxScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        Arrays.sort(nums);\\n        reverse(nums);\\n        int res = 0;\\n        prefix[0] = nums[0];\\n        if(prefix[0]>0){\\n            res++;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n            if(prefix[i]>0){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public void reverse(int[] nums){\\n        int x = 0,y = nums.length-1;\\n        while(x<y){\\n            int t = nums[x];\\n            nums[x] = nums[y];\\n            nums[y] = t;\\n            x++;\\n            y--;\\n        }\\n    }\\n    public int maxScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        Arrays.sort(nums);\\n        reverse(nums);\\n        int res = 0;\\n        prefix[0] = nums[0];\\n        if(prefix[0]>0){\\n            res++;\\n        }\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i] = prefix[i-1] + nums[i];\\n            if(prefix[i]>0){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304111,
                "title": "simple-solution-using-sorting-and-prefix-sum-in-c",
                "content": "```\\nint maxScore(vector<int>& nums) {\\n        sort(nums.rbegin(),nums.rend());\\n        int n=nums.size();\\n        vector<long long>v(n);\\n        v[0]=nums[0];\\n        if(v[0]<=0) return 0;\\n        int count=1;\\n        for(int i=1;i<n;i++){\\n            v[i]=v[i-1]+nums[i];\\n            if(v[i]>0) count++;\\n            \\n        }\\n        \\n        return count;\\n    }\\n```\\n\\nPlease Upvote if found useful",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nint maxScore(vector<int>& nums) {\\n        sort(nums.rbegin(),nums.rend());\\n        int n=nums.size();\\n        vector<long long>v(n);\\n        v[0]=nums[0];\\n        if(v[0]<=0) return 0;\\n        int count=1;\\n        for(int i=1;i<n;i++){\\n            v[i]=v[i-1]+nums[i];\\n            if(v[i]>0) count++;\\n            \\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302648,
                "title": "java-sorting-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length/2; i++){\\n            int temp = nums[i];\\n            nums[i] = nums[nums.length - 1 - i];\\n            nums[nums.length - 1 - i] = temp;\\n\\n        }\\n        int sum = 0;\\n        long p = 0;\\n        for(int i : nums){\\n            p += (long) i;\\n            if(p > 0){\\n                sum++;\\n            }\\n            else{\\n                p=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length/2; i++){\\n            int temp = nums[i];\\n            nums[i] = nums[nums.length - 1 - i];\\n            nums[nums.length - 1 - i] = temp;\\n\\n        }\\n        int sum = 0;\\n        long p = 0;\\n        for(int i : nums){\\n            p += (long) i;\\n            if(p > 0){\\n                sum++;\\n            }\\n            else{\\n                p=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301974,
                "title": "c-1-liner-func",
                "content": "We need an extra variable to track the prefix and use a `Func` to do this without changing the method signature.\\n\\nUsing sorting, the numbers are processed from largest to smallest. Continue as long as the prefix is positive. The result is the count of processed numbers.\\n \\n```cs\\npublic int MaxScore(int[] nums) =>\\n    new Func<long, int>(prefix => nums\\n        .OrderByDescending(x => x)\\n        .TakeWhile(x => (prefix += x) > 0L)\\n        .Count()\\n    )(0L);\\n```\\n\\nIf you don\\'t mind adding a default parameter, (which *is* accepted by LeetCode), then you can simply things a bit.\\n\\n```cs\\npublic int MaxScore(int[] nums, long prefix = 0L) => nums\\n    .OrderByDescending(x => x)\\n    .TakeWhile(x => (prefix += x) > 0L)\\n    .Count();\\n```\\n\\nCheck out my other C# 1-liners!\\n\\n - https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners\\n",
                "solutionTags": [],
                "code": "```cs\\npublic int MaxScore(int[] nums) =>\\n    new Func<long, int>(prefix => nums\\n        .OrderByDescending(x => x)\\n        .TakeWhile(x => (prefix += x) > 0L)\\n        .Count()\\n    )(0L);\\n```\n```cs\\npublic int MaxScore(int[] nums, long prefix = 0L) => nums\\n    .OrderByDescending(x => x)\\n    .TakeWhile(x => (prefix += x) > 0L)\\n    .Count();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3301956,
                "title": "c-golang-greedy-prefix-sum",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        long sum = 0;\\n        int count = 0;\\n        for(int num: nums) {\\n            sum += num;\\n            count += sum > 0;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maxScore(nums []int) int {\\n    sort.Slice(nums, func(i, j int) bool {\\n        return nums[i] > nums[j]\\n    })\\n    var sum int64 = 0\\n    var count int = 0\\n    for _, num := range nums {\\n        sum += int64(num)\\n        if sum > 0 {count++}\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        long sum = 0;\\n        int count = 0;\\n        for(int num: nums) {\\n            sum += num;\\n            count += sum > 0;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n// Golang\\nfunc maxScore(nums []int) int {\\n    sort.Slice(nums, func(i, j int) bool {\\n        return nums[i] > nums[j]\\n    })\\n    var sum int64 = 0\\n    var count int = 0\\n    for _, num := range nums {\\n        sum += int64(num)\\n        if sum > 0 {count++}\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301623,
                "title": "prefix-sum-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        count = 0\\n        if nums[0] > 0:\\n            count += 1\\n        for i in range(1,len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n            if nums[i] > 0:\\n                count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        count = 0\\n        if nums[0] > 0:\\n            count += 1\\n        for i in range(1,len(nums)):\\n            nums[i] = nums[i] + nums[i-1]\\n            if nums[i] > 0:\\n                count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300924,
                "title": "javascript-92-o-n-log-n-time-o-1-space-sorting",
                "content": "![image.png](https://assets.leetcode.com/users/images/3862fff1-b0e0-4bbf-bbdb-34869b40bcee_1678897154.866321.png)\\n\\n# Approach\\nUses sorting:\\n\\n```\\nfunction maxScore(nums) {\\n    nums.sort((a, b) => b - a);\\n\\n    let sum = 0;\\n\\n    for (let i = 0; i in nums; i++) {\\n        sum += nums[i];\\n        if (sum <= 0) return i;\\n    }\\n\\n    return nums.length;\\n};\\n```\\n\\nNote, time complexity can be further optimized to $$O(10^6 * 2 + 1)$$ by using bucket/radix sort instead of quicksort.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nfunction maxScore(nums) {\\n    nums.sort((a, b) => b - a);\\n\\n    let sum = 0;\\n\\n    for (let i = 0; i in nums; i++) {\\n        sum += nums[i];\\n        if (sum <= 0) return i;\\n    }\\n\\n    return nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3300905,
                "title": "easy-c-solution-just-sort-it",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long long count=0, sum=0;\\n        sort(nums.rbegin(), nums.rend());\\n        for(auto it : nums)\\n        {\\n            sum+=it;\\n            if(sum>0){\\n                count++;\\n            }\\n        }    \\n        return count;\\n    }\\n};\\n```\\n\\nIf it helps you please upvote me. Thank you \\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        long long count=0, sum=0;\\n        sort(nums.rbegin(), nums.rend());\\n        for(auto it : nums)\\n        {\\n            sum+=it;\\n            if(sum>0){\\n                count++;\\n            }\\n        }    \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300652,
                "title": "dart-sort-reverse-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\n  int maxScore(List<int> nums) {\\n    int n = nums.length;\\n    nums.sort((a, b) => b.compareTo(a));\\n    int res = 0;\\n    for (var sum = 0, i = 0; i < n; i++) {\\n      sum += nums[i];\\n      if (sum > 0) {\\n        res++;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maxScore(List<int> nums) {\\n    int n = nums.length;\\n    nums.sort((a, b) => b.compareTo(a));\\n    int res = 0;\\n    for (var sum = 0, i = 0; i < n; i++) {\\n      sum += nums[i];\\n      if (sum > 0) {\\n        res++;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300418,
                "title": "c-sorting-and-counting-prefix-sum-o-n-time",
                "content": "# Explanation \\nSolution using Sorting, prefix sum and iteration.\\n \\n- Firstly sort the array in decreasing order.\\n\\n- Now initialize ans and sum with 0.\\n\\n- Iterate the array and add in sum if(sum > 0) then increament ans else break the loop.\\n\\n- Return the ans.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        long long ans = 0;\\n        long long  sum = 0;\\n\\n        for(int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            if(sum > 0) ans++;\\n            else break;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end(), greater<int>());\\n\\n        long long ans = 0;\\n        long long  sum = 0;\\n\\n        for(int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            if(sum > 0) ans++;\\n            else break;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300276,
                "title": "java-o-n-log-n-99-95-faster-0ms-using-constant-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        \\n        int count=0;\\n        long sum=0;\\n        for(int j=nums.length-1;j>=0;j--){\\n            sum+=(long)nums[j];\\n            if(sum>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        \\n        int count=0;\\n        long sum=0;\\n        for(int j=nums.length-1;j>=0;j--){\\n            sum+=(long)nums[j];\\n            if(sum>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299286,
                "title": "scala-sort-scan-count",
                "content": "```\\nobject Solution {\\n  def maxScore(nums: Array[Int]): Int = {\\n    val sort = nums sorted Ordering.Int.reverse\\n    val scan = (sort scanLeft 0L)(_ + _)\\n    return scan count (_ > 0)\\n  }\\n}\\n```\\nSort the array from largest to smallest, perform a plus scan, then count the positive values.",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def maxScore(nums: Array[Int]): Int = {\\n    val sort = nums sorted Ordering.Int.reverse\\n    val scan = (sort scanLeft 0L)(_ + _)\\n    return scan count (_ > 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3299018,
                "title": "scala-scanleft",
                "content": "# Code\\n```\\nobject Solution {\\n  def maxScore(nums: Array[Int]): Int =\\n    nums.sortBy(-_).scanLeft(0L)(_ + _).tail.takeWhile(_ > 0).length\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def maxScore(nums: Array[Int]): Int =\\n    nums.sortBy(-_).scanLeft(0L)(_ + _).tail.takeWhile(_ > 0).length\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3298035,
                "title": "o-1-sc-and-o-nlogn-tc-simple-c-solution",
                "content": "\\n# Intuition\\njust dry run  the below code once you get the intuition \\n\\n# Complexity\\n- Time complexity:\\n O(nlogn)\\n\\n- Space complexity:\\nO(1)\\n**Plz Upvote if you like the solution **\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.end());\\n       long long maxi=0;\\n       long long prefixSum=0;\\n       for(int i=0;i<nums.size();i++){\\n           prefixSum+=nums[i];\\n           if(prefixSum>0) maxi++;\\n       } \\n       return maxi;\\n    }\\n};\\n\\n**Plz Upvote if you like the solution **\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.end());\\n       long long maxi=0;\\n       long long prefixSum=0;\\n       for(int i=0;i<nums.size();i++){\\n           prefixSum+=nums[i];\\n           if(prefixSum>0) maxi++;\\n       } \\n       return maxi;\\n    }\\n};\\n\\n**Plz Upvote if you like the solution **\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297992,
                "title": "c-181-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(const vector<int>& nums) {\\n        int count = 0;\\n        long long sum = 0;\\n        priority_queue<int> neg;\\n\\n        for(int i : nums) {\\n            if(i > 0) {\\n                sum += i;\\n                ++count;\\n            }\\n            else neg.push(i);\\n        }\\n\\n        while(!neg.empty()) {\\n            sum += neg.top();\\n            neg.pop();\\n            if(sum > 0) ++count;\\n            else break;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(const vector<int>& nums) {\\n        int count = 0;\\n        long long sum = 0;\\n        priority_queue<int> neg;\\n\\n        for(int i : nums) {\\n            if(i > 0) {\\n                sum += i;\\n                ++count;\\n            }\\n            else neg.push(i);\\n        }\\n\\n        while(!neg.empty()) {\\n            sum += neg.top();\\n            neg.pop();\\n            if(sum > 0) ++count;\\n            else break;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297922,
                "title": "simple-java-solution-with-explanation-and-approach",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we need to count the elements whole prefix or in this case postfix sum should be greater than 0. So going ahead and simply sort the array in ascending order and looping it reverse and count all the prefix sum number whose sum is greater than 0. \\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        long maxScore = 0;\\n        int ans = 0;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            maxScore += nums[i];\\n            if (maxScore <= 0) break;\\n            ans += 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        long maxScore = 0;\\n        int ans = 0;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            maxScore += nums[i];\\n            if (maxScore <= 0) break;\\n            ans += 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297683,
                "title": "simple-java-solution",
                "content": "# Intuition\\nSort Array in ascending order. Go through array in reverse order and keep prefix sum. Increment count till the sum is greater than zero\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long sum = nums[n-1];\\n        if(sum<=0)\\n            return 0;\\n        int count = 1;\\n        for(int i=n-2;i>=0;i--){\\n            sum += nums[i];\\n            if(sum<=0)\\n                return count;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long sum = nums[n-1];\\n        if(sum<=0)\\n            return 0;\\n        int count = 1;\\n        for(int i=n-2;i>=0;i--){\\n            sum += nums[i];\\n            if(sum<=0)\\n                return count;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297408,
                "title": "very-fast-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int maxScore(int[] arr) {\\n        Arrays.sort(arr);\\n        int count = 0;\\n        long sum = 0;\\n        \\n        for(int i=arr.length-1;i>=0;--i){\\n            sum += arr[i];\\n            if(sum>0){\\n                count++;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int maxScore(int[] arr) {\\n        Arrays.sort(arr);\\n        int count = 0;\\n        long sum = 0;\\n        \\n        for(int i=arr.length-1;i>=0;--i){\\n            sum += arr[i];\\n            if(sum>0){\\n                count++;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297377,
                "title": "nlogk-priority-queue-solution-in-c",
                "content": "# Intuition\\nIt makes sense to take all positive numbers and zeroes since they can all be used to extend the positive prefix. In case total is negative, we need to kick out some of the negative numbers to increase the prefix sum in hope that it becomes positive. Which numbers to remove? Obviously, the smaller the negative number, the larger prefix sum without it is going to be, so it\\'s best to remove the smallest numbers.\\n\\n# Approach\\nGreedily remove smallest numbers until `total` becomes positive and as soon it becomes positive, all numbers in `nums` contribute to the `score`. There are many ways to find smallest candidates, and in this particular case priority queue is used.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(k))$$\\n\\n- Space complexity:\\n$$O(n)$$ since input array is modified in-place\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        auto total = reduce(begin(nums), end(nums), 0LL);\\n        if (total > 0) return nums.size();\\n        auto cmp = greater<int>{};\\n        make_heap(begin(nums), end(nums), cmp);\\n        while (total <= 0 && !nums.empty()) {\\n            pop_heap(begin(nums), end(nums), cmp);\\n            total -= nums.back(); nums.pop_back();\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        auto total = reduce(begin(nums), end(nums), 0LL);\\n        if (total > 0) return nums.size();\\n        auto cmp = greater<int>{};\\n        make_heap(begin(nums), end(nums), cmp);\\n        while (total <= 0 && !nums.empty()) {\\n            pop_heap(begin(nums), end(nums), cmp);\\n            total -= nums.back(); nums.pop_back();\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296990,
                "title": "sorting-prefixsum-easy-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    int maxScore(vector<int>& nums) \\n    {\\n     sort(nums.begin(),nums.end()) ;\\n     reverse(nums.begin(),nums.end());\\n     vector<int>pre ;\\n     long long int sum=0 ;\\n     int count=0 ;\\n     for(int i=0;i<nums.size();i++)\\n     {\\n      sum += nums[i] ;\\n      pre.push_back(sum) ;\\n      if(sum>0) count++ ;\\n     }\\n     return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int maxScore(vector<int>& nums) \\n    {\\n     sort(nums.begin(),nums.end()) ;\\n     reverse(nums.begin(),nums.end());\\n     vector<int>pre ;\\n     long long int sum=0 ;\\n     int count=0 ;\\n     for(int i=0;i<nums.size();i++)\\n     {\\n      sum += nums[i] ;\\n      pre.push_back(sum) ;\\n      if(sum>0) count++ ;\\n     }\\n     return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296860,
                "title": "python3-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Sort array to achieve maximum positive prefix\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*Log(N))\\n- Space complexity:\\nO(N) The origial array\\n\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        score = 0\\n        base = 0\\n        \\n        nums.sort(reverse=True)\\n        \\n        for num in nums:\\n            base = base + num\\n            \\n            if base > 0:\\n                score = score + 1\\n        \\n        return score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        score = 0\\n        base = 0\\n        \\n        nums.sort(reverse=True)\\n        \\n        for num in nums:\\n            base = base + num\\n            \\n            if base > 0:\\n                score = score + 1\\n        \\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296859,
                "title": "easy-to-understand-c-prefix-sum-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake another vector of long long of same size as given vector. Sort given vector in descending order and find prefix sum for taken vector. Count total positive number and return it. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int size = nums.size();\\n        // vector<int> v(size);\\n        // int k = 0;\\n        // int j = size - 1;\\n        // for(int i=0; i<size; i++)\\n        // {\\n        //     if(nums[i] <= 0)\\n        //     {\\n        //         v[j] = nums[i];\\n        //         j--;\\n        //     }\\n        //     else\\n        //     {\\n        //         v[k] = nums[i];\\n        //         k++;\\n        //     }\\n        // }\\n        sort(begin(nums), end(nums), greater<int>());\\n        vector<long long> ps(size);\\n        long long sum = 0;\\n        ps[0] = nums[0];\\n        for(int i=1; i<size; i++)\\n        {\\n            sum = nums[i] + ps[i-1];\\n            ps[i] = sum;\\n        }\\n        int cnt = 0;\\n        for(int i=0; i<size; i++)\\n        {\\n            if(ps[i] > 0)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        int size = nums.size();\\n        // vector<int> v(size);\\n        // int k = 0;\\n        // int j = size - 1;\\n        // for(int i=0; i<size; i++)\\n        // {\\n        //     if(nums[i] <= 0)\\n        //     {\\n        //         v[j] = nums[i];\\n        //         j--;\\n        //     }\\n        //     else\\n        //     {\\n        //         v[k] = nums[i];\\n        //         k++;\\n        //     }\\n        // }\\n        sort(begin(nums), end(nums), greater<int>());\\n        vector<long long> ps(size);\\n        long long sum = 0;\\n        ps[0] = nums[0];\\n        for(int i=1; i<size; i++)\\n        {\\n            sum = nums[i] + ps[i-1];\\n            ps[i] = sum;\\n        }\\n        int cnt = 0;\\n        for(int i=0; i<size; i++)\\n        {\\n            if(ps[i] > 0)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296715,
                "title": "easy-reverse-sort-and-prefix-sum",
                "content": "# Intuition\\nJust reverse sort the array and take the prefix sums and check if it is positive , if yes then increase answer by 1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n        int ans=0;\\n        long long sum=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum = sum +0LL + nums[i];\\n            if(sum>0)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n        int ans=0;\\n        long long sum=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum = sum +0LL + nums[i];\\n            if(sum>0)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296531,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int ans=0;\\n        vector<long long int>v;\\n        v.resize(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==0)\\n            {\\n                if(nums[i]>0)\\n                {\\n                    ans++;\\n                }\\n                v[i]=nums[i]*1LL;\\n            }\\n            else\\n            {\\n                v[i]=nums[i]+v[i-1]+0LL;\\n                if(v[i]>0)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int ans=0;\\n        vector<long long int>v;\\n        v.resize(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==0)\\n            {\\n                if(nums[i]>0)\\n                {\\n                    ans++;\\n                }\\n                v[i]=nums[i]*1LL;\\n            }\\n            else\\n            {\\n                v[i]=nums[i]+v[i-1]+0LL;\\n                if(v[i]>0)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296382,
                "title": "rearrange-array-to-maximize-prefix-score",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n    \\n        int result = 0;\\n        sort(nums.begin(),nums.end(), greater<int>());\\n        long long int prefix_sum = 0;\\n        for(int i = 0; i<nums.size();i++){\\n          prefix_sum += nums[i];\\n                if (prefix_sum > 0)\\n                    result++;\\n        }\\n     return result;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxScore(vector<int>& nums) {\\n    \\n        int result = 0;\\n        sort(nums.begin(),nums.end(), greater<int>());\\n        long long int prefix_sum = 0;\\n        for(int i = 0; i<nums.size();i++){\\n          prefix_sum += nums[i];\\n                if (prefix_sum > 0)\\n                    result++;\\n        }\\n     return result;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1829802,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829774,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829853,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829924,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1941918,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1884901,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1854790,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829927,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 2062375,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1980054,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829802,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829774,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829853,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829924,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1941918,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1884901,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1854790,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1829927,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 2062375,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            },
            {
                "id": 1980054,
                "content": [
                    {
                        "username": "aeroabrar_31",
                        "content": "Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "sunnykumarbr85",
                        "content": "same to same bro\\n"
                    },
                    {
                        "username": "hellstormangel",
                        "content": "+1 \\uD83D\\uDE02"
                    },
                    {
                        "username": "samyak1409",
                        "content": "+1 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Me also\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@papannn](/papannn) same with me!"
                    },
                    {
                        "username": "papannn",
                        "content": "Absolutely me \\u261D\\uFE0F\\uD83D\\uDE14"
                    },
                    {
                        "username": "CODEX47",
                        "content": "I have seen easy marked problem harder than this one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Anyone here forgot use long instead of int to calculate sum.\\nI wasted 1 hour in this problem to finally figure out this. I\\'m stupid"
                    },
                    {
                        "username": "Asta_Kun",
                        "content": "me too ;-;"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "me \\uD83D\\uDE2D"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "Return the maximum score you can achieve\\n\\nTHIS LINE FORCED EVERYONE TO FIND MAX. ELEMENT IN PREFIX ARRAY \\uD83D\\uDE02"
                    },
                    {
                        "username": "HelloDavid",
                        "content": "A medium problem, I feel worried about LeetCode\\'s problem ranking :v"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How on earth this is a medium question !"
                    },
                    {
                        "username": "aniket1104",
                        "content": "        long ans= 0;\\n        long rsum= 0;\\n        Array.Sort(nums);\\n        Array.Reverse(nums);\\n        for(int i =0;i<nums.Length;i++){\\n            rsum+=nums[i];\\n            ans=Math.Max(ans,rsum);\\n        }\\n        return (int)ans;\\n\\n\\nHow the o/p for the following i/p is 20?\\nMy o/p is 7583210\\n\\n[-687767,-860350,950296,52109,510127,545329,-291223,-966728,852403,828596,456730,-483632,-529386,356766,147293,572374,243605,931468,641668,494446]\\n"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "[@user2049D](/user2049D)  me also . 209 / 1071 testcases passed . "
                    },
                    {
                        "username": "user2049D",
                        "content": "aeroabrar_31 wrote : \"Who else have misread this question and returning max element from the prefix array.\\uD83D\\uDE02\\uD83D\\uDE02\""
                    },
                    {
                        "username": "ishpreet956",
                        "content": "But why do we need to use long for finding the sum?"
                    },
                    {
                        "username": "ishpreet956",
                        "content": "[@ayushashank](/ayushashank) ok got it thanks"
                    },
                    {
                        "username": "ayushashank",
                        "content": "Because size of nums can be 10^5 and if all the numbers are 10^6, their sum will be of order 10^11 which cannot be stored in int."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Problem difficulty: Easy\\nDescription difficulty: Hard.\\nTips:\\n1. The problem wants to know how many positive prefixSums you can build if you arrange the array in a \"good way\"\\n2. EG: -5,-6,4,3,1,2,4 -> prefixSum = [-5,-11,-7,-4,-3,-1,3]. => you only have 1 positive sum element\\n3. Sort it => 4,4,3,2,1,-5,-6 => prefixSum = [4,8,11,13,14,9,3] => you have 7 positive prefixSum elements\\n"
                    },
                    {
                        "username": "Kuba111",
                        "content": "Think about sorting and also what happens when you add large integer numbers together :)"
                    }
                ]
            }
        ]
    }
]