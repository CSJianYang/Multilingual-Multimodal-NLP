[
    {
        "title": "Maximum Split of Positive Even Integers",
        "question_content": "You are given an integer finalSum. Split it into a sum of a maximum number of unique positive even integers.\n\n\tFor example, given finalSum = 12, the following splits are valid (unique positive even integers summing up to finalSum): (12), (2 + 10), (2 + 4 + 6), and (4 + 8). Among them, (2 + 4 + 6) contains the maximum number of integers. Note that finalSum cannot be split into (2 + 2 + 4 + 4) as all the numbers should be unique.\n\nReturn a list of integers that represent a valid split containing a maximum number of integers. If no valid split exists for finalSum, return an empty list. You may return the integers in any order.\n&nbsp;\nExample 1:\n\nInput: finalSum = 12\nOutput: [2,4,6]\nExplanation: The following are valid splits: (12), (2 + 10), (2 + 4 + 6), and (4 + 8).\n(2 + 4 + 6) has the maximum number of integers, which is 3. Thus, we return [2,4,6].\nNote that [2,6,4], [6,2,4], etc. are also accepted.\n\nExample 2:\n\nInput: finalSum = 7\nOutput: []\nExplanation: There are no valid splits for the given finalSum.\nThus, we return an empty array.\n\nExample 3:\n\nInput: finalSum = 28\nOutput: [6,8,2,12]\nExplanation: The following are valid splits: (2 + 26), (6 + 8 + 2 + 12), and (4 + 24). \n(6 + 8 + 2 + 12) has the maximum number of integers, which is 4. Thus, we return [6,8,2,12].\nNote that [10,2,4,12], [6,2,4,16], etc. are also accepted.\n\n&nbsp;\nConstraints:\n\n\t1 <= finalSum <= 1010",
        "solutions": [
            {
                "id": 1783191,
                "title": "c-easy-simulation-o-maximumnumbers-time-o-1-space",
                "content": "So it\\'s clear from question that if **n** is odd answer is not possible (bcz we can\\'t represent a odd number as a sum of even numbers)\\n\\nNow if **n** is **even** , then we have to make the largest list of unique even number such that the sum is equal to given n.\\n\\nNow to make the largest we have to take smallest numbers first like 2,4,6,8... and so on.\\n\\nbut wait what happen if we are doing in this manner and the total sum is greater than desired , no worries , we wll do this step untill our sum is less than or equal to given number , and just add the remaining difference to last number in the list.\\n\\nTake n =14 \\n1) i = 2 , crSum = 0 , list = []    (crSum + 2 <= 14 , so push it) , crSum + i = 2 , list = [2]\\n2) i = 4 , crSum = 2 , list = [2]   (crSum + 4 <= 14 , so push it) , crSum + i = 6 , list = [2,4]\\n3) i = 6 , crSum = 6 , list = [2,4] (crSum + 6 <= 14 , so push it) , crSum + i = 12 , list = [2,4,6]\\n4) i = 8 , crSum = 12 , list = [2,4,6] (crSum + 8 > 14 , so **don\\'t** push it , **break** the loop)\\n\\nNow we have crSum = 12 , and we want 14 , so simply add difference (which is 14-12 = 2 ) in the last element of list\\n\\nso list = [2,4,6+(14-12)] = [2,4,8]\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long n) {\\n        if(n%2) // odd\\n            return {};\\n\\n\\t\\tvector<long long> ans;\\n        long long i = 2;\\n        long long crSum=0;\\n\\t\\t\\n        while((crSum+i)<= n)\\n        {\\n            ans.push_back(i);\\n            crSum+=i;\\n            i+=2;\\n        }\\n\\t\\t\\n\\t\\t// add remaining difference to the last value in answer list\\n\\t\\tint sz = ans.size();\\n        ans[sz-1] += (n-crSum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long n) {\\n        if(n%2) // odd\\n            return {};\\n\\n\\t\\tvector<long long> ans;\\n        long long i = 2;\\n        long long crSum=0;\\n\\t\\t\\n        while((crSum+i)<= n)\\n        {\\n            ans.push_back(i);\\n            crSum+=i;\\n            i+=2;\\n        }\\n\\t\\t\\n\\t\\t// add remaining difference to the last value in answer list\\n\\t\\tint sz = ans.size();\\n        ans[sz-1] += (n-crSum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783317,
                "title": "java-python-3-greedy-w-brief-explanation-and-analysis",
                "content": "**Note:** For the rigorous proof of greedy algorithm correctness you can refer to \\n\\nsimilar problem: [881. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/discuss/156855/javapython-3-onlogn-code-sorting-greedy-with-greedy-algorithm-proof) \\n\\nto prove it similarly.\\n\\n----\\n\\n1. Starting from smallest positive even, `2`, each iteration deduct it from the `finalSum` and increase by 2, till reach or go beyond `final sum`; \\n2. Add the remaining part of the `finalSum` to the largest positive to make sure all are distinct.\\n**Note:** if the remaining part is `0`, then adding it to the largest positive will NOT influence anything; if NOT, then the remaining part must be less than or equal to the largest one, if NOT adding it to the largest one, there will be a **duplicate** number since we have traversed all positive even numbers that are less than or equal to the largest one. e.g., \\n\\n\\t`finalSum = 32`, and we have increased `i` from `2` to `10` and get `2 + 4 + 6 + 8 + 10 = 30`. Now `finalSum` has deducted `30` and now is `2`, which is less than the next value of `i = 12`. Since we must used up `finalSum`, but putting `finalSum = 2` back into the even number sequence will result duplicates of `2`; In addition, if we add `2` to any number other than the biggest `10`, there will be duplicates also. The only option is adding `2` to the largest one, `10`, to avoid duplicates.\\n\\n```java\\n    public List<Long> maximumEvenSplit(long f) {\\n        LinkedList<Long> ans = new LinkedList<>();\\n        if (f % 2 == 0) {\\n            long i = 2;\\n            while (i <= f) {\\n                ans.offer(i);\\n                f -= i;\\n                i += 2;\\n            } \\n            ans.offer(f + ans.pollLast());\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def maximumEvenSplit(self, f: int) -> List[int]:\\n        ans, i = [], 2\\n        if f % 2 == 0:\\n            while i <= f:\\n                ans.append(i)\\n                f -= i\\n                i += 2\\n            ans[-1] += f\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nAssume there are totally `i` iterations, so `2 + 4 + ... + 2 * i = (2 + 2 * i) * i / 2 =  i * (i + 1) = i + i`<sup>2</sup> `~ finalSum`, get rid of the minor term `i`, we have `i`<sup>2</sup> `~ finalSum`, which means `i ~ finalSum`<sup>0.5</sup>; therefore\\n\\nTime: `O(n`<sup>0.5</sup>`)`, where `n = finalSum`, space: `O(1)`- excluding return space.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<Long> maximumEvenSplit(long f) {\\n        LinkedList<Long> ans = new LinkedList<>();\\n        if (f % 2 == 0) {\\n            long i = 2;\\n            while (i <= f) {\\n                ans.offer(i);\\n                f -= i;\\n                i += 2;\\n            } \\n            ans.offer(f + ans.pollLast());\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maximumEvenSplit(self, f: int) -> List[int]:\\n        ans, i = [], 2\\n        if f % 2 == 0:\\n            while i <= f:\\n                ans.append(i)\\n                f -= i\\n                i += 2\\n            ans[-1] += f\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1783966,
                "title": "simple-python-solution-with-explanation-o-sqrt-n-time-complexity-o-1-space-complexity",
                "content": "```\\n\\'\\'\\'VOTE  UP, if you like and understand the solution\\'\\'\\'\\n\\'\\'\\'You are free to correct my time complexity if you feel it is incorrect.\\'\\'\\' \\n```\\n```\\n**If finalSum is odd then their is no possible way**\\n1. If finalSum is even then take s=0 and pointer i=2.\\n2.  add i in sum till s < finalSum and add i in the set l.\\n3.  If s == finalSum then return l\\n4.  else delete s from the l and return l.\\n```\\n![image](https://assets.leetcode.com/users/images/bd47a046-b7c5-4a4f-bfbf-497a52ad33ee_1645295814.303415.jpeg)\\n\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        l=set()\\n        if finalSum%2!=0:\\n            return l\\n        else:\\n            s=0\\n            i=2                       # even pointer 2, 4, 6, 8, 10, 12...........\\n            while(s<finalSum):\\n                s+=i                #sum \\n                l.add(i)      # append the i in list\\n                i+=2\\n            if s==finalSum:  #if sum s is equal to finalSum then no modidfication required\\n                return l\\n            else:\\n                l.discard(s-finalSum)  #Deleting the element which makes s greater than finalSum\\n\\t\\t\\t\\treturn l\\n```\\n![image](https://assets.leetcode.com/users/images/e0b0feaa-9239-4d93-83ee-85c13fac81ca_1645295840.8109055.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n\\'\\'\\'VOTE  UP, if you like and understand the solution\\'\\'\\'\\n\\'\\'\\'You are free to correct my time complexity if you feel it is incorrect.\\'\\'\\' \\n```\n```\\n**If finalSum is odd then their is no possible way**\\n1. If finalSum is even then take s=0 and pointer i=2.\\n2.  add i in sum till s < finalSum and add i in the set l.\\n3.  If s == finalSum then return l\\n4.  else delete s from the l and return l.\\n```\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        l=set()\\n        if finalSum%2!=0:\\n            return l\\n        else:\\n            s=0\\n            i=2                       # even pointer 2, 4, 6, 8, 10, 12...........\\n            while(s<finalSum):\\n                s+=i                #sum \\n                l.add(i)      # append the i in list\\n                i+=2\\n            if s==finalSum:  #if sum s is equal to finalSum then no modidfication required\\n                return l\\n            else:\\n                l.discard(s-finalSum)  #Deleting the element which makes s greater than finalSum\\n\\t\\t\\t\\treturn l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783586,
                "title": "c-greedy-o-sqrt-n-time-o-1-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Backtracking\\n\\nIf `finalSum` is odd, return empty array.\\n\\nOtherwise, we keep trying subtracting `2, 4, 6, 8, ...` from `finalSum` via backtracking.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-split-of-positive-even-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(sqrt(N))\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long s) {\\n        if (s % 2) return {};\\n        vector<long long> ans;\\n        function<bool(long, long)>dfs = [&](long i, long target) {\\n            if (target == 0) return true;\\n            if (target < i) return false;\\n            ans.push_back(i);\\n            if (dfs(i + 2, target - i)) return true; // use `i`\\n            ans.pop_back();\\n            return dfs(i + 2, target); // skip `i`\\n        };\\n        dfs(2, s);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n## Solution 2. Greedy\\n\\nIn solution 1, in fact we only backtrack at most once.\\n\\nWe can keep trying subtracting `2, 4, 6, 8, ...` from `finalSum`. We stop the loop when subtracting the current number `i` is invalid -- `s - i < i + 2` (the reminder after the subtraction is less than the next even number). And we push the reminder into the answer.\\n\\n**Time Complexity**: Assume there are `k` numbers in the answer, the sum is roughly `2 + 4 + ... + 2*k ~= finalSum`. The sum of the left side is `(2 + 2*k) * k / 2`, so `k` is of the magnitude of `sqrt(finalSum)`. Thus, this solution takes `O(sqrt(N))` time.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-split-of-positive-even-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long s) {\\n        if (s % 2) return {};\\n        vector<long long> ans;\\n        for (int i = 2; s - i >= i + 2; i += 2) {\\n            ans.push_back(i);\\n            s -= i;\\n        }\\n        ans.push_back(s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximum-split-of-positive-even-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(sqrt(N))\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long s) {\\n        if (s % 2) return {};\\n        vector<long long> ans;\\n        function<bool(long, long)>dfs = [&](long i, long target) {\\n            if (target == 0) return true;\\n            if (target < i) return false;\\n            ans.push_back(i);\\n            if (dfs(i + 2, target - i)) return true; // use `i`\\n            ans.pop_back();\\n            return dfs(i + 2, target); // skip `i`\\n        };\\n        dfs(2, s);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-split-of-positive-even-integers/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(N))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long s) {\\n        if (s % 2) return {};\\n        vector<long long> ans;\\n        for (int i = 2; s - i >= i + 2; i += 2) {\\n            ans.push_back(i);\\n            s -= i;\\n        }\\n        ans.push_back(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786937,
                "title": "greedy",
                "content": "We cannot split odd numbers, and we can always split even ones.\\n \\nSince split numbers must be unique, the best strategy is to use the smallest possible numbers (`2, 4, 6, ...` and so on) first.\\n \\nAt some point, we won\\'t be able to split the remaining sum without repeating a previously used number (`sum - cur < cur + 2`). So, that remaining sum will be our last number in the split sequence.\\n\\n**C++**\\n```cpp\\nvector<long long> maximumEvenSplit(long long sum) {\\n    vector<long long> res;\\n    for (int cur = 2; sum % 2 == 0 && sum > 0; cur += 2) {\\n        if (sum - cur < cur + 2)\\n            res.push_back(sum);\\n        else\\n            res.push_back(cur);        \\n        sum -= res.back();\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<long long> maximumEvenSplit(long long sum) {\\n    vector<long long> res;\\n    for (int cur = 2; sum % 2 == 0 && sum > 0; cur += 2) {\\n        if (sum - cur < cur + 2)\\n            res.push_back(sum);\\n        else\\n            res.push_back(cur);        \\n        sum -= res.back();\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783721,
                "title": "java-intuitive-explanation-greedy-approach",
                "content": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<Long>();\\n        //odd sum cannot be divided into even numbers\\n        if(finalSum % 2 != 0) {\\n            return res;\\n        }\\n        //Greedy approach, try to build the total sum using minimum unique even nos\\n        long currNum = 2;\\n        long remainingSum = finalSum;\\n        //as long as we can add subtract this number from remaining sum\\n        while(currNum <= remainingSum) {\\n            res.add(currNum);\\n            remainingSum -= currNum;//reducing remaining sum\\n            currNum += 2;//next even number\\n        }\\n        //now, remaining sum cannot be fulfilled by any larger even number\\n        //so extract the largest even number we added to the last index of res, and make it even larger by adding this current remaining sum\\n        //add remaining sum to the last element\\n        long last = res.remove(res.size()-1);\\n        res.add(last+remainingSum);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<Long>();\\n        //odd sum cannot be divided into even numbers\\n        if(finalSum % 2 != 0) {\\n            return res;\\n        }\\n        //Greedy approach, try to build the total sum using minimum unique even nos\\n        long currNum = 2;\\n        long remainingSum = finalSum;\\n        //as long as we can add subtract this number from remaining sum\\n        while(currNum <= remainingSum) {\\n            res.add(currNum);\\n            remainingSum -= currNum;//reducing remaining sum\\n            currNum += 2;//next even number\\n        }\\n        //now, remaining sum cannot be fulfilled by any larger even number\\n        //so extract the largest even number we added to the last index of res, and make it even larger by adding this current remaining sum\\n        //add remaining sum to the last element\\n        long last = res.remove(res.size()-1);\\n        res.add(last+remainingSum);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784208,
                "title": "javascript-greedy-with-set",
                "content": "```\\n var maximumEvenSplit = function(finalSum) {\\n\\n    if(finalSum % 2) return [];\\n\\n    const set = new Set();\\n\\n    let n = 2, sum = 0;\\n\\n    while(sum < finalSum) {\\n        sum += n;\\n        set.add(n);\\n        n += 2;\\n    }\\n\\n    set.delete(sum - finalSum);\\n\\n    return [...set];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\n var maximumEvenSplit = function(finalSum) {\\n\\n    if(finalSum % 2) return [];\\n\\n    const set = new Set();\\n\\n    let n = 2, sum = 0;\\n\\n    while(sum < finalSum) {\\n        sum += n;\\n        set.add(n);\\n        n += 2;\\n    }\\n\\n    set.delete(sum - finalSum);\\n\\n    return [...set];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783313,
                "title": "easy-c-code-easy-to-understand-with-comments",
                "content": "If the given finalSum is odd then we can not divide it into sum of even numbers so we will return an empty vector in this scenario.\\n\\nSo, if the given sum in even than we can divide it into sum of even numbers.\\nBut we need it to be longest length possible and all the numbers should be unique.\\n\\nWe can think of a greedy way, every time we pick a smallest even number and return it and finally if we get a number which is already used we will add it to the last inserted number.\\n\\nFor example: 28\\n\\nfirst i will pick 2.\\n And the number becomes 26 and vector becomes {2};\\nNext I will pick 4 so the number becomes 22 and vector becomes (2,4};\\nNext I will pick 6 so the number becomes 16 and vector becomes (2,4,6};\\nNext I will pick 12 so the number becomes 4 and vector becomes (2,4,6,12};\\n But i already used 4 so i will add 4 to the last inserted number (all the elements must be unique) so our final answer becomes {2,4,6,16}; \\n\\n**Time complexity** : O(sqrt(n)).\\n**Space complexity** : O(1).\\n\\nC++ code:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long sum) {\\n        vector<long long> ans;\\n        if(sum%2) return ans;  // if given sum is odd return empty vector.\\n        \\n        long long cnt = sum/2;     // how many 2\\'s available for each time.\\n        \\n        long long i=1;          // how many 2\\'s we are currently using.\\n        while(cnt>=i){\\n            ans.push_back(2*i);\\n            cnt -= i;\\n            i++;\\n        }\\n        if(cnt){     // if any 2\\'s are left we are adding them to the last inserted element.\\n            ans[ans.size()-1] = ans[ans.size()-1] + (2*cnt);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Why the time complexity is O(sqrt(n)) ?**\\n\\nConsider this problem, given a number x and we need to Split it into a sum of a maximum number of unique positive integers.\\n\\nInorder to solve this we every time pick a smallest avalible positive integer. We do this until we get sum of first n natural numbers equal to the given x or greater than x and remove the last number and add the remaining part to last added number.\\n \\n So the sum of first n natural numbers is n*(n+1)/2.\\n From this we can get the time complexity as O(sqrt(n));\\n\\n**Upvote if it helps!!**",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long sum) {\\n        vector<long long> ans;\\n        if(sum%2) return ans;  // if given sum is odd return empty vector.\\n        \\n        long long cnt = sum/2;     // how many 2\\'s available for each time.\\n        \\n        long long i=1;          // how many 2\\'s we are currently using.\\n        while(cnt>=i){\\n            ans.push_back(2*i);\\n            cnt -= i;\\n            i++;\\n        }\\n        if(cnt){     // if any 2\\'s are left we are adding them to the last inserted element.\\n            ans[ans.size()-1] = ans[ans.size()-1] + (2*cnt);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783590,
                "title": "using-binary-search-a-bit-of-math-with-comments-faster-than-100-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    \\n    ll bs(ll low , ll high, ll fs){\\n\\n        ll ans = 1;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(mid*(mid+1)>fs){\\n                high = mid-1; // If sum till index equal to \\'mid\\' > fs then make high = mid-1\\n            }\\n            else if(mid*(mid+1)==fs){\\n                return mid; // If sum till index equal to \\'mid == fs, return \\'mid\\'\\n            }\\n            else{\\n                ans = mid; // If sum till index equal to \\'mid\\' < fs, update answer\\n                low = mid+1; // check for better answer\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        // ****some base cases / corner cases****\\n\\t\\tif(finalSum&1)  return {}; \\n        if(finalSum==4) return {4}; \\n        if(finalSum==8) return {2,6}; \\n\\t\\t\\n        vector<ll> ans; \\n        \\n\\t\\t// assume that we are giving indices to even numbers\\n\\t\\t// EVEN NUMBERS -> 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ..............\\n\\t\\t// THEIR INDICES-> 1 , 2 , 3 , 4 ,  5 ,  6 ,  7 , 8  ..............\\n\\t\\t\\n\\t\\t// \\'idx\\' is the index of that EVEN number uptil which the total sum of all even numbers <= finalSum\\n        ll idx = bs(1,finalSum/2,finalSum);\\n\\t\\t\\n\\t\\t//Consequently, \\'end\\' is that EVEN number uptil which the total sum of all even numbers <= finalSum\\n        ll start = 2, end = idx*2;\\n        \\n\\t\\t//Now, we add all the even numbers from index 1 to index \\'idx-1\\'\\n\\t\\t// 2 + 4 + 6 + 8  ........................... + (end-2) + end\\n\\t\\t// 1   2   3   4  ...........................    idx-1    idx\\n        for(int i = start; i<= (idx-1)*2; i+=2){\\n            ans.push_back(i);\\n        }\\n\\t\\t\\n\\t\\t// We do not add the last even number yet, so that we can modify it and add it later to make the (totalSumSoFar) == finalSum\\n\\t\\t// \\'totalSumSoFar\\' can be easily calculated by using the formula ( totalSumSoFar = idx*(idx+1) )\\n\\t\\t\\n\\t\\t// increasing the last even number \\'end\\' by the difference of (finalSum and totalSumSoFar)\\n        if(idx*(idx+1)<finalSum){\\n            end = end + abs(finalSum - idx*(idx+1));\\n        }\\n\\t\\t\\n\\t\\t// adding the last even number after increasing it with the required factor\\n        ans.push_back(end);\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    \\n    ll bs(ll low , ll high, ll fs){\\n\\n        ll ans = 1;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(mid*(mid+1)>fs){\\n                high = mid-1; // If sum till index equal to \\'mid\\' > fs then make high = mid-1\\n            }\\n            else if(mid*(mid+1)==fs){\\n                return mid; // If sum till index equal to \\'mid == fs, return \\'mid\\'\\n            }\\n            else{\\n                ans = mid; // If sum till index equal to \\'mid\\' < fs, update answer\\n                low = mid+1; // check for better answer\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        // ****some base cases / corner cases****\\n\\t\\tif(finalSum&1)  return {}; \\n        if(finalSum==4) return {4}; \\n        if(finalSum==8) return {2,6}; \\n\\t\\t\\n        vector<ll> ans; \\n        \\n\\t\\t// assume that we are giving indices to even numbers\\n\\t\\t// EVEN NUMBERS -> 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 ..............\\n\\t\\t// THEIR INDICES-> 1 , 2 , 3 , 4 ,  5 ,  6 ,  7 , 8  ..............\\n\\t\\t\\n\\t\\t// \\'idx\\' is the index of that EVEN number uptil which the total sum of all even numbers <= finalSum\\n        ll idx = bs(1,finalSum/2,finalSum);\\n\\t\\t\\n\\t\\t//Consequently, \\'end\\' is that EVEN number uptil which the total sum of all even numbers <= finalSum\\n        ll start = 2, end = idx*2;\\n        \\n\\t\\t//Now, we add all the even numbers from index 1 to index \\'idx-1\\'\\n\\t\\t// 2 + 4 + 6 + 8  ........................... + (end-2) + end\\n\\t\\t// 1   2   3   4  ...........................    idx-1    idx\\n        for(int i = start; i<= (idx-1)*2; i+=2){\\n            ans.push_back(i);\\n        }\\n\\t\\t\\n\\t\\t// We do not add the last even number yet, so that we can modify it and add it later to make the (totalSumSoFar) == finalSum\\n\\t\\t// \\'totalSumSoFar\\' can be easily calculated by using the formula ( totalSumSoFar = idx*(idx+1) )\\n\\t\\t\\n\\t\\t// increasing the last even number \\'end\\' by the difference of (finalSum and totalSumSoFar)\\n        if(idx*(idx+1)<finalSum){\\n            end = end + abs(finalSum - idx*(idx+1));\\n        }\\n\\t\\t\\n\\t\\t// adding the last even number after increasing it with the required factor\\n        ans.push_back(end);\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127710,
                "title": "detailed-explanation-of-logic-with-example-and-code",
                "content": "This is more of a brain teaser than a coding problem. Once you get to the trick, coding is a piece of cake. (This problem has been asked in Google interviews quite frequently)\\n\\nLet\\'s see two main observations:\\n1. There cannot be any valid split if finalSum is odd. **finalSum must be even**.\\n2. If you start with 2, and keep adding subsequent even numbers (4,6,8...) either you will reach a sum which is **either equal to finalSum, or greater than finalSum**. If it is equal to final sum, you\\'re good to go. If not, then we can be sure that up untill the last added even number our split list\\'s values are correct. Only the last even number caused the sum to exceed finalSum. \\n\\nSo, we simply keep adding all consecutive even numbers in a variable currSum, and also add these even numbers to our answer list. Once we encounter **an even number which would cause the currSum to exceed finalSum, we don\\'t add it**, and break out of the loop. Now, (finalSum - currSum) is the remaining amount. How to adjust it? Simply **remove the last added even number from the answer list, and add the remaining amount to it.** Then insert it back in the list. Let\\'s understand this with an example: \\n\\nSuppose finalSum = 18\\nYou keep adding until next even integer > (finalSum - currSum). So you add 2,4,6 => This makes currSum = 12. Now next even value is 8. Since 8 > (18-12), we don\\'t add it. Instead, we remove 6 (last added even) and add (18-12) to 6, which makes it 6+6 = 12. Just add 12 to the answer. Final answer list becomes 2,4,12.\\n\\nCode:\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> ans = new ArrayList();\\n        if(finalSum % 2 != 0) return ans;\\n        \\n        long currSum = 0l;\\n        long i = 1l;\\n        long nextEven = 2l;\\n        while(currSum < finalSum) {\\n            nextEven = (2*i);\\n            if(nextEven > finalSum - currSum) break;\\n            currSum += nextEven;\\n            ans.add(nextEven);\\n            i++;\\n        }\\n        \\n        long last = ans.remove(ans.size() - 1);\\n        last += (finalSum - currSum);\\n        ans.add(last);\\n        return ans;\\n    }\\n}\\n```\\n\\nDo upvote if it helped :)\\nPeace!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> ans = new ArrayList();\\n        if(finalSum % 2 != 0) return ans;\\n        \\n        long currSum = 0l;\\n        long i = 1l;\\n        long nextEven = 2l;\\n        while(currSum < finalSum) {\\n            nextEven = (2*i);\\n            if(nextEven > finalSum - currSum) break;\\n            currSum += nextEven;\\n            ans.add(nextEven);\\n            i++;\\n        }\\n        \\n        long last = ans.remove(ans.size() - 1);\\n        last += (finalSum - currSum);\\n        ans.add(last);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783570,
                "title": "classic-backtracking-solution-no-tle-java",
                "content": "Comapred with other backtracking problems, in order to resolve the crazy TLE specifically for this problem: once the recursion comes up with the first completed combination, you can return it as the final result immediately. Since the backtracking always starts from the next smallest even number, the first result will be guranteed to keep the largest amount of numbers.\\nThis problem is pretty similar to [77. Combinations](https://leetcode.com/problems/combinations/)\\n\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<List<Long>> res = new ArrayList<>();\\n        if(finalSum % 2 != 0){//2m+2n=2(m+n)\\n            return new ArrayList<>();\\n        }\\n        \\n        bt(finalSum, 2, new ArrayList<>(), res);\\n\\n        return res.get(0);\\n    }\\n    \\n    private void bt(long finalSum, long start, List<Long> curComb, List<List<Long>> res){\\n        if(finalSum == 0){\\n            res.add(new ArrayList<>(curComb));\\n            return;\\n        }\\n        for(long i = start; i <= finalSum; i+=2){\\n            curComb.add(i);\\n            bt(finalSum - i, i + 2, curComb, res);\\n            if(res.size() > 0) return;\\n            curComb.remove(curComb.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<List<Long>> res = new ArrayList<>();\\n        if(finalSum % 2 != 0){//2m+2n=2(m+n)\\n            return new ArrayList<>();\\n        }\\n        \\n        bt(finalSum, 2, new ArrayList<>(), res);\\n\\n        return res.get(0);\\n    }\\n    \\n    private void bt(long finalSum, long start, List<Long> curComb, List<List<Long>> res){\\n        if(finalSum == 0){\\n            res.add(new ArrayList<>(curComb));\\n            return;\\n        }\\n        for(long i = start; i <= finalSum; i+=2){\\n            curComb.add(i);\\n            bt(finalSum - i, i + 2, curComb, res);\\n            if(res.size() > 0) return;\\n            curComb.remove(curComb.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783248,
                "title": "python-solution-by-splitting-and-merging",
                "content": "Basically divide the numbers into sum of 2\\'s and then join the 2\\'s to make different even sized numbers by first taking one 2, then two 2\\'s, then three 2\\'s and so on. If we do not have the required number of 2\\'s left, then just add the remaining 2\\'s into the last integer in the array. We add them to the last element of arr and not in middle to avoid clashing of values since we need unique values.\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        arr = []\\n        if finalSum % 2 == 0: # If finalSum is odd then we cannot ever divide it with the given conditions\\n            a, i = finalSum // 2, 1 # a is the number of 2\\'s and i is the number of 2\\'s that we will use to form a even number in the current iteration\\n            while i <= a: # Till we have sufficient number of 2\\'s available\\n                arr.append(2*i) # Join the i number of 2\\'s to form a even number\\n                a -= i # Number of 2\\'s remaining reduces by i\\n                i += 1 # Number of 2\\'s required in next itertation increases by 1\\n            s = sum(arr)\\n            arr[-1] += finalSum - s # This is done if their were still some 2\\'s remaining that could not form a number due to insufficient count, then we add the remaining 2\\'s into the last number.\\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        arr = []\\n        if finalSum % 2 == 0: # If finalSum is odd then we cannot ever divide it with the given conditions\\n            a, i = finalSum // 2, 1 # a is the number of 2\\'s and i is the number of 2\\'s that we will use to form a even number in the current iteration\\n            while i <= a: # Till we have sufficient number of 2\\'s available\\n                arr.append(2*i) # Join the i number of 2\\'s to form a even number\\n                a -= i # Number of 2\\'s remaining reduces by i\\n                i += 1 # Number of 2\\'s required in next itertation increases by 1\\n            s = sum(arr)\\n            arr[-1] += finalSum - s # This is done if their were still some 2\\'s remaining that could not form a number due to insufficient count, then we add the remaining 2\\'s into the last number.\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783458,
                "title": "c-2-solutions-greedy-and-backtracking",
                "content": "\\t----------------------------------------------------GREEDY--------------------------------------------------------------\\n\\t\\n\\tclass Solution {            // give a dry run with finalSum values as 12 and 8 ,then you would easily get the logic :\\')\\n\\tpublic:\\n\\t\\tvector<long long> maximumEvenSplit(long long finalSum) {\\n\\t\\t\\tlong long i=2;\\n\\t\\t\\tif(finalSum % 2) return {};\\n\\t\\t\\tvector<long long >v;\\n\\t\\t\\twhile(finalSum)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i<=finalSum)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(i);\\n\\t\\t\\t\\t\\tfinalSum-=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.back()+=finalSum;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti+=2;\\n\\t\\t\\t}\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};\\t\\n\\t\\n\\t---------------------------------------------BACKTRACKING-------------------------------------------------------------\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool solve(long long currSum,long long finalSum,vector<long long>&temp,long long i)\\n\\t\\t{\\n\\t\\t\\tif(currSum == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tif(currSum < 0 || currSum < i) return false;\\n\\n\\t\\t\\tfor(int j=i;j<finalSum;j+=2)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.push_back(j);\\n\\t\\t\\t\\tif(solve(currSum-j,finalSum,temp,j+2)) return true;\\n\\t\\t\\t\\ttemp.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<long long> maximumEvenSplit(long long finalSum) {\\n\\t\\t\\tif(finalSum % 2 != 0) return {};\\n\\t\\t\\tif(finalSum == 2 || finalSum == 4) return {finalSum};\\n\\t\\t\\tvector<long long>temp;\\n\\t\\t\\tif( solve(finalSum,finalSum,temp,2)) return temp;\\n\\t\\t\\treturn {};\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Greedy",
                    "Recursion"
                ],
                "code": "class Solution {            // give a dry run with finalSum values as 12 and 8 ,then you would easily get the logic :\\')\\n\\tpublic:\\n\\t\\tvector<long long> maximumEvenSplit(long long finalSum) {\\n\\t\\t\\tlong long i=2;\\n\\t\\t\\tif(finalSum % 2) return {}",
                "codeTag": "Java"
            },
            {
                "id": 1784566,
                "title": "python-with-explanation",
                "content": "if n is odd we will return empty list base case. if n is even we will do following:\\nlet take n=30 list=```[2,4,6,8,10]```. for suppose we you need n=28 you just need to delete difference of 30,28 from above list.**our logic stars here.** we wiil add all even number into the list until the sum is  greater than the target and remove the difference of exceeded from the list and return.\\n```\\ndef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        l=[]\\n        i=2\\n        k=0\\n\\t\\t#base case\\n        if finalSum%2!=0:\\n            return []\\n        else:\\n            while k<finalSum:\\n                l.append(i)\\n                k+=i\\n                i+=2  \\n            if k==finalSum:\\n                return l\\n            l.remove(k-finalSum)\\n            return l\\n```\\n**PLEASE UPVOTE. I NEED YOUR ENCOURAGEMENT.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```[2,4,6,8,10]```\n```\\ndef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        l=[]\\n        i=2\\n        k=0\\n\\t\\t#base case\\n        if finalSum%2!=0:\\n            return []\\n        else:\\n            while k<finalSum:\\n                l.append(i)\\n                k+=i\\n                i+=2  \\n            if k==finalSum:\\n                return l\\n            l.remove(k-finalSum)\\n            return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1783481,
                "title": "python-o-finalsum-0-5-easy-solution",
                "content": "If finalSum is divisible by 2, we can divide it by 2 and try to find list of unique positive integers that sum to finalSum. We can multiply everything by 2 at the end to return result. Take the smallest consecutive sequence i.e. 1,2,3,...,n -> this will have a sum of n*(n+1)/2. If this sum == finalSum, we are done. This is trivial case.\\n\\nThe non-trivial case:\\nIf we observe that 1+2+...+n < finalSum but 1+2+...+(n+1) > finalSum. Then, it is impossible to have a solution of size \\'n+1\\'. The smallest sequence of size n+1 exceeds finalSum. But, we can create a sequence of size \\'n\\' and this is a valid output. \\n\\nLet S = sum(1,2,...,n+1) and S-finalSum be the extra amount we don\\'t need. So we can remove the number \"S-finalSum\" from the seq [1,2,...,n+1]. Observe, 1 <= S-finalSum <= n. Therefore, from the sequence [1,2,...,n+1] if we remove S-finalSum, we have the solution that is of size \\'n\\'. \\n\\nTime Complexity:\\nWe are looking at the sequence of numbers [1,2,...,n] with the smallest \\'n\\' such that it\\'s sum exceeds finalSum. This sequence will have sum = O(n^2). This sum should match finalSum, i.e. O(n^2) = finalSum. Therefore, n = O(finalSum^0.5). For example, if finalSum = 10^10, then the sequence [1,2,...,n] will be of size 10^5 and the loop in this algorithm will run for 10^5 iterations.\\n\\nPS: There are other ways to solve this too but they all revolve around the fact that if the smallest sequence of size \\'n+1\\' exceeds finalSum, you can always generate a sequence of size \\'n\\' whose sum equals finalSum.\\n\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if(finalSum%2 != 0):\\n            return []\\n        \\n        finalSum = finalSum//2\\n        result = []\\n        total = 0\\n        remove = None\\n        for i in range(1, finalSum+1):\\n            result.append(i)\\n            total += i\\n            if(total == finalSum):\\n                break\\n            elif(total > finalSum):\\n                remove = total-finalSum\\n                break\\n        \\n        output = []\\n        for num in result:\\n            if(remove==None):\\n                output.append(2*num)\\n            else:\\n                if(num!=remove):\\n                    output.append(2*num)\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if(finalSum%2 != 0):\\n            return []\\n        \\n        finalSum = finalSum//2\\n        result = []\\n        total = 0\\n        remove = None\\n        for i in range(1, finalSum+1):\\n            result.append(i)\\n            total += i\\n            if(total == finalSum):\\n                break\\n            elif(total > finalSum):\\n                remove = total-finalSum\\n                break\\n        \\n        output = []\\n        for num in result:\\n            if(remove==None):\\n                output.append(2*num)\\n            else:\\n                if(num!=remove):\\n                    output.append(2*num)\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395712,
                "title": "python-backtracking-accepted-solution",
                "content": "Innitially got TLE but eventually figured out an acceptable backtracking solution.\\n\\n1. Since we start the backtracking process from the minmum even integer 2 and building the path upwords, **the first acceptable path whose values sum up to target is gureenteed to be the longest one**\\n2. Hence once we have found that path we return back immediately\\n\\nHopefully this is helpful for folks who got TLE on backtracking\\n\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        \\n        if finalSum % 2:\\n            return []\\n        \\n        self.res = []\\n        self.backtrack(finalSum, 0, [], 2)\\n        \\n        return self.res\\n        \\n    def backtrack(self, target, currSum, path, start):\\n\\n        if currSum == target:\\n            if len(path) > len(self.res):\\n                self.res = path[:]\\n                return True\\n            \\n        for i in range(start, target+1, 2):\\n            if currSum + i > target:\\n                break\\n            path.append(i)\\n            if self.backtrack(target,  currSum + i, path, i+2):\\n                return True\\n            path.pop()\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        \\n        if finalSum % 2:\\n            return []\\n        \\n        self.res = []\\n        self.backtrack(finalSum, 0, [], 2)\\n        \\n        return self.res\\n        \\n    def backtrack(self, target, currSum, path, start):\\n\\n        if currSum == target:\\n            if len(path) > len(self.res):\\n                self.res = path[:]\\n                return True\\n            \\n        for i in range(start, target+1, 2):\\n            if currSum + i > target:\\n                break\\n            path.append(i)\\n            if self.backtrack(target,  currSum + i, path, i+2):\\n                return True\\n            path.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997727,
                "title": "python-optimal-greedy-with-set",
                "content": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        ans = set() \\n        \\n        if finalSum % 2 == 1:\\n            return ans\\n        \\n        i = 2\\n        while finalSum > 0:\\n            ans.add(i)\\n            finalSum -= i\\n            i += 2\\n        if finalSum < 0:\\n            ans.remove(-finalSum)\\n            \\n        return list(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        ans = set() \\n        \\n        if finalSum % 2 == 1:\\n            return ans\\n        \\n        i = 2\\n        while finalSum > 0:\\n            ans.add(i)\\n            finalSum -= i\\n            i += 2\\n        if finalSum < 0:\\n            ans.remove(-finalSum)\\n            \\n        return list(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783273,
                "title": "c-greedy",
                "content": "**Inserting 2,4,6,8,10......**\\n```\\nvector<long long> maximumEvenSplit(long long f) {\\n        if(f%2!=0) return {};\\n        vector<long long> ans;\\n        long long j=2;\\n        while(f>0){\\n            if(f-j<=j){\\n                ans.push_back(f);\\n                return ans;\\n            }\\n            ans.push_back(j);\\n            f-=j;\\n            j+=2;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Inserting 2,4,6,8,10......**\\n```\\nvector<long long> maximumEvenSplit(long long f) {\\n        if(f%2!=0) return {};\\n        vector<long long> ans;\\n        long long j=2;\\n        while(f>0){\\n            if(f-j<=j){\\n                ans.push_back(f);\\n                return ans;\\n            }\\n            ans.push_back(j);\\n            f-=j;\\n            j+=2;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2453433,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0) return Collections.emptyList();\\n\\n        List<Long> result = new ArrayList<>();\\n        long sum = 0, evenNum = 2;\\n        while (sum + evenNum <= finalSum) {\\n            sum += evenNum;\\n            result.add(evenNum);\\n            evenNum += 2;\\n        }\\n\\n        // Adjust last even num if current sum is not matching to final sum\\n        if (sum < finalSum) {\\n            long lastEvenNum = result.remove(result.size() - 1);\\n            lastEvenNum += finalSum - sum;\\n            result.add(lastEvenNum);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0) return Collections.emptyList();\\n\\n        List<Long> result = new ArrayList<>();\\n        long sum = 0, evenNum = 2;\\n        while (sum + evenNum <= finalSum) {\\n            sum += evenNum;\\n            result.add(evenNum);\\n            evenNum += 2;\\n        }\\n\\n        // Adjust last even num if current sum is not matching to final sum\\n        if (sum < finalSum) {\\n            long lastEvenNum = result.remove(result.size() - 1);\\n            lastEvenNum += finalSum - sum;\\n            result.add(lastEvenNum);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324257,
                "title": "python3-simple-5-lines-solution-by-space-o-1-time-o-sqrt-n",
                "content": "First, to simplify the problem, let\\'s early-return for the odd case. We never get the result of odd number. Now this problem is finding an array for the integer instead of even number if we divide the finalSum by 2.\\n\\nThen let\\'s hand-write the expected result first:\\n* 1 -> [1]\\n* 2 -> [2]\\n* 3 -> [1 2]\\n* 4 -> [1 3]\\n* 5 -> [1 4]\\n* 6 -> [1 2 3]\\n* 7 -> [1 2 4]\\n* 8 -> [1 2 5]\\n* 9 -> [1 2 6]\\n* 10 -> [1 2 3 4]\\n\\nWe may observe:\\n1. The count of outcome array grows when the result of finalSum is a sequence of integer like 1..N.\\n\\te.g. 1 -> 1, 3 -> 2, 6 -> 3, 10 -> 4, ...\\n2. The outcome is generated by combining sequence of integer and the finalSum - the summation of the squence.\\n\\te.g. 9 -> [1 2] + [9-(1+2)], 10 -> [1 2 3] + [10-(1+2+3)]\\n\\nSo, we can use quadratic formula to calculate the count of outcome array.\\n```text\\nLet\\'s suppose s is finalSum//2, n is a count of outcome array.\\nn(n+1)/2 = s\\nn^2+n-2s = 0\\nn = (b+sqrt(b^2-4ac))/2a = (1+sqrt(1+8s))/2\\nHence, s=5 -> n=2 / s=6 -> n=3\\n```\\n\\nFinally, we can generate the sequence of integer of which size is n-1 and add the value of finalSum//2 minus sum of the sequence. Double them and return it.\\n\\nHere\\'s the code.\\n\\n```py\\nclass Solution:\\n     def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n         if finalSum % 2 == 1: return [] # Early return if target is odd\\n         s = finalSum//2\\n         n = (1+math.sqrt(1+8*s))/2 # Quadratic formula\\n         n = int(n)-1 \\n         out = [i*2 for i in range(1,n)]\\n         return out + [finalSum - (n-1)*n]\\n```\\n",
                "solutionTags": [],
                "code": "```text\\nLet\\'s suppose s is finalSum//2, n is a count of outcome array.\\nn(n+1)/2 = s\\nn^2+n-2s = 0\\nn = (b+sqrt(b^2-4ac))/2a = (1+sqrt(1+8s))/2\\nHence, s=5 -> n=2 / s=6 -> n=3\\n```\n```py\\nclass Solution:\\n     def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n         if finalSum % 2 == 1: return [] # Early return if target is odd\\n         s = finalSum//2\\n         n = (1+math.sqrt(1+8*s))/2 # Quadratic formula\\n         n = int(n)-1 \\n         out = [i*2 for i in range(1,n)]\\n         return out + [finalSum - (n-1)*n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783397,
                "title": "c-space-o-1-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        long long lastEven = 0;\\n        if (finalSum%2) return {};\\n        while (finalSum!=0){\\n\\t\\t// start off with the lowest even number\\n            lastEven+=2;\\n            if (finalSum-lastEven <=lastEven){\\n\\t\\t\\t// if the final sum is smaller than the current even number, that means the remainder will only be the taken numbers\\n                vector<long long> result;\\n                for (int i=2; i<lastEven; i+=2){\\n                    result.push_back(i);\\n                }\\n                result.push_back(finalSum);\\n                return result;\\n            }else{\\n                finalSum-=lastEven;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        long long lastEven = 0;\\n        if (finalSum%2) return {};\\n        while (finalSum!=0){\\n\\t\\t// start off with the lowest even number\\n            lastEven+=2;\\n            if (finalSum-lastEven <=lastEven){\\n\\t\\t\\t// if the final sum is smaller than the current even number, that means the remainder will only be the taken numbers\\n                vector<long long> result;\\n                for (int i=2; i<lastEven; i+=2){\\n                    result.push_back(i);\\n                }\\n                result.push_back(finalSum);\\n                return result;\\n            }else{\\n                finalSum-=lastEven;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783357,
                "title": "cpp-iterative-soltion-solution",
                "content": "vector<long long> maximumEvenSplit(long long finalSum) {\\n\\t\\t\\t\\tif(finalSum%2)        //If odd we get sum \\n            return {};\\n\\t\\t\\t\\n        vector<long long int>a;\\n\\t\\t\\n\\t\\t\\tlong long k = 2;      // we start from 2\\n        //We will increase k unitl it becomes greater than finalsum\\n\\t\\t\\n\\t\\twhile(finalSum)\\n        {\\n            if(finalSum-k>k){\\n\\t\\t\\t\\tfinalSum -= k;\\n\\t\\t\\t\\ta.push_back(k);\\n            }else{\\n                a.push_back(finalSum);\\n                finalSum=0;\\n            }\\n            k+=2;\\n        }\\n        return a;\\n    }",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "vector<long long> maximumEvenSplit(long long finalSum) {\\n\\t\\t\\t\\tif(finalSum%2)        //If odd we get sum \\n            return {};\\n\\t\\t\\t\\n        vector<long long int>a;\\n\\t\\t\\n\\t\\t\\tlong long k = 2;      // we start from 2\\n        //We will increase k unitl it becomes greater than finalsum\\n\\t\\t\\n\\t\\twhile(finalSum)\\n        {\\n            if(finalSum-k>k){\\n\\t\\t\\t\\tfinalSum -= k;\\n\\t\\t\\t\\ta.push_back(k);\\n            }else{\\n                a.push_back(finalSum);\\n                finalSum=0;\\n            }\\n            k+=2;\\n        }\\n        return a;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2506710,
                "title": "intuition-from-a-non-mathematician",
                "content": "We need to observe a few simple truths. \\n\\n(1) It\\'s impossible to create a sum of numbers totaling an odd number, without at least one odd number in the sequence of summed numbers. You can see this by testing a few small numbers (5, 7, 13, etc.); although you can create the even numbers just 1-off from them (i.e. 13 => 12) using only even numbers, you need that one last odd number to get to 13. Therefore if we are trying to split an odd number we can quickly return empty list.\\n(2) Also observe that the sum of a sequence composed entirely of even numbers, is ultimately a large even number. \\n(3) The difference between two even numbers, is an even number.\\n\\nHow do we create the longest possible sequence of even numbers totaling an even number? Greedy: we want to keep summing the smallest even numbers possible. This would be `2`. But we can\\'t have duplicate evens; so we keep adding the smallest possible even to the sequence; `2 + 4 + 6 ...`.\\n\\nNow eventually, the sum of this sequence is going to either hit `finalSum` exactly, or surpass it. If it hits it exactly, this is the longest possible sequence of unique evens; we know this because we decided to add the smallest possible unique even at each iteration.\\n\\nIf it surpasses it, then we know the last even number we added made the sum too large. We have to remove it. We know that each intermediate sum was even, including this final one that is too big; if we remove this last number, we go back to a smaller even number which is less than `finalSum` - and it is composed of unique even numbers. We know that we can\\'t add any smaller evens than the one we removed since we\\'ve been adding them greedily as described above. So, what do we do to get our sequence of unique even numbers which sum to something less than `finalSum`, over to a sequence of unique even numbers which sum exactly to `finalSum`?\\n\\nThink about (3). When we surpassed `finalSum`, we had a large even number composed of smaller, unique even numbers. If we remove that last number, we bring our current sum to an even number smaller than `finalSum`. The difference between `finalSum` and this current sum is even - so, why not add that difference to the last even number? Then because of (2), the result is a sequence of (still even) unique numbers.\\n\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        \\n        if (finalSum % 2 != 0) return new ArrayList<Long>();\\n        \\n        List<Long> result = new ArrayList();\\n        \\n        long sum = 0;\\n        for (long i = 2; sum < finalSum; i += 2) {\\n            result.add(i);\\n            sum += i;\\n        }\\n        \\n        long difference = sum - finalSum;\\n        if (difference > 0) {\\n            long last = result.remove(result.size() - 1);\\n            sum -= last;\\n            long trueLast = result.remove(result.size() - 1);\\n            result.add(trueLast + (finalSum - sum));\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        \\n        if (finalSum % 2 != 0) return new ArrayList<Long>();\\n        \\n        List<Long> result = new ArrayList();\\n        \\n        long sum = 0;\\n        for (long i = 2; sum < finalSum; i += 2) {\\n            result.add(i);\\n            sum += i;\\n        }\\n        \\n        long difference = sum - finalSum;\\n        if (difference > 0) {\\n            long last = result.remove(result.size() - 1);\\n            sum -= last;\\n            long trueLast = result.remove(result.size() - 1);\\n            result.add(trueLast + (finalSum - sum));\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944809,
                "title": "java-greedy-approch",
                "content": "```\\nclass Solution {\\n    public static List<Long> maximumEvenSplit(long finalSum) {\\n\\t\\tif (finalSum % 2 == 1) {\\n\\t\\t\\treturn new ArrayList<>();\\n\\t\\t}\\n\\t\\tList<Long> list = new ArrayList<>();\\n\\t\\tlong sum = finalSum;\\n\\t\\tlong temp = 2;\\n\\t\\twhile (temp <= sum) {\\n\\t\\t\\tlist.add(temp);\\n\\t\\t\\tsum -= temp;\\n\\t\\t\\ttemp += 2;\\n\\t\\t}\\n\\t\\tlist.add(list.remove(list.size() - 1) + sum);\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public static List<Long> maximumEvenSplit(long finalSum) {\\n\\t\\tif (finalSum % 2 == 1) {\\n\\t\\t\\treturn new ArrayList<>();\\n\\t\\t}\\n\\t\\tList<Long> list = new ArrayList<>();\\n\\t\\tlong sum = finalSum;\\n\\t\\tlong temp = 2;\\n\\t\\twhile (temp <= sum) {\\n\\t\\t\\tlist.add(temp);\\n\\t\\t\\tsum -= temp;\\n\\t\\t\\ttemp += 2;\\n\\t\\t}\\n\\t\\tlist.add(list.remove(list.size() - 1) + sum);\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815699,
                "title": "c-simple-solution-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>v;\\n        long long n=finalSum;\\n        if(finalSum%2==1)\\n        {\\n            return v;\\n        }\\n        long long count = 2;\\n        while(count<=finalSum){\\n            v.push_back(count);\\n            finalSum-=count;\\n            count+=2;\\n        }\\n        v[v.size()-1]+=finalSum;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>v;\\n        long long n=finalSum;\\n        if(finalSum%2==1)\\n        {\\n            return v;\\n        }\\n        long long count = 2;\\n        while(count<=finalSum){\\n            v.push_back(count);\\n            finalSum-=count;\\n            count+=2;\\n        }\\n        v[v.size()-1]+=finalSum;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796966,
                "title": "c-simple-8-line-solution-o-1-easy-explanation",
                "content": "```\\nSo its clear from the question that if n is an odd answer, it is impossible to find ans .Now, to get the maximum even number, you must first take the smallest numbers, such as 2, 4, 6, 8 ... and so on.\\nSo what we are trying to do is we iterate on even numbers and Substract the finalSum by even number and if finalSum==i  we stop the loop and then we add remainig finalSum to our last element of ans vector. \\n\\nTake an Example:  finalSum=28;\\niterate on even number until our finalSum>=i\\nans= 2 4 6 8\\nfinalSum =28 -->26-->22-->16 -->8\\n1)   i==2;  ans. push (i) ;     finalsum-=i;\\n2)  i==4;  ans. push (i) ;     finalsum-=i;\\n3)   i==6;  ans. push (i) ;     finalsum-=i;\\n4)   i==8;  ans. push (i) ;     finalsum-=i;\\n\\n in 4th iteration our finalSum==i so we stop the loop\\n ans at last we add our finalSum 8 to last element of our ans.\\n \\n ans.back()=8+finalSum;\\n \\n  So ans is [2,4,6,16]\\n \\n \\n class Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2!=0 )return vector<long long>{};\\n        vector<long long> ans;\\n        for(int i = 2;i<=finalSum;i+=2){\\n            ans.push_back(i);\\n            finalSum-=i;\\n        }\\n        ans.back()+=finalSum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nSo its clear from the question that if n is an odd answer, it is impossible to find ans .Now, to get the maximum even number, you must first take the smallest numbers, such as 2, 4, 6, 8 ... and so on.\\nSo what we are trying to do is we iterate on even numbers and Substract the finalSum by even number and if finalSum==i  we stop the loop and then we add remainig finalSum to our last element of ans vector. \\n\\nTake an Example:  finalSum=28;\\niterate on even number until our finalSum>=i\\nans= 2 4 6 8\\nfinalSum =28 -->26-->22-->16 -->8\\n1)   i==2;  ans. push (i) ;     finalsum-=i;\\n2)  i==4;  ans. push (i) ;     finalsum-=i;\\n3)   i==6;  ans. push (i) ;     finalsum-=i;\\n4)   i==8;  ans. push (i) ;     finalsum-=i;\\n\\n in 4th iteration our finalSum==i so we stop the loop\\n ans at last we add our finalSum 8 to last element of our ans.\\n \\n ans.back()=8+finalSum;\\n \\n  So ans is [2,4,6,16]\\n \\n \\n class Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2!=0 )return vector<long long>{};\\n        vector<long long> ans;\\n        for(int i = 2;i<=finalSum;i+=2){\\n            ans.push_back(i);\\n            finalSum-=i;\\n        }\\n        ans.back()+=finalSum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783254,
                "title": "java-split-even-into-even-numbers",
                "content": "In-order to solve this problem, lets understand the concept first - \\n\\xA0\\nWe have to split the given number into unique even numbers, So the first thing that we should remember is :\\n\\t\\u2022\\tA number can be split into even number if it\\u2019s a even number\\n\\t\\u2022\\tOdd number cannot be split into even number\\n\\xA0\\nHere are the rules to split the number into maximum unique even numbers:\\n\\t\\u2022\\tAs we all know the first even number is 2, so if we start from the lowest to highest then we can get maximum unique even numbers\\n\\t\\u2022\\tIf we divide the number by 2 (for e.g., 28/2 =14) then only possible solution could be to get other even numbers to sum up 14(e.g., 2, 4, 8). So the unique pairs will be 2,4,8,14. In some case like for e.g 30, its not possible as 30/2 = 15\\n\\t\\u2022\\tSo its better to find the unique combination other than the /2 values.\\n\\xA0\\nNext we need to think how to programmatically get the result\\n\\t\\u2022\\tSo our rule is to start from the starting even number 2 and subtract the given number from this even number,\\n\\t\\u2022\\tIf the value is less than the given num/2 value then add to the result, subsequently increasing the even number to next (+2)\\n\\t\\u2022\\tIf the value is equal or greater than the givennum/2 then we can directly add the subtracted given number to our result.\\nNow here is the code for the same :\\n\\xA0\\n```\\npublic List<Long> maximumEvenSplit(long finalSum) {\\n\\xA0\\xA0\\xA0 List<Long> res = new ArrayList<Long>();\\nif(finalSum%2==1)\\nreturn res;\\nLong num = (long) 2;\\nwhile(finalSum>0){\\nif(num>finalSum/2)\\n\\tnum = finalSum;\\nfinalSum = finalSum - num;\\nres.add(num);\\nif(num+2<finalSum/2)\\nnum = num+2;\\nelse\\nnum = finalSum;\\n}\\nreturn res;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\n```\\nNote when value is 4 - basic even number will be = 4/2, so we have no other choice other than adding the number 4 itself to the result.\\n\\xA0\\nHappy learning :)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Long> maximumEvenSplit(long finalSum) {\\n\\xA0\\xA0\\xA0 List<Long> res = new ArrayList<Long>();\\nif(finalSum%2==1)\\nreturn res;\\nLong num = (long) 2;\\nwhile(finalSum>0){\\nif(num>finalSum/2)\\n\\tnum = finalSum;\\nfinalSum = finalSum - num;\\nres.add(num);\\nif(num+2<finalSum/2)\\nnum = num+2;\\nelse\\nnum = finalSum;\\n}\\nreturn res;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2983453,
                "title": "c-faster-than-98-clean-code-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfinalsum should be even for answer to be exist if not exist return empty vector \\nif final sum is even follow approach described below \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n2+4+6+8+.....2*k <=final sum \\nfinding number of term use \\nk*(k+1)-finalsum=0;\\nthen for k solved using quadratic root \\nnow till k-1 term pushback series of 2,4,6,8 .. and kth term will be difference of final sum and sum of the series till k-1 \\n![Screenshot - 2023-01-02T105946.469.png](https://assets.leetcode.com/users/images/78656707-606d-423e-96cd-f33502dc7001_1672637484.7398858.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalsum) {\\n         vector<long long>ret;\\n         if(finalsum%2!=0){\\n             return ret;\\n         }\\n             long long p=(-1+sqrt(4*finalsum+1))/2;\\n             long long sum=0;\\n             for(int i=1;i<p;i++){\\n                 ret.push_back(2*i);\\n                 sum+=2*i;\\n             }\\n             ret.push_back(finalsum-sum);\\n             return ret;\\n        \\n    }\\n};\\n```\\n``````\\nThank for reading !\\nPlease upvote if you liked it.\\n```````",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalsum) {\\n         vector<long long>ret;\\n         if(finalsum%2!=0){\\n             return ret;\\n         }\\n             long long p=(-1+sqrt(4*finalsum+1))/2;\\n             long long sum=0;\\n             for(int i=1;i<p;i++){\\n                 ret.push_back(2*i);\\n                 sum+=2*i;\\n             }\\n             ret.push_back(finalsum-sum);\\n             return ret;\\n        \\n    }\\n};\\n```\n``````\n``````",
                "codeTag": "Java"
            },
            {
                "id": 2636290,
                "title": "fast-greedy-solution",
                "content": "Just build the number bottom up (2 + 4 + 6 + ... ) until reaching/exceeding finalSum. \\nIf finalSum was exceeded simply remove that one extra number that\\'s making the difference ( this is possible to do because your number is even and you have all even numbers in your disposal so whatever that diffirence is, it exists in the results array and you can simply remove it).\\n\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum % 2 != 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<Long> result = new ArrayList<>();\\n        long currentNum = 0;\\n        long currentSum = 0;\\n\\n        while (currentSum < finalSum) {\\n            currentNum += 2;\\n            currentSum += currentNum;\\n            result.add(currentNum);\\n        }\\n\\n        if(currentSum != finalSum) {\\n            long diff = currentSum - finalSum;\\n            result.remove((int) (diff / 2) - 1);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum % 2 != 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        List<Long> result = new ArrayList<>();\\n        long currentNum = 0;\\n        long currentSum = 0;\\n\\n        while (currentSum < finalSum) {\\n            currentNum += 2;\\n            currentSum += currentNum;\\n            result.add(currentNum);\\n        }\\n\\n        if(currentSum != finalSum) {\\n            long diff = currentSum - finalSum;\\n            result.remove((int) (diff / 2) - 1);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329635,
                "title": "java-very-easy-solution-o-sqrt-n-with-comments",
                "content": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum%2 != 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        long sum = 0;\\n        long i = 2;\\n        \\n        List<Long> answer = new ArrayList<>();\\n        \\n        // Keep adding all the even integers starting from 2 until the sum becomes greater than finalSum\\n        while(sum <= finalSum) {\\n            if(sum + i > finalSum)\\n                break;\\n            sum = sum + i;\\n            answer.add(i);\\n            i = i+2;\\n        }\\n        \\n        if(sum == finalSum) {\\n            return answer;\\n        }\\n        \\n        /* Remove the last element and add the remaining difference to the last number and return the answer.\\n        For example: Input - 8\\n        We first add 2, then 4\\n        Now we check 2+4+6 is ater than 8. So we pop the last element and add\\n        the difference to it.\\n        We remove 4. Then add 4+2 which is 6. We then add 6 into the list to get \\n        [2,6]. */\\n        int lastElementIndex = answer.size() - 1;\\n        long lastElement = answer.get(lastElementIndex);\\n        answer.remove(lastElementIndex);\\n        answer.add(lastElement + (finalSum - sum));\\n        return answer;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum%2 != 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        long sum = 0;\\n        long i = 2;\\n        \\n        List<Long> answer = new ArrayList<>();\\n        \\n        // Keep adding all the even integers starting from 2 until the sum becomes greater than finalSum\\n        while(sum <= finalSum) {\\n            if(sum + i > finalSum)\\n                break;\\n            sum = sum + i;\\n            answer.add(i);\\n            i = i+2;\\n        }\\n        \\n        if(sum == finalSum) {\\n            return answer;\\n        }\\n        \\n        /* Remove the last element and add the remaining difference to the last number and return the answer.\\n        For example: Input - 8\\n        We first add 2, then 4\\n        Now we check 2+4+6 is ater than 8. So we pop the last element and add\\n        the difference to it.\\n        We remove 4. Then add 4+2 which is 6. We then add 6 into the list to get \\n        [2,6]. */\\n        int lastElementIndex = answer.size() - 1;\\n        long lastElement = answer.get(lastElementIndex);\\n        answer.remove(lastElementIndex);\\n        answer.add(lastElement + (finalSum - sum));\\n        return answer;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944547,
                "title": "java-binary-search-greedy-two-approaches-beats-100",
                "content": "\\nGreedy Approach\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> output = new ArrayList();\\n        if (finalSum % 2 != 0) return output;\\n        \\n        long i = 2;\\n        while (i <= finalSum) {\\n            output.add(i);\\n            finalSum -= i;\\n            i += 2;\\n        }\\n        if(finalSum != 0) output.set(output.size() - 1, output.get(output.size() - 1) + finalSum);\\n        return output;\\n    }\\n}\\n```\\n\\nBinary Search Approach\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0) return new ArrayList();\\n        \\n        int low = 0, high = (int) Math.sqrt(finalSum);\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if(sumOfFirstKEvens(finalSum, mid)) low = mid + 1;\\n            else high = mid;\\n        }\\n        \\n        List<Long> output = new ArrayList();\\n        for (int digit = 1; digit < low; digit++) {\\n            output.add((long) 2 * digit);\\n            finalSum -= 2 * digit;\\n        }\\n        output.add(finalSum);\\n        return output;\\n    }\\n    \\n    boolean sumOfFirstKEvens(long finalSum, int mid) {\\n        long reminder = finalSum - (long) mid * (mid + 1);\\n        if(reminder > 2 * mid) return true;\\n        return false;\\n    }\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> output = new ArrayList();\\n        if (finalSum % 2 != 0) return output;\\n        \\n        long i = 2;\\n        while (i <= finalSum) {\\n            output.add(i);\\n            finalSum -= i;\\n            i += 2;\\n        }\\n        if(finalSum != 0) output.set(output.size() - 1, output.get(output.size() - 1) + finalSum);\\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0) return new ArrayList();\\n        \\n        int low = 0, high = (int) Math.sqrt(finalSum);\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if(sumOfFirstKEvens(finalSum, mid)) low = mid + 1;\\n            else high = mid;\\n        }\\n        \\n        List<Long> output = new ArrayList();\\n        for (int digit = 1; digit < low; digit++) {\\n            output.add((long) 2 * digit);\\n            finalSum -= 2 * digit;\\n        }\\n        output.add(finalSum);\\n        return output;\\n    }\\n    \\n    boolean sumOfFirstKEvens(long finalSum, int mid) {\\n        long reminder = finalSum - (long) mid * (mid + 1);\\n        if(reminder > 2 * mid) return true;\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923175,
                "title": "greedy-solution-in-python-very-clearly-explained-in-details",
                "content": "Use **Greedy**!\\n\\nFirst **check whether the input is even**, if not, return directly.\\n\\nSince the problem asks us to return a split that contains a maximum number of integers, we will **try to add the smallest even interger** every time.\\n\\nThe **challenging part** is: what if after the last integer added, the sum of all is larger than the input?\\n**For example:**\\ninput is: 28\\nwe add 2, 4, 6, 8 into the list, then we find that we are not able to add 10.\\n**So what should we do?** We simply add the rest (28 - (2 + 4 + 6 + 8)), which is 8, to the last interger we already added, making it [2, 4, 6, 16].\\n\\n**Time:** O(sqrt(n))\\n\\twe will add 2 + 4 + 6 + ... + 2k = (2 + 2k) * k / 2, so that k is O(sqrt(n)). \\n**Space:** O(1), except the output\\n\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        \\n        if finalSum % 2 != 0:\\n            return []\\n        \\n        res = []\\n        num = 2\\n        \\n        while num <= finalSum:\\n            res.append(num)\\n            finalSum -= num\\n            num += 2\\n        res[-1] += finalSum\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        \\n        if finalSum % 2 != 0:\\n            return []\\n        \\n        res = []\\n        num = 2\\n        \\n        while num <= finalSum:\\n            res.append(num)\\n            finalSum -= num\\n            num += 2\\n        res[-1] += finalSum\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902617,
                "title": "python-3-simple-math-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def maximumEvenSplit(self, k: int) -> List[int]:\\n        if k%2:\\n            return []\\n\\t\\t\\t\\n        # - Calculate N\\n        N = floor(sqrt(k+0.25)-0.5)\\n\\t\\t\\n\\t\\t# - Construct number sequence\\n        seq = list(range(2,N*2+2,2))\\n\\t\\t\\n\\t\\t# - Replace the number x with 2N+2, where x = i + 2N+2 - k\\n        i = N*(N*2+2)//2\\n        if k-i > 0:\\n            seq[seq.index(i+2*N+2-k)] = 2*N+2\\n\\t\\t\\t\\n        return seq\\n```\\nIf my code is not clear to you, check the following explaination.\\n\\n* Assume there is a num *i* composed by *N* even numbers and *j* composed by *N+1* even numbers.\\n\\t*i = sum([2, 4, 6, ..., 2N])* \\n\\t *j = i + (2N + 2)*\\n* For any number *k*, *i < k < j*. \\n\\t*k = i + 2N+2 - x*, where *2 <= x <= N*\\n\\t\\u2192 *x = i + 2N + 2 - k*\\n\\nTo find *N* for *k*,\\n1. *i < k < j*, where *i = f(N) = N(2N+2)/2* (trapezoid area) and *j = f(N+1)*\\n\\t*N(2N+2)/2 < k* \\n\\t\\u2192 *N < sqrt(k+0.25)-0.5*\\n1. Since *N = f_inverse(i) < f_inverse(k) < N+1 = f_inverse(j)*,\\n*N = floor(sqrt(2k+0.25)-0.5)*",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, k: int) -> List[int]:\\n        if k%2:\\n            return []\\n\\t\\t\\t\\n        # - Calculate N\\n        N = floor(sqrt(k+0.25)-0.5)\\n\\t\\t\\n\\t\\t# - Construct number sequence\\n        seq = list(range(2,N*2+2,2))\\n\\t\\t\\n\\t\\t# - Replace the number x with 2N+2, where x = i + 2N+2 - k\\n        i = N*(N*2+2)//2\\n        if k-i > 0:\\n            seq[seq.index(i+2*N+2-k)] = 2*N+2\\n\\t\\t\\t\\n        return seq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839684,
                "title": "java-ap-maths",
                "content": "#### Thinking is pretty simple here.\\n#### \\nwe are suppose to use even numbers only.\\nso basically I\\'m calculating sum of first mid numbers using (Sum of first n numbers having 2 as common difference as well as first term (AP))\\n Sn = n/2{2a+(n-1)d)} on putting values a = 2, d= 2.\\nwe get Sn = n(n+1)\\nnow what I\\'m checking is if sum of first mid numbers is less than or equal to finalSum this means we can make the requird sum with n numbers.\\nfor returning list last numbers is taken care with adding remaining sum.\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<>();\\n        if(finalSum%2!=0){\\n            return res;\\n        }\\n        long low = 0L;\\n        long high = 100000L;\\n        long n = -1;\\n        while(low<=high){\\n            long mid = low+(high-low)/2;\\n            long sum  = mid*(mid+1);\\n            if(sum<=finalSum){\\n                n = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n                \\n            }\\n        }\\n        // System.out.println(ans);\\n        for(long i=1;i<=n;i++){\\n            finalSum-=(2*i);\\n            res.add(2*i);\\n        }\\n        if(finalSum>0 && res.size()>0){\\n            long last = res.remove(res.size()-1);\\n            res.add(last+finalSum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<>();\\n        if(finalSum%2!=0){\\n            return res;\\n        }\\n        long low = 0L;\\n        long high = 100000L;\\n        long n = -1;\\n        while(low<=high){\\n            long mid = low+(high-low)/2;\\n            long sum  = mid*(mid+1);\\n            if(sum<=finalSum){\\n                n = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n                \\n            }\\n        }\\n        // System.out.println(ans);\\n        for(long i=1;i<=n;i++){\\n            finalSum-=(2*i);\\n            res.add(2*i);\\n        }\\n        if(finalSum>0 && res.size()>0){\\n            long last = res.remove(res.size()-1);\\n            res.add(last+finalSum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785403,
                "title": "python-greedy-math-o-1-time",
                "content": "The longest array takes the form of `[2,4,6,...,2x-2,2x+leftover]` and `0 <= leftover < 2x+2`.\\nA quick prove is we cannot make this array longer. \\nWe cannot split any existing element as the smallest of resulting elements is smaller than `2x` and must collide with one of the  elements as the array contains all the even integers that is smaller than `2x`.\\nAnother choise is to add one of the elements `ai` to `2x+leftover` and then split it into `3` integers, which is not possible either as `ai+2x+leftover < 2x-2+2x+2x+2 < 6x`. We cannot split into `3` unique integers that are all larger than `2x-2`.\\n\\nThen we just use math to find out that `x` in `O(1)` time. As `[2,4,6,...,2x-2,2x]` is an arithmetic sequence whose sum is `x(x+1)`. `finalSum >= x(x+1)` or `x^2+x-finalSum <= 0`, with quadratic formula, gives us `x <= (sqrt(4finalSum+1)-1)/2`. We want to get the largest `x` so `x = int(((4*finalSum+1)**0.5-1)/2)`. Then we just add the `leftover` to the last element `2x`.\\n```\\ndef maximumEvenSplit(s):\\n\\tif s & 1:\\n\\t\\treturn []\\n\\tx = int(((4*s+1)**0.5-1)/2)\\n\\tleftover = s-x*(x+1)\\n\\treturn list(range(2,2*x,2)) + [2*x+leftover]\\n```\\nWell I don\\'t count the time of building the resulting array.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef maximumEvenSplit(s):\\n\\tif s & 1:\\n\\t\\treturn []\\n\\tx = int(((4*s+1)**0.5-1)/2)\\n\\tleftover = s-x*(x+1)\\n\\treturn list(range(2,2*x,2)) + [2*x+leftover]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1783955,
                "title": "simple-and-easy-solution-c",
                "content": "\\n* If finalSum is odd return empty array\\n* We are supposed to decrease minimum possible number from the finalSum i.e -2 then -4 , - 6, - 8 ....\\n\\t* Till noToBeSubtracted is less than or equal to finalSum\\n\\t* noToBeSubtracted should not be already present (for this we are using hashmap)\\n\\t* for eg finalSum=10\\n\\t\\t*  finalSum-2=8\\n\\t\\t*  finalSum-4=4 in this case there would be two 4s which is wrong \\n\\t\\ti.e`finalSum-noToBeSubtracted!=noToBeSubtracted`\\n* if these conditions are not followed add the finalSum to array\\n\\n### C++\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum&1) return {};\\n        \\n        vector<long long>ans;\\n        unordered_map<long long,int>h;\\n        long long x = 2;\\n        while(finalSum>0)\\n        {\\n            if(finalSum-x>=0 &&  finalSum-x!=x && h.find(finalSum-x)==h.end())\\n            {\\n                finalSum-=x;\\n                h[x]++;\\n                ans.push_back(x);\\n                x+=2;\\n            }\\n            else\\n            {\\n                ans.push_back(finalSum);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum&1) return {};\\n        \\n        vector<long long>ans;\\n        unordered_map<long long,int>h;\\n        long long x = 2;\\n        while(finalSum>0)\\n        {\\n            if(finalSum-x>=0 &&  finalSum-x!=x && h.find(finalSum-x)==h.end())\\n            {\\n                finalSum-=x;\\n                h[x]++;\\n                ans.push_back(x);\\n                x+=2;\\n            }\\n            else\\n            {\\n                ans.push_back(finalSum);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783709,
                "title": "c-greedy-100-o-n-time-o-1-space-why-it-works",
                "content": "T : O(N)\\nS : O(1)\\nHere N is the closest multiple of 2 which we can reach until sum <= finalSum\\n```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n\\t// if odd no answer exists as even + even = even\\n\\tif(finalSum % 2 == 1) return {};\\n\\t\\n\\tvector<long long> ans; \\n\\tint i = 2;\\n\\tlong long sum = 0;\\n\\t\\n\\t// find the closest greatest sum of all elements (elements are multiple of 2)\\n\\tfor(i = 2; sum <= finalSum; i = i + 2) {\\n\\t\\tsum += i;\\n\\t\\tans.push_back(i);\\n\\t}\\n\\t\\n\\t// If the closest greater sum is greater than finalSum then the \\n\\t// difference between them is a multiple of 2\\n\\t// since our vector already has multiples of 2, we can directly remove it by finding it\\'s index\\n\\tif(sum - finalSum > 0) {\\n\\t\\tint ix = (sum - finalSum)/2 - 1;\\n\\t\\tans[ix] = *(ans.end()-1);\\n\\t\\tans.pop_back();\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n\\t// if odd no answer exists as even + even = even\\n\\tif(finalSum % 2 == 1) return {};\\n\\t\\n\\tvector<long long> ans; \\n\\tint i = 2;\\n\\tlong long sum = 0;\\n\\t\\n\\t// find the closest greatest sum of all elements (elements are multiple of 2)\\n\\tfor(i = 2; sum <= finalSum; i = i + 2) {\\n\\t\\tsum += i;\\n\\t\\tans.push_back(i);\\n\\t}\\n\\t\\n\\t// If the closest greater sum is greater than finalSum then the \\n\\t// difference between them is a multiple of 2\\n\\t// since our vector already has multiples of 2, we can directly remove it by finding it\\'s index\\n\\tif(sum - finalSum > 0) {\\n\\t\\tint ix = (sum - finalSum)/2 - 1;\\n\\t\\tans[ix] = *(ans.end()-1);\\n\\t\\tans.pop_back();\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783483,
                "title": "well-explained-for-beginners-o-n",
                "content": "## IDEA :\\nSo it\\'s clear from question that if n is odd answer is not possible (bcz we can\\'t represent a odd number as a sum of even numbers)\\n\\nNow if n is even , then we have to make the largest list of unique even number such that the sum is equal to given n.\\n\\nNow to make the largest we have to take smallest numbers first like 2,4,6,8... and so on.\\n\\nbut wait what happen if we are doing in this manner and the total sum is greater than desired , no worries , we wll do this step untill our sum is less than or equal to given number , and just add the remaining difference to last number in the list.\\n\\n**Example n =14:**\\n\\n* i = 2 , crSum = 0 , list = [] (crSum + 2 <= 14 , so push it) , crSum + i = 2 , list = [2]\\n* i = 4 , crSum = 2 , list = [2] (crSum + 4 <= 14 , so push it) , crSum + i = 6 , list = [2,4]\\n* i = 6 , crSum = 6 , list = [2,4] (crSum + 6 <= 14 , so push it) , crSum + i = 12 , list = [2,4,6]\\n* i = 8 , crSum = 12 , list = [2,4,6] (crSum + 8 > 14 , so don\\'t push it , break the loop)\\n* Now we have crSum = 12 , and we want 14 , so simply add difference (which is 14-12 = 2 ) in the last element of list\\n\\nso list = [2,4,6+(14-12)] = [2,4,8]\\n\\n### Implementation :\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maximumEvenSplit(self, f: int) -> List[int]:\\n\\n\\t\\t\\tif f%2:\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tres, i = [], 2\\n\\t\\t\\twhile i<=f:\\n\\t\\t\\t\\tres.append(i)\\n\\t\\t\\t\\tf -= i\\n\\t\\t\\t\\ti += 2\\n\\n\\t\\t\\tres[-1]+=f\\n\\t\\t\\treturn res\\n\\t \\n### **Thanks and Upvote If you like the Idea !!**\\uD83E\\uDD17",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "## IDEA :\\nSo it\\'s clear from question that if n is odd answer is not possible (bcz we can\\'t represent a odd number as a sum of even numbers)\\n\\nNow if n is even , then we have to make the largest list of unique even number such that the sum is equal to given n.\\n\\nNow to make the largest we have to take smallest numbers first like 2,4,6,8... and so on.\\n\\nbut wait what happen if we are doing in this manner and the total sum is greater than desired , no worries , we wll do this step untill our sum is less than or equal to given number , and just add the remaining difference to last number in the list.\\n\\n**Example n =14:**\\n\\n* i = 2 , crSum = 0 , list = [] (crSum + 2 <= 14 , so push it) , crSum + i = 2 , list = [2]\\n* i = 4 , crSum = 2 , list = [2] (crSum + 4 <= 14 , so push it) , crSum + i = 6 , list = [2,4]\\n* i = 6 , crSum = 6 , list = [2,4] (crSum + 6 <= 14 , so push it) , crSum + i = 12 , list = [2,4,6]\\n* i = 8 , crSum = 12 , list = [2,4,6] (crSum + 8 > 14 , so don\\'t push it , break the loop)\\n* Now we have crSum = 12 , and we want 14 , so simply add difference (which is 14-12 = 2 ) in the last element of list\\n\\nso list = [2,4,6+(14-12)] = [2,4,8]\\n\\n### Implementation :\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maximumEvenSplit(self, f: int) -> List[int]:\\n\\n\\t\\t\\tif f%2:\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tres, i = [], 2\\n\\t\\t\\twhile i<=f:\\n\\t\\t\\t\\tres.append(i)\\n\\t\\t\\t\\tf -= i\\n\\t\\t\\t\\ti += 2\\n\\n\\t\\t\\tres[-1]+=f\\n\\t\\t\\treturn res\\n\\t \\n### **Thanks and Upvote If you like the Idea !!**\\uD83E\\uDD17",
                "codeTag": "Java"
            },
            {
                "id": 1783325,
                "title": "c-soluton",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long num) \\n    {\\n        if(num%2==1)\\n        {\\n            return {};\\n        }\\n        vector<long long>ans;\\n        long long sum=0;\\n        for(int i=1;;i++)\\n        {\\n            if(sum+i*2<=num)\\n            {\\n                ans.push_back(i*2);\\n                sum+=i*2;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        ans.back()+=(num-sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long num) \\n    {\\n        if(num%2==1)\\n        {\\n            return {};\\n        }\\n        vector<long long>ans;\\n        long long sum=0;\\n        for(int i=1;;i++)\\n        {\\n            if(sum+i*2<=num)\\n            {\\n                ans.push_back(i*2);\\n                sum+=i*2;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        ans.back()+=(num-sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783260,
                "title": "c-java-simple-solution-with-explanation",
                "content": "If number is odd then such sequence is not possible.\\nIf number is even, an `ideal sequence` which we try to make is 2,4,6,8...\\nBut we cant always make such sequence.\\n\\nFor Example:\\nfinalSum = 28\\n[2,4,6,8]\\nNow at this moment, we left with 8 [28-(2+4+6+8)], According to our ideal sequence we have to add 10, but ofcourse\\nwe can\\'t add 10, So we will increment our numbers from ans array till we exhaust our leftover number(8 in this example)\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    #define ll long long\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        vector<ll> ans;\\n        if(finalSum%2 != 0) return ans;\\n        \\n        ll  num = 2;\\n        while(num <= finalSum){\\n            ans.push_back(num);\\n            finalSum -= num;\\n            \\n            num += 2;\\n        }\\n        \\n        int i = ans.size()-1;\\n        \\n        while(i >= 0 && finalSum > 0){\\n            ans[i] += 2; \\n            finalSum -= 2;\\n            i--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        \\n        if(finalSum%2 != 0) return new ArrayList<>();\\n        \\n        long num = 2;\\n        List<Long> ans = new ArrayList<>();\\n        while(num <= finalSum){\\n            ans.add(num);\\n            finalSum -= num;\\n            \\n            num += 2;\\n        }\\n        \\n        int i = ans.size()-1;\\n        \\n        while(i >= 0 && finalSum > 0){\\n            ans.set(i,ans.get(i)+2);\\n            finalSum -= 2;\\n            i--;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    #define ll long long\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        vector<ll> ans;\\n        if(finalSum%2 != 0) return ans;\\n        \\n        ll  num = 2;\\n        while(num <= finalSum){\\n            ans.push_back(num);\\n            finalSum -= num;\\n            \\n            num += 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3218266,
                "title": "time-o-n-90-beats-space-o-1-99-beats-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long n) {\\n        if(n&1)return {};\\n        long long int x = 2,sum=0;\\n        vector<long long int> ans;\\n        while(sum+x<=n){\\n            sum += x;\\n            ans.push_back(x);\\n            x += 2;\\n        }\\n        ans.back()+=(n-sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long n) {\\n        if(n&1)return {};\\n        long long int x = 2,sum=0;\\n        vector<long long int> ans;\\n        while(sum+x<=n){\\n            sum += x;\\n            ans.push_back(x);\\n            x += 2;\\n        }\\n        ans.back()+=(n-sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439256,
                "title": "python3-easy-math-with-arithmetic-sequence",
                "content": "To obtain the maximum split, it makes sense to adopt the greedy algorithm: **always pick the current least possible even integer first such that we finally obtain a longest split**. If the remaining target sum becomes smaller than the current least possible even integer, we simply go one step back, and add to the end of the previous remaining sum. Here are a few examples:\\n\\n\\t2 => [2]\\n\\t4 => [2], then adding 4 would not work, as 2 + 4 > 4. So we move one step back, remove 2, and directly add 4 - 0 = 4 to the result. 4 => [4]\\n\\t\\nLooking at more complicated examples:\\n\\n\\t36 => starting with an empty list []\\n\\tstep 1: adding 2 to the result, we have [2], with a remaining sum of 34\\n\\tstep 2: adding 4 to the result, we have [2, 4], with a remaining sum of 30\\n\\tstep 3: adding 6 to the result, we have [2, 4, 6], with a remaining sum of 24\\n\\tstep 4: adding 8 to the result, we have [2, 4, 6, 8], with a remaining sum of 16\\n\\tstep 5: adding 10 to the result, we have [2, 4, 6, 8, 10], with a remaining sum of 6\\n\\tstep 6: We cannot add 12, because the remaining sum is 6. In this case, we move one step backward, with the result [2,4,6,8], and append the remaining sum of 16. Thus we will have the final result [2,4,6,8,16]. \\n\\t\\nOf course, [2,4,6,10,14] would also be a solution to the previous example. But **no other solution would be longer than the one we obtain from greedy algorithm. As we have tried out best to use those smallest possible even numbers.**\\n\\t\\nThen we spotted the result is simply an** Arithmetic Sequence** with a common difference of 2, plus the ending remaining sum. We know that from middle school math:\\n\\t\\n\\t2 + 4 + 6 + ... + 2*(n - 1) = n * (n - 1)\\n\\t\\nTherefore, we simply want to find such an **n**, so that we can summarize our result as such an Arithmetic Sequence with the final remaining sum to the end. Taking a **square root of the finalSum** would be the quickest way to find such **n**, rather than iterating from 1. Then, calculating **n** would take roughly *O(1)* time (correct me if I am wrong about this), and formulating the result takes *O(sqrt(targetSum))* time. So the solution could be optimized in the following way:\\n\\n\\n\\timport math\\n\\tclass Solution:\\n\\n\\t\\tdef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\t\\t\\tif finalSum % 2 == 1:\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\ti = math.floor(math.sqrt(finalSum))\\n\\n\\t\\t\\tif i * (i + 1) > finalSum:\\n\\t\\t\\t\\ti -= 1\\n\\n\\t\\t\\treturn [2 * j for j in range(1, i)] + [finalSum - (i * (i - 1))]",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "To obtain the maximum split, it makes sense to adopt the greedy algorithm: **always pick the current least possible even integer first such that we finally obtain a longest split**. If the remaining target sum becomes smaller than the current least possible even integer, we simply go one step back, and add to the end of the previous remaining sum. Here are a few examples:\\n\\n\\t2 => [2]\\n\\t4 => [2], then adding 4 would not work, as 2 + 4 > 4. So we move one step back, remove 2, and directly add 4 - 0 = 4 to the result. 4 => [4]\\n\\t\\nLooking at more complicated examples:\\n\\n\\t36 => starting with an empty list []\\n\\tstep 1: adding 2 to the result, we have [2], with a remaining sum of 34\\n\\tstep 2: adding 4 to the result, we have [2, 4], with a remaining sum of 30\\n\\tstep 3: adding 6 to the result, we have [2, 4, 6], with a remaining sum of 24\\n\\tstep 4: adding 8 to the result, we have [2, 4, 6, 8], with a remaining sum of 16\\n\\tstep 5: adding 10 to the result, we have [2, 4, 6, 8, 10], with a remaining sum of 6\\n\\tstep 6: We cannot add 12, because the remaining sum is 6. In this case, we move one step backward, with the result [2,4,6,8], and append the remaining sum of 16. Thus we will have the final result [2,4,6,8,16]. \\n\\t\\nOf course, [2,4,6,10,14] would also be a solution to the previous example. But **no other solution would be longer than the one we obtain from greedy algorithm. As we have tried out best to use those smallest possible even numbers.**\\n\\t\\nThen we spotted the result is simply an** Arithmetic Sequence** with a common difference of 2, plus the ending remaining sum. We know that from middle school math:\\n\\t\\n\\t2 + 4 + 6 + ... + 2*(n - 1) = n * (n - 1)\\n\\t\\nTherefore, we simply want to find such an **n**, so that we can summarize our result as such an Arithmetic Sequence with the final remaining sum to the end. Taking a **square root of the finalSum** would be the quickest way to find such **n**, rather than iterating from 1. Then, calculating **n** would take roughly *O(1)* time (correct me if I am wrong about this), and formulating the result takes *O(sqrt(targetSum))* time. So the solution could be optimized in the following way:\\n\\n\\n\\timport math\\n\\tclass Solution:\\n\\n\\t\\tdef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\t\\t\\tif finalSum % 2 == 1:\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\ti = math.floor(math.sqrt(finalSum))\\n\\n\\t\\t\\tif i * (i + 1) > finalSum:\\n\\t\\t\\t\\ti -= 1\\n\\n\\t\\t\\treturn [2 * j for j in range(1, i)] + [finalSum - (i * (i - 1))]",
                "codeTag": "Java"
            },
            {
                "id": 2284895,
                "title": "65-tc-and-83-sc-easy-python-solution",
                "content": "```\\ndef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\tif(finalSum % 2):\\n\\t\\treturn []\\n\\tans = 0\\n\\ti = 2\\n\\ts = c = 0\\n\\tans = []\\n\\twhile(s != finalSum and i <= finalSum):\\n\\t\\tif(i < (finalSum-s)//2 or i == finalSum-s):\\n\\t\\t\\tc += 1\\n\\t\\t\\tans.append(i)\\n\\t\\t\\ts += i\\n\\t\\ti += 2\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\ndef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\tif(finalSum % 2):\\n\\t\\treturn []\\n\\tans = 0\\n\\ti = 2\\n\\ts = c = 0\\n\\tans = []\\n\\twhile(s != finalSum and i <= finalSum):\\n\\t\\tif(i < (finalSum-s)//2 or i == finalSum-s):\\n\\t\\t\\tc += 1\\n\\t\\t\\tans.append(i)\\n\\t\\t\\ts += i\\n\\t\\ti += 2\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2185143,
                "title": "java-simple-greedy-solution",
                "content": "```\\npublic List<Long> maximumEvenSplit(long finalSum) {\\n        ArrayList<Long> result = new ArrayList<>();\\n        if(finalSum%2!=0) return result;\\n        long curSum = finalSum;\\n        long evenNo = 2;\\n        while(curSum-evenNo>evenNo){\\n            result.add(evenNo);\\n            curSum-=evenNo;\\n            evenNo+=2;\\n        }\\n        result.add(curSum);\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Long> maximumEvenSplit(long finalSum) {\\n        ArrayList<Long> result = new ArrayList<>();\\n        if(finalSum%2!=0) return result;\\n        long curSum = finalSum;\\n        long evenNo = 2;\\n        while(curSum-evenNo>evenNo){\\n            result.add(evenNo);\\n            curSum-=evenNo;\\n            evenNo+=2;\\n        }\\n        result.add(curSum);\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079849,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> maxEvenArray = new ArrayList<>();\\n        if(finalSum % 2 != 0)\\n            return maxEvenArray;\\n        long count = 2;\\n        while (finalSum > 0) {\\n            maxEvenArray.add(count);\\n            finalSum -= count;\\n            if(finalSum == 0) return maxEvenArray;\\n            if(finalSum < 0) maxEvenArray.remove(-finalSum);\\n            count += 2;\\n        }\\n        return maxEvenArray;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> maxEvenArray = new ArrayList<>();\\n        if(finalSum % 2 != 0)\\n            return maxEvenArray;\\n        long count = 2;\\n        while (finalSum > 0) {\\n            maxEvenArray.add(count);\\n            finalSum -= count;\\n            if(finalSum == 0) return maxEvenArray;\\n            if(finalSum < 0) maxEvenArray.remove(-finalSum);\\n            count += 2;\\n        }\\n        return maxEvenArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023427,
                "title": "python",
                "content": "\\n    def maximumEvenSplit(self, finalSum):\\n        if finalSum % 2 == 1:\\n            return []\\n        \\n        i, res = 2, set()\\n        \\n        while finalSum > 0:\\n            res.add(i)\\n            finalSum -= i\\n            i += 2\\n            \\n        if finalSum < 0:\\n            res.remove(-finalSum)\\n            \\n        return res\\n",
                "solutionTags": [],
                "code": "\\n    def maximumEvenSplit(self, finalSum):\\n        if finalSum % 2 == 1:\\n            return []\\n        \\n        i, res = 2, set()\\n        \\n        while finalSum > 0:\\n            res.add(i)\\n            finalSum -= i\\n            i += 2\\n            \\n        if finalSum < 0:\\n            res.remove(-finalSum)\\n            \\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2002974,
                "title": "java-16ms-o-1-space",
                "content": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<>();\\n        if (finalSum % 2 == 1) {\\n            return res;\\n        }\\n        long f = finalSum;\\n        long i = 2;\\n        while (i < f - i) {\\n            res.add(i);\\n            f -= i;\\n            i += 2;\\n        }\\n        res.add(f);\\n        return res;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<>();\\n        if (finalSum % 2 == 1) {\\n            return res;\\n        }\\n        long f = finalSum;\\n        long i = 2;\\n        while (i < f - i) {\\n            res.add(i);\\n            f -= i;\\n            i += 2;\\n        }\\n        res.add(f);\\n        return res;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854966,
                "title": "apl-1-line-solution-dyalog-apl",
                "content": "Here\\'s my solution in Dyalog\\'s implementation of APL.\\n```c++\\nmaximumEvenSplit \\u2190 {(\\u22A2,\\u2375-(+/\\u22A2))2\\xD7\\u2373\\u230A2\\xF7\\u2368\\xAF3+0.5*\\u23684\\xD7\\u2375+1} \\n```\\nIt\\'s my first time using APL so I\\'m sure there are better ways to write it. Regardless, here\\'s what it does.\\n\\nInstead of looping over even integers until the sum reaches the target number, we can calculate how many integers there will be. \\nWe can find the nth partial sum of a sequence containing positive even digits with the formula `n(n-1)`. \\nFor a given target integer \\u2375, we get the equation `n\\xB2-n-\\u2375 = 0`. Solving this with the quadratic formula leaves us with `n = (1\\xB1\\u221A(1+4\\u2375))/2`.\\n\\nWhen rounded down to the nearest integer, `n` is the number of consecutive even numbers starting from 2 that it takes to reach the target value (`n\\xB2-n \\u2265 \\u2375` and `\\u2375 \\u2265 (n-1)\\xB2-(n-1)`).\\n\\nAs we don\\'t want the sum to be greater than the target but equal to it, we subtract n by 2 (we take the last 2 numbers away from the sequence) and add the difference of the new sum and target value (`\\u2375`) back onto the list.\\nAnd that\\'s it!\\n\\n*Note that this function won\\'t throw an exception for odd numbers.*\\n\\n![image](https://assets.leetcode.com/users/images/c8f0cf16-c3f9-4c99-9f1a-8f13a6ae11aa_1647435985.3598652.png)\\n",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "```c++\\nmaximumEvenSplit \\u2190 {(\\u22A2,\\u2375-(+/\\u22A2))2\\xD7\\u2373\\u230A2\\xF7\\u2368\\xAF3+0.5*\\u23684\\xD7\\u2375+1} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826632,
                "title": "python-binary-search-with-detailed-explanation",
                "content": "To achieve the goal, i.e., longest, we need to use even number as small as possible.\\n\\nDefine `f(upper)=sum([2,4,6,8,...,upper)]`. We can try different `upper` until `f(upper) >= target`. What to do next?\\n\\nIf `f(upper) == target`, then we can return `[2,4,6,8,...,upper]`. Done. What if `f(upper) > target`?\\n\\nThe key observation here is that `diff = f(upper) - target` is an even number, and it must exist in `[2,4,6,8,...,upper]`! We just need to delete it.\\n\\n        28: 2+4+6+8+10 = 30 -> 30 - 28 = 2 -> [4,6,8,10]\\n        12: 2+4+6 = 12 -> 12-12=0 -> [2,4,6]\\n        14: 2+4+6+8=20 -> 20-14 = 6 -> [2,4,8]\\n\\nInstead of increasing by 1 in searching for the `upper bound`, we can use open end binary search and then general binary search.\\n\\n```Python\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\n        if finalSum % 2 == 1:\\n            return []\\n        \\n        def f(n):\\n            \\'\\'\\'\\n            calculate the sum of [2, 4, 6, ..., n]\\n            \\'\\'\\'\\n            return (2 + n) * (n // 2) // 2\\n        \\n        bound = 2\\n        while f(bound) < finalSum:\\n            bound *= 2\\n            \\n        if f(bound) == finalSum:\\n            return [num for num in range(2, bound + 1, 2)]\\n        \\n        upper = bound\\n        low = 2\\n        while low < upper:\\n            mid = low + (upper - low) // 2\\n            if mid % 2 == 1:\\n                mid -= 1\\n            if f(mid) < finalSum:\\n                low = mid + 2\\n            else:\\n                upper = mid\\n                \\n        total = f(low)\\n        if total == finalSum:\\n            return [num for num in range(2, low + 1, 2)]\\n        diff = total - finalSum\\n        return [num for num in range(2, low + 1, 2) if num != diff]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```Python\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\n        if finalSum % 2 == 1:\\n            return []\\n        \\n        def f(n):\\n            \\'\\'\\'\\n            calculate the sum of [2, 4, 6, ..., n]\\n            \\'\\'\\'\\n            return (2 + n) * (n // 2) // 2\\n        \\n        bound = 2\\n        while f(bound) < finalSum:\\n            bound *= 2\\n            \\n        if f(bound) == finalSum:\\n            return [num for num in range(2, bound + 1, 2)]\\n        \\n        upper = bound\\n        low = 2\\n        while low < upper:\\n            mid = low + (upper - low) // 2\\n            if mid % 2 == 1:\\n                mid -= 1\\n            if f(mid) < finalSum:\\n                low = mid + 2\\n            else:\\n                upper = mid\\n                \\n        total = f(low)\\n        if total == finalSum:\\n            return [num for num in range(2, low + 1, 2)]\\n        diff = total - finalSum\\n        return [num for num in range(2, low + 1, 2) if num != diff]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800070,
                "title": "c-simple-code-to-understand",
                "content": "```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        vector < long long > v;\\n        if(finalSum %2==1){    \\n            return v;\\n        }\\n        \\n        long a= 2;\\n        long long x = finalSum;\\n        \\n        while(x>0){\\n           if(x-a > a || x-a==0){\\n               v.push_back(a);\\n               x = x-a;\\n           }   \\n               a+=2;\\n        }\\n        return v;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        vector < long long > v;\\n        if(finalSum %2==1){    \\n            return v;\\n        }\\n        \\n        long a= 2;\\n        long long x = finalSum;\\n        \\n        while(x>0){\\n           if(x-a > a || x-a==0){\\n               v.push_back(a);\\n               x = x-a;\\n           }   \\n               a+=2;\\n        }\\n        return v;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1800015,
                "title": "javascript-easy-solution-explain",
                "content": "1. Loop from i = 2 to maxium number \\n2. In each loop subtract `finalSum` with `i` to get next final number if next `finalSum` greater or equal `i` push total` (i + finalSum)` else push `i` to the result\\n\\nExample: finalSum 28\\nLoop 1: i = 2, finalSum = 28 - 2 = 26 => res = [2]\\nLoop 2: i = 4, finalSum = 26 - 4 = 22 => res = [2, 4]\\nLoop 3: i = 6, finalSum = 22 - 6 = 16 => res = [2, 4, 6]\\nLoop 4: i = 8, finalSum = 16 - 8 = 8 (at this time `finalSum <= i` => res[2, 4, 6, 16])\\nBecause finalSum can not subtract anymore so we need to add it back in the loop 4\\n```\\n/**\\n * @param {number} finalSum\\n * @return {number[]}\\n */\\nvar maximumEvenSplit = function(finalSum) {\\n    if(finalSum % 2) return [];\\n    let i = 2;\\n    const res = [];\\n    \\n    while(true){\\n        finalSum = finalSum - i;\\n        \\n        if(finalSum <= i) {\\n            res.push(i + finalSum)\\n            break;\\n        }\\n        res.push(i)\\n        i+=2;\\n    }    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} finalSum\\n * @return {number[]}\\n */\\nvar maximumEvenSplit = function(finalSum) {\\n    if(finalSum % 2) return [];\\n    let i = 2;\\n    const res = [];\\n    \\n    while(true){\\n        finalSum = finalSum - i;\\n        \\n        if(finalSum <= i) {\\n            res.push(i + finalSum)\\n            break;\\n        }\\n        res.push(i)\\n        i+=2;\\n    }    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796667,
                "title": "easiest-javascript-solution",
                "content": "Steps\\n1. Add all even no one by one in a while loop and add those no in an \"evenNoArr\" array.\\n2. When \"even no sum\" is greater then or equal to \"finalSum\" break the loop \\n3. Subtract \"finalSum\" from \"even no sum\" (evenNoSum - finalSum)\\n4. Remove the the resulting number from the \"evenNoArr\".\\n5. Resulting array is your answer.\\n\\n```\\nvar maximumEvenSplit = function (finalSum) {\\n    let i=0,a=2,result=[],x=0;\\n    if(finalSum%2!==0) return [];\\n    while(i<finalSum){\\n        i+=a;\\n        result.push(a);\\n        a=a+2;\\n    }\\n    x=i-finalSum;\\n    if(x>0) return result.filter(m=>m!==x);\\n    return result;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar maximumEvenSplit = function (finalSum) {\\n    let i=0,a=2,result=[],x=0;\\n    if(finalSum%2!==0) return [];\\n    while(i<finalSum){\\n        i+=a;\\n        result.push(a);\\n        a=a+2;\\n    }\\n    x=i-finalSum;\\n    if(x>0) return result.filter(m=>m!==x);\\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796308,
                "title": "using-series-of-even-number-c-detailed-explanation-maths",
                "content": "[**@Iemprashant**](https://leetcode.com/iemprashant/) \\uD83D\\uDE80\\n[2178. Maximum Split of Positive Even Integers](https://leetcode.com/problems/maximum-split-of-positive-even-integers/)\\n```\\n1. C++ Code. \\uD83C\\uDF93\\n2. Please Upvote if it helps\\u2B06\\uFE0F\\n3. Detailed Approach \\u2705\\n4. Github Repository for code:->\\n\\n```\\n\\u26A1[ GithubRepo](https://github.com/iemprashant/LeetHub)\\n \\n**Observation** \\uD83D\\uDCCD\\n```\\nIdea-0:-> SUM OF EVEN CAN NEVER BE ODD=> FINAL SUM-> ODD => return EMPTY\\nIdea-1=> As per question (Split it into a sum of a maximum number of unique positive even integers.)-> this give the idea to take sum from the start of the even integer series.\\nIdea-2=> To have maximum number, so as sum reach the final sum, we should have skipped the least no of even number.\\nIdea-3=> So, sum of starting N even integers = N*(N+1)\\nIdea-4=>if we get to the sum of even numbers just more than the finalsum , we can remove the (finalsum)-sumofseries) number from the series.\\nExplantion=>\\n final sum=28.\\n so we take the sum of starting 5 even number= 2+4+6+8+10=>30 \\n now if we remove (30-28)= 2 from the series then we have our ans=[4,6,8,10]\\n```\\n**Approach** \\uD83D\\uDEA9 \\n1:-> To reach to the sum of n intgers just more than the finalnumber.\\n as we want final sum < n*(n+1).\\n we would take n=sqrt(final sum) , and increase n till while (n*(n+1)<finalsum)\\n2:> Now calculate the number which need to be remove from the series of n even integers =(n*(n+1)-finalsum)\\n3:-> Now, push the series of first n even integer into the vector  except the left number (n*(n+1)-finalsum).\\n**CODE** \\uD83D\\uDCCB\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum &1) return {};\\n        long long n=sqrt(finalSum);\\n        while(n*(n+1)<finalSum){\\n            n++;\\n        }\\n        vector<long long>ans;\\n        long long left=n*(n+1)-finalSum;\\n        for(long long i=2;i<=2*n;i+=2){\\n            if(i!=left){\\n               ans.push_back(i); \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n1. C++ Code. \\uD83C\\uDF93\\n2. Please Upvote if it helps\\u2B06\\uFE0F\\n3. Detailed Approach \\u2705\\n4. Github Repository for code:->\\n\\n```\n```\\nIdea-0:-> SUM OF EVEN CAN NEVER BE ODD=> FINAL SUM-> ODD => return EMPTY\\nIdea-1=> As per question (Split it into a sum of a maximum number of unique positive even integers.)-> this give the idea to take sum from the start of the even integer series.\\nIdea-2=> To have maximum number, so as sum reach the final sum, we should have skipped the least no of even number.\\nIdea-3=> So, sum of starting N even integers = N*(N+1)\\nIdea-4=>if we get to the sum of even numbers just more than the finalsum , we can remove the (finalsum)-sumofseries) number from the series.\\nExplantion=>\\n final sum=28.\\n so we take the sum of starting 5 even number= 2+4+6+8+10=>30 \\n now if we remove (30-28)= 2 from the series then we have our ans=[4,6,8,10]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum &1) return {};\\n        long long n=sqrt(finalSum);\\n        while(n*(n+1)<finalSum){\\n            n++;\\n        }\\n        vector<long long>ans;\\n        long long left=n*(n+1)-finalSum;\\n        for(long long i=2;i<=2*n;i+=2){\\n            if(i!=left){\\n               ans.push_back(i); \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796294,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic List<Long> maximumEvenSplit(long finalSum) {\\n        Set<Long> res = new HashSet<>();\\n        \\n        if(finalSum % 2 == 0){\\n            for(Long i = 2L; finalSum > 0; finalSum -= i, i += 2)\\n                res.add(i);\\n\\n            res.remove(Math.abs(finalSum));\\n        }\\n        \\n        return res.stream().collect(Collectors.toList());\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    \\n\\tpublic List<Long> maximumEvenSplit(long finalSum) {\\n        Set<Long> res = new HashSet<>();\\n        \\n        if(finalSum % 2 == 0){\\n            for(Long i = 2L; finalSum > 0; finalSum -= i, i += 2)\\n                res.add(i);\\n\\n            res.remove(Math.abs(finalSum));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1783630,
                "title": "c-simple-approach-easy-understanding",
                "content": "- Put the numbers as 2,4,6,8,10,....\\n- If `finalSum < insertedNumber` then break the loop and add finalSum to the last element of vector\\n\\n```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2 != 0){\\n            return {};\\n        }\\n        vector<long long> vec;\\n        long long i = 2;\\n        while(finalSum >= i){\\n            vec.push_back(i);\\n            finalSum -= i;\\n            i+=2;\\n        }\\n        vec[vec.size() - 1] += finalSum;\\n        return vec;\\n    }\\n```\\n**Please Upvote if you like the solution.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2 != 0){\\n            return {};\\n        }\\n        vector<long long> vec;\\n        long long i = 2;\\n        while(finalSum >= i){\\n            vec.push_back(i);\\n            finalSum -= i;\\n            i+=2;\\n        }\\n        vec[vec.size() - 1] += finalSum;\\n        return vec;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783605,
                "title": "easiest-solution-best-approach-simplest-solution",
                "content": "```\\n//Please upvote,if u like it :)\\nvector<long long> maximumEvenSplit(long long num) {\\n        vector<long long> ans;\\n        if(num & 1) return ans;\\n        int i = 2;\\n        while(num >= i){\\n            num -= i;\\n            ans.push_back(i);\\n            i+=2;\\n        }\\n        if(!num) return ans;\\n        long long last = ans.back();\\n        ans.pop_back();\\n        ans.push_back(last+num);\\n        return ans;\\n    }\\n//Please upvote,if u like it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n//Please upvote,if u like it :)\\nvector<long long> maximumEvenSplit(long long num) {\\n        vector<long long> ans;\\n        if(num & 1) return ans;\\n        int i = 2;\\n        while(num >= i){\\n            num -= i;\\n            ans.push_back(i);\\n            i+=2;\\n        }\\n        if(!num) return ans;\\n        long long last = ans.back();\\n        ans.pop_back();\\n        ans.push_back(last+num);\\n        return ans;\\n    }\\n//Please upvote,if u like it :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783507,
                "title": "java-thought-process-with-comments-28ms-116-5mb-2178-maximumevensplit",
                "content": "**Observation**:\\nIf the given number is odd, we can straight away return empty list. Reason: We cannot form an odd number by adding just even numbers (even+even=even).\\n\\nSo, let\\'s consider even numbers now.\\n\\n```\\nNumber -> Splits\\n```\\n```\\n2 -> 2\\n4 -> 4\\n```\\n```\\n6 -> 2 4\\n8 -> 2 6\\n10 -> 2 8\\n```\\n```\\n12 -> 2 4 6\\n14 -> 2 4 8\\n16 -> 2 4 10\\n18 -> 2 4 12\\n```\\n```\\n20 -> 2 4 6 8\\n22 -> 2 4 6 10\\n24 -> 2 4 6 12\\n26 -> 2 4 6 14\\n28 -> 2 4 6 16\\n```\\n```\\n30 -> 2 4 6 8 10\\n.\\n.\\n```\\n\\nHere, we can observe a pattern.\\n```\\nFirst 2 numbers - 1 split\\nNext 3 numbers - 2 split\\nNext 4 numbers - 3 split\\nNext 5 numbers - 4 split\\n.\\n.\\n```\\nConsider the 1st number in each section `2,6,12,20,30,...`\\nwhich gives this pattern **`1*1+1`, `2*2+2`, `3*3+3`, `4*4+4`, ..., `n*n+n`**\\n\\nFor a given number, let\\'s first find the number of maximum splits it will form, by using this information.\\nOnce we find that, we can form the pattern by `2,4,6,8,....(given number - sum so far).`\\n\\n\\n**Solution**:\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum%2 == 1) return new ArrayList(); // If given number is not divisble by 2, return empty list\\n        long count = findCountOfSplits(finalSum);    // Find the number of splits based on the observation mentioned\\n        List<Long> ans = new ArrayList();            // Answer list\\n        long sum = 0;                                // To store the sum of values added to the answer so far\\n        for (long i=1; i<count;i++) {                // Except for the last number, keep iterating\\n            ans.add(i*2);                            // Add values to \"ans\" starting from 2,4,6,8,... etc. (Except for last number)\\n            sum += i*2;                              // Sum of values added to answer so far\\n        }\\n        ans.add(finalSum-sum);                       // Last number\\n        return ans;                                  // Return the list\\n    }\\n    \\n    private long findCountOfSplits(long num) {     // To find the number of splits\\n        for (long i=1;i<=num;i++) {                // No. of iterations doesn\\'t reach \"num\", it will end way sooner\\n            long temp = i*i + i;\\n            if (temp == num) return i;             // If we find the num, return the number of splits\\n            if (temp > num) return i-1;            // If the temp value exceeds the given num, then, return previous number\\n        }\\n        return 0;                                  // Code doesn\\'t reach this line\\n    }\\n    \\n}\\n```\\n\\nOne thing to improve from this code is that, we don\\'t have to check for the count of splits.\\nCode and explanation for this is available in below [comment](https://leetcode.com/problems/maximum-split-of-positive-even-integers/discuss/1783507/Java-oror-Thought-Process-oror-With-comments-oror-28ms-oror-116.5MB-oror-2178.-maximumEvenSplit/1274636). (Realized this only after checking other posts. So, adding it as a comment, instead of editing this post)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nNumber -> Splits\\n```\n```\\n2 -> 2\\n4 -> 4\\n```\n```\\n6 -> 2 4\\n8 -> 2 6\\n10 -> 2 8\\n```\n```\\n12 -> 2 4 6\\n14 -> 2 4 8\\n16 -> 2 4 10\\n18 -> 2 4 12\\n```\n```\\n20 -> 2 4 6 8\\n22 -> 2 4 6 10\\n24 -> 2 4 6 12\\n26 -> 2 4 6 14\\n28 -> 2 4 6 16\\n```\n```\\n30 -> 2 4 6 8 10\\n.\\n.\\n```\n```\\nFirst 2 numbers - 1 split\\nNext 3 numbers - 2 split\\nNext 4 numbers - 3 split\\nNext 5 numbers - 4 split\\n.\\n.\\n```\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum%2 == 1) return new ArrayList(); // If given number is not divisble by 2, return empty list\\n        long count = findCountOfSplits(finalSum);    // Find the number of splits based on the observation mentioned\\n        List<Long> ans = new ArrayList();            // Answer list\\n        long sum = 0;                                // To store the sum of values added to the answer so far\\n        for (long i=1; i<count;i++) {                // Except for the last number, keep iterating\\n            ans.add(i*2);                            // Add values to \"ans\" starting from 2,4,6,8,... etc. (Except for last number)\\n            sum += i*2;                              // Sum of values added to answer so far\\n        }\\n        ans.add(finalSum-sum);                       // Last number\\n        return ans;                                  // Return the list\\n    }\\n    \\n    private long findCountOfSplits(long num) {     // To find the number of splits\\n        for (long i=1;i<=num;i++) {                // No. of iterations doesn\\'t reach \"num\", it will end way sooner\\n            long temp = i*i + i;\\n            if (temp == num) return i;             // If we find the num, return the number of splits\\n            if (temp > num) return i-1;            // If the temp value exceeds the given num, then, return previous number\\n        }\\n        return 0;                                  // Code doesn\\'t reach this line\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783488,
                "title": "c-o-maxnumbers-time-o-1-space",
                "content": "**Intuition:**\\n1. Result is an empty vector if finalSum is odd\\n2. Greedily add every even number starting from 2 in each iteration until the remaining sum required is greater than 2*currentnum, then add the remaining number and return\\n\\t\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum % 2)\\n            return vector<long long>();\\n        \\n        vector<long long> res;\\n        long long rem = finalSum;\\n        \\n        for(int i=2; rem > 2*i; i=i+2) {\\n            rem = rem - i;\\n            res.push_back(i);  \\n        }\\n        res.push_back(rem);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum % 2)\\n            return vector<long long>();\\n        \\n        vector<long long> res;\\n        long long rem = finalSum;\\n        \\n        for(int i=2; rem > 2*i; i=i+2) {\\n            rem = rem - i;\\n            res.push_back(i);  \\n        }\\n        res.push_back(rem);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783437,
                "title": "just-brute-force",
                "content": "```\\n#define ll long long\\nvector<long long> maximumEvenSplit(long long f) {\\n        vector<ll> v;\\n        if(f&1) return v;\\n        ll st = 2;\\n        while(1){\\n            if(f-st <= st) break;\\n            v.push_back(st);\\n            f -= st;\\n            st+=2;\\n        }\\n        v.push_back(f);\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nvector<long long> maximumEvenSplit(long long f) {\\n        vector<ll> v;\\n        if(f&1) return v;\\n        ll st = 2;\\n        while(1){\\n            if(f-st <= st) break;\\n            v.push_back(st);\\n            f -= st;\\n            st+=2;\\n        }\\n        v.push_back(f);\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783435,
                "title": "java-backtrack-simple-since-no-one-mentioned",
                "content": "```\\nclass Solution {\\n    int maxLen = 0;\\n    List<Long> res;\\n    public List<Long> maximumEvenSplit(long n) {\\n        if (n % 2 == 1) {\\n            return new ArrayList<>();\\n        }\\n        res = new ArrayList<>();\\n        helper(n, 2, new ArrayList<>());\\n        return res;\\n    }\\n    \\n    public void helper(long n, long toUse, List<Long> cand) {\\n        if (n == 0) {\\n            if (cand.size() > maxLen) {\\n                res = new ArrayList<>(cand);\\n                maxLen = cand.size();\\n            }\\n            return;\\n        }\\n        for (long i = toUse; i <= n; i += 2) {\\n            if (n - i >= 0) {\\n                cand.add(i);\\n                helper(n - i, i + 2, cand);\\n                cand.remove(cand.size() - 1);\\n            }\\n            if (res.size() > 0) {\\n                return;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int maxLen = 0;\\n    List<Long> res;\\n    public List<Long> maximumEvenSplit(long n) {\\n        if (n % 2 == 1) {\\n            return new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1783384,
                "title": "c-easy-simulation-t-o-n-s-o-1",
                "content": "//The approach is based on sum of first n even natural numbers \\n\\nclass Solution {\\npublic:    \\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n\\t\\t// some base cases\\n        if(finalSum%2==1) return {};\\n        if(finalSum==2) return {2};\\n        if(finalSum==4) return {4};\\n\\t\\t\\n\\t\\t\\n        vector<long long> ans;\\n        long long int sum=0, c=0;\\n\\t\\t\\n\\t\\t//Calculate the number which is just greater or equal to our finalSum\\n        while(sum<finalSum)\\n        {\\n            c+=2;\\n            sum+=c;\\n            ans.push_back(c);\\n        }\\n\\t\\t\\n        if(sum!=finalSum)\\n        {\\n            sum-=c;\\n            ans.pop_back();\\n            long long diff=finalSum-sum;\\n            while(diff<=ans[ans.size()-1]) \\n            {\\n                sum-=ans[ans.size()-1];\\n                diff+=ans[ans.size()-1];\\n                ans.pop_back();\\n                \\n            }\\n            ans.push_back(diff);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:    \\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n\\t\\t// some base cases\\n        if(finalSum%2==1) return {}",
                "codeTag": "Java"
            },
            {
                "id": 1783206,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        long long sum=2;\\n        vector<long long> ans;\\n        if(finalSum%2==1) return ans;\\n        while(finalSum!=0){\\n            if(finalSum-sum<0){\\n                ans[ans.size()-1]=ans[ans.size()-1]+finalSum;\\n                break;\\n            }\\n            finalSum-=sum;\\n            ans.push_back(sum);\\n            sum=sum+2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        long long sum=2;\\n        vector<long long> ans;\\n        if(finalSum%2==1) return ans;\\n        while(finalSum!=0){\\n            if(finalSum-sum<0){\\n                ans[ans.size()-1]=ans[ans.size()-1]+finalSum;\\n                break;\\n            }\\n            finalSum-=sum;\\n            ans.push_back(sum);\\n            sum=sum+2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783176,
                "title": "java-straightforward",
                "content": "```\\nclass Solution\\n{\\n    public List<Long> maximumEvenSplit(long finalSum)\\n    {\\n        List<Long> list = new ArrayList<>();\\n        if(finalSum % 2 != 0) // Not possible\\n            return list;\\n        long sum = 0L;\\n        for(long i = 2; i <= finalSum; i+=2) // Even only\\n        {\\n            if(sum == finalSum)\\n                break;\\n            while(list.size() > 0 && sum+i> finalSum) // Removing the most recently added\\n            {\\n                sum -= list.get(list.size()-1); \\n                list.remove(list.size()-1);\\n            }\\n            sum += i;\\n            list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public List<Long> maximumEvenSplit(long finalSum)\\n    {\\n        List<Long> list = new ArrayList<>();\\n        if(finalSum % 2 != 0) // Not possible\\n            return list;\\n        long sum = 0L;\\n        for(long i = 2; i <= finalSum; i+=2) // Even only\\n        {\\n            if(sum == finalSum)\\n                break;\\n            while(list.size() > 0 && sum+i> finalSum) // Removing the most recently added\\n            {\\n                sum -= list.get(list.size()-1); \\n                list.remove(list.size()-1);\\n            }\\n            sum += i;\\n            list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342474,
                "title": "backtracking-greedy-c",
                "content": "# Approach - 1\\n### **Backtracking**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int ind, long long target, vector<long long>&ds, vector<long long>&ans){\\n        if(target == 0){\\n            if(ds.size() > ans.size()) ans = ds;\\n            return;\\n        }\\n\\n        for(int i=ind;i<=target;i+=2){\\n            ds.push_back(i);\\n            solve(i+2, target-i, ds, ans);\\n            ds.pop_back();\\n            if(ans.size() > 0) break;\\n        }\\n    }\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>ans;\\n        if(finalSum % 2 != 0) return ans;\\n        vector<long long>ds;\\n        solve(2, finalSum, ds, ans);\\n        return ans;\\n    }\\n};\\n```\\n# Approach - 2\\n### **Greedy**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>ans;\\n        if(finalSum % 2 != 0) return ans;\\n        long long i = 2;\\n        while(i <= finalSum){\\n            ans.push_back(i);\\n            finalSum -= i;\\n            i += 2;\\n        }\\n        ans.back() = ans.back() + finalSum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int ind, long long target, vector<long long>&ds, vector<long long>&ans){\\n        if(target == 0){\\n            if(ds.size() > ans.size()) ans = ds;\\n            return;\\n        }\\n\\n        for(int i=ind;i<=target;i+=2){\\n            ds.push_back(i);\\n            solve(i+2, target-i, ds, ans);\\n            ds.pop_back();\\n            if(ans.size() > 0) break;\\n        }\\n    }\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>ans;\\n        if(finalSum % 2 != 0) return ans;\\n        vector<long long>ds;\\n        solve(2, finalSum, ds, ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>ans;\\n        if(finalSum % 2 != 0) return ans;\\n        long long i = 2;\\n        while(i <= finalSum){\\n            ans.push_back(i);\\n            finalSum -= i;\\n            i += 2;\\n        }\\n        ans.back() = ans.back() + finalSum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265552,
                "title": "faster-0-n-time-complexity-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo it\\'s clear from question that if n is odd answer is not possible (bcz we can\\'t represent a odd number as a sum of even numbers)\\n\\nNow if n is even , then we have to make the largest list of unique even number such that the sum is equal to given n.\\n\\nNow to make the largest we have to take smallest numbers first like 2,4,6,8... and so on.\\n\\nbut wait what happen if we are doing in this manner and the total sum is greater than desired , no worries , we wll do this step untill our sum is less than or equal to given number , and just add the remaining difference to last number in the list.\\n\\nTake n =14\\n\\ni = 2 , currentsum = 0 , list = [] (currentsum + 2 <= 14 , so push it) , currentsum + i = 2 , list = [2]\\ni = 4 , currentsum = 2 , list = [2] (currentsum + 4 <= 14 , so push it) , currentsum + i = 6 , list = [2,4]\\ni = 6 , currentsum = 6 , list = [2,4] (currentsum + 6 <= 14 , so push it) , currentsum + i = 12 , list = [2,4,6]\\ni = 8 , currentsum = 12 , list = [2,4,6] (currentsum + 8 > 14 , so don\\'t push it , break the loop)\\nNow we have currentsum = 12 , and we want 14 , so simply add difference (which is 14-12 = 2 ) in the last element of list\\n\\nso list = [2,4,6+(14-12)] = [2,4,8]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if( finalSum % 2 != 0 ) return {};\\n        \\n        vector<long long> ans ; \\n         long i = 2; \\n         long currentsum = 0 ; \\n        \\n        while( (currentsum + i ) <= finalSum){\\n            ans.push_back(i);\\n             currentsum += i ; \\n            i += 2; \\n          }\\n        \\n        long lastans = ans.size();\\n        ans[lastans-1] += finalSum - currentsum ; \\n        return ans ; \\n    }\\n};\\n\\n\\n`feel free to ask :)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if( finalSum % 2 != 0 ) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2900343,
                "title": "math-proof-fast-simple-c-solution",
                "content": "# Math proof\\nThe first this we need to prove is, there is always a solution with the maximum possible number of terms of the form:\\n\\n$$ 2 + 4 + ... + 2k + m = \\\\text{finalSum}$$ where $$m > 2k$$.\\n\\nTo show this, suppose we have any solution with the maximum possible number of terms. For example:\\n\\n$$ 2 + 6 + 8 + 12 = 28 $$\\n\\nTake the lowest term which can still be reduced, and reduce it by 2, while also increasing the largest term by 2, and keep doing this until it is in the desired form:\\n\\n$$ 2 + 4 + 8 + 14 = 28 $$\\n$$ 2 + 4 + 6 + 16 = 28 $$\\n\\nCall this algorithm **Procedure 1**.\\n\\nNext, note that there exists a unique $$k$$ such that:\\n\\n$$ \\\\text{finalSum} - \\\\sum_{i=1}^k 2i > 2k$$ but\\n\\n$$ \\\\text{finalSum} - \\\\sum_{i=1}^{k+1} 2i \\\\leq 2(k+1)$$.\\n\\nLet $$m = \\\\text{finalSum} - \\\\sum_{i=1}^k 2i$$. This gives the solution:\\n\\n$$2 + 4 + ... + 2k + m = \\\\text{finalSum}$$\\n\\nSuppose that there were a solution using more terms. In that case, using Procedure 1, we could reduce that solution to:\\n\\n$$2 + 4 + ... + 2k + 2(k+1) + m\\' = \\\\text{finalSum}$$\\n\\nwhere $$m\\'$$ is the sum of all terms above $$2(k+1)$$. But then, from the above inequalities, $$m\\' \\\\leq 2(k+1)$$, so it\\'s not in the form yielded by Procedure 1 where $$m\\' > 2(k+1)$$. Contradiction.\\n\\n# Approach\\nThe above proof can be converted into a simple algorithm. Just add up 2, 4, ... while also subtracting the same values from finalSum, until we reach the largest value of $$k$$ where the inequality $$ \\\\text{finalSum} - \\\\sum_{i=1}^k 2i > 2k$$ is satisfied, or equivalently:\\n\\n$$ \\\\text{finalSum} - \\\\left[\\\\left(\\\\sum_{i=1}^{k-1} 2i\\\\right)+2i\\\\right] > 2k \\\\implies \\\\text{finalSum} - \\\\sum_{i=1}^{k-1} 2i > 4k. $$\\n\\nIntuitively, before we go adding $$2k$$ to the sum, we must make sure there\\'s still room for both $$2k$$ and at least one value $$> 2k$$. If there is not, we stop and emit the running remainder, done.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if (finalSum % 2 == 1) {\\n            return vector<long long> { };\\n        }\\n\\n        vector<long long> result;\\n        long long remainder = finalSum;\\n        for (int i=1; remainder > 4*i; i++) {\\n            result.push_back(2*i);\\n            remainder -= 2*i;\\n        }\\n        result.push_back(remainder);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if (finalSum % 2 == 1) {\\n            return vector<long long> { };\\n        }\\n\\n        vector<long long> result;\\n        long long remainder = finalSum;\\n        for (int i=1; remainder > 4*i; i++) {\\n            result.push_back(2*i);\\n            remainder -= 2*i;\\n        }\\n        result.push_back(remainder);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752384,
                "title": "python3-simple-sum-of-unique-even-numbers",
                "content": "```\\n# idea is to generate array of sum of unique even numbers i.e.\\n# [2 , 2+4 , 2+4+6 , 2+4+6+8 , .... sum_greater_than_finalSum]\\n# when some goes beyond finalSum , substract the diff from final sum and this diff\\n# is the number which is not required in answer array\\n# ans: [2,4,6,8...]\\n# To avoid space of array , we can calculate sum iteratively.\\n\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum %2 :\\n            return []\\n        total = 0 \\n        num = 1\\n        while finalSum > total :\\n            total = total + num * 2\\n            num +=1\\n            \\n        diff = total - finalSum\\n        result = []\\n        for i in range(1,num):\\n            if i*2 != diff :\\n                result.append(i*2)\\n        \\n        return result\\n            \\n\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\n# idea is to generate array of sum of unique even numbers i.e.\\n# [2 , 2+4 , 2+4+6 , 2+4+6+8 , .... sum_greater_than_finalSum]\\n# when some goes beyond finalSum , substract the diff from final sum and this diff\\n# is the number which is not required in answer array\\n# ans: [2,4,6,8...]\\n# To avoid space of array , we can calculate sum iteratively.\\n\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum %2 :\\n            return []\\n        total = 0 \\n        num = 1\\n        while finalSum > total :\\n            total = total + num * 2\\n            num +=1\\n            \\n        diff = total - finalSum\\n        result = []\\n        for i in range(1,num):\\n            if i*2 != diff :\\n                result.append(i*2)\\n        \\n        return result\\n            \\n\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2715103,
                "title": "fast-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long num) {\\n        if((num%2) !=0 )\\n        return {};\\n\\n        vector<long long>ans;\\n        long long counter=2;\\n\\n        while((num-counter)>=0)\\n        {\\n            ans.push_back(counter);\\n            num=num-counter;\\n            counter=counter+2;\\n        }\\n        if(num==0)  //num has utilized fully\\n        return ans;\\n\\n        \\n         ans[ans.size()-1]=ans[ans.size()-1]+num;\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long num) {\\n        if((num%2) !=0 )\\n        return {};\\n\\n        vector<long long>ans;\\n        long long counter=2;\\n\\n        while((num-counter)>=0)\\n        {\\n            ans.push_back(counter);\\n            num=num-counter;\\n            counter=counter+2;\\n        }\\n        if(num==0)  //num has utilized fully\\n        return ans;\\n\\n        \\n         ans[ans.size()-1]=ans[ans.size()-1]+num;\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651671,
                "title": "c-hashmap-approach-explained-begginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTill we dont reach equal or greater than the finalSum, we will keep adding even integers and adding it in our map then we will check if our sum is greater than finalSum then we will check which value needs to subtracted to get finalSum, then we will remove that particular value and and push all the values in our result vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n\\n        int i = 2;\\n        long long sum = 0;\\n        unordered_map<long long,long long>mpp;\\n        vector<long long>v;\\n\\n        while(sum <= finalSum )\\n        {\\n            sum += i;\\n            mpp[i] = 1;\\n            i += 2;\\n\\n        }\\n\\n        if(sum != finalSum)\\n        { \\n       \\n            if(mpp.find(sum-finalSum)!=mpp.end())\\n            {\\n                mpp[sum-finalSum] = -1;\\n            }\\n            else return {};\\n            \\n        }\\n        \\n        for( auto it : mpp)\\n        {\\n            if(it.second>0) v.push_back(it.first);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n\\n        int i = 2;\\n        long long sum = 0;\\n        unordered_map<long long,long long>mpp;\\n        vector<long long>v;\\n\\n        while(sum <= finalSum )\\n        {\\n            sum += i;\\n            mpp[i] = 1;\\n            i += 2;\\n\\n        }\\n\\n        if(sum != finalSum)\\n        { \\n       \\n            if(mpp.find(sum-finalSum)!=mpp.end())\\n            {\\n                mpp[sum-finalSum] = -1;\\n            }\\n            else return {};\\n            \\n        }\\n        \\n        for( auto it : mpp)\\n        {\\n            if(it.second>0) v.push_back(it.first);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518738,
                "title": "python-greedy-approach",
                "content": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum & 1:\\n            return []\\n        res, num = [], 2\\n        while finalSum - num > num:\\n            res.append(num)\\n            finalSum -= num\\n            num += 2\\n        res.append(finalSum)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum & 1:\\n            return []\\n        res, num = [], 2\\n        while finalSum - num > num:\\n            res.append(num)\\n            finalSum -= num\\n            num += 2\\n        res.append(finalSum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481297,
                "title": "javascript-simple-greedy-o-sqrt-n-time-o-1-space-explanation",
                "content": "Every even number minus a different even number, result in a even number. (i.e.  `2*x - 2*y = 2 (x-y)` )\\nFrom the `finalSum` we can subtract each next even number (cNum+2) while the missing value from finalSum is greater than the current and the next.\\n\\n(the missing value represents the missing part of finalSum after subtracting each even number.\\nEx: for finalSum 28:\\n```\\nfinalSum = 28\\nMissing=26, 22, 16, \\n    Even=2,  4,  6, \\n```\\nThe next even numbers are: 8 and 10.\\nIf on next step we subtract 16-8=8 , we couldn\\'t subtract 10 from 8. So, the loop ends on: `missing >= 2*cNum + 2`\\nAnd the end we check if there is some missing value and add it: `if (missing > 0) ans.push(missing);`\\n\\nGreedy Algorithm:\\n```\\nvar maximumEvenSplit = function(finalSum) {\\n    if (finalSum % 2 === 1) return [];\\n    \\n    var missing = finalSum;\\n    var ans = [];\\n    for (var cNum = 2; missing >= 2*cNum + 2; cNum+=2) {\\n        ans.push(cNum);\\n        missing -= cNum;\\n    }\\n    \\n    if (missing > 0) ans.push(missing);\\n    return ans;\\n};\\n```\\n\\nHope it help others.\\n\\nTime complexity thanks to [@lzl124631x](http://https://leetcode.com/problems/maximum-split-of-positive-even-integers/discuss/1783586/C%2B%2B-Greedy-O(sqrt(N))-time-O(1)-space)\\nThe time complexity is given O(sqrt(N)) because the values that sum up to finalSum are: 2, 4, 6, .... 2k. ( i.e. 2 + 4+ 6 + ... +2k ~= finalSum), PA with K elements, SUM: (2 + 2k)*k /2 = finalSum.\\n\\nIf you liked it, or it helped you plz give a vote :).",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nfinalSum = 28\\nMissing=26, 22, 16, \\n    Even=2,  4,  6, \\n```\n```\\nvar maximumEvenSplit = function(finalSum) {\\n    if (finalSum % 2 === 1) return [];\\n    \\n    var missing = finalSum;\\n    var ans = [];\\n    for (var cNum = 2; missing >= 2*cNum + 2; cNum+=2) {\\n        ans.push(cNum);\\n        missing -= cNum;\\n    }\\n    \\n    if (missing > 0) ans.push(missing);\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2477101,
                "title": "beats-runtime-99-41-memory-95-49-c-greedy-math-fast-and-easy",
                "content": "![image](https://assets.leetcode.com/users/images/ec053d88-767a-4eab-86eb-c35e644214ac_1661411855.4809449.png)\\n```\\nvector<long long> maximumEvenSplit(long long n) {   //changed finalSum to n for simplicity \\n        vector<long long>v;\\n        if(n%2!=0){   //Split is not possible for odd finalSum\\n            return v;\\n        }\\n        else{\\n            long long i=2;\\n            long long sum=0;\\n            while(1){\\n                if((sum+i) > n) break;\\n                 v.push_back(i); //keep pushing the even numbers starting from 2 and incrementing it by 2\\n                 sum+=i;\\n                 i+=2;\\n            }\\n            long long dif = n - sum;\\n            if(dif > 0){\\n                long long x = v[v.size()-1];  \\n                x+=dif;\\n                v.pop_back();   //Pop out last element and push whole remaining difference needed\\n                v.push_back(x);\\n            }\\n            return v;\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/ec053d88-767a-4eab-86eb-c35e644214ac_1661411855.4809449.png)\\n```\\nvector<long long> maximumEvenSplit(long long n) {   //changed finalSum to n for simplicity \\n        vector<long long>v;\\n        if(n%2!=0){   //Split is not possible for odd finalSum\\n            return v;\\n        }\\n        else{\\n            long long i=2;\\n            long long sum=0;\\n            while(1){\\n                if((sum+i) > n) break;\\n                 v.push_back(i); //keep pushing the even numbers starting from 2 and incrementing it by 2\\n                 sum+=i;\\n                 i+=2;\\n            }\\n            long long dif = n - sum;\\n            if(dif > 0){\\n                long long x = v[v.size()-1];  \\n                x+=dif;\\n                v.pop_back();   //Pop out last element and push whole remaining difference needed\\n                v.push_back(x);\\n            }\\n            return v;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2460923,
                "title": "python3-3-lines-python-greedy-math-beats-99",
                "content": "Greedy approach works because always choosing the smallest numbers when given a choice ensures the largest number of splits.\\n\\nUse the triangular series 2 * (1+2+3...) as the basis of the solution. We only need to replace the last number of this series with a larger number to make the sum equal to finalSum.\\n\\n6 => [2, 4]\\n8 => [2, 6]\\n10 => [2, 8]\\n\\n12 => [2, 4, 6]\\n14 => [2, 4, 8]\\n16 => [2, 4, 10]\\n18 => [2, 4, 12]\\n\\n20 => [2, 4, 6, 8]\\n22 => [2, 4, 6, 10]\\n24 => [2, 4, 6, 12]\\n26 => [2, 4, 6, 14]\\n28 => [2, 4, 6, 16]\\n\\n30 => [2, 4, 6, 8, 10]\\n32 => [2, 4, 6, 8, 12]\\n...\\n\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        \\n        if finalSum % 2:\\n            return []\\n        \\n        # largest value of n for which 2 + 4 + ... + n <= finalSum\\n        # solve the quadratic equation  2 (k*(k+1)) / 2 = finalSum, where k = n/2. use the real root\\n        largest_n = 2 * int((-1 + (1 + 4*finalSum)**.5) / 2)\\n        \\n        # sum of the numbers 2 + 4 + ... + largest_n-2 + largest_n\\n        triangular_n = 2 * (largest_n/2 * (largest_n/2 + 1) / 2)\\n        \\n        # replace the last number of the triangular_n series so that the sum becomes finalSum\\n        return [i for i in range(2, largest_n, 2)] + [int(finalSum - triangular_n + largest_n)]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        \\n        if finalSum % 2:\\n            return []\\n        \\n        # largest value of n for which 2 + 4 + ... + n <= finalSum\\n        # solve the quadratic equation  2 (k*(k+1)) / 2 = finalSum, where k = n/2. use the real root\\n        largest_n = 2 * int((-1 + (1 + 4*finalSum)**.5) / 2)\\n        \\n        # sum of the numbers 2 + 4 + ... + largest_n-2 + largest_n\\n        triangular_n = 2 * (largest_n/2 * (largest_n/2 + 1) / 2)\\n        \\n        # replace the last number of the triangular_n series so that the sum becomes finalSum\\n        return [i for i in range(2, largest_n, 2)] + [int(finalSum - triangular_n + largest_n)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408939,
                "title": "java-8-lines-greedy-math",
                "content": "Following the hints, we want the numbers to grow slowly: the difference between two consecutive numbers = 2.\\nTherefore, the sum of such sequence will be,\\n- `2 * 1 + 2 * 2 + 2 * 3 + ... + 2 * n`\\n- `= 2 * (1 + 2 + 3 + ... + n)`\\n- `= 2 * (n * (n + 1) / 2)`\\n- `= n * (n + 1)`\\n\\nWith this pattern, we can find the number of numbers in this sequence/array. We want to find a `n` such that the result array has `n` numbers and their sum will be **strictly greater than** the given `finalSum`.\\n- Note that if the condition of the while loop is `n * (n + 1) < finalSum`, it will break if the `sum == finalSum`, which requires exactly n numbers. However, if `sum > finalSum`, then the array can only have `n - 1` numbers. \\n- Therefore, we will use **strictly greater than**: `n * (n + 1) <= finalSum` and then decrement `n--`;\\n\\nOnce we know how many numbers we need, we can add them one by one with step size = 2. Note the last number added will be `finalSum - sum of n - 1`;\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList();\\n        if (finalSum % 2 == 1) return res;\\n        long n = 1;\\n        while (n * (n + 1) <= finalSum) n++;\\n        n--;\\n        for (long i = 0; i < n - 1; i++) res.add(2 * (i + 1));\\n        res.add(finalSum - ((n - 1) * n));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList();\\n        if (finalSum % 2 == 1) return res;\\n        long n = 1;\\n        while (n * (n + 1) <= finalSum) n++;\\n        n--;\\n        for (long i = 0; i < n - 1; i++) res.add(2 * (i + 1));\\n        res.add(finalSum - ((n - 1) * n));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403782,
                "title": "easy-solution",
                "content": "class Solution {\\n# public:\\n    vector<long long> maximumEvenSplit(long long finalsum) {\\n        vector<long long >v;\\n        if(finalsum%2!=0){\\n            return v;\\n        }\\n        long long ans=2;\\n        long long  x;\\n         while(finalsum!=0){\\n             x=finalsum-ans;\\n             if(x!=ans && x/2<=(ans+2)){\\n                 v.push_back(ans);\\n                 if(x!=0){\\n                    v.push_back(x); \\n                 }\\n                 \\n                 break;\\n             }\\n             while(x%2!=0 ||x==ans){\\n                 ans+=2;\\n              x=finalsum-ans;\\n             }\\n             finalsum=x;\\n             v.push_back(ans);\\n             ans+=2;\\n         }\\n       return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n# public:\\n    vector<long long> maximumEvenSplit(long long finalsum) {\\n        vector<long long >v;\\n        if(finalsum%2!=0){\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2358189,
                "title": "c-dfs-clean-code",
                "content": "```\\nclass Solution {\\n    bool dfs(long long val, long long sum , vector<long long> & ans){\\n        if(sum == 0) return true;\\n        if(val > sum) return false;\\n        for(int i = val ; i <= sum ; i+=2){\\n            ans.push_back(i);\\n            // cout<<sum<<\"-\"<<i<<\" \";\\n            sum -= i;\\n            if(dfs(i+2, sum, ans)) return true;\\n            sum += i;\\n            ans.pop_back();\\n        }\\n        cout<<\",\";\\n        return false;\\n    }\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2 != 0) return{};\\n        vector<long long > ans;\\n        dfs(2,finalSum,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(long long val, long long sum , vector<long long> & ans){\\n        if(sum == 0) return true;\\n        if(val > sum) return false;\\n        for(int i = val ; i <= sum ; i+=2){\\n            ans.push_back(i);\\n            // cout<<sum<<\"-\"<<i<<\" \";\\n            sum -= i;\\n            if(dfs(i+2, sum, ans)) return true;\\n            sum += i;\\n            ans.pop_back();\\n        }\\n        cout<<\",\";\\n        return false;\\n    }\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2 != 0) return{};\\n        vector<long long > ans;\\n        dfs(2,finalSum,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2342425,
                "title": "super-simple-javascript",
                "content": "```js\\n// Time: O(n)\\n// Space: O(1)\\n\\n/**\\n * @param {number} finalSum\\n * @return {number[]}\\n */\\nvar maximumEvenSplit = function(finalSum) {\\n    if (finalSum % 2) {\\n        return [];\\n    }\\n    \\n    let remainder = finalSum;\\n    const res = [];\\n    \\n    for (let i = 2; remainder >= i; i += 2) {\\n        res.push(i);\\n        remainder -= i;\\n    }\\n    \\n    res[res.length - 1] += remainder;\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n// Time: O(n)\\n// Space: O(1)\\n\\n/**\\n * @param {number} finalSum\\n * @return {number[]}\\n */\\nvar maximumEvenSplit = function(finalSum) {\\n    if (finalSum % 2) {\\n        return [];\\n    }\\n    \\n    let remainder = finalSum;\\n    const res = [];\\n    \\n    for (let i = 2; remainder >= i; i += 2) {\\n        res.push(i);\\n        remainder -= i;\\n    }\\n    \\n    res[res.length - 1] += remainder;\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297715,
                "title": "beats-99-7-java-greedy-o-1-time-to-determine-the-solution-o-sqrt-n-total",
                "content": "---In Case of you don\\'t know the greedy idea yet---\\nFor any `finalSum`, traditionally we use greedy to insert even number from 2 until there is no room for a bigger number. For example, if `finalSum=36`, we would build the list by adding smallest even number `[2, 4, 6, 8,...]` until we are \"close\" to 36, here`2 + 4 + 6 + 8 = 20`and we need 16 to get to 36 so we cannot continue to add 10 to our list since if we added 10, the sum becomes 30 and 6 is already used. This method was justified by other solutions so I will skip the proof. \\n\\n---Problem of Greedy Method---\\nThe main part of this problem is WHEN to stop adding the increasing even numbers from 2, i.e. (in the example above, we stopped at 8). Traditionally, we keep computing the running sum by adding the numbers in current list and comparing it with how much it is still needed to get to `finalSum`, this will be time consuming when the number gets big.\\n\\n---Our Method---\\nWe use a bit of math to directly determine where to stop, below is the deduction:\\nLet `f = finalSum` and `n` be the number where we stop, so we have `f = 2 + 4 + 6 + ... + n + x`,\\nwhere `x > n` is a bigger even number\\nWe know that `2 + 4 + ... + n = n (n + 2) / 4` from the formula of arithmetic sequence, so the question becomes:\\nwe want the LARGEST `n` such that both  `x > n`, and `n (n + 2) / 4 + x = f` hold, \\nthis is equivalent to `f - n (n + 2) / 4 > n` and this is a inequality we need to solve\\nBy moving things around, this inequality is equivalent to `n^2 + 6n - 4f < 0`, and we need to find the largest possible `n` which satisfy this. \\n![image](https://assets.leetcode.com/users/images/2b16f800-9afa-43f7-92f8-ea54c1999d3a_1658117381.3178227.png)\\n\\nLuckily, `n^2 + 6n - 4f` is a parabola and we already know `f` so we treat it as a constant, so `n` should be the larger zero point of this parabola, by solving the formula `n^2 + 6n - 4f = 0`, we get\\n`n < Sqrt(4f + 9) - 3`, which is our final solution for `n`, once we know this, we can directly compute `n` in O(1) time and then build the list, which cost O(sqrt(N)) time, below is the java code, it runs lightning fast (beats 99.7%) even without optimizing the list building process (with custom list)\\n\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<>();\\n        if ((finalSum & 1) != 0) return res; // if odd, return empty\\n        long n = (long) (Math.floor(Math.sqrt(4 * finalSum + 9) - 3));\\n        if ((n & 1) != 0) n--; // get n to be the largest EVEN number\\n        long rest = finalSum - (n*(n+2)) / 4;\\n        if (n == rest) n -= 2; // since we solved the equality equation, sometimes we could have n==rest\\n        for (long i = 2; i <= n; i+=2) {\\n            res.add(i);\\n        }\\n        res.add(finalSum - (n*(n+2)) / 4);\\n        return res;\\n    }\\n}\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<>();\\n        if ((finalSum & 1) != 0) return res; // if odd, return empty\\n        long n = (long) (Math.floor(Math.sqrt(4 * finalSum + 9) - 3));\\n        if ((n & 1) != 0) n--; // get n to be the largest EVEN number\\n        long rest = finalSum - (n*(n+2)) / 4;\\n        if (n == rest) n -= 2; // since we solved the equality equation, sometimes we could have n==rest\\n        for (long i = 2; i <= n; i+=2) {\\n            res.add(i);\\n        }\\n        res.add(finalSum - (n*(n+2)) / 4);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281398,
                "title": "just-normal-iteration-on-the-array",
                "content": "The logic is start  from first even number that is num = 2, and increament everytime by 2. Why.? Beacause we need even number everytime.\\nAnd add this num to our currSum, which the current even number sum. \\nAs soon as we get the number, on which adding the currSum will go out of bound for the final sum we break out from our loop, and subtract the last added even number from the currSum and add the remaining number, that is (finalSum - currSum).\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2 == 1) return {};\\n        if(finalSum <= 4) return {finalSum};\\n        vector<long long> ans;\\n        long long num = 2;\\n        long long  currSum = 0;\\n        \\n        while(num <= finalSum/2) {\\n            if(currSum == finalSum) return ans;\\n            if(currSum + num > finalSum) break;\\n            currSum += num;\\n            ans.push_back(num);\\n            num+=2;\\n        }\\n        num-=2;\\n        currSum -= num;\\n        ans.pop_back();\\n        ans.push_back(finalSum - currSum);\\n        return ans;\\n    }\\n};\\n```\\n**TC: - O(N/2) \\nSC: - O(N/2)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2 == 1) return {};\\n        if(finalSum <= 4) return {finalSum};\\n        vector<long long> ans;\\n        long long num = 2;\\n        long long  currSum = 0;\\n        \\n        while(num <= finalSum/2) {\\n            if(currSum == finalSum) return ans;\\n            if(currSum + num > finalSum) break;\\n            currSum += num;\\n            ans.push_back(num);\\n            num+=2;\\n        }\\n        num-=2;\\n        currSum -= num;\\n        ans.pop_back();\\n        ans.push_back(finalSum - currSum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270642,
                "title": "python-greedy-approach",
                "content": "```\\n# Greedy: Try to get the maximum length split array. \\n# It starts with the smallest even integer (2) and increases \\n# by 2 until it reaches the finalSum. If the progression is equal\\n# to finalSum, then the split array is the longest solution. \\n# If it exceeds it, then we just remove the difference from the \\n# split array. Time: O(sqrt(finalSum)) - Space: O(1)\\ndef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\t# 1) Check edge case for odd inputs:\\n\\tif finalSum % 2 == 1:\\n\\t\\treturn []\\n\\n\\t# 2) Set operational vars: \\n\\teven_integers = []\\n\\tcumulative = 0\\n\\tprogression = 2\\n\\n\\t# 3) Generate Arithmetic progression:\\n\\twhile cumulative < finalSum:\\n\\t\\tcumulative += progression\\n\\t\\teven_integers.append(progression)\\n\\t\\tprogression += 2\\n\\n\\t# 4) Check if progression equals finalSum:   \\n\\tif cumulative == finalSum:\\n\\t\\treturn even_integers\\n\\n\\t# 5) Otherwise, remove the difference:\\n\\tdiff = cumulative - finalSum\\n\\teven_integers.remove(diff)\\n\\n\\treturn even_integers\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n# Greedy: Try to get the maximum length split array. \\n# It starts with the smallest even integer (2) and increases \\n# by 2 until it reaches the finalSum. If the progression is equal\\n# to finalSum, then the split array is the longest solution. \\n# If it exceeds it, then we just remove the difference from the \\n# split array. Time: O(sqrt(finalSum)) - Space: O(1)\\ndef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\t# 1) Check edge case for odd inputs:\\n\\tif finalSum % 2 == 1:\\n\\t\\treturn []\\n\\n\\t# 2) Set operational vars: \\n\\teven_integers = []\\n\\tcumulative = 0\\n\\tprogression = 2\\n\\n\\t# 3) Generate Arithmetic progression:\\n\\twhile cumulative < finalSum:\\n\\t\\tcumulative += progression\\n\\t\\teven_integers.append(progression)\\n\\t\\tprogression += 2\\n\\n\\t# 4) Check if progression equals finalSum:   \\n\\tif cumulative == finalSum:\\n\\t\\treturn even_integers\\n\\n\\t# 5) Otherwise, remove the difference:\\n\\tdiff = cumulative - finalSum\\n\\teven_integers.remove(diff)\\n\\n\\treturn even_integers\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2233688,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 == 1:\\n            return []\\n        \\n        total = 0\\n        result = []\\n        num = 2\\n        while total < finalSum:\\n            total += num\\n            result.append(num)\\n            num += 2\\n        \\n        if total == finalSum:\\n            return result\\n        \\n        diff = total - finalSum\\n        result.remove(diff)\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 == 1:\\n            return []\\n        \\n        total = 0\\n        result = []\\n        num = 2\\n        while total < finalSum:\\n            total += num\\n            result.append(num)\\n            num += 2\\n        \\n        if total == finalSum:\\n            return result\\n        \\n        diff = total - finalSum\\n        result.remove(diff)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165694,
                "title": "java-simple-mathematical-approach-beats-95-of-the-solutions",
                "content": "```\\npublic List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> ans = new ArrayList<Long>();\\n        if((finalSum&1)==1) // if finalSum is odd return empty list\\n            return ans;\\n        long x = (long)Math.sqrt(finalSum); // Count of sum of even numbers > finalSum\\n        if(x*(x+1)<finalSum)                //  as per Arithmetic progression it\\'s\\n            x = x+1;                        // x*(x+1) > finalSum\\n        long diff = x*(x+1) - finalSum;     // Calculate the difference\\n        for(long i=1;i<=x;i++){\\n            long k = 2*i;\\n            if(k!=diff){                    // don\\'t include the number equal to difference\\n                ans.add(k);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> ans = new ArrayList<Long>();\\n        if((finalSum&1)==1) // if finalSum is odd return empty list\\n            return ans;\\n        long x = (long)Math.sqrt(finalSum); // Count of sum of even numbers > finalSum\\n        if(x*(x+1)<finalSum)                //  as per Arithmetic progression it\\'s\\n            x = x+1;                        // x*(x+1) > finalSum\\n        long diff = x*(x+1) - finalSum;     // Calculate the difference\\n        for(long i=1;i<=x;i++){\\n            long k = 2*i;\\n            if(k!=diff){                    // don\\'t include the number equal to difference\\n                ans.add(k);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2080088,
                "title": "sum-of-consecutive-evens-till-remaining-is-greater",
                "content": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 == 1:\\n            return []\\n        pos = 0\\n        i = 1\\n        while i * (i + 1) <= finalSum:\\n            k = finalSum - i * (i + 1)\\n            if k % 2 == 0 and k > 2 * i:\\n                pos = i\\n            i += 1\\n        return [2 * i for i in range(1, pos + 1)] + [finalSum - pos * (pos + 1)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 == 1:\\n            return []\\n        pos = 0\\n        i = 1\\n        while i * (i + 1) <= finalSum:\\n            k = finalSum - i * (i + 1)\\n            if k % 2 == 0 and k > 2 * i:\\n                pos = i\\n            i += 1\\n        return [2 * i for i in range(1, pos + 1)] + [finalSum - pos * (pos + 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070111,
                "title": "python-elixir-i-m-afraid-we-re-going-to-have-to-use-math",
                "content": "Okay, so first off, let\\'s recognize that this problem can be solved with a greedy algorithm. Intuitively, it makes sense that if we are adding a bunch of numbers to reach a sum, and we want as many terms in the sum as possible, then each term should be as small as possible. But let\\'s prove it.\\n\\nImagine I give you that a sequence of numbers [2, 4, 6, ...k] (where k is an even number) sums to a target value T. Could you find a solution that contains more digits? No, of course not. If you added any number, you\\'d have to subtract something from an existing value, which would either create a duplicate value or take that value to be 0 or negative, which aren\\'t allowed. \\n\\nImagine instead that I give you a sequence of numbers [2, 4, 6, ...k, C] that sums to T, where k is an even number and C is some other even number where k+2 < C <= 2(k+2). Can you do any better than that? Well, you can\\'t break C into k+2 and k+4 because it isn\\'t big enough. And you can\\'t split off any value of k or less without creatine a duplicate value in the range 2, 4, ...k. So you can\\'t split C, and we\\'ve already identified that 2, 4, 6...k can\\'t be split. Therefore while you could shift the terms around a bit (like going to k+2 and C-2 as the last two terms), but you can\\'t end up with a longer list of sum terms. \\n\\nSo we could do a greedy algorithm that subtracts 2, 4, 6, ... sequentially from targetSum until we end up with either 0 (in which case we\\'re done) or we get a value which is too small to subtract from, at which point we backtrack by one. For example, with the number 16 we could greedily sum 2,4,6 to get 12, but then we\\'re left with 4 to go and a minimum append of 8, so we instead back off to be [2,4,10] as our final answer. This works.\\n\\nBut we can do better. We can identify that our final answer is going to look like either: [2, 4, 6...k] or [2, 4, 6...k, C]. Using Gauss\\' formula, we can simplify this to k(k+2)/4 + C, and we know it equals T. \\n\\nThis lets us set an upper bound on k; we know that k(k+2)/4 + C <= k(k+2)/4 <= k^2/ 4, so this means that k <= floor(sqrt(4T)) = 2*floor(sqrt(T)). Then we can evaluate c as T - k(k+2)/4, and check a few cases:\\n\\n* Case 1: We hit T exactly, and we\\'re done.\\n\\t* If our target sum is 12, our initial estimate of k is 6, which means our sum is 12, and we return [2, 4, 6].\\n* Case 2: we undershoot, and end up with a positive remainder. Since we chose the maximum possible value of k, that means our remainder c is an even number in the range 2...k and we have a duplicate. We resolve this by adding our remainder to the last term, and we\\'re done. \\n\\t* For example, our target sum is 8, we estimate k as 4. The sum of [2,4] is 6, leaving us a remainder of 2, so we reset it to be [2,6] and we\\'re done.\\n* Case 3: we overshoot, and end up with a negative remainder. In this case we need to back out by two terms; one term would still leave us in the range 2...k-2, so we need to back out twice. \\n\\t* For example, our target sum is 10, and we estimate k as 6. The sum of [2,4,6] is 12, leaving us a remainder of -2, so we need to reset to [2,10-2] = [2,8] and we\\'re done.\\n\\nOne final check: if finalSum is odd, we throw an empty list.\\n\\nPython:\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 == 1:\\n            return []\\n        \\n        k = 2*math.floor(math.sqrt(finalSum))\\n        c = finalSum -  k * (k+2) // 4\\n        \\n        if c == 0:\\n            return list(range(2, k+2, 2))\\n        elif c>0:\\n            return list(range(2, k, 2)) + [c+k]\\n        else:\\n            return list(range(2, k-2, 2)) + [c+2*k-2]\\n```\\n\\nElixir:\\n```\\ndefmodule Solution do\\n  @spec maximum_even_split(final_sum :: integer) :: [integer]\\n  def maximum_even_split(final_sum) when rem(final_sum, 2)==1, do: []\\n  def maximum_even_split(final_sum) do\\n    k = final_sum |> Kernel.**(0.5) |> Kernel.trunc |> Kernel.*(2)\\n    c = final_sum - (k*(k+2))/4\\n    cond do\\n        c == 0 -> Enum.to_list(2..k//2)\\n        c > 0 -> Enum.to_list(2..k-2//2) ++ [c+k]\\n        true -> Enum.to_list(2..k-4//2) ++ [c+2*k-2]\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Python",
                    "Elixir",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 == 1:\\n            return []\\n        \\n        k = 2*math.floor(math.sqrt(finalSum))\\n        c = finalSum -  k * (k+2) // 4\\n        \\n        if c == 0:\\n            return list(range(2, k+2, 2))\\n        elif c>0:\\n            return list(range(2, k, 2)) + [c+k]\\n        else:\\n            return list(range(2, k-2, 2)) + [c+2*k-2]\\n```\n```\\ndefmodule Solution do\\n  @spec maximum_even_split(final_sum :: integer) :: [integer]\\n  def maximum_even_split(final_sum) when rem(final_sum, 2)==1, do: []\\n  def maximum_even_split(final_sum) do\\n    k = final_sum |> Kernel.**(0.5) |> Kernel.trunc |> Kernel.*(2)\\n    c = final_sum - (k*(k+2))/4\\n    cond do\\n        c == 0 -> Enum.to_list(2..k//2)\\n        c > 0 -> Enum.to_list(2..k-2//2) ++ [c+k]\\n        true -> Enum.to_list(2..k-4//2) ++ [c+2*k-2]\\n    end\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020151,
                "title": "java-solution-using-for-loop",
                "content": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> list = new ArrayList<>();\\n        long tempf = finalSum;\\n        if(finalSum % 2 != 0){\\n            return list;\\n        }\\n       for(long i = 2; i <= tempf; i+=2){\\n                if(i < tempf-i){\\n                    list.add(i);\\n                    tempf -= i;\\n                }\\n       }\\n        list.add(tempf);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> list = new ArrayList<>();\\n        long tempf = finalSum;\\n        if(finalSum % 2 != 0){\\n            return list;\\n        }\\n       for(long i = 2; i <= tempf; i+=2){\\n                if(i < tempf-i){\\n                    list.add(i);\\n                    tempf -= i;\\n                }\\n       }\\n        list.add(tempf);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017446,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\t\\t\\tif finalSum % 2 != 0: \\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tcurr = 0\\n\\t\\t\\tresult = []\\n\\t\\t\\ttotal = 0\\n\\t\\t\\t\\n\\t\\t\\twhile total + curr < finalSum:\\n\\t\\t\\t\\tcurr += 2\\n\\t\\t\\t\\tif total + curr <= finalSum:\\n\\t\\t\\t\\t\\tresult.append(curr)\\n\\t\\t\\t\\t\\ttotal += curr\\n\\t\\t\\t\\n\\t\\t\\tresult[-1] += finalSum - total\\n\\t\\t\\treturn result",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\t\\t\\tif finalSum % 2 != 0: \\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tcurr = 0\\n\\t\\t\\tresult = []\\n\\t\\t\\ttotal = 0\\n\\t\\t\\t\\n\\t\\t\\twhile total + curr < finalSum:\\n\\t\\t\\t\\tcurr += 2\\n\\t\\t\\t\\tif total + curr <= finalSum:\\n\\t\\t\\t\\t\\tresult.append(curr)\\n\\t\\t\\t\\t\\ttotal += curr\\n\\t\\t\\t\\n\\t\\t\\tresult[-1] += finalSum - total\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 2005084,
                "title": "c-math",
                "content": "We use arithmetic series: 2, 4, 6 ... Added until exceed finalSum.\\ntake 3rd test case as an example: \\n2 + 4 + 6 + 8 + 10 = 30, exceed 28. We drop the final 10, and add reminding part 28 - (2 + 4 + 6 + 8) = 8 to the last number,\\nhere we get [2, 4, 6, 16].\\n\\nReasoning: as every step, we pick the smallest possible number. Thus, pick any number outside out result cannot produce a better solution.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long> res;\\n        if (finalSum & 1) {\\n            return res;\\n        }\\n        long long _sqrt = sqrt(finalSum);\\n        long long i = _sqrt + 1;\\n        for (; i >= 2; --i) {\\n            if (i * (i + 1) <= finalSum) {\\n                break;\\n            }\\n        }\\n        long long rem = finalSum - i * (i + 1);\\n        res.push_back(2 * i + rem);\\n        for (long long j = i - 1; j >= 1; --j) {\\n            res.push_back(j * 2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long> res;\\n        if (finalSum & 1) {\\n            return res;\\n        }\\n        long long _sqrt = sqrt(finalSum);\\n        long long i = _sqrt + 1;\\n        for (; i >= 2; --i) {\\n            if (i * (i + 1) <= finalSum) {\\n                break;\\n            }\\n        }\\n        long long rem = finalSum - i * (i + 1);\\n        res.push_back(2 * i + rem);\\n        for (long long j = i - 1; j >= 1; --j) {\\n            res.push_back(j * 2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985129,
                "title": "simple-java-solution-time-o-n",
                "content": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<>();\\n        long sum = 0;\\n        \\n        if (finalSum % 2 != 0) return res; \\n        \\n\\t\\t// add as many distinct small even number as possible, starts from 2\\n        long curr = 2;\\n        while (sum < finalSum) {\\n            sum += curr;\\n            res.add(curr);\\n            curr += 2;\\n        }\\n        \\n\\t\\t// now current sum can only be equal to or larger than finalSum\\n        long diff = finalSum - sum;\\n        if (diff == 0) {\\n\\t\\t\\t// if same, then it\\'s the most optimal solution\\n            return res;\\n        } else {\\n\\t\\t\\t// if lager than finalSum, remove last two elements in the list,\\n\\t\\t\\t// here we cannot put two distinct two even number, \\n\\t\\t\\t// the difference between current Sum and finalSum is the number of last element\\n            sum -= res.get(res.size() - 1);\\n            res.remove(res.size() - 1);\\n            sum -= res.get(res.size() - 1);\\n            res.remove(res.size() - 1);\\n            diff = finalSum - sum;\\n            res.add(diff);\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> res = new ArrayList<>();\\n        long sum = 0;\\n        \\n        if (finalSum % 2 != 0) return res; \\n        \\n\\t\\t// add as many distinct small even number as possible, starts from 2\\n        long curr = 2;\\n        while (sum < finalSum) {\\n            sum += curr;\\n            res.add(curr);\\n            curr += 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1934288,
                "title": "python-3-simple-greedy-solution",
                "content": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2:\\n            return []\\n        res = []\\n        n = 2\\n        while finalSum >= 2*n + 2:\\n            res.append(n)\\n            finalSum -= n\\n            n += 2\\n            \\n        res.append(finalSum)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2:\\n            return []\\n        res = []\\n        n = 2\\n        while finalSum >= 2*n + 2:\\n            res.append(n)\\n            finalSum -= n\\n            n += 2\\n            \\n        res.append(finalSum)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1919737,
                "title": "98-09-python-solution-with-explanation",
                "content": "It\\'s a math + binary search problem.\\n\\nAll we have to do is to find the maximum m which meets the following two conditions.\\n1) 2*(1 + 2 + 3 + ... + m) + k = finalSum\\n2) 2*m < k\\n\\nAfter finding the maximum m, we just have to return [2x1, 2x2, ... , 2xm, k].\\nThe reason for \\'2 * m < k\\' is that if k <= 2 * m, it means that k can be made up with number which is already in the list. (2*smallerNumber = k <= 2 * m)\\n\\nFor example, if finalSum is 50, 2*(1+2+3+4)+30 and 2*(1+2+3+4+5) + 20 can meet the two conditions,\\nwhile 2*(1+2+3+4+5+6) + 8 cannot. (because 8 < 2 * 6)\\n\\nAnd we use binary search for finding the maximum m to reduce time complexity.\\nIf we meet two conditions above (eg. 2*(1+2+3+4)+30, 2*(1+2+3+4+5) + 20),  we increment the value of m,\\nwhereas if not we decrease the value of m to find the m that meets the conditions.\\n\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        #Cannot make odd number only with even numbers \\n        if finalSum % 2 == 1 or finalSum < 2:\\n            return []\\n        \\n        def calculate(m):\\n            k = finalSum - m*(m+1)\\n            if m * 2 < k:\\n                return True\\n            return False\\n        s, e, optimalM = 1, int(math.sqrt(finalSum)), 0\\n        \\n        #Use binary search to find optimal m\\n        while s <= e:\\n            mid = (s + e) // 2\\n            if calculate(mid):\\n                optimalM = mid\\n                s = mid + 1\\n            else:\\n                e = mid - 1\\n                \\n        #if finalSum cannot be made up with two or more numbers, only return finalSum itself\\n        if optimalM == 0:\\n            return [finalSum]\\n        answer = [2*i for i in range(1, optimalM + 1)] + [finalSum - optimalM * (optimalM + 1)]\\n        return answer\\n    \\n    \\n```\\n",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        #Cannot make odd number only with even numbers \\n        if finalSum % 2 == 1 or finalSum < 2:\\n            return []\\n        \\n        def calculate(m):\\n            k = finalSum - m*(m+1)\\n            if m * 2 < k:\\n                return True\\n            return False\\n        s, e, optimalM = 1, int(math.sqrt(finalSum)), 0\\n        \\n        #Use binary search to find optimal m\\n        while s <= e:\\n            mid = (s + e) // 2\\n            if calculate(mid):\\n                optimalM = mid\\n                s = mid + 1\\n            else:\\n                e = mid - 1\\n                \\n        #if finalSum cannot be made up with two or more numbers, only return finalSum itself\\n        if optimalM == 0:\\n            return [finalSum]\\n        answer = [2*i for i in range(1, optimalM + 1)] + [finalSum - optimalM * (optimalM + 1)]\\n        return answer\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842112,
                "title": "easy-scala-solution",
                "content": "```\\ndef maximumEvenSplit(finalSum: Long): List[Long] =\\n  if(finalSum % 2 == 0) go(2, finalSum, List.empty)\\n  else List.empty\\n\\ndef go(currNum: Long, remSum: Long, acc: List[Long]): List[Long] =\\n  if(remSum < currNum) acc.head + remSum :: acc.tail\\n  else go(currNum + 2, remSum - currNum, currNum :: acc)\\n```",
                "solutionTags": [
                    "Scala",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\ndef maximumEvenSplit(finalSum: Long): List[Long] =\\n  if(finalSum % 2 == 0) go(2, finalSum, List.empty)\\n  else List.empty\\n\\ndef go(currNum: Long, remSum: Long, acc: List[Long]): List[Long] =\\n  if(remSum < currNum) acc.head + remSum :: acc.tail\\n  else go(currNum + 2, remSum - currNum, currNum :: acc)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1821868,
                "title": "simple-binary-search",
                "content": "When the **finalSum** is odd there is no way to get a non-empty result. When **finalSum** is even there will always exist a non-empty answer. For eg: if finalSum is 2n the the answer can be {2n} since its a list with 1 even integer.\\n\\n**Since we want list of max length so it makes sense to include as many small integers as possible.**\\n\\nConsider the sum: \\nS=2+4+6+...+2n = n*(n+1) so now we want to find the smallest n such that **S>=finalSum**\\n\\nSo we can **BinarySearch** the value for **n**. The difference **S-finalSum** will always be even number (since both numbers are even) and the difference will be less than **2n** (trivial). \\n\\n**So the above line tells us that from the list of [2,4,6,....,2n] we can remove the even integer corresponding to diff and return the remaining list as answer as the new modified list will be the largest possible**\\n\\n```\\n#define ll long long int\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\npublic:\\n    Solution(){\\n        IOS;\\n    }\\n    \\n    vector<ll> maximumEvenSplit(ll s) {\\n        if(s&1)\\n            return {};\\n        \\n        ll l=0,ans=1e6,r=1e6;\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            ll cnt=m*(m+1);\\n            if(cnt<s)\\n                l=m+1;\\n            else{\\n                ans=min(ans,m);\\n                r=m-1;\\n            }\\n        }\\n        \\n        ll diff=(ans*(ans+1))-s;\\n        vector<ll> f;\\n        for(ll i=1;i<=ans;i++){\\n            if(diff!=(i<<1))\\n                f.push_back(i<<1);\\n        }\\n        \\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long int\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\npublic:\\n    Solution(){\\n        IOS;\\n    }\\n    \\n    vector<ll> maximumEvenSplit(ll s) {\\n        if(s&1)\\n            return {};\\n        \\n        ll l=0,ans=1e6,r=1e6;\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            ll cnt=m*(m+1);\\n            if(cnt<s)\\n                l=m+1;\\n            else{\\n                ans=min(ans,m);\\n                r=m-1;\\n            }\\n        }\\n        \\n        ll diff=(ans*(ans+1))-s;\\n        vector<ll> f;\\n        for(ll i=1;i<=ans;i++){\\n            if(diff!=(i<<1))\\n                f.push_back(i<<1);\\n        }\\n        \\n        return f;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1814930,
                "title": "python-3-math-and-summations-o-maxsplit-beats-95",
                "content": "If the target is odd, then return 0.\\nFind the number of even integers whose sum is less than or equal to the target.\\nNow, add the difference between target and the sum to the largest even integer in the sum to get the maximum split.\\n\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum%2 != 0:\\n            return []\\n    \\n        total = 0\\n        i=2\\n        answer = []\\n        while total+i <= finalSum:\\n            total += i\\n            answer.append(i)\\n            i += 2\\n        \\n        answer[-1] += finalSum-total\\n        return answer\\n```\\nTime Complexity: O(maximum split) = O(logn)\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum%2 != 0:\\n            return []\\n    \\n        total = 0\\n        i=2\\n        answer = []\\n        while total+i <= finalSum:\\n            total += i\\n            answer.append(i)\\n            i += 2\\n        \\n        answer[-1] += finalSum-total\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799298,
                "title": "just-did-as-per-the-hints-given-java-runtime-19-ms-faster-than-72-21",
                "content": "### *Runtime: 19 ms, faster than 72.21% of Java online submissions for Maximum Split of Positive Even Integers.*****\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> dp = new ArrayList<Long>();\\n        \\n        if(finalSum % 2 != 0)\\n            return dp;\\n        \\n        // Let k be the number of elements in our split. As we want the maximum number of elements, we should try to use the first k - 1 even elements to grow our sum as slowly as possible.\\n         long n = (long)Math.sqrt(finalSum);\\n        \\n        while(n*(n + 1) < finalSum){\\n            n++;\\n        }\\n        \\n        long left = n*(n + 1) - finalSum; // the number which we need to skip when the sumOfSeries comes to be greater than the finalSum!\\n        for(long i = 2; i <= 2*n; i+=2){\\n            if(i != left){\\n                dp.add(i);\\n            }\\n        }\\n        \\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> dp = new ArrayList<Long>();\\n        \\n        if(finalSum % 2 != 0)\\n            return dp;\\n        \\n        // Let k be the number of elements in our split. As we want the maximum number of elements, we should try to use the first k - 1 even elements to grow our sum as slowly as possible.\\n         long n = (long)Math.sqrt(finalSum);\\n        \\n        while(n*(n + 1) < finalSum){\\n            n++;\\n        }\\n        \\n        long left = n*(n + 1) - finalSum; // the number which we need to skip when the sumOfSeries comes to be greater than the finalSum!\\n        for(long i = 2; i <= 2*n; i+=2){\\n            if(i != left){\\n                dp.add(i);\\n            }\\n        }\\n        \\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788790,
                "title": "c-concise-greedy",
                "content": "```\\n\\tpublic IList<long> MaximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0)\\n            return new List<long>();\\n        \\n        var result = new List<long>();\\n        var val = 2;\\n        while (finalSum > 2*val) {\\n            result.Add(val);\\n            finalSum -= val;\\n            val +=2;\\n        }\\n        result.Add(finalSum);\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic IList<long> MaximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0)\\n            return new List<long>();\\n        \\n        var result = new List<long>();\\n        var val = 2;\\n        while (finalSum > 2*val) {\\n            result.Add(val);\\n            finalSum -= val;\\n            val +=2;\\n        }\\n        result.Add(finalSum);\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788419,
                "title": "c-easy-to-understand-constructive-alogorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long> ans;\\n        if(finalSum%2!=0)\\n        return ans;\\n        long long i=2;\\n        while(i<=finalSum)\\n        {\\n            ans.push_back(i);\\n            finalSum-=i;\\n            i+=2;\\n        }\\n        int n=ans.size();\\n        ans[n-1]+=finalSum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long> ans;\\n        if(finalSum%2!=0)\\n        return ans;\\n        long long i=2;\\n        while(i<=finalSum)\\n        {\\n            ans.push_back(i);\\n            finalSum-=i;\\n            i+=2;\\n        }\\n        int n=ans.size();\\n        ans[n-1]+=finalSum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786609,
                "title": "c-easy-to-understand-o-1-space-water-than-76-92-with-explanation",
                "content": "Simply start with 2 and go every even number subtracting from finalSum till finalSum become less than the inserting value. In the end if finalSum is not 0 then add the finalSum to last element of vector to make it full sum.\\n```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2==1) return {};\\n        long long a=2;\\n        vector<long long> v;\\n        while(finalSum>=a){\\n            finalSum-=a;\\n            v.push_back(a);\\n            a+=2;\\n        }\\n        v.back()+=finalSum;\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2==1) return {};\\n        long long a=2;\\n        vector<long long> v;\\n        while(finalSum>=a){\\n            finalSum-=a;\\n            v.push_back(a);\\n            a+=2;\\n        }\\n        v.back()+=finalSum;\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786553,
                "title": "java-o-n-explained",
                "content": "**Code:**\\n\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum%2!=0) \\n            return new ArrayList<>();\\n        long x = 0, sum = 0;\\n        List res = new ArrayList();\\n        \\n        while(sum<finalSum) {\\n            x+=2; \\n            if(finalSum<sum+x)\\n                break;\\n            sum+=x;\\n            res.add(x);\\n        }\\n\\n        while(finalSum!=sum) {\\n            sum -= (long)res.get(res.size()-1); \\n            res.remove(res.size()-1);\\n            if( res.size()==0 || (long)res.get(res.size()-1) < finalSum-sum ) {\\n                res.add(finalSum-sum);\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n**Approach:**\\n\\nwe can never make an odd number with just using even values, so:\\n\\n        if(finalSum%2!=0) // if odd number\\n            return new ArrayList<>();\\n\\nnow, we need some variables to keep track of our sum, our current value that we\\'re adding (x)\\nand the list that we need to return.\\n\\t\\t\\n        long x = 0, sum = 0;\\n        List res = new ArrayList();\\n        \\n\\t\\t\\n**now, to maximize our number of integers, we should use smallest possible numbers**\\n**why/how:** if our target was 12 and repeating numbers was allowed, instead of using `6+6` or `6+4+2` or `4+4+4` we\\'d use `2+2+2+2+2+2` right? we\\'ll use the same idea here! but we won\\'t be repeating any number, we\\'ll just use the next smallest even number. ie, we\\'ll increment previously used number by two.\\n\\n**in some/most cases, we won\\'t reach our target like this. we\\'d eventually end up over our target.**\\n**example:** 28\\n2+4+6+12 = 24, if we try to add 14, the total becomes 38.\\n*we\\'ll worry about this later, and let\\'s just add the numbers till our sum is equal to or less than finalSum.*\\n\\n        while(sum<finalSum){  // keep adding \\'x\\' to list\\n            x+=2; \\n            if(finalSum<sum+x) // break if sum will become greater than required.\\n                break;\\n            sum+=x;\\n            res.add(x);\\n        }\\n\\t\\t\\ncool, now we just need to fix the issue that was mentioned before.\\nfor that **we\\'ll need to find how far off are we from our finalSum.** i.e, (finalSum - sum) and add that exact amount to our list.\\n**example:** 28 ->2+4+6+12 = 24, we\\'re 4 away from 28. BUT, we can\\'t use 4 again since we\\'ve already used it.\\nso what can we do?\\n**well, we\\'ll just keep removing the last element from our list till we find a number that we can add!**\\nso 2+4+6+12 = 24 but if we remove the last element,  2+4+6+ ??? = 28 (finalSum)\\nwe find that the number we need is 16! and we can totally add it without breaking any rules.\\n\\n[ **NOTE:** in this example, we only had to remove one item, but that might not always be the case. Infact, everytime we\\'ll remove some item, our required sum also changes. ]\\n\\n        while(finalSum!=sum){\\n            sum -= (long)res.get(res.size()-1);  //subtract last item\\'s value from sum (typecasted from Long to long)\\n            res.remove(res.size()-1);  // remove last item\\n            if( res.size()==0 || (long)res.get(res.size()-1) < finalSum-sum ) { // if list becomes empty ex: 4,  or we find our required value.\\n                res.add(finalSum-sum);\\n                break;\\n            }\\n        }\\n\\t\\t\\nfinally, we can return our list, huh,\\n\\n        return res;\\n    }\\n---\\nkinda liked this question, what do you guys think?",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum%2!=0) \\n            return new ArrayList<>();\\n        long x = 0, sum = 0;\\n        List res = new ArrayList();\\n        \\n        while(sum<finalSum) {\\n            x+=2; \\n            if(finalSum<sum+x)\\n                break;\\n            sum+=x;\\n            res.add(x);\\n        }\\n\\n        while(finalSum!=sum) {\\n            sum -= (long)res.get(res.size()-1); \\n            res.remove(res.size()-1);\\n            if( res.size()==0 || (long)res.get(res.size()-1) < finalSum-sum ) {\\n                res.add(finalSum-sum);\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n**Approach:**\\n\\nwe can never make an odd number with just using even values, so:\\n\\n        if(finalSum%2!=0) // if odd number\\n            return new ArrayList<>();\\n\\nnow, we need some variables to keep track of our sum, our current value that we\\'re adding (x)\\nand the list that we need to return.\\n\\t\\t\\n        long x = 0, sum = 0;\\n        List res = new ArrayList();\\n        \\n\\t\\t\\n**now, to maximize our number of integers, we should use smallest possible numbers**\\n**why/how:** if our target was 12 and repeating numbers was allowed, instead of using `6+6` or `6+4+2` or `4+4+4` we\\'d use `2+2+2+2+2+2` right? we\\'ll use the same idea here! but we won\\'t be repeating any number, we\\'ll just use the next smallest even number. ie, we\\'ll increment previously used number by two.\\n\\n**in some/most cases, we won\\'t reach our target like this. we\\'d eventually end up over our target.**\\n**example:** 28\\n2+4+6+12 = 24, if we try to add 14, the total becomes 38.\\n*we\\'ll worry about this later, and let\\'s just add the numbers till our sum is equal to or less than finalSum.*\\n\\n        while(sum<finalSum){  // keep adding \\'x\\' to list\\n            x+=2; \\n            if(finalSum<sum+x) // break if sum will become greater than required.\\n                break;\\n            sum+=x;\\n            res.add(x);\\n        }\\n\\t\\t\\ncool, now we just need to fix the issue that was mentioned before.\\nfor that **we\\'ll need to find how far off are we from our finalSum.** i.e, (finalSum - sum) and add that exact amount to our list.\\n**example:** 28 ->2+4+6+12 = 24, we\\'re 4 away from 28. BUT, we can\\'t use 4 again since we\\'ve already used it.\\nso what can we do?\\n**well, we\\'ll just keep removing the last element from our list till we find a number that we can add!**\\nso 2+4+6+12 = 24 but if we remove the last element,  2+4+6+ ??? = 28 (finalSum)\\nwe find that the number we need is 16! and we can totally add it without breaking any rules.\\n\\n[ **NOTE:** in this example, we only had to remove one item, but that might not always be the case. Infact, everytime we\\'ll remove some item, our required sum also changes. ]\\n\\n        while(finalSum!=sum){\\n            sum -= (long)res.get(res.size()-1);  //subtract last item\\'s value from sum (typecasted from Long to long)\\n            res.remove(res.size()-1);  // remove last item\\n            if( res.size()==0 || (long)res.get(res.size()-1) < finalSum-sum ) { // if list becomes empty ex: 4,  or we find our required value.\\n                res.add(finalSum-sum);\\n                break;\\n            }\\n        }\\n\\t\\t\\nfinally, we can return our list, huh,\\n\\n        return res;\\n    }\\n---\\nkinda liked this question, what do you guys think?",
                "codeTag": "Unknown"
            },
            {
                "id": 1786404,
                "title": "c-easy-greedy-solution-o-n",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long n) {\\n        vector<long long>v;\\n        \\n        if(n%2!=0)\\n            return {};\\n        \\n        ll start=2,sum=0;\\n        while(sum<n)\\n        {\\n            sum+=start;\\n            v.push_back(start);\\n            start+=2;\\n        }\\n        \\n        if(sum==n)\\n            return v;\\n        \\n        //remove last two and add required\\n        \\n        sum-=v[v.size()-1];\\n        v.pop_back();\\n        sum-=v[v.size()-1];\\n        v.pop_back();\\n        v.push_back(n-sum);  \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long n) {\\n        vector<long long>v;\\n        \\n        if(n%2!=0)\\n            return {};\\n        \\n        ll start=2,sum=0;\\n        while(sum<n)\\n        {\\n            sum+=start;\\n            v.push_back(start);\\n            start+=2;\\n        }\\n        \\n        if(sum==n)\\n            return v;\\n        \\n        //remove last two and add required\\n        \\n        sum-=v[v.size()-1];\\n        v.pop_back();\\n        sum-=v[v.size()-1];\\n        v.pop_back();\\n        v.push_back(n-sum);  \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786035,
                "title": "c-easy-understanding",
                "content": "```\\nvector<long long> maximumEvenSplit(long long f) {\\n        if(f & 1)\\n            return {};\\n        vector<long long> res;\\n        long long i = 2;\\n        while(i <= f){\\n            res.push_back(i);\\n            f -= i;\\n            i += 2;\\n        } \\n        if(i != 0)\\n            res.back() +=  f;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<long long> maximumEvenSplit(long long f) {\\n        if(f & 1)\\n            return {};\\n        vector<long long> res;\\n        long long i = 2;\\n        while(i <= f){\\n            res.push_back(i);\\n            f -= i;\\n            i += 2;\\n        } \\n        if(i != 0)\\n            res.back() +=  f;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785934,
                "title": "c-two-approach-backtracking-iterative",
                "content": "**First Approach**\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        if(finalSum%2!=0) return {};\\n        \\n        vector<long long> result;\\n        vector<long long> ans;\\n        \\n        helper(result,finalSum,2,ans);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    bool helper(vector<long long> &result, long long finalSum,int index,vector<long long> &ans){\\n        \\n       \\n           \\n           if(finalSum==0) {\\n               if(result.size()>ans.size()) ans=result;\\n               return true;\\n             }     \\n        \\n        for(int i=index;i<=finalSum;i+=2){\\n            if(finalSum-i>=0){\\n                 result.push_back(i);\\n                 if(helper(result,finalSum-i,i+2,ans)) return true;\\n                 result.pop_back();\\n            }\\n           \\n        }\\n          return false;\\n    }\\n  \\n};\\n```\\n\\n**Second Approach**\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        if(finalSum%2!=0) return {};\\n       \\n        vector<long long> ans;\\n        long long i=2;\\n        long long curSum=0;\\n        while(curSum+i<=finalSum){\\n          \\n            ans.push_back(i);curSum+=i;\\n            i+=2;\\n        }\\n        \\n        ans[ans.size()-1]=ans[ans.size()-1]+(finalSum-curSum);\\n\\t  return ans;\\n        \\n    }\\n    \\n    \\n};\\n```\\n\\nPlease upvote if the code helped you in anyway!\\uD83D\\uDE42\\n\\nAll the best buddy!\\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        if(finalSum%2!=0) return {};\\n        \\n        vector<long long> result;\\n        vector<long long> ans;\\n        \\n        helper(result,finalSum,2,ans);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    bool helper(vector<long long> &result, long long finalSum,int index,vector<long long> &ans){\\n        \\n       \\n           \\n           if(finalSum==0) {\\n               if(result.size()>ans.size()) ans=result;\\n               return true;\\n             }     \\n        \\n        for(int i=index;i<=finalSum;i+=2){\\n            if(finalSum-i>=0){\\n                 result.push_back(i);\\n                 if(helper(result,finalSum-i,i+2,ans)) return true;\\n                 result.pop_back();\\n            }\\n           \\n        }\\n          return false;\\n    }\\n  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        if(finalSum%2!=0) return {};\\n       \\n        vector<long long> ans;\\n        long long i=2;\\n        long long curSum=0;\\n        while(curSum+i<=finalSum){\\n          \\n            ans.push_back(i);curSum+=i;\\n            i+=2;\\n        }\\n        \\n        ans[ans.size()-1]=ans[ans.size()-1]+(finalSum-curSum);\\n\\t  return ans;\\n        \\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785695,
                "title": "backtracking",
                "content": "class Solution {\\n    private:\\n        bool solve(long long currSum,long long finalSum,vector<long long>&ds,long long index){\\n            // for valid combination of number\\n            // base case--1\\n            if(currSum==0){\\n                return true;\\n            }\\n            // for unvalid combination\\n            // base case--2\\n            if(currSum<0 or currSum<index){\\n                return false;\\n            }\\n            for(int j=index;j<finalSum;j+=2){\\n                ds.push_back(j);\\n                if(solve(currSum-j,finalSum,ds,j+2)) return true;\\n                ds.pop_back();\\n            }\\n            return false;\\n        }\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2!=0) return {};\\n        if(finalSum==2||finalSum==4) return {finalSum};\\n        vector<long long>ds;\\n        if(solve(finalSum,finalSum,ds,2)) return ds;\\n        return {};\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    private:\\n        bool solve(long long currSum,long long finalSum,vector<long long>&ds,long long index){\\n            // for valid combination of number\\n            // base case--1\\n            if(currSum==0){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1785318,
                "title": "my-tiny-brain-binary-search-solution-c",
                "content": "Algorithm \\n* By observing the question we can say if number is odd then answer doesnot exist (because sum of even numbers is always a even number try to remove the condition which is sum of even numbers =finalsum this is done by dividing the finalsum=finalsum/2\\n* now we can use any number to obtain finalsum and we multiply this result with the *2 then numbers become even.\\n* As we need maximum numbers to be used in obtaining finalsum we need take the first( consecutive numbers(like 1+2+3....+ some number which is not consecutive may or maynot be present(take like (p))\\n* we can search the maximum numbers or(last number which will be used in finalsum in O(log(n)) by Binary Search\\n taking low=1 and high=finalsum/2\\nmid=(low+high)/2\\n if finalsum-sum(1+2...mid)==0\\nthen that is best solution low=mid break\\n else if(finalsum-sum(1+2..mid)>mid\\n  then lastnumber is above the mid (low=mid+1)\\n else lastnumber is below the mid(high=mid-1)\\n\\n* atlast we need to check the some number which is not consecutive exist or not .\\n* if finalsum-sum(1+2+low)<=low and !=0.\\n* the some number is lesser than low which is not considered because that number is already been used consecutive integers so we need add remaining number to last integer (so decrease low and finalsum-sum(1+2+..low) is remaining number).\\n* And multiply allnumbers with 2.\\n\\t\\n\\t\\n\\t eg:finalsum=28\\n\\t it is even so answer exist\\n\\t finalsum=28/2\\n\\t now low=1 high=14\\n\\t after binary search low=4\\n\\t then we update low=low-1 because remaing number is < = low\\n\\t answer=[2,4,6,16]\\n\\t        \\n\\n\\n\\n# \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalsum) {\\n        long long low=1;\\n        long long high=finalsum/2;\\n        \\n        if(finalsum%2)\\n        {\\n            return {};\\n        }\\n        finalsum=finalsum/2;\\n        long long sum,mid;\\n        \\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            sum=(mid*(mid+1))/2;\\n            sum=finalsum-sum;\\n            if(sum>mid)\\n            {\\n                low=mid+1;\\n            }\\n            else if(sum==0)\\n            {\\n                low=mid;\\n                break;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        vector<long long > ans;\\n        if(finalsum-(low*(low+1))/2<=low&&(finalsum-(low*(low+1))/2)!=0)\\n        {\\n            low=low-1;\\n        }\\n        for(int i=1;i<=low;i++)\\n        {\\n            ans.push_back(2*i);\\n        }\\n        if(finalsum-(low*(low+1))/2)\\n        {\\n            ans.push_back(2*(finalsum-(low*(low+1))/2));\\n        }\\n        return ans;\\n    }\\n};\\n```\\nLegend Please Support Legend,UPVOTE \\nThank You !",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalsum) {\\n        long long low=1;\\n        long long high=finalsum/2;\\n        \\n        if(finalsum%2)\\n        {\\n            return {};\\n        }\\n        finalsum=finalsum/2;\\n        long long sum,mid;\\n        \\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            sum=(mid*(mid+1))/2;\\n            sum=finalsum-sum;\\n            if(sum>mid)\\n            {\\n                low=mid+1;\\n            }\\n            else if(sum==0)\\n            {\\n                low=mid;\\n                break;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        vector<long long > ans;\\n        if(finalsum-(low*(low+1))/2<=low&&(finalsum-(low*(low+1))/2)!=0)\\n        {\\n            low=low-1;\\n        }\\n        for(int i=1;i<=low;i++)\\n        {\\n            ans.push_back(2*i);\\n        }\\n        if(finalsum-(low*(low+1))/2)\\n        {\\n            ans.push_back(2*(finalsum-(low*(low+1))/2));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784170,
                "title": "full-intution-and-solution-in-o-sqrt-n-time-and-o-1-space-complexity",
                "content": "In this question we have to find the maximum number of unique positive even integers thats sum equals to targetSum.\\n\\nCase 1:\\nSo first thing is sum of even numbers are always even, so if the targetSum is odd then we will not make sum of any even no equal to odd hence we return empty vector.\\n\\nCase 2:\\nIf the no is even then we can make sum of some even numbers to get targetSum .\\n\\nNow to maximize the no. of even numbers we will continuously add 2 until we get sum equals to targetSum **but** the question ask us to maximize the no. of **unique** positive even integers.\\nSo to maximize this we will always take minimum unique positive even integers.\\nLets take a number n\\nSo here what we do is we split the number **n** into 2 & (n-2). We will push this 2 to the vector , then we will split **(n-2)** to 4 & (n-6). why 4 because we already pushed 2 into the vector. Now we will split **(n-6)** to 6 & (n - 12). We do the same process until our pushed element not becomes greater than equal to remaining no. **Why this because if we do not stop here then the even numbers will start repeating.**\\nNow after this we check if the remaining no is not equal to 0 then we will push into the vector \\n\\nExample\\nn = 28\\npushed element........ remaining.........vector\\n........( i )  ......................... ( curr - i )...........( v )                // Used in the code. \\n...........................................28.........................[ ]\\n..........2 .........................   26.........................[2]\\n..........4  .........................  22 .......................[2,4]\\n..........6 .........................  16........................[2,4,6]\\n..........8 ................ ...........8.........................stop\\n\\t\\t\\nafter stop check if **rem != 0** then push the **curr + i** into the vector i.e [2,4,6,16]. So this is the ans that we want to return.\\n\\n**Source Code**\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        vector<long long> v;\\n        if(finalSum % 2 != 0)\\n            return v;\\n        long long curr = finalSum;\\n        for(long long i=2;curr > 0; i += 2)\\n        {\\n            \\n                if(i >= curr - i)\\n                    break;\\n                v.push_back(i);\\n                curr = curr - i;\\n        }\\n        if(curr > 0)\\n            v.push_back(curr);\\n        return v;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n\\nTime Complexity : O(sqrt(n))\\nSpace Complexity : O(1)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        vector<long long> v;\\n        if(finalSum % 2 != 0)\\n            return v;\\n        long long curr = finalSum;\\n        for(long long i=2;curr > 0; i += 2)\\n        {\\n            \\n                if(i >= curr - i)\\n                    break;\\n                v.push_back(i);\\n                curr = curr - i;\\n        }\\n        if(curr > 0)\\n            v.push_back(curr);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784088,
                "title": "c-greedy-ascending",
                "content": "```\\npublic class Solution {\\n    public IList<long> MaximumEvenSplit(long finalSum) {\\n        var res = new HashSet<long>();\\n        if(finalSum % 2 == 1)\\n            return res.ToList();\\n        Helper(finalSum, res, 2);\\n        return res.ToList();\\n    }\\n    \\n    private bool Helper(long tgt, HashSet<long> res, long start) \\n    {\\n        for(long i=start; i<tgt; i+=2)\\n            if(!res.Contains(i))\\n            {\\n                res.Add(i);\\n                if(Helper(tgt - i, res, i))\\n                    return true;\\n                res.Remove(i);\\n            }\\n        if(!res.Contains(tgt))\\n        {\\n            res.Add(tgt);\\n            return true;\\n        }\\n        return false;               \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<long> MaximumEvenSplit(long finalSum) {\\n        var res = new HashSet<long>();\\n        if(finalSum % 2 == 1)\\n            return res.ToList();\\n        Helper(finalSum, res, 2);\\n        return res.ToList();\\n    }\\n    \\n    private bool Helper(long tgt, HashSet<long> res, long start) \\n    {\\n        for(long i=start; i<tgt; i+=2)\\n            if(!res.Contains(i))\\n            {\\n                res.Add(i);\\n                if(Helper(tgt - i, res, i))\\n                    return true;\\n                res.Remove(i);\\n            }\\n        if(!res.Contains(tgt))\\n        {\\n            res.Add(tgt);\\n            return true;\\n        }\\n        return false;               \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783972,
                "title": "have-a-look",
                "content": "made you look\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n      vector<long long> res,x;\\n      long long n=0;\\n        if(finalSum%2!=0)\\n            return res;\\n        stack<long long> s;\\n        s.push(2);\\n \\n        for(long long i=2;i<=finalSum;i+=2)\\n        {\\n            if(n==finalSum)\\n                return res;\\n            n+=i;\\n            res.push_back(i);\\n            if(n>finalSum)\\n            {if((n-finalSum)%2==0)\\n               {int k=n-finalSum;\\n                k/=2;\\n                res.erase(res.begin()+k-1);\\n                return res;}\\n             else\\n                 return x;}\\n            \\n        }\\n        return res;\\n    }\\n};\\n\\n```\\nbit messy but easy to understand",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n      vector<long long> res,x;\\n      long long n=0;\\n        if(finalSum%2!=0)\\n            return res;\\n        stack<long long> s;\\n        s.push(2);\\n \\n        for(long long i=2;i<=finalSum;i+=2)\\n        {\\n            if(n==finalSum)\\n                return res;\\n            n+=i;\\n            res.push_back(i);\\n            if(n>finalSum)\\n            {if((n-finalSum)%2==0)\\n               {int k=n-finalSum;\\n                k/=2;\\n                res.erase(res.begin()+k-1);\\n                return res;}\\n             else\\n                 return x;}\\n            \\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783908,
                "title": "python",
                "content": "Our desired list is a sequence of  integers \\nThe length of the list can be approximated by  finding n such that the sum of the first n terms is just below finalSum.\\n\\nThe sum of the first n terms of an AP is Sn = (n/2)*(2*a + (n-1)*d) \\nHere, d=2 and a= 2. We can therefore setup the inequality and reduce it to\\n\\nn^2 + n - finalSum<=0 \\nIf we solve this and consider only the integer part of the real positive value of n, we can set up the first n elements of the list.\\n\\nrem = finalSum- sum(list)\\nIf rem is in our list, add it to the last element else append  it to the list\\n\\nofcos if finalSum is not even return []\\n\\n```\\n    def maximumEvenSplit(self, finalSum):\\n        \"\"\"\\n        :type finalSum: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if finalSum%2==1:\\n            return []\\n        n = int((-1+sqrt(1+4*finalSum))//2)\\n        \\n        ls = [2*a for a in range(1,n+1)]\\n        \\n        rem = finalSum - sum(ls)\\n        if rem ==0:\\n            return ls\\n        if rem in ls:\\n            ls[-1]= ls[-1]+rem\\n        else:\\n            ls.append(rem)\\n   \\n        return ls  \\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    def maximumEvenSplit(self, finalSum):\\n        \"\"\"\\n        :type finalSum: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if finalSum%2==1:\\n            return []\\n        n = int((-1+sqrt(1+4*finalSum))//2)\\n        \\n        ls = [2*a for a in range(1,n+1)]\\n        \\n        rem = finalSum - sum(ls)\\n        if rem ==0:\\n            return ls\\n        if rem in ls:\\n            ls[-1]= ls[-1]+rem\\n        else:\\n            ls.append(rem)\\n   \\n        return ls  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1783892,
                "title": "small-c-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n       vector<long long> ans;\\n       if(finalSum%2)\\n           return ans;\\n        long long i = 2;\\n        while(i<=finalSum){\\n                ans.push_back(i);\\n                finalSum -=i;\\n                i+=2;\\n        }\\n        ans[ans.size() - 1] = ans[ans.size() - 1] + finalSum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n       vector<long long> ans;\\n       if(finalSum%2)\\n           return ans;\\n        long long i = 2;\\n        while(i<=finalSum){\\n                ans.push_back(i);\\n                finalSum -=i;\\n                i+=2;\\n        }\\n        ans[ans.size() - 1] = ans[ans.size() - 1] + finalSum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783884,
                "title": "javascript-2178-maximum-split-of-positive-even-integers",
                "content": "---\\n\\n**Biweekly Contest 72** answers:\\n\\n- **Q1**\\n  - https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/discuss/1783863/JavaScript-2176.-Count-Equal-and-Divisible-Pairs-in-an-Array\\n- **Q2**\\n  - https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/discuss/1783879/JavaScript-2177.-Find-Three-Consecutive-Integers-That-Sum-to-a-Given-Number\\n- **Q3**\\n  - https://leetcode.com/problems/maximum-split-of-positive-even-integers/discuss/1783884/JavaScript-2178.-Maximum-Split-of-Positive-Even-Integers\\n  - **below**\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar maximumEvenSplit = function (finalSum) {\\n    let ans = [];\\n    for (let n = 2; finalSum && n <= 2 * 100000; n += 2) {\\n        if (n > finalSum) break;\\n        ans.push(n);\\n        finalSum -= n;\\n    }\\n    if (finalSum % 2 === 0) {\\n        ans[ans.length - 1] += finalSum;\\n        finalSum = 0;\\n    }\\n    return !finalSum ? ans : [];\\n};\\n```\\n\\n---\\n\\nContest screenshot:\\n\\n![image](https://assets.leetcode.com/users/images/3bb78df6-4a89-4df0-8552-2abf472ce238_1645294091.331256.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumEvenSplit = function (finalSum) {\\n    let ans = [];\\n    for (let n = 2; finalSum && n <= 2 * 100000; n += 2) {\\n        if (n > finalSum) break;\\n        ans.push(n);\\n        finalSum -= n;\\n    }\\n    if (finalSum % 2 === 0) {\\n        ans[ans.length - 1] += finalSum;\\n        finalSum = 0;\\n    }\\n    return !finalSum ? ans : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783850,
                "title": "c-easy",
                "content": "```\\npublic class Solution {\\n    public IList<long> MaximumEvenSplit(long finalSum) {\\n        IList<long> ans = new List<long>();\\n        if(finalSum%2==1)\\n        {\\n            return ans;\\n        }\\n        \\n        long sum = 0, next = 2;\\n        while(sum+next<=finalSum)\\n        {\\n            ans.Add(next);\\n            sum+=next;\\n            next+=2;\\n        }\\n        ans[ans.Count()-1] += finalSum - sum;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<long> MaximumEvenSplit(long finalSum) {\\n        IList<long> ans = new List<long>();\\n        if(finalSum%2==1)\\n        {\\n            return ans;\\n        }\\n        \\n        long sum = 0, next = 2;\\n        while(sum+next<=finalSum)\\n        {\\n            ans.Add(next);\\n            sum+=next;\\n            next+=2;\\n        }\\n        ans[ans.Count()-1] += finalSum - sum;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783848,
                "title": "c-both-iterative-and-recursive-approach-backtracking",
                "content": "**Iterative appraoch -**\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2!=0) return {};\\n        vector<long long>ans;\\n        int val = 2;\\n        while(val<=finalSum){\\n            ans.push_back(val);\\n            finalSum-=val;\\n            val+=2;\\n        }\\n        ans[ans.size()-1]+=finalSum;\\n        return ans;\\n    }\\n};\\n```\\n**Recursion + Backtracking approach -**\\n```\\nclass Solution {\\nprivate:\\n    vector<long long>ans;\\n    void getMax(long long n, long long prev, vector<long long>&cur){\\n        if(n==0){\\n            ans = cur;\\n            return;\\n        }\\n        if(n<0) return;\\n        for(long long k = prev; k <= n; k += 2) {\\n            cur.push_back(k);\\n            getMax(n - k, k+2, cur);\\n            if (ans.size() > 0) break;\\n            cur.pop_back();\\n        }\\n    }\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2!=0) return {};\\n        vector<long long>cur;\\n        getMax(finalSum, 2, cur);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2!=0) return {};\\n        vector<long long>ans;\\n        int val = 2;\\n        while(val<=finalSum){\\n            ans.push_back(val);\\n            finalSum-=val;\\n            val+=2;\\n        }\\n        ans[ans.size()-1]+=finalSum;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<long long>ans;\\n    void getMax(long long n, long long prev, vector<long long>&cur){\\n        if(n==0){\\n            ans = cur;\\n            return;\\n        }\\n        if(n<0) return;\\n        for(long long k = prev; k <= n; k += 2) {\\n            cur.push_back(k);\\n            getMax(n - k, k+2, cur);\\n            if (ans.size() > 0) break;\\n            cur.pop_back();\\n        }\\n    }\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2!=0) return {};\\n        vector<long long>cur;\\n        getMax(finalSum, 2, cur);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783829,
                "title": "kotlin-solution-with-explanation",
                "content": "There are simple observations we should do to solve the challenge. \\n\\nFirst of all, if `finalSum` is not divisible by `2`, solution does not exists. That\\'s because we can\\'t sum up even numbers to get odd number.\\n\\nSecond thing is we start summing up from smallest even number and move forward increasing sequence. This way we will have the maximum number of integers.\\n\\nThird, we should collect integers until their sum `currSum` reaches `finalSum` or some number that is greater than `finalSum`. If we reached `finalSum`, tnen we already have a solution.\\n\\nIf we reached some number that is greater than `finalSum`, than we should remove just a single number from our sequence to obtain `finalSum`, and this number is `currSum - finalSum`. The number `currSum - finalSum` is certainly in the collected sequence, because of two reasons:\\n\\n1. `currSum - finalSum` is even number (both `currSum` and `finalSum` are even)\\n2. Our sequence contains the smallest positive even integer - `2`, and if we remove the biggest integer from our collection, we obtain `currSum < finalSum`.\\n\\nConsider the example `32`. We collect numbers:\\n\\n`2` ->  `2`\\n`2`, `4` -> `2 + 4 = 6 < 32`\\n`2`, `4`, `6` -> `2 + 4 + 6 = 12 < 32`\\n`2`, `4`, `6`, `8` -> `2 + 4 + 6 + 8 = 20 < 32`\\n`2`, `4`, `6`, `8`, `10` -> `2 + 4 + 6 + 8 + 10 = 30 > 32`\\n`2`, `4`, `6`, `8`, `10`, `12` -> `2 + 4 + 6 + 8 + 10 + 12 = 42 > 32`\\n\\nWe reached number `42` which is greater than `32`. To obtain `32` we need to remove `42 - 32 = 10` from our collection, obtaining the resulting sequence: `2`, `4`, `6`, `8`, `12` -> `2 + 4 + 6 + 8 + 12 = 32`.\\n\\nThe code is pretty straightforward:\\n\\n```\\nclass Solution {\\n    fun maximumEvenSplit(finalSum: Long): List<Long> {\\n\\t\\t// If finalSum is not even, solution does not exist (first observation)\\n        if (finalSum % 2L != 0L) return emptyList()\\n        \\n\\t\\t// Collect numbers into linked list so adding and removing elements take O(1)\\n        val result = LinkedList<Long>()\\n        var currSum = 0L\\n        var currNumber = 0L\\n        while (currSum < finalSum) {\\n            currNumber += 2L\\n            result.addFirst(currNumber)\\n            currSum += currNumber\\n        }\\n        \\n\\t\\t// Either return the resulting sequence, or remove currSum - finalSum from it\\n        if (currSum == finalSum) return result\\n        \\n        val diff = currSum - finalSum\\n        result.remove(diff)\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumEvenSplit(finalSum: Long): List<Long> {\\n\\t\\t// If finalSum is not even, solution does not exist (first observation)\\n        if (finalSum % 2L != 0L) return emptyList()\\n        \\n\\t\\t// Collect numbers into linked list so adding and removing elements take O(1)\\n        val result = LinkedList<Long>()\\n        var currSum = 0L\\n        var currNumber = 0L\\n        while (currSum < finalSum) {\\n            currNumber += 2L\\n            result.addFirst(currNumber)\\n            currSum += currNumber\\n        }\\n        \\n\\t\\t// Either return the resulting sequence, or remove currSum - finalSum from it\\n        if (currSum == finalSum) return result\\n        \\n        val diff = currSum - finalSum\\n        result.remove(diff)\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783737,
                "title": "c-easy-to-code-solution",
                "content": "if sum is odd than clearly return empty vector.\\n**Approch: Pick even no in increasing order.**\\nfirst we will pick 2 so remaining sum 26 : (2};\\nNext I will pick 4 so: 22 and vector becomes (2,4};\\nNext I will pick 6 so: 16 and vector becomes (2,4,6};\\nNext I will pick 8 so: 8 and vector becomes (2,4,6,8};\\nNow I can\\'t Pick 10 cause Reaming sum is alredy less than 10\\nso I pop back 8 from vector and push remaing Sum which is 16 (2,4,6,16};\\n```\\nvector<long long> maximumEvenSplit(long long Sum) {\\n        vector<long long>v;\\n        if(Sum%2!=0) return v;\\n        \\n        for(long long i=2;i<=Sum;i+=2){\\n            v.push_back(i);\\n            Sum-=i;\\n        }\\n        long long i=v.back();\\n        v.pop_back();\\n        v.push_back(Sum+i);\\n        \\n        \\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<long long> maximumEvenSplit(long long Sum) {\\n        vector<long long>v;\\n        if(Sum%2!=0) return v;\\n        \\n        for(long long i=2;i<=Sum;i+=2){\\n            v.push_back(i);\\n            Sum-=i;\\n        }\\n        long long i=v.back();\\n        v.pop_back();\\n        v.push_back(Sum+i);\\n        \\n        \\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783714,
                "title": "c-easy-to-understand-sliding-window",
                "content": "1. Store all even  numbers in a array which are less than equal to the finalsum.\\n2.  Then just traverse in the array and calculate sum  and insert in  the arr the num[j].\\n3.  While sum>finalsum , check if (finalsum - sum ) exists in the st. if it is remove it.\\n4.  When the sum = finalsum, just push all the values of set in the array and return it,\\n```\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>nums;\\n        long long int numsum = 0;\\n        for(int i = 2;numsum<=finalSum;i+=2){\\n            nums.push_back(i);\\n            numsum+=i;\\n        }\\n        int j = 0;\\n        int n = nums.size();\\n        unordered_set<long long>st;\\n        vector<long long>ans;\\n        long long int sum = 0;\\n        \\n        while(j<n){\\n              sum+=nums[j];\\n             st.insert(nums[j]);\\n             \\n             if(sum>=finalSum){\\n                 \\n                 while(sum>finalSum){\\n                     long long int val = sum-finalSum;\\n                     if(st.count(val)){\\n                         sum-=val;\\n                         st.erase(val);\\n                     }else{\\n                         return {};\\n                     }\\n                 }\\n                 if(sum==finalSum){\\n                     for(auto it:st){\\n                         ans.push_back(it);\\n                     }\\n                     return ans;\\n                 }\\n             }\\n            \\n            j++;\\n        }\\n        \\n        if(ans.size()==0)\\n            return {};\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>nums;\\n        long long int numsum = 0;\\n        for(int i = 2;numsum<=finalSum;i+=2){\\n            nums.push_back(i);\\n            numsum+=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1783680,
                "title": "easy-c-solution-simple-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long> st;\\n        if(finalSum&1){\\n            return {};\\n        }\\n        int curr = 2;\\n        while(finalSum>0){\\n            if(finalSum>=curr){\\n                st.push_back(curr);\\n                finalSum-=curr;\\n            }else{\\n                break;\\n            }\\n            curr+=2;\\n        }\\n        if(finalSum>0){\\n            long long x = st.back();\\n            st.pop_back();\\n            st.push_back(x+finalSum);\\n        }return st;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long> st;\\n        if(finalSum&1){\\n            return {};\\n        }\\n        int curr = 2;\\n        while(finalSum>0){\\n            if(finalSum>=curr){\\n                st.push_back(curr);\\n                finalSum-=curr;\\n            }else{\\n                break;\\n            }\\n            curr+=2;\\n        }\\n        if(finalSum>0){\\n            long long x = st.back();\\n            st.pop_back();\\n            st.push_back(x+finalSum);\\n        }return st;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783669,
                "title": "c-easy-implementation-using-set",
                "content": "* If the number is odd, simply return an empty vector.\\n* Then subtract even numbers starting from 2, then 4, 6 so on... to get maximum number of elements in the vector.\\n* At each iteration, insert the even number in the set.\\n* Before inserting check if that number already exists in the set or if finalSum would be greater than or equal to zero after subtracting that number.\\n* If any of the above two conditions don\\'t hold true then check for the next value of t such that it\\'s not already in the set and since we are adding a greater value of t, we need to keep a record of the number which needs to be deleted from the set in \\'u\\'.\\n* Then insert all values of the set in the ans vector except \\'u\\' which needs to be discarded.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long> ans;\\n        if(finalSum%2)\\n            return ans;\\n        \\n        unordered_set<long long> st;\\n        long long t = 2, u=0;\\n        \\n        while(finalSum>0)\\n        {\\n            if(finalSum-t >= 0 && st.find(t) == st.end())\\n            {\\n                st.insert(t);\\n                finalSum -= t;\\n                t += 2;\\n            }\\n            else\\n            {\\n                while(st.find(t) != st.end())\\n                    t += 2;\\n                st.insert(t);\\n                u = t - finalSum;\\n                finalSum -= t;\\n            }\\n        }\\n        \\n        for(auto i : st)\\n            if(i != u)\\n                ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long> ans;\\n        if(finalSum%2)\\n            return ans;\\n        \\n        unordered_set<long long> st;\\n        long long t = 2, u=0;\\n        \\n        while(finalSum>0)\\n        {\\n            if(finalSum-t >= 0 && st.find(t) == st.end())\\n            {\\n                st.insert(t);\\n                finalSum -= t;\\n                t += 2;\\n            }\\n            else\\n            {\\n                while(st.find(t) != st.end())\\n                    t += 2;\\n                st.insert(t);\\n                u = t - finalSum;\\n                finalSum -= t;\\n            }\\n        }\\n        \\n        for(auto i : st)\\n            if(i != u)\\n                ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783635,
                "title": "c-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void func(long long finalSum, long long num, vector<long long>&v){\\n        long long val=finalSum-num;\\n        if(val>num){\\n            v.push_back(num);\\n            func(val,num+2,v);\\n        }else{\\n            v.push_back(finalSum);\\n            return;\\n        }\\n    }\\n    \\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum&1){\\n            return {};\\n        }\\n        \\n        vector<long long> v;\\n        func(finalSum,2,v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(long long finalSum, long long num, vector<long long>&v){\\n        long long val=finalSum-num;\\n        if(val>num){\\n            v.push_back(num);\\n            func(val,num+2,v);\\n        }else{\\n            v.push_back(finalSum);\\n            return;\\n        }\\n    }\\n    \\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum&1){\\n            return {};\\n        }\\n        \\n        vector<long long> v;\\n        func(finalSum,2,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783617,
                "title": "python-simple-intution-easy",
                "content": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        ans = []\\n        if finalSum%2==0:\\n            i = 2\\n            while finalSum >= i:\\n                ans.append(i)\\n                finalSum-=i\\n                i=i+2\\n            ans[-1] += finalSum\\n        return ans\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        ans = []\\n        if finalSum%2==0:\\n            i = 2\\n            while finalSum >= i:\\n                ans.append(i)\\n                finalSum-=i\\n                i=i+2\\n            ans[-1] += finalSum\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783615,
                "title": "c-straight-forward-and-short-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        // Number is odd\\n        if(finalSum % 2 != 0) return {};\\n        vector<long long> nums;\\n        long long sum = 0;\\n        for(int i = 2; sum < finalSum; i += 2) {\\n            sum += i;\\n            nums.push_back(i);\\n        }\\n\\t\\t// Remove the 1 extra number\\n        if(finalSum != sum) nums.erase(nums.begin() + (sum - finalSum) / 2 - 1);\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        // Number is odd\\n        if(finalSum % 2 != 0) return {};\\n        vector<long long> nums;\\n        long long sum = 0;\\n        for(int i = 2; sum < finalSum; i += 2) {\\n            sum += i;\\n            nums.push_back(i);\\n        }\\n\\t\\t// Remove the 1 extra number\\n        if(finalSum != sum) nums.erase(nums.begin() + (sum - finalSum) / 2 - 1);\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783536,
                "title": "java-easy-soln",
                "content": "```\\nmport java.util.*;\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> ans = new ArrayList<>();\\n        long n = 1;\\n        long count =1;\\n        long rums = 1;\\n        if(finalSum%2!=0){\\n            return ans;\\n        }\\n        HashSet<Long> check = new HashSet<>();\\n        // Checking when the sum of even integers is greatrer than finalsum\\n        // eg 2->4->6->8->10 has a sum of 30 , so if finalsum = 28 we just subtract 2 and remove it from our answer\\n        while((n*(n+1))<finalSum){\\n            rums = (n*(n+1));\\n            n++;\\n            check.add(count*2);\\n            count++;\\n        }\\n        check.add(count*2);\\n        long b = rums + count*2 - finalSum;\\n        for (Long ele: check) {\\n            if(ele!=b){\\n                ans.add(ele);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nmport java.util.*;\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        List<Long> ans = new ArrayList<>();\\n        long n = 1;\\n        long count =1;\\n        long rums = 1;\\n        if(finalSum%2!=0){\\n            return ans;\\n        }\\n        HashSet<Long> check = new HashSet<>();\\n        // Checking when the sum of even integers is greatrer than finalsum\\n        // eg 2->4->6->8->10 has a sum of 30 , so if finalsum = 28 we just subtract 2 and remove it from our answer\\n        while((n*(n+1))<finalSum){\\n            rums = (n*(n+1));\\n            n++;\\n            check.add(count*2);\\n            count++;\\n        }\\n        check.add(count*2);\\n        long b = rums + count*2 - finalSum;\\n        for (Long ele: check) {\\n            if(ele!=b){\\n                ans.add(ele);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783530,
                "title": "java-backtracking-approach-recursion",
                "content": "```\\nclass Solution {\\n    // int max = 0;\\n    boolean solFound = false;\\n            List<Long> ans = new ArrayList<>();  \\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum%2 != 0) {\\n            return new ArrayList<>();\\n        }\\n        solve(2,0,finalSum,new ArrayList<>(),new HashMap<>());\\n        return ans;\\n    }\\n    void solve(long currEle,long currSum,long targetSum,List<Long> temp,HashMap<String,List<Long>> hm) {\\n        if(solFound) {\\n            return;\\n        }\\n        if(currSum == targetSum) {\\n            // System.out.println(ans);\\n            ans = new ArrayList<>(temp);\\n            solFound = true;\\n            return;\\n        }\\n        if(currSum+currEle > targetSum) \\n            return;\\n        if(currSum+currEle <= targetSum) {\\n            temp.add(currEle);\\n            solve(currEle+2,currSum+currEle,targetSum,temp,hm);\\n            temp.remove(temp.size()-1);\\n        }\\n        solve(currEle+2,currSum,targetSum,temp,hm);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    // int max = 0;\\n    boolean solFound = false;\\n            List<Long> ans = new ArrayList<>();  \\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if(finalSum%2 != 0) {\\n            return new ArrayList<>();\\n        }\\n        solve(2,0,finalSum,new ArrayList<>(),new HashMap<>());\\n        return ans;\\n    }\\n    void solve(long currEle,long currSum,long targetSum,List<Long> temp,HashMap<String,List<Long>> hm) {\\n        if(solFound) {\\n            return;\\n        }\\n        if(currSum == targetSum) {\\n            // System.out.println(ans);\\n            ans = new ArrayList<>(temp);\\n            solFound = true;\\n            return;\\n        }\\n        if(currSum+currEle > targetSum) \\n            return;\\n        if(currSum+currEle <= targetSum) {\\n            temp.add(currEle);\\n            solve(currEle+2,currSum+currEle,targetSum,temp,hm);\\n            temp.remove(temp.size()-1);\\n        }\\n        solve(currEle+2,currSum,targetSum,temp,hm);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783496,
                "title": "c-easy-solution",
                "content": "\\nCase 1: if finalSum is odd return empty vector \\nCase 2 : if  if finalSum is even \\n\\nfind try to write as a sum of series as 2 , 4, 6, ,,.,, \\nso first find value of n such that  [ sum of n even numbers ] , n*(n+1) <=final sum\\n\\nso i can make the series as 2 ,4 ,6 , ... ......2*n\\nwhat about the extra part ?  (if n*(n+1) < finalsum)  , i will add extra ( finalsum-n*(n+1)  )in last generated  term so that all the even numbers are distinct :\\nfeel free to comment if you got any doubts.\\n```\\nclass Solution\\n{\\npublic:\\n  vector<long long> maximumEvenSplit(long long finalSum)\\n  {\\n\\n    map<long long, long long> mp;\\n    long long limit ; // to find the value such that limit*(limit*1)<f=finalSum\\n    vector<long long> ans;\\n    if (finalSum % 2 == 1)   // return empty as finalSum is odd\\n      return ans;\\n\\n    for (long long i = 1; i < 1e10; i++)\\n    {\\n      if ((i * (i + 1)) > finalSum)\\n      {\\n        limit = i;\\n        break;\\n      }\\n    }\\n\\n    limit--;     // i got limit value such that (limit*(limit*1))>finalSum so i will at limit-1 i will get (limit*(limit*1))<=finalSum) \\n\\t\\n\\n    long long st = 2; // starting of series\\n \\n    long long st1 = 0;\\n    for (int i = 1; i <= limit; i++)\\n    {\\n      ans.push_back(st);\\n      st1 += st; \\n      st += 2;  // current sum of what i am putting in series\\n    }\\n\\n    ans[limit - 1] += finalSum - st1; // adding extra (finalSum-current sum) to make the total sum as final sum.\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  vector<long long> maximumEvenSplit(long long finalSum)\\n  {\\n\\n    map<long long, long long> mp;\\n    long long limit ; // to find the value such that limit*(limit*1)<f=finalSum\\n    vector<long long> ans;\\n    if (finalSum % 2 == 1)   // return empty as finalSum is odd\\n      return ans;\\n\\n    for (long long i = 1; i < 1e10; i++)\\n    {\\n      if ((i * (i + 1)) > finalSum)\\n      {\\n        limit = i;\\n        break;\\n      }\\n    }\\n\\n    limit--;     // i got limit value such that (limit*(limit*1))>finalSum so i will at limit-1 i will get (limit*(limit*1))<=finalSum) \\n\\t\\n\\n    long long st = 2; // starting of series\\n \\n    long long st1 = 0;\\n    for (int i = 1; i <= limit; i++)\\n    {\\n      ans.push_back(st);\\n      st1 += st; \\n      st += 2;  // current sum of what i am putting in series\\n    }\\n\\n    ans[limit - 1] += finalSum - st1; // adding extra (finalSum-current sum) to make the total sum as final sum.\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783491,
                "title": "python-simple-solution",
                "content": "```\\n\\tdef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum%2:\\n            return []\\n        res = []\\n        k   = 2\\n        while finalSum >= k:\\n            res.append(k)\\n            finalSum -= k\\n            k += 2\\n        res[-1] += finalSum\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\tdef maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum%2:\\n            return []\\n        res = []\\n        k   = 2\\n        while finalSum >= k:\\n            res.append(k)\\n            finalSum -= k\\n            k += 2\\n        res[-1] += finalSum\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1783442,
                "title": "c-greedy-solution",
                "content": "```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum % 2 != 0) return {};\\n        \\n        vector<long long> ans;\\n        long long x = 2, sum = 0;\\n        \\n        while(sum < finalSum) {\\n            if(sum + x <= finalSum) {\\n                ans.push_back(x);\\n                sum += x;\\n                x += 2;\\n            } else {\\n                ans.pop_back();\\n                x -= 2;\\n                sum -= x;\\n                ans.push_back(finalSum - sum);\\n                sum = finalSum;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum % 2 != 0) return {};\\n        \\n        vector<long long> ans;\\n        long long x = 2, sum = 0;\\n        \\n        while(sum < finalSum) {\\n            if(sum + x <= finalSum) {\\n                ans.push_back(x);\\n                sum += x;\\n                x += 2;\\n            } else {\\n                ans.pop_back();\\n                x -= 2;\\n                sum -= x;\\n                ans.push_back(finalSum - sum);\\n                sum = finalSum;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783428,
                "title": "python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/97dff55b43563450a33c98f2a216954117100dfe) for solutions of weekly 72. \\n\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2: return []\\n        ans = []\\n        x = 2\\n        while finalSum >= x: \\n            ans.append(x)\\n            finalSum -= x\\n            x += 2\\n        ans[-1] += finalSum\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2: return []\\n        ans = []\\n        x = 2\\n        while finalSum >= x: \\n            ans.append(x)\\n            finalSum -= x\\n            x += 2\\n        ans[-1] += finalSum\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783408,
                "title": "binary-search-cpp",
                "content": "i am finding out  maximum how many even can be added in our answer set such that it\\'s sum either becomes equal to target or just exceeds it ,\\nif it\\'s exactly equal than just return set thus formed \\nif it\\'s not exactly equal find the difference b/w your set\\'s sum and target , since it will be an even number as well so just exclude that number (diffference) from answer set\\n\\nfor finding out how many numbers can be taken in our set such that it exceeds or becomes equal to target we use binary search since sum of ```n even numbers is n*(n+1)```,\\nso we just need to find lower bound for value of ```n``` with respect to target\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long num) {\\n        if(num&1)return {}; // if odd can\\'t form\\n        \\n        long long l=1,r=1e6,p=1;\\n        \\n        while(l<=r){\\n            long long m=l+((r-l)>>1);\\n            \\n            if((m*(m+1)) >= num){\\n                p=m;\\n                r=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        long long x=p*(p+1); //sum of our set formed (>=target)\\n        long long ex=x-num; //difference to exclude from set\\n        \\n        vector<long long > ans;\\n        for(int i=1;i<=p;++i){\\n            if((i<<1) != ex){\\n                ans.push_back(i<<1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```n even numbers is n*(n+1)```\n```n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long num) {\\n        if(num&1)return {}; // if odd can\\'t form\\n        \\n        long long l=1,r=1e6,p=1;\\n        \\n        while(l<=r){\\n            long long m=l+((r-l)>>1);\\n            \\n            if((m*(m+1)) >= num){\\n                p=m;\\n                r=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n            \\n        }\\n        long long x=p*(p+1); //sum of our set formed (>=target)\\n        long long ex=x-num; //difference to exclude from set\\n        \\n        vector<long long > ans;\\n        for(int i=1;i<=p;++i){\\n            if((i<<1) != ex){\\n                ans.push_back(i<<1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783395,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum%2!=0:\\n            return []\\n        if finalSum==4:\\n            return [4]\\n        finalSum=finalSum//2\\n        res=[]\\n        i=1\\n        while True:\\n            finalSum-=i\\n            res.append(2*i)\\n            if finalSum==0:\\n                break\\n            if finalSum<2*i+3:\\n                res.append(2*(finalSum))\\n                break\\n            i+=1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum%2!=0:\\n            return []\\n        if finalSum==4:\\n            return [4]\\n        finalSum=finalSum//2\\n        res=[]\\n        i=1\\n        while True:\\n            finalSum-=i\\n            res.append(2*i)\\n            if finalSum==0:\\n                break\\n            if finalSum<2*i+3:\\n                res.append(2*(finalSum))\\n                break\\n            i+=1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1783349,
                "title": "c-solution-easy-to-understand",
                "content": "```\\n    vector<long long> maximumEvenSplit(long long n) \\n    {\\n          vector<long long> res;\\n         if(n%2==1) \\n             return res;\\n         else\\n         {\\n           int i=2;\\n             long long sum=0;\\n           while(sum<=n)\\n           {\\n               res.push_back(i);\\n               sum+=i;\\n               i+=2;\\n           }\\n           if(sum==n)\\n               return res;\\n             int target=sum-n;\\n             for (auto i = res.begin(); i != res.end(); ++i) \\n             {\\n               if (*i  == target) \\n               {\\n              res.erase(i);\\n              i--;\\n              break;\\n              }\\n               }\\n         }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<long long> maximumEvenSplit(long long n) \\n    {\\n          vector<long long> res;\\n         if(n%2==1) \\n             return res;\\n         else\\n         {\\n           int i=2;\\n             long long sum=0;\\n           while(sum<=n)\\n           {\\n               res.push_back(i);\\n               sum+=i;\\n               i+=2;\\n           }\\n           if(sum==n)\\n               return res;\\n             int target=sum-n;\\n             for (auto i = res.begin(); i != res.end(); ++i) \\n             {\\n               if (*i  == target) \\n               {\\n              res.erase(i);\\n              i--;\\n              break;\\n              }\\n               }\\n         }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783348,
                "title": "easy-c-solution-with-proper-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>v;\\n        if(finalSum%2!=0) //finalSum must be even so that it is sum of even numbers\\n\\t\\treturn v;\\n        else     // If finalSum is even,we can get our answer\\n        {\\n            v.push_back(2);  //Let we push our first even number as 2 into vector\\n            finalSum-=2;\\n\\t\\t\\t//Next number we need to push as 4,since we are adding only even \\n            //numbers,each time increase x by 2\\n            long long x=4;                                                                    \\n\\t\\t\\t\\n            while(finalSum>0)\\n            {\\n\\t\\t\\t// If Our remaining finalSum is lesser or equal\\n                // than our last inserted number in our vector we break loop.\\n                if(finalSum<=v[v.size()-1])\\n                    break;\\n                v.push_back(x);\\n                finalSum-=x;\\n                x+=2;\\n    \\n            }\\n\\t\\t\\t//If numbers are reamining then we add 2 each time from back in vector and decrease by 2\\n                   if(finalSum>=2)\\n                   {\\n                           for(int i=v.size()-1;i>=0;i--)\\n                            {\\n                               if(finalSum<2) break;\\n                                v[i]+=2;\\n                               finalSum-=2;\\n                            }\\n                   }\\n            return v;\\n        \\n        }\\n    }\\n};\\nIf You like my solutuon,guys plz upvote,thanks.\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        vector<long long>v;\\n        if(finalSum%2!=0) //finalSum must be even so that it is sum of even numbers\\n\\t\\treturn v;\\n        else     // If finalSum is even,we can get our answer\\n        {\\n            v.push_back(2);  //Let we push our first even number as 2 into vector\\n            finalSum-=2;\\n\\t\\t\\t//Next number we need to push as 4,since we are adding only even \\n            //numbers,each time increase x by 2\\n            long long x=4;                                                                    \\n\\t\\t\\t\\n            while(finalSum>0)\\n            {\\n\\t\\t\\t// If Our remaining finalSum is lesser or equal\\n                // than our last inserted number in our vector we break loop.\\n                if(finalSum<=v[v.size()-1])\\n                    break;\\n                v.push_back(x);\\n                finalSum-=x;\\n                x+=2;\\n    \\n            }\\n\\t\\t\\t//If numbers are reamining then we add 2 each time from back in vector and decrease by 2\\n                   if(finalSum>=2)\\n                   {\\n                           for(int i=v.size()-1;i>=0;i--)\\n                            {\\n                               if(finalSum<2) break;\\n                                v[i]+=2;\\n                               finalSum-=2;\\n                            }\\n                   }\\n            return v;\\n        \\n        }\\n    }\\n};\\nIf You like my solutuon,guys plz upvote,thanks.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783283,
                "title": "java-simple-o-n-solution",
                "content": "```\\npublic List<Long> maximumEvenSplit(long finalSum) {\\n        // If finalSum is odd return empty List     \\n        if( finalSum % 2 == 1){\\n            return new ArrayList<Long>();\\n        }        \\n        List<Long> evenList = new ArrayList<>();\\n        /* The question reduces to finding  maximum length positive integers with sum equal to finalSum /2\\n\\t\\tAt each step, keep adding i to j till j exceeds the required Sum. If j is equal to the required sum then return the list,\\n\\t\\telse remove the excess element from the list which is (j - finalSum) * 2. We start from 1 since we have to maximize the length of the arrayList\\n\\t\\t*/\\n         finalSum = finalSum / 2;\\n        long j=0;\\n        for(long i=1; j < finalSum; i++) {\\n            j += i;\\n            evenList.add(i*2);\\n        }\\n        \\n        if(j == finalSum) {\\n             return evenList;\\n        }     \\n        evenList.remove((j - finalSum) * 2);       \\n        return evenList;                 \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Long> maximumEvenSplit(long finalSum) {\\n        // If finalSum is odd return empty List     \\n        if( finalSum % 2 == 1){\\n            return new ArrayList<Long>();\\n        }        \\n        List<Long> evenList = new ArrayList<>();\\n        /* The question reduces to finding  maximum length positive integers with sum equal to finalSum /2\\n\\t\\tAt each step, keep adding i to j till j exceeds the required Sum. If j is equal to the required sum then return the list,\\n\\t\\telse remove the excess element from the list which is (j - finalSum) * 2. We start from 1 since we have to maximize the length of the arrayList\\n\\t\\t*/\\n         finalSum = finalSum / 2;\\n        long j=0;\\n        for(long i=1; j < finalSum; i++) {\\n            j += i;\\n            evenList.add(i*2);\\n        }\\n        \\n        if(j == finalSum) {\\n             return evenList;\\n        }     \\n        evenList.remove((j - finalSum) * 2);       \\n        return evenList;                 \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783241,
                "title": "python3-solution-using-square-root",
                "content": "\\n\\n```python\\nimport math\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 != 0: return []\\n        k = int(math.sqrt(finalSum))\\n        if k * (k+1) < finalSum:\\n            k = k+1\\n        diff = k * (k+1) -finalSum\\n        # print(diff)\\n        return [2*v for v in range(1, k+1) if 2*v != diff]\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nimport math\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 != 0: return []\\n        k = int(math.sqrt(finalSum))\\n        if k * (k+1) < finalSum:\\n            k = k+1\\n        diff = k * (k+1) -finalSum\\n        # print(diff)\\n        return [2*v for v in range(1, k+1) if 2*v != diff]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783186,
                "title": "java-solution-using-backtracking",
                "content": "I used Set during the contest, however while re-reading the code I realized that I could have used ArrayList as well.\\nIn case of ArrayList, just need to remove the last element after backtracking.\\n\\nThis solution is kind of Greedy + Backtrack.\\nIt always tries to use the smallest number first before moving on to next number so that we get the maximum length.\\n\\n```\\nclass Solution {\\n    Set<Long> ans;\\n    \\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Set<Long> nums = new HashSet<>();\\n        ans = new HashSet<Long>();\\n        backtrackAndSum(finalSum, 0, nums);\\n        \\n        return new ArrayList<Long>(nums);\\n    }\\n    \\n    private void backtrackAndSum(long finalSum, long prev, Set<Long> nums) {\\n        if (finalSum == 0) {\\n            ans = nums;\\n            return;\\n        }\\n\\n        for(long num = prev + 2; num <= finalSum; num += 2) {\\n            nums.add(num);\\n            backtrackAndSum(finalSum - num, num, nums);\\n            \\n            if (ans.size() > 0) {\\n                break;\\n            }\\n            \\n            nums.remove(num);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    Set<Long> ans;\\n    \\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        if (finalSum % 2 != 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Set<Long> nums = new HashSet<>();\\n        ans = new HashSet<Long>();\\n        backtrackAndSum(finalSum, 0, nums);\\n        \\n        return new ArrayList<Long>(nums);\\n    }\\n    \\n    private void backtrackAndSum(long finalSum, long prev, Set<Long> nums) {\\n        if (finalSum == 0) {\\n            ans = nums;\\n            return;\\n        }\\n\\n        for(long num = prev + 2; num <= finalSum; num += 2) {\\n            nums.add(num);\\n            backtrackAndSum(finalSum - num, num, nums);\\n            \\n            if (ans.size() > 0) {\\n                break;\\n            }\\n            \\n            nums.remove(num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783173,
                "title": "easy-python3-solution-with-explanation-o-n",
                "content": "Let\\'s assume we can cumulate all even numbers until finalSum, by using each even number only once. While doing this, we store each number in a set. Once our cumulated sum is bigger than finalSum, we need to substract the difference and remove the difference (which is also an even number) from the set. \\n```\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\t\\t# if finalSum is odd, there is no solution\\n        if finalSum & 1 == 1:\\n            return []\\n        \\n        n = set()\\n        cum_sum = 0\\n        for i in range(2, finalSum+1, 2):\\n            cum_sum += i\\n            n.add(i)\\n            if cum_sum == finalSum:\\n                return list(n)\\n            elif cum_sum >= finalSum:\\n                n.remove(cum_sum - finalSum)\\n                return list(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n\\t\\t# if finalSum is odd, there is no solution\\n        if finalSum & 1 == 1:\\n            return []\\n        \\n        n = set()\\n        cum_sum = 0\\n        for i in range(2, finalSum+1, 2):\\n            cum_sum += i\\n            n.add(i)\\n            if cum_sum == finalSum:\\n                return list(n)\\n            elif cum_sum >= finalSum:\\n                n.remove(cum_sum - finalSum)\\n                return list(n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4069304,
                "title": "c-math-greedy-98-37-faster",
                "content": "# Please UpVote if it helps you\\n\\nApproach -> sum of even numbers are `n*(n+1)` do equal to `sum` which is given in the input.....after it make quadratic equation `n^2 + n - sum = 0 ` solve it with the help of `(-b + sqrt(1-4*a*c))/2` take ceil value of all....after that with help of `Greedy` approach remove minimum number of `numbers`.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long sum) {\\n        if(sum&1)return {};\\n        long long x = ceil((ceil(sqrt(1+4*(double)sum))-1)/2.0);\\n        long long sum1 = x*(x+1) - sum,t=x*2;\\n        unordered_map<long long,long long>m;\\n        while(sum1>0){\\n            if(sum1<=t){\\n                m[sum1]=1;\\n                break;\\n            }\\n            else{\\n                m[t]=1;\\n                sum1-=t;\\n            }\\n        }\\n        vector<long long> ans;\\n        t = 2;\\n        for(long long i=0;i<x;i+=1){\\n            if(m.find(t)==m.end())ans.push_back(t);\\n            t+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long sum) {\\n        if(sum&1)return {};\\n        long long x = ceil((ceil(sqrt(1+4*(double)sum))-1)/2.0);\\n        long long sum1 = x*(x+1) - sum,t=x*2;\\n        unordered_map<long long,long long>m;\\n        while(sum1>0){\\n            if(sum1<=t){\\n                m[sum1]=1;\\n                break;\\n            }\\n            else{\\n                m[t]=1;\\n                sum1-=t;\\n            }\\n        }\\n        vector<long long> ans;\\n        t = 2;\\n        for(long long i=0;i<x;i+=1){\\n            if(m.find(t)==m.end())ans.push_back(t);\\n            t+=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053317,
                "title": "java-o-answer-solution-only-time-needed-is-to-fill-the-answers",
                "content": "# Intuition\\nFirst odd numbers can be eliminated because they cannot be summed by even integers.\\n\\nFor even integers, consider summing first K positive even integers (2+4+6...) until the sum exceeds `finalSum`. Stop before the number where sum exceeds, add the remaining from the finalSum to the partial sum in the last number.\\n\\nEg: finalSum = 28\\n2+4+6+8+10 = 30 > finalSum\\n2+4+6+8 = 20 < finalSum\\n\\nAdd 28 - 20 = 8 to the last number 8. Result = [2,4,6,16]\\n\\n## How to compute N\\n\\n2+4+6+8....(N Terms) <= finalSum\\n2*(1+2+3+4..) <= finalSum\\n2*N(N+1)/2 <= finalSum\\nN(N+1) <= finalSum\\n\\nN = (-1 +/- sqrt(1 + 4 *  finalSum))/2 \\n\\nWe can disregard the negative term, so:\\n\\nN = (sqrt(1 + 4 * finalSum) - 1)/2\\n\\nIf we take the integer part of the square root it will account for the <= in the equation.\\n\\n# Approach\\nCompute N from the above equation and add first N-1 numbers. Also, compute the partialSum in the loop. Add `finalSum - partialSum` to the Nth number.\\n\\n# Complexity\\n- Time complexity:\\nThe only time complexity occurs in filling up the solution. O(solution)\\n\\n- Space complexity:\\nThe only space complexity occurs in filling up the solution. O(solution)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n\\n        if (finalSum % 2 == 1) {\\n            return Arrays.asList();\\n        }\\n\\n        int count = ((int)(Math.sqrt(1 + 4 * finalSum)) - 1)/2;\\n\\n        List<Long> result = new ArrayList<>(count);\\n        long partialSum = 0;\\n        for (long i = 1; i < count; i++) {\\n            result.add(2 * i);\\n            partialSum += 2 * i;\\n        }\\n        result.add(finalSum - partialSum);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n\\n        if (finalSum % 2 == 1) {\\n            return Arrays.asList();\\n        }\\n\\n        int count = ((int)(Math.sqrt(1 + 4 * finalSum)) - 1)/2;\\n\\n        List<Long> result = new ArrayList<>(count);\\n        long partialSum = 0;\\n        for (long i = 1; i < count; i++) {\\n            result.add(2 * i);\\n            partialSum += 2 * i;\\n        }\\n        result.add(finalSum - partialSum);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052883,
                "title": "c-100-better-runtime-explained-code-greedy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) \\n    {\\n        if(finalSum%2 != 0) return {};\\n\\n        vector<long long> res;\\n        long long sum = 0;\\n        int i;\\n\\n        // Iterate a loop with an increment of 2, until we exceed or equal to finalSum, and keep appending index of every iteration to our final result.\\n        for(i=2; i<=finalSum; i+=2)\\n        {\\n            if(sum >= finalSum) break;\\n            sum += i;\\n            res.push_back(i);\\n        }\\n        \\n        // If the sum == finalSum, we achieved the objective and hence return the res\\n        if(sum == finalSum) return res;\\n\\n        // Otherwise we first calculate the margin by which we overstepped the finalSum. And we just add the calulated margin to the last element we added to res. And return the res. \\n        if(sum > finalSum) res.pop_back(), res[res.size()-1] = res[res.size()-1] + (finalSum-sum+i-2);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) \\n    {\\n        if(finalSum%2 != 0) return {};\\n\\n        vector<long long> res;\\n        long long sum = 0;\\n        int i;\\n\\n        // Iterate a loop with an increment of 2, until we exceed or equal to finalSum, and keep appending index of every iteration to our final result.\\n        for(i=2; i<=finalSum; i+=2)\\n        {\\n            if(sum >= finalSum) break;\\n            sum += i;\\n            res.push_back(i);\\n        }\\n        \\n        // If the sum == finalSum, we achieved the objective and hence return the res\\n        if(sum == finalSum) return res;\\n\\n        // Otherwise we first calculate the margin by which we overstepped the finalSum. And we just add the calulated margin to the last element we added to res. And return the res. \\n        if(sum > finalSum) res.pop_back(), res[res.size()-1] = res[res.size()-1] + (finalSum-sum+i-2);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031423,
                "title": "python-binary-search-detailled-explanation",
                "content": "# Intuition\\nCheck if finalSum can be made of $$\\\\sum{2k} = k*(k+1)$$. If it can be made so, then our work is done. Or else, force it and handle duplicate.\\n\\n# Approach\\nWe need to find $$k$$ so that `finalSum <= k * (k + 1)`. \\n- If `k * (k + 1) != finalSum`, then let `r = k * (k + 1) - finalSum` and `A` the array of even number `A = [2i | 0 < i <= k]`. We need to substract last element of `A by r` to make sure that `sum(A) = finalSum`. That last operation introduce duplicate, so to get rid of it, we just need to do `A[previous last] += A[last]` and remove the `last` element. \\n\\n# Complexity\\n- Time complexity: $$O(log(finalSum) + k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2:\\n            return []\\n\\n        found = -1\\n        left, right = 0, finalSum\\n        \\n        while left <= right:\\n            k = (left + right) // 2\\n            if k*(k+1) >= finalSum:\\n                found = k\\n                right = k - 1\\n            else: left = k + 1\\n\\n        A = [i << 1 for i in range(1, found+1)]\\n        r = found*(found + 1) - finalSum\\n        if r > 0:\\n            x = A.pop() - r\\n            A[-1] += x\\n\\n        return A\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2:\\n            return []\\n\\n        found = -1\\n        left, right = 0, finalSum\\n        \\n        while left <= right:\\n            k = (left + right) // 2\\n            if k*(k+1) >= finalSum:\\n                found = k\\n                right = k - 1\\n            else: left = k + 1\\n\\n        A = [i << 1 for i in range(1, found+1)]\\n        r = found*(found + 1) - finalSum\\n        if r > 0:\\n            x = A.pop() - r\\n            A[-1] += x\\n\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988244,
                "title": "javascript-using-recursion-inclusion-exclusion-principle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} finalSum\\n * @return {number[]}\\n */\\n\\nvar maximumEvenSplit = function(finalSum) {\\n    let result = []\\n\\n    if(finalSum == 2) return [2];\\n\\n    var recursion = function(res = [], j = 2, sum = 0) {\\n        if(sum == finalSum) {\\n            if(res.length > result.length) {\\n                result = res.slice();\\n            }\\n        }\\n\\n        if(sum > finalSum) return;\\n        \\n        for(let i = j; i < finalSum; i += 2) {\\n            res.push(i);\\n            recursion(res, i + 2, sum + res[res.length - 1]);            \\n            res.pop();\\n        }\\n    }\\n\\n    recursion();\\n\\n    return result == undefined ? [] : result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} finalSum\\n * @return {number[]}\\n */\\n\\nvar maximumEvenSplit = function(finalSum) {\\n    let result = []\\n\\n    if(finalSum == 2) return [2];\\n\\n    var recursion = function(res = [], j = 2, sum = 0) {\\n        if(sum == finalSum) {\\n            if(res.length > result.length) {\\n                result = res.slice();\\n            }\\n        }\\n\\n        if(sum > finalSum) return;\\n        \\n        for(let i = j; i < finalSum; i += 2) {\\n            res.push(i);\\n            recursion(res, i + 2, sum + res[res.length - 1]);            \\n            res.pop();\\n        }\\n    }\\n\\n    recursion();\\n\\n    return result == undefined ? [] : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938361,
                "title": "greedy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBacktracking leeds to TLE, so we stick with greedy\\n\\n1) we build an ascending array [2,4,6,8,10,12,...]\\n   as soon as it starts to exceed the needed sum we stop\\n2) Then we should find a value we can remove to make the whole array sum to be equal to \\'finalSum\\'. We need to remove an element that is equal to \\'arrayTotalSum-finalSum\\', which is guaranteed to be in the array cause all numbers are even\\n\\nExample: `finalSum = 40`\\ngenerate: `[2,4,6,8,10,12]`, with total `sum = 42`\\nthen we remove 42-40=2, we get `[4,6,8,10,12]` with total sum=40\\nsince all numbers are even it is guaranteed there will be a target value to remove\\n\\n# Complexity\\n- Time complexity:\\n$$O(2n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Backtracking Leads to TLE\\n```\\n var maximumEvenSplit = function(finalSum) {\\n   if(finalSum%2!==0) return [];  \\n   let ans=[];\\n   const dfs=(start,sum,path)=>{\\n       if(sum>finalSum) return;\\n       if(sum===finalSum){\\n           if(ans.length<path.length) { \\n              ans=[...path];\\n              return;            \\n           }\\n       }\\n\\n       for(let i=start;i<=finalSum;i+=2){\\n           if(sum+i>finalSum) break;\\n           path.push(i);\\n           dfs(i+2,sum+i,path);\\n           path.pop();\\n       }\\n   }\\n   dfs(2,0,[]);\\n   return ans;\\n };\\n```\\n\\n# Greedy passed\\n```\\nvar maximumEvenSplit = function(finalSum) {\\n  if(finalSum%2!==0) return [];\\n  let res=[], sum=0,total=0;\\n  while(total<finalSum){\\n    sum=sum+2;\\n    total+=sum;\\n    res.push(sum);\\n  }\\n  if(finalSum===total) return res;\\n  else{\\n      const removeTarget=total-finalSum;\\n      const ind = res.indexOf(removeTarget);\\n      res.splice(ind,1);\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n var maximumEvenSplit = function(finalSum) {\\n   if(finalSum%2!==0) return [];  \\n   let ans=[];\\n   const dfs=(start,sum,path)=>{\\n       if(sum>finalSum) return;\\n       if(sum===finalSum){\\n           if(ans.length<path.length) { \\n              ans=[...path];\\n              return;            \\n           }\\n       }\\n\\n       for(let i=start;i<=finalSum;i+=2){\\n           if(sum+i>finalSum) break;\\n           path.push(i);\\n           dfs(i+2,sum+i,path);\\n           path.pop();\\n       }\\n   }\\n   dfs(2,0,[]);\\n   return ans;\\n };\\n```\n```\\nvar maximumEvenSplit = function(finalSum) {\\n  if(finalSum%2!==0) return [];\\n  let res=[], sum=0,total=0;\\n  while(total<finalSum){\\n    sum=sum+2;\\n    total+=sum;\\n    res.push(sum);\\n  }\\n  if(finalSum===total) return res;\\n  else{\\n      const removeTarget=total-finalSum;\\n      const ind = res.indexOf(removeTarget);\\n      res.splice(ind,1);\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866254,
                "title": "solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngreedy and Binary search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search \\n\\n# Complexity\\n- Time complexity:\\nO(log N) + O(sqrt(N))\\n\\n- Space complexity:\\n- O(sqrt(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\n   bool check(long long m,long long finalSum)\\n   {\\n       long long val = (m*(m+1))/2;\\n       if(val<=finalSum)\\n       {\\n           return true;\\n       }\\n       return false;\\n   }\\n\\n    vector<long long> maximumEvenSplit(long long finalSum) \\n    {\\n\\n        vector<long long >ans;\\n\\n        if(finalSum%2)\\n        {\\n            return ans;\\n        }\\n\\n        finalSum/=2;\\n\\n        long long  lo = 1;\\n        long long hi  = 1e5;\\n\\n        long long mid;\\n\\n        while(hi-lo>1)\\n        {\\n            mid = lo + (hi-lo)/2;\\n\\n            if(check(mid,finalSum))\\n            {\\n                lo = mid;\\n            }\\n            else\\n            {\\n                hi = mid-1;\\n            }\\n        }\\n\\n        // cout<<hi<<\" \"<<lo<<\"\\\\n\";\\n\\n        if(check(hi,finalSum))\\n        {\\n           long long val = (hi*(hi+1))/2;\\n\\n            val = finalSum - val;\\n\\n           int x;\\n           for(int i=hi;i>=1;i--)\\n           {\\n               x = i;\\n               if(val)\\n               {\\n                   x++;\\n                   val--;\\n               }\\n               x*=2;\\n               ans.push_back(x);\\n           }\\n        }\\n        else\\n        {\\n            long long val = (lo*(lo+1))/2;\\n\\n            val = finalSum - val;\\n\\n           int x;\\n           for(int i=lo;i>=1;i--)\\n           {\\n               x = i;\\n               if(val)\\n               {\\n                   x++;\\n                   val--;\\n               }\\n               x*=2;\\n               ans.push_back(x);\\n           }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n   bool check(long long m,long long finalSum)\\n   {\\n       long long val = (m*(m+1))/2;\\n       if(val<=finalSum)\\n       {\\n           return true;\\n       }\\n       return false;\\n   }\\n\\n    vector<long long> maximumEvenSplit(long long finalSum) \\n    {\\n\\n        vector<long long >ans;\\n\\n        if(finalSum%2)\\n        {\\n            return ans;\\n        }\\n\\n        finalSum/=2;\\n\\n        long long  lo = 1;\\n        long long hi  = 1e5;\\n\\n        long long mid;\\n\\n        while(hi-lo>1)\\n        {\\n            mid = lo + (hi-lo)/2;\\n\\n            if(check(mid,finalSum))\\n            {\\n                lo = mid;\\n            }\\n            else\\n            {\\n                hi = mid-1;\\n            }\\n        }\\n\\n        // cout<<hi<<\" \"<<lo<<\"\\\\n\";\\n\\n        if(check(hi,finalSum))\\n        {\\n           long long val = (hi*(hi+1))/2;\\n\\n            val = finalSum - val;\\n\\n           int x;\\n           for(int i=hi;i>=1;i--)\\n           {\\n               x = i;\\n               if(val)\\n               {\\n                   x++;\\n                   val--;\\n               }\\n               x*=2;\\n               ans.push_back(x);\\n           }\\n        }\\n        else\\n        {\\n            long long val = (lo*(lo+1))/2;\\n\\n            val = finalSum - val;\\n\\n           int x;\\n           for(int i=lo;i>=1;i--)\\n           {\\n               x = i;\\n               if(val)\\n               {\\n                   x++;\\n                   val--;\\n               }\\n               x*=2;\\n               ans.push_back(x);\\n           }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3864895,
                "title": "rust-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo maximize the number of splits we should minimize the number in each split\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* If the input is odd, there is no split possible\\n* Keep pushing numbers [2..=input] in 2-step to the output until the prospective current sum is greater than the input\\n* Add the difference between the input and the current sum to the last split\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_even_split(final_sum: i64) -> Vec<i64> {\\n        if final_sum % 2 != 0 { return vec![] }\\n\\n        let mut ans = Vec::new();\\n        let mut cur_sum = 0;\\n        for n in (2..=final_sum).step_by(2) {\\n            if cur_sum + n > final_sum {\\n                *ans.last_mut().unwrap() += final_sum - cur_sum;\\n                break;\\n            } else {\\n                ans.push(n);\\n            }\\n            cur_sum += n;\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_even_split(final_sum: i64) -> Vec<i64> {\\n        if final_sum % 2 != 0 { return vec![] }\\n\\n        let mut ans = Vec::new();\\n        let mut cur_sum = 0;\\n        for n in (2..=final_sum).step_by(2) {\\n            if cur_sum + n > final_sum {\\n                *ans.last_mut().unwrap() += final_sum - cur_sum;\\n                break;\\n            } else {\\n                ans.push(n);\\n            }\\n            cur_sum += n;\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837408,
                "title": "binary-search-beats-100-o-log-finalsum-solution",
                "content": "# Intuition\\nFind the maximum number of even numbers that can be used using binary search\\n\\n# Approach\\nIf the given number is odd, return an empty array directly.\\nWe already know that the smallest size can be 1. Let the maximum possible size that can be used be equal to finalSum/2.\\n\\nPick the middle number, mid, and try to form the sum using the first mid-1 even numbers and check if you can complete the sum with a number greater than all the numbers you have used. If yes, record size and try for a greater size.\\n\\nOnce you have the maximum possible size, fill in the array totalling to the size found. This array will be the answer. \\n\\n# Complexity\\n- Time complexity:\\nO(log(finalSum))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> ans;\\n\\n    bool check(long long num, long long tar){\\n        if(tar - num*(num-1) < 0) return false;\\n        tar -= num*(num-1);\\n        if(tar > (num-1)*2) return true;\\n        return false;\\n    }\\n\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2) return ans;\\n        long long r = finalSum/2;\\n        long long l = 1;\\n        long long ms = 0;\\n        while(l<=r){\\n            long long mid = r - (r-l)/2;\\n            if(check(mid,finalSum)){\\n                ms = mid;\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        for(long long i=1;i<=ms-1;i++){\\n            ans.push_back(i*2);\\n        }\\n        if(finalSum - ms*(ms-1) != 0)\\n            ans.push_back(finalSum - ms*(ms-1));\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> ans;\\n\\n    bool check(long long num, long long tar){\\n        if(tar - num*(num-1) < 0) return false;\\n        tar -= num*(num-1);\\n        if(tar > (num-1)*2) return true;\\n        return false;\\n    }\\n\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if(finalSum%2) return ans;\\n        long long r = finalSum/2;\\n        long long l = 1;\\n        long long ms = 0;\\n        while(l<=r){\\n            long long mid = r - (r-l)/2;\\n            if(check(mid,finalSum)){\\n                ms = mid;\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        for(long long i=1;i<=ms-1;i++){\\n            ans.push_back(i*2);\\n        }\\n        if(finalSum - ms*(ms-1) != 0)\\n            ans.push_back(finalSum - ms*(ms-1));\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836829,
                "title": "python3-beats-99",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum&1:\\n            return []\\n        res = []\\n        tot = 0\\n        for i in range(2,int(1e10),2):\\n            if tot+i <= finalSum:\\n                res.append(i)\\n                tot+=i\\n            else:\\n                break\\n        diff = finalSum - tot\\n        res[-1] += diff\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum&1:\\n            return []\\n        res = []\\n        tot = 0\\n        for i in range(2,int(1e10),2):\\n            if tot+i <= finalSum:\\n                res.append(i)\\n                tot+=i\\n            else:\\n                break\\n        diff = finalSum - tot\\n        res[-1] += diff\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816895,
                "title": "easy-to-understand-java-solution-beats-98-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart with the lowest even integer \\'2\\', and keep adding the lowest unique even integer possible until you reach the inputted \\'finalSum\\', and this will guarantee that you have the maximum number of unique even numbers to be added to reach the target.\\n\\nSee comments in code for finer details.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        //initialize arraylist to return\\n        List ans = new ArrayList();\\n        //if input number is odd, return an empty list\\n        if (finalSum % 2 == 1)\\n        {\\n            return ans;\\n        }\\n        //curSum keeps track of the current sum as we go\\n        long curSum = 0;\\n        //numToAdd stores the next even integer to add to the curSum\\n        long numToAdd = 2;\\n        while (curSum < finalSum)\\n        {\\n            //check to see if the next unique even number can be added\\n            long potentialNext = curSum + numToAdd;\\n            if (potentialNext > finalSum)\\n            {\\n                //if reached here, then the remaining number to add is not unique\\n                //remove the previous number added to list and add the remaining difference\\n                long difference = potentialNext - finalSum;\\n                numToAdd = (numToAdd - 2) + numToAdd - difference;\\n                ans.remove(ans.size() - 1);\\n                ans.add(numToAdd);\\n                break;\\n            }\\n            //if next unique even number is valid, add it to the list, and increment + loop\\n            ans.add(numToAdd);\\n            curSum += numToAdd;\\n            numToAdd += 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Long> maximumEvenSplit(long finalSum) {\\n        //initialize arraylist to return\\n        List ans = new ArrayList();\\n        //if input number is odd, return an empty list\\n        if (finalSum % 2 == 1)\\n        {\\n            return ans;\\n        }\\n        //curSum keeps track of the current sum as we go\\n        long curSum = 0;\\n        //numToAdd stores the next even integer to add to the curSum\\n        long numToAdd = 2;\\n        while (curSum < finalSum)\\n        {\\n            //check to see if the next unique even number can be added\\n            long potentialNext = curSum + numToAdd;\\n            if (potentialNext > finalSum)\\n            {\\n                //if reached here, then the remaining number to add is not unique\\n                //remove the previous number added to list and add the remaining difference\\n                long difference = potentialNext - finalSum;\\n                numToAdd = (numToAdd - 2) + numToAdd - difference;\\n                ans.remove(ans.size() - 1);\\n                ans.add(numToAdd);\\n                break;\\n            }\\n            //if next unique even number is valid, add it to the list, and increment + loop\\n            ans.add(numToAdd);\\n            curSum += numToAdd;\\n            numToAdd += 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809120,
                "title": "greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        if(finalSum % 2 != 0) return {};\\n        long long currSum = 0;\\n        long long i=2;\\n        while(currSum < finalSum){\\n           currSum += i;\\n           i+= 2;\\n        }\\n        vector<long long> res;\\n        long long k = 2;\\n        while(k < i){\\n            if(k != currSum - finalSum){\\n                res.push_back(k);\\n            }\\n            k+=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        \\n        if(finalSum % 2 != 0) return {};\\n        long long currSum = 0;\\n        long long i=2;\\n        while(currSum < finalSum){\\n           currSum += i;\\n           i+= 2;\\n        }\\n        vector<long long> res;\\n        long long k = 2;\\n        while(k < i){\\n            if(k != currSum - finalSum){\\n                res.push_back(k);\\n            }\\n            k+=2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801475,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    // if it is even it must be possible\\n    // we start by having all the lowest even numbers\\n    // then we shift the most right number\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if (finalSum % 2 == 1) return {};\\n        long long sum = 0, cur = 2;\\n        vector<long long> ans;\\n        while (finalSum - cur >= sum){\\n            ans.push_back(cur);\\n            sum += cur;\\n            cur += 2;\\n        }\\n        ans.back() += finalSum - sum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // if it is even it must be possible\\n    // we start by having all the lowest even numbers\\n    // then we shift the most right number\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n        if (finalSum % 2 == 1) return {};\\n        long long sum = 0, cur = 2;\\n        vector<long long> ans;\\n        while (finalSum - cur >= sum){\\n            ans.push_back(cur);\\n            sum += cur;\\n            cur += 2;\\n        }\\n        ans.back() += finalSum - sum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793678,
                "title": "pytthon-backtracking-solution",
                "content": "# Intuition\\nIn the problem, we have to explore all possible solutions to a problem by trying out various choices and undoing those choices when they lead to dead-ends. Thus we now know that we have to use Backtracking.\\n\\n# Approach\\nWe follow typical backtracking approach:\\n[Base case: to know when we reaach our goal]\\n1. Take the current iteration\\n2. Pass it to further iterations\\n3. Remove the iteration\\n\\nIn this problem, we need to make sure we leave the further check as soon as we reach our solution. We will be getting the best solution (and not have to check further) as we will be iterating from the smaller numbers, thus getting the list of maximum numbers as our answer.\\n\\n\\n# Complexity\\nRuntime: 1136 ms\\nBeats: 5.10%\\nMemory: 166.8 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 != 0: return []\\n        ans = []\\n        def dfs(curRes, ind, rem):\\n            nonlocal ans\\n            #base case\\n            if rem <= 0:\\n                if len(ans) < len(curRes):\\n                    ans = curRes[:]\\n                    return True\\n                return\\n            for i in range(ind,finalSum+2, 2):\\n                if rem - i < 0: \\n                    break\\n                #1. take\\n                curRes.append(i)\\n                #2. Pass further\\n                if dfs(curRes,ind+2,rem-i):\\n                    return True\\n                #3. Leave it\\n                curRes.pop()\\n        dfs([],2,finalSum)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\\n        if finalSum % 2 != 0: return []\\n        ans = []\\n        def dfs(curRes, ind, rem):\\n            nonlocal ans\\n            #base case\\n            if rem <= 0:\\n                if len(ans) < len(curRes):\\n                    ans = curRes[:]\\n                    return True\\n                return\\n            for i in range(ind,finalSum+2, 2):\\n                if rem - i < 0: \\n                    break\\n                #1. take\\n                curRes.append(i)\\n                #2. Pass further\\n                if dfs(curRes,ind+2,rem-i):\\n                    return True\\n                #3. Leave it\\n                curRes.pop()\\n        dfs([],2,finalSum)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727545,
                "title": "greedy-c-o-n",
                "content": "# Approach\\n\\n1. If the `finalSum` is odd (`finalSum % 2 != 0`), return an empty list since no valid split is possible.\\n2. Initialize an empty vector called `ans` to store the split integers.\\n3. Iterate from 2 up to `finalSum` with a step size of 2 (considering only even integers).\\n   - In each iteration, add the current even integer to the `ans` vector.\\n   - Subtract the current even integer from `finalSum`.\\n4. If there is a remaining value in `finalSum` after the loop, add it to the last element of the `ans` vector.\\n5. Return the `ans` vector, which represents a valid split of `finalSum` containing the maximum number of integers.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n    if(finalSum%2!=0) return {};\\n    vector<long long> ans;\\n    for(long long i=2;i<=finalSum;i+=2){\\n       ans.push_back(i);\\n       finalSum-=i;\\n    }\\n    ans.back() += finalSum;\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long> maximumEvenSplit(long long finalSum) {\\n    if(finalSum%2!=0) return {};\\n    vector<long long> ans;\\n    for(long long i=2;i<=finalSum;i+=2){\\n       ans.push_back(i);\\n       finalSum-=i;\\n    }\\n    ans.back() += finalSum;\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706363,
                "title": "maximum-split-of-positive-even-integers-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n  \\n      vector<long long> ans;\\n\\n      if(!(finalSum % 2 == 0)){\\n        return ans;\\n      }\\n      long long i=2,sum = 0;\\n      while( sum + i <= finalSum ){\\n        sum += i;\\n        ans.push_back(i);\\n        i+=2;\\n      }\\n\\n      ans.back()+=(finalSum-sum);\\n      \\n      return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long finalSum) {\\n  \\n      vector<long long> ans;\\n\\n      if(!(finalSum % 2 == 0)){\\n        return ans;\\n      }\\n      long long i=2,sum = 0;\\n      while( sum + i <= finalSum ){\\n        sum += i;\\n        ans.push_back(i);\\n        i+=2;\\n      }\\n\\n      ans.back()+=(finalSum-sum);\\n      \\n      return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689681,
                "title": "greedy",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart from 2 and remove as many even numbers as we can from s until it is equal to current even number we are removing.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long s) {\\n        vector<long long> ans;\\n        if(s%2 != 0) return ans;\\n        int n = 2;\\n        while((s-n) > n){\\n            ans.push_back(n);\\n            s -= n;\\n            n += 2;\\n        }\\n        ans.push_back(s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumEvenSplit(long long s) {\\n        vector<long long> ans;\\n        if(s%2 != 0) return ans;\\n        int n = 2;\\n        while((s-n) > n){\\n            ans.push_back(n);\\n            s -= n;\\n            n += 2;\\n        }\\n        ans.push_back(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1785473,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Backtracking gives TLE. Go for greedy."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Can anybody explain how we know when to adopt a greedy approach if backtracking does not work (e.g., TLE)?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have to say, greedy is always hard for me. ("
                    },
                    {
                        "username": "najim",
                        "content": "Is it really necessary for the return type of the method `public List<Long> maximumEvenSplit(long finalSum)` to be  List<Long> or  List<Integer> would be sufficient? Shouldn\\'t the maximum item in the resultant list be sqrt(10^10)? "
                    },
                    {
                        "username": "deepal15",
                        "content": " ```\\nclass Solution {\\n    func maximumEvenSplit(_ finalSum: Int) -> [Int] {\\n        var result = [Int]()\\n        var temp = [Int]()\\n        var index = 2\\n        guard finalSum % 2 == 0 else { return result }\\n        f(index, finalSum, &temp, &result)\\n        return result\\n    }\\n\\n    private func f(_ in @dex: Int,\\n                    _ finalSum: Int,\\n                    _ temp: inout [Int],\\n                    _ result: inout [Int]) {\\n        if finalSum == 0 {\\n            result.append(contentsOf: temp)\\n            return\\n        }\\n\\n        for i in stride(from: index, to: finalSum + 1, by: 2) {\\n            temp.append(i)\\n            f(i + 2, finalSum - i, &temp, &result)\\n            temp.removeLast()\\n\\n            if !result.isEmpty { return }\\n        }\\n    }\\n}\\n```\\n1. Incrementing `i` by 2 in `for` loop\\n2. Ignore adding, removing  in constant time and copying to the another data structure.\\n3. Each recursion\\'s `for` loop starts from `index` to `finalSum` which is decrementing each time\\n\\nWhat will be the time complexity of this? "
                    }
                ]
            },
            {
                "id": 1881046,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Backtracking gives TLE. Go for greedy."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Can anybody explain how we know when to adopt a greedy approach if backtracking does not work (e.g., TLE)?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have to say, greedy is always hard for me. ("
                    },
                    {
                        "username": "najim",
                        "content": "Is it really necessary for the return type of the method `public List<Long> maximumEvenSplit(long finalSum)` to be  List<Long> or  List<Integer> would be sufficient? Shouldn\\'t the maximum item in the resultant list be sqrt(10^10)? "
                    },
                    {
                        "username": "deepal15",
                        "content": " ```\\nclass Solution {\\n    func maximumEvenSplit(_ finalSum: Int) -> [Int] {\\n        var result = [Int]()\\n        var temp = [Int]()\\n        var index = 2\\n        guard finalSum % 2 == 0 else { return result }\\n        f(index, finalSum, &temp, &result)\\n        return result\\n    }\\n\\n    private func f(_ in @dex: Int,\\n                    _ finalSum: Int,\\n                    _ temp: inout [Int],\\n                    _ result: inout [Int]) {\\n        if finalSum == 0 {\\n            result.append(contentsOf: temp)\\n            return\\n        }\\n\\n        for i in stride(from: index, to: finalSum + 1, by: 2) {\\n            temp.append(i)\\n            f(i + 2, finalSum - i, &temp, &result)\\n            temp.removeLast()\\n\\n            if !result.isEmpty { return }\\n        }\\n    }\\n}\\n```\\n1. Incrementing `i` by 2 in `for` loop\\n2. Ignore adding, removing  in constant time and copying to the another data structure.\\n3. Each recursion\\'s `for` loop starts from `index` to `finalSum` which is decrementing each time\\n\\nWhat will be the time complexity of this? "
                    }
                ]
            },
            {
                "id": 2014719,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Backtracking gives TLE. Go for greedy."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Can anybody explain how we know when to adopt a greedy approach if backtracking does not work (e.g., TLE)?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have to say, greedy is always hard for me. ("
                    },
                    {
                        "username": "najim",
                        "content": "Is it really necessary for the return type of the method `public List<Long> maximumEvenSplit(long finalSum)` to be  List<Long> or  List<Integer> would be sufficient? Shouldn\\'t the maximum item in the resultant list be sqrt(10^10)? "
                    },
                    {
                        "username": "deepal15",
                        "content": " ```\\nclass Solution {\\n    func maximumEvenSplit(_ finalSum: Int) -> [Int] {\\n        var result = [Int]()\\n        var temp = [Int]()\\n        var index = 2\\n        guard finalSum % 2 == 0 else { return result }\\n        f(index, finalSum, &temp, &result)\\n        return result\\n    }\\n\\n    private func f(_ in @dex: Int,\\n                    _ finalSum: Int,\\n                    _ temp: inout [Int],\\n                    _ result: inout [Int]) {\\n        if finalSum == 0 {\\n            result.append(contentsOf: temp)\\n            return\\n        }\\n\\n        for i in stride(from: index, to: finalSum + 1, by: 2) {\\n            temp.append(i)\\n            f(i + 2, finalSum - i, &temp, &result)\\n            temp.removeLast()\\n\\n            if !result.isEmpty { return }\\n        }\\n    }\\n}\\n```\\n1. Incrementing `i` by 2 in `for` loop\\n2. Ignore adding, removing  in constant time and copying to the another data structure.\\n3. Each recursion\\'s `for` loop starts from `index` to `finalSum` which is decrementing each time\\n\\nWhat will be the time complexity of this? "
                    }
                ]
            },
            {
                "id": 1736219,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Backtracking gives TLE. Go for greedy."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Can anybody explain how we know when to adopt a greedy approach if backtracking does not work (e.g., TLE)?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have to say, greedy is always hard for me. ("
                    },
                    {
                        "username": "najim",
                        "content": "Is it really necessary for the return type of the method `public List<Long> maximumEvenSplit(long finalSum)` to be  List<Long> or  List<Integer> would be sufficient? Shouldn\\'t the maximum item in the resultant list be sqrt(10^10)? "
                    },
                    {
                        "username": "deepal15",
                        "content": " ```\\nclass Solution {\\n    func maximumEvenSplit(_ finalSum: Int) -> [Int] {\\n        var result = [Int]()\\n        var temp = [Int]()\\n        var index = 2\\n        guard finalSum % 2 == 0 else { return result }\\n        f(index, finalSum, &temp, &result)\\n        return result\\n    }\\n\\n    private func f(_ in @dex: Int,\\n                    _ finalSum: Int,\\n                    _ temp: inout [Int],\\n                    _ result: inout [Int]) {\\n        if finalSum == 0 {\\n            result.append(contentsOf: temp)\\n            return\\n        }\\n\\n        for i in stride(from: index, to: finalSum + 1, by: 2) {\\n            temp.append(i)\\n            f(i + 2, finalSum - i, &temp, &result)\\n            temp.removeLast()\\n\\n            if !result.isEmpty { return }\\n        }\\n    }\\n}\\n```\\n1. Incrementing `i` by 2 in `for` loop\\n2. Ignore adding, removing  in constant time and copying to the another data structure.\\n3. Each recursion\\'s `for` loop starts from `index` to `finalSum` which is decrementing each time\\n\\nWhat will be the time complexity of this? "
                    }
                ]
            },
            {
                "id": 1732023,
                "content": [
                    {
                        "username": "kr_vishnu",
                        "content": "Backtracking gives TLE. Go for greedy."
                    },
                    {
                        "username": "jensenlwt",
                        "content": "Can anybody explain how we know when to adopt a greedy approach if backtracking does not work (e.g., TLE)?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I have to say, greedy is always hard for me. ("
                    },
                    {
                        "username": "najim",
                        "content": "Is it really necessary for the return type of the method `public List<Long> maximumEvenSplit(long finalSum)` to be  List<Long> or  List<Integer> would be sufficient? Shouldn\\'t the maximum item in the resultant list be sqrt(10^10)? "
                    },
                    {
                        "username": "deepal15",
                        "content": " ```\\nclass Solution {\\n    func maximumEvenSplit(_ finalSum: Int) -> [Int] {\\n        var result = [Int]()\\n        var temp = [Int]()\\n        var index = 2\\n        guard finalSum % 2 == 0 else { return result }\\n        f(index, finalSum, &temp, &result)\\n        return result\\n    }\\n\\n    private func f(_ in @dex: Int,\\n                    _ finalSum: Int,\\n                    _ temp: inout [Int],\\n                    _ result: inout [Int]) {\\n        if finalSum == 0 {\\n            result.append(contentsOf: temp)\\n            return\\n        }\\n\\n        for i in stride(from: index, to: finalSum + 1, by: 2) {\\n            temp.append(i)\\n            f(i + 2, finalSum - i, &temp, &result)\\n            temp.removeLast()\\n\\n            if !result.isEmpty { return }\\n        }\\n    }\\n}\\n```\\n1. Incrementing `i` by 2 in `for` loop\\n2. Ignore adding, removing  in constant time and copying to the another data structure.\\n3. Each recursion\\'s `for` loop starts from `index` to `finalSum` which is decrementing each time\\n\\nWhat will be the time complexity of this? "
                    }
                ]
            }
        ]
    }
]