[
    {
        "title": "Maximal Rectangle",
        "question_content": "Given a rows x cols&nbsp;binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n&nbsp;\nExample 1:\n\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.\n\nExample 2:\n\nInput: matrix = [[\"0\"]]\nOutput: 0\n\nExample 3:\n\nInput: matrix = [[\"1\"]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\trows == matrix.length\n\tcols == matrix[i].length\n\t1 <= row, cols <= 200\n\tmatrix[i][j] is '0' or '1'.",
        "solutions": [
            {
                "id": 29054,
                "title": "share-my-dp-solution",
                "content": "The DP solution proceeds row by row, starting from the first row. Let the maximal rectangle area at row i and column j be computed by [right(i,j) - left(i,j)]*height(i,j).\\n\\nAll the 3 variables left, right, and height can be determined by the information from previous row, and also information from the current row. So it can be regarded as a DP solution. The transition equations are:\\n\\n> left(i,j) = max(left(i-1,j), cur_left), cur_left can be determined from the current row\\n\\n> right(i,j) = min(right(i-1,j), cur_right), cur_right can be determined from the current row \\n\\n> height(i,j) = height(i-1,j) + 1,  if matrix[i][j]=='1'; \\n\\n> height(i,j) = 0,  if matrix[i][j]=='0'\\n\\n\\n\\nThe code is as below. The loops can be combined for speed but I separate them for more clarity of the algorithm.\\n\\n    class Solution {public:\\n    int maximalRectangle(vector<vector<char> > &matrix) {\\n        if(matrix.empty()) return 0;\\n        const int m = matrix.size();\\n        const int n = matrix[0].size();\\n        int left[n], right[n], height[n];\\n        fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0);\\n        int maxA = 0;\\n        for(int i=0; i<m; i++) {\\n            int cur_left=0, cur_right=n; \\n            for(int j=0; j<n; j++) { // compute height (can do this from either side)\\n                if(matrix[i][j]=='1') height[j]++; \\n                else height[j]=0;\\n            }\\n            for(int j=0; j<n; j++) { // compute left (from left to right)\\n                if(matrix[i][j]=='1') left[j]=max(left[j],cur_left);\\n                else {left[j]=0; cur_left=j+1;}\\n            }\\n            // compute right (from right to left)\\n            for(int j=n-1; j>=0; j--) {\\n                if(matrix[i][j]=='1') right[j]=min(right[j],cur_right);\\n                else {right[j]=n; cur_right=j;}    \\n            }\\n            // compute the area of rectangle (can do this from either side)\\n            for(int j=0; j<n; j++)\\n                maxA = max(maxA,(right[j]-left[j])*height[j]);\\n        }\\n        return maxA;\\n    }\\n};\\n\\n\\nIf you think this algorithm is not easy to understand, you can try this example:\\n\\n    0 0 0 1 0 0 0 \\n    0 0 1 1 1 0 0 \\n    0 1 1 1 1 1 0\\n\\nThe vector \"left\" and \"right\" from row 0 to row 2 are as follows\\n\\nrow 0:\\n \\n\\n    l: 0 0 0 3 0 0 0\\n    r: 7 7 7 4 7 7 7\\n\\nrow 1:\\n\\n    l: 0 0 2 3 2 0 0\\n    r: 7 7 5 4 5 7 7 \\n\\nrow 2:\\n\\n    l: 0 1 2 3 2 1 0\\n    r: 7 6 5 4 5 6 7\\n\\nThe vector \"left\" is computing the left boundary. Take (i,j)=(1,3) for example. On current row 1, the left boundary is at j=2. However, because matrix[1][3] is 1, you need to consider the left boundary on previous row as well, which is 3. So the real left boundary at (1,3) is 3. \\n\\nI hope this additional explanation makes things clearer.",
                "solutionTags": [],
                "code": "class Solution {public:\\n    int maximalRectangle(vector<vector<char> > &matrix) {\\n        if(matrix.empty()) return 0;\\n        const int m = matrix.size();\\n        const int n = matrix[0].size();\\n        int left[n], right[n], height[n];\\n        fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0);\\n        int maxA = 0;\\n        for(int i=0; i<m; i++) {\\n            int cur_left=0, cur_right=n; \\n            for(int j=0; j<n; j++) { // compute height (can do this from either side)\\n                if(matrix[i][j]=='1') height[j]++; \\n                else height[j]=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 29064,
                "title": "a-o-n-2-solution-based-on-largest-rectangle-in-histogram",
                "content": "This question is similar as [\\\\[Largest Rectangle in Histogram\\\\]][1]:\\n\\nYou can maintain a row length of Integer array H recorded its height of '1's, and scan and update row by row to find out the largest rectangle of each row.\\n\\nFor each row, if matrix[row][i] == '1'. H[i] +=1, or reset the H[i] to zero.\\nand accroding the algorithm of [Largest Rectangle in Histogram], to update the maximum area.\\n\\n    public class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n            if (matrix==null||matrix.length==0||matrix[0].length==0)\\n                return 0;\\n            int cLen = matrix[0].length;    // column length\\n            int rLen = matrix.length;       // row length\\n            // height array \\n            int[] h = new int[cLen+1];\\n            h[cLen]=0;\\n            int max = 0;\\n            \\n            \\n            for (int row=0;row<rLen;row++) {\\n                Stack<Integer> s = new Stack<Integer>();\\n                for (int i=0;i<cLen+1;i++) {\\n                    if (i<cLen)\\n                        if(matrix[row][i]=='1')\\n                            h[i]+=1;\\n                        else h[i]=0;\\n                    \\n                    if (s.isEmpty()||h[s.peek()]<=h[i])\\n                        s.push(i);\\n                    else {\\n                        while(!s.isEmpty()&&h[i]<h[s.peek()]){\\n                            int top = s.pop();\\n                            int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1));\\n                            if (area>max)\\n                                max = area;\\n                        }\\n                        s.push(i);\\n                    }\\n                }\\n            }\\n            return max;\\n        }\\n    }\\n\\n  [1]: http://oj.leetcode.com/problems/largest-rectangle-in-histogram/",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n            if (matrix==null||matrix.length==0||matrix[0].length==0)\\n                return 0;\\n            int cLen = matrix[0].length;    // column length\\n            int rLen = matrix.length;       // row length\\n            // height array \\n            int[] h = new int[cLen+1];\\n            h[cLen]=0;\\n            int max = 0;\\n            \\n            \\n            for (int row=0;row<rLen;row++) {\\n                Stack<Integer> s = new Stack<Integer>();\\n                for (int i=0;i<cLen+1;i++) {\\n                    if (i<cLen)\\n                        if(matrix[row][i]=='1')\\n                            h[i]+=1;\\n                        else h[i]=0;\\n                    \\n                    if (s.isEmpty()||h[s.peek()]<=h[i])\\n                        s.push(i);\\n                    else {\\n                        while(!s.isEmpty()&&h[i]<h[s.peek()]){\\n                            int top = s.pop();\\n                            int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1));\\n                            if (area>max)\\n                                max = area;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 29065,
                "title": "ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram",
                "content": "    def maximalRectangle(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n = len(matrix[0])\\n        height = [0] * (n + 1)\\n        ans = 0\\n        for row in matrix:\\n            for i in xrange(n):\\n                height[i] = height[i] + 1 if row[i] == '1' else 0\\n            stack = [-1]\\n            for i in xrange(n + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - 1 - stack[-1]\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        return ans\\n\\n    # 65 / 65 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 120 ms\\n    # 100%\\n\\nThe solution is based on [largest rectangle in histogram][1] solution. Every row in the matrix is viewed as the ground with some buildings on it. The building height is the count of consecutive 1s from that row to above rows. The rest is then the same as [this solution for largest rectangle in histogram][2]\\n\\n\\n  [1]: https://leetcode.com/problems/largest-rectangle-in-histogram/\\n  [2]: https://leetcode.com/discuss/65647/ac-python-clean-solution-using-stack-76ms",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def maximalRectangle(self, matrix):\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n = len(matrix[0])\\n        height = [0] * (n + 1)\\n        ans = 0\\n        for row in matrix:\\n            for i in xrange(n):\\n                height[i] = height[i] + 1 if row[i] == '1' else 0\\n            stack = [-1]\\n            for i in xrange(n + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - 1 - stack[-1]\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        return ans\\n\\n    # 65 / 65 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 120 ms\\n    # 100%\\n\\nThe solution is based on [largest rectangle in histogram][1] solution. Every row in the matrix is viewed as the ground with some buildings on it. The building height is the count of consecutive 1s from that row to above rows. The rest is then the same as [this solution for largest rectangle in histogram][2]\\n\\n\\n  [1]: https://leetcode.com/problems/largest-rectangle-in-histogram/\\n  [2]: https://leetcode.com/discuss/65647/ac-python-clean-solution-using-stack-76ms",
                "codeTag": "Python3"
            },
            {
                "id": 29055,
                "title": "my-java-solution-based-on-maximum-rectangle-in-histogram-with-explanation",
                "content": "We can apply the maximum in histogram in each row of the 2D matrix. What we need is to maintain an int array for each row, which represent for the height of the histogram.\\n\\nPlease refer to https://leetcode.com/problems/largest-rectangle-in-histogram/      first.\\n\\n\\nSuppose there is a 2D matrix like\\n\\n1 1 0 1 0 1\\n\\n0 1 0 0 1 1\\n\\n1 1 1 1 0 1\\n\\n1 1 1 1 0 1\\n\\n\\nFirst initiate the height array as 1 1 0 1 0 1, which is just a copy of the first row. Then we can easily calculate the max area is 2.\\n\\nThen update the array. We scan the second row, when the matrix[1][i] is 0, set the height[i] to 0; else height[i] += 1, which means the height has increased by 1. So the height array again becomes 0 2 0 0 1 2. The max area now is also 2.\\n\\nApply the same method until we scan the whole matrix. the last height arrays is 2 4 2 2 0 4, so the max area has been found as 2 * 4 = 8.\\n\\nThen reason we scan the whole matrix is that the maximum value may appear in any row of the height.\\n\\n\\nCode as follows: \\n\\n    public class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\\n        \\n        int[] height = new int[matrix[0].length];\\n        for(int i = 0; i < matrix[0].length; i ++){\\n            if(matrix[0][i] == '1') height[i] = 1;\\n        }\\n        int result = largestInLine(height);\\n        for(int i = 1; i < matrix.length; i ++){\\n            resetHeight(matrix, height, i);\\n            result = Math.max(result, largestInLine(height));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void resetHeight(char[][] matrix, int[] height, int idx){\\n        for(int i = 0; i < matrix[0].length; i ++){\\n            if(matrix[idx][i] == '1') height[i] += 1;\\n            else height[i] = 0;\\n        }\\n    }    \\n    \\n    public int largestInLine(int[] height) {\\n        if(height == null || height.length == 0) return 0;\\n        int len = height.length;\\n        Stack<Integer> s = new Stack<Integer>();\\n        int maxArea = 0;\\n        for(int i = 0; i <= len; i++){\\n            int h = (i == len ? 0 : height[i]);\\n            if(s.isEmpty() || h >= height[s.peek()]){\\n                s.push(i);\\n            }else{\\n                int tp = s.pop();\\n                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));\\n                i--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n    \\n\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\\n        \\n        int[] height = new int[matrix[0].length];\\n        for(int i = 0; i < matrix[0].length; i ++){\\n            if(matrix[0][i] == '1') height[i] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1604254,
                "title": "c-simple-solution-w-explanation-optimizations-from-brute-force-to-dp",
                "content": "We are given a matrix `M` and required to find the area of largest rectangle having all `\"1\"` within it.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nThe most brute force way of solving this problem would be to simply consider each and every possible rectangle and consider the maximal out of the rectangles which only consists of `1` in them\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        for(int start_i = 0; start_i < m; start_i++) \\n            for(int start_j = 0; start_j < n; start_j++) \\n                for(int end_i = start_i; end_i < m; end_i++) \\n                    for(int end_j = start_j; end_j < n; end_j++) {\\n                        bool allOnes = true;\\n                        for(int i = start_i; i <= end_i && allOnes; i++) \\n                            for(int j = start_j; j <= end_j && allOnes; j++) \\n                                if(M[i][j] != \\'1\\') allOnes = false;                           \\n                        ans = max(ans, allOnes * (end_i - start_i + 1) * (end_j - start_j + 1));\\n                    }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O((MN)<sup>3</sup>)</code>\\n***Space Complexity :*** <code>O(1)</code>\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Brute-Force)***\\n\\nInstead of forming every rectangle, then checking validity of rectangle, we can optimize the brute-force by only considering valid rectangles. For this, we can start from every cell and consider valid rectangle starting from that cell. \\n* Let the current cell be at `(i, j)`.\\n* We first consider `i`th row and find maximum column length of 1s starting from `M[i][j]`.\\n* Then move to `i+1`th row and find maximum column length of 1s starting from `M[i+1][j]`. Take minimum of all lengths and find the area and keep updating max area.\\n* Continue similar process till you reach last row and then repeat the process for all other cells as well.\\n* Finally return maximum area found from all valid rectangles.\\n\\nThe below image illustrates the process for first two cells of the grid -\\n\\n<img src=\"https://assets.leetcode.com/users/images/6a6c48d6-32be-4a61-8408-309b3217cb3c_1638279969.659467.png\" />\\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                for(int row = i, colLen = n, col; row < m && M[row][j] == \\'1\\'; row++) {\\n                    for(col = j; col < n && M[row][col] == \\'1\\'; col++);\\n                    colLen = min(colLen, col-j);\\n                    ans = max(ans, (row-i+1) * colLen);\\n                }\\n            \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O((MN)<sup>2</sup>)</code>\\n***Space Complexity :*** <code>O(1)</code>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Pre-compute consecutive 1s to the right / DP)***\\n\\nWe can improve previous solution if we pre-compute the maximum number of 1s to the right of each cell. This will allow us to save save the iteration for finding maximum column length of 1s starting from `M[i][j]` in the previous solution. After a pre-computation which requires `O(MN)` time, we can compute the maximum column length in just `O(1)` essentially eliminating a loop from above solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        vector<vector<short>> dp(m+1, vector<short>(n+1));\\n        for(int i = m-1; ~i; i--) \\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = M[i][j] == \\'1\\' ? dp[i][j+1] + 1 : 0;\\n                    \\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                for(int row = i, colLen = n; row < m && M[row][j] == \\'1\\'; row++)\\n                    ans = max(ans, (row-i+1) * (colLen = min(colLen, dp[row][j]*1)));\\n                    \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(M<sup>2</sup>N)</code>\\n***Space Complexity :*** <code>O(MN)</code>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Pre-compute consecutive 1s to right + number of rows above & below having atleast same number of consecutive 1s / DP)***\\n\\nWe can eliminate one more loop in the above solution before we arrive at the optimal solution. In previous approach, we pre-computed the number of consecutive 1s to the right of each cell (referred as `dp[i][j]` henceforth) allowing us to eliminate iterate whole columns for each row. But, still we required to iterate from each row till bottom because we didnt know if other rows below had smaller `dp[i][j]` and thus we had to keep adjusting `colLen` to hold minimum `dp[i][j]` checking for each row till the bottom.\\n\\nTo avoid this, we can take a slightly different approach and only **check the consecutive number of rows above and below, that have the same or greater `dp[i][j]`**. This ensures that using the current cell, we can form a rectangle of width `dp[i][j]` and use current row + number of rows above & below having same or greater `dp[i][j]`. We must note that this approach ensures that we only considering maximal area rectangle having width `dp[i][j]`, for each cell under consideration, since we are also using the max possible height for that width.\\n\\n**Computing `up` and `down`:**\\n\\nNow, the only thing remaining is how to calculate number of rows above and below having atleast `dp[i][j]`. This can be calculated from `dp` using a monotonic stack. For this, we compute two matrices `up` and `down` where `up[i][j]` will denote consecutive number of rows above `i` (and including current)  having corresponding value of `dp` for each row as atleast `dp[i][j]` and similarly `down[i][j]` denotes consecutive number of rows below `j` (and including current) each having corresponding value of `dp` for each rows as atleast equal to `dp[i][j]`.\\n\\nFor calculating `up` matrix- \\n1. We iterate from 1st row till last row. \\n2. Each time, we get a row having `dp[i][j] >= dp[s.top()][j]`, we push it into stack. \\n3. If we get a row having `dp[i][j] < dp[s.top()][j]`, we pop from stack until we find row index in stack having atleast `dp[i][j]`. This helps maintain the monotonous stack. \\n4. At each iteration, the value of `up[i][j]` is equal to `i-s.top()` (current row - row index on top of stack having atleast `dp[i][j]` for that row), i.e, number of consecutive rows above having atleast `dp[i][j]`.\\n\\nWe follow a similar approach for `down` as well.\\n\\n\\n(*PS:* This approach\\'s logic seems to be similar to other solutions based on largest rectangle in histogram, but with different implementation. Since my brute-force approaches were based on this, I have kept it same. The only difference is that for each cell, I have just used width and calculated `up` & `down` having same width instead of using height and calculating `left` & `right` having same height.)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        vector<vector<short>> dp(m+1, vector<short>(n+1)), up(m, vector<short>(n,1)), down(up);\\n        for(int i = m-1; ~i; i--) \\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = M[i][j] == \\'1\\' ? dp[i][j+1] + 1 : 0;\\n        \\n        stack<int> s;\\n        for(int j = 0; j < n; j++) {\\n            s = stack<int>();\\n            for(int i = 0; i < m; i++) {\\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\\n                up[i][j] = i - (size(s) ? s.top() : -1);\\n                s.push(i);\\n            }\\n            s = stack<int>();\\n            for(int i = m-1; ~i; i--) {\\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\\n                down[i][j] = (size(s) ? s.top() : m) - i;\\n                s.push(i);\\n            }            \\n        }\\n\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                ans = max(ans, dp[i][j] * (up[i][j]+down[i][j]-1));\\n                    \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(MN)</code>\\n***Space Complexity :*** <code>O(MN)</code>\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        for(int start_i = 0; start_i < m; start_i++) \\n            for(int start_j = 0; start_j < n; start_j++) \\n                for(int end_i = start_i; end_i < m; end_i++) \\n                    for(int end_j = start_j; end_j < n; end_j++) {\\n                        bool allOnes = true;\\n                        for(int i = start_i; i <= end_i && allOnes; i++) \\n                            for(int j = start_j; j <= end_j && allOnes; j++) \\n                                if(M[i][j] != \\'1\\') allOnes = false;                           \\n                        ans = max(ans, allOnes * (end_i - start_i + 1) * (end_j - start_j + 1));\\n                    }\\n\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                for(int row = i, colLen = n, col; row < m && M[row][j] == \\'1\\'; row++) {\\n                    for(col = j; col < n && M[row][col] == \\'1\\'; col++);\\n                    colLen = min(colLen, col-j);\\n                    ans = max(ans, (row-i+1) * colLen);\\n                }\\n            \\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        vector<vector<short>> dp(m+1, vector<short>(n+1));\\n        for(int i = m-1; ~i; i--) \\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = M[i][j] == \\'1\\' ? dp[i][j+1] + 1 : 0;\\n                    \\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                for(int row = i, colLen = n; row < m && M[row][j] == \\'1\\'; row++)\\n                    ans = max(ans, (row-i+1) * (colLen = min(colLen, dp[row][j]*1)));\\n                    \\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& M) {\\n        if(!size(M)) return 0;\\n        int ans = 0, m = size(M), n = size(M[0]);\\n        vector<vector<short>> dp(m+1, vector<short>(n+1)), up(m, vector<short>(n,1)), down(up);\\n        for(int i = m-1; ~i; i--) \\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = M[i][j] == \\'1\\' ? dp[i][j+1] + 1 : 0;\\n        \\n        stack<int> s;\\n        for(int j = 0; j < n; j++) {\\n            s = stack<int>();\\n            for(int i = 0; i < m; i++) {\\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\\n                up[i][j] = i - (size(s) ? s.top() : -1);\\n                s.push(i);\\n            }\\n            s = stack<int>();\\n            for(int i = m-1; ~i; i--) {\\n                while(size(s) && dp[s.top()][j] >= dp[i][j]) s.pop();\\n                down[i][j] = (size(s) ? s.top() : m) - i;\\n                s.push(i);\\n            }            \\n        }\\n\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                ans = max(ans, dp[i][j] * (up[i][j]+down[i][j]-1));\\n                    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122456,
                "title": "easiest-solution-build-on-top-of-leetcode84",
                "content": "```\\npublic int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = yourLeetCode84Method(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = yourLeetCode84Method(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29094,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "This problem is similar to [maximal square](https://discuss.leetcode.com/topic/55063/evolve-from-brute-force-to-dp) but much more difficult.\\n1. brute force O(n^6), count each rectangle\\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()) return 0;\\n        int r = matrix.size(), c = matrix[0].size(), area = 0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++) { //each start point (i,j)\\n                if(matrix[i][j]=='0') continue;\\n                for(int p=i;p<r;p++)\\n                    for(int q=j;q<c;q++) { // each end point (p,q)\\n                        if(matrix[p][q]=='0') continue;\\n                        bool ones = 1;\\n                        for(int x=i;x<=p;x++) {   //check if the rectangle contains all 1s\\n                            for(int y=j;y<=q;y++) \\n                                if(matrix[x][y] == '0') {\\n                                    ones = 0;\\n                                    break;\\n                                }\\n                            if(!ones) break;\\n                        }\\n                        if(ones) area = max(area, (p-i+1)*(q-j+1));\\n                    }\\n            }\\n        return area;\\n    }\\n```\\n2. O(n^4), whether a rectangle contains all 1s can be determined incrementally from the previous rectangle\\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()) return 0;\\n        int r = matrix.size(), c = matrix[0].size(), area = 0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++) {\\n                vector<vector<bool>> dp(r,vector<bool>(c));\\n                for(int p=i;p<r;p++)\\n                    for(int q=j;q<c;q++) {\\n                        dp[p][q] = matrix[p][q]=='1';\\n                        if(p>i) dp[p][q] = dp[p][q] & dp[p-1][q];\\n                        if(q>j) dp[p][q] = dp[p][q] & dp[p][q-1];\\n                        if(dp[p][q]) area=max(area,(p-i+1)*(q-j+1));\\n                        else break;\\n                    }\\n            }\\n        return area;\\n    }\\n```\\n3. O(n^3), for a start/end point, we do not need to consider all end/start points, we only need to consider points that connect to the start/end point by all 1s. We use a 2d array to cache number of consecutive 1s to the left of each point. Then for a point, we can determine its maximal rectangles in linear time. [The idea is from @uniqueness ](https://discuss.leetcode.com/topic/1122/my-o-n-3-solution-for-your-reference).\\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if (!r) return 0;\\n        int c = matrix[0].size(), area = 0;\\n        vector<vector<int>> ones(r,vector<int>(c));\\n        for(int i=0;i<r;i++) \\n            for(int j=0;j<c;j++) {\\n                if(matrix[i][j]=='0') continue;\\n                int w = ones[i][j] = (j?ones[i][j-1]:0) + 1;\\n                for(int k=i; k>=0; k--) {\\n                    w = min(ones[k][j],w);\\n                    area = max(area,w*(i-k+1));\\n                }\\n            }\\n        return area;\\n    }\\n```\\n4. O(n^2) dp. The optimal solution does not check a rectangle by start/end point. Given a point (i, j), it computes the left boundary, right boundary of the maximal rectangle with height(i,j) incrementally in constant time. [The idea is from @morrischen2008](https://discuss.leetcode.com/topic/6650/share-my-dp-solution).\\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if (!r) return 0;\\n        int c = matrix[0].size(), area = 0;\\n        vector<int> left(c), right(c,c), height(c);\\n        for(int i=0;i<r;i++) { \\n            int cur = 0;\\n            for(int j=0;j<c;j++)\\n                if(matrix[i][j]=='0') {\\n                    height[j] = left[j] = 0;\\n                    cur = j+1; //left boundary of current row\\n                } else {\\n                    left[j] = max(left[j],cur);  //left boundary for height[j]\\n                    height[j]++;\\n                }\\n            cur = c;\\n            for(int j=c-1;j>=0;j--) {\\n                if (matrix[i][j]=='0') cur = j;\\n                right[j] = matrix[i][j]=='0'? c:min(right[j],cur);\\n                area = max(height[j]*(right[j]-left[j]),area);\\n            }\\n        }\\n        return area;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()) return 0;\\n        int r = matrix.size(), c = matrix[0].size(), area = 0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++) { //each start point (i,j)\\n                if(matrix[i][j]=='0') continue;\\n                for(int p=i;p<r;p++)\\n                    for(int q=j;q<c;q++) { // each end point (p,q)\\n                        if(matrix[p][q]=='0') continue;\\n                        bool ones = 1;\\n                        for(int x=i;x<=p;x++) {   //check if the rectangle contains all 1s\\n                            for(int y=j;y<=q;y++) \\n                                if(matrix[x][y] == '0') {\\n                                    ones = 0;\\n                                    break;\\n                                }\\n                            if(!ones) break;\\n                        }\\n                        if(ones) area = max(area, (p-i+1)*(q-j+1));\\n                    }\\n            }\\n        return area;\\n    }\\n```\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()) return 0;\\n        int r = matrix.size(), c = matrix[0].size(), area = 0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++) {\\n                vector<vector<bool>> dp(r,vector<bool>(c));\\n                for(int p=i;p<r;p++)\\n                    for(int q=j;q<c;q++) {\\n                        dp[p][q] = matrix[p][q]=='1';\\n                        if(p>i) dp[p][q] = dp[p][q] & dp[p-1][q];\\n                        if(q>j) dp[p][q] = dp[p][q] & dp[p][q-1];\\n                        if(dp[p][q]) area=max(area,(p-i+1)*(q-j+1));\\n                        else break;\\n                    }\\n            }\\n        return area;\\n    }\\n```\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if (!r) return 0;\\n        int c = matrix[0].size(), area = 0;\\n        vector<vector<int>> ones(r,vector<int>(c));\\n        for(int i=0;i<r;i++) \\n            for(int j=0;j<c;j++) {\\n                if(matrix[i][j]=='0') continue;\\n                int w = ones[i][j] = (j?ones[i][j-1]:0) + 1;\\n                for(int k=i; k>=0; k--) {\\n                    w = min(ones[k][j],w);\\n                    area = max(area,w*(i-k+1));\\n                }\\n            }\\n        return area;\\n    }\\n```\n```\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if (!r) return 0;\\n        int c = matrix[0].size(), area = 0;\\n        vector<int> left(c), right(c,c), height(c);\\n        for(int i=0;i<r;i++) { \\n            int cur = 0;\\n            for(int j=0;j<c;j++)\\n                if(matrix[i][j]=='0') {\\n                    height[j] = left[j] = 0;\\n                    cur = j+1; //left boundary of current row\\n                } else {\\n                    left[j] = max(left[j],cur);  //left boundary for height[j]\\n                    height[j]++;\\n                }\\n            cur = c;\\n            for(int j=c-1;j>=0;j--) {\\n                if (matrix[i][j]=='0') cur = j;\\n                right[j] = matrix[i][j]=='0'? c:min(right[j],cur);\\n                area = max(height[j]*(right[j]-left[j]),area);\\n            }\\n        }\\n        return area;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29059,
                "title": "sharing-my-straightforward-c-solution-with-o-n-2-time-with-explanation",
                "content": "    int maximalRectangle(vector<vector<char> > &matrix) {\\n        if(matrix.empty()){\\n            return 0;\\n        }\\n        int maxRec = 0;\\n        vector<int> height(matrix[0].size(), 0);\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                if(matrix[i][j] == '0'){\\n                    height[j] = 0;\\n                }\\n                else{\\n                    height[j]++;\\n                }\\n            }\\n            maxRec = max(maxRec, largestRectangleArea(height));\\n        }\\n        return maxRec;\\n    }\\n    \\n    int largestRectangleArea(vector<int> &height) {\\n        stack<int> s;\\n        height.push_back(0);\\n        int maxSize = 0;\\n        for(int i = 0; i < height.size(); i++){\\n            if(s.empty() || height[i] >= height[s.top()]){\\n                s.push(i);\\n            }\\n            else{\\n                int temp = height[s.top()];\\n                s.pop();\\n                maxSize = max(maxSize, temp * (s.empty() ? i : i - 1 - s.top()));\\n                i--;\\n            }\\n        }\\n        return maxSize;\\n    }\\n\\nIn order to solve this problem, I use the solution from \"Largest Rectangle in Histogram\". \\n\\nNow I assume you already know how to solve \"Largest Rectangle in Histogram\".\\n\\nWe can regard a matrix as many histograms. For example, given a matrix below:\\n\\n1 0 1 0\\n\\n0 1 0 1\\n\\n0 1 1 0\\n\\n1 0 1 0\\n\\n1 0 1 1\\n\\nFrom top to bottom, we can find these histograms:\\n\\nNumber 1: 1 0 1 0\\n\\nNumber 2: 0 1 0 1\\n\\nNumber 3: 0 2 1 0\\n\\nNumber 4: 1 0 2 0\\n\\nNumber 5: 2 0 3 1\\n\\nPass all of these histograms to the function which can solve \"Largest Rectangle in Histogram\". And then find the maximum one. \\n\\nFinally, we get the answer.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int maximalRectangle(vector<vector<char> > &matrix) {\\n        if(matrix.empty()){\\n            return 0;\\n        }\\n        int maxRec = 0;\\n        vector<int> height(matrix[0].size(), 0);\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                if(matrix[i][j] == '0'){\\n                    height[j] = 0;\\n                }\\n                else{\\n                    height[j]++;\\n                }\\n            }\\n            maxRec = max(maxRec, largestRectangleArea(height));\\n        }\\n        return maxRec;\\n    }\\n    \\n    int largestRectangleArea(vector<int> &height) {\\n        stack<int> s;\\n        height.push_back(0);\\n        int maxSize = 0;\\n        for(int i = 0; i < height.size(); i++){\\n            if(s.empty() || height[i] >= height[s.top()]){\\n                s.push(i);\\n            }\\n            else{\\n                int temp = height[s.top()];\\n                s.pop();\\n                maxSize = max(maxSize, temp * (s.empty() ? i : i - 1 - s.top()));\\n                i--;\\n            }\\n        }\\n        return maxSize;\\n    }\\n\\nIn order to solve this problem, I use the solution from \"Largest Rectangle in Histogram\". \\n\\nNow I assume you already know how to solve \"Largest Rectangle in Histogram\".\\n\\nWe can regard a matrix as many histograms. For example, given a matrix below:\\n\\n1 0 1 0\\n\\n0 1 0 1\\n\\n0 1 1 0\\n\\n1 0 1 0\\n\\n1 0 1 1\\n\\nFrom top to bottom, we can find these histograms:\\n\\nNumber 1: 1 0 1 0\\n\\nNumber 2: 0 1 0 1\\n\\nNumber 3: 0 2 1 0\\n\\nNumber 4: 1 0 2 0\\n\\nNumber 5: 2 0 3 1\\n\\nPass all of these histograms to the function which can solve \"Largest Rectangle in Histogram\". And then find the maximum one. \\n\\nFinally, we get the answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 872089,
                "title": "easy-c-soln-based-on-largest-histogram",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\n\\n2 0 2 1 1 \\n\\n3 1 3 2 2 \\n\\n\\nAlgorithm Outline:\\nlargestArea()\\n\\n        |\\n    |   |       |\\n|   |   |   |   |\\n\\n1   2   3   1   2   -> 5\\n0   1   2   3   4   -> index\\n\\n1. stack\\n2. iterate, check when value is less that top\\n3. While less than top, area = height of bar * distance from i (anchor)\\n4. Add to stack\\n5. Check while stack not empty\\n6. Return max_area\\n\\nmain()\\n1. Calculate histogra array for each row\\n2. Check largest area in that row\\n3. Return ans\\n\\n\\nHorizontal - can check length\\nVerticle - Keep height of each column top to bottum\\n\\ncalculate area for each histogram in each row \\n\\n1 0 1 0 0   -> 1\\n1 0 1 1 1   -> 3\\n1 1 1 1 1   -> 6\\n1 0 1 1 1\\n\\n*/\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\n\\n2 0 2 1 1 \\n\\n3 1 3 2 2 \\n\\n\\nAlgorithm Outline:\\nlargestArea()\\n\\n        |\\n    |   |       |\\n|   |   |   |   |\\n\\n1   2   3   1   2   -> 5\\n0   1   2   3   4   -> index\\n\\n1. stack\\n2. iterate, check when value is less that top\\n3. While less than top, area = height of bar * distance from i (anchor)\\n4. Add to stack\\n5. Check while stack not empty\\n6. Return max_area\\n\\nmain()\\n1. Calculate histogra array for each row\\n2. Check largest area in that row\\n3. Return ans\\n\\n\\nHorizontal - can check length\\nVerticle - Keep height of each column top to bottum\\n\\ncalculate area for each histogram in each row \\n\\n1 0 1 0 0   -> 1\\n1 0 1 1 1   -> 3\\n1 1 1 1 1   -> 6\\n1 0 1 1 1\\n\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1603766,
                "title": "python-o-mn-solution-explained",
                "content": "There is dp `O(n^2m^2)` solution. We can do better, with `O(nm*min(m,n))` complexity, if we use dynamic programming and keep two tables: `h[i][j]` is the largest `L`, such that all elements in `A[i:i+L-1][j] = 1`, and similar `w[i][j]`. Then we go through our original table `A` and we can calculate for `A[i][j]` the largest subarray that has `A[i][j]` as its bottom-left corner, it can be done with `O(n)` iterations.\\n\\nFinally, there is very smart way with complexity `O(nm)`, using problem **0084**. Indeed, for each row we can evaluate our skyline heights, given previous row in `O(m)` and do it `n` times. Additional complexity is `O(m)`, because actually we need to keep only one row at at time.\\n\\n#### Complexity\\nIt is `O(nm)` for time and `O(m)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maximalRectangle(self, matrix):\\n        def hist(heights):\\n            stack, ans = [], 0\\n            for i, h in enumerate(heights + [0]):\\n                while stack and heights[stack[-1]] >= h:\\n                    H = heights[stack.pop()]\\n                    W = i if not stack else i-stack[-1]-1\\n                    ans = max(ans, H*W)\\n                stack.append(i)\\n            return ans\\n        \\n        if not matrix or not matrix[0]: return 0\\n        m, n, ans = len(matrix[0]), len(matrix), 0\\n        row = [0]*m\\n        for i in range(n):\\n            for j in range(m):\\n                row[j] = 0 if matrix[i][j] == \"0\" else row[j] + 1\\n            ans = max(ans, hist(row))\\n            \\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def maximalRectangle(self, matrix):\\n        def hist(heights):\\n            stack, ans = [], 0\\n            for i, h in enumerate(heights + [0]):\\n                while stack and heights[stack[-1]] >= h:\\n                    H = heights[stack.pop()]\\n                    W = i if not stack else i-stack[-1]-1\\n                    ans = max(ans, H*W)\\n                stack.append(i)\\n            return ans\\n        \\n        if not matrix or not matrix[0]: return 0\\n        m, n, ans = len(matrix[0]), len(matrix), 0\\n        row = [0]*m\\n        for i in range(n):\\n            for j in range(m):\\n                row[j] = 0 if matrix[i][j] == \"0\" else row[j] + 1\\n            ans = max(ans, hist(row))\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255410,
                "title": "python-based-on-maximum-rectangle-in-histogram-clean-concise",
                "content": "**Idea**\\n- Sub problem of this problem is: [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n- So, instead of solving sub-matrix problems, we can change to solve by sub-array problems.\\n\\n```python\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if len(matrix) == 0: return 0\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [0] * n\\n        maxArea = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == \"1\":\\n                    dp[c] += 1\\n                else:\\n                    dp[c] = 0\\n            maxArea = max(maxArea, self.maxRectangleInHistogram(dp))\\n        return maxArea\\n\\n    def maxRectangleInHistogram(self, heights):  # O(N)\\n        n = len(heights)\\n        st = [-1]\\n        maxArea = 0\\n        for i in range(n):\\n            while st[-1] != -1 and heights[st[-1]] >= heights[i]:\\n                currentHeight = heights[st.pop()]\\n                currentWidth = i - st[-1] - 1\\n                maxArea = max(maxArea, currentWidth * currentHeight)\\n            st.append(i)\\n        while st[-1] != -1:\\n            currentHeight = heights[st.pop()]\\n            currentWidth = n - st[-1] - 1\\n            maxArea = max(maxArea, currentWidth * currentHeight)\\n        return maxArea\\n```\\n\\nComplexity:\\n- Time: `O(R * C)`\\n- Space: `O(C)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if len(matrix) == 0: return 0\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [0] * n\\n        maxArea = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == \"1\":\\n                    dp[c] += 1\\n                else:\\n                    dp[c] = 0\\n            maxArea = max(maxArea, self.maxRectangleInHistogram(dp))\\n        return maxArea\\n\\n    def maxRectangleInHistogram(self, heights):  # O(N)\\n        n = len(heights)\\n        st = [-1]\\n        maxArea = 0\\n        for i in range(n):\\n            while st[-1] != -1 and heights[st[-1]] >= heights[i]:\\n                currentHeight = heights[st.pop()]\\n                currentWidth = i - st[-1] - 1\\n                maxArea = max(maxArea, currentWidth * currentHeight)\\n            st.append(i)\\n        while st[-1] != -1:\\n            currentHeight = heights[st.pop()]\\n            currentWidth = n - st[-1] - 1\\n            maxArea = max(maxArea, currentWidth * currentHeight)\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254705,
                "title": "dp-thinking-process",
                "content": "\\n> **How can we identify a rectangle?**\\nThe point on the top-left corner and the point on te bottom-right corner.\\n```\\nFor each possible top-left\\n  For each possible bottom-right\\n    Check if matrix is made of 1s\\n\\t  If valid, we calculate area and update maxArea\\n```\\n\\n> **How can we check if matrix with top-left (i, j) and bottome-right(x, y) is made of 1s?**\\n> In Brute Force, we check each cells in matrix, that takes O(n^2) time complexity\\n> To optimize, we observe that, \\n```\\nwith (i, j) as  top-left, rectangle with (x, y) as bottom-right is valid if \\n  matrix[x][y] is 1\\n  && rectangle with (x, y - 1) as bottom-right is valid\\n  && rectangle with (x - 1, y) as bottom-right is valid\\n```\\n> We build an array isValid to save states. That takes O(1) time complexity.\\n****\\n```\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n        \\n        int rows = matrix.length, cols = matrix[0].length, maxArea = 0;\\n        // For each point topleft\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                // Construt isValid\\n                boolean[][] isValid = new boolean[rows][cols];\\n                // For each point bottom right \\n                for (int x = i; x < rows; x++) {\\n                    for (int y = j; y < cols; y++) {\\n                        if (matrix[x][y] != \\'1\\') continue;\\n                        // Check if valid matrix\\n                        isValid[x][y] = true;\\n                        if (x > i) isValid[x][y] = isValid[x][y] && isValid[x - 1][y];\\n                        if (y > j) isValid[x][y] = isValid[x][y] && isValid[x][y - 1];\\n                        // If valid, calculate area and update max\\n                        if (isValid[x][y]) {\\n                            int area = (x - i + 1) * (y - j + 1);\\n                            maxArea = Math.max(maxArea, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nFor each possible top-left\\n  For each possible bottom-right\\n    Check if matrix is made of 1s\\n\\t  If valid, we calculate area and update maxArea\\n```\n```\\nwith (i, j) as  top-left, rectangle with (x, y) as bottom-right is valid if \\n  matrix[x][y] is 1\\n  && rectangle with (x, y - 1) as bottom-right is valid\\n  && rectangle with (x - 1, y) as bottom-right is valid\\n```\n```\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n        \\n        int rows = matrix.length, cols = matrix[0].length, maxArea = 0;\\n        // For each point topleft\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                // Construt isValid\\n                boolean[][] isValid = new boolean[rows][cols];\\n                // For each point bottom right \\n                for (int x = i; x < rows; x++) {\\n                    for (int y = j; y < cols; y++) {\\n                        if (matrix[x][y] != \\'1\\') continue;\\n                        // Check if valid matrix\\n                        isValid[x][y] = true;\\n                        if (x > i) isValid[x][y] = isValid[x][y] && isValid[x - 1][y];\\n                        if (y > j) isValid[x][y] = isValid[x][y] && isValid[x][y - 1];\\n                        // If valid, calculate area and update max\\n                        if (isValid[x][y]) {\\n                            int area = (x - i + 1) * (y - j + 1);\\n                            maxArea = Math.max(maxArea, area);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1603593,
                "title": "java-detailed-explanation-easy-approach-o-row-col",
                "content": "```\\nIntuition :\\n1) Pick one row\\n2) Do summation of each index till that row\\n\\t\\ti) if any index value is 0 then put 0 else previous summation + 1 \\n3) Pass this array to get max area (84. Largest Rectangle in Historgram)\\n4) Update max area\\n\\n84. Largest Rectangle in Histogram\\nIntuition :\\n1) Max area will always have atleast one full bar height on any index\\n2) Find largest rectangle including each bar one by one.\\n\\ta) For each bar, We have to find it\\'s left limit & right limit (to know the maximum width)\\n\\tb) Find it\\'s left limit (where we find any index\\'s value is smaller than current index in left side array of curr index)\\n\\tc) Find it\\'s right limit (where we find any index\\'s value is smaller than current index in right side array of curr index\\n3) Take the maximum of all the max area found by each bar.\\n4) calculate area\\n\\t\\twidth * height\\nwhere width = right limit - left limit + 1\\nheight = curr index\\'s value\\n5) Update max area & return it\\n```\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0)  return 0;\\n        int maxArea = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dp = new int[col];\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                dp[j] = matrix[i][j] == \\'1\\' ? dp[j]+1 : 0;\\n            }\\n            //treating dp[j] as histogram, solving max area problem there and updating the max area\\n            maxArea = Math.max(maxArea, findMaxAreaInHistogram(dp));\\n        }\\n        return maxArea;\\n    }\\n\\t//84. Largest Rectangle in Histogram code\\n    public int findMaxAreaInHistogram(int[] dp){\\n        int len = dp.length;\\n        int maxArea = 0;\\n        int[] left = new int[len];\\n        int[] right = new int[len];\\n        Stack<Integer> stack = new Stack<>();\\n        //traversing left to right, finding left limit\\n        for(int i=0;i<len;i++){\\n            if(stack.isEmpty()){\\n                stack.push(i);\\n                left[i] = 0;\\n            }else{\\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\\n                    stack.pop();\\n                left[i] = stack.isEmpty() ? 0 : stack.peek()+1;\\n                stack.push(i);\\n            }\\n        }\\n        //doing empty to stack\\n        while(!stack.isEmpty())\\n            stack.pop();\\n        \\n        //traversing right to left, find right limit\\n        for(int i=len-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(len-1);\\n                right[i] = len - 1;\\n            }else{\\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\\n                    stack.pop();\\n                right[i] = stack.isEmpty() ? len-1 : stack.peek()-1;\\n                stack.push(i);\\n            }\\n        }\\n        //traversing the array , caculating area\\n        int[] area = new int[len];\\n        for(int i=0;i<len;i++){\\n            area[i] = (right[i] - left[i] + 1) * dp[i];\\n            maxArea = Math.max(maxArea, area[i]);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nIntuition :\\n1) Pick one row\\n2) Do summation of each index till that row\\n\\t\\ti) if any index value is 0 then put 0 else previous summation + 1 \\n3) Pass this array to get max area (84. Largest Rectangle in Historgram)\\n4) Update max area\\n\\n84. Largest Rectangle in Histogram\\nIntuition :\\n1) Max area will always have atleast one full bar height on any index\\n2) Find largest rectangle including each bar one by one.\\n\\ta) For each bar, We have to find it\\'s left limit & right limit (to know the maximum width)\\n\\tb) Find it\\'s left limit (where we find any index\\'s value is smaller than current index in left side array of curr index)\\n\\tc) Find it\\'s right limit (where we find any index\\'s value is smaller than current index in right side array of curr index\\n3) Take the maximum of all the max area found by each bar.\\n4) calculate area\\n\\t\\twidth * height\\nwhere width = right limit - left limit + 1\\nheight = curr index\\'s value\\n5) Update max area & return it\\n```\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0)  return 0;\\n        int maxArea = 0;\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dp = new int[col];\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                dp[j] = matrix[i][j] == \\'1\\' ? dp[j]+1 : 0;\\n            }\\n            //treating dp[j] as histogram, solving max area problem there and updating the max area\\n            maxArea = Math.max(maxArea, findMaxAreaInHistogram(dp));\\n        }\\n        return maxArea;\\n    }\\n\\t//84. Largest Rectangle in Histogram code\\n    public int findMaxAreaInHistogram(int[] dp){\\n        int len = dp.length;\\n        int maxArea = 0;\\n        int[] left = new int[len];\\n        int[] right = new int[len];\\n        Stack<Integer> stack = new Stack<>();\\n        //traversing left to right, finding left limit\\n        for(int i=0;i<len;i++){\\n            if(stack.isEmpty()){\\n                stack.push(i);\\n                left[i] = 0;\\n            }else{\\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\\n                    stack.pop();\\n                left[i] = stack.isEmpty() ? 0 : stack.peek()+1;\\n                stack.push(i);\\n            }\\n        }\\n        //doing empty to stack\\n        while(!stack.isEmpty())\\n            stack.pop();\\n        \\n        //traversing right to left, find right limit\\n        for(int i=len-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(len-1);\\n                right[i] = len - 1;\\n            }else{\\n                while(!stack.isEmpty() && dp[stack.peek()] >= dp[i])\\n                    stack.pop();\\n                right[i] = stack.isEmpty() ? len-1 : stack.peek()-1;\\n                stack.push(i);\\n            }\\n        }\\n        //traversing the array , caculating area\\n        int[] area = new int[len];\\n        for(int i=0;i<len;i++){\\n            area[i] = (right[i] - left[i] + 1) * dp[i];\\n            maxArea = Math.max(maxArea, area[i]);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29140,
                "title": "pyrhon-o-n-2-solution-based-on-largest-rectangle-in-histogram",
                "content": "    class Solution:\\n    # @param matrix, a list of lists of 1 length string\\n    # @return an integer\\n    def maximalRectangle(self, matrix):\\n        if not matrix:\\n            return 0\\n        h, w = len(matrix), len(matrix[0])\\n        m = [[0]*w for _ in range(h)]\\n        for j in range(h):\\n            for i in range(w):\\n                if matrix[j][i] == '1':\\n                    m[j][i] = m[j-1][i] + 1\\n        return max(self.largestRectangleArea(row) for row in m)\\n\\n    def largestRectangleArea(self, height):\\n        height.append(0)\\n        stack, size = [], 0\\n        for i in range(len(height)):\\n            while stack and height[stack[-1]] > height[i]:\\n                h = height[stack.pop()]\\n                w = i if not stack else i-stack[-1]-1\\n                size = max(size, h*w)\\n            stack.append(i)\\n        return size\\n\\nm is every row height, it is easy to convert this to Largest Rectangle in Histogram",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param matrix, a list of lists of 1 length string\\n    # @return an integer\\n    def maximalRectangle(self, matrix):\\n        if not matrix:\\n            return 0\\n        h, w = len(matrix), len(matrix[0])\\n        m = [[0]*w for _ in range(h)]\\n        for j in range(h):\\n            for i in range(w):\\n                if matrix[j][i] == '1':\\n                    m[j][i] = m[j-1][i] + 1\\n        return max(self.largestRectangleArea(row) for row in m)\\n\\n    def largestRectangleArea(self, height):\\n        height.append(0)\\n        stack, size = [], 0\\n        for i in range(len(height)):\\n            while stack and height[stack[-1]] > height[i]:\\n                h = height[stack.pop()]\\n                w = i if not stack else i-stack[-1]-1\\n                size = max(size, h*w)\\n            stack.append(i)\\n        return size\\n\\nm is every row height, it is easy to convert this to Largest Rectangle in Histogram",
                "codeTag": "Java"
            },
            {
                "id": 29172,
                "title": "my-o-n-3-solution-for-your-reference",
                "content": "    class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char> > &matrix) {\\n            int num_i=matrix.size();\\n            if (num_i==0) return 0;\\n            int num_j=matrix[0].size();\\n            if (num_j==0) return 0;\\n            vector<vector<int>> max_x(num_i,vector<int>(num_j,0));  //number of consecutive 1s to the left of matrix[i][j], including itself\\n    \\n            int area=0;\\n            for (int i=0;i<num_i;i++){\\n                for (int j=0;j<num_j;j++){\\n                    if (matrix[i][j]=='1'){\\n                        if (j==0) max_x[i][j]=1;\\n                        else max_x[i][j]=max_x[i][j-1]+1;\\n                        int y=1;\\n                        int x=num_j;\\n                        while((i-y+1>=0)&&(matrix[i-y+1][j]=='1')){\\n                            x=min(x, max_x[i-y+1][j]);\\n                            area=max(area,x*y);\\n                            y++;\\n                        } \\n                    }\\n                }\\n            }\\n            \\n    \\n            \\n            return area;\\n            \\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char> > &matrix) {\\n            int num_i=matrix.size();\\n            if (num_i==0) return 0;\\n            int num_j=matrix[0].size();\\n            if (num_j==0) return 0;\\n            vector<vector<int>> max_x(num_i,vector<int>(num_j,0));  //number of consecutive 1s to the left of matrix[i][j], including itself\\n    \\n            int area=0;\\n            for (int i=0;i<num_i;i++){\\n                for (int j=0;j<num_j;j++){\\n                    if (matrix[i][j]=='1'){\\n                        if (j==0) max_x[i][j]=1;\\n                        else max_x[i][j]=max_x[i][j-1]+1;\\n                        int y=1;\\n                        int x=num_j;\\n                        while((i-y+1>=0)&&(matrix[i-y+1][j]=='1')){\\n                            x=min(x, max_x[i-y+1][j]);\\n                            area=max(area,x*y);\\n                            y++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1603962,
                "title": "c-2-solutions-better-to-optimal-with-explanation-easy-to-understand",
                "content": "## Approach 1\\n\\n```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n//base cases\\n        int n = matrix.size();\\n        if(n == 0) return 0;\\n        int m = matrix[0].size();\\n        if(n + m == 2) return matrix.front().front() == \\'1\\';\\n\\t\\t\\n\\t\\t//dp to store max number of adjacent 1s on left for each matrix[ i ][ j ]\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(matrix[i-1][j-1] != \\'0\\')\\n                  dp[i][j] = 1 + dp[i][j-1];\\n                // cout<<dp[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        \\n\\t\\t\\n\\t\\t//variable to store answer\\n        int area = 0;\\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n\\t\\t\\t//variable to store current width of rectangle of size 1 * dp[i][j]\\n                int width = dp[i][j];\\n                int k = i-1;\\n                int height = 1;\\n                area = max(area,width * height);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//now we\\'ll start moving upwards as long as we are inside the matrix\\n\\t\\t\\t\\t//ans change the height ans width accordingly to find the largest\\n\\t\\t\\t\\t//area which can be achieved including current element\\n\\t\\t\\t\\t//height always increases as we go up, width of rectangle till that height changes\\n\\t\\t\\t\\t//to minimum no. of left 1s for every upward element\\n                while(k > 0 and dp[k][j] > 0)\\n                {\\n                    height++;\\n                    width = min(width,dp[k--][j]);\\n\\t\\t\\t\\t\\t//for every acceptable height, we check if it can be our answer\\n                    area = max(width * height,area);\\n                }\\n            }\\n        }\\n        \\n        return area;\\n    }\\n```\\n\\n**Time Complexity :** O(n * m * n)\\n**Space Complexity :** O(n * m)\\n\\n## Approach 2\\n\\nThe second method utilizes the concept of the [Largest Reactangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) to compute the largest rectangle for a given row efficiently.\\n\\n```\\n//code to find largest rectangle in histogram\\nint largestRectangle(vector<int> &dp)\\n    {\\n        stack<int> st;\\n        st.push(-1);\\n        int max_area = 0;\\n        for(int i=0;i<=dp.size();i++)\\n        {\\n            int val = (i == dp.size()) ? -1 : dp[i];\\n            while(st.top() != -1 and dp[st.top()] > val)\\n            {\\n                int height = dp[st.top()];\\n                st.pop();\\n                int width = i - st.top() - 1;\\n                max_area = max(max_area,width * height);\\n            }\\n            st.push(i);\\n        }\\n        return max_area;\\n    }\\n\\t\\n\\tint maximalRectangle(vector<vector<char>>& matrix) {\\n\\t\\t//base cases\\n        int n = matrix.size();\\n        if(n == 0) return 0;\\n        int m = matrix[0].size();\\n        if(n + m == 2) return matrix[0][0] == \\'1\\';\\n        \\n\\t\\t//program to calculate maximum height for current element\\n        vector<int> dp(m,0);\\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n\\t\\t\\t\\t//if current 0 then total height is 0 else increase the previous height\\n                if(matrix[i][j] == \\'0\\') dp[j] = 0;\\n                else dp[j]++;\\n            }\\n            res = max(res,largestRectangle(dp));\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n**Time Complexity :** O(n * (m + n) )\\n**Space Complexity :** O(n + n) [dp array + stack to find largest rectangle]\\n\\nDO upvote, if it helped you :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n//base cases\\n        int n = matrix.size();\\n        if(n == 0) return 0;\\n        int m = matrix[0].size();\\n        if(n + m == 2) return matrix.front().front() == \\'1\\';\\n\\t\\t\\n\\t\\t//dp to store max number of adjacent 1s on left for each matrix[ i ][ j ]\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(matrix[i-1][j-1] != \\'0\\')\\n                  dp[i][j] = 1 + dp[i][j-1];\\n                // cout<<dp[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        \\n\\t\\t\\n\\t\\t//variable to store answer\\n        int area = 0;\\n\\t\\t\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n\\t\\t\\t//variable to store current width of rectangle of size 1 * dp[i][j]\\n                int width = dp[i][j];\\n                int k = i-1;\\n                int height = 1;\\n                area = max(area,width * height);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//now we\\'ll start moving upwards as long as we are inside the matrix\\n\\t\\t\\t\\t//ans change the height ans width accordingly to find the largest\\n\\t\\t\\t\\t//area which can be achieved including current element\\n\\t\\t\\t\\t//height always increases as we go up, width of rectangle till that height changes\\n\\t\\t\\t\\t//to minimum no. of left 1s for every upward element\\n                while(k > 0 and dp[k][j] > 0)\\n                {\\n                    height++;\\n                    width = min(width,dp[k--][j]);\\n\\t\\t\\t\\t\\t//for every acceptable height, we check if it can be our answer\\n                    area = max(width * height,area);\\n                }\\n            }\\n        }\\n        \\n        return area;\\n    }\\n```\n```\\n//code to find largest rectangle in histogram\\nint largestRectangle(vector<int> &dp)\\n    {\\n        stack<int> st;\\n        st.push(-1);\\n        int max_area = 0;\\n        for(int i=0;i<=dp.size();i++)\\n        {\\n            int val = (i == dp.size()) ? -1 : dp[i];\\n            while(st.top() != -1 and dp[st.top()] > val)\\n            {\\n                int height = dp[st.top()];\\n                st.pop();\\n                int width = i - st.top() - 1;\\n                max_area = max(max_area,width * height);\\n            }\\n            st.push(i);\\n        }\\n        return max_area;\\n    }\\n\\t\\n\\tint maximalRectangle(vector<vector<char>>& matrix) {\\n\\t\\t//base cases\\n        int n = matrix.size();\\n        if(n == 0) return 0;\\n        int m = matrix[0].size();\\n        if(n + m == 2) return matrix[0][0] == \\'1\\';\\n        \\n\\t\\t//program to calculate maximum height for current element\\n        vector<int> dp(m,0);\\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n\\t\\t\\t\\t//if current 0 then total height is 0 else increase the previous height\\n                if(matrix[i][j] == \\'0\\') dp[j] = 0;\\n                else dp[j]++;\\n            }\\n            res = max(res,largestRectangle(dp));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1603612,
                "title": "python3-dynamic-programming-explained",
                "content": "First, we form an auxiliary matrix `dp` storing the number of consecutive \"1\"s on the left side of the corresponding slot at the input matrix. Then we iterate slots of the `dp` upwards and find all possible rectangles that can be formed having the current slot as the right bottom angle. The first possible rectangle area is equal to `dp[i][j] * 1`. We go up and check whether the above slot can form a rectangle with the current one and if yes, the rectangle area will be equal to `min(dp[i][j], dp[i - 1][j]) * 2`, and so on. The maximum value is our result.\\n\\nTime: **O(rows*cols * rows)**  - because when searching for a max rectangle using our `dp`, in worst case we have to scan all rows up to the first one for every slot\\nSpace: **O(rows*cols)** - for an aux matrix\\n\\nRuntime: 420 ms, faster than **20.81%** of Python3 online submissions for Maximal Rectangle.\\nMemory Usage: 15.6 MB, less than **21.06%** of Python3 online submissions for Maximal Rectangle.\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, m: List[List[str]]) -> int:\\n        rows = len(m)\\n        if not rows:\\n            return 0\\n        \\n        cols = len(m[0])\\n        \\n        dp = [[0] * cols for _ in range(rows)]\\n\\n        for i in range(rows): # fill dp, value = number of 1s on the left side\\n            acc = 0\\n            \\n            for j in range(cols):\\n                if m[i][j] == \"1\":\\n                    acc += 1\\n                else:\\n                    acc = 0\\n                    \\n                dp[i][j] = acc\\n                \\n        res = 0\\n        \\n        for i in reversed(range(rows)):\\n            for j in reversed(range(cols)):\\n                bSide, rSide = dp[i][j], 0 # bottom and right side\\n                k = i\\n                \\n                while k > -1 and dp[k][j]:  # iterate all possible rectangles\\n                    bSide = min(bSide, dp[k][j])\\n                    rSide += 1\\n\\n                    res = max(res, bSide * rSide)\\n                    \\n                    k -= 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, m: List[List[str]]) -> int:\\n        rows = len(m)\\n        if not rows:\\n            return 0\\n        \\n        cols = len(m[0])\\n        \\n        dp = [[0] * cols for _ in range(rows)]\\n\\n        for i in range(rows): # fill dp, value = number of 1s on the left side\\n            acc = 0\\n            \\n            for j in range(cols):\\n                if m[i][j] == \"1\":\\n                    acc += 1\\n                else:\\n                    acc = 0\\n                    \\n                dp[i][j] = acc\\n                \\n        res = 0\\n        \\n        for i in reversed(range(rows)):\\n            for j in reversed(range(cols)):\\n                bSide, rSide = dp[i][j], 0 # bottom and right side\\n                k = i\\n                \\n                while k > -1 and dp[k][j]:  # iterate all possible rectangles\\n                    bSide = min(bSide, dp[k][j])\\n                    rSide += 1\\n\\n                    res = max(res, bSide * rSide)\\n                    \\n                    k -= 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749853,
                "title": "easy-solution-c",
                "content": "**Tabulation code : Dynamic Programming** : Idea behind this\\nTaking a small refernce from largest rectangle area Question , where we have to calculate largest area possible by using stack approach. We can boil down this problem in sub - problem that are related to the largest rectangle area problem . where in this we traverse this matrix for every value of j from 0 to m , if the matrix value at that particular is 1 then we just increment the height vector that we have consider. at each traversal of i we calculate the area at the last from the refrence question . calculate the max at the last.\\n\\n```\\n// Maximal Rectangle\\n    // tab\\n        class Solution {\\n        public:\\n            int largestRectangleArea(vector < int > & histo) {\\n            stack < int > st;\\n            int maxA = 0;\\n            int n = histo.size();\\n            for (int i = 0; i <= n; i++) {\\n                while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {\\n                int height = histo[st.top()];\\n                st.pop();\\n                int width;\\n                if (st.empty())\\n                    width = i;\\n                else\\n                    width = i - st.top() - 1;\\n                maxA = max(maxA, width * height);\\n                }\\n                st.push(i);\\n            }\\n            return maxA;\\n            }\\n            int maximalRectangle(vector<vector<char>>& matrix) {\\n                int maxiArea = 0, n = matrix.size(), m = matrix[0].size();\\n                vector<int> height(m,0);\\n                \\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                        if(matrix[i][j] == \\'1\\') height[j]++;\\n                        else height[j] = 0;\\n                    }   \\n                    int area = largestRectangleArea(height);\\n                    maxiArea = max(maxiArea,area);\\n                }\\n                return maxiArea;\\n            }\\n        };\\n```\\n<br>\\n<div>Happy Coding</div>\\nPlease do upvote this post. \\n\\n![image](https://assets.leetcode.com/users/images/5ce11bf6-0db9-4239-bbb9-dfe5d76443f3_1666346629.9681695.gif)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n// Maximal Rectangle\\n    // tab\\n        class Solution {\\n        public:\\n            int largestRectangleArea(vector < int > & histo) {\\n            stack < int > st;\\n            int maxA = 0;\\n            int n = histo.size();\\n            for (int i = 0; i <= n; i++) {\\n                while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {\\n                int height = histo[st.top()];\\n                st.pop();\\n                int width;\\n                if (st.empty())\\n                    width = i;\\n                else\\n                    width = i - st.top() - 1;\\n                maxA = max(maxA, width * height);\\n                }\\n                st.push(i);\\n            }\\n            return maxA;\\n            }\\n            int maximalRectangle(vector<vector<char>>& matrix) {\\n                int maxiArea = 0, n = matrix.size(), m = matrix[0].size();\\n                vector<int> height(m,0);\\n                \\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                        if(matrix[i][j] == \\'1\\') height[j]++;\\n                        else height[j] = 0;\\n                    }   \\n                    int area = largestRectangleArea(height);\\n                    maxiArea = max(maxiArea,area);\\n                }\\n                return maxiArea;\\n            }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519263,
                "title": "java-tc-o-rc-sc-o-min-r-c-optimal-stack-solution",
                "content": "```java\\n/**\\n * This solution is converting the input matrix row by row (OR column by column)\\n * to Largest Rectangle in a Histogram.\\n *\\n * For each row (OR column) cumulative height is calculated. Then use stack to\\n * save the increasing height index.\\n *\\n * Time Complexity: O(R * C). Each element is added to stack once and popped\\n * from stack once.\\n *\\n * Space Complexity: O(min(R,C)). We will either store a row or a column\\n *\\n * R = Number of rows in the matrix. C = Number of columns in the matrix.\\n */\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input matrix is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n\\n        if (cols < rows) {\\n            return maximalRectangleHelper(matrix, rows, cols, true);\\n        } else {\\n            return maximalRectangleHelper(matrix, cols, rows, false);\\n        }\\n    }\\n\\n    private int maximalRectangleHelper(char[][] matrix, int big, int small, boolean isColsSmall) {\\n        int[] heights = new int[small];\\n        int largestRectangle = 0;\\n        for (int i = 0; i < big; i++) {\\n            Deque<Integer> stack = new ArrayDeque<>();\\n            for (int j = 0; j <= small; j++) {\\n                if (j < small) {\\n                    if (isColsSmall) {\\n                        heights[j] = matrix[i][j] == \\'0\\' ? 0 : heights[j] + 1;\\n                    } else {\\n                        heights[j] = matrix[j][i] == \\'0\\' ? 0 : heights[j] + 1;\\n                    }\\n\\n                }\\n                while (!stack.isEmpty() && (j == small || heights[stack.peek()] >= heights[j])) {\\n                    int h = heights[stack.pop()];\\n                    int left = stack.isEmpty() ? -1 : stack.peek();\\n                    largestRectangle = Math.max(largestRectangle, (j - 1 - left) * h);\\n                }\\n                stack.push(j);\\n            }\\n        }\\n        return largestRectangle;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other similar question on LeetCode:\\n- [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1519257/Java-or-TC:-O(N)-or-SC:-O(N)-or-Optimal-Stack-solution)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * This solution is converting the input matrix row by row (OR column by column)\\n * to Largest Rectangle in a Histogram.\\n *\\n * For each row (OR column) cumulative height is calculated. Then use stack to\\n * save the increasing height index.\\n *\\n * Time Complexity: O(R * C). Each element is added to stack once and popped\\n * from stack once.\\n *\\n * Space Complexity: O(min(R,C)). We will either store a row or a column\\n *\\n * R = Number of rows in the matrix. C = Number of columns in the matrix.\\n */\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input matrix is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n\\n        if (cols < rows) {\\n            return maximalRectangleHelper(matrix, rows, cols, true);\\n        } else {\\n            return maximalRectangleHelper(matrix, cols, rows, false);\\n        }\\n    }\\n\\n    private int maximalRectangleHelper(char[][] matrix, int big, int small, boolean isColsSmall) {\\n        int[] heights = new int[small];\\n        int largestRectangle = 0;\\n        for (int i = 0; i < big; i++) {\\n            Deque<Integer> stack = new ArrayDeque<>();\\n            for (int j = 0; j <= small; j++) {\\n                if (j < small) {\\n                    if (isColsSmall) {\\n                        heights[j] = matrix[i][j] == \\'0\\' ? 0 : heights[j] + 1;\\n                    } else {\\n                        heights[j] = matrix[j][i] == \\'0\\' ? 0 : heights[j] + 1;\\n                    }\\n\\n                }\\n                while (!stack.isEmpty() && (j == small || heights[stack.peek()] >= heights[j])) {\\n                    int h = heights[stack.pop()];\\n                    int left = stack.isEmpty() ? -1 : stack.peek();\\n                    largestRectangle = Math.max(largestRectangle, (j - 1 - left) * h);\\n                }\\n                stack.push(j);\\n            }\\n        }\\n        return largestRectangle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407011,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 142 videos for leetcode questions as of April 10, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**Largest Color Value in a Directed Graph video**\\nhttps://qr.paps.jp/asEvO\\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nhttps://qr.paps.jp/q2r7Z\\n\\n\\n![FotoJet (38).jpg](https://assets.leetcode.com/users/images/9b0c0cf7-7e85-4976-b69e-41f4a3fa14d9_1680906259.8040502.jpeg)\\n\\n\\n---\\n\\n\\n\\n# Approach\\n1. Check if the input matrix is empty, if it is return 0.\\n\\n2. Determine the number of columns in the matrix (n) by getting the length of the first row of the matrix.\\n\\n3. Create a list called heights, with n+1 elements, and initialize each element to 0.\\n\\n4. Create a variable called max_area and initialize it to 0.\\n\\n5. For each row in the matrix, do the following:\\n    - Iterate through each column in the row, and update the corresponding height in the \"heights\" list.\\n    - If the character in the matrix is \"1\", increment the corresponding height in the \"heights\" list by 1, otherwise set it to 0.\\n\\n6. Create an empty stack and add -1 to it.\\n\\n7. For each element in the \"heights\" list, do the following:\\n    - Compare the current height to the height of the top element in the stack.\\n    - If the current height is less than the height of the top element of the stack, do the following:\\n        - Pop the top element of the stack and calculate the area of the rectangle formed by the popped height.\\n        - Calculate the width of the rectangle by subtracting the index of the current element from the index of the new top element of the stack.\\n        - Calculate the area of the rectangle by multiplying the height and width.\\n        - Update the maximum area seen so far if the area of the current rectangle is larger than the current maximum.\\n    - Append the index of the current element to the stack.\\n\\n8. Return the maximum area seen so far.\\n\\n# Complexity\\n- Time complexity:  O(m*n)\\nm is the number of rows in the input matrix and n is the number of columns. This is because we have to iterate through each element in the matrix at least once, and the time it takes to process each element is constant.\\n\\n- Space complexity: O(n)\\nn is the number of columns in the matrix. This is because we are creating a \"heights\" list with n+1 elements, and a stack that could have up to n+1 elements. The rest of the variables used in the algorithm are constants and do not contribute significantly to the space complexity.\\n\\n# Python\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        n = len(matrix[0])\\n        heights = [0] * (n + 1)\\n        max_area = 0\\n\\n        for row in matrix:\\n            for i in range(n):\\n                heights[i] = heights[i] + 1 if row[i] == \"1\" else 0\\n            \\n            stack = [-1]\\n            for i in range(n + 1):\\n                while heights[i] < heights[stack[-1]]:\\n                    h = heights[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    max_area = max(max_area, h * w)\\n                \\n                stack.append(i)\\n        \\n        return max_area\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalRectangle = function(matrix) {\\n    if (!matrix.length) {\\n        return 0;\\n    }\\n    \\n    const n = matrix[0].length;\\n    const heights = new Array(n + 1).fill(0);\\n    let maxArea = 0;\\n    \\n    for (let row of matrix) {\\n        for (let i = 0; i < n; i++) {\\n            heights[i] = row[i] === \\'1\\' ? heights[i] + 1 : 0;\\n        }\\n        \\n        const stack = [-1];\\n        for (let i = 0; i < n + 1; i++) {\\n            while (heights[i] < heights[stack[stack.length - 1]]) {\\n                const h = heights[stack.pop()];\\n                const w = i - stack[stack.length - 1] - 1;\\n                maxArea = Math.max(maxArea, h * w);\\n            }\\n            stack.push(i);\\n        }\\n    }\\n    \\n    return maxArea;    \\n};\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix == null || matrix.length == 0) {\\n            return 0;\\n        }\\n        \\n        int n = matrix[0].length;\\n        int[] heights = new int[n + 1];\\n        int maxArea = 0;\\n        \\n        for (char[] row : matrix) {\\n            for (int i = 0; i < n; i++) {\\n                heights[i] = row[i] == \\'1\\' ? heights[i] + 1 : 0;\\n            }\\n            \\n            Stack<Integer> stack = new Stack<>();\\n            stack.push(-1);\\n            for (int i = 0; i < n + 1; i++) {\\n                while (stack.peek() != -1 && heights[i] < heights[stack.peek()]) {\\n                    int h = heights[stack.pop()];\\n                    int w = i - stack.peek() - 1;\\n                    maxArea = Math.max(maxArea, h * w);\\n                }\\n                stack.push(i);\\n            }\\n        }\\n        \\n        return maxArea;        \\n    }\\n}\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        \\n        int n = matrix[0].size();\\n        vector<int> heights(n + 1);\\n        int maxArea = 0;\\n        \\n        for (auto row : matrix) {\\n            for (int i = 0; i < n; i++) {\\n                heights[i] = row[i] == \\'1\\' ? heights[i] + 1 : 0;\\n            }\\n            \\n            stack<int> st;\\n            st.push(-1);\\n            for (int i = 0; i < n + 1; i++) {\\n                while (st.top() != -1 && heights[i] < heights[st.top()]) {\\n                    int h = heights[st.top()];\\n                    st.pop();\\n                    int w = i - st.top() - 1;\\n                    maxArea = max(maxArea, h * w);\\n                }\\n                st.push(i);\\n            }\\n        }\\n        \\n        return maxArea;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        \\n        n = len(matrix[0])\\n        heights = [0] * (n + 1)\\n        max_area = 0\\n\\n        for row in matrix:\\n            for i in range(n):\\n                heights[i] = heights[i] + 1 if row[i] == \"1\" else 0\\n            \\n            stack = [-1]\\n            for i in range(n + 1):\\n                while heights[i] < heights[stack[-1]]:\\n                    h = heights[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    max_area = max(max_area, h * w)\\n                \\n                stack.append(i)\\n        \\n        return max_area\\n```\n```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalRectangle = function(matrix) {\\n    if (!matrix.length) {\\n        return 0;\\n    }\\n    \\n    const n = matrix[0].length;\\n    const heights = new Array(n + 1).fill(0);\\n    let maxArea = 0;\\n    \\n    for (let row of matrix) {\\n        for (let i = 0; i < n; i++) {\\n            heights[i] = row[i] === \\'1\\' ? heights[i] + 1 : 0;\\n        }\\n        \\n        const stack = [-1];\\n        for (let i = 0; i < n + 1; i++) {\\n            while (heights[i] < heights[stack[stack.length - 1]]) {\\n                const h = heights[stack.pop()];\\n                const w = i - stack[stack.length - 1] - 1;\\n                maxArea = Math.max(maxArea, h * w);\\n            }\\n            stack.push(i);\\n        }\\n    }\\n    \\n    return maxArea;    \\n};\\n```\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix == null || matrix.length == 0) {\\n            return 0;\\n        }\\n        \\n        int n = matrix[0].length;\\n        int[] heights = new int[n + 1];\\n        int maxArea = 0;\\n        \\n        for (char[] row : matrix) {\\n            for (int i = 0; i < n; i++) {\\n                heights[i] = row[i] == \\'1\\' ? heights[i] + 1 : 0;\\n            }\\n            \\n            Stack<Integer> stack = new Stack<>();\\n            stack.push(-1);\\n            for (int i = 0; i < n + 1; i++) {\\n                while (stack.peek() != -1 && heights[i] < heights[stack.peek()]) {\\n                    int h = heights[stack.pop()];\\n                    int w = i - stack.peek() - 1;\\n                    maxArea = Math.max(maxArea, h * w);\\n                }\\n                stack.push(i);\\n            }\\n        }\\n        \\n        return maxArea;        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        \\n        int n = matrix[0].size();\\n        vector<int> heights(n + 1);\\n        int maxArea = 0;\\n        \\n        for (auto row : matrix) {\\n            for (int i = 0; i < n; i++) {\\n                heights[i] = row[i] == \\'1\\' ? heights[i] + 1 : 0;\\n            }\\n            \\n            stack<int> st;\\n            st.push(-1);\\n            for (int i = 0; i < n + 1; i++) {\\n                while (st.top() != -1 && heights[i] < heights[st.top()]) {\\n                    int h = heights[st.top()];\\n                    st.pop();\\n                    int w = i - st.top() - 1;\\n                    maxArea = max(maxArea, h * w);\\n                }\\n                st.push(i);\\n            }\\n        }\\n        \\n        return maxArea;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644117,
                "title": "using-max-area-of-histofgram",
                "content": "This guy deserves an appluase for a fabulous explanation ! (video in Hindi)\\n\\nhttps://www.youtube.com/watch?v=St0Jf_VmG_g&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&index=8\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix:\\n            return 0\\n        \\n        prev = [0]*len(matrix[0])\\n        max_area = 0\\n        for row in matrix:\\n            curr_row = [int(i) for i in row]\\n            for j in range (len(curr_row)):\\n                curr_row[j] = curr_row[j] + prev[j] if curr_row[j] !=0 else 0\\n            max_area = max(max_area, self.largestRectangleArea(curr_row))\\n            prev = curr_row\\n            \\n        return max_area\\n                \\n            \\n    \\n    #largest ares of a histogram !!\\n    def largestRectangleArea(self, heights):      \\n\\n        def get_small_r(heights):\\n            stack_r = []\\n            sm_r = [0] * len(heights)\\n            for j in range(len(heights) - 1, -1 , -1):\\n\\n                while stack_r and heights[stack_r[-1]] >= heights[j]:\\n                    stack_r.pop()\\n\\n                if(not stack_r):\\n                    sm_r[j] = -1\\n                else:\\n                    sm_r[j] = stack_r[-1]\\n                stack_r.append(j) \\n            return sm_r\\n\\n        def get_small_l(heights):\\n            stack_l = []\\n            sm_l = [None] * len(heights)\\n            for j in range(len(heights)):\\n                while stack_l and heights[stack_l[-1]] >= heights[j]:\\n                    stack_l.pop()\\n                if(not stack_l):\\n                    sm_l[j] = -1\\n                else:\\n                    sm_l[j] = stack_l[-1]\\n                stack_l.append(j) \\n            return sm_l\\n\\n        max_area = 0\\n        stack_l = get_small_l(heights)\\n        stack_r = get_small_r(heights)\\n        \\n        for j in range (len(heights)):\\n            l = j - stack_l[j] -1 if stack_l[j] != -1 else j\\n            r = stack_r[j] -1 -j  if stack_r[j] != -1 else len(heights) - j -1\\n            t = 1 + l + r \\n            max_area = max(max_area,   heights[j] *t )\\n        return max_area\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix:\\n            return 0\\n        \\n        prev = [0]*len(matrix[0])\\n        max_area = 0\\n        for row in matrix:\\n            curr_row = [int(i) for i in row]\\n            for j in range (len(curr_row)):\\n                curr_row[j] = curr_row[j] + prev[j] if curr_row[j] !=0 else 0\\n            max_area = max(max_area, self.largestRectangleArea(curr_row))\\n            prev = curr_row\\n            \\n        return max_area\\n                \\n            \\n    \\n    #largest ares of a histogram !!\\n    def largestRectangleArea(self, heights):      \\n\\n        def get_small_r(heights):\\n            stack_r = []\\n            sm_r = [0] * len(heights)\\n            for j in range(len(heights) - 1, -1 , -1):\\n\\n                while stack_r and heights[stack_r[-1]] >= heights[j]:\\n                    stack_r.pop()\\n\\n                if(not stack_r):\\n                    sm_r[j] = -1\\n                else:\\n                    sm_r[j] = stack_r[-1]\\n                stack_r.append(j) \\n            return sm_r\\n\\n        def get_small_l(heights):\\n            stack_l = []\\n            sm_l = [None] * len(heights)\\n            for j in range(len(heights)):\\n                while stack_l and heights[stack_l[-1]] >= heights[j]:\\n                    stack_l.pop()\\n                if(not stack_l):\\n                    sm_l[j] = -1\\n                else:\\n                    sm_l[j] = stack_l[-1]\\n                stack_l.append(j) \\n            return sm_l\\n\\n        max_area = 0\\n        stack_l = get_small_l(heights)\\n        stack_r = get_small_r(heights)\\n        \\n        for j in range (len(heights)):\\n            l = j - stack_l[j] -1 if stack_l[j] != -1 else j\\n            r = stack_r[j] -1 -j  if stack_r[j] != -1 else len(heights) - j -1\\n            t = 1 + l + r \\n            max_area = max(max_area,   heights[j] *t )\\n        return max_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584368,
                "title": "c-20ms-99-simple-easy-small-commented",
                "content": "\\n![image](https://assets.leetcode.com/users/images/3dd5e53c-fa9c-4ad9-b765-67145629724c_1637224731.3485026.png)\\n\\n\\n**General idea : do precalculating contigious ones (vertical and horizontal)**\\n\\nRuntime: 20 ms, faster than 98.92% of C++ online submissions for Maximal Rectangle.\\nMemory Usage: 12.1 MB, less than 53.69% of C++ online submissions for Maximal Rectangle.\\n```\\nclass Solution {\\npublic:\\n  int maximalRectangle(vector<vector<char>>& matrix) {\\n    if(matrix.empty()) return 0;\\n    int y = matrix.size(), x = matrix[0].size(), answer = 0;\\n    vector<vector<int>> a(y,vector<int>(x)), b(y,vector<int>(x));\\n    \\n    for(int j = 0; j != x; j++)\\n      for(int i = y - 1, k = 0; i >= 0; i--)\\n        if(matrix[i][j] == \\'1\\') a[i][j] = ++k;\\n        else a[i][j] = k = 0;\\n      \\n    for(int i = 0; i != y; i++)\\n      for(int j = x - 1, k = 0; j >= 0; j--)\\n        if(matrix[i][j] == \\'1\\') b[i][j] = ++k;\\n        else b[i][j] = k = 0;\\n    \\n    for(int i = 0; i != y; i++)\\n      for(int j = 0; j != x; j++){\\n        int Y = a[i][j], X = b[i][j];\\n        for(int w = j + 1, lim = j + X; w < lim; w++)\\n          if(Y > a[i][w]) {answer = max(answer, Y * (w - j)); Y = a[i][w];}\\n        \\n        answer = max(answer, Y * X);\\n      }\\n            \\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maximalRectangle(vector<vector<char>>& matrix) {\\n    if(matrix.empty()) return 0;\\n    int y = matrix.size(), x = matrix[0].size(), answer = 0;\\n    vector<vector<int>> a(y,vector<int>(x)), b(y,vector<int>(x));\\n    \\n    for(int j = 0; j != x; j++)\\n      for(int i = y - 1, k = 0; i >= 0; i--)\\n        if(matrix[i][j] == \\'1\\') a[i][j] = ++k;\\n        else a[i][j] = k = 0;\\n      \\n    for(int i = 0; i != y; i++)\\n      for(int j = x - 1, k = 0; j >= 0; j--)\\n        if(matrix[i][j] == \\'1\\') b[i][j] = ++k;\\n        else b[i][j] = k = 0;\\n    \\n    for(int i = 0; i != y; i++)\\n      for(int j = 0; j != x; j++){\\n        int Y = a[i][j], X = b[i][j];\\n        for(int w = j + 1, lim = j + X; w < lim; w++)\\n          if(Y > a[i][w]) {answer = max(answer, Y * (w - j)); Y = a[i][w];}\\n        \\n        answer = max(answer, Y * X);\\n      }\\n            \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385631,
                "title": "variation-of-mah-c-a-bit-long-but-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<int> NSL(vector<int> heights){ // Function to find indices of next smallest left element\\n        vector<int> left;\\n        stack<pair<int,int>> st;\\n        for(int i=0;i<heights.size();i++){\\n            if(st.empty())\\n                left.push_back(-1);\\n            else if(!st.empty() && st.top().first<heights[i])\\n                left.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first>=heights[i]){\\n                while(!st.empty() && st.top().first>=heights[i])\\n                    st.pop();\\n                if(st.empty())\\n                    left.push_back(-1);\\n                else \\n                    left.push_back(st.top().second);\\n            }\\n            st.push({heights[i],i});\\n        }\\n        return left;\\n    }\\n    vector<int> NSR(vector<int> heights){  // Function to find indices of next smallest right element\\n        vector<int> right;\\n        stack<pair<int,int>> st;\\n        for(int i=heights.size()-1;i>=0;i--){\\n            if(st.empty())\\n                right.push_back(heights.size());\\n            else if(!st.empty() && st.top().first<heights[i])\\n                right.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first>=heights[i]){\\n                while(!st.empty() && st.top().first>=heights[i])\\n                    st.pop();\\n                if(st.empty())\\n                    right.push_back(heights.size());\\n                else \\n                    right.push_back(st.top().second);\\n            }\\n            st.push({heights[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n    int MAH(vector<int>& heights) {  //Function to find maximum area of histogram\\n        vector<int> right;\\n        vector<int> left;\\n        \\n        right=NSR(heights);\\n        left=NSL(heights);\\n        \\n        vector<int> width;\\n        int mx=0;\\n        for(int i=0;i<left.size();i++){\\n            width.push_back(right[i]-left[i]-1);\\n        }\\n        \\n        for(int i=0;i<heights.size();i++){\\n            mx=max(mx,heights[i]*width[i]);\\n        }\\n        \\n        return mx;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {  // Finally......our required Maximal Rectangle Function\\n        int n=matrix.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]-\\'0\\');\\n        }\\n        int mx= MAH(v);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'0\\')\\n                    v[j]=0;\\n                else\\n                    v[j]=v[j]+(matrix[i][j]-\\'0\\');\\n            }\\n            mx=max(mx,MAH(v));\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<int> NSL(vector<int> heights){ // Function to find indices of next smallest left element\\n        vector<int> left;\\n        stack<pair<int,int>> st;\\n        for(int i=0;i<heights.size();i++){\\n            if(st.empty())\\n                left.push_back(-1);\\n            else if(!st.empty() && st.top().first<heights[i])\\n                left.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first>=heights[i]){\\n                while(!st.empty() && st.top().first>=heights[i])\\n                    st.pop();\\n                if(st.empty())\\n                    left.push_back(-1);\\n                else \\n                    left.push_back(st.top().second);\\n            }\\n            st.push({heights[i],i});\\n        }\\n        return left;\\n    }\\n    vector<int> NSR(vector<int> heights){  // Function to find indices of next smallest right element\\n        vector<int> right;\\n        stack<pair<int,int>> st;\\n        for(int i=heights.size()-1;i>=0;i--){\\n            if(st.empty())\\n                right.push_back(heights.size());\\n            else if(!st.empty() && st.top().first<heights[i])\\n                right.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first>=heights[i]){\\n                while(!st.empty() && st.top().first>=heights[i])\\n                    st.pop();\\n                if(st.empty())\\n                    right.push_back(heights.size());\\n                else \\n                    right.push_back(st.top().second);\\n            }\\n            st.push({heights[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n    int MAH(vector<int>& heights) {  //Function to find maximum area of histogram\\n        vector<int> right;\\n        vector<int> left;\\n        \\n        right=NSR(heights);\\n        left=NSL(heights);\\n        \\n        vector<int> width;\\n        int mx=0;\\n        for(int i=0;i<left.size();i++){\\n            width.push_back(right[i]-left[i]-1);\\n        }\\n        \\n        for(int i=0;i<heights.size();i++){\\n            mx=max(mx,heights[i]*width[i]);\\n        }\\n        \\n        return mx;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {  // Finally......our required Maximal Rectangle Function\\n        int n=matrix.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]-\\'0\\');\\n        }\\n        int mx= MAH(v);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'0\\')\\n                    v[j]=0;\\n                else\\n                    v[j]=v[j]+(matrix[i][j]-\\'0\\');\\n            }\\n            mx=max(mx,MAH(v));\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255610,
                "title": "java-simple-detailed-explanation-histogram-approach-o-n-2",
                "content": "**Note:**\\nIf you haven\\'t solved the [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram) problem, I\\'d highly recommend to solve that first. You can check my detailed explanation for the same [here](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1255567/Java-or-Explanation-or-Stack-approach).\\n\\nApproach:\\n1. The idea here is to break the problem in parts. We see each set of rows as a histogram, and evaluate the height of the building considering row in consideration/iteration currently as the base, and evaluating the maximum area using above mentioned **Histogram** approach.\\n2. Then we continue to next row and consider the imaginary histogram with this row as base, and again evaluate the maximum area in this histogram.\\n3. Similarly, we do the above at each row, and keep updating the **maxArea** and have the max. rectangle area at the end.\\n\\nFor example, if the matrix is:\\n1 0 1 0 0\\n1 0 1 1 1\\n1 1 1 1 1\\n1 0 0 1 0\\n\\n**Round-1:**\\nWe consider row-1. Histogram at this point is, `1 0 1 0 0`.\\nHere, `heights[0] = [1,0,1,0,0]`.\\n\\n**Round-2:**\\nWe consider row-1 and row-2.\\nSo now, histogram is of max. height 2, and buildings are like:\\n`1 0 1 0 0`\\n`1 0 1 1 1`\\nSo, here, `heights[1] = [2 0 2 1 1]`.\\n\\nSimilarly, at next levels,\\n`heights[3] = [3 1 3 2 2]`\\n`heights[4] = [4 0 0 3 0]`\\n\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0)\\n            return 0;\\n        int m = matrix.length, n = matrix[0].length;\\n        int[] heights = new int[n];\\n        int maxArea = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (matrix[i][j] == \\'0\\')\\n                    heights[j] = 0;\\n                if (matrix[i][j] == \\'1\\')\\n                    heights[j] += 1;\\n            }\\n            maxArea = Math.max(maxArea, largestRectangleArea(heights));\\n        }\\n        return maxArea;\\n    }\\n\\n    private int largestRectangleArea(int[] heights) {\\n        Stack<int[]> stack = new Stack<>();\\n        int maxArea = 0;\\n\\n        for (int i = 0; i < heights.length; i++) {\\n            int[] block = new int[]{i, heights[i]};\\n            while (!stack.isEmpty() && stack.peek()[1] > heights[i]) {\\n                block = stack.pop();\\n                maxArea = Math.max(maxArea, block[1] * (i - block[0]));\\n                block[1] = heights[i];\\n            }\\n            stack.push(block);\\n        }\\n        while (!stack.isEmpty()) {\\n            int[] block = stack.pop();\\n            maxArea = Math.max(maxArea, block[1] * (heights.length - block[0]));\\n        }\\n        return maxArea;\\n    }\\n}\\n```\\n\\n-------------------------------------------------------------------------------------------\\nHope this helps! Please let me know if something isn\\'t clear/missing. I\\'ll try to improve.\\n\\nAlso, please upvote this if you find this useful. Happy Coding!!",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0)\\n            return 0;\\n        int m = matrix.length, n = matrix[0].length;\\n        int[] heights = new int[n];\\n        int maxArea = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (matrix[i][j] == \\'0\\')\\n                    heights[j] = 0;\\n                if (matrix[i][j] == \\'1\\')\\n                    heights[j] += 1;\\n            }\\n            maxArea = Math.max(maxArea, largestRectangleArea(heights));\\n        }\\n        return maxArea;\\n    }\\n\\n    private int largestRectangleArea(int[] heights) {\\n        Stack<int[]> stack = new Stack<>();\\n        int maxArea = 0;\\n\\n        for (int i = 0; i < heights.length; i++) {\\n            int[] block = new int[]{i, heights[i]};\\n            while (!stack.isEmpty() && stack.peek()[1] > heights[i]) {\\n                block = stack.pop();\\n                maxArea = Math.max(maxArea, block[1] * (i - block[0]));\\n                block[1] = heights[i];\\n            }\\n            stack.push(block);\\n        }\\n        while (!stack.isEmpty()) {\\n            int[] block = stack.pop();\\n            maxArea = Math.max(maxArea, block[1] * (heights.length - block[0]));\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 403093,
                "title": "java-simple-dp-solution-with-state-table",
                "content": "DP State\\n```\\n1 0 1 0 0      1 0 1 0 0\\n1 0 1 1 1  =>  2 0 2 1 1\\n1 1 1 1 1  =>  3 1 3 2 2\\n1 0 0 1 0      4 0 0 3 0\\n```\\nFind the **max area** row by row, as we can see `3 1 3 2 2` contains the **max area**.\\n\\n```java\\nclass Solution {\\n  public int maximalRectangle(char[][] matrix) {\\n    if (matrix.length <= 0) return 0;\\n    int n = matrix.length;\\n    int m = matrix[0].length;\\n    int[][] dp = new int[n][m];\\n    int maxArea = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (i == 0)\\n\\t\\t  dp[i][j] = matrix[i][j] == \\'1\\' ? 1 : 0;\\n        else\\n\\t\\t  dp[i][j] = matrix[i][j] == \\'1\\' ? (dp[i-1][j] + 1) : 0;\\n        int min = dp[i][j];\\n        for (int k = j; k >= 0; k--) {\\n          if (min == 0) break;\\n          if (dp[i][k] < min) min = dp[i][k];\\n          maxArea = Math.max(maxArea, min * (j - k + 1));\\n        }\\n      }\\n    }\\n    return maxArea;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n1 0 1 0 0      1 0 1 0 0\\n1 0 1 1 1  =>  2 0 2 1 1\\n1 1 1 1 1  =>  3 1 3 2 2\\n1 0 0 1 0      4 0 0 3 0\\n```\n```java\\nclass Solution {\\n  public int maximalRectangle(char[][] matrix) {\\n    if (matrix.length <= 0) return 0;\\n    int n = matrix.length;\\n    int m = matrix[0].length;\\n    int[][] dp = new int[n][m];\\n    int maxArea = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (i == 0)\\n\\t\\t  dp[i][j] = matrix[i][j] == \\'1\\' ? 1 : 0;\\n        else\\n\\t\\t  dp[i][j] = matrix[i][j] == \\'1\\' ? (dp[i-1][j] + 1) : 0;\\n        int min = dp[i][j];\\n        for (int k = j; k >= 0; k--) {\\n          if (min == 0) break;\\n          if (dp[i][k] < min) min = dp[i][k];\\n          maxArea = Math.max(maxArea, min * (j - k + 1));\\n        }\\n      }\\n    }\\n    return maxArea;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29080,
                "title": "my-solution-on-java-using-dp",
                "content": "Open matrix from top to the bottom line by line, counting height of each column. Then check for each  column (only if it wasn't counted already) how many times it appears to the right and to the left.  Area = (left+right)*height. Just pick the max one. Pretty fast\\n\\n    public class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n            int area = 0, new_area, r, l;\\n            if(matrix.length > 0){\\n                int[] line = new int[matrix[0].length];\\n                boolean[] is_processed = new boolean[matrix[0].length];\\n                for(int i = 0; i < matrix.length; i++){\\n                    for(int j = 0; j < matrix[i].length; j++){\\n                        if (matrix[i][j] == '1') {\\n                            line[j]++;\\n                            is_processed[j] = false;\\n                        } else {\\n                            line[j] = 0;\\n                            is_processed[j] = true;\\n                        }\\n                    }\\n                    for(int j = 0; j < matrix[i].length; j++){\\n                        if(is_processed[j]) continue;\\n                        r = l = 1;\\n                        while((j + r < line.length)&&(line[j + r] >= line[j])){\\n                            if(line[j + r] == line[j]) is_processed[j + r] = true;\\n                            r++;\\n                        }\\n                        while((j - l >= 0)&&(line[j - l] >= line[j])) l++;\\n                        new_area = (r + l - 1)*line[j];\\n                        if (new_area > area) area = new_area;\\n                    }\\n                }\\n            } return area;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n            int area = 0, new_area, r, l;\\n            if(matrix.length > 0){\\n                int[] line = new int[matrix[0].length];\\n                boolean[] is_processed = new boolean[matrix[0].length];\\n                for(int i = 0; i < matrix.length; i++){\\n                    for(int j = 0; j < matrix[i].length; j++){\\n                        if (matrix[i][j] == '1') {\\n                            line[j]++;\\n                            is_processed[j] = false;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1921903,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n\\tfunc maximalRectangle(_ matrix: [[Character]]) -> Int {\\n        if matrix.count == 0 || matrix[0].count == 0 { return 0 }\\n        var max = 0\\n\\n        for i in 0..<matrix.count {\\n            for j in 0..<matrix[0].count {\\n                let area = helper(matrix, i, j, matrix.count,  matrix[0].count)\\n                max = max > area ? max : area\\n            }\\n        }\\n        \\n        return max\\n    }\\n\\n\\n    func helper(_ matrix: [[Character]], _ i: Int, _ j: Int, _ maxI: Int, _ maxJ: Int) -> Int {\\n        if matrix[i][j] == \"0\" || maxI == i || maxJ == j { return 0 }\\n        var x = -1\\n        var y = -1\\n\\n        loop: \\n        for row in i..<maxI {\\n            for col in j..<maxJ {\\n                if matrix[row][col] == \"0\" {\\n                    x = row\\n                    y = col\\n                    break loop\\n                }\\n            }\\n        }\\n        \\n        if x >= 0 {\\n            return max(helper(matrix, i, j, x, maxJ), helper(matrix, i, j, maxI, y))\\n        } else {\\n            return (maxI - i) * (maxJ - j)\\n        } \\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc maximalRectangle(_ matrix: [[Character]]) -> Int {\\n        if matrix.count == 0 || matrix[0].count == 0 { return 0 }\\n        var max = 0\\n\\n        for i in 0..<matrix.count {\\n            for j in 0..<matrix[0].count {\\n                let area = helper(matrix, i, j, matrix.count,  matrix[0].count)\\n                max = max > area ? max : area\\n            }\\n        }\\n        \\n        return max\\n    }\\n\\n\\n    func helper(_ matrix: [[Character]], _ i: Int, _ j: Int, _ maxI: Int, _ maxJ: Int) -> Int {\\n        if matrix[i][j] == \"0\" || maxI == i || maxJ == j { return 0 }\\n        var x = -1\\n        var y = -1\\n\\n        loop: \\n        for row in i..<maxI {\\n            for col in j..<maxJ {\\n                if matrix[row][col] == \"0\" {\\n                    x = row\\n                    y = col\\n                    break loop\\n                }\\n            }\\n        }\\n        \\n        if x >= 0 {\\n            return max(helper(matrix, i, j, x, maxJ), helper(matrix, i, j, maxI, y))\\n        } else {\\n            return (maxI - i) * (maxJ - j)\\n        } \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705081,
                "title": "c-dp-stack-o-n-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int getarea(vector<vector<int>>&dp , int row , int n)\\n    {\\n        \\n        vector<int> pre(n) ; \\n        pre[0] = -1 ;\\n        vector<int> next(n) ;\\n        next[n-1] = n ; \\n        stack<int> s ; \\n        s.push(0) ; \\n        \\n        for(int i = 1 ; i<n ; i++)\\n        {\\n            if(dp[row][s.top()] < dp[row][i]) \\n            {\\n                pre[i] = s.top() ; \\n                s.push(i) ; \\n            }\\n            else\\n            {\\n                while(!s.empty() && dp[row][s.top()] >= dp[row][i]) \\n                {\\n                    s.pop() ; \\n                }\\n                if(s.empty())\\n                {\\n                    pre[i] = -1 ; \\n                    s.push(i) ;\\n                }\\n                else\\n                {\\n                    pre[i] = s.top() ; \\n                    s.push(i) ; \\n                }\\n            }\\n        }\\n        // s.clear() ; \\n        while(!s.empty()) s.pop() ; \\n        \\n        s.push(n-1) ; \\n        for(int i = n-2 ; i>=0 ; i--)\\n        {\\n            if(dp[row][s.top()] < dp[row][i]) \\n            {\\n                next[i] = s.top() ; \\n                s.push(i) ; \\n            }\\n            else\\n            {\\n                while(!s.empty() && dp[row][s.top()] >= dp[row][i]) \\n                {\\n                    s.pop() ; \\n                }\\n                if(s.empty())\\n                {\\n                    s.push(i) ;\\n                    next[i] = n ; \\n                }\\n                else\\n                {\\n                    next[i] = s.top() ; \\n                    s.push(i) ; \\n                }\\n            }\\n        }\\n        int ans = INT_MIN ; \\n        int area ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            area = ( next[i] - pre[i] - 1) * dp[row][i] ; \\n            ans = max(ans , area) ; \\n        }\\n        return ans ; \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size() ; \\n        int m = matrix[0].size() ; \\n        vector<vector<int>> dp(n , vector<int> (m)) ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(i == 0)\\n                {\\n                    if(matrix[i][j] == \\'0\\') dp[i][j] = 0 ;\\n                    else dp[i][j] = 1 ; \\n                    continue ;  \\n                }\\n                if(matrix[i][j] == \\'0\\') dp[i][j] = 0 ; \\n                else dp[i][j] = dp[i-1][j] + 1 ; \\n            }\\n        }\\n        int ans = INT_MIN ; \\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int area = getarea(dp , i , m ) ; \\n            ans = max(ans , area) ;\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getarea(vector<vector<int>>&dp , int row , int n)\\n    {\\n        \\n        vector<int> pre(n) ; \\n        pre[0] = -1 ;\\n        vector<int> next(n) ;\\n        next[n-1] = n ; \\n        stack<int> s ; \\n        s.push(0) ; \\n        \\n        for(int i = 1 ; i<n ; i++)\\n        {\\n            if(dp[row][s.top()] < dp[row][i]) \\n            {\\n                pre[i] = s.top() ; \\n                s.push(i) ; \\n            }\\n            else\\n            {\\n                while(!s.empty() && dp[row][s.top()] >= dp[row][i]) \\n                {\\n                    s.pop() ; \\n                }\\n                if(s.empty())\\n                {\\n                    pre[i] = -1 ; \\n                    s.push(i) ;\\n                }\\n                else\\n                {\\n                    pre[i] = s.top() ; \\n                    s.push(i) ; \\n                }\\n            }\\n        }\\n        // s.clear() ; \\n        while(!s.empty()) s.pop() ; \\n        \\n        s.push(n-1) ; \\n        for(int i = n-2 ; i>=0 ; i--)\\n        {\\n            if(dp[row][s.top()] < dp[row][i]) \\n            {\\n                next[i] = s.top() ; \\n                s.push(i) ; \\n            }\\n            else\\n            {\\n                while(!s.empty() && dp[row][s.top()] >= dp[row][i]) \\n                {\\n                    s.pop() ; \\n                }\\n                if(s.empty())\\n                {\\n                    s.push(i) ;\\n                    next[i] = n ; \\n                }\\n                else\\n                {\\n                    next[i] = s.top() ; \\n                    s.push(i) ; \\n                }\\n            }\\n        }\\n        int ans = INT_MIN ; \\n        int area ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            area = ( next[i] - pre[i] - 1) * dp[row][i] ; \\n            ans = max(ans , area) ; \\n        }\\n        return ans ; \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size() ; \\n        int m = matrix[0].size() ; \\n        vector<vector<int>> dp(n , vector<int> (m)) ; \\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(i == 0)\\n                {\\n                    if(matrix[i][j] == \\'0\\') dp[i][j] = 0 ;\\n                    else dp[i][j] = 1 ; \\n                    continue ;  \\n                }\\n                if(matrix[i][j] == \\'0\\') dp[i][j] = 0 ; \\n                else dp[i][j] = dp[i-1][j] + 1 ; \\n            }\\n        }\\n        int ans = INT_MIN ; \\n        \\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int area = getarea(dp , i , m ) ; \\n            ans = max(ans , area) ;\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239576,
                "title": "c-based-on-largest-rectangle-in-histogram",
                "content": "```\\nint maxHistogram(vector<int>& heights)\\n    {\\n        heights.push_back(0);\\n        int n = heights.size();\\n        stack<int> st;\\n        int res = 0;\\n        \\n        int i = 0;\\n        while(i < n)\\n        {\\n            if(st.empty() || heights[i] >= heights[st.top()])\\n              st.push(i++);\\n            else\\n             {\\n                 int top = st.top();\\n                 st.pop();\\n                 res = max(res, heights[top] * (st.empty() ? i : i - st.top() - 1));\\n             }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {\\n        if(matrix.empty())\\n            return 0;\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int res = 0;\\n        \\n        vector<int> height(n, 0);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(matrix[i][j] == \\'1\\')\\n                    height[j]++;\\n                else\\n                    height[j] = 0;\\n            }\\n            \\n            res = max(res, maxHistogram(height));\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nint maxHistogram(vector<int>& heights)\\n    {\\n        heights.push_back(0);\\n        int n = heights.size();\\n        stack<int> st;\\n        int res = 0;\\n        \\n        int i = 0;\\n        while(i < n)\\n        {\\n            if(st.empty() || heights[i] >= heights[st.top()])\\n              st.push(i++);\\n            else\\n             {\\n                 int top = st.top();\\n                 st.pop();\\n                 res = max(res, heights[top] * (st.empty() ? i : i - st.top() - 1));\\n             }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {\\n        if(matrix.empty())\\n            return 0;\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int res = 0;\\n        \\n        vector<int> height(n, 0);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(matrix[i][j] == \\'1\\')\\n                    height[j]++;\\n                else\\n                    height[j] = 0;\\n            }\\n            \\n            res = max(res, maxHistogram(height));\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29122,
                "title": "step-by-step-thoughts-on-the-problem",
                "content": "Just like my previous post of the largest area under the histogram.\\n\\nWe can solve this problem by solve level by level and the sub-problem is just the largest rectangle under the histogram.\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char>>& matrix) {\\n            /** largest rectangle based solution **/\\n            if(matrix.size()<=0 || matrix[0].size()<=0)\\n                return 0;\\n            int m=matrix.size();\\n            int n=matrix[0].size()+1;\\n            int h=0, w=0, result=0;\\n            vector<int> height(n, 0);\\n            for(int i=0; i<m; i++){\\n                stack<int> s;\\n                for(int j=0; j<n; j++){\\n                    /** update the current row ended height array **/\\n                    if(j<n-1){\\n                        if(matrix[i][j]=='1')  height[j]+=1;\\n                        else height[j]=0;\\n                    }\\n                    /** use the histogram-max-rectangle-module **/\\n                    while(!s.empty() && height[s.top()]>=height[j]){\\n                        h=height[s.top()];\\n                        s.pop();\\n                        w=s.empty() ? j:j-s.top()-1;\\n                        if(h*w>result) result=h*w;\\n                    }\\n                    s.push(j);\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char>>& matrix) {\\n            /** largest rectangle based solution **/\\n            if(matrix.size()<=0 || matrix[0].size()<=0)\\n                return 0;\\n            int m=matrix.size();\\n            int n=matrix[0].size()+1;\\n            int h=0, w=0, result=0;\\n            vector<int> height(n, 0);\\n            for(int i=0; i<m; i++){\\n                stack<int> s;\\n                for(int j=0; j<n; j++){\\n                    /** update the current row ended height array **/\\n                    if(j<n-1){\\n                        if(matrix[i][j]=='1')  height[j]+=1;\\n                        else height[j]=0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 29143,
                "title": "c-solution-uff0c-simple-and-clean-code",
                "content": "     int maximalRectangle(vector<vector<char>>& matrix) {\\n        const int row = matrix.size();\\n        if (0 == row) return 0;\\n        const int col = matrix[0].size();\\n        vector<vector<int>> ones(row, vector<int>(col+1, 0));\\n        for (int i = 0; i < row; i++) \\n         for (int j = 0; j < col; j++) {\\n              if (matrix[i][j] == '1') {\\n                  ones[i][j] = 1 + (i > 0 ? ones[i-1][j] : 0);\\n              }\\n         }\\n         int i = 0, max_a = 0;\\n         for (i; i < row; i++) {\\n             stack<int> stk;\\n             vector<int> cur = ones[i];\\n             int idx = 0;\\n             while (idx < cur.size()) {\\n                 if (stk.empty() || cur[idx] >= cur[stk.top()]) {\\n                     stk.push(idx++);\\n                 } else {\\n                    int h = stk.top();\\n                    stk.pop();\\n                    max_a = max(max_a, cur[h] *(stk.empty() ? idx : idx - stk.top() - 1));\\n                 }\\n             }\\n         }\\n         return max_a;\\n    }",
                "solutionTags": [],
                "code": "     int maximalRectangle(vector<vector<char>>& matrix) {\\n        const int row = matrix.size();\\n        if (0 == row) return 0;\\n        const int col = matrix[0].size();\\n        vector<vector<int>> ones(row, vector<int>(col+1, 0));\\n        for (int i = 0; i < row; i++) \\n         for (int j = 0; j < col; j++) {\\n              if (matrix[i][j] == '1') {\\n                  ones[i][j] = 1 + (i > 0 ? ones[i-1][j] : 0);\\n              }\\n         }\\n         int i = 0, max_a = 0;\\n         for (i; i < row; i++) {\\n             stack<int> stk;\\n             vector<int> cur = ones[i];\\n             int idx = 0;\\n             while (idx < cur.size()) {\\n                 if (stk.empty() || cur[idx] >= cur[stk.top()]) {\\n                     stk.push(idx++);\\n                 } else {\\n                    int h = stk.top();\\n                    stk.pop();\\n                    max_a = max(max_a, cur[h] *(stk.empty() ? idx : idx - stk.top() - 1));\\n                 }\\n             }\\n         }\\n         return max_a;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2954041,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        int n=heights.size();\\n        vector<int> left(n);\\n        vector<int> ryt(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                            st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else\\n                left[i]=st.top()+1;\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                ryt[i]=n-1;\\n            else\\n                ryt[i]=st.top()-1;\\n            st.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int area=heights[i]*(ryt[i]-left[i]+1);\\n            ans=max(ans, area);\\n        }\\n        return ans;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                dp[i][j]=matrix[i][j]-\\'0\\';\\n        \\n        for(int i=1;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(dp[i][j]!=0)\\n                    dp[i][j]+=dp[i-1][j];\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n            ans=max(ans, largestRectangleArea(dp[i]));\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> st;\\n        int n=heights.size();\\n        vector<int> left(n);\\n        vector<int> ryt(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                            st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else\\n                left[i]=st.top()+1;\\n            st.push(i);\\n        }\\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && heights[i]<=heights[st.top()])\\n                st.pop();\\n            if(st.empty())\\n                ryt[i]=n-1;\\n            else\\n                ryt[i]=st.top()-1;\\n            st.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int area=heights[i]*(ryt[i]-left[i]+1);\\n            ans=max(ans, area);\\n        }\\n        return ans;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                dp[i][j]=matrix[i][j]-\\'0\\';\\n        \\n        for(int i=1;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(dp[i][j]!=0)\\n                    dp[i][j]+=dp[i-1][j];\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n            ans=max(ans, largestRectangleArea(dp[i]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228033,
                "title": "dp-concise-explanation-97-faster-javascript-js-es6",
                "content": "\\n`ALGORITHM:` \\n- Initiate an aux-matrix with zeroes to begin with.\\n- The first row of aux-matrix is same as matrix\\'s first row.\\n- Values in aux-matrix reflect the height for that column, like this:\\n```\\n[\"1\",\"0\",\"1\",\"0\",\"0\"]\\n[\"1\",\"0\",\"1\",\"1\",\"1\"]\\n[\"1\",\"1\",\"1\",\"1\",\"1\"]\\n[\"1\",\"0\",\"0\",\"1\",\"0\"]\\nbecomes\\n[\"1\",\"0\",\"1\",\"0\",\"0\"]\\n[\"2\",\"0\",\"2\",\"1\",\"1\"]\\n[\"3\",\"1\",\"3\",\"2\",\"2\"]\\n[\"4\",\"0\",\"0\",\"3\",\"0\"]]\\n```\\n- Another for-loop moves the column-pointer backwards, while updating the maxArea \\n\\n`CODE:`\\n```\\nconst maximalRectangle = function(matrix) {\\n  if (!matrix.length) return 0;\\n  const ROWS = matrix.length;\\n  const COLS = matrix[0].length;\\n  const dp = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));\\n  let maxArea = 0;\\n  \\n  for (let row = 0; row < ROWS; row++) {\\n    for (let col = 0; col < COLS; col++) {\\n\\t\\n\\t  //update height\\n      if(row === 0) dp[row][col] = matrix[row][col] == \\'1\\' ? 1 : 0;\\n      else dp[row][col] = matrix[row][col] == \\'1\\' ? (dp[row-1][col] + 1) : 0;\\n\\t  \\n      //update area \\n\\t  let minHeight = dp[row][col];\\n\\t  for(let pointer = col; pointer >= 0; pointer--) {\\n\\t\\t if (minHeight === 0) break;\\n\\t\\t if (dp[row][pointer] < minHeight) minHeight = dp[row][pointer];\\n\\t\\t maxArea = Math.max(maxArea, minHeight * (col - pointer + 1));\\n\\t  }\\n   }\\n  }\\n  return maxArea;  \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6e93b417-3583-4f58-9804-5719bc8dd99e_1621868328.6235888.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n[\"1\",\"0\",\"1\",\"0\",\"0\"]\\n[\"1\",\"0\",\"1\",\"1\",\"1\"]\\n[\"1\",\"1\",\"1\",\"1\",\"1\"]\\n[\"1\",\"0\",\"0\",\"1\",\"0\"]\\nbecomes\\n[\"1\",\"0\",\"1\",\"0\",\"0\"]\\n[\"2\",\"0\",\"2\",\"1\",\"1\"]\\n[\"3\",\"1\",\"3\",\"2\",\"2\"]\\n[\"4\",\"0\",\"0\",\"3\",\"0\"]]\\n```\n```\\nconst maximalRectangle = function(matrix) {\\n  if (!matrix.length) return 0;\\n  const ROWS = matrix.length;\\n  const COLS = matrix[0].length;\\n  const dp = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));\\n  let maxArea = 0;\\n  \\n  for (let row = 0; row < ROWS; row++) {\\n    for (let col = 0; col < COLS; col++) {\\n\\t\\n\\t  //update height\\n      if(row === 0) dp[row][col] = matrix[row][col] == \\'1\\' ? 1 : 0;\\n      else dp[row][col] = matrix[row][col] == \\'1\\' ? (dp[row-1][col] + 1) : 0;\\n\\t  \\n      //update area \\n\\t  let minHeight = dp[row][col];\\n\\t  for(let pointer = col; pointer >= 0; pointer--) {\\n\\t\\t if (minHeight === 0) break;\\n\\t\\t if (dp[row][pointer] < minHeight) minHeight = dp[row][pointer];\\n\\t\\t maxArea = Math.max(maxArea, minHeight * (col - pointer + 1));\\n\\t  }\\n   }\\n  }\\n  return maxArea;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1603527,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size(); \\n        if(row==0) return 0;\\n        int col = matrix[0].size();\\n        vector<vector<int>> grid(row,vector<int> (col,0));\\n        int area=0;\\n        for(int i=0; i<row; ++i){\\n            for(int j=0; j<col; ++j){\\n                if(i==0){\\n                    grid[i][j]=matrix[i][j]-\\'0\\';\\n                }else{\\n                    if(matrix[i][j]==\\'0\\') grid[i][j]=0;\\n                    else grid[i][j] = 1+grid[i-1][j];\\n                }\\n            }\\n            \\n            vector<int> left(col), right(col);\\n            stack<int> stk;\\n            for(int j=0; j<col; ++j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) left[j]=-1 ;\\n                else left[j]=stk.top();\\n                stk.push(j);\\n            }\\n            \\n            while(!stk.empty()) stk.pop();\\n            \\n            for(int j=col-1; j>=0; --j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) right[j]=col;\\n                else right[j]=stk.top();\\n                stk.push(j);\\n            }\\n            \\n            for(int j=0;j<col;++j){\\n                area=max(area, (grid[i][j]*(right[j]-left[j]-1)));\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size(); \\n        if(row==0) return 0;\\n        int col = matrix[0].size();\\n        vector<vector<int>> grid(row,vector<int> (col,0));\\n        int area=0;\\n        for(int i=0; i<row; ++i){\\n            for(int j=0; j<col; ++j){\\n                if(i==0){\\n                    grid[i][j]=matrix[i][j]-\\'0\\';\\n                }else{\\n                    if(matrix[i][j]==\\'0\\') grid[i][j]=0;\\n                    else grid[i][j] = 1+grid[i-1][j];\\n                }\\n            }\\n            \\n            vector<int> left(col), right(col);\\n            stack<int> stk;\\n            for(int j=0; j<col; ++j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) left[j]=-1 ;\\n                else left[j]=stk.top();\\n                stk.push(j);\\n            }\\n            \\n            while(!stk.empty()) stk.pop();\\n            \\n            for(int j=col-1; j>=0; --j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) right[j]=col;\\n                else right[j]=stk.top();\\n                stk.push(j);\\n            }\\n            \\n            for(int j=0;j<col;++j){\\n                area=max(area, (grid[i][j]*(right[j]-left[j]-1)));\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331110,
                "title": "maximal-rectangle-using-max-area-histogram-aditya-verma-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    /*\\n    \\n    1.> for every row consider as 1 block of height \\n    2.> write maximum are in histogram\\n    3.> for MAH \\n        a> create a left array of next smaller element  to left\\n        b> create a right array of next smaller to right\\n        c> create a width array\\n        d>make area array \\n        e> take max area\\n    4> for all row it return a max area\\n    5> take maximu of all returned value\\n    6> which is our answer\\n    \\n    \\n    \\n    */\\n    int MAH(int*arr,int n)\\n    {  // next smaller to right side\\n        stack<pair<int,int>>stk1;\\n        vector<int>right;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stk1.empty() and stk1.top().first>=arr[i])\\n            {\\n                stk1.pop();\\n            }\\n            if(stk1.empty())\\n            {\\n                right.push_back(n);\\n            }\\n            else\\n                right.push_back(stk1.top().second);\\n            \\n            stk1.push({arr[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        // next smaller to left side of array\\n        \\n        stack<pair<int,int>>stk2;\\n        vector<int>left;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!stk2.empty() and stk2.top().first>=arr[i])\\n            {\\n                stk2.pop();\\n            }\\n            if(stk2.empty())\\n            {\\n                left.push_back(-1);\\n            }\\n            else\\n            {\\n                left.push_back(stk2.top().second);\\n            }\\n            stk2.push({arr[i],i});\\n        }\\n        \\n        // make width array and area area;\\n        vector<int>area;\\n        for(int i=0;i<n;i++)\\n        {\\n            area.push_back((right[i]-left[i]-1)*arr[i]);\\n        }\\n        int no=*max_element(area.begin(),area.end());\\n        return no;\\n        \\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {   if(matrix.empty())\\n        return 0;\\n        int n=matrix[0].size();\\n         \\n        \\n         int arr[200];\\n         vector<int>check;\\n         for(int i=0;i<n;i++)\\n         {\\n             arr[i]=0;\\n         }\\n        for(int i=0;i<matrix.size();i++)\\n        {     int k=0;\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    arr[k]=arr[k]+1;\\n                     k++;\\n                    \\n                }\\n                else\\n                {\\n                    arr[k]=0;\\n                    k++;\\n                }\\n                    \\n           }\\n           \\n          int no=MAH(arr,n);\\n           \\n          check.push_back(no);\\n        }\\n        int ans=0;\\n        ans=*max_element(check.begin(),check.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    /*\\n    \\n    1.> for every row consider as 1 block of height \\n    2.> write maximum are in histogram\\n    3.> for MAH \\n        a> create a left array of next smaller element  to left\\n        b> create a right array of next smaller to right\\n        c> create a width array\\n        d>make area array \\n        e> take max area\\n    4> for all row it return a max area\\n    5> take maximu of all returned value\\n    6> which is our answer\\n    \\n    \\n    \\n    */\\n    int MAH(int*arr,int n)\\n    {  // next smaller to right side\\n        stack<pair<int,int>>stk1;\\n        vector<int>right;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!stk1.empty() and stk1.top().first>=arr[i])\\n            {\\n                stk1.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1149784,
                "title": "python-monotone-stack-solution-with-comments-and-explanation",
                "content": "This problem can be visualised as an extension to [largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\nIn the above problem you can use Next Smallest Element (NSE) logic on a monotonically increasing stack to find the maximum rectangle possible in the histogram given.\\n\\nYou can easily extend that concept on this 2D matrix by constructing/updating histogram row by row and processing on the histogram. \\n1.  For the first row the whole row is a histogram with bar heights either 1 or 0\\n2.  For the next row we update the histogram as\\n        =>  If the value of current grid is \\'0\\' then histogram height is reset to 0 (as the continuation of the rectangle breaks here)\\n\\t\\t=>  If the value of the current grid is \\'1\\' then histogram height can be increased by 1 vertically\\n3.  So on for rest of the rows...\\n**Note:**  As we are processing row by row so rectangle continuity in horizontal direction is handled in histogram automatically while the vertical continuity is handled by updating the histogram as in step 2.\\n4. Now after updating the histogram for each row, we calculate the maximum area of rectangle possible.\\n5. Once we have maximum from all the rows, we pick the maximum of the maximums to get our final answer. \\n\\nExample:\\n**Input:** \\n```\\n[\\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\\n]\\n```\\n\\n**Histogram creation and updation for each row of matrix:**\\n```\\nRow 1 => [1, 0, 1, 0, 0]   [current max = 1 and overall max = 1]\\nRow 2 => [2, 0, 2, 1, 1]   [current max = 3 and overall max = 3]\\nRow 3 => [3, 1, 3, 2, 2]   [current max = 6 and overall max = 6]\\nRow 4 => [4, 0, 0, 3, 0]   [current max = 4 and overall max = 6]\\n```\\nAs you can see the final answer will be picked as 6\\n\\n**Code:**\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0  # To handle `matrix = []` case\\n\\t\\t\\n\\t\\t# Prepare histogram for the first row of input matrix and find maximum area.\\n        histogram = list(map(int, matrix[0]))\\n        histogram.append(0)\\n        current_max = self.max_rect_histogram(histogram)\\n\\t\\t\\n\\t\\t# Process on the remaining rows of matrix\\n        for row in matrix[1:]:\\n            for i in range(len(row)):\\n\\t\\t\\t    # update histogram, if grid is a \\'0\\' reset histogram height else increase height by one\\n                if row[i] == \\'0\\':\\n                    histogram[i] = 0\\n                else:\\n                    histogram[i] += int(row[i])\\n\\t\\t\\t# Once histogram is updated for current row find the maximum rectangle area in current histogram\\n            current_max = max(current_max, self.max_rect_histogram(histogram))\\n        return current_max\\n        \\n    def max_rect_histogram(self, histogram):\\n        stack = [-1]\\n        mx = 0\\n        for i,v in enumerate(histogram):\\n\\t\\t\\t# As long as the stack has increasing value keep adding the index of histogram\\n\\t\\t\\t# If the insertion to stack will result in a decreasing stack, then keep poping till it becomes increasing again\\n\\t\\t\\t# For each pop, calculate the area of the rectangle\\n            while(stack[-1] != -1 and histogram[stack[-1]] > v):\\n                height = histogram[stack.pop()]\\n\\t\\t\\t\\t# i is right limit, stack[-1] is left limit so width of rectangle in consideration is r-l-1\\n                width = i - stack[-1] - 1\\n                mx = max(mx, height*width)\\n            stack.append(i)\\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\n[\\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\\n]\\n```\n```\\nRow 1 => [1, 0, 1, 0, 0]   [current max = 1 and overall max = 1]\\nRow 2 => [2, 0, 2, 1, 1]   [current max = 3 and overall max = 3]\\nRow 3 => [3, 1, 3, 2, 2]   [current max = 6 and overall max = 6]\\nRow 4 => [4, 0, 0, 3, 0]   [current max = 4 and overall max = 6]\\n```\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0  # To handle `matrix = []` case\\n\\t\\t\\n\\t\\t# Prepare histogram for the first row of input matrix and find maximum area.\\n        histogram = list(map(int, matrix[0]))\\n        histogram.append(0)\\n        current_max = self.max_rect_histogram(histogram)\\n\\t\\t\\n\\t\\t# Process on the remaining rows of matrix\\n        for row in matrix[1:]:\\n            for i in range(len(row)):\\n\\t\\t\\t    # update histogram, if grid is a \\'0\\' reset histogram height else increase height by one\\n                if row[i] == \\'0\\':\\n                    histogram[i] = 0\\n                else:\\n                    histogram[i] += int(row[i])\\n\\t\\t\\t# Once histogram is updated for current row find the maximum rectangle area in current histogram\\n            current_max = max(current_max, self.max_rect_histogram(histogram))\\n        return current_max\\n        \\n    def max_rect_histogram(self, histogram):\\n        stack = [-1]\\n        mx = 0\\n        for i,v in enumerate(histogram):\\n\\t\\t\\t# As long as the stack has increasing value keep adding the index of histogram\\n\\t\\t\\t# If the insertion to stack will result in a decreasing stack, then keep poping till it becomes increasing again\\n\\t\\t\\t# For each pop, calculate the area of the rectangle\\n            while(stack[-1] != -1 and histogram[stack[-1]] > v):\\n                height = histogram[stack.pop()]\\n\\t\\t\\t\\t# i is right limit, stack[-1] is left limit so width of rectangle in consideration is r-l-1\\n                width = i - stack[-1] - 1\\n                mx = max(mx, height*width)\\n            stack.append(i)\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787990,
                "title": "python-solution-built-off-of-maximal-square-time-complexity-o-n-3",
                "content": "```class Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        #prepping max squares array and finding largest value in array (max_num)\\n\\t\\tmax_num = 1\\n        for i in range(m):\\n            matrix[i][0] = int(matrix[i][0])\\n\\n        for j in range(n):\\n            matrix[0][j] = int(matrix[0][j])\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][j] == \\'1\\':\\n                    tmp = min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\\n                    matrix[i][j] = tmp\\n                    max_num = max(max_num, tmp)\\n                else:\\n                    matrix[i][j] = 0\\n    \\n\\t\\t#initialize array for global longest chain of each number\\n        max_values = [0 for i in range(max_num)]\\n        \\n        #iterate through rows to find longest chain of each value\\n\\t\\tfor step in range(max_num):\\n            for i in range(m):\\n                curr_value = 0\\n                for j in range(n):\\n                    if matrix[i][j] > step:\\n                        curr_value += 1\\n                    else:\\n                        if curr_value > max_values[step]:\\n                            max_values[step] = curr_value\\n                        curr_value = 0\\n                if curr_value > max_values[step]:\\n                    max_values[step] = curr_value\\n            \\n        #iterate through columns to find largest chain of each value\\n        for step in range(max_num):\\n            for j in range(n):\\n                curr_value = 0\\n                for i in range(m):\\n                    if matrix[i][j] > step:\\n                        curr_value += 1\\n                    else:\\n                        if curr_value > max_values[step]:\\n                            max_values[step] = curr_value\\n                        curr_value = 0\\n                if curr_value > max_values[step]:\\n                    max_values[step] = curr_value                \\n                        \\n        res = 0\\n        \\n\\t\\t#area of the rectangle can be calculated from neigboring squares\\n        for s, count in enumerate(max_values):\\n            if count != 0:\\n                res = max(res, (s + 1) ** 2 + (s + 1) * (count - 1))\\n        \\n        return res",
                "solutionTags": [],
                "code": "```class Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        #prepping max squares array and finding largest value in array (max_num)\\n\\t\\tmax_num = 1\\n        for i in range(m):\\n            matrix[i][0] = int(matrix[i][0])\\n\\n        for j in range(n):\\n            matrix[0][j] = int(matrix[0][j])\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][j] == \\'1\\':\\n                    tmp = min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\\n                    matrix[i][j] = tmp\\n                    max_num = max(max_num, tmp)\\n                else:\\n                    matrix[i][j] = 0\\n    \\n\\t\\t#initialize array for global longest chain of each number\\n        max_values = [0 for i in range(max_num)]\\n        \\n        #iterate through rows to find longest chain of each value\\n\\t\\tfor step in range(max_num):\\n            for i in range(m):\\n                curr_value = 0\\n                for j in range(n):\\n                    if matrix[i][j] > step:\\n                        curr_value += 1\\n                    else:\\n                        if curr_value > max_values[step]:\\n                            max_values[step] = curr_value\\n                        curr_value = 0\\n                if curr_value > max_values[step]:\\n                    max_values[step] = curr_value\\n            \\n        #iterate through columns to find largest chain of each value\\n        for step in range(max_num):\\n            for j in range(n):\\n                curr_value = 0\\n                for i in range(m):\\n                    if matrix[i][j] > step:\\n                        curr_value += 1\\n                    else:\\n                        if curr_value > max_values[step]:\\n                            max_values[step] = curr_value\\n                        curr_value = 0\\n                if curr_value > max_values[step]:\\n                    max_values[step] = curr_value                \\n                        \\n        res = 0\\n        \\n\\t\\t#area of the rectangle can be calculated from neigboring squares\\n        for s, count in enumerate(max_values):\\n            if count != 0:\\n                res = max(res, (s + 1) ** 2 + (s + 1) * (count - 1))\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 768988,
                "title": "simple-solution-using-nsr-and-nsl-stack-based-solution",
                "content": "``\\nSame approach as to find maximum area histogram using Nearest smaller to left and Nearest smaller to right, only difference is that maximum area histogram is 1D and this is 2D so we start taking by one row at a time and find its area and keep max_area variable which keep track of max and then add it to second row and find again and so on and just keep in mind one thing while you are at current row and adding values to previous check if current level ith value is 0 or 1 if 0 then put 0 because if base is zero which is not possible means bulding can\\'t be in air and if 1 then add it...\\n``\\n\\n```\\nclass Solution {\\npublic:\\n    int pseudoIndex;\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n       int rows = matrix.size();\\n        if (rows == 0) {\\n            return 0;\\n        }\\n        int cols = matrix[0].size();\\n        if (cols == 0) {\\n            return 0;\\n        }\\n        vector<int>histogram(cols,0);\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i< rows; i++) {\\n            for (int j = 0; j< cols; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    histogram[j] = 0;\\n                }\\n                else {\\n                    histogram[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            int area = largestRectangleArea(histogram);\\n            \\n            res = max(area, res);\\n        }\\n        return res;\\n    }\\n    \\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        if(heights.size() == 0)\\n            return 0;\\n        //we store index of nearest smaller to left of i\\n        vector<int> nsl = NearestSmallerToLeft(heights);\\n        //we store index of nearest smaller to right of i\\n        vector<int> nsr = NearestSmallerToRight(heights);\\n        \\n        //find the max area possible\\n        int max_area = INT_MIN,area;\\n        for(int i = 0; i < heights.size(); i++)\\n        {\\n            area = (nsr[i]-nsl[i]-1)*heights[i];\\n            max_area = max(area,max_area);\\n        }\\n        return max_area;\\n    }\\n    \\n   vector<int> NearestSmallerToLeft(vector<int> temp)\\n    {\\n        stack<pair<int,int>> st;\\n        vector<int> left;\\n        pseudoIndex = -1;\\n        for(int i = 0; i < temp.size();i++)\\n        {\\n            if(st.empty())\\n                left.push_back(pseudoIndex);\\n            else if(!st.empty() && st.top().first < temp[i])\\n                left.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first >= temp[i])\\n            {\\n                while(!st.empty() && st.top().first >= temp[i])\\n                {\\n                    st.pop();\\n                }\\n                if(st.empty())\\n                {\\n                    left.push_back(-1);\\n                }\\n                else left.push_back(st.top().second);\\n            }\\n        st.push({temp[i],i});\\n        }\\n    return left;\\n    }\\n\\n    vector<int> NearestSmallerToRight(vector<int> temp)\\n    {\\n        stack<pair<int,int>> st;\\n        vector<int> right;\\n        pseudoIndex = temp.size();    \\n        for(int i = temp.size() - 1; i >= 0; i--)\\n        {\\n            if(st.empty())\\n            {\\n                right.push_back(pseudoIndex);\\n            }\\n            else if(!st.empty() && st.top().first < temp[i])\\n                right.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first >= temp[i])\\n            {\\n                while(!st.empty() && st.top().first >= temp[i])\\n                    st.pop();\\n                if(st.empty())\\n                    right.push_back(pseudoIndex);\\n                else \\n                    right.push_back(st.top().second);\\n            }\\n        st.push({temp[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pseudoIndex;\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n       int rows = matrix.size();\\n        if (rows == 0) {\\n            return 0;\\n        }\\n        int cols = matrix[0].size();\\n        if (cols == 0) {\\n            return 0;\\n        }\\n        vector<int>histogram(cols,0);\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i< rows; i++) {\\n            for (int j = 0; j< cols; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    histogram[j] = 0;\\n                }\\n                else {\\n                    histogram[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            int area = largestRectangleArea(histogram);\\n            \\n            res = max(area, res);\\n        }\\n        return res;\\n    }\\n    \\n    int largestRectangleArea(vector<int>& heights) {\\n        \\n        if(heights.size() == 0)\\n            return 0;\\n        //we store index of nearest smaller to left of i\\n        vector<int> nsl = NearestSmallerToLeft(heights);\\n        //we store index of nearest smaller to right of i\\n        vector<int> nsr = NearestSmallerToRight(heights);\\n        \\n        //find the max area possible\\n        int max_area = INT_MIN,area;\\n        for(int i = 0; i < heights.size(); i++)\\n        {\\n            area = (nsr[i]-nsl[i]-1)*heights[i];\\n            max_area = max(area,max_area);\\n        }\\n        return max_area;\\n    }\\n    \\n   vector<int> NearestSmallerToLeft(vector<int> temp)\\n    {\\n        stack<pair<int,int>> st;\\n        vector<int> left;\\n        pseudoIndex = -1;\\n        for(int i = 0; i < temp.size();i++)\\n        {\\n            if(st.empty())\\n                left.push_back(pseudoIndex);\\n            else if(!st.empty() && st.top().first < temp[i])\\n                left.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first >= temp[i])\\n            {\\n                while(!st.empty() && st.top().first >= temp[i])\\n                {\\n                    st.pop();\\n                }\\n                if(st.empty())\\n                {\\n                    left.push_back(-1);\\n                }\\n                else left.push_back(st.top().second);\\n            }\\n        st.push({temp[i],i});\\n        }\\n    return left;\\n    }\\n\\n    vector<int> NearestSmallerToRight(vector<int> temp)\\n    {\\n        stack<pair<int,int>> st;\\n        vector<int> right;\\n        pseudoIndex = temp.size();    \\n        for(int i = temp.size() - 1; i >= 0; i--)\\n        {\\n            if(st.empty())\\n            {\\n                right.push_back(pseudoIndex);\\n            }\\n            else if(!st.empty() && st.top().first < temp[i])\\n                right.push_back(st.top().second);\\n            else if(!st.empty() && st.top().first >= temp[i])\\n            {\\n                while(!st.empty() && st.top().first >= temp[i])\\n                    st.pop();\\n                if(st.empty())\\n                    right.push_back(pseudoIndex);\\n                else \\n                    right.push_back(st.top().second);\\n            }\\n        st.push({temp[i],i});\\n        }\\n        reverse(right.begin(),right.end());\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733725,
                "title": "a-simple-c-approach-with-explanation",
                "content": "This is a mixture of two problems that is\\n1. Finding the largest rectangle in an Histogram.\\n2. Then finding the answer for the particular problem\\n\\nI hereby assume that u know how to find the largest Rectangle in a Histogram,if not check this out\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\nSolve  it first before jumping to it as the intuition behind that problem is the base for this and those who have solve that here is the explanation..\\n\\nThe function find answer is the snippet which simply finds the maximum area rectangle in an histogram but before that the main function requires some preprocessing..\\nIf given the Input\\n1 0 1 0 0 \\n1 0 1 1 1\\n1 1 1 1 1\\n1 0 0 1 0\\n\\n**We can assume each row as potential input for histogram but for every row we have to take the cummulative sum with the above row inorder to get how many 1\\'s are there in the above row**\\n\\nOnce u get the above where each cummulative sum vector is an input for the function **find_ans** which calculates largest are rectangle we can extend it to 2D as well,Once u get the above then it is down hill from there..\\n\\n```\\nclass Solution {\\npublic:\\n    int find_ans(vector<int>& h)\\n    {\\n        h.push_back(0);\\n        int n = h.size();\\n        stack<int> s;\\n        int sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && h[i] < h[s.top()])\\n            {\\n                int idx = s.top();\\n                s.pop();\\n                int l = s.empty() ? 0 : s.top() + 1;\\n                sum = max(sum,h[idx]*(i-l));\\n            }\\n            s.push(i);\\n        }\\n        return sum;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty())\\n            return 0;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int max_ans = 0;\\n        vector<int> h(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                if(matrix[i][j] == \\'0\\')\\n                    h[j] = 0;\\n                else\\n                    h[j]++;\\n            max_ans = max(max_ans,find_ans(h));\\n        }\\n        return max_ans;\\n    }\\n};\\n```\\n\\n**Upvotes are appreciated**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_ans(vector<int>& h)\\n    {\\n        h.push_back(0);\\n        int n = h.size();\\n        stack<int> s;\\n        int sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && h[i] < h[s.top()])\\n            {\\n                int idx = s.top();\\n                s.pop();\\n                int l = s.empty() ? 0 : s.top() + 1;\\n                sum = max(sum,h[idx]*(i-l));\\n            }\\n            s.push(i);\\n        }\\n        return sum;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty())\\n            return 0;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int max_ans = 0;\\n        vector<int> h(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                if(matrix[i][j] == \\'0\\')\\n                    h[j] = 0;\\n                else\\n                    h[j]++;\\n            max_ans = max(max_ans,find_ans(h));\\n        }\\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640895,
                "title": "c-dynamic-programming-not-so-fast-but-easy-with-explanation",
                "content": "The key to the question is that, in each row, we can compute the area subtended by each column to its right. The maximum value will eventually be computed. The complexity is O(n*m*m). The dynamic programming comes from just memoizing the height of column row by row.\\n```\\nvector<vector<int>> memo;\\nint maximalRectangle(vector<vector<char>>& matrix) \\n{\\n\\tint n=matrix.size(),m;\\n    if(n)\\n        m=matrix[0].size();\\t\\n\\tmemo.resize(n,vector<int>(m,0));\\n    if(n>0)\\n        for(int j=0;j<m;++j)\\n            if(matrix[0][j]==\\'1\\')\\n                memo[0][j]=1;\\n   \\tfor(int i=1;i<n;++i)//finding height of  each cloumn in each row.\\n\\t\\tfor(int j=0;j<m;++j)\\n\\t\\t\\tif(matrix[i][j]==\\'1\\')\\n\\t\\t\\t\\tmemo[i][j]=1+memo[i-1][j];\\n\\tint ret=0;\\n\\tfor(int i=0;i<n;++i)\\n\\t\\tfor(int j=0;j<m;++j)\\n\\t\\t{\\n\\t\\t\\tint h=memo[i][j];\\n\\t\\t\\tfor(int k=j;k<m;++k)\\n\\t\\t\\t{\\n\\t\\t\\t\\th=min(h,memo[i][k]);\\n\\t\\t\\t\\tret=max(ret,(k-j+1)*h);\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> memo;\\nint maximalRectangle(vector<vector<char>>& matrix) \\n{\\n\\tint n=matrix.size(),m;\\n    if(n)\\n        m=matrix[0].size();\\t\\n\\tmemo.resize(n,vector<int>(m,0));\\n    if(n>0)\\n        for(int j=0;j<m;++j)\\n            if(matrix[0][j]==\\'1\\')\\n                memo[0][j]=1;\\n   \\tfor(int i=1;i<n;++i)//finding height of  each cloumn in each row.\\n\\t\\tfor(int j=0;j<m;++j)\\n\\t\\t\\tif(matrix[i][j]==\\'1\\')\\n\\t\\t\\t\\tmemo[i][j]=1+memo[i-1][j];\\n\\tint ret=0;\\n\\tfor(int i=0;i<n;++i)\\n\\t\\tfor(int j=0;j<m;++j)\\n\\t\\t{\\n\\t\\t\\tint h=memo[i][j];\\n\\t\\t\\tfor(int k=j;k<m;++k)\\n\\t\\t\\t{\\n\\t\\t\\t\\th=min(h,memo[i][k]);\\n\\t\\t\\t\\tret=max(ret,(k-j+1)*h);\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452868,
                "title": "javascript-dp-o-n-time-space",
                "content": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nconst maximalRectangle = (matrix) => {\\n  if (!matrix.length || !matrix[0].length) return 0;\\n  const height = matrix.length;\\n  const width = matrix[0].length;\\n  const lefts = matrix[0].map(() => 0);\\n  const rights = matrix[0].map(() => width);\\n  const heights = lefts.slice();\\n  let max = 0;\\n  for (let row = 0; row < height; row++) {\\n    let left = 0;\\n    let right = width;\\n    for (let i = 0; i < width; i++) {\\n      if (matrix[row][i] === \\'1\\') {\\n        lefts[i] = Math.max(left, lefts[i]);\\n        heights[i]++;\\n      } else {\\n        lefts[i] = heights[i] = 0;\\n        left = i + 1\\n      }\\n\\n      const rightIdx = width - 1 - i;\\n      if (matrix[row][rightIdx] === \\'1\\') {\\n        rights[rightIdx] = Math.min(right, rights[rightIdx])\\n      } else {\\n        rights[rightIdx] = width;\\n        right = rightIdx;\\n      }\\n    }\\n    for (let i = 0; i < width; i++) {\\n      max = Math.max(max,(rights[i] - lefts[i]) * heights[i]);\\n    }\\n  }\\n  return max\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nconst maximalRectangle = (matrix) => {\\n  if (!matrix.length || !matrix[0].length) return 0;\\n  const height = matrix.length;\\n  const width = matrix[0].length;\\n  const lefts = matrix[0].map(() => 0);\\n  const rights = matrix[0].map(() => width);\\n  const heights = lefts.slice();\\n  let max = 0;\\n  for (let row = 0; row < height; row++) {\\n    let left = 0;\\n    let right = width;\\n    for (let i = 0; i < width; i++) {\\n      if (matrix[row][i] === \\'1\\') {\\n        lefts[i] = Math.max(left, lefts[i]);\\n        heights[i]++;\\n      } else {\\n        lefts[i] = heights[i] = 0;\\n        left = i + 1\\n      }\\n\\n      const rightIdx = width - 1 - i;\\n      if (matrix[row][rightIdx] === \\'1\\') {\\n        rights[rightIdx] = Math.min(right, rights[rightIdx])\\n      } else {\\n        rights[rightIdx] = width;\\n        right = rightIdx;\\n      }\\n    }\\n    for (let i = 0; i < width; i++) {\\n      max = Math.max(max,(rights[i] - lefts[i]) * heights[i]);\\n    }\\n  }\\n  return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218583,
                "title": "dp-solution-faster-than-99-8-w-description-example-analysis-o-nm-n-time-o-1-space",
                "content": "# Solution:\\n```\\n/* Leetcode speedup */\\nstatic vector<vector<char>> mat {[](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(NULL);\\n    std::cout.tie(NULL);\\n    return NULL;\\n}()};\\n\\n/* Solution */\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>> &mat) {\\n\\t\\t// Iterate over mat and count the number of contiguous 1\\'s to the left of each position\\n        for (int i {0}; i < mat.size(); ++i) {\\n            for (int j {1}; j < mat.front().size(); ++j) {\\n                mat[i][j] = mat[i][j] != \\'0\\' ? mat[i][j-1] + 1 : mat[i][j];\\n            }\\n        }\\n\\n\\t\\t// Return value -- area of maximal 1\\'s rectangle \\n        int ret {0};\\n\\t\\t\\n\\t\\t// Iterate over new values and calculate/find area of maximal 1\\'s rectangle\\n        for (int i {0}; i < mat.size(); ++i) { \\n            for (int j {0}; j < mat.front().size(); ++j) {\\n                for (int k {i}, minw {mat[i][j] - \\'0\\'}; k < mat.size() && minw; ++k) {\\n                    ret = max(ret, (k - i + 1) * (minw= min(minw, mat[k][j] - \\'0\\')));\\n\\t\\t\\t\\t\\tmat[k][j] = mat[k][j] - \\'0\\' <= minw ? \\'0\\' : mat[k][j];\\n                }\\n            }\\n        }\\n    \\n\\t\\t// Return area of maximal rectangle\\n        return ret;\\n    }\\n};\\n```\\n\\n\\n# Description:\\nFirst, the algorithm iterates over the elements in the matrix and counts the number of horizontally contiguous 1\\u2019s to the left of each position. Starting at the 2nd element (1th position) of each row, if the current element, ```mat[i][j]```, is ```\\u20181\\u2019```, then its value is set to that of the previous element in the same row plus one.\\n\\ni.e., if ```mat[i][j] == \\u20181\\u2019``` then  ```mat[i][j] = mat[i][j-1] + 1```, else ```mat[i][j]``` remains ```\\'0\\'```. \\n\\nHere there\\'s one iteration for each element, and the original matrix is modified to count horizontally contiguous 1\\u2019s. Hence, the time complexity for this portion is O(nm), and the space complexity is O(1).\\n \\n*Note: since the matrix holds char types and not ints, it\\u2019s necessary to subtract  \\u20180\\u2019 from elements to obtain an accurate numerical value for the number of horizontally contiguous 1\\u2019s counted. Alternatively, you could use an identical 2d vector of ints for counting, but this would change the space complexity from O(1) to O(nm).*\\n \\nTake the following example matrix: \\n\\n ```\\nvector<vector<char>> mat {\\n    { \\'0\\', \\'1\\', \\'1\\', \\'1\\', \\'0\\' },\\n    { \\'0\\', \\'1\\', \\'1\\', \\'0\\', \\'0\\' }, \\n    { \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\' },\\n    { \\'1\\', \\'1\\', \\'0\\', \\'0\\', \\'0\\' } \\n};\\n```\\n\\nAfter iterating over the elements and counting the number of horizontally contiguous 1\\u2019s for each position, the values (after having subtracted \\u20180\\u2019 from them) for each element would be:\\n \\n ```\\n0 1 2 3 0 \\n0 1 2 0 0 \\n0 0 0 0 1 \\n1 2 0 0 0 \\n ```\\n \\nNext, the new values are iterated over and used to calculate areas of rectangles in the matrix originally, and the maximal area calculated is kept track of with the return variable ```ret```.\\n \\nThis is done using three nested loops:\\n1. The outermost loop iterates vertically over the rows of the matrix, from ```i = 0``` to ```i = n-1```. \\n2. The second loop iterates horizontally over the columns, from ```j = 0``` to ```j = m-1```. \\n3. The innermost loop also iterates over the rows, from```k = i``` to ```k = n-1```, but only while the value of ```mat[k][j]``` is not ```\\'0\\'``` (i.e., non-zero).\\n \\nAs we iterate vertically over elements in the innermost loop, we keep track of the minimum (non-zero) value encountered for ```mat[k][j]```. This value represents the largest width for which the elements iterated over by ```k``` form a rectangle without any gaps or holes. Moreover, since these elements make up one side of the rectangle, the number of elements iterated over consecutively in this loop, ```k - i + 1```, represents the height of the rectangle they form.\\n\\nUsing these values for width and height, each iteration we calculate the area of the largest possible rectangle and keep track of the overall maximal area found. \\n\\nAdditionally, an optimization is made by setting ```mat[k][j] = \\'0\\'``` when its numerical value (```mat[k][j] - \\'0\\'```) is not greater than ```minw```. This allows duplicate iterations over elements we know will not produce a larger area to be avoided. \\n \\n#  Example:\\n\\nGiven the following example input matrix:\\n \\n ```\\nvector<vector<char>> mat {\\n    { \\'0\\', \\'1\\', \\'1\\', \\'1\\', \\'0\\' },\\n    { \\'0\\', \\'1\\', \\'1\\', \\'0\\', \\'0\\' }, \\n    { \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\' },\\n    { \\'1\\', \\'1\\', \\'0\\', \\'0\\', \\'0\\' } \\n};\\n```\\n\\n\\nAfter iterating over the matrix the first time and recording the number of contiguous 1\\'s to the left of each position the values become:\\n\\n![image](https://assets.leetcode.com/users/dd0rz/image_1547590069.png)\\n\\n\\n*Note: integer values shown for mat, i.e., mat[][] - \\'0\\'*\\n\\nNext, the new values are iterated over and used to calculate the area of 1\\'s rectangles in the matrix originally. The first several iterations where area calculations are performed are as follows (note that the innermost loop does not execute and no calculations are performed when ```mat[i][j] == \\'0\\'```, thus these iterations are not shown):\\n\\n![image](https://assets.leetcode.com/users/dd0rz/image_1547588408.png)\\n\\nAfter completion, the maximal rectangle returned for the given matrix is ```ret = 4```.\\n\\n# Computational Complexity\\n**Worst-case Space Complexity**\\nSince our solution modifies the original input matrix and uses a constant amount of memory rather than some amount based on the input size, our space complexity is constant time, O(1). \\n\\n**Worst-case Time Complexity**\\nTo analyze the worst-case runtime complexity, consider a 5x5 matrix with the worst-case configuration:\\n\\n```\\n0, 0, 0, 0, 1\\n0, 0, 0, 1, 1\\n0, 0, 1, 1, 1\\n0, 1, 1, 1, 1\\n1, 1, 1, 1, 1\\n```\\n\\nWhen counting horizontally contiguous 1\\'s in the first set of loops, there\\'s one iteration for each element in the matrix. Hence the runtime complexity for this part is O(nm), where where n = height and w = width. Next, we consider the now modified worst-case 5x5 matrix to determine the runtime complexity of the second set of loops:\\n\\n```\\n0, 0, 0, 0, 1\\n0, 0, 0, 1, 2\\n0, 0, 1, 2, 3\\n0, 1, 2, 3, 4\\n1, 2, 3, 4, 5\\n```\\n\\nIt\\'s now apparent this is the worst-case configuration because when calculating areas smaller widths are always checked before larger ones. This prevents duplicate iterations from being avoided by setting elements to 0. \\n\\nSince the two outer loops in the second part will produce one iteration for each element in the matrix, we\\'ll always have nm iterations plus any additional duplicate iterations over elements performed by the innermost loop. If we can find an expression, X, for the number of extra iterations over elements performed by the innermost loop, then we\\'ll know the runtime complexity for this part is O(nm + X).\\n\\nStart by considering elements in the rightmost column, ```j=4```. When ```i=0``` and the innermost loop is entered, all elements in the column from [```k=0``` to ```k=4```] will be iterated over for 5 iterations total. This is the first time iterating over any element in the column, so none of the iterations are extra iterations. When ```i=1``` elements in the column from [```k=1``` to ```k=4```] (from the value 2 downwards) will be iterated over for 4 iterations total. This time these will all be duplicate iterations since all elements in the column have been iterated over already. When ```i=2```, elements in the column from [```k=2``` to ```k=4```] are iterated over for 3 iterations total, which again are all duplicate iterations. For all values of ```i``` the number of duplicate iterations over elements in rightmost column, ```j=4```, will be:\\n\\n*4 + 3 + 2 + 1 = 10*\\n\\nFor the preceding column, ```j=3```, the first element is 0, so there are no iterations over elements in the column when ```i=0```. Starting at ```i=1```, however, we can see the same pattern as before will occur. This means the total number of duplicate iterations over elements in the column for all values of ```i``` will be:\\n\\n*3 + 2 + 1 = 6*\\n\\nThe same pattern occurs for all columns in the matrix, and the number of duplicate iterations over elements in each will be:\\n\\n*1st column (```j=0```): 0 = 0\\n2nd column (```j=1```): 1 + 0 = 1\\n3rd column (```j=2```): 2 + 1 + 0 = 3\\n4th column (```j=3```): 3 + 2 + 1 + 0 = 6\\n5th column (```j=4```): 4 + 3 + 2 + 1 + 0 = 10*\\n\\nIt can be seen for the worst-case configuration, in each column the number of duplicate iterations over elements will be the sum of the first n-1 natural numbers, where n is the largest value in the column. Putting n-1 into the equation n(n+1)/2 (sum of natural numbers up to n), for each column we have:\\n\\n*(n-1)(n-1+1)/2 = n(n-1)/2 duplicate iterations*\\n\\nThus, for all columns in the matrix, the total number duplicate iterations is:\\n\\n*\\u03A3n(n-1)/2 [1 => n]*, or equivalently, *n\\xB3/6 - n/6*\\n\\nThis means for our worst-case 5x5 matrix we should have nm iterations + n\\xB3/6 - n/6 duplicate iterations:\\n\\n*5 * 5 + 125/6 - 5/6 = 25 iterations + 20 duplicate iterations = 45 total iterations*, which is accurate.\\n\\nCombining both the first and second parts, our overall worst-case time is:\\n\\n*O(nm) + O(nm + n\\xB3/6 - n/6) = O(2nm + n\\xB3/6 - n/6) =*\\n\\n*O(nm + n\\xB3)*, where n = height and m = width.",
                "solutionTags": [],
                "code": "```\\n/* Leetcode speedup */\\nstatic vector<vector<char>> mat {[](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(NULL);\\n    std::cout.tie(NULL);\\n    return NULL;\\n}()};\\n\\n/* Solution */\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>> &mat) {\\n\\t\\t// Iterate over mat and count the number of contiguous 1\\'s to the left of each position\\n        for (int i {0}; i < mat.size(); ++i) {\\n            for (int j {1}; j < mat.front().size(); ++j) {\\n                mat[i][j] = mat[i][j] != \\'0\\' ? mat[i][j-1] + 1 : mat[i][j];\\n            }\\n        }\\n\\n\\t\\t// Return value -- area of maximal 1\\'s rectangle \\n        int ret {0};\\n\\t\\t\\n\\t\\t// Iterate over new values and calculate/find area of maximal 1\\'s rectangle\\n        for (int i {0}; i < mat.size(); ++i) { \\n            for (int j {0}; j < mat.front().size(); ++j) {\\n                for (int k {i}, minw {mat[i][j] - \\'0\\'}; k < mat.size() && minw; ++k) {\\n                    ret = max(ret, (k - i + 1) * (minw= min(minw, mat[k][j] - \\'0\\')));\\n\\t\\t\\t\\t\\tmat[k][j] = mat[k][j] - \\'0\\' <= minw ? \\'0\\' : mat[k][j];\\n                }\\n            }\\n        }\\n    \\n\\t\\t// Return area of maximal rectangle\\n        return ret;\\n    }\\n};\\n```\n```mat[i][j]```\n```\\u20181\\u2019```\n```mat[i][j] == \\u20181\\u2019```\n```mat[i][j] = mat[i][j-1] + 1```\n```mat[i][j]```\n```\\'0\\'```\n```\\nvector<vector<char>> mat {\\n    { \\'0\\', \\'1\\', \\'1\\', \\'1\\', \\'0\\' },\\n    { \\'0\\', \\'1\\', \\'1\\', \\'0\\', \\'0\\' }, \\n    { \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\' },\\n    { \\'1\\', \\'1\\', \\'0\\', \\'0\\', \\'0\\' } \\n};\\n```\n```\\n0 1 2 3 0 \\n0 1 2 0 0 \\n0 0 0 0 1 \\n1 2 0 0 0 \\n ```\n```ret```\n```i = 0```\n```i = n-1```\n```j = 0```\n```j = m-1```\n```k = i```\n```k = n-1```\n```mat[k][j]```\n```\\'0\\'```\n```mat[k][j]```\n```k```\n```k - i + 1```\n```mat[k][j] = \\'0\\'```\n```mat[k][j] - \\'0\\'```\n```minw```\n```\\nvector<vector<char>> mat {\\n    { \\'0\\', \\'1\\', \\'1\\', \\'1\\', \\'0\\' },\\n    { \\'0\\', \\'1\\', \\'1\\', \\'0\\', \\'0\\' }, \\n    { \\'0\\', \\'0\\', \\'0\\', \\'0\\', \\'1\\' },\\n    { \\'1\\', \\'1\\', \\'0\\', \\'0\\', \\'0\\' } \\n};\\n```\n```mat[i][j] == \\'0\\'```\n```ret = 4```\n```\\n0, 0, 0, 0, 1\\n0, 0, 0, 1, 1\\n0, 0, 1, 1, 1\\n0, 1, 1, 1, 1\\n1, 1, 1, 1, 1\\n```\n```\\n0, 0, 0, 0, 1\\n0, 0, 0, 1, 2\\n0, 0, 1, 2, 3\\n0, 1, 2, 3, 4\\n1, 2, 3, 4, 5\\n```\n```j=4```\n```i=0```\n```k=0```\n```k=4```\n```i=1```\n```k=1```\n```k=4```\n```i=2```\n```k=2```\n```k=4```\n```i```\n```j=4```\n```j=3```\n```i=0```\n```i=1```\n```i```\n```j=0```\n```j=1```\n```j=2```\n```j=3```\n```j=4```",
                "codeTag": "C++"
            },
            {
                "id": 29127,
                "title": "o-n-2-dp-java-solution",
                "content": "    public int maximalRectangle(char[][] matrix) {\\n            if (matrix.length == 0) return 0;\\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            int[] left = new int[n]; // left boundary of histogram columns.\\n            int[] right = new int[n]; // right boundary of histogram columns.\\n            int[] height = new int[n]; // height of histogram columns.\\n            Arrays.fill(right, n);\\n            int area = 0;\\n            for (int i = 0; i < m; i++) {\\n                int l = 0, r = n;\\n                for (int j = 0; j < n; j++) {\\n                    if (matrix[i][j] == '1') {\\n                        height[j]++;\\n                        left[j] = Math.max(l, left[j]);\\n                    }\\n                    else {\\n                        l = j + 1;\\n                        height[j] = 0;\\n                        left[j] = 0;\\n                        right[j] = n;\\n                    }\\n                }\\n                for (int j = n - 1; j >= 0; j--) {\\n                    if (matrix[i][j] == '1') {\\n                        right[j] = Math.min(r, right[j]);\\n                        area = Math.max(area, height[j] * (right[j] - left[j]));\\n                    }\\n                    else {\\n                        r = j;\\n                    }\\n                }\\n            }\\n            return area;\\n        }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int maximalRectangle(char[][] matrix) {\\n            if (matrix.length == 0) return 0;\\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            int[] left = new int[n]; // left boundary of histogram columns.\\n            int[] right = new int[n]; // right boundary of histogram columns.\\n            int[] height = new int[n]; // height of histogram columns.\\n            Arrays.fill(right, n);\\n            int area = 0;\\n            for (int i = 0; i < m; i++) {\\n                int l = 0, r = n;\\n                for (int j = 0; j < n; j++) {\\n                    if (matrix[i][j] == '1') {\\n                        height[j]++;\\n                        left[j] = Math.max(l, left[j]);\\n                    }\\n                    else {\\n                        l = j + 1;\\n                        height[j] = 0;\\n                        left[j] = 0;\\n                        right[j] = n;\\n                    }\\n                }\\n                for (int j = n - 1; j >= 0; j--) {\\n                    if (matrix[i][j] == '1') {\\n                        right[j] = Math.min(r, right[j]);\\n                        area = Math.max(area, height[j] * (right[j] - left[j]));\\n                    }\\n                    else {\\n                        r = j;\\n                    }\\n                }\\n            }\\n            return area;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3822775,
                "title": "easy-stack-solution-using-c",
                "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\\n\\n# Approach\\nThe nextelement function takes a vector heights and its size n as input. It initializes an empty stack and a vector ans of size n to store the indices of the next smaller elements. It then iterates through the heights vector from right to left (from the last element to the first).\\n\\nFor each element in the heights vector, it compares its height with the elements at the top of the stack (using st.top()), and if the element at the top of the stack is greater than or equal to the current element, it pops elements from the stack (until the top element is smaller than the current element).\\n\\nAfter the while loop, it stores the index of the next smaller element in the ans vector for the current element (ans[i] = st.top()). If there is no smaller element, it stores the value n (one greater than the last index) to indicate that there is no next smaller element for that element.\\n\\nThe prevelement function works similarly to nextelement but iterates from left to right to find the previous smaller elements for each element in the heights vector.\\n\\nThe largestRectangleArea function calculates the largest rectangle area in a histogram. It takes a vector heights as input and uses the nextelement and prevelement functions to find the indices of the next smaller and previous smaller elements for each element in the histogram.\\n\\nIt then iterates through the heights vector and calculates the area of the rectangle for each bar, considering the bar as the height and the width as the difference between the indices of the next smaller and previous smaller elements for that bar.\\n\\nThe function returns the maximum area found.\\n\\nThe maximalRectangle function takes a 2D matrix matrix as input. It initializes a vector histogram of size equal to the number of columns in the matrix, and maxi variable to store the maximum area.\\n\\nIt iterates through each row of the matrix and populates the histogram vector based on the \\'1\\'s encountered in each column. When a \\'0\\' is encountered, the height of the histogram for that column is reset to 0.\\n\\nFor each row, it calculates the largest rectangle area in the histogram (representing the consecutive \\'1\\'s encountered so far) using the largestRectangleArea function.\\n\\nThe function updates maxi with the maximum area found.\\n\\nFinally, the function returns the maximum area, which represents the largest rectangle area formed by \\'1\\'s in the binary matrix.\\n\\nThe approach efficiently uses the concept of histograms and the largest rectangle area calculation to solve the maximalRectangle problem for a binary matrix, resulting in an overall time complexity of O(M * N), where M is the number of rows and N is the number of columns in the matrix.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*(M+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> nextelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =n-1;i>=0;i--)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n        if(st.top()==-1)\\n        {\\n            ans[i]=n;\\n        }\\n        else\\n        {\\n            ans[i]=st.top();\\n        }\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\nvector<int> prevelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =0;i<n;i++)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n    ans[i]=st.top();\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\n int largestRectangleArea(vector<int>& heights) {\\n       int n =heights.size();\\n       int area= INT_MIN;\\n       vector<int>next=nextelement(heights,n); \\n       vector<int>prev=prevelement(heights,n); \\n       for(int i =0;i<n;i++)\\n       {\\n           int l = heights[i];\\n           int b = next[i]-prev[i]-1;\\n           int newarea= l*b;\\n           area=max(area,newarea);\\n       }\\n       return area;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int>histogram(matrix[0].size(),0);\\n        int maxi= INT_MIN;\\n        \\n        for(int i = 0;i<matrix.size();i++)\\n        {\\n            for(int j= 0 ;j<histogram.size();j++)\\n            {\\n                if (matrix[i][j]==\\'1\\')\\n                {\\n                    histogram[j]++;\\n                }\\n                else\\n                {\\n                    histogram[j]=0;\\n                }\\n            }\\n            maxi=max(maxi,largestRectangleArea(histogram));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> nextelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =n-1;i>=0;i--)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n        if(st.top()==-1)\\n        {\\n            ans[i]=n;\\n        }\\n        else\\n        {\\n            ans[i]=st.top();\\n        }\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\nvector<int> prevelement(vector<int>& heights, int n )\\n{\\n    stack<int>st;\\n    st.push(-1);\\n    vector<int>ans(n);\\n    for(int i =0;i<n;i++)\\n    {\\n        int curr= heights[i];\\n        while(st.top()!=-1 && heights[st.top()]>=curr)\\n        {\\n            st.pop();\\n        }\\n    ans[i]=st.top();\\n    st.push(i);\\n    }\\n    return ans;\\n}\\n\\n int largestRectangleArea(vector<int>& heights) {\\n       int n =heights.size();\\n       int area= INT_MIN;\\n       vector<int>next=nextelement(heights,n); \\n       vector<int>prev=prevelement(heights,n); \\n       for(int i =0;i<n;i++)\\n       {\\n           int l = heights[i];\\n           int b = next[i]-prev[i]-1;\\n           int newarea= l*b;\\n           area=max(area,newarea);\\n       }\\n       return area;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int>histogram(matrix[0].size(),0);\\n        int maxi= INT_MIN;\\n        \\n        for(int i = 0;i<matrix.size();i++)\\n        {\\n            for(int j= 0 ;j<histogram.size();j++)\\n            {\\n                if (matrix[i][j]==\\'1\\')\\n                {\\n                    histogram[j]++;\\n                }\\n                else\\n                {\\n                    histogram[j]=0;\\n                }\\n            }\\n            maxi=max(maxi,largestRectangleArea(histogram));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603531,
                "title": "c-very-easy-solution-using-stack-84-largest-rectangle-in-histogram",
                "content": "```\\nint largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        stack<int> s;\\n        s.push(-1);\\n        int maxArea=0;\\n        int rm=0,lm=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            int val = (i==n ? 0 : heights[i]);\\n            while(s.top() != -1 and heights[s.top()]>=val)\\n            {\\n                rm = i;\\n                int h = heights[s.top()];\\n                s.pop();\\n                lm = s.top();\\n                maxArea = max(maxArea, h*(rm-lm-1));\\n            }\\n            s.push(i);\\n        }\\n        return maxArea;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix){\\n        int row = matrix.size();\\n        if(row == 0) return 0;\\n        int col = matrix[0].size();\\n    \\n        vector<int> v(col);\\n        for(int i=0;i<col;i++)\\n        {\\n            v[i] = matrix[0][i] - \\'0\\';\\n        }\\n        int maxArea = 0;\\n        maxArea = max(maxArea, largestRectangleArea(v));\\n        for(int i=1;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    v[j]++;\\n                }\\n                else\\n                {\\n                    v[j]=0;\\n                }\\n            }\\n            maxArea = max(maxArea, largestRectangleArea(v));\\n        }\\n        return maxArea;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint largestRectangleArea(vector<int>& heights) {\\n        int n=heights.size();\\n        stack<int> s;\\n        s.push(-1);\\n        int maxArea=0;\\n        int rm=0,lm=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            int val = (i==n ? 0 : heights[i]);\\n            while(s.top() != -1 and heights[s.top()]>=val)\\n            {\\n                rm = i;\\n                int h = heights[s.top()];\\n                s.pop();\\n                lm = s.top();\\n                maxArea = max(maxArea, h*(rm-lm-1));\\n            }\\n            s.push(i);\\n        }\\n        return maxArea;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix){\\n        int row = matrix.size();\\n        if(row == 0) return 0;\\n        int col = matrix[0].size();\\n    \\n        vector<int> v(col);\\n        for(int i=0;i<col;i++)\\n        {\\n            v[i] = matrix[0][i] - \\'0\\';\\n        }\\n        int maxArea = 0;\\n        maxArea = max(maxArea, largestRectangleArea(v));\\n        for(int i=1;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    v[j]++;\\n                }\\n                else\\n                {\\n                    v[j]=0;\\n                }\\n            }\\n            maxArea = max(maxArea, largestRectangleArea(v));\\n        }\\n        return maxArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229906,
                "title": "simple-explanation-o-n-2-c-derived-from-maximum-area-in-histogram",
                "content": "**Prerequisite** : Please solve this problem first for better understanding [Maximum Area in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// This function accepts height of histograms and calculates the maximum area of reactange\\n\\t// i.e this function is the solution of problem mentioned in the above link\\n    int maxAreaHistogram(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        vector<int> rig(n, n), lef(n, -1);        // rig and lef vectors stores the first index in right and left whose height is less\\n        stack<int> s;\\n        \\n\\t\\t// storing the right index\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s.empty() && arr[s.top()]>=arr[i]) s.pop();\\n            \\n            if(!s.empty()) rig[i] = s.top();\\n            s.push(i);\\n        }\\n\\t\\t\\n        while(!s.empty()) s.pop();\\n        \\n\\t\\t// storing the left index\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && arr[s.top()]>=arr[i]) s.pop();\\n            if(!s.empty()) lef[i] = s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// area =  width x height = ( rig[i] - lef[i]-1 )  x ( arr[i] )\\n        for(int i=0;i<n;i++)\\n            ans = max(ans, arr[i]*(rig[i]-lef[i]-1));\\n        \\n        return ans;\\n    }\\n    \\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size();\\n        if(n==0) return 0;\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int> > mat(n, vector<int>(m));\\n        \\n\\t\\t// Converting char matrix to integer matrix\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                mat[i][j] = int(matrix[i][j]-\\'0\\');\\n                \\n\\t\\t// Calculating height of histogram for each row, but note that whenever we encounter zero height will become zero\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(mat[i][j])\\n                    mat[i][j] += mat[i-1][j];\\n\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// now solving maxAreaHistogram for considering each row, and maximum of each level will be our ans\\n        for(int i=0;i<n;i++)\\n            ans = max(ans, maxAreaHistogram(mat[i]) );\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// This function accepts height of histograms and calculates the maximum area of reactange\\n\\t// i.e this function is the solution of problem mentioned in the above link\\n    int maxAreaHistogram(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        vector<int> rig(n, n), lef(n, -1);        // rig and lef vectors stores the first index in right and left whose height is less\\n        stack<int> s;\\n        \\n\\t\\t// storing the right index\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s.empty() && arr[s.top()]>=arr[i]) s.pop();\\n            \\n            if(!s.empty()) rig[i] = s.top();\\n            s.push(i);\\n        }\\n\\t\\t\\n        while(!s.empty()) s.pop();\\n        \\n\\t\\t// storing the left index\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s.empty() && arr[s.top()]>=arr[i]) s.pop();\\n            if(!s.empty()) lef[i] = s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// area =  width x height = ( rig[i] - lef[i]-1 )  x ( arr[i] )\\n        for(int i=0;i<n;i++)\\n            ans = max(ans, arr[i]*(rig[i]-lef[i]-1));\\n        \\n        return ans;\\n    }\\n    \\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size();\\n        if(n==0) return 0;\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int> > mat(n, vector<int>(m));\\n        \\n\\t\\t// Converting char matrix to integer matrix\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                mat[i][j] = int(matrix[i][j]-\\'0\\');\\n                \\n\\t\\t// Calculating height of histogram for each row, but note that whenever we encounter zero height will become zero\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(mat[i][j])\\n                    mat[i][j] += mat[i-1][j];\\n\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// now solving maxAreaHistogram for considering each row, and maximum of each level will be our ans\\n        for(int i=0;i<n;i++)\\n            ans = max(ans, maxAreaHistogram(mat[i]) );\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688497,
                "title": "python-similar-to-leetcode-84-explained",
                "content": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## SIMILAR TO LEETCODE 84. LARGEST RECTANGLE IN A HISTOGRAM ##\\n        \\n        #   1. we will create heights matrix, just like below (to imagine line histogram)\\n        #   2. on each heights matrix row, we find the maxArea\\n        #   3. return maxArea\\n        #   Ex :\\n        # [\\n        #   [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n        #   [\"1\",\"0\",\"1\",\"1\",\"1\"],\\n        #   [\"1\",\"1\",\"1\",\"1\",\"1\"],\\n        #   [\"1\",\"0\",\"0\",\"1\",\"0\"]\\n        # ]\\n        # [\\n        #   [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n        #   [\"2\",\"0\",\"2\",\"1\",\"1\"],\\n        #   [\"3\",\"1\",\"3\",\"2\",\"2\"],\\n        #   [\"4\",\"0\",\"0\",\"3\",\"0\"]\\n        # ]\\n        \\n        if(not matrix) : return 0\\n        \\n        for i in range(0, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if( matrix[i][j] == \\'1\\' ):\\n                    matrix[i][j] = int(matrix[i][j]) + int(matrix[i-1][j] if(i>0) else 0 )\\n                else:\\n                    matrix[i][j] = 0\\n        \\n        def findLargestArea(heights):\\n            if(not heights): return 0\\n            heights.append(0)\\n            stack = [-1]\\n            ans = 0\\n            for i in range(len(heights)):\\n                while( heights[i] < heights[stack[-1]] ):\\n                    h = heights[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    ans = max( ans, h*w )\\n                stack.append(i)\\n            return ans\\n            \\n        maxArea = 0\\n        for row in matrix:\\n            maxArea = max( maxArea, findLargestArea(row) )\\n        return maxArea        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## SIMILAR TO LEETCODE 84. LARGEST RECTANGLE IN A HISTOGRAM ##\\n        \\n        #   1. we will create heights matrix, just like below (to imagine line histogram)\\n        #   2. on each heights matrix row, we find the maxArea\\n        #   3. return maxArea\\n        #   Ex :\\n        # [\\n        #   [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n        #   [\"1\",\"0\",\"1\",\"1\",\"1\"],\\n        #   [\"1\",\"1\",\"1\",\"1\",\"1\"],\\n        #   [\"1\",\"0\",\"0\",\"1\",\"0\"]\\n        # ]\\n        # [\\n        #   [\"1\",\"0\",\"1\",\"0\",\"0\"],\\n        #   [\"2\",\"0\",\"2\",\"1\",\"1\"],\\n        #   [\"3\",\"1\",\"3\",\"2\",\"2\"],\\n        #   [\"4\",\"0\",\"0\",\"3\",\"0\"]\\n        # ]\\n        \\n        if(not matrix) : return 0\\n        \\n        for i in range(0, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if( matrix[i][j] == \\'1\\' ):\\n                    matrix[i][j] = int(matrix[i][j]) + int(matrix[i-1][j] if(i>0) else 0 )\\n                else:\\n                    matrix[i][j] = 0\\n        \\n        def findLargestArea(heights):\\n            if(not heights): return 0\\n            heights.append(0)\\n            stack = [-1]\\n            ans = 0\\n            for i in range(len(heights)):\\n                while( heights[i] < heights[stack[-1]] ):\\n                    h = heights[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    ans = max( ans, h*w )\\n                stack.append(i)\\n            return ans\\n            \\n        maxArea = 0\\n        for row in matrix:\\n            maxArea = max( maxArea, findLargestArea(row) )\\n        return maxArea        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 125717,
                "title": "javascript-100-00-72-ms",
                "content": "```\\nvar maximalRectangle = function (matrix) {\\n    const n = matrix.length;\\n    if (n === 0) return 0;\\n    const m = matrix[0].length;\\n\\n    const h = new Array(n).fill(0);\\n\\n    let max = 0;\\n    for (let j = 0; j < m; j++) {\\n        for (let i = 0; i < n; i++) {\\n            if (matrix[i][j] === \\'1\\') h[i]++;\\n            else h[i] = 0;\\n        }\\n        for (let i = 0; i < n; i++) {\\n            let k1 = i - 1;\\n            while (k1 >= 0 && h[i] <= h[k1]) k1--;\\n            let k2 = i + 1;\\n            while (k2 < n && h[i] <= h[k2]) k2++;\\n            max = Math.max(max, h[i] * (k2 - k1 - 1));\\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximalRectangle = function (matrix) {\\n    const n = matrix.length;\\n    if (n === 0) return 0;\\n    const m = matrix[0].length;\\n\\n    const h = new Array(n).fill(0);\\n\\n    let max = 0;\\n    for (let j = 0; j < m; j++) {\\n        for (let i = 0; i < n; i++) {\\n            if (matrix[i][j] === \\'1\\') h[i]++;\\n            else h[i] = 0;\\n        }\\n        for (let i = 0; i < n; i++) {\\n            let k1 = i - 1;\\n            while (k1 >= 0 && h[i] <= h[k1]) k1--;\\n            let k2 = i + 1;\\n            while (k2 < n && h[i] <= h[k2]) k2++;\\n            max = Math.max(max, h[i] * (k2 - k1 - 1));\\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846495,
                "title": "easiest-java-solution-beats-100",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this question using the \"Largest Rectangle in Histogram\" question approach. consider every row as a histogram and for every row find the max rectangle area. \\n\\nYou can check the histogram approach [here](https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/3845893/best-simple-java-solution-beats-85/).\\n\\nAlso, if the current row has an element with 0 value, then the height will be 0. for the rest where matrix[i][j] == 0, just add the previous value + 1, \\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int histogram(int[] heights){\\n         int n = heights.length;\\n\\n        ArrayDeque<Integer> st1 = new ArrayDeque<>();\\n        ArrayDeque<Integer> st2 = new ArrayDeque<>();\\n\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n\\n        //previous smaller element\\n        for(int i = 0; i < n; i++){\\n\\n            int num = heights[i] ;\\n\\n            while(!st1.isEmpty() && heights[st1.peek()] > num)\\n                st1.pop();\\n\\n            if(st1.isEmpty())\\n                left[i] = -1;\\n            else \\n                left[i] = st1.peek();\\n\\n            st1.push(i);            \\n\\n        }\\n    \\n\\n        //next greater element\\n        for(int i = n-1; i >= 0; i--){\\n\\n            int num = heights[i];\\n\\n            while(!st2.isEmpty() && heights[st2.peek()] >= num)\\n                st2.pop();\\n\\n            if(st2.isEmpty())\\n                right[i] = n;\\n            else \\n                right[i] = st2.peek();\\n\\n            st2.push(i);            \\n\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < n; i++){\\n\\n            int sum = (right[i] - left[i] - 1) * (heights[i]);\\n            max = Math.max(max, sum); \\n\\n        }\\n\\n        System.out.println(\"Max\"+ max);\\n        return max;\\n    }\\n\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[] currRow = new int[matrix[0].length];\\n        int max = 0;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            for(int j = 0; j < m; j++){\\n\\n                if(matrix[i][j] == \\'1\\')\\n                    currRow[j]++;\\n                else \\n                    currRow[j] = 0;    \\n            }\\n\\n            int currMax = histogram(currRow);\\n            max = Math.max(max, currMax);\\n\\n        }\\n\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int histogram(int[] heights){\\n         int n = heights.length;\\n\\n        ArrayDeque<Integer> st1 = new ArrayDeque<>();\\n        ArrayDeque<Integer> st2 = new ArrayDeque<>();\\n\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n\\n        //previous smaller element\\n        for(int i = 0; i < n; i++){\\n\\n            int num = heights[i] ;\\n\\n            while(!st1.isEmpty() && heights[st1.peek()] > num)\\n                st1.pop();\\n\\n            if(st1.isEmpty())\\n                left[i] = -1;\\n            else \\n                left[i] = st1.peek();\\n\\n            st1.push(i);            \\n\\n        }\\n    \\n\\n        //next greater element\\n        for(int i = n-1; i >= 0; i--){\\n\\n            int num = heights[i];\\n\\n            while(!st2.isEmpty() && heights[st2.peek()] >= num)\\n                st2.pop();\\n\\n            if(st2.isEmpty())\\n                right[i] = n;\\n            else \\n                right[i] = st2.peek();\\n\\n            st2.push(i);            \\n\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < n; i++){\\n\\n            int sum = (right[i] - left[i] - 1) * (heights[i]);\\n            max = Math.max(max, sum); \\n\\n        }\\n\\n        System.out.println(\"Max\"+ max);\\n        return max;\\n    }\\n\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[] currRow = new int[matrix[0].length];\\n        int max = 0;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            for(int j = 0; j < m; j++){\\n\\n                if(matrix[i][j] == \\'1\\')\\n                    currRow[j]++;\\n                else \\n                    currRow[j] = 0;    \\n            }\\n\\n            int currMax = histogram(currRow);\\n            max = Math.max(max, currMax);\\n\\n        }\\n\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472019,
                "title": "java-solution-for-maximal-rectangle-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe above solution uses a dynamic programming approach to calculate the height of the largest rectangle that can be formed with the current cell at the bottom of the rectangle. It then applies a modified version of the algorithm for finding the maximum area of a histogram on each row of the matrix to find the maximum area of a rectangle that can be formed using that row as the bottom edge.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach first creates a new matrix height where height[i][j] represents the height of the largest rectangle that can be formed with cell (i,j) as the bottom cell. If matrix[i][j] is \\'0\\', then height[i][j] is set to 0, since no rectangle can be formed with a bottom cell of \\'0\\'. Otherwise, height[i][j] is set to height[i-1][j] + 1 if i > 0, since we can extend a rectangle from the cell above it, or to 1 if i == 0, since the current cell is the topmost cell of the rectangle.\\n\\nOnce the height matrix has been constructed, the solution applies the modified histogram algorithm to each row of the height matrix to find the maximum area of a rectangle that can be formed using that row as the bottom edge. The modified histogram algorithm maintains a stack of indices of increasing heights of bars seen so far. When a bar with height smaller than the bar at the top of the stack is encountered, the bars in the stack are popped and their maximum area is calculated based on the height of the popped bar and the width of the rectangle, which is the difference between the current index and the index of the bar at the top of the stack (or the entire length of the stack if it is empty). The maximum area seen so far is updated if the current area is greater than it. Finally, the function returns the maximum area of a rectangle that can be formed using the heights of the bars in the given input array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\nThe code iterates over every cell in the input matrix once to calculate the height array, where m and n are the dimensions of the input matrix. It then calls the maxAreaInHist method once for each row in the matrix, which has a time complexity of O(n) for each row. Thus, the total time complexity is O(m * n) for the two nested loops and the maxAreaInHist method.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\nThe code creates a 2D array height with m rows and n+1 columns to store the height of the histogram. Each row of the height array has n+1 elements, which increases the space complexity by an extra n elements per row. Thus, the space complexity is O(m * (n+1)), which can be simplified to O(m * n) asymptotically. Additionally, the code uses a stack to store indices, which can have a worst-case space complexity of O(n) if all elements are strictly decreasing in height\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = m == 0 ? 0 : matrix[0].length;\\n        int[][] height = new int[m][n + 1];\\n        int maxArea = 0;\\n        for (int i = 0; i < m; i++) \\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (matrix[i][j] == \\'0\\') \\n                {\\n                    height[i][j] = 0;\\n                } \\n                else \\n                {\\n                    height[i][j] = i == 0 ? 1 : height[i - 1][j] + 1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++) \\n        {\\n            int area = maxAreaInHist(height[i]);\\n            if (area > maxArea) \\n            {\\n                maxArea = area;\\n            }\\n        }\\n        return maxArea;\\n    }\\n    private int maxAreaInHist(int[] height) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int i = 0;\\n        int max = 0;\\n        while (i < height.length) \\n        {\\n            if (stack.isEmpty() || height[stack.peek()] <= height[i]) \\n            {\\n                stack.push(i++);\\n            } \\n            else \\n            {\\n                int t = stack.pop();\\n                max = Math.max(max, height[t] * (stack.isEmpty() ? i : i - stack.peek() - 1));\\n            }\\n        }\\n        return max;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = m == 0 ? 0 : matrix[0].length;\\n        int[][] height = new int[m][n + 1];\\n        int maxArea = 0;\\n        for (int i = 0; i < m; i++) \\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (matrix[i][j] == \\'0\\') \\n                {\\n                    height[i][j] = 0;\\n                } \\n                else \\n                {\\n                    height[i][j] = i == 0 ? 1 : height[i - 1][j] + 1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; i++) \\n        {\\n            int area = maxAreaInHist(height[i]);\\n            if (area > maxArea) \\n            {\\n                maxArea = area;\\n            }\\n        }\\n        return maxArea;\\n    }\\n    private int maxAreaInHist(int[] height) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int i = 0;\\n        int max = 0;\\n        while (i < height.length) \\n        {\\n            if (stack.isEmpty() || height[stack.peek()] <= height[i]) \\n            {\\n                stack.push(i++);\\n            } \\n            else \\n            {\\n                int t = stack.pop();\\n                max = Math.max(max, height[t] * (stack.isEmpty() ? i : i - stack.peek() - 1));\\n            }\\n        }\\n        return max;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333513,
                "title": "stack-cpp-similar-to-max-area-in-histogram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote the solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution uses the concept of histogram where the heights of each column are taken as bars of the histogram. Then, the problem is reduced to finding the largest rectangle area in the histogram.\\n\\nThe code first defines two helper functions nextSmaller() and prevSmaller() that return the indices of the next smaller and previous smaller element to each element of a given array. These functions use a stack to store the indices of the elements in a decreasing order of their values. The top of the stack always stores the index of the next smaller or previous smaller element.\\n\\nThen, the maxAreaHistogram() function takes an array and returns the maximum area of the rectangle that can be formed using the histogram of the heights of the bars of the histogram. It uses the nextSmaller() and prevSmaller() functions to calculate the next and previous smaller elements\\' indices for each element in the array and then calculates the maximum area of the rectangle using the formula area = length * width, where length is the height of the current element, and width is the distance between the next smaller and previous smaller element indices.\\n\\nFinally, the maximalRectangle() function takes the binary matrix as input, converts it into an array of integers, and calculates the maximum area of the rectangle by iterating over each row of the matrix and updating the array of heights for each row. The maximum area is returned as the output.\\n\\nOverall, the code is an implementation of the histogram-based approach to find the maximal rectangle area in a binary matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) where m and n are the dimensions of the input matrix.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmaller(vector<int> &arr,int n){\\n        stack<int> st;\\n        vector<int> ans(n);\\n        st.push(-1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\\n                st.pop();\\n            }\\n            ans[i]=st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmaller(vector<int> &arr,int n){\\n        stack<int> st;\\n        vector<int> ans(n);\\n        st.push(-1);\\n        for(int i=0;i<arr.size();i++){\\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\\n                st.pop();\\n            }\\n            ans[i]=st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    int maxAreaHistogram(vector<int> &arr){\\n        int n = arr.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = nextSmaller(arr,n);\\n        prev = prevSmaller(arr,n);\\n        int area = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int length = arr[i];\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int width = next[i]-prev[i]-1;\\n            area = max(area,(length*width));\\n        }\\n        return area;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        ios_base::sync_with_stdio(false);\\n        vector<vector<int>> mat;\\n        for(int i=0;i<matrix.size();i++){\\n            vector<int> v;\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    v.push_back(1);\\n                }\\n                else{\\n                    v.push_back(0);\\n                }\\n            }\\n            mat.push_back(v);\\n        }\\n        int n = mat.size();\\n        int area = maxAreaHistogram(mat[0]);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]!=0){\\n                    mat[i][j]+=mat[i-1][j];\\n                }\\n            }\\n            area=max(area,maxAreaHistogram(mat[i]));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmaller(vector<int> &arr,int n){\\n        stack<int> st;\\n        vector<int> ans(n);\\n        st.push(-1);\\n        for(int i=arr.size()-1;i>=0;i--){\\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\\n                st.pop();\\n            }\\n            ans[i]=st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmaller(vector<int> &arr,int n){\\n        stack<int> st;\\n        vector<int> ans(n);\\n        st.push(-1);\\n        for(int i=0;i<arr.size();i++){\\n            while(st.top()!=-1 && arr[st.top()]>=arr[i]){\\n                st.pop();\\n            }\\n            ans[i]=st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    int maxAreaHistogram(vector<int> &arr){\\n        int n = arr.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = nextSmaller(arr,n);\\n        prev = prevSmaller(arr,n);\\n        int area = 0;\\n        for(int i=0;i<arr.size();i++){\\n            int length = arr[i];\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int width = next[i]-prev[i]-1;\\n            area = max(area,(length*width));\\n        }\\n        return area;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        ios_base::sync_with_stdio(false);\\n        vector<vector<int>> mat;\\n        for(int i=0;i<matrix.size();i++){\\n            vector<int> v;\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    v.push_back(1);\\n                }\\n                else{\\n                    v.push_back(0);\\n                }\\n            }\\n            mat.push_back(v);\\n        }\\n        int n = mat.size();\\n        int area = maxAreaHistogram(mat[0]);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]!=0){\\n                    mat[i][j]+=mat[i-1][j];\\n                }\\n            }\\n            area=max(area,maxAreaHistogram(mat[i]));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308619,
                "title": "easy-c-code-zarur-dkhooo",
                "content": "# Intuition\\nThis question links the concept of several questions, for example: \\n- Finding next smaller element\\n- Finding Previous smaller element\\n- Histogram area problem.\\nSo we will be just writting 3 seperate functions for each set of problem mentioned above and use these functions in our current working function.\\n\\n---\\n\\n# Complexity\\n\\n- Time complexity:\\nO(NXN)\\n\\n- Space complexity:\\nO(N), since we have created vectors.\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int> prev(vector<int> v,int n){\\n         vector<int> ans(n);\\n         stack<int> s;\\n         s.push(-1);\\n         for(int i=0;i<n;i++){\\n        int curr=v[i];\\n        while(s.top()!=-1 && v[s.top()]>=curr){\\n            s.pop();\\n        }\\n        //top me hi ans h;\\n         ans[i]=s.top();\\n         s.push(i);\\n         }\\n         return ans;\\n     }\\n\\n     vector<int> next(vector<int> v,int n){\\n         vector<int> ans(n);\\n         stack<int> s;\\n           s.push(-1);\\n         for(int i=n-1;i>=0;i--){\\n        int curr=v[i];\\n        while(s.top()!=-1 && v[s.top()]>=curr){\\n            s.pop();\\n        }\\n        //top me hi ans h;\\n         ans[i]=s.top();\\n         s.push(i);\\n         }\\n         return ans;\\n     }\\n\\n    int maxHisto(vector<int> v){\\n        int nt=v.size();\\n        vector<int> p(nt);\\n        p=prev(v,nt);\\n        vector<int> n(nt);\\n        n=next(v,nt);\\n        int sum=INT_MIN;\\n        for(int i=0;i<nt;i++){\\n          if(n[i]==-1){\\n              n[i]=nt;\\n          }\\n        int a= v[i]*(n[i]-p[i]-1);\\n        sum=max(a,sum);\\n        }\\n        return sum;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n       vector<vector<int>> v(matrix.size());\\n       for(int i=0;i<matrix.size();i++){\\n           for(int j=0;j<matrix[i].size();j++){\\n               if(matrix[i][j]==\\'0\\')\\n  v[i].push_back(0);\\n  else v[i].push_back(1);\\n           }\\n       } \\n       int first= maxHisto(v[0]);\\n     for(int i=1;i<v.size();i++){\\n        for(int j=0;j<v[i].size();j++){\\n            if(v[i][j]!=0){\\n                v[i][j]=v[i-1][j]+v[i][j];\\n            }\\n            else v[i][j]=0;\\n        }\\n        int a=  maxHisto(v[i]);\\n        first= max(first,a);\\n     }\\nreturn first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> prev(vector<int> v,int n){\\n         vector<int> ans(n);\\n         stack<int> s;\\n         s.push(-1);\\n         for(int i=0;i<n;i++){\\n        int curr=v[i];\\n        while(s.top()!=-1 && v[s.top()]>=curr){\\n            s.pop();\\n        }\\n        //top me hi ans h;\\n         ans[i]=s.top();\\n         s.push(i);\\n         }\\n         return ans;\\n     }\\n\\n     vector<int> next(vector<int> v,int n){\\n         vector<int> ans(n);\\n         stack<int> s;\\n           s.push(-1);\\n         for(int i=n-1;i>=0;i--){\\n        int curr=v[i];\\n        while(s.top()!=-1 && v[s.top()]>=curr){\\n            s.pop();\\n        }\\n        //top me hi ans h;\\n         ans[i]=s.top();\\n         s.push(i);\\n         }\\n         return ans;\\n     }\\n\\n    int maxHisto(vector<int> v){\\n        int nt=v.size();\\n        vector<int> p(nt);\\n        p=prev(v,nt);\\n        vector<int> n(nt);\\n        n=next(v,nt);\\n        int sum=INT_MIN;\\n        for(int i=0;i<nt;i++){\\n          if(n[i]==-1){\\n              n[i]=nt;\\n          }\\n        int a= v[i]*(n[i]-p[i]-1);\\n        sum=max(a,sum);\\n        }\\n        return sum;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n       vector<vector<int>> v(matrix.size());\\n       for(int i=0;i<matrix.size();i++){\\n           for(int j=0;j<matrix[i].size();j++){\\n               if(matrix[i][j]==\\'0\\')\\n  v[i].push_back(0);\\n  else v[i].push_back(1);\\n           }\\n       } \\n       int first= maxHisto(v[0]);\\n     for(int i=1;i<v.size();i++){\\n        for(int j=0;j<v[i].size();j++){\\n            if(v[i][j]!=0){\\n                v[i][j]=v[i-1][j]+v[i][j];\\n            }\\n            else v[i][j]=0;\\n        }\\n        int a=  maxHisto(v[i]);\\n        first= max(first,a);\\n     }\\nreturn first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185239,
                "title": "maximal-rectangle-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses the concept of histogram to solve the problem. For each row, it converts the binary values into heights of the bars and then calculates the largest rectangle in the histogram using the stack data structure. The solution has a time complexity of O(n * m) and a space complexity of O(m).\\n\\n# Complexity\\n- Time complexity:\\n89.51%\\n\\n- Space complexity:\\n85%\\n\\n# Code\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        n, m = len(matrix), len(matrix[0])\\n        height = [0] * (m + 1)\\n        ans = 0\\n        \\n        for row in matrix:\\n            for i in range(m):\\n                height[i] = height[i] + 1 if row[i] == \\'1\\' else 0\\n            stack = [-1]\\n            for i in range(m + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        \\n        n, m = len(matrix), len(matrix[0])\\n        height = [0] * (m + 1)\\n        ans = 0\\n        \\n        for row in matrix:\\n            for i in range(m):\\n                height[i] = height[i] + 1 if row[i] == \\'1\\' else 0\\n            stack = [-1]\\n            for i in range(m + 1):\\n                while height[i] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = i - stack[-1] - 1\\n                    ans = max(ans, h * w)\\n                stack.append(i)\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495314,
                "title": "aditya-verma-solution-c-maximal-rectangle",
                "content": "# Aditya Verma Solutions\\n\\n**Q1.**\\n***85. Maximal Rectangle***\\nhttps://leetcode.com/problems/maximal-rectangle/\\n\\n```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n    int n= heights.size();\\n    vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);// taking max after finding area\\n    }\\n    return m;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestRectangleArea(histogram));\\n            // cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n\\n```\\n\\n**Q2.**\\n***84. Largest Rectangle in Histogram***\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\n```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tint getMaxArea(vector<int> &arr, int n)\\n\\t\\t{\\n\\t\\t\\tvector<int> left, right;\\n\\t\\t\\tstack<pair<int, int>> s1, s2;\\n\\t\\t\\tint pseudo_index = -1;\\n\\t\\t\\tint pseudo_index1 = n;\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (s1.size() == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft.push_back(pseudo_index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s1.size() > 0 && s1.top().first < arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft.push_back(s1.top().second);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s1.size() > 0 && s1.top().first >= arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile (s1.size() > 0 && s1.top().first >= arr[i])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts1.pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (s1.size() == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tleft.push_back(pseudo_index);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tleft.push_back(s1.top().second);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ts1.push({ arr[i], i });\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = n - 1; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (s2.size() == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright.push_back(pseudo_index1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s2.size() > 0 && s2.top().first < arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright.push_back(s2.top().second);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (s2.size() > 0 && s2.top().first >= arr[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile (s2.size() > 0 && s2.top().first >= arr[i])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts2.pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (s2.size() == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tright.push_back(pseudo_index1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tright.push_back(s2.top().second);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ts2.push({ arr[i], i });\\n\\t\\t\\t}\\n\\n\\t\\t\\treverse(right.begin(), right.end());\\n\\t\\t\\tint m = INT_MIN;\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint s = (right[i] - left[i] - 1) *arr[i];\\n\\t\\t\\t\\tm = max(m, s);\\t// taking max after finding area\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn m;\\n\\t\\t}\\n\\n\\tint largestRectangleArea(vector<int> &heights)\\n\\t{\\n\\t\\tint n = heights.size();\\n\\t\\treturn getMaxArea(heights, n);\\n\\n\\t}\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n    int n= heights.size();\\n    vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);// taking max after finding area\\n    }\\n    return m;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestRectangleArea(histogram));\\n            // cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2490705,
                "title": "using-kadane-s-algorithm",
                "content": "Just Replace 0 with negative of MAX possible sum in array. And proceed as in the question of finding maximum sum rectangle.\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int ans = 0, m=matrix.length,n = matrix[0].length,INF = -m*n;\\n        for(int j=0;j<n;j++){\\n            int[] temp = new int[m];\\n            for(int z=j;z<n;z++){\\n                for(int c=0;c<m;c++) temp[c]+= matrix[c][z]==\\'0\\'?INF:1;\\n        \\n                ans = Math.max(ans,kadaneAlgo(temp));\\n            }\\n        }\\n        return ans;\\n    }\\n    private int kadaneAlgo(int[] arr){\\n        int max = arr[0], local_max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            local_max = Math.max(arr[i],local_max+arr[i]);\\n            max = Math.max(local_max,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int ans = 0, m=matrix.length,n = matrix[0].length,INF = -m*n;\\n        for(int j=0;j<n;j++){\\n            int[] temp = new int[m];\\n            for(int z=j;z<n;z++){\\n                for(int c=0;c<m;c++) temp[c]+= matrix[c][z]==\\'0\\'?INF:1;\\n        \\n                ans = Math.max(ans,kadaneAlgo(temp));\\n            }\\n        }\\n        return ans;\\n    }\\n    private int kadaneAlgo(int[] arr){\\n        int max = arr[0], local_max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            local_max = Math.max(arr[i],local_max+arr[i]);\\n            max = Math.max(local_max,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460850,
                "title": "java-same-as-maximum-rectangle-in-histogram-nsl-nsr-aditya-verma",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] heights = new int[n];\\n           \\n        int ans = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               heights[j] = matrix[i][j] == \\'1\\' ? heights[j] + 1: 0;\\n            }\\n            ans = Math.max(ans, getMAH(heights, n));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int getMAH(int[] heights, int n) {\\n        int maxArea = Integer.MIN_VALUE;\\n        List<Integer> nsl = NSL(heights, n);\\n        List<Integer> nsr = NSR(heights, n);\\n        int[] width = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            width[i] = nsr.get(i) - nsl.get(i) - 1;\\n                \\n        for(int i=0; i<n; i++) {\\n            int area = heights[i] * width[i];\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n    \\n    \\n    private List<Integer> NSL(int[] heights, int n) {\\n            \\n        List<Integer> nsl = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int curr = heights[i];\\n            while(!st.isEmpty() && st.peek()[0] >= curr) { st.pop(); }\\n            if(st.isEmpty()) nsl.add(-1);\\n            else nsl.add(st.peek()[1]);\\n            st.add(new int[] { curr, i });\\n        }\\n        \\n        return nsl;\\n    }\\n    \\n    \\n     private List<Integer> NSR(int[] heights, int n) {\\n            \\n        List<Integer> nsr = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            int curr = heights[i];\\n            while(!st.isEmpty() && st.peek()[0] >= curr) { st.pop(); }\\n            if(st.isEmpty()) nsr.add(n);\\n            else nsr.add(st.peek()[1]);\\n            st.add(new int[] { curr, i });\\n        }\\n         \\n        Collections.reverse(nsr);\\n        return nsr;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] heights = new int[n];\\n           \\n        int ans = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               heights[j] = matrix[i][j] == \\'1\\' ? heights[j] + 1: 0;\\n            }\\n            ans = Math.max(ans, getMAH(heights, n));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int getMAH(int[] heights, int n) {\\n        int maxArea = Integer.MIN_VALUE;\\n        List<Integer> nsl = NSL(heights, n);\\n        List<Integer> nsr = NSR(heights, n);\\n        int[] width = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            width[i] = nsr.get(i) - nsl.get(i) - 1;\\n                \\n        for(int i=0; i<n; i++) {\\n            int area = heights[i] * width[i];\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n    \\n    \\n    private List<Integer> NSL(int[] heights, int n) {\\n            \\n        List<Integer> nsl = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int curr = heights[i];\\n            while(!st.isEmpty() && st.peek()[0] >= curr) { st.pop(); }\\n            if(st.isEmpty()) nsl.add(-1);\\n            else nsl.add(st.peek()[1]);\\n            st.add(new int[] { curr, i });\\n        }\\n        \\n        return nsl;\\n    }\\n    \\n    \\n     private List<Integer> NSR(int[] heights, int n) {\\n            \\n        List<Integer> nsr = new ArrayList<>();\\n        Stack<int[]> st = new Stack<>();\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            int curr = heights[i];\\n            while(!st.isEmpty() && st.peek()[0] >= curr) { st.pop(); }\\n            if(st.isEmpty()) nsr.add(n);\\n            else nsr.add(st.peek()[1]);\\n            st.add(new int[] { curr, i });\\n        }\\n         \\n        Collections.reverse(nsr);\\n        return nsr;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281941,
                "title": "easy-c-solution-dp-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxarea(vector<int> &v){\\n        stack<int> s;\\n        int ans=0;\\n        for(int i=0; i<=v.size(); i++){\\n            while(!s.empty() && (i==v.size() || v[s.top()]>v[i])){\\n                int cur=s.top();\\n                s.pop();\\n                int width = s.empty()? i:i-s.top()-1;\\n                ans = max(ans, width*v[cur]);\\n            }\\n            s.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> curr(n, 0);\\n        \\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')     curr[j]++;\\n                else    curr[j]=0;\\n            }\\n            int area = maxarea(curr);\\n            ans=max(ans, area);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxarea(vector<int> &v){\\n        stack<int> s;\\n        int ans=0;\\n        for(int i=0; i<=v.size(); i++){\\n            while(!s.empty() && (i==v.size() || v[s.top()]>v[i])){\\n                int cur=s.top();\\n                s.pop();\\n                int width = s.empty()? i:i-s.top()-1;\\n                ans = max(ans, width*v[cur]);\\n            }\\n            s.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> curr(n, 0);\\n        \\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')     curr[j]++;\\n                else    curr[j]=0;\\n            }\\n            int area = maxarea(curr);\\n            ans=max(ans, area);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904690,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/0f9c1431-a088-4d22-b810-5abfd51f4630_1648848619.0584486.png)\\n\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \"\"\" O(NM)TS \"\"\"\\n        ans = []\\n        prefix = [*zip(*([*itertools.accumulate(map(int, col), lambda x, y: x + y if y == 1 else 0)] for col in zip(*matrix)))]\\n\\n        for row in prefix:\\n            stack = [-1]\\n            for i, n in enumerate(row):\\n                while len(stack) > 1 and row[stack[-1]] >= n:\\n                    ans += row[stack.pop()] * (i - stack[-1] - 1),\\n                stack += i,\\n            while len(stack) > 1:\\n                ans += row[stack.pop()] * (len(row) - stack[-1] - 1),\\n\\n        return max(ans)\\n\\t\\t\\n\\nsee the problem 84\\n\\n![image](https://assets.leetcode.com/users/images/25726517-a8f6-4496-9756-8ee5d78a0a1d_1648848646.6423938.png)\\n\\nhow to use pref summ\\n\\n\\n![image](https://assets.leetcode.com/users/images/afee3df3-6d24-4b1b-9a54-b5bce4bb1679_1648848659.2007706.png)\\n\\n![image](https://assets.leetcode.com/users/images/28fa08c0-f430-4f32-98ff-c016d18e16e4_1648848666.474494.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/0f9c1431-a088-4d22-b810-5abfd51f4630_1648848619.0584486.png)\\n\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \"\"\" O(NM)TS \"\"\"\\n        ans = []\\n        prefix = [*zip(*([*itertools.accumulate(map(int, col), lambda x, y: x + y if y == 1 else 0)] for col in zip(*matrix)))]\\n\\n        for row in prefix:\\n            stack = [-1]\\n            for i, n in enumerate(row):\\n                while len(stack) > 1 and row[stack[-1]] >= n:\\n                    ans += row[stack.pop()] * (i - stack[-1] - 1),\\n                stack += i,\\n            while len(stack) > 1:\\n                ans += row[stack.pop()] * (len(row) - stack[-1] - 1),\\n\\n        return max(ans)\\n\\t\\t\\n\\nsee the problem 84\\n\\n![image](https://assets.leetcode.com/users/images/25726517-a8f6-4496-9756-8ee5d78a0a1d_1648848646.6423938.png)\\n\\nhow to use pref summ\\n\\n\\n![image](https://assets.leetcode.com/users/images/afee3df3-6d24-4b1b-9a54-b5bce4bb1679_1648848659.2007706.png)\\n\\n![image](https://assets.leetcode.com/users/images/28fa08c0-f430-4f32-98ff-c016d18e16e4_1648848666.474494.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1873952,
                "title": "explanation-with-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/468d99fd-4348-4866-8b8c-9609d3293cfd_1648020077.274421.png)\\n\\n\\n1. Every row can be converted into a histogram very easily. Total time taken for this operation will be **O(rows * cols)**.\\n2. Then for every histogram we can find the largest area of rectangle in it. We can find the largest area of rectangle in histogram in **O(cols)** time using monotonous stack. So the total time complexity for finding largest area of reactangle in every histogram will be **O(rows * cols)**.\\n3. Max rectangle will be the largest area of histogram among all histograms.\\n\\nTime Complexity: O(rows * cols)\\nSpace Complexity: O(rows * cols)\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n\\n        vector<vector<int>> rowHeights(rows, vector(cols, 0));\\n        \\n\\t\\t// convert every row into a histogram\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                if (row == 0) {\\n                    rowHeights[row][col] = matrix[row][col] - \\'0\\';\\n                } else {\\n                    if (matrix[row][col] == \\'0\\') rowHeights[row][col] = 0;\\n                    else rowHeights[row][col] = 1 + rowHeights[row-1][col];\\n                }\\n            }\\n        }\\n        \\n        int maxRectangle = 0;\\n        \\n        for(auto &heights: rowHeights) {\\n            int area = getMaxArea(heights);\\n            maxRectangle = max(area, maxRectangle);\\n        }\\n        \\n        return maxRectangle;\\n    }\\n    \\n    // return the maximum area of rectangle in histogram\\n    int getMaxArea(vector<int> &heights) {\\n        int n = heights.size();\\n        vector<int> areas(n);\\n        stack<int> stk;\\n        stk.push(n);\\n        \\n        // nearest smaller element to right\\n        for(int i = n-1; i >= 0; i--) {\\n            int height = heights[i];\\n\\n            while (stk.top() != n && heights[stk.top()] >= height) stk.pop();\\n            \\n            areas[i] = stk.top();\\n            \\n            stk.push(i);\\n        }\\n\\n        stk.push(-1);\\n        // nearest smaller element to left\\n        for(int i = 0; i < n; i++) {\\n            int height = heights[i];\\n\\n            while (stk.top() != -1 && heights[stk.top()] >= height) stk.pop();\\n            \\n            // width = right - left - 1\\n            // width = right - (left + 1)\\n            areas[i] -= stk.top() + 1;\\n\\n            areas[i] *= height;\\n            \\n            stk.push(i);\\n        }\\n        \\n        return *max_element(areas.begin(), areas.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n\\n        vector<vector<int>> rowHeights(rows, vector(cols, 0));\\n        \\n\\t\\t// convert every row into a histogram\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                if (row == 0) {\\n                    rowHeights[row][col] = matrix[row][col] - \\'0\\';\\n                } else {\\n                    if (matrix[row][col] == \\'0\\') rowHeights[row][col] = 0;\\n                    else rowHeights[row][col] = 1 + rowHeights[row-1][col];\\n                }\\n            }\\n        }\\n        \\n        int maxRectangle = 0;\\n        \\n        for(auto &heights: rowHeights) {\\n            int area = getMaxArea(heights);\\n            maxRectangle = max(area, maxRectangle);\\n        }\\n        \\n        return maxRectangle;\\n    }\\n    \\n    // return the maximum area of rectangle in histogram\\n    int getMaxArea(vector<int> &heights) {\\n        int n = heights.size();\\n        vector<int> areas(n);\\n        stack<int> stk;\\n        stk.push(n);\\n        \\n        // nearest smaller element to right\\n        for(int i = n-1; i >= 0; i--) {\\n            int height = heights[i];\\n\\n            while (stk.top() != n && heights[stk.top()] >= height) stk.pop();\\n            \\n            areas[i] = stk.top();\\n            \\n            stk.push(i);\\n        }\\n\\n        stk.push(-1);\\n        // nearest smaller element to left\\n        for(int i = 0; i < n; i++) {\\n            int height = heights[i];\\n\\n            while (stk.top() != -1 && heights[stk.top()] >= height) stk.pop();\\n            \\n            // width = right - left - 1\\n            // width = right - (left + 1)\\n            areas[i] -= stk.top() + 1;\\n\\n            areas[i] *= height;\\n            \\n            stk.push(i);\\n        }\\n        \\n        return *max_element(areas.begin(), areas.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825997,
                "title": "c-two-stacks-solution-simple",
                "content": "leetcode 84-> same approach\\n https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1825607/C++-oror-two-stack-solution-oror-simple-oror-previous-smaller-element-oror-next-smaller-element\\n \\n ```\\n class Solution {\\n    int fun(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nsl,nsr;\\n        stack<pair<int,int>> s1,s2;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s1.empty())\\n                nsl.push_back(-1);\\n            else{\\n                while(!s1.empty() && s1.top().first>=nums[i])\\n                    s1.pop();\\n                if(s1.empty())\\n                    nsl.push_back(-1);\\n                else\\n                    nsl.push_back(s1.top().second);\\n            }\\n            s1.push({nums[i],i});\\n        }\\n\\t\\t\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s2.empty())\\n                nsr.push_back(n);\\n            else{\\n                while(!s2.empty() && s2.top().first>=nums[i])\\n                    s2.pop();\\n                if(s2.empty())\\n                    nsr.push_back(n);\\n                else\\n                    nsr.push_back(s2.top().second);\\n            }\\n            s2.push({nums[i],i});\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n\\t\\t\\n        int res = INT_MIN;\\n        int val=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            val = (nsr[i]-nsl[i]-1)*nums[i];\\n            res = max(res,val);\\n        }\\n        return res;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size();\\n        int column = matrix[0].size();\\n        vector<int> arr(column,0);\\n        int res = INT_MIN;\\n        for(int i = 0;i<row;i++)\\n        {\\n            for(int j=0;j<column;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')\\n                    arr[j]=0;\\n                else\\n                    arr[j]++;\\n            }\\n            res = max(res,fun(arr));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n    int fun(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nsl,nsr;\\n        stack<pair<int,int>> s1,s2;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s1.empty())\\n                nsl.push_back(-1);\\n            else{\\n                while(!s1.empty() && s1.top().first>=nums[i])\\n                    s1.pop();\\n                if(s1.empty())\\n                    nsl.push_back(-1);\\n                else\\n                    nsl.push_back(s1.top().second);\\n            }\\n            s1.push({nums[i],i});\\n        }\\n\\t\\t\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s2.empty())\\n                nsr.push_back(n);\\n            else{\\n                while(!s2.empty() && s2.top().first>=nums[i])\\n                    s2.pop();\\n                if(s2.empty())\\n                    nsr.push_back(n);\\n                else\\n                    nsr.push_back(s2.top().second);\\n            }\\n            s2.push({nums[i],i});\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n\\t\\t\\n        int res = INT_MIN;\\n        int val=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            val = (nsr[i]-nsl[i]-1)*nums[i];\\n            res = max(res,val);\\n        }\\n        return res;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size();\\n        int column = matrix[0].size();\\n        vector<int> arr(column,0);\\n        int res = INT_MIN;\\n        for(int i = 0;i<row;i++)\\n        {\\n            for(int j=0;j<column;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')\\n                    arr[j]=0;\\n                else\\n                    arr[j]++;\\n            }\\n            res = max(res,fun(arr));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791446,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic: \\n    vector<int> nextSmallerElement(int *arr,int n)\\n    {\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmallerElement(int *arr,int n)\\n    {\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int largestRectangleArea(int *heights,int n) {\\n        //int n=heights.size();\\n        \\n        vector<int> next(n);\\n        next=nextSmallerElement(heights,n);\\n        \\n        vector<int> prev(n);\\n        prev=prevSmallerElement(heights,n);\\n        \\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            \\n            if(next[i]==-1)\\n                next[i]=n;\\n            int b=next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area= max(area,newArea);\\n        }\\n        return area;\\n        \\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        int mat[rows][cols];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                mat[i][j]=matrix[i][j]-\\'0\\';\\n            }\\n        }\\n        int area=largestRectangleArea(mat[0],cols);\\n        for(int i=1;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n               if(mat[i][j]!=0)\\n                   mat[i][j]=mat[i][j]+mat[i-1][j];\\n                else\\n                    mat[i][j]=0;\\n            }\\n             int newArea=largestRectangleArea(mat[i],cols);\\n            area=max(area,newArea);\\n        }\\n        \\n       return area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: \\n    vector<int> nextSmallerElement(int *arr,int n)\\n    {\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmallerElement(int *arr,int n)\\n    {\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int curr=arr[i];\\n            while(s.top()!=-1 && arr[s.top()]>=curr)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int largestRectangleArea(int *heights,int n) {\\n        //int n=heights.size();\\n        \\n        vector<int> next(n);\\n        next=nextSmallerElement(heights,n);\\n        \\n        vector<int> prev(n);\\n        prev=prevSmallerElement(heights,n);\\n        \\n        int area=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=heights[i];\\n            \\n            if(next[i]==-1)\\n                next[i]=n;\\n            int b=next[i]-prev[i]-1;\\n            int newArea=l*b;\\n            area= max(area,newArea);\\n        }\\n        return area;\\n        \\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        int mat[rows][cols];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                mat[i][j]=matrix[i][j]-\\'0\\';\\n            }\\n        }\\n        int area=largestRectangleArea(mat[0],cols);\\n        for(int i=1;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n               if(mat[i][j]!=0)\\n                   mat[i][j]=mat[i][j]+mat[i-1][j];\\n                else\\n                    mat[i][j]=0;\\n            }\\n             int newArea=largestRectangleArea(mat[i],cols);\\n            area=max(area,newArea);\\n        }\\n        \\n       return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718057,
                "title": "c-solution",
                "content": "```class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> dp (matrix[0].size(), 0);\\n        int res = 0;\\n        \\n        for (int i = 0; i < matrix.size(); i++) {\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    dp[j] ++;\\n                    int row_len = dp[j];\\n                    int k = j;\\n                    while (k >= 0) {\\n                        row_len = min(row_len, dp[k]);\\n                        res = max(res, row_len * (j - k + 1));\\n                        k--;\\n                    }\\n                } else {\\n                    dp[j] = 0;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> dp (matrix[0].size(), 0);\\n        int res = 0;\\n        \\n        for (int i = 0; i < matrix.size(); i++) {\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    dp[j] ++;\\n                    int row_len = dp[j];\\n                    int k = j;\\n                    while (k >= 0) {\\n                        row_len = min(row_len, dp[k]);\\n                        res = max(res, row_len * (j - k + 1));\\n                        k--;\\n                    }\\n                } else {\\n                    dp[j] = 0;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630281,
                "title": "easy-to-understand-in-c-histogram-approach-d-p",
                "content": "class Solution {\\npublic:\\n    \\n    int maxAreaHistogram(vector<int>& heights)\\n    {\\n        int n = heights.size();\\n        vector<int> nsl(n),psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            nsl[i] = s.empty() ? n : s.top();\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }\\n            psl[i] = s.empty() ? -1: s.top();\\n            s.push(i);\\n        }\\n        \\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            ans = max(ans,(nsl[i]-psl[i]-1)*(heights[i]));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        if( matrix.empty() ) return 0;\\n        \\n        int rowSize = matrix.size();\\n        int colSize = matrix[0].size();\\n        int maxArea = 0;\\n        \\n        vector<vector<int>>grid(rowSize,vector<int>(colSize,0));\\n        \\n        for( int i = 0; i < rowSize; i++ )\\n        {\\n            for( int j = 0; j < colSize; j++ )\\n            {\\n                grid[i][j] = ( matrix[i][j] == \\'1\\' ? 1 : 0 );\\n                if( i != 0 && grid[i][j] == 1 ) grid[i][j] += grid[i-1][j];\\n            }\\n            \\n            int tmpAns = maxAreaHistogram(grid[i]);\\n            maxArea = max(maxArea,tmpAns);\\n        }\\n\\n        return maxArea;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int maxAreaHistogram(vector<int>& heights)\\n    {\\n        int n = heights.size();\\n        vector<int> nsl(n),psl(n);\\n        \\n        stack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() && heights[s.top()]>=heights[i]){\\n                s.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1572778,
                "title": "python-from-n-4-to-n-3-to-n-2",
                "content": "**Goal**: explain approach from n^4 to n^3 to n^2\\n\\n**n^4**\\n- we start creating a rectangle at any given point in matrix -> o(n^2)\\n- so at this given point we check each row below it and see if the # of consecutive \\'1\\'s in each row gives us a new `minWidth` to consider\\n- then update `maxArea` according to this `minWidth`\\n- this approach has ideas similar to max stock price profit problem\\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        maxVal = 0\\n        out = 0\\n        minWidth = defaultdict(int)\\n        for i in range(len(matrix)-1,-1,-1):\\n            for j in range(len(matrix[0])-1, -1, -1):\\n                minW = len(matrix[0])-j\\n                maxArea = 0\\n                for di in range(i, len(matrix)):\\n                    currW = len(matrix[0])-j\\n                    for dj in range(j,len(matrix[0])):\\n                        if matrix[di][dj] != \"1\":\\n                            currW=dj-j\\n                            break\\n                    minW = min(minW, currW)\\n                    maxArea = max(maxArea, (di-i+1)*minW)\\n                out = max(out, maxArea)\\n        return out\\n```\\n\\n**n^3**\\n- we can preprocess the `minWidth` beforehand\\n- if the `matrix[i][j+1]` is \"1\" and `matrix[i][j]` is \\'1\\' then just add `minWidth[i][j+1] + 1` to `matrix[i][j]` else it remains 0\\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):        \\n        maxVal = 0\\n        out = 0\\n        minWidth = defaultdict(int)\\n        for di in range(len(matrix)):\\n            currW = len(matrix[0])\\n            for dj in range(len(matrix[0])-1, -1, -1):\\n                if matrix[di][dj] != \"1\":\\n                    minWidth[(di,dj)] = 0\\n                else:\\n                    minWidth[(di,dj)] = 1\\n                    minWidth[(di,dj)] += minWidth[(di,dj+1)] if dj+1!=len(matrix[0]) else 0\\n\\n        \\n        for i in range(len(matrix)-1,-1,-1):\\n            for j in range(len(matrix[0])-1, -1, -1):\\n                minW = len(matrix[0])-j\\n                maxArea = 0\\n                for di in range(i, len(matrix)):\\n                    minW = min(minW, minWidth[(di,j)])\\n                    maxArea = max(maxArea, (di-i+1)*minW)\\n                out = max(out, maxArea)\\n        return out\\n```\\n\\n**n^2**\\n- the last optimization to consider is that instead of using the o(1) extra space `maxArea`, we can use o(n) extra space with `maxLeft`, `maxRight`, and `stack` to do one less loop\\n- we consider that at each column `j`:\\n- one row\\'s `maxWidth[i][j]` to be the max width\\n\\t- that means anything greater than this can still be considered in the rectangle\\'s area\\n\\t- anything less than this will bound the rectangle we\\'re considering\\n\\t- area = `minWidth[i][j]` * distance btwn the two bounding rows\\n- this operation can be implemented using the `stack` data structure\\n- this approach is very similar to the largest rectangle in histogram problem\\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        maxVal = 0\\n        out = 0\\n        if matrix==[]:\\n            return 0\\n        minWidth = defaultdict(lambda: defaultdict(int))\\n        for di in range(len(matrix)):\\n            currW = len(matrix[0])\\n            for dj in range(len(matrix[0])-1, -1, -1):\\n                if matrix[di][dj] != \"1\":\\n                    minWidth[di][dj] = 0\\n                else:\\n                    minWidth[di][dj] = 1\\n                    minWidth[di][dj] += minWidth[di][dj+1] if dj+1!=len(matrix[0]) else 0\\n\\t\\t\\t\\t\\t\\n        maxArea = 0\\n        for j in range(len(matrix[0])):\\n            maxLeft = [-1]*len(matrix)\\n            maxRight = [len(matrix)]*len(matrix)\\n            stack = []\\n            for i in range(len(matrix)):\\n                while stack and minWidth[i][j] < minWidth[stack[-1]][j]:\\n                    maxRight[stack.pop()] = i\\n                maxLeft[i] = stack[-1] if stack else -1\\n                stack.append(i)\\n            area = [(maxRight[i] - maxLeft[i] - 1)*minWidth[i][j] for i in range(len(matrix))]\\n            maxArea = max(maxArea, max(area))\\n        return maxArea\\n```    \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        maxVal = 0\\n        out = 0\\n        minWidth = defaultdict(int)\\n        for i in range(len(matrix)-1,-1,-1):\\n            for j in range(len(matrix[0])-1, -1, -1):\\n                minW = len(matrix[0])-j\\n                maxArea = 0\\n                for di in range(i, len(matrix)):\\n                    currW = len(matrix[0])-j\\n                    for dj in range(j,len(matrix[0])):\\n                        if matrix[di][dj] != \"1\":\\n                            currW=dj-j\\n                            break\\n                    minW = min(minW, currW)\\n                    maxArea = max(maxArea, (di-i+1)*minW)\\n                out = max(out, maxArea)\\n        return out\\n```\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):        \\n        maxVal = 0\\n        out = 0\\n        minWidth = defaultdict(int)\\n        for di in range(len(matrix)):\\n            currW = len(matrix[0])\\n            for dj in range(len(matrix[0])-1, -1, -1):\\n                if matrix[di][dj] != \"1\":\\n                    minWidth[(di,dj)] = 0\\n                else:\\n                    minWidth[(di,dj)] = 1\\n                    minWidth[(di,dj)] += minWidth[(di,dj+1)] if dj+1!=len(matrix[0]) else 0\\n\\n        \\n        for i in range(len(matrix)-1,-1,-1):\\n            for j in range(len(matrix[0])-1, -1, -1):\\n                minW = len(matrix[0])-j\\n                maxArea = 0\\n                for di in range(i, len(matrix)):\\n                    minW = min(minW, minWidth[(di,j)])\\n                    maxArea = max(maxArea, (di-i+1)*minW)\\n                out = max(out, maxArea)\\n        return out\\n```\n```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        maxVal = 0\\n        out = 0\\n        if matrix==[]:\\n            return 0\\n        minWidth = defaultdict(lambda: defaultdict(int))\\n        for di in range(len(matrix)):\\n            currW = len(matrix[0])\\n            for dj in range(len(matrix[0])-1, -1, -1):\\n                if matrix[di][dj] != \"1\":\\n                    minWidth[di][dj] = 0\\n                else:\\n                    minWidth[di][dj] = 1\\n                    minWidth[di][dj] += minWidth[di][dj+1] if dj+1!=len(matrix[0]) else 0\\n\\t\\t\\t\\t\\t\\n        maxArea = 0\\n        for j in range(len(matrix[0])):\\n            maxLeft = [-1]*len(matrix)\\n            maxRight = [len(matrix)]*len(matrix)\\n            stack = []\\n            for i in range(len(matrix)):\\n                while stack and minWidth[i][j] < minWidth[stack[-1]][j]:\\n                    maxRight[stack.pop()] = i\\n                maxLeft[i] = stack[-1] if stack else -1\\n                stack.append(i)\\n            area = [(maxRight[i] - maxLeft[i] - 1)*minWidth[i][j] for i in range(len(matrix))]\\n            maxArea = max(maxArea, max(area))\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481047,
                "title": "based-on-largest-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n    \\n        \\n    int[] left = new int[heights.length]; \\n    int[] right = new int[heights.length];\\n    int[] width = new int[heights.length];\\n    Stack<Integer> stack = new Stack();\\n        \\n        \\n       //width --- left\\n        for(int i=0;i<heights.length;i++){\\n            \\n            while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            if(stack.isEmpty()){\\n                left[i] = -1;\\n            }else{\\n                left[i] = stack.peek();\\n            }\\n            \\n            stack.add(i);\\n        }\\n        stack.clear();\\n        //width --- right\\n        for(int i=heights.length-1;i>=0;i--){\\n            \\n            while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            if(stack.isEmpty()){\\n                right[i] = heights.length;\\n            }else{\\n                right[i] = stack.peek();\\n            }\\n            \\n            stack.add(i);\\n        }\\n        \\n        int area = 0;\\n        \\n         for(int i=0;i<heights.length;i++){\\n            width[i] = right[i]-left[i]-1;\\n            area = Math.max(heights[i]* width[i] ,area);\\n         }\\n        \\n        return area;\\n    }\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = largestRectangleArea(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n    \\n        \\n    int[] left = new int[heights.length]; \\n    int[] right = new int[heights.length];\\n    int[] width = new int[heights.length];\\n    Stack<Integer> stack = new Stack();\\n        \\n        \\n       //width --- left\\n        for(int i=0;i<heights.length;i++){\\n            \\n            while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            if(stack.isEmpty()){\\n                left[i] = -1;\\n            }else{\\n                left[i] = stack.peek();\\n            }\\n            \\n            stack.add(i);\\n        }\\n        stack.clear();\\n        //width --- right\\n        for(int i=heights.length-1;i>=0;i--){\\n            \\n            while(!stack.isEmpty() && heights[i]<=heights[stack.peek()]){\\n                stack.pop();\\n            }\\n            \\n            if(stack.isEmpty()){\\n                right[i] = heights.length;\\n            }else{\\n                right[i] = stack.peek();\\n            }\\n            \\n            stack.add(i);\\n        }\\n        \\n        int area = 0;\\n        \\n         for(int i=0;i<heights.length;i++){\\n            width[i] = right[i]-left[i]-1;\\n            area = Math.max(heights[i]* width[i] ,area);\\n         }\\n        \\n        return area;\\n    }\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = largestRectangleArea(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374213,
                "title": "c-dp",
                "content": "```\\n\\n```public:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int i,j,k,n,m,minn,res=0;\\n        n=matrix.size();\\n        if(n==0)\\n        {\\n            return 0;\\n        }\\n        m=matrix[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(i=0;i<n;i++)\\n        {\\n            dp[i][m-1]=(int)matrix[i][m-1]-\\'0\\';\\n            for(j=m-2;j>=0;j--)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    dp[i][j]=dp[i][j+1]+1;\\n                }\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                k=i;\\n                minn=dp[i][j];\\n                while(k<n&&dp[k][j])\\n                {\\n                    minn=min(minn,dp[k][j]);\\n                    res=max(res,minn*(k-i+1));\\n                    k++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304139,
                "title": "python-o-row-col-using-histogram",
                "content": "![image](https://assets.leetcode.com/users/images/cf0c802f-690c-4c93-a4bb-8f2c10e032c9_1624947641.2761607.jpeg)\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        row=len(matrix)\\n        col=len(matrix[0])\\n        histograms=[[0]*col for _ in range(row)]\\n        for i in range(row):\\n            for j in range(col):\\n                if i==0:\\n                    histograms[i][j]=int(matrix[i][j])\\n                else:\\n                    if int(matrix[i][j])==0:\\n                        histograms[i][j]=0\\n                    else:\\n                        histograms[i][j]=histograms[i-1][j]+int(matrix[i][j])\\n        def maxArea(arr):\\n            stack=[]\\n            i=0\\n            Max=0\\n            while i<len(arr):\\n                if not stack or arr[i]>=arr[stack[-1]]:\\n                    stack.append(i)\\n                    i+=1\\n                else:\\n                    a=stack.pop()\\n                    area=arr[a]*((i-stack[-1]-1) if stack else i)\\n                    Max=max(area,Max)\\n            pre=stack[-1]\\n            while stack:\\n                a=stack.pop()\\n                area=arr[a]*((pre-stack[-1]) if stack else pre+1)\\n                Max=max(area,Max)\\n            return Max\\n        k=0\\n        for i in histograms:\\n            k=max(k,maxArea(i))\\n        return k\\n                    \\n                    \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        row=len(matrix)\\n        col=len(matrix[0])\\n        histograms=[[0]*col for _ in range(row)]\\n        for i in range(row):\\n            for j in range(col):\\n                if i==0:\\n                    histograms[i][j]=int(matrix[i][j])\\n                else:\\n                    if int(matrix[i][j])==0:\\n                        histograms[i][j]=0\\n                    else:\\n                        histograms[i][j]=histograms[i-1][j]+int(matrix[i][j])\\n        def maxArea(arr):\\n            stack=[]\\n            i=0\\n            Max=0\\n            while i<len(arr):\\n                if not stack or arr[i]>=arr[stack[-1]]:\\n                    stack.append(i)\\n                    i+=1\\n                else:\\n                    a=stack.pop()\\n                    area=arr[a]*((i-stack[-1]-1) if stack else i)\\n                    Max=max(area,Max)\\n            pre=stack[-1]\\n            while stack:\\n                a=stack.pop()\\n                area=arr[a]*((pre-stack[-1]) if stack else pre+1)\\n                Max=max(area,Max)\\n            return Max\\n        k=0\\n        for i in histograms:\\n            k=max(k,maxArea(i))\\n        return k\\n                    \\n                    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243824,
                "title": "largest-histogram-bottom-up-filling-o-n-2-solution",
                "content": "\\nBased on Largest area rectangle in  Histogram ...\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int hist(vector<int> &height){\\n        \\n        if(height.size()==0){return 0;}\\n        if(height.size()==1){return height[0];}\\n        int ans=0;\\n        stack<int> s;\\n        for(int i=0;i<height.size();i++){\\n            if(s.empty()||height[i]>=height[s.top()]){\\n                s.push(i);\\n            }\\n            else {\\n                int temp=s.top();\\n                s.pop();\\n                if(s.empty()){\\n                    ans=max(ans,height[temp]*i);\\n                }\\n                else{\\n                    ans=max(ans,height[temp]*(i-s.top()-1));\\n                }\\n                i--;\\n            }\\n        }\\n        int i=height.size();\\n        while(!s.empty()){\\n            int temp=s.top();\\n                s.pop();\\n                if(s.empty()){\\n                    ans=max(ans,height[temp]*i);\\n                }\\n                else{\\n                    ans=max(ans,height[temp]*(i-s.top()-1));\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0){return 0;}\\n        vector<vector<int>> heights(matrix.size(),vector<int> (matrix[0].size(),0));\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            heights[i][matrix[i].size()-1]= matrix[i][matrix[i].size()-1]==\\'0\\'?0:1;\\n            \\n            for(int j=matrix[i].size()-2;j>=0;j--){\\n                if(matrix[i][j]==\\'0\\'){heights[i][j]=0;}\\n                else{\\n                    heights[i][j]=heights[i][j+1]+1;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n      \\n        for(int j=0;j<matrix[0].size();j++){\\n            vector<int> temp;\\n              int mini =INT_MAX;\\n            for(int i=0;i<matrix.size();i++){\\n                mini=min(mini,heights[i][j]);\\n                temp.push_back(heights[i][j]);\\n            }\\n            ans=max(ans,hist(temp));\\n            j+=mini;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int hist(vector<int> &height){\\n        \\n        if(height.size()==0){return 0;}\\n        if(height.size()==1){return height[0];}\\n        int ans=0;\\n        stack<int> s;\\n        for(int i=0;i<height.size();i++){\\n            if(s.empty()||height[i]>=height[s.top()]){\\n                s.push(i);\\n            }\\n            else {\\n                int temp=s.top();\\n                s.pop();\\n                if(s.empty()){\\n                    ans=max(ans,height[temp]*i);\\n                }\\n                else{\\n                    ans=max(ans,height[temp]*(i-s.top()-1));\\n                }\\n                i--;\\n            }\\n        }\\n        int i=height.size();\\n        while(!s.empty()){\\n            int temp=s.top();\\n                s.pop();\\n                if(s.empty()){\\n                    ans=max(ans,height[temp]*i);\\n                }\\n                else{\\n                    ans=max(ans,height[temp]*(i-s.top()-1));\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0){return 0;}\\n        vector<vector<int>> heights(matrix.size(),vector<int> (matrix[0].size(),0));\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            heights[i][matrix[i].size()-1]= matrix[i][matrix[i].size()-1]==\\'0\\'?0:1;\\n            \\n            for(int j=matrix[i].size()-2;j>=0;j--){\\n                if(matrix[i][j]==\\'0\\'){heights[i][j]=0;}\\n                else{\\n                    heights[i][j]=heights[i][j+1]+1;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n      \\n        for(int j=0;j<matrix[0].size();j++){\\n            vector<int> temp;\\n              int mini =INT_MAX;\\n            for(int i=0;i<matrix.size();i++){\\n                mini=min(mini,heights[i][j]);\\n                temp.push_back(heights[i][j]);\\n            }\\n            ans=max(ans,hist(temp));\\n            j+=mini;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801801,
                "title": "java-stack-o-n-m-time-largest-area-in-histogram",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] M) {\\n    \\n         int m = M.length;\\n        if( m == 0) return 0;\\n        int n = M[0].length;\\n        int ans  = 0;\\n        int a[] = new int[n];\\n        \\n        for(int i = 0;i<n;i++)\\n            a[i] = M[0][i]-\\'0\\';\\n            \\n        for(int i = 0;i<m;i++){\\n            if( i == 0){\\n                \\n                ans = Math.max(ans, maximumAreaInHistogram(a));\\n                continue;\\n            }\\n            \\n            for(int j = 0; j<n;j++){\\n                a[j] += M[i][j]-\\'0\\' ;\\n                if( M[i][j] == \\'0\\')\\n                    a[j] = 0;\\n            }    \\n            \\n            \\n            ans = Math.max(ans, maximumAreaInHistogram(a));\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    \\n    \\n   int maximumAreaInHistogram(int h[]){\\n        \\n        int n = h.length;\\n        \\n        Stack<Integer> st = new Stack();\\n        \\n        int l[] = new int[n];\\n        int r[] = new int[n];\\n        \\n        \\n        for(int i = 0;i<n;i++){\\n            if( st.isEmpty()){\\n                l[i] = -1;\\n                st.push(i);\\n                continue;\\n            }\\n            \\n            while( !st.isEmpty() && h[st.peek()] >= h[i]  ){\\n                st.pop();\\n                \\n            }\\n            \\n            int p = st.isEmpty() ? -1 : st.peek() ;\\n            \\n            l[i] = p;\\n            st.push(i);\\n\\n        }\\n        \\n        st.clear();\\n        \\n        for(int i = n-1; i>=0; i--){\\n            if( st.isEmpty()){\\n                r[i] = n;\\n                st.push(i);\\n                continue;\\n            }\\n            \\n            while( !st.isEmpty() && h[st.peek()] >= h[i]  ){\\n                st.pop();\\n                \\n            }\\n            \\n            int p = st.isEmpty() ? n : st.peek() ;\\n            \\n            r[i] = p;\\n            st.push(i);\\n\\n        }\\n        \\n        \\n        \\n        int m = 0;\\n        \\n        for(int i = 0;i<n;i++){\\n            m = Math.max(m, h[i]*(r[i]-l[i]-1) );\\n        }\\n        \\n        \\n        return m;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] M) {\\n    \\n         int m = M.length;\\n        if( m == 0) return 0;\\n        int n = M[0].length;\\n        int ans  = 0;\\n        int a[] = new int[n];\\n        \\n        for(int i = 0;i<n;i++)\\n            a[i] = M[0][i]-\\'0\\';\\n            \\n        for(int i = 0;i<m;i++){\\n            if( i == 0){\\n                \\n                ans = Math.max(ans, maximumAreaInHistogram(a));\\n                continue;\\n            }\\n            \\n            for(int j = 0; j<n;j++){\\n                a[j] += M[i][j]-\\'0\\' ;\\n                if( M[i][j] == \\'0\\')\\n                    a[j] = 0;\\n            }    \\n            \\n            \\n            ans = Math.max(ans, maximumAreaInHistogram(a));\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    \\n    \\n   int maximumAreaInHistogram(int h[]){\\n        \\n        int n = h.length;\\n        \\n        Stack<Integer> st = new Stack();\\n        \\n        int l[] = new int[n];\\n        int r[] = new int[n];\\n        \\n        \\n        for(int i = 0;i<n;i++){\\n            if( st.isEmpty()){\\n                l[i] = -1;\\n                st.push(i);\\n                continue;\\n            }\\n            \\n            while( !st.isEmpty() && h[st.peek()] >= h[i]  ){\\n                st.pop();\\n                \\n            }\\n            \\n            int p = st.isEmpty() ? -1 : st.peek() ;\\n            \\n            l[i] = p;\\n            st.push(i);\\n\\n        }\\n        \\n        st.clear();\\n        \\n        for(int i = n-1; i>=0; i--){\\n            if( st.isEmpty()){\\n                r[i] = n;\\n                st.push(i);\\n                continue;\\n            }\\n            \\n            while( !st.isEmpty() && h[st.peek()] >= h[i]  ){\\n                st.pop();\\n                \\n            }\\n            \\n            int p = st.isEmpty() ? n : st.peek() ;\\n            \\n            r[i] = p;\\n            st.push(i);\\n\\n        }\\n        \\n        \\n        \\n        int m = 0;\\n        \\n        for(int i = 0;i<n;i++){\\n            m = Math.max(m, h[i]*(r[i]-l[i]-1) );\\n        }\\n        \\n        \\n        return m;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657433,
                "title": "detailed-explanation-code-video-with-best-time-complexity",
                "content": "Please refer this video for detailed explanation - \\n[https://www.youtube.com/watch?v=Q39oYu4p9gY]\\n\\n\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0)\\n            return 0;\\n        int max = 0;\\n        int[] height = new int[matrix[0].length];\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == \\'0\\'){\\n                    height[j] = 0;\\n                } else {\\n                    height[j]+=1;\\n                }\\n            }\\n            max = Math.max(max, findTheArea(height));\\n        }\\n        return max;\\n    }\\n    \\n    public int findTheArea(int[] h){\\n        int max = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.add(0);\\n        for(int i=1; i<h.length; i++){\\n            int curr = h[i];\\n            if(stack.isEmpty() || curr >= h[stack.peek()]){\\n                stack.add(i);\\n            } else {\\n                while(!stack.isEmpty() && curr < h[stack.peek()]){\\n                    int temp = h[stack.pop()];\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, temp*i);\\n                    } else {\\n                        max = Math.max(max, temp*(i-stack.peek()-1));\\n                    }\\n                }\\n                stack.add(i);\\n            }\\n        }\\n        \\n        if(!stack.isEmpty()){\\n             while(!stack.isEmpty()){\\n                    int i = h.length;\\n                    int temp = h[stack.pop()];\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, temp*i);\\n                    } else {\\n                        max = Math.max(max, temp*(i-stack.peek()-1));\\n                    }\\n                }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0)\\n            return 0;\\n        int max = 0;\\n        int[] height = new int[matrix[0].length];\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == \\'0\\'){\\n                    height[j] = 0;\\n                } else {\\n                    height[j]+=1;\\n                }\\n            }\\n            max = Math.max(max, findTheArea(height));\\n        }\\n        return max;\\n    }\\n    \\n    public int findTheArea(int[] h){\\n        int max = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.add(0);\\n        for(int i=1; i<h.length; i++){\\n            int curr = h[i];\\n            if(stack.isEmpty() || curr >= h[stack.peek()]){\\n                stack.add(i);\\n            } else {\\n                while(!stack.isEmpty() && curr < h[stack.peek()]){\\n                    int temp = h[stack.pop()];\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, temp*i);\\n                    } else {\\n                        max = Math.max(max, temp*(i-stack.peek()-1));\\n                    }\\n                }\\n                stack.add(i);\\n            }\\n        }\\n        \\n        if(!stack.isEmpty()){\\n             while(!stack.isEmpty()){\\n                    int i = h.length;\\n                    int temp = h[stack.pop()];\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, temp*i);\\n                    } else {\\n                        max = Math.max(max, temp*(i-stack.peek()-1));\\n                    }\\n                }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222391,
                "title": "reuse-code-from-problem-84-largest-rectangle-in-histogram",
                "content": "![image](https://assets.leetcode.com/users/goldsail/image_1547999243.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        if (matrix.empty() || matrix[0].empty()) return 0;\\n        \\n        // To ensure all 1\\'s in the monotonic stacks can be popped, insert 0\\'s at the back of each row.\\n        for (int i = 0; i < matrix.size(); i++) {\\n            matrix[i].push_back(\\'0\\');\\n        }\\n        \\n        // First, for each row,\\n        // obtain the number of consecutive 1\\'s on the right side of each element using a monotonic stack.\\n        // These numbers (stored in nums) form a histogram for each column\\n        \\n        vector<vector<int>> nums = vector<vector<int>>(matrix.size(), vector<int>(matrix[0].size()));\\n        \\n        for (int i = 0; i < matrix.size(); i++) {\\n            stack<int> monoStack;\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                while (!monoStack.empty() && matrix[i][monoStack.top()] > matrix[i][j]) {\\n                    nums[i][monoStack.top()] = j - monoStack.top();\\n                    monoStack.pop();\\n                }\\n                monoStack.push(j);\\n            }\\n        }\\n        \\n        // Second, for each column,\\n        // solve the maximal rectangle in the histogram using the idea of Problem 84 (largest rectangle in histogram)\\n        \\n        int result = 0;\\n        for (int j = 0; j < matrix[0].size(); j++) {\\n            vector<int> column = vector<int>(nums.size());\\n            for (int i = 0; i < matrix.size(); i++) {\\n                column[i] = nums[i][j];\\n            }\\n            \\n            SolutionProblem84 solve;\\n            int area = solve.largestRectangleArea(column);\\n            result = max(result, area);\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    static int max(int a, int b) {\\n        return a > b ? a : b;\\n    }\\n    \\n    class SolutionProblem84 {\\n    public:\\n        int largestRectangleArea(vector<int>& heights) {\\n\\n            // Claim: The area of largest rectangle starting from index i depends on next[i] and prev[i], where\\n            // next[i] is the index of the next element smaller than heights[i], and\\n            // prev[i] is the index of the last element smaller than heights[i].\\n            // Initially, set next[i] = heights.size() as we do not know where the next smaller element is.\\n            // Initially, set prev[i] = -1 as we do not know where the last smaller element is.\\n            vector<int> next = vector<int>(heights.size(), heights.size());\\n            vector<int> prev = vector<int>(heights.size(), -1);\\n\\n            // We maintain a monotonic stack which stores indices of which the heights ascend from bottom to top.\\n            stack<int> monoStack;\\n\\n            // First, scan from left to right. \\n            // Update next[j] when j is popped from the monotonic stack, indicating a \"next smaller element\".\\n            monoStack = stack<int>();\\n            for (int i = 0; i < heights.size(); i++) {\\n                while (!monoStack.empty() && heights[monoStack.top()] > heights[i]) {\\n                    next[monoStack.top()] = i;\\n                    monoStack.pop();\\n                }\\n                monoStack.push(i);\\n            }\\n\\n            // Second, scan from right to left. \\n            // Update prev[j] when j is popped from the monotonic stack, indicating a \"last smaller element\".\\n            monoStack = stack<int>();\\n            for (int i = heights.size() - 1; i >= 0; i--) {\\n                while (!monoStack.empty() && heights[monoStack.top()] > heights[i]) {\\n                    prev[monoStack.top()] = i;\\n                    monoStack.pop();\\n                }\\n                monoStack.push(i);\\n            }\\n\\n            // Then, using next[i] and prev[i], calculate the area of the largest rectangle starting from index i\\n            int result = 0;\\n            for (int i = 0; i < heights.size(); i++) {\\n                int area = heights[i] * (next[i] - prev[i] - 1);\\n                result = max(result, area);\\n            }\\n            return result;\\n        }\\n\\n    private:\\n        static int min(int a, int b) {\\n            return a < b ? a : b;\\n        }\\n\\n        static int max(int a, int b) {\\n            return a > b ? a : b;\\n        }\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        if (matrix.empty() || matrix[0].empty()) return 0;\\n        \\n        // To ensure all 1\\'s in the monotonic stacks can be popped, insert 0\\'s at the back of each row.\\n        for (int i = 0; i < matrix.size(); i++) {\\n            matrix[i].push_back(\\'0\\');\\n        }\\n        \\n        // First, for each row,\\n        // obtain the number of consecutive 1\\'s on the right side of each element using a monotonic stack.\\n        // These numbers (stored in nums) form a histogram for each column\\n        \\n        vector<vector<int>> nums = vector<vector<int>>(matrix.size(), vector<int>(matrix[0].size()));\\n        \\n        for (int i = 0; i < matrix.size(); i++) {\\n            stack<int> monoStack;\\n            for (int j = 0; j < matrix[0].size(); j++) {\\n                while (!monoStack.empty() && matrix[i][monoStack.top()] > matrix[i][j]) {\\n                    nums[i][monoStack.top()] = j - monoStack.top();\\n                    monoStack.pop();\\n                }\\n                monoStack.push(j);\\n            }\\n        }\\n        \\n        // Second, for each column,\\n        // solve the maximal rectangle in the histogram using the idea of Problem 84 (largest rectangle in histogram)\\n        \\n        int result = 0;\\n        for (int j = 0; j < matrix[0].size(); j++) {\\n            vector<int> column = vector<int>(nums.size());\\n            for (int i = 0; i < matrix.size(); i++) {\\n                column[i] = nums[i][j];\\n            }\\n            \\n            SolutionProblem84 solve;\\n            int area = solve.largestRectangleArea(column);\\n            result = max(result, area);\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    static int max(int a, int b) {\\n        return a > b ? a : b;\\n    }\\n    \\n    class SolutionProblem84 {\\n    public:\\n        int largestRectangleArea(vector<int>& heights) {\\n\\n            // Claim: The area of largest rectangle starting from index i depends on next[i] and prev[i], where\\n            // next[i] is the index of the next element smaller than heights[i], and\\n            // prev[i] is the index of the last element smaller than heights[i].\\n            // Initially, set next[i] = heights.size() as we do not know where the next smaller element is.\\n            // Initially, set prev[i] = -1 as we do not know where the last smaller element is.\\n            vector<int> next = vector<int>(heights.size(), heights.size());\\n            vector<int> prev = vector<int>(heights.size(), -1);\\n\\n            // We maintain a monotonic stack which stores indices of which the heights ascend from bottom to top.\\n            stack<int> monoStack;\\n\\n            // First, scan from left to right. \\n            // Update next[j] when j is popped from the monotonic stack, indicating a \"next smaller element\".\\n            monoStack = stack<int>();\\n            for (int i = 0; i < heights.size(); i++) {\\n                while (!monoStack.empty() && heights[monoStack.top()] > heights[i]) {\\n                    next[monoStack.top()] = i;\\n                    monoStack.pop();\\n                }\\n                monoStack.push(i);\\n            }\\n\\n            // Second, scan from right to left. \\n            // Update prev[j] when j is popped from the monotonic stack, indicating a \"last smaller element\".\\n            monoStack = stack<int>();\\n            for (int i = heights.size() - 1; i >= 0; i--) {\\n                while (!monoStack.empty() && heights[monoStack.top()] > heights[i]) {\\n                    prev[monoStack.top()] = i;\\n                    monoStack.pop();\\n                }\\n                monoStack.push(i);\\n            }\\n\\n            // Then, using next[i] and prev[i], calculate the area of the largest rectangle starting from index i\\n            int result = 0;\\n            for (int i = 0; i < heights.size(); i++) {\\n                int area = heights[i] * (next[i] - prev[i] - 1);\\n                result = max(result, area);\\n            }\\n            return result;\\n        }\\n\\n    private:\\n        static int min(int a, int b) {\\n            return a < b ? a : b;\\n        }\\n\\n        static int max(int a, int b) {\\n            return a > b ? a : b;\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29061,
                "title": "simple-solution-beats-98-27-of-java-submissions",
                "content": "Height is calculated for every row and contains number of '1's in this column. \\n\\n```    \\npublic int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n        \\n        int col_nums = matrix[0].length;\\n        int height[] = new int[col_nums];\\n        int max_area = 0, area; \\n        for (int i=0; i< matrix.length;i++) {\\n            for(int j=0; j < col_nums; j++) {\\n                if (matrix[i][j] == '0') {\\n                    height[j] = 0;\\n                } else {\\n                    height[j] += 1;\\n                }\\n            }\\n\\n            for(int j=0;j<col_nums;j++) {\\n                if (height[j]==0) continue;\\n \\n                int left = 0, right = 0;\\n\\n                // Check how many columns to my left have same or more height as me\\n                for(int k=j-1;k>=0;k--) {\\n                    if (height[k]<height[j]) break;\\n                    left++;\\n                }\\n\\n                // Check how many columns to my right have same or more height as me\\n                for(int k=j+1;k<col_nums;k++) {\\n                    if (height[k]<height[j]) break;\\n                    right++;\\n                }\\n\\n                area = height[j]*(1+left+right);\\n                if (area > max_area) max_area = area;\\n            }\\n        }\\n\\n        return max_area;\\n    }\\n```",
                "solutionTags": [],
                "code": "```    \\npublic int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n        \\n        int col_nums = matrix[0].length;\\n        int height[] = new int[col_nums];\\n        int max_area = 0, area; \\n        for (int i=0; i< matrix.length;i++) {\\n            for(int j=0; j < col_nums; j++) {\\n                if (matrix[i][j] == '0') {\\n                    height[j] = 0;\\n                } else {\\n                    height[j] += 1;\\n                }\\n            }\\n\\n            for(int j=0;j<col_nums;j++) {\\n                if (height[j]==0) continue;\\n \\n                int left = 0, right = 0;\\n\\n                // Check how many columns to my left have same or more height as me\\n                for(int k=j-1;k>=0;k--) {\\n                    if (height[k]<height[j]) break;\\n                    left++;\\n                }\\n\\n                // Check how many columns to my right have same or more height as me\\n                for(int k=j+1;k<col_nums;k++) {\\n                    if (height[k]<height[j]) break;\\n                    right++;\\n                }\\n\\n                area = height[j]*(1+left+right);\\n                if (area > max_area) max_area = area;\\n            }\\n        }\\n\\n        return max_area;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29099,
                "title": "simple-java-solution-using-dp",
                "content": "```\\npublic class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix==null||matrix.length==0) return 0;\\n        int m=matrix.length;int n=matrix[0].length;\\n        int[] left=new int[n];int[] right=new int[n];int[] height=new int[n];\\n        Arrays.fill(right,n);\\n        int max=0;\\n        for(int i=0;i<m;i++){\\n            int curleft=0;int curright=n;\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]=='1'){height[j]+=1;}\\n                else{height[j]=0;}\\n            }\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]=='1'){left[j]=Math.max(left[j],curleft);}\\n                else{left[j]=0;curleft=j+1;}\\n            }\\n            for(int j=n-1;j>=0;j--){\\n                if(matrix[i][j]=='1'){right[j]=Math.min(right[j],curright);}\\n                else{right[j]=n;curright=j;}\\n            }\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,(right[j]-left[j])*height[j]);\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix==null||matrix.length==0) return 0;\\n        int m=matrix.length;int n=matrix[0].length;\\n        int[] left=new int[n];int[] right=new int[n];int[] height=new int[n];\\n        Arrays.fill(right,n);\\n        int max=0;\\n        for(int i=0;i<m;i++){\\n            int curleft=0;int curright=n;\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]=='1'){height[j]+=1;}",
                "codeTag": "Java"
            },
            {
                "id": 29066,
                "title": "java-7ms-solution-beats-100-using-largest-rectangle-in-histogram-solved-by-stack-simulation",
                "content": "The idea is to use \\u3010Leetcode#84\\u3011(see below comments). \\n\\nAs for \\u3010LC84\\u3011, there are many fast O(n)/O(n)-time/space methods such as using a stack. Mine is to use an array nLeftGeq[] to simulate the stack so that it is faster than the default implement of stack. \\nIndeed, nLeftGeq[i] = the number of elements to the left of [i] having value greater than or equal to a[i] (including a[i] itself). \\n\\nSince for j < i, with a[j]>a[i], we can compute the largest rectangle area with base a[j] then we throw away [j] or pop() it from the stack. \\n\\nTherefore, nLeftGeq[i] is also = the index difference between [i] and the next index on the top of the stack. And thus such as peek(), pop() methods can be implemented by manipulating the array nLeftGeq[].\\n\\nThis sub-algorithm for \\u3010LC84\\u3011is not the fastest one unfortunately, but still beats 95.45%.\\n\\n    public int maximalRectangle(char[][] matrix) {\\n\\t\\t\\t/**\\n\\t\\t\\t * idea: using [LC84 Largest Rectangle in Histogram]. For each row\\n\\t\\t\\t * of the matrix, construct the histogram based on the current row\\n\\t\\t\\t * and the previous histogram (up to the previous row), then compute\\n\\t\\t\\t * the largest rectangle area using LC84.\\n\\t\\t\\t */\\n\\t\\t\\tint m = matrix.length, n;\\n\\t\\t\\tif (m == 0 || (n = matrix[0].length) == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint i, j, res = 0;\\n\\t\\t\\tint[] heights = new int[n];\\n\\t\\t\\tfor (i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tif (matrix[i][j] == '0')\\n\\t\\t\\t\\t\\t\\theights[j] = 0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\theights[j] += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = Math.max(res, largestRectangleArea(heights));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int largestRectangleArea(int[] heights) {\\n\\t\\t\\t/**\\n\\t\\t\\t * idea: scan and store if a[i-1]<=a[i] (increasing), then as long\\n\\t\\t\\t * as a[i]<a[i-1], then we can compute the largest rectangle area\\n\\t\\t\\t * with base a[j], for j<=i-1, and a[j]>a[i], which is a[j]*(i-j).\\n\\t\\t\\t * And meanwhile, all these bars (a[j]'s) are already done, and thus\\n\\t\\t\\t * are throwable (using pop() with a stack).\\n\\t\\t\\t * \\n\\t\\t\\t * We can use an array nLeftGeq[] of size n to simulate a stack.\\n\\t\\t\\t * nLeftGeq[i] = the number of elements to the left of [i] having\\n\\t\\t\\t * value greater than or equal to a[i] (including a[i] itself). It\\n\\t\\t\\t * is also the index difference between [i] and the next index on\\n\\t\\t\\t * the top of the stack.\\n\\t\\t\\t */\\n\\t\\t\\tint n = heights.length;\\n\\t\\t\\tif (n == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint[] nLeftGeq = new int[n]; // the number of elements to the left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// of [i] with value >= heights[i]\\n\\t\\t\\tnLeftGeq[0] = 1;\\n\\n\\t\\t\\t// preIdx=the index of stack.peek(), res=max area so far\\n\\t\\t\\tint preIdx = 0, res = 0;\\n\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tnLeftGeq[i] = 1;\\n\\n\\t\\t\\t\\t// notice that preIdx = i - 1 = peek()\\n\\t\\t\\t\\twhile (preIdx >= 0 && heights[i] < heights[preIdx]) {\\n\\t\\t\\t\\t\\tres = Math.max(res, heights[preIdx] * (nLeftGeq[preIdx] + i - preIdx - 1));\\n\\t\\t\\t\\t\\tnLeftGeq[i] += nLeftGeq[preIdx]; // pop()\\n\\n\\t\\t\\t\\t\\tpreIdx = preIdx - nLeftGeq[preIdx]; // peek() current top\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (preIdx >= 0 && heights[i] == heights[preIdx])\\n\\t\\t\\t\\t\\tnLeftGeq[i] += nLeftGeq[preIdx]; // pop()\\n\\t\\t\\t\\t// otherwise nothing to do\\n\\n\\t\\t\\t\\tpreIdx = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the rest largest rectangle areas with (indices of) bases\\n\\t\\t\\t// on stack\\n\\t\\t\\twhile (preIdx >= 0 && 0 < heights[preIdx]) {\\n\\t\\t\\t\\tres = Math.max(res, heights[preIdx] * (nLeftGeq[preIdx] + n - preIdx - 1));\\n\\t\\t\\t\\tpreIdx = preIdx - nLeftGeq[preIdx]; // peek() current top\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is to use \\u3010Leetcode#84\\u3011(see below comments). \\n\\nAs for \\u3010LC84\\u3011, there are many fast O(n)/O(n)-time/space methods such as using a stack. Mine is to use an array nLeftGeq[] to simulate the stack so that it is faster than the default implement of stack. \\nIndeed, nLeftGeq[i] = the number of elements to the left of [i] having value greater than or equal to a[i] (including a[i] itself). \\n\\nSince for j < i, with a[j]>a[i], we can compute the largest rectangle area with base a[j] then we throw away [j] or pop() it from the stack. \\n\\nTherefore, nLeftGeq[i] is also = the index difference between [i] and the next index on the top of the stack. And thus such as peek(), pop() methods can be implemented by manipulating the array nLeftGeq[].\\n\\nThis sub-algorithm for \\u3010LC84\\u3011is not the fastest one unfortunately, but still beats 95.45%.\\n\\n    public int maximalRectangle(char[][] matrix) {\\n\\t\\t\\t/**\\n\\t\\t\\t * idea: using [LC84 Largest Rectangle in Histogram]. For each row\\n\\t\\t\\t * of the matrix, construct the histogram based on the current row\\n\\t\\t\\t * and the previous histogram (up to the previous row), then compute\\n\\t\\t\\t * the largest rectangle area using LC84.\\n\\t\\t\\t */\\n\\t\\t\\tint m = matrix.length, n;\\n\\t\\t\\tif (m == 0 || (n = matrix[0].length) == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint i, j, res = 0;\\n\\t\\t\\tint[] heights = new int[n];\\n\\t\\t\\tfor (i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tif (matrix[i][j] == '0')\\n\\t\\t\\t\\t\\t\\theights[j] = 0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\theights[j] += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres = Math.max(res, largestRectangleArea(heights));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int largestRectangleArea(int[] heights) {\\n\\t\\t\\t/**\\n\\t\\t\\t * idea: scan and store if a[i-1]<=a[i] (increasing), then as long\\n\\t\\t\\t * as a[i]<a[i-1], then we can compute the largest rectangle area\\n\\t\\t\\t * with base a[j], for j<=i-1, and a[j]>a[i], which is a[j]*(i-j).\\n\\t\\t\\t * And meanwhile, all these bars (a[j]'s) are already done, and thus\\n\\t\\t\\t * are throwable (using pop() with a stack).\\n\\t\\t\\t * \\n\\t\\t\\t * We can use an array nLeftGeq[] of size n to simulate a stack.\\n\\t\\t\\t * nLeftGeq[i] = the number of elements to the left of [i] having\\n\\t\\t\\t * value greater than or equal to a[i] (including a[i] itself). It\\n\\t\\t\\t * is also the index difference between [i] and the next index on\\n\\t\\t\\t * the top of the stack.\\n\\t\\t\\t */\\n\\t\\t\\tint n = heights.length;\\n\\t\\t\\tif (n == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint[] nLeftGeq = new int[n]; // the number of elements to the left\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// of [i] with value >= heights[i]\\n\\t\\t\\tnLeftGeq[0] = 1;\\n\\n\\t\\t\\t// preIdx=the index of stack.peek(), res=max area so far\\n\\t\\t\\tint preIdx = 0, res = 0;\\n\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tnLeftGeq[i] = 1;\\n\\n\\t\\t\\t\\t// notice that preIdx = i - 1 = peek()\\n\\t\\t\\t\\twhile (preIdx >= 0 && heights[i] < heights[preIdx]) {\\n\\t\\t\\t\\t\\tres = Math.max(res, heights[preIdx] * (nLeftGeq[preIdx] + i - preIdx - 1));\\n\\t\\t\\t\\t\\tnLeftGeq[i] += nLeftGeq[preIdx]; // pop()\\n\\n\\t\\t\\t\\t\\tpreIdx = preIdx - nLeftGeq[preIdx]; // peek() current top\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (preIdx >= 0 && heights[i] == heights[preIdx])\\n\\t\\t\\t\\t\\tnLeftGeq[i] += nLeftGeq[preIdx]; // pop()\\n\\t\\t\\t\\t// otherwise nothing to do\\n\\n\\t\\t\\t\\tpreIdx = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the rest largest rectangle areas with (indices of) bases\\n\\t\\t\\t// on stack\\n\\t\\t\\twhile (preIdx >= 0 && 0 < heights[preIdx]) {\\n\\t\\t\\t\\tres = Math.max(res, heights[preIdx] * (nLeftGeq[preIdx] + n - preIdx - 1));\\n\\t\\t\\t\\tpreIdx = preIdx - nLeftGeq[preIdx]; // peek() current top\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 29124,
                "title": "c-clear-dp-method",
                "content": "Learn from @morrischen2008\\n\\n\\nclass Solution {\\n\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n\\n        int m = matrix.size();\\n        if (m == 0) return 0;\\n        int n = matrix[0].size();\\n        \\n        vector<int> height (n, 0);\\n        vector<int> left (n, 0);\\n        vector<int> right (n, n - 1);\\n        \\n        int maxA = INT_MIN;\\n        for (int i = 0 ; i < m; ++i){\\n            int current_left = 0;\\n            int current_right = n - 1;\\n            for (int j = 0; j < n; ++j){\\n                if (matrix[i][j] == '0'){\\n                    height[j] = 0;\\n                }else{\\n                    height[j]++;\\n                }\\n            }\\n            for (int j = 0; j < n; ++j){\\n                if (matrix[i][j] == '0'){\\n                    left[j] = 0; \\n                    current_left = j + 1;\\n                }else{\\n                    left[j] = max(left[j], current_left);\\n                }\\n            } \\n            for (int j = n - 1; j >= 0; --j){\\n                if (matrix[i][j] == '0'){\\n                    right[j] = n - 1; \\n                    current_right = j - 1;\\n                }else{\\n                    right[j] = min(right[j], current_right);\\n                }\\n            }\\n            for (int j = 0; j < n; ++j){\\n                if (maxA < (right[j] - left[j] + 1) * height[j]){\\n                    maxA = (right[j] - left[j] + 1) * height[j];\\n                }\\n            }\\n        }\\n        return maxA;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n\\n        int m = matrix.size();\\n        if (m == 0) return 0;\\n        int n = matrix[0].size();\\n        \\n        vector<int> height (n, 0);\\n        vector<int> left (n, 0);\\n        vector<int> right (n, n - 1);\\n        \\n        int maxA = INT_MIN;\\n        for (int i = 0 ; i < m; ++i){\\n            int current_left = 0;\\n            int current_right = n - 1;\\n            for (int j = 0; j < n; ++j){\\n                if (matrix[i][j] == '0'){\\n                    height[j] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29136,
                "title": "python-solution-using-maximum-histogram",
                "content": "First calculate the height for each row. Then convert this problem to finding the largest rectangle in histogram by computing the rectangle row by row and take the maximum.\\n\\n \\n    class Solution(object):\\n        def maximalRectangle(self, matrix):\\n            \"\"\"\\n            :type matrix: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if len(matrix) == 0: return 0\\n            for i in xrange(len(matrix)):\\n                for j in xrange(len(matrix[i])):\\n                    if i == 0: \\n                        matrix[i][j] = int(matrix[i][j])\\n                        continue\\n                    if matrix[i][j] == '1':\\n                        matrix[i][j] = matrix[i-1][j] + int(matrix[i][j])\\n                    else:\\n                        matrix[i][j] = 0\\n            return max([self.maxRectangle(row) for row in matrix])\\n            \\n        def maxRectangle(self, hist):\\n            stk = []\\n            maxx = 0\\n            hist.append(0)\\n            for i in xrange(len(hist)):\\n                while len(stk) > 0 and hist[i] < hist[stk[-1]]:\\n                    s = stk.pop()\\n                    if len(stk) == 0:\\n                        maxx = max(maxx, i*hist[s])\\n                    else:\\n                        maxx = max(maxx, (i - stk[-1] - 1)*hist[s])\\n                stk.append(i)\\n            return maxx",
                "solutionTags": [],
                "code": "First calculate the height for each row. Then convert this problem to finding the largest rectangle in histogram by computing the rectangle row by row and take the maximum.\\n\\n \\n    class Solution(object):\\n        def maximalRectangle(self, matrix):\\n            \"\"\"\\n            :type matrix: List[List[str]]\\n            :rtype: int\\n            \"\"\"\\n            if len(matrix) == 0: return 0\\n            for i in xrange(len(matrix)):\\n                for j in xrange(len(matrix[i])):\\n                    if i == 0: \\n                        matrix[i][j] = int(matrix[i][j])\\n                        continue\\n                    if matrix[i][j] == '1':\\n                        matrix[i][j] = matrix[i-1][j] + int(matrix[i][j])\\n                    else:\\n                        matrix[i][j] = 0\\n            return max([self.maxRectangle(row) for row in matrix])\\n            \\n        def maxRectangle(self, hist):\\n            stk = []\\n            maxx = 0\\n            hist.append(0)\\n            for i in xrange(len(hist)):\\n                while len(stk) > 0 and hist[i] < hist[stk[-1]]:\\n                    s = stk.pop()\\n                    if len(stk) == 0:\\n                        maxx = max(maxx, i*hist[s])\\n                    else:\\n                        maxx = max(maxx, (i - stk[-1] - 1)*hist[s])\\n                stk.append(i)\\n            return maxx",
                "codeTag": "Java"
            },
            {
                "id": 3544364,
                "title": "super-similar-problem-like-histogram",
                "content": "https://leetcode.com/problems/maximal-rectangle/discuss/3544364/Super-Similar-problem-like-Histogram-------------------------->Histogram problem\\n# Similar to Histogram Problem\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        maxarea=0\\n        height=[0]*(len(matrix[0]))\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==\"1\":\\n                    height[j]+=1\\n                else:\\n                    height[j]=0\\n\\t\\t\\t\\tstack=[]\\n            for i,h in enumerate(height):\\n                start=i\\n                while stack and h<stack[-1][1]:\\n                    index,hi=stack.pop()\\n                    start=index\\n                    maxarea=max(maxarea,(i-index)*hi)\\n                stack.append([start,h])\\n            for i,h in stack:\\n                maxarea=max(maxarea,(len(height)-i)*h)\\n        return maxarea\\n  ```\\n  # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        maxarea=0\\n        height=[0]*(len(matrix[0]))\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==\"1\":\\n                    height[j]+=1\\n                else:\\n                    height[j]=0\\n\\t\\t\\t\\tstack=[]\\n            for i,h in enumerate(height):\\n                start=i\\n                while stack and h<stack[-1][1]:\\n                    index,hi=stack.pop()\\n                    start=index\\n                    maxarea=max(maxarea,(i-index)*hi)\\n                stack.append([start,h])\\n            for i,h in stack:\\n                maxarea=max(maxarea,(len(height)-i)*h)\\n        return maxarea\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3010641,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    vector<int> nextsmall(vector<int>& arr,int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            int c=arr[i];\\n            while(s.top()!=-1&&arr[s.top()]>=c)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevsmall(vector<int>& arr,int n){\\n         stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            int c=arr[i];\\n            while(s.top()!=-1&&arr[s.top()]>=c)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n     int large(vector<int>& height,int n){\\n        int area=INT_MIN;\\n        \\n        vector<int> prev(n);\\n        vector<int> next(n);\\n        prev=prevsmall(height,n);\\n        next=nextsmall(height,n);\\n        for(int i=0;i<n;i++){\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int l=height[i];\\n            int b=next[i]-prev[i]-1;\\n            int newarea=l*b;\\n            area=max(area,newarea);\\n        }\\n        return area;\\n    }\\npublic:\\n   int maximalRectangle(vector<vector<char> > &matrix) {\\n    if(matrix.empty()){\\n        return 0;\\n    }\\n    int maxRec = 0;\\n    vector<int> height(matrix[0].size(), 0);\\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(matrix[i][j] == \\'0\\'){\\n                height[j] = 0;\\n            }\\n            else{\\n                height[j]++;\\n            }\\n        }\\n        maxRec = max(maxRec, large(height,matrix[0].size()));\\n    }\\n    return maxRec;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> nextsmall(vector<int>& arr,int n){\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            int c=arr[i];\\n            while(s.top()!=-1&&arr[s.top()]>=c)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevsmall(vector<int>& arr,int n){\\n         stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            int c=arr[i];\\n            while(s.top()!=-1&&arr[s.top()]>=c)\\n            {\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n     int large(vector<int>& height,int n){\\n        int area=INT_MIN;\\n        \\n        vector<int> prev(n);\\n        vector<int> next(n);\\n        prev=prevsmall(height,n);\\n        next=nextsmall(height,n);\\n        for(int i=0;i<n;i++){\\n            if(next[i]==-1){\\n                next[i]=n;\\n            }\\n            int l=height[i];\\n            int b=next[i]-prev[i]-1;\\n            int newarea=l*b;\\n            area=max(area,newarea);\\n        }\\n        return area;\\n    }\\npublic:\\n   int maximalRectangle(vector<vector<char> > &matrix) {\\n    if(matrix.empty()){\\n        return 0;\\n    }\\n    int maxRec = 0;\\n    vector<int> height(matrix[0].size(), 0);\\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(matrix[i][j] == \\'0\\'){\\n                height[j] = 0;\\n            }\\n            else{\\n                height[j]++;\\n            }\\n        }\\n        maxRec = max(maxRec, large(height,matrix[0].size()));\\n    }\\n    return maxRec;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630546,
                "title": "maximal-rectangle-most-clean-code",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int row = matrix.length;\\n        int column = matrix[0].length;\\n        \\n        if (matrix == null || row == 0) return 0;\\n        \\n        int maxArea = Integer.MIN_VALUE;\\n        \\n        int []arr = new int[column];\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < column; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    arr[j] = arr[j] + 1;\\n                } else {\\n                    arr[j] = 0;\\n                }\\n            }\\n            int currArea = getMaxArea(arr, column);\\n            maxArea = Math.max(maxArea, currArea);\\n        }\\n        return maxArea;\\n    }\\n    \\n    public int getMaxArea(int []arr, int len) {\\n        \\n        int pse[] = getPreviousSmall(arr, len);\\n        int nse[] = getNextSmall(arr, len);\\n        \\n        int maxArea = Integer.MIN_VALUE;\\n        \\n        for (int k = 0; k < len; k++) {\\n            int currArea = (nse[k] - pse[k] - 1) * arr[k];\\n            maxArea = Math.max(maxArea, currArea);\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public int[] getPreviousSmall(int []arr, int len) {\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(0);\\n        \\n        int pse[] = new int[len];\\n        pse[0] = -1;\\n        \\n        for (int i = 1; i < len; i++) {\\n            while(!s.isEmpty() && arr[s.peek()] >= arr[i]) {\\n                s.pop();\\n            }\\n            \\n            if (s.isEmpty()) {\\n                pse[i] = -1;\\n            } else {\\n                pse[i] = s.peek();\\n            }\\n            s.push(i);\\n        }\\n        return pse;\\n    }\\n    \\n    public int[] getNextSmall(int []arr, int len) {\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(len - 1);\\n        \\n        int nse[] = new int[len];\\n        nse[len - 1] = len;\\n        \\n        for (int j = len - 2; j >= 0; j--) {\\n            while(!s.isEmpty() && arr[s.peek()] >= arr[j]) {\\n                s.pop();\\n            }\\n            \\n            if (s.isEmpty()) {\\n                nse[j] = len;\\n            } else {\\n                nse[j] = s.peek();\\n            }\\n            s.push(j);\\n        }\\n        return nse;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int row = matrix.length;\\n        int column = matrix[0].length;\\n        \\n        if (matrix == null || row == 0) return 0;\\n        \\n        int maxArea = Integer.MIN_VALUE;\\n        \\n        int []arr = new int[column];\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < column; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    arr[j] = arr[j] + 1;\\n                } else {\\n                    arr[j] = 0;\\n                }\\n            }\\n            int currArea = getMaxArea(arr, column);\\n            maxArea = Math.max(maxArea, currArea);\\n        }\\n        return maxArea;\\n    }\\n    \\n    public int getMaxArea(int []arr, int len) {\\n        \\n        int pse[] = getPreviousSmall(arr, len);\\n        int nse[] = getNextSmall(arr, len);\\n        \\n        int maxArea = Integer.MIN_VALUE;\\n        \\n        for (int k = 0; k < len; k++) {\\n            int currArea = (nse[k] - pse[k] - 1) * arr[k];\\n            maxArea = Math.max(maxArea, currArea);\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public int[] getPreviousSmall(int []arr, int len) {\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(0);\\n        \\n        int pse[] = new int[len];\\n        pse[0] = -1;\\n        \\n        for (int i = 1; i < len; i++) {\\n            while(!s.isEmpty() && arr[s.peek()] >= arr[i]) {\\n                s.pop();\\n            }\\n            \\n            if (s.isEmpty()) {\\n                pse[i] = -1;\\n            } else {\\n                pse[i] = s.peek();\\n            }\\n            s.push(i);\\n        }\\n        return pse;\\n    }\\n    \\n    public int[] getNextSmall(int []arr, int len) {\\n        \\n        Stack<Integer> s = new Stack<>();\\n        s.push(len - 1);\\n        \\n        int nse[] = new int[len];\\n        nse[len - 1] = len;\\n        \\n        for (int j = len - 2; j >= 0; j--) {\\n            while(!s.isEmpty() && arr[s.peek()] >= arr[j]) {\\n                s.pop();\\n            }\\n            \\n            if (s.isEmpty()) {\\n                nse[j] = len;\\n            } else {\\n                nse[j] = s.peek();\\n            }\\n            s.push(j);\\n        }\\n        return nse;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477654,
                "title": "c-recursion-dp-tle-68-test-cases-passed-out-of-73",
                "content": "If someone is looking for recursive approach here it is. It will run fine for smaller teset cases but give TLE for large ones.\\nT.C=O(N^4)\\nS.C=O(N^4)+O(N^4)\\nclass Solution {\\npublic:\\n\\n    int maxarea=0;\\n    int check(vector<vector<char>>& matrix,int i,int j,int s,int e){   \\n         for(int k=i;k<=s;k++){\\n            for(int l=j;l<=e;l++){\\n                if(matrix[k][l]==\\'1\\')continue;\\n                else return false;\\n                    \\n                }\\n            }\\n          return true;\\n        }\\n  \\n    \\n    void dp(vector<vector<char>>& matrix,   vector<vector<vector<vector<int>>>>&dps,int i,int j,int s,int e){\\n         int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(i>m || j>n || i<0 || j<0 )return ;\\n        if(s>m || e>n || s<0 || e<0 )return ;\\n        if(i>s || j>e)return ;\\n        if(dps[i][j][s][e]!=-1)return;\\n                 int temp=(s-i+1)*(e-j+1);\\n                  dps[i][j][s][e]=temp;\\n                if(check(matrix,i,j,s,e)){\\n                              \\n                    //cout<<temp<<endl;\\n                    maxarea=max(maxarea,temp);\\n                    dps[i][j][s][e]=maxarea;\\n                    \\n                }\\n                dp(matrix,dps,i,j+1,s,e);\\n                dp(matrix,dps,i+1,j,s,e);\\n                dp(matrix,dps,i,j,s-1,e);\\n                dp(matrix,dps,i,j,s,e-1);           \\n\\n        \\n        \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n       vector<vector<vector<vector<int>>>> dps(m, vector<vector<vector<int>>>\\n                                           (n, vector<vector<int>>\\n                                           (m, vector<int>\\n                                           (n,-1))));\\n      \\n        \\n        //cout<<check(matrix,1,2,2,4)<<endl;\\n     dp(matrix,dps,0,0,m-1,n-1);\\n        return maxarea;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxarea=0;\\n    int check(vector<vector<char>>& matrix,int i,int j,int s,int e){   \\n         for(int k=i;k<=s;k++){\\n            for(int l=j;l<=e;l++){\\n                if(matrix[k][l]==\\'1\\')continue;\\n                else return false;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2402447,
                "title": "java-solution-monotonic-stack-based-on-largest-area-in-histogram",
                "content": "This solution uses the code of the problem  \\'maximum area in histogram\\'.\\nThis solution is also classified as DP solution because height array uses the history of itself to update itself.\\nIf you like the solution, then please UPVOTE :)\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] height = new int[n];\\n        int maxA = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(matrix[i][j] == \\'1\\')   height[j] = height[j]+1;\\n                else    height[j] = 0;\\n            }\\n            maxA = Math.max(maxA , maxAreaHisto(height , n));\\n        }\\n        return maxA;\\n    }\\n    \\n    public int maxAreaHisto(int[] height , int n){\\n        Stack<Integer> st = new Stack<>();\\n        int maxA = 0;\\n        for(int i = 0 ; i <= n ; i++){\\n            while(!st.isEmpty() && (i == n || height[st.peek()] >= height[i])){\\n                int ht = height[st.peek()];\\n                st.pop();\\n                int width;\\n                if(st.isEmpty())    width = i;\\n                else    width = i-st.peek()-1;\\n                maxA = Math.max(maxA , ht*width);\\n            }\\n            st.push(i);\\n        }\\n        return maxA;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] height = new int[n];\\n        int maxA = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(matrix[i][j] == \\'1\\')   height[j] = height[j]+1;\\n                else    height[j] = 0;\\n            }\\n            maxA = Math.max(maxA , maxAreaHisto(height , n));\\n        }\\n        return maxA;\\n    }\\n    \\n    public int maxAreaHisto(int[] height , int n){\\n        Stack<Integer> st = new Stack<>();\\n        int maxA = 0;\\n        for(int i = 0 ; i <= n ; i++){\\n            while(!st.isEmpty() && (i == n || height[st.peek()] >= height[i])){\\n                int ht = height[st.peek()];\\n                st.pop();\\n                int width;\\n                if(st.isEmpty())    width = i;\\n                else    width = i-st.peek()-1;\\n                maxA = Math.max(maxA , ht*width);\\n            }\\n            st.push(i);\\n        }\\n        return maxA;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130637,
                "title": "c-easy-brute-force",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void presum(vector<vector<int>> &mat){\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> mat(n, vector<int>(m, 0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==\\'0\\')   mat[i][j] = 0;\\n                else    mat[i][j] = 1;\\n            }\\n        }\\n        presum(mat);\\n        \\n        \\n        int ans = 0;\\n        \\n            for(int c1 = 0;c1<m;c1++){\\n        for(int c2 = c1;c2<m;c2++){\\n                int sum = 0;\\n                for(int i=0;i<n;i++){\\n                    \\n                    int temp = mat[i][c2];\\n                    if(c1>0)    temp-=mat[i][c1-1];\\n                    if(temp==(c2-c1+1)){\\n                        sum+=temp;\\n                        ans = max(ans, sum);\\n                    }\\n                    else    sum = 0;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    void presum(vector<vector<int>> &mat){\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1603362,
                "title": "python3",
                "content": "class Solution:\\n\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        ROW,COL=len(matrix),len(matrix[0])\\n        dph=[[0]*COL for _ in range(1+ROW)]\\n        dpl=[[0]*COL for _ in range(1+ROW)]\\n        dpr=[[COL-1]*COL for _ in range(1+ROW)]\\n        for i in range(1,1+ROW):\\n            lb,ub=0,COL-1\\n            for j in range(COL):\\n                if matrix[i-1][j]==\"1\":\\n                    dph[i][j]=1+dph[i-1][j]\\n                    dpl[i][j]=max(lb,dpl[i-1][j])\\n                else:\\n                    lb=j+1\\n            for j in reversed(range(COL)):\\n                if matrix[i-1][j]==\"1\":\\n                    dpr[i][j]=min(ub,dpr[i-1][j])\\n                else:\\n                    ub=j-1\\n        maxArea=0             \\n        for i in range(1,1+ROW):\\n            for j in range(COL):\\n                maxArea=max(maxArea,(dpr[i][j]-dpl[i][j]+1)*dph[i][j])\\n        return maxArea",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix:\\n            return 0\\n        ROW,COL=len(matrix),len(matrix[0])\\n        dph=[[0]*COL for _ in range(1+ROW)]\\n        dpl=[[0]*COL for _ in range(1+ROW)]\\n        dpr=[[COL-1]*COL for _ in range(1+ROW)]\\n        for i in range(1,1+ROW):\\n            lb,ub=0,COL-1\\n            for j in range(COL):\\n                if matrix[i-1][j]==\"1\":\\n                    dph[i][j]=1+dph[i-1][j]\\n                    dpl[i][j]=max(lb,dpl[i-1][j])\\n                else:\\n                    lb=j+1\\n            for j in reversed(range(COL)):\\n                if matrix[i-1][j]==\"1\":\\n                    dpr[i][j]=min(ub,dpr[i-1][j])\\n                else:\\n                    ub=j-1\\n        maxArea=0             \\n        for i in range(1,1+ROW):\\n            for j in range(COL):\\n                maxArea=max(maxArea,(dpr[i][j]-dpl[i][j]+1)*dph[i][j])\\n        return maxArea",
                "codeTag": "Java"
            },
            {
                "id": 1383459,
                "title": "c-solution-too-easy",
                "content": "Application of problem - https://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nApproach - we need to make histogram of each row and calculate maximum area from that histogram. Ans will be maximum of all rows.\\nTo make histogram of each row.\\nIf element =0 then height of histogram =0\\nelse height of histogram = Current element height of histogram of previous row  + 1\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n         if(matrix.size()==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<int> heights(matrix[0].size(),0);\\n        int maxm=0;\\n       \\n        for(int k=0;k<matrix.size();k++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[k][j]==\\'0\\')\\n                {\\n                    heights[j]=0;\\n                }\\n                else\\n                {\\n                    heights[j]+=1;\\n                }\\n            }\\n            // Approach to find maximum area of histogram link - https://leetcode.com/problems/largest-rectangle-in-histogram/\\n            vector<int> rb(heights.size(),heights.size());\\n        vector<int> lb(heights.size(),-1);\\n        stack<int> s;\\n        s.push(0);\\n        lb[0]=-1;\\n        for(int i=1;i<heights.size();i++)\\n        {\\n            while(!s.empty() && heights[s.top()]>=heights[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                lb[i]=-1;\\n            }\\n            else\\n            {\\n                lb[i]=s.top();\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty())\\n        {\\n            s.pop();\\n        }\\n        s.push(heights.size()-1);\\n        for(int i=heights.size()-2;i>=0;i--)\\n        {\\n            while(!s.empty() && heights[s.top()]>=heights[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                rb[i]=heights.size();\\n            }\\n            else\\n            {\\n                rb[i]=s.top();\\n            }\\n            s.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<heights.size();i++)\\n        {\\n            ans=max(ans,(rb[i]-lb[i]-1)*heights[i]);\\n        }\\n        maxm=max(ans,maxm);\\n        \\n        }\\n        return maxm;\\n        \\n    }\\n};\\n```\\n\\nIt would be great if you upvote.",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n         if(matrix.size()==0)\\n        {\\n            return 0;\\n        }\\n        \\n        vector<int> heights(matrix[0].size(),0);\\n        int maxm=0;\\n       \\n        for(int k=0;k<matrix.size();k++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[k][j]==\\'0\\')\\n                {\\n                    heights[j]=0;\\n                }\\n                else\\n                {\\n                    heights[j]+=1;\\n                }\\n            }\\n            // Approach to find maximum area of histogram link - https://leetcode.com/problems/largest-rectangle-in-histogram/\\n            vector<int> rb(heights.size(),heights.size());\\n        vector<int> lb(heights.size(),-1);\\n        stack<int> s;\\n        s.push(0);\\n        lb[0]=-1;\\n        for(int i=1;i<heights.size();i++)\\n        {\\n            while(!s.empty() && heights[s.top()]>=heights[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                lb[i]=-1;\\n            }\\n            else\\n            {\\n                lb[i]=s.top();\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty())\\n        {\\n            s.pop();\\n        }\\n        s.push(heights.size()-1);\\n        for(int i=heights.size()-2;i>=0;i--)\\n        {\\n            while(!s.empty() && heights[s.top()]>=heights[i])\\n            {\\n                s.pop();\\n            }\\n            if(s.empty())\\n            {\\n                rb[i]=heights.size();\\n            }\\n            else\\n            {\\n                rb[i]=s.top();\\n            }\\n            s.push(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<heights.size();i++)\\n        {\\n            ans=max(ans,(rb[i]-lb[i]-1)*heights[i]);\\n        }\\n        maxm=max(ans,maxm);\\n        \\n        }\\n        return maxm;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353800,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        if len(matrix) == 0: return 0\\n        matrix, rows, cols=[map(int, i) for i in matrix], len(matrix), len(matrix[0])\\n        max_area, dp = float(\"-inf\"), [[0 for __ in range(cols+1)] for _ in range(rows+1)]\\n        for i in range(0, rows):\\n            for j in range(cols):\\n                dp[i][j]=matrix[i][j] if i==0 else matrix[i][j]+dp[i-matrix[i][j]][j]\\n        for i in range(rows):\\n            for j in range(cols):\\n                current_height = dp[i][j]\\n                for k in range(j, cols):\\n                    current_height = min(current_height, dp[i][k])\\n                    max_area = max(max_area, current_height * (k-j+1))\\n        return max_area\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximalRectangle(self, matrix):\\n        if len(matrix) == 0: return 0\\n        matrix, rows, cols=[map(int, i) for i in matrix], len(matrix), len(matrix[0])\\n        max_area, dp = float(\"-inf\"), [[0 for __ in range(cols+1)] for _ in range(rows+1)]\\n        for i in range(0, rows):\\n            for j in range(cols):\\n                dp[i][j]=matrix[i][j] if i==0 else matrix[i][j]+dp[i-matrix[i][j]][j]\\n        for i in range(rows):\\n            for j in range(cols):\\n                current_height = dp[i][j]\\n                for k in range(j, cols):\\n                    current_height = min(current_height, dp[i][k])\\n                    max_area = max(max_area, current_height * (k-j+1))\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351032,
                "title": "c-using-max-rectangle-in-histogram-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {int n=0;\\n        int m=matrix.size();\\n        if(m!=0)\\n         n=matrix[0].size();\\n        int res=0;\\n        if(m==0) return 0;\\n        vector<int> v(n,0);\\n        for(int i=0;i<m;++i){\\n           for(int j=0;j<n;++j){ \\n               if(matrix[i][j]==\\'0\\') v[j]=0;\\n               else{\\n                   v[j]+= (matrix[i][j]-\\'0\\');\\n                   }\\n           }\\n              int tmp=maxInRow(v,n);\\n               res=max(res,tmp);\\n            \\n        }\\n        return res;\\n    }\\n    int maxInRow(vector<int> v,int n){\\n     \\n        int res=0;\\n        v.push_back(0);\\n        stack<int> st;\\n        \\n        int i=0;\\n        while(i<n+1){\\n            if(st.empty()|| v[i]>= v[st.top()]) st.push(i++);\\n            else{\\n                int index=st.top();\\n                st.pop();\\n                if(st.empty()) res=max(res, i*v[index]);\\n                else{\\n                    res=max(res,v[index]*(i-st.top()-1));\\n                }                \\n            }     \\n        } \\n       return res;     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {int n=0;\\n        int m=matrix.size();\\n        if(m!=0)\\n         n=matrix[0].size();\\n        int res=0;\\n        if(m==0) return 0;\\n        vector<int> v(n,0);\\n        for(int i=0;i<m;++i){\\n           for(int j=0;j<n;++j){ \\n               if(matrix[i][j]==\\'0\\') v[j]=0;\\n               else{\\n                   v[j]+= (matrix[i][j]-\\'0\\');\\n                   }\\n           }\\n              int tmp=maxInRow(v,n);\\n               res=max(res,tmp);\\n            \\n        }\\n        return res;\\n    }\\n    int maxInRow(vector<int> v,int n){\\n     \\n        int res=0;\\n        v.push_back(0);\\n        stack<int> st;\\n        \\n        int i=0;\\n        while(i<n+1){\\n            if(st.empty()|| v[i]>= v[st.top()]) st.push(i++);\\n            else{\\n                int index=st.top();\\n                st.pop();\\n                if(st.empty()) res=max(res, i*v[index]);\\n                else{\\n                    res=max(res,v[index]*(i-st.top()-1));\\n                }                \\n            }     \\n        } \\n       return res;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218156,
                "title": "c-stack-solution-based-on-largest-area-in-histogram",
                "content": "```\\nclass Solution {\\npublic:\\n    int mah(vector<int>& heights) {\\n    int n= heights.size();\\n    vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);\\n    }\\n    return m;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n         if(matrix.size()==0)\\n             return 0;\\n          vector<int>v;\\n          for(int i=0;i<matrix[0].size();i++)\\n              v.push_back(matrix[0][i]-\\'0\\');\\n          int mx=mah(v);\\n          for(int i=1;i<matrix.size();i++)\\n          {\\n              for(int j=0;j<matrix[0].size();j++)\\n              {\\n                  if(matrix[i][j]==\\'0\\')\\n                      v[j]=0;\\n                  else\\n                      v[j]=v[j]+1;\\n              }\\n              mx=max(mx,mah(v));\\n          }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mah(vector<int>& heights) {\\n    int n= heights.size();\\n    vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);\\n    }\\n    return m;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n         if(matrix.size()==0)\\n             return 0;\\n          vector<int>v;\\n          for(int i=0;i<matrix[0].size();i++)\\n              v.push_back(matrix[0][i]-\\'0\\');\\n          int mx=mah(v);\\n          for(int i=1;i<matrix.size();i++)\\n          {\\n              for(int j=0;j<matrix[0].size();j++)\\n              {\\n                  if(matrix[i][j]==\\'0\\')\\n                      v[j]=0;\\n                  else\\n                      v[j]=v[j]+1;\\n              }\\n              mx=max(mx,mah(v));\\n          }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024094,
                "title": "python-solution",
                "content": "This is a 2D version of 84. Largest Rectangle in Histogram. For each `row` of `matrix`, and for each index `i` of the `row`, we can find the histogram\\'s bar height at `row[i]`, and find the area of the largest rectangle in the histogram. We have one such largest rectangle per `row`, and when taking the maximum of all such rectangles over the rows, we get the largest rectangle containing only `1`s in the matrix.\\n\\nTime complexity: O(mn), space complexity: O(mn).\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0:\\n            return 0\\n        n = len(matrix[0])\\n        if n == 0:\\n            return 0\\n        \\n        rec = [[0] * n for _ in range(m)]\\n        for i in range(n):\\n            if matrix[0][i] == \\'1\\':\\n                rec[0][i] = 1\\n                \\n        max_area = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0 and matrix[i][j] != \\'0\\':\\n                    rec[i][j] = rec[i - 1][j] + 1\\n            \\n            stack = []\\n            heights = rec[i]\\n            for k, h in enumerate(heights):\\n                if not stack or stack[-1][1] < h:\\n                    stack.append((k, h))\\n                else:\\n                    while stack and stack[-1][1] >= h:\\n                        l, p = stack.pop()\\n                        max_area = max(max_area, (k - l) * p)\\n                    stack.append((l, h))\\n            while stack:\\n                l, p = stack.pop()\\n                max_area = max(max_area, (n - l) * p)  \\n                \\n        return max_area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0:\\n            return 0\\n        n = len(matrix[0])\\n        if n == 0:\\n            return 0\\n        \\n        rec = [[0] * n for _ in range(m)]\\n        for i in range(n):\\n            if matrix[0][i] == \\'1\\':\\n                rec[0][i] = 1\\n                \\n        max_area = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0 and matrix[i][j] != \\'0\\':\\n                    rec[i][j] = rec[i - 1][j] + 1\\n            \\n            stack = []\\n            heights = rec[i]\\n            for k, h in enumerate(heights):\\n                if not stack or stack[-1][1] < h:\\n                    stack.append((k, h))\\n                else:\\n                    while stack and stack[-1][1] >= h:\\n                        l, p = stack.pop()\\n                        max_area = max(max_area, (k - l) * p)\\n                    stack.append((l, h))\\n            while stack:\\n                l, p = stack.pop()\\n                max_area = max(max_area, (n - l) * p)  \\n                \\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937427,
                "title": "clean-code-using-stack",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        int output[] = new int[matrix[0].length];\\n        int max = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++)\\n                output[j] = matrix[i][j] == \\'0\\' ? 0 : output[j]+1;\\n            max = Math.max(max, Histogram(output));\\n        }\\n        return max;\\n\\t}\\n\\n    static int Histogram(int output[]){\\n        int left[] = findLeft(output);\\n\\t\\tint right[] = findRight(output);\\n\\t\\tint width[] = findWidth(left, right);\\n\\t\\tint area[] = findArea(output, width);\\n\\t\\tint maxArea = findMax(area);\\n        return maxArea;\\n    }\\n\\n\\tstatic int[] findLeft(int arr[]){\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tstack.push(0);\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\ttemp[0] = -1;\\n\\t\\tfor(int i = 1; i < arr.length; i++){\\n\\t\\t\\tif(stack.size() == 0) temp[i] = -1;\\n\\t\\t\\telse if(stack.size() > 0 && arr[stack.peek()] >= arr[i]){\\n\\t\\t\\t\\twhile(stack.size() > 0 && arr[stack.peek()] >= arr[i]) stack.pop();\\n                temp[i] = stack.size() == 0 ? -1 : stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\telse temp[i] = stack.peek();\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findRight(int arr[]){\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tstack.push(arr.length - 1);\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\ttemp[arr.length - 1] = arr.length;\\n\\t\\tfor(int i = arr.length - 1; i >= 0; i--){\\n\\t\\t\\tif(stack.size() == 0) temp[i] = arr.length;\\n\\t\\t\\telse if(stack.size() > 0 && arr[stack.peek()] >= arr[i]){\\n\\t\\t\\t\\twhile(stack.size() > 0 && arr[stack.peek()] >= arr[i]) stack.pop();\\n                temp[i] = stack.size() == 0 ? arr.length : stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\telse temp[i] = stack.peek();\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\tCollections.reverse(Arrays.asList(temp));\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findWidth(int left[], int right[]){\\n\\t\\tint temp[] = new int[left.length];\\n\\t\\tfor(int i = 0; i < left.length; i++)\\n\\t\\t\\ttemp[i] = right[i] - left[i] - 1;\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findArea(int arr[], int width[]){\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\tfor(int i = 0; i < arr.length; i++)\\n\\t\\t\\ttemp[i] = arr[i] * width[i];\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int findMax(int area[]){\\n\\t\\tint max = 0;\\n\\t\\tfor(int i = 0; i < area.length; i++)\\n            max = Math.max(max, area[i]);\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        int output[] = new int[matrix[0].length];\\n        int max = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++)\\n                output[j] = matrix[i][j] == \\'0\\' ? 0 : output[j]+1;\\n            max = Math.max(max, Histogram(output));\\n        }\\n        return max;\\n\\t}\\n\\n    static int Histogram(int output[]){\\n        int left[] = findLeft(output);\\n\\t\\tint right[] = findRight(output);\\n\\t\\tint width[] = findWidth(left, right);\\n\\t\\tint area[] = findArea(output, width);\\n\\t\\tint maxArea = findMax(area);\\n        return maxArea;\\n    }\\n\\n\\tstatic int[] findLeft(int arr[]){\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tstack.push(0);\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\ttemp[0] = -1;\\n\\t\\tfor(int i = 1; i < arr.length; i++){\\n\\t\\t\\tif(stack.size() == 0) temp[i] = -1;\\n\\t\\t\\telse if(stack.size() > 0 && arr[stack.peek()] >= arr[i]){\\n\\t\\t\\t\\twhile(stack.size() > 0 && arr[stack.peek()] >= arr[i]) stack.pop();\\n                temp[i] = stack.size() == 0 ? -1 : stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\telse temp[i] = stack.peek();\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findRight(int arr[]){\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tstack.push(arr.length - 1);\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\ttemp[arr.length - 1] = arr.length;\\n\\t\\tfor(int i = arr.length - 1; i >= 0; i--){\\n\\t\\t\\tif(stack.size() == 0) temp[i] = arr.length;\\n\\t\\t\\telse if(stack.size() > 0 && arr[stack.peek()] >= arr[i]){\\n\\t\\t\\t\\twhile(stack.size() > 0 && arr[stack.peek()] >= arr[i]) stack.pop();\\n                temp[i] = stack.size() == 0 ? arr.length : stack.peek();\\n\\t\\t\\t}\\n\\t\\t\\telse temp[i] = stack.peek();\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\tCollections.reverse(Arrays.asList(temp));\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findWidth(int left[], int right[]){\\n\\t\\tint temp[] = new int[left.length];\\n\\t\\tfor(int i = 0; i < left.length; i++)\\n\\t\\t\\ttemp[i] = right[i] - left[i] - 1;\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int[] findArea(int arr[], int width[]){\\n\\t\\tint temp[] = new int[arr.length];\\n\\t\\tfor(int i = 0; i < arr.length; i++)\\n\\t\\t\\ttemp[i] = arr[i] * width[i];\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tstatic int findMax(int area[]){\\n\\t\\tint max = 0;\\n\\t\\tfor(int i = 0; i < area.length; i++)\\n            max = Math.max(max, area[i]);\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824064,
                "title": "java-short-dp-solution",
                "content": "```\\nprivate static int findRectangleArea2Ds(char[][] matrix) {\\n\\t\\tif (matrix == null || matrix.length == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint maxArea = 0;\\n\\t\\tint rows = matrix.length;\\n\\t\\tint cols = matrix[0].length;\\n\\t\\tint[][] dp = new int[rows][cols];\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\tdp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1;\\n\\t\\t\\t\\t\\tint length = dp[i][j];\\n\\n\\t\\t\\t\\t\\tfor (int k = i; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tlength = Math.min(length, dp[k][j]);\\n\\t\\t\\t\\t\\t\\tint width = i - k + 1;\\n\\t\\t\\t\\t\\t\\tmaxArea = Math.max(maxArea, length * width);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxArea;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate static int findRectangleArea2Ds(char[][] matrix) {\\n\\t\\tif (matrix == null || matrix.length == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint maxArea = 0;\\n\\t\\tint rows = matrix.length;\\n\\t\\tint cols = matrix[0].length;\\n\\t\\tint[][] dp = new int[rows][cols];\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\tdp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1;\\n\\t\\t\\t\\t\\tint length = dp[i][j];\\n\\n\\t\\t\\t\\t\\tfor (int k = i; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tlength = Math.min(length, dp[k][j]);\\n\\t\\t\\t\\t\\t\\tint width = i - k + 1;\\n\\t\\t\\t\\t\\t\\tmaxArea = Math.max(maxArea, length * width);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxArea;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 771664,
                "title": "javascript-dp",
                "content": "```\\nvar maximalRectangle = function (matrix) {\\n  if (matrix.length <= 0) return 0;\\n  const n = matrix.length;\\n  const m = matrix[0].length;\\n  const dp = new Array(n).fill([]).map(() => new Array(m).fill(0))\\n  let maxArea = 0;\\n  for (let r = 0; r < n; r++) {\\n    for (let c = 0; c < m; c++) {\\n      if (matrix[r][c] == 0) continue;\\n      dp[r][c] += dp[r - 1] ? dp[r - 1][c] + 1 : 1;\\n      let min = dp[r][c];\\n      for (let k = c; k >= 0; k--) {\\n        if (dp[r][k] == 0) break;\\n        min = dp[r][k] < min ? dp[r][k] : min;\\n        maxArea = Math.max(maxArea, min * (c - k + 1))\\n      }\\n    }\\n  }\\n  return maxArea;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maximalRectangle = function (matrix) {\\n  if (matrix.length <= 0) return 0;\\n  const n = matrix.length;\\n  const m = matrix[0].length;\\n  const dp = new Array(n).fill([]).map(() => new Array(m).fill(0))\\n  let maxArea = 0;\\n  for (let r = 0; r < n; r++) {\\n    for (let c = 0; c < m; c++) {\\n      if (matrix[r][c] == 0) continue;\\n      dp[r][c] += dp[r - 1] ? dp[r - 1][c] + 1 : 1;\\n      let min = dp[r][c];\\n      for (let k = c; k >= 0; k--) {\\n        if (dp[r][k] == 0) break;\\n        min = dp[r][k] < min ? dp[r][k] : min;\\n        maxArea = Math.max(maxArea, min * (c - k + 1))\\n      }\\n    }\\n  }\\n  return maxArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764461,
                "title": "c-dp",
                "content": "Dynamic Programming:\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if (matrix.size() == 0) return 0;\\n            int maxarea = 0;\\n            vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if (matrix[i][j] == \\'1\\'){\\n\\n                        // compute the maximum width and update dp with it\\n                        dp[i][j] = j == 0? 1 : dp[i][j-1] + 1;\\n\\n                        int width = dp[i][j];\\n\\n                        // compute the maximum area rectangle with a lower right corner at [i, j]\\n                        for(int k = i; k >= 0; k--){\\n                            width = min(width, dp[k][j]);\\n                            maxarea = max(maxarea, width * (i - k + 1));\\n                        }\\n                    }\\n                }\\n            } \\n\\t\\t\\treturn maxarea;\\n        }\\n};\\n```\\n\\nmethod 2: using histogram (stack)\\nThis method uses [approach 5 in LeetCode 84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/solution/)\\n```\\nclass Solution {\\npublic:\\n    \\n/*\\n\\norg:         \\n\\n       c0 c1 c2 c3\\nrow      \\n  0     1  0  1  0\\n  1     1  0  1  1\\n  2     1  1  1  1 \\n  3     1  0  0  1\\n   \\n   \\nstep 1: calculate hist upon rows:\\n   \\n        c0 c1 c2 c3\\nrow\\n  0     1  0  1  0\\n  1     2  0  2  1\\n  2     3  1  3  2\\n  3     4  0  0  3\\n\\n\\nstep 2: calculate max rectangle of hist upon each row:\\n\\nrow\\n  0     1\\n  1     2\\n  2     4\\n  3     4\\n    \\nstep 3: return max area (4).\\n   \\n   \\n*/\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n_rows = matrix.size();\\n        \\n        if (n_rows == 0)\\n            return 0;\\n        \\n        int n_cols = matrix[0].size();\\n        \\n        vector<int> hist(n_cols, 0);\\n        \\n        int max_area = 0;\\n        \\n        for (int r = 0; r < n_rows; r++) {\\n            \\n            // update the state of this row\\'s histogram using the last row\\'s histogram\\n            // by keeping track of the number of consecutive ones\\n            for (int c= 0; c < n_cols; c++) {\\n                if (matrix[r][c] == \\'1\\')\\n                    hist[c] += 1;\\n                else\\n                    hist[c] = 0;\\n            }\\n            \\n            \\n            // update maxarea with the maximum area from this row\\'s histogram\\n            int area = largest_rectangle_hist(hist);\\n            \\n            max_area = max(max_area, area);\\n        }\\n        \\n        return max_area;\\n    }\\n    \\n    \\n    /*\\n                     #\\n            #     #  #\\n            #     #  #\\n            #  #  #  #\\n    index   0  1  2  3\\n    \\n\\n                     #\\n            .     #  #\\n            .     #  #\\n            .  #  #  #\\n    index   0  1  2  3\\n    \\n    \\n                     .\\n            .     .  .\\n            .     .  .\\n            .  #  .  .\\n    index   0  1  2  3\\n    \\n    \\n    */\\n    int largest_rectangle_hist(vector<int> hist) {\\n        int max_area = 0;\\n        \\n        stack<int> st;\\n        \\n        hist.insert(hist.begin(), 0);\\n        hist.insert(hist.end(), 0);\\n        \\n        for (int i = 0; i < hist.size(); i++) {\\n            while(!st.empty() && hist[st.top()] > hist[i]) {\\n                int h = hist[st.top()];\\n                st.pop();\\n                \\n                int w = (i - st.top() - 1);\\n                \\n                max_area = max(max_area, h * w);\\n            }  \\n            \\n            st.push(i);\\n        }\\n\\n        return max_area;\\n    }\\n};\\n```\\n\\ndp with maximum height at each point\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size() == 0) return 0;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        vector<int> left(n); // initialize left as the leftmost boundary possible\\n        vector<int> right(n, n);// initialize right as the rightmost boundary possible\\n        vector<int> height(n);\\n\\n        int maxarea = 0;\\n        for(int i = 0; i < m; i++) {\\n            int cur_left = 0, cur_right = n;\\n            // update height\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j] == \\'1\\') height[j]++;\\n                else height[j] = 0;\\n            }\\n            // update left\\n            for(int j=0; j<n; j++) {\\n                if(matrix[i][j]==\\'1\\') left[j]=max(left[j],cur_left);\\n                else {left[j]=0; cur_left=j+1;}\\n            }\\n            // update right\\n            for(int j = n - 1; j >= 0; j--) {\\n                if(matrix[i][j] == \\'1\\') right[j] = min(right[j], cur_right);\\n                else {right[j] = n; cur_right = j;}    \\n            }\\n            // update area\\n            for(int j = 0; j < n; j++) {\\n                maxarea = max(maxarea, (right[j] - left[j]) * height[j]);\\n            }\\n        }\\n        return maxarea;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if (matrix.size() == 0) return 0;\\n            int maxarea = 0;\\n            vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if (matrix[i][j] == \\'1\\'){\\n\\n                        // compute the maximum width and update dp with it\\n                        dp[i][j] = j == 0? 1 : dp[i][j-1] + 1;\\n\\n                        int width = dp[i][j];\\n\\n                        // compute the maximum area rectangle with a lower right corner at [i, j]\\n                        for(int k = i; k >= 0; k--){\\n                            width = min(width, dp[k][j]);\\n                            maxarea = max(maxarea, width * (i - k + 1));\\n                        }\\n                    }\\n                }\\n            } \\n\\t\\t\\treturn maxarea;\\n        }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n/*\\n\\norg:         \\n\\n       c0 c1 c2 c3\\nrow      \\n  0     1  0  1  0\\n  1     1  0  1  1\\n  2     1  1  1  1 \\n  3     1  0  0  1\\n   \\n   \\nstep 1: calculate hist upon rows:\\n   \\n        c0 c1 c2 c3\\nrow\\n  0     1  0  1  0\\n  1     2  0  2  1\\n  2     3  1  3  2\\n  3     4  0  0  3\\n\\n\\nstep 2: calculate max rectangle of hist upon each row:\\n\\nrow\\n  0     1\\n  1     2\\n  2     4\\n  3     4\\n    \\nstep 3: return max area (4).\\n   \\n   \\n*/\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n_rows = matrix.size();\\n        \\n        if (n_rows == 0)\\n            return 0;\\n        \\n        int n_cols = matrix[0].size();\\n        \\n        vector<int> hist(n_cols, 0);\\n        \\n        int max_area = 0;\\n        \\n        for (int r = 0; r < n_rows; r++) {\\n            \\n            // update the state of this row\\'s histogram using the last row\\'s histogram\\n            // by keeping track of the number of consecutive ones\\n            for (int c= 0; c < n_cols; c++) {\\n                if (matrix[r][c] == \\'1\\')\\n                    hist[c] += 1;\\n                else\\n                    hist[c] = 0;\\n            }\\n            \\n            \\n            // update maxarea with the maximum area from this row\\'s histogram\\n            int area = largest_rectangle_hist(hist);\\n            \\n            max_area = max(max_area, area);\\n        }\\n        \\n        return max_area;\\n    }\\n    \\n    \\n    /*\\n                     #\\n            #     #  #\\n            #     #  #\\n            #  #  #  #\\n    index   0  1  2  3\\n    \\n\\n                     #\\n            .     #  #\\n            .     #  #\\n            .  #  #  #\\n    index   0  1  2  3\\n    \\n    \\n                     .\\n            .     .  .\\n            .     .  .\\n            .  #  .  .\\n    index   0  1  2  3\\n    \\n    \\n    */\\n    int largest_rectangle_hist(vector<int> hist) {\\n        int max_area = 0;\\n        \\n        stack<int> st;\\n        \\n        hist.insert(hist.begin(), 0);\\n        hist.insert(hist.end(), 0);\\n        \\n        for (int i = 0; i < hist.size(); i++) {\\n            while(!st.empty() && hist[st.top()] > hist[i]) {\\n                int h = hist[st.top()];\\n                st.pop();\\n                \\n                int w = (i - st.top() - 1);\\n                \\n                max_area = max(max_area, h * w);\\n            }  \\n            \\n            st.push(i);\\n        }\\n\\n        return max_area;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size() == 0) return 0;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        vector<int> left(n); // initialize left as the leftmost boundary possible\\n        vector<int> right(n, n);// initialize right as the rightmost boundary possible\\n        vector<int> height(n);\\n\\n        int maxarea = 0;\\n        for(int i = 0; i < m; i++) {\\n            int cur_left = 0, cur_right = n;\\n            // update height\\n            for(int j = 0; j < n; j++) {\\n                if(matrix[i][j] == \\'1\\') height[j]++;\\n                else height[j] = 0;\\n            }\\n            // update left\\n            for(int j=0; j<n; j++) {\\n                if(matrix[i][j]==\\'1\\') left[j]=max(left[j],cur_left);\\n                else {left[j]=0; cur_left=j+1;}\\n            }\\n            // update right\\n            for(int j = n - 1; j >= 0; j--) {\\n                if(matrix[i][j] == \\'1\\') right[j] = min(right[j], cur_right);\\n                else {right[j] = n; cur_right = j;}    \\n            }\\n            // update area\\n            for(int j = 0; j < n; j++) {\\n                maxarea = max(maxarea, (right[j] - left[j]) * height[j]);\\n            }\\n        }\\n        return maxarea;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739494,
                "title": "javascript-clean-dp-using-histograms",
                "content": "```javascript\\nvar maximalRectangle = function(matrix) {\\n    if(!matrix.length) return 0;\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    const histogram = Array(C_NUM).fill(0);\\n    let maxArea = 0;\\n    \\n    for(let r = 0; r < R_NUM; r++) {\\n        for(let c = 0; c < C_NUM; c++) {\\n            if(+matrix[r][c]) histogram[c]++;\\n            else histogram[c] = 0;\\n        }\\n        \\n        for(let c = 0; c < C_NUM; c++) {\\n            let left = c - 1, right = c + 1;\\n            while(left >= 0 && histogram[left] >= histogram[c]) left--;\\n            while(right < C_NUM && histogram[right] >= histogram[c]) right++;\\n            maxArea = Math.max(histogram[c] * (right - left - 1), maxArea);\\n        }\\n    }\\n    return maxArea;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar maximalRectangle = function(matrix) {\\n    if(!matrix.length) return 0;\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    const histogram = Array(C_NUM).fill(0);\\n    let maxArea = 0;\\n    \\n    for(let r = 0; r < R_NUM; r++) {\\n        for(let c = 0; c < C_NUM; c++) {\\n            if(+matrix[r][c]) histogram[c]++;\\n            else histogram[c] = 0;\\n        }\\n        \\n        for(let c = 0; c < C_NUM; c++) {\\n            let left = c - 1, right = c + 1;\\n            while(left >= 0 && histogram[left] >= histogram[c]) left--;\\n            while(right < C_NUM && histogram[right] >= histogram[c]) right++;\\n            maxArea = Math.max(histogram[c] * (right - left - 1), maxArea);\\n        }\\n    }\\n    return maxArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 737438,
                "title": "brute-force-method",
                "content": "Similar question of [Count Submatrices With All Ones](https://leetcode.com/problems/count-submatrices-with-all-ones/)\\n\\nInspired by @rsdavis6\\'s [solution](https://leetcode.com/problems/count-submatrices-with-all-ones/discuss/721266/C%2B%2B-Understand-the-brute-force-solution-first!) for above question.\\n\\nI know the `boundary` is not needed, but I leave it there to respect the original author.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size();\\n        if (row == 0) return 0;\\n        int col = matrix[0].size();\\n        \\n        int ans = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                ans = max(ans, area(i, j, matrix));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int area(int row, int col, vector<vector<char>>& matrix) {\\n        int row_max = matrix.size();\\n        int col_max = matrix[0].size();\\n        int boundary = col_max;\\n        \\n        int area = 0;\\n        for (int i = row; i < row_max; i++) {\\n            for (int j = col; j < boundary; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    continue;\\n                } else {\\n                    boundary = j;\\n                    break;\\n                }\\n            }\\n            area = max((i-row+1) * (boundary-col), area);\\n        }\\n        return area;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row = matrix.size();\\n        if (row == 0) return 0;\\n        int col = matrix[0].size();\\n        \\n        int ans = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                ans = max(ans, area(i, j, matrix));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int area(int row, int col, vector<vector<char>>& matrix) {\\n        int row_max = matrix.size();\\n        int col_max = matrix[0].size();\\n        int boundary = col_max;\\n        \\n        int area = 0;\\n        for (int i = row; i < row_max; i++) {\\n            for (int j = col; j < boundary; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    continue;\\n                } else {\\n                    boundary = j;\\n                    break;\\n                }\\n            }\\n            area = max((i-row+1) * (boundary-col), area);\\n        }\\n        return area;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736725,
                "title": "python-rust-stack-solution",
                "content": "- **Python**\\n\\n```python\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix: \\n            return 0\\n        \\n        res, histogram = 0, [0] * (len(matrix[0]) + 2)\\n        \\n        for row in matrix:\\n            for i, val in enumerate(row):\\n                if val == \\'0\\':\\n                    histogram[i + 1] = 0\\n                else:\\n                    histogram[i + 1] += 1\\n                    \\n            res = max(res, self.maxInHistogram(histogram))\\n        \\n        return res\\n        \\n        \\n    def maxInHistogram(self, hist: List[int]) -> int:\\n        res, stack = 0, []\\n        \\n        for i, h in enumerate(hist):\\n            \\n            while stack and hist[stack[-1]] > h:\\n                j = stack.pop()\\n                res = max(res, (i - stack[-1]-1) * hist[j])\\n            \\n            stack.append(i)\\n        \\n        return res\\n```\\n\\n- **Rust**\\n\\n```rust\\nimpl Solution {\\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\\n        if matrix.len() == 0 {\\n            return 0;\\n        }\\n        \\n        let mut res = 0;\\n        let mut histogram: Vec<i32> = vec![ 0; (matrix[0].len() + 2) ];\\n        \\n        for row in matrix.iter() {\\n            for (i, val) in row.iter().enumerate() {\\n                if *val == \\'0\\' {\\n                    histogram[i + 1] = 0;\\n                } else {\\n                    histogram[i + 1] += 1;\\n                }\\n            }\\n            res = res.max(Self::maxInHistogram(&histogram));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    pub fn maxInHistogram(hist: &Vec<i32>) -> i32 {\\n        let mut res: i32 = 0;\\n        let mut stack: Vec<usize> = vec![];\\n        \\n        for (i, val) in hist.iter().enumerate() {\\n            while stack.len() > 0 && hist[*stack.iter().last().unwrap()] > *val {\\n                let j = stack.pop().unwrap();\\n                let width = (i - stack[stack.len() - 1] - 1) as i32;\\n                res = res.max(hist[j] * width);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix: \\n            return 0\\n        \\n        res, histogram = 0, [0] * (len(matrix[0]) + 2)\\n        \\n        for row in matrix:\\n            for i, val in enumerate(row):\\n                if val == \\'0\\':\\n                    histogram[i + 1] = 0\\n                else:\\n                    histogram[i + 1] += 1\\n                    \\n            res = max(res, self.maxInHistogram(histogram))\\n        \\n        return res\\n        \\n        \\n    def maxInHistogram(self, hist: List[int]) -> int:\\n        res, stack = 0, []\\n        \\n        for i, h in enumerate(hist):\\n            \\n            while stack and hist[stack[-1]] > h:\\n                j = stack.pop()\\n                res = max(res, (i - stack[-1]-1) * hist[j])\\n            \\n            stack.append(i)\\n        \\n        return res\\n```\n```rust\\nimpl Solution {\\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\\n        if matrix.len() == 0 {\\n            return 0;\\n        }\\n        \\n        let mut res = 0;\\n        let mut histogram: Vec<i32> = vec![ 0; (matrix[0].len() + 2) ];\\n        \\n        for row in matrix.iter() {\\n            for (i, val) in row.iter().enumerate() {\\n                if *val == \\'0\\' {\\n                    histogram[i + 1] = 0;\\n                } else {\\n                    histogram[i + 1] += 1;\\n                }\\n            }\\n            res = res.max(Self::maxInHistogram(&histogram));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    pub fn maxInHistogram(hist: &Vec<i32>) -> i32 {\\n        let mut res: i32 = 0;\\n        let mut stack: Vec<usize> = vec![];\\n        \\n        for (i, val) in hist.iter().enumerate() {\\n            while stack.len() > 0 && hist[*stack.iter().last().unwrap()] > *val {\\n                let j = stack.pop().unwrap();\\n                let width = (i - stack[stack.len() - 1] - 1) as i32;\\n                res = res.max(hist[j] * width);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29126,
                "title": "sharing-my-12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char>>& matrix) {\\n            // pure application of dynamic programming\\n            int m = matrix.size();\\n            if(m==0)\\n                return 0;\\n            int n = matrix[0].size();\\n            if(n==0)\\n                return 0;\\n                \\n            int result=0;\\n            vector<int> height(n, 0);\\n            vector<int> left(n, 0);\\n            vector<int> right(n, n-1);\\n            int currentLeft, currentRight;\\n            int i, j;\\n            for(i=0; i<m; i++)\\n            {\\n                currentLeft = 0;\\n                currentRight = n-1;\\n                \\n                for(j=0; j<n; j++)\\n                {\\n                    if(matrix[i][j]=='1')\\n                        height[j]++;\\n                    else\\n                        height[j] = 0;\\n                }\\n                \\n                for(j=0; j<n; j++)\\n                {\\n                    if(matrix[i][j]=='1')\\n                        left[j] = max(left[j], currentLeft);\\n                    else\\n                    {\\n                        left[j] = 0;\\n                        currentLeft = j+1;\\n                    }\\n                }\\n                \\n                for(j=n-1; j>=0; j--)\\n                {\\n                    if(matrix[i][j]=='1')\\n                        right[j] = min(right[j], currentRight);\\n                    else\\n                    {\\n                        right[j] = n-1;\\n                        currentRight = j-1;\\n                    }\\n                }\\n                \\n                for(j=0; j<n; j++)\\n                    result = max(result, (right[j]-left[j]+1)*height[j]);\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maximalRectangle(vector<vector<char>>& matrix) {\\n            // pure application of dynamic programming\\n            int m = matrix.size();\\n            if(m==0)\\n                return 0;\\n            int n = matrix[0].size();\\n            if(n==0)\\n                return 0;\\n                \\n            int result=0;\\n            vector<int> height(n, 0);\\n            vector<int> left(n, 0);\\n            vector<int> right(n, n-1);\\n            int currentLeft, currentRight;\\n            int i, j;\\n            for(i=0; i<m; i++)\\n            {\\n                currentLeft = 0;\\n                currentRight = n-1;\\n                \\n                for(j=0; j<n; j++)\\n                {\\n                    if(matrix[i][j]=='1')\\n                        height[j]++;\\n                    else\\n                        height[j] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 29153,
                "title": "sharing-my-296ms-java-solution",
                "content": "The idea is, to form a matrix x where each element indicates the next index of horizontal '1' before '0' or end (getX()), and another matrix y where each element indicates the index of next vertical '1' before '0' or end (getY()). E.g. 1 1 1 0 0 1 1 becomes 2 2 2 -1 -1 6 6.\\n\\nThen, for each element [i][j], only [i+1][j+1], [i+2][j+2]... needs to be checked. The area can be easily computed by the indexes on x and y.\\n\\n    public class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n    \\n    \\t\\tint h = matrix.length;\\n    \\t\\tif (h == 0) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}\\n    \\t\\tint w = matrix[0].length;\\n    \\t\\tif (w == 0) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}\\n    \\n    \\t\\tint[][] x = getX(matrix, h, w);\\n    \\t\\tint[][] y = getY(matrix, h, w);\\n    \\n    \\t\\tint maxArea = 0;\\n    \\n    \\t\\tfor (int i = 0; i < h; i++) {\\n    \\t\\t\\tfor (int j = 0; j < w; j++) {\\n    \\n    \\t\\t\\t\\tint xIdx = x[i][j];\\n    \\t\\t\\t\\tint yIdx = y[i][j];\\n    \\n    \\t\\t\\t\\tint k = 0;\\n    \\t\\t\\t\\twhile (k <= Math.min((xIdx - j), (yIdx - i))\\n    \\t\\t\\t\\t\\t\\t&& matrix[i + k][j + k] == '1') {\\n    \\n    \\t\\t\\t\\t\\txIdx = Math.min(xIdx, x[i+k][j+k]);\\n    \\t\\t\\t\\t\\tyIdx = Math.min(yIdx, y[i+k][j+k]);\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif ((xIdx - j + 1) * (yIdx - i + 1) <= maxArea) {\\n    \\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tint wArea = (k + 1) * (xIdx - j + 1);\\n    \\t\\t\\t\\t\\tint hArea = (k + 1) * (yIdx - i + 1);\\n    \\t\\t\\t\\t\\tif (wArea > maxArea) {\\n    \\t\\t\\t\\t\\t\\tmaxArea = wArea;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tif (hArea > maxArea) {\\n    \\t\\t\\t\\t\\t\\tmaxArea = hArea;\\n    \\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t\\tk++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\treturn maxArea;\\n    \\t}\\n    \\n    \\tprivate int[][] getX(char[][] matrix, int h, int w) {\\n    \\n    \\t\\tint[][] res = new int[h][w];\\n    \\n    \\t\\tfor (int i = h - 1; i >= 0; i--) {\\n    \\t\\t\\tint curr = -1;\\n    \\t\\t\\tfor (int j = w - 1; j >= 0; j--) {\\n    \\t\\t\\t\\tif (matrix[i][j] == '1') {\\n    \\t\\t\\t\\t\\tif (curr == -1) {\\n    \\t\\t\\t\\t\\t\\tcurr = j;\\n    \\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tcurr = -1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tres[i][j] = curr;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    \\n    \\tprivate int[][] getY(char[][] matrix, int h, int w) {\\n    \\n    \\t\\tint[][] res = new int[h][w];\\n    \\n    \\t\\tfor (int j = w - 1; j >= 0; j--) {\\n    \\t\\t\\tint curr = -1;\\n    \\t\\t\\tfor (int i = h - 1; i >= 0; i--) {\\n    \\t\\t\\t\\tif (matrix[i][j] == '1') {\\n    \\t\\t\\t\\t\\tif (curr == -1) {\\n    \\t\\t\\t\\t\\t\\tcurr = i;\\n    \\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tcurr = -1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tres[i][j] = curr;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    \\t\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maximalRectangle(char[][] matrix) {\\n    \\n    \\t\\tint h = matrix.length;\\n    \\t\\tif (h == 0) {\\n    \\t\\t\\treturn 0;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3898796,
                "title": "java-solution-stack-based-on-aditya-verma-approach-using-maximum-area-of-histogram-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783795,
                "title": "java-dp",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int maxArea = 0;\\n        int[] heights = new int[matrix[0].length];\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == \\'1\\') heights[j]++;\\n                else heights[j] = 0;\\n            }\\n\\n            int area = largestRectangleArea(heights);\\n            maxArea = Math.max(area, maxArea);\\n        }\\n        return maxArea;\\n    }\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n\\n        int[] ls = new int[n];  // next smallest index on the left\\n        ls[0] = -1;\\n        Stack<Integer> st = new Stack<>();\\n        st.push(0);\\n\\n        for(int i = 1; i < n; i++) {\\n            while(st.size() > 0 && heights[i] <= heights[st.peek()]) st.pop();\\n\\n            if(st.size() == 0) ls[i] = -1;\\n            else ls[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        int[] rs = new int[n];  // next smallest index on the right\\n        rs[n-1] = n;\\n        st = new Stack<>();\\n        st.push(n-1);\\n\\n        for(int i = n-2; i >= 0; i--) {\\n            while(st.size() > 0 && heights[i] <= heights[st.peek()]) st.pop();\\n\\n            if(st.size() == 0) rs[i] = n;\\n            else rs[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        int maxArea = 0;\\n        for(int i = 0; i < n; i++) {\\n            int width = rs[i] - ls[i] - 1;\\n            int area = heights[i] * width;\\n            maxArea = Math.max(area, maxArea);\\n        } \\n\\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int maxArea = 0;\\n        int[] heights = new int[matrix[0].length];\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == \\'1\\') heights[j]++;\\n                else heights[j] = 0;\\n            }\\n\\n            int area = largestRectangleArea(heights);\\n            maxArea = Math.max(area, maxArea);\\n        }\\n        return maxArea;\\n    }\\n\\n    public int largestRectangleArea(int[] heights) {\\n        int n = heights.length;\\n\\n        int[] ls = new int[n];  // next smallest index on the left\\n        ls[0] = -1;\\n        Stack<Integer> st = new Stack<>();\\n        st.push(0);\\n\\n        for(int i = 1; i < n; i++) {\\n            while(st.size() > 0 && heights[i] <= heights[st.peek()]) st.pop();\\n\\n            if(st.size() == 0) ls[i] = -1;\\n            else ls[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        int[] rs = new int[n];  // next smallest index on the right\\n        rs[n-1] = n;\\n        st = new Stack<>();\\n        st.push(n-1);\\n\\n        for(int i = n-2; i >= 0; i--) {\\n            while(st.size() > 0 && heights[i] <= heights[st.peek()]) st.pop();\\n\\n            if(st.size() == 0) rs[i] = n;\\n            else rs[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        int maxArea = 0;\\n        for(int i = 0; i < n; i++) {\\n            int width = rs[i] - ls[i] - 1;\\n            int area = heights[i] * width;\\n            maxArea = Math.max(area, maxArea);\\n        } \\n\\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659705,
                "title": "c-dp-simple-solution-w-explanation-easy-histogram-stack",
                "content": "# Intuition\\n1) The problem asks to find the maximum area of a rectangle in a binary matrix.\\n2) We can solve this problem by treating each row of the matrix as a histogram and applying the histogram approach to find the maximum rectangle area.\\n\\n# Approach\\n- Initialize the maxArea variable to 0 to store the maximum area found so far.\\n- Create a vector heights of size cols to track the heights of each column.\\n- Iterate through each row of the matrix.\\n- Update the heights array for the current row:\\n- If the current cell is \\'1\\', increment the height of the column by 1.\\n- If the current cell is \\'0\\', reset the height of the column to 0.\\n- Calculate the maximum area using the histogram approach:\\nUse a stack to maintain a non-decreasing sequence of column heights.\\n- Iterate through each column and compare the current height with the height of the top column in the stack.\\n- If the current height is less than or equal to the height of the top column, pop the top column from the stack and calculate the area using the popped column as the height.\\n- Update the maximum area if necessary.\\n- Push the current column index to the stack.\\n- Update the maximum area if the current area is larger than the previous maximum area.\\n- Return the maximum area found.\\n\\n# Complexity\\n- Time complexity:O(rows * cols)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(cols)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows = matrix.size();\\n        if (rows == 0) {\\n            return 0;\\n        }\\n\\n        int cols = matrix[0].size();\\n        int maxArea = 0;\\n\\n        // Create a vector to track the heights of each column\\n        vector<int> heights(cols, 0);\\n\\n        for (int i = 0; i < rows; i++) {\\n            // Update the heights array for the current row\\n            for (int j = 0; j < cols; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    // If the current cell is \\'1\\', increment the height of the column\\n                    heights[j]++;\\n                } else {\\n                    // If the current cell is \\'0\\', reset the height of the column to 0\\n                    heights[j] = 0;\\n                }\\n            }\\n\\n            // Calculate the maximum area using the histogram approach\\n            stack<int> stk;\\n            int currArea = 0;\\n\\n            for (int j = 0; j <= cols; j++) {\\n                // Process each column and maintain a non-decreasing stack of heights\\n                while (!stk.empty() && (j == cols || heights[j] <= heights[stk.top()])) {\\n                    // The current height is less than the height of the previous column\\n                    int top = heights[stk.top()]; // Get the height of the top column\\n                    stk.pop(); // Pop the top column from the stack\\n                    int breadth = stk.empty() ? j : j - stk.top() - 1;\\n                    // Calculate the breadth of the rectangle using the current column and the previous column\\n                    currArea = max(currArea, top * breadth);\\n                    // Update the maximum area if necessary\\n                }\\n                stk.push(j); // Push the current column index to the stack\\n            }\\n\\n            // Update the maximum area\\n            maxArea = max(maxArea, currArea);\\n        }\\n\\n        return maxArea;\\n    }\\n};\\n\\n```\\n*PLease Upvote If You Find It Helpful.*\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int rows = matrix.size();\\n        if (rows == 0) {\\n            return 0;\\n        }\\n\\n        int cols = matrix[0].size();\\n        int maxArea = 0;\\n\\n        // Create a vector to track the heights of each column\\n        vector<int> heights(cols, 0);\\n\\n        for (int i = 0; i < rows; i++) {\\n            // Update the heights array for the current row\\n            for (int j = 0; j < cols; j++) {\\n                if (matrix[i][j] == \\'1\\') {\\n                    // If the current cell is \\'1\\', increment the height of the column\\n                    heights[j]++;\\n                } else {\\n                    // If the current cell is \\'0\\', reset the height of the column to 0\\n                    heights[j] = 0;\\n                }\\n            }\\n\\n            // Calculate the maximum area using the histogram approach\\n            stack<int> stk;\\n            int currArea = 0;\\n\\n            for (int j = 0; j <= cols; j++) {\\n                // Process each column and maintain a non-decreasing stack of heights\\n                while (!stk.empty() && (j == cols || heights[j] <= heights[stk.top()])) {\\n                    // The current height is less than the height of the previous column\\n                    int top = heights[stk.top()]; // Get the height of the top column\\n                    stk.pop(); // Pop the top column from the stack\\n                    int breadth = stk.empty() ? j : j - stk.top() - 1;\\n                    // Calculate the breadth of the rectangle using the current column and the previous column\\n                    currArea = max(currArea, top * breadth);\\n                    // Update the maximum area if necessary\\n                }\\n                stk.push(j); // Push the current column index to the stack\\n            }\\n\\n            // Update the maximum area\\n            maxArea = max(maxArea, currArea);\\n        }\\n\\n        return maxArea;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623094,
                "title": "simple-and-efficient-java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA rectangle can be maximum in three cases:\\n1. Length=1 and Breadth=A positive Integer value.\\n2. Breadth=1 and Heigth=A positive Integer value.\\n3. Both Length and Breadth are positive Integer values.\\n\\n# Approach\\n1. Initially create two arrays as length[][] and breadth[][](below they are considered as h[][] and b[][]).\\n2. By using DP find the maximum length and breadth for each in their respective arrays.\\n3. Find Max value from two arrays.\\n4. For case 3: Both Length and Breadth are positive Integer values.\\n5. create res[][]\\n6. res[i][j] will be fill as mentioned below in code.Find the max value.\\n7. Return max value.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncode as follows:\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] m) {\\n        int h[][]=new int[m.length+1][m[0].length+1];\\n        int b[][]=new int[m.length+1][m[0].length+1];\\n        int res[][]=new int[m.length][m[0].length];\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                else{\\n                    h[i+1][j+1]=h[i][j+1]+1;\\n                    b[i+1][j+1]=b[i+1][j]+1;\\n                    maxi=Math.max(maxi,Math.max(h[i+1][j+1],b[i+1][j+1]));\\n                }\\n            }\\n        }\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                if(b[i][j+1]!=0 && b[i+1][j+1]!=0 && h[i+1][j+1]!=0){\\n                    int val=find(h,b,i,j,Math.min(b[i][j+1],b[i+1][j+1]));\\n                    res[i][j]=val;\\n                    maxi=Math.max(maxi,val);\\n                }\\n                else res[i][j]=1;\\n            }\\n        }\\n        return maxi==Integer.MIN_VALUE?0:maxi;\\n    }\\n    public int find(int[][] h,int[][] b,int i,int j,int len){\\n        int mini=Integer.MIN_VALUE;\\n        int v=0,cur=0;\\n        for(int k=1;k<=len;k++){\\n            if(k==1){\\n                v=h[i+1][j+1];\\n                cur=h[i+1][j+1];\\n            }\\n            else{\\n                cur=Math.min(cur,h[i+1][j+1]);\\n                v=k*cur;\\n            }\\n            mini=Math.max(mini,v);\\n            j--;\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] m) {\\n        int h[][]=new int[m.length+1][m[0].length+1];\\n        int b[][]=new int[m.length+1][m[0].length+1];\\n        int res[][]=new int[m.length][m[0].length];\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                else{\\n                    h[i+1][j+1]=h[i][j+1]+1;\\n                    b[i+1][j+1]=b[i+1][j]+1;\\n                    maxi=Math.max(maxi,Math.max(h[i+1][j+1],b[i+1][j+1]));\\n                }\\n            }\\n        }\\n        for(int i=0;i<m.length;i++){\\n            for(int j=0;j<m[0].length;j++){\\n                if(m[i][j]==\\'0\\') continue;\\n                if(b[i][j+1]!=0 && b[i+1][j+1]!=0 && h[i+1][j+1]!=0){\\n                    int val=find(h,b,i,j,Math.min(b[i][j+1],b[i+1][j+1]));\\n                    res[i][j]=val;\\n                    maxi=Math.max(maxi,val);\\n                }\\n                else res[i][j]=1;\\n            }\\n        }\\n        return maxi==Integer.MIN_VALUE?0:maxi;\\n    }\\n    public int find(int[][] h,int[][] b,int i,int j,int len){\\n        int mini=Integer.MIN_VALUE;\\n        int v=0,cur=0;\\n        for(int k=1;k<=len;k++){\\n            if(k==1){\\n                v=h[i+1][j+1];\\n                cur=h[i+1][j+1];\\n            }\\n            else{\\n                cur=Math.min(cur,h[i+1][j+1]);\\n                v=k*cur;\\n            }\\n            mini=Math.max(mini,v);\\n            j--;\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610157,
                "title": "java-code-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] mat = new int[row][col];\\n        \\n        for(int i = 0 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    mat[i][j] = 1;\\n                }else{\\n                    mat[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        int[] curr_row = mat[0];\\n        int curr_sum = max_histogram(curr_row);\\n        \\n        for(int i = 1 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(mat[i][j] == 1){\\n                    curr_row[j] += 1;\\n                }else{\\n                    curr_row[j] = 0;\\n                }\\n            }\\n            int temp = max_histogram(curr_row);\\n            curr_sum = Math.max(curr_sum , temp);\\n        }\\n        return curr_sum;\\n        \\n    }\\n    \\n    public int max_histogram(int[] m){\\n        \\n        Stack<Integer> s1 = new Stack<>();\\n        int[] prev_smaller = new int[m.length];\\n        \\n        for(int i = 0 ; i < m.length ; i++){\\n            while(!s1.isEmpty() && m[s1.peek()] >= m[i]){\\n                s1.pop();\\n            }\\n            \\n            if(s1.isEmpty()){\\n                prev_smaller[i] = -1;\\n            }else{\\n                prev_smaller[i] = s1.peek();\\n            }\\n            s1.push(i);\\n            \\n        }\\n        \\n        Stack<Integer> s2 = new Stack<>();\\n        int[] next_smaller = new int[m.length];\\n        \\n        for(int i = m.length-1 ; i >= 0; i--){\\n            while(!s2.isEmpty() && m[s2.peek()] >= m[i]){\\n                s2.pop();\\n            }\\n            \\n            if(s2.isEmpty()){\\n                next_smaller[i] = m.length;\\n            }else{\\n                next_smaller[i] = s2.peek();\\n            }\\n            s2.push(i);\\n        }\\n        int ans = 0;\\n        \\n        for(int i = 0 ;i < m.length ; i++){\\n            int temp = (next_smaller[i] - prev_smaller[i]-1) * m[i];\\n            ans = Math.max(temp , ans);\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] mat = new int[row][col];\\n        \\n        for(int i = 0 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    mat[i][j] = 1;\\n                }else{\\n                    mat[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        int[] curr_row = mat[0];\\n        int curr_sum = max_histogram(curr_row);\\n        \\n        for(int i = 1 ; i < row ; i++){\\n            for(int j = 0 ; j < col ; j++){\\n                if(mat[i][j] == 1){\\n                    curr_row[j] += 1;\\n                }else{\\n                    curr_row[j] = 0;\\n                }\\n            }\\n            int temp = max_histogram(curr_row);\\n            curr_sum = Math.max(curr_sum , temp);\\n        }\\n        return curr_sum;\\n        \\n    }\\n    \\n    public int max_histogram(int[] m){\\n        \\n        Stack<Integer> s1 = new Stack<>();\\n        int[] prev_smaller = new int[m.length];\\n        \\n        for(int i = 0 ; i < m.length ; i++){\\n            while(!s1.isEmpty() && m[s1.peek()] >= m[i]){\\n                s1.pop();\\n            }\\n            \\n            if(s1.isEmpty()){\\n                prev_smaller[i] = -1;\\n            }else{\\n                prev_smaller[i] = s1.peek();\\n            }\\n            s1.push(i);\\n            \\n        }\\n        \\n        Stack<Integer> s2 = new Stack<>();\\n        int[] next_smaller = new int[m.length];\\n        \\n        for(int i = m.length-1 ; i >= 0; i--){\\n            while(!s2.isEmpty() && m[s2.peek()] >= m[i]){\\n                s2.pop();\\n            }\\n            \\n            if(s2.isEmpty()){\\n                next_smaller[i] = m.length;\\n            }else{\\n                next_smaller[i] = s2.peek();\\n            }\\n            s2.push(i);\\n        }\\n        int ans = 0;\\n        \\n        for(int i = 0 ;i < m.length ; i++){\\n            int temp = (next_smaller[i] - prev_smaller[i]-1) * m[i];\\n            ans = Math.max(temp , ans);\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501899,
                "title": "python-easy-understandable-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n, m = len(matrix), len(matrix[0])\\n        height = [0] * (m + 1)\\n        res = 0\\n        for row in matrix:\\n            for a in range(m):\\n                height[a] = height[a] + 1 if row[a] == \\'1\\' else 0\\n            stack = [-1]\\n            for a in range(m + 1):\\n                while height[a] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = a - stack[-1] - 1\\n                    res = max(res, h * w)\\n                stack.append(a)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n, m = len(matrix), len(matrix[0])\\n        height = [0] * (m + 1)\\n        res = 0\\n        for row in matrix:\\n            for a in range(m):\\n                height[a] = height[a] + 1 if row[a] == \\'1\\' else 0\\n            stack = [-1]\\n            for a in range(m + 1):\\n                while height[a] < height[stack[-1]]:\\n                    h = height[stack.pop()]\\n                    w = a - stack[-1] - 1\\n                    res = max(res, h * w)\\n                stack.append(a)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292697,
                "title": "javascript-85-maximal-rectangle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- 1-dimensional: https://leetcode.com/problems/largest-rectangle-in-histogram/\\n\\nSolution: https://leetcode.com/problems/largest-rectangle-in-histogram/solutions/3297538/javascript-84-largest-rectangle-in-histogram/\\n\\n- 2-dimensional: https://leetcode.com/problems/maximal-rectangle/\\n\\nSolution: below\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nGood one\\n\\n1\\n```\\nvar maximalRectangle = function (aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let widthOnLeftTillHere = Array.from({ length: m }, () =>\\n        new Array(n).fill(0)\\n    );\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                widthOnLeftTillHere[r][c] =\\n                    (widthOnLeftTillHere[r][c - 1] || 0) + 1;\\n            }\\n\\n    let maxArea = 0;\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                let minWidthGoingUp = Infinity;\\n                let increasingHeight = 1;\\n                for (let r2 = r; r2 >= 0; r2--, increasingHeight++) {\\n                    minWidthGoingUp = Math.min(\\n                        minWidthGoingUp,\\n                        widthOnLeftTillHere[r2][c]\\n                    );\\n                    maxArea = Math.max(\\n                        maxArea,\\n                        minWidthGoingUp * increasingHeight\\n                    );\\n                }\\n            }\\n    return maxArea;\\n};\\n```\\n\\n2 - Optimized, a bit difficult to understand at begin\\n```\\nfunction maximalRectangle(aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let heights = new Array(n + 1).fill(0), // this row heights, last col is 0\\n        maxArea = 0;\\n\\n    for (let r = 0; r < m; r++) {\\n        let cols = []; // prev increasing columns - stack\\n        cols.top = () => cols[cols.length - 1]; // get column left on top of stack\\n\\n        for (let c = 0; c <= n; c++) {\\n            if (c < n) {\\n                if (aa[r][c] === \"1\") heights[c]++;\\n                else heights[c] = 0;\\n            }\\n\\n            while (cols.length && heights[cols.top()] > heights[c]) {\\n                let height = heights[cols.pop()]; // prev column height\\n                let width = cols.length ? c - cols.top() - 1 : c; // prev prev column to cur column width\\n                maxArea = Math.max(maxArea, width * height);\\n            }\\n            cols.push(c);\\n        }\\n    }\\n    return maxArea;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximalRectangle = function (aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let widthOnLeftTillHere = Array.from({ length: m }, () =>\\n        new Array(n).fill(0)\\n    );\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                widthOnLeftTillHere[r][c] =\\n                    (widthOnLeftTillHere[r][c - 1] || 0) + 1;\\n            }\\n\\n    let maxArea = 0;\\n    for (let r = 0; r < m; r++)\\n        for (let c = 0; c < n; c++)\\n            if (aa[r][c] === \"1\") {\\n                let minWidthGoingUp = Infinity;\\n                let increasingHeight = 1;\\n                for (let r2 = r; r2 >= 0; r2--, increasingHeight++) {\\n                    minWidthGoingUp = Math.min(\\n                        minWidthGoingUp,\\n                        widthOnLeftTillHere[r2][c]\\n                    );\\n                    maxArea = Math.max(\\n                        maxArea,\\n                        minWidthGoingUp * increasingHeight\\n                    );\\n                }\\n            }\\n    return maxArea;\\n};\\n```\n```\\nfunction maximalRectangle(aa) {\\n    let m = aa.length,\\n        n = aa[0].length;\\n\\n    let heights = new Array(n + 1).fill(0), // this row heights, last col is 0\\n        maxArea = 0;\\n\\n    for (let r = 0; r < m; r++) {\\n        let cols = []; // prev increasing columns - stack\\n        cols.top = () => cols[cols.length - 1]; // get column left on top of stack\\n\\n        for (let c = 0; c <= n; c++) {\\n            if (c < n) {\\n                if (aa[r][c] === \"1\") heights[c]++;\\n                else heights[c] = 0;\\n            }\\n\\n            while (cols.length && heights[cols.top()] > heights[c]) {\\n                let height = heights[cols.pop()]; // prev column height\\n                let width = cols.length ? c - cols.top() - 1 : c; // prev prev column to cur column width\\n                maxArea = Math.max(maxArea, width * height);\\n            }\\n            cols.push(c);\\n        }\\n    }\\n    return maxArea;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133444,
                "title": "rectangles-in-histogram-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\\n        let mut histogram = vec![0; matrix[0].len()];\\n        let mut max_area = 0;\\n        for col in matrix {\\n            for (i, c) in col.into_iter().enumerate() {\\n                histogram[i] = if c == \\'0\\' { 0 } else { histogram[i] + 1 }\\n            }\\n            max_area = i32::max(max_area, Self::max_rect(&histogram));\\n        }\\n        max_area\\n    }\\n\\n    fn max_rect(histogram: &Vec<i32>) -> i32 {\\n        let (mut max_area, mut width, n) = (0, 0, histogram.len());\\n        let mut stack = Vec::with_capacity(n);\\n\\n        (0..n).for_each(|cur| {\\n            while let Some(&last) = stack.last() {\\n                if histogram[last] > histogram[cur] {\\n                    stack.pop();\\n                    width = if let Some(&prev) = stack.last() { cur - prev - 1 } else { cur };\\n                    max_area = i32::max(max_area, width as i32 * histogram[last]);\\n                } else { break; }\\n            }\\n            stack.push(cur);\\n        });\\n\\n        while let Some(last) = stack.pop() {\\n            width = if let Some(&prev) = stack.last() { n - prev - 1 } else { n };\\n            max_area = i32::max(max_area, width as i32 * histogram[last]);\\n        }\\n\\n        max_area\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {\\n        let mut histogram = vec![0; matrix[0].len()];\\n        let mut max_area = 0;\\n        for col in matrix {\\n            for (i, c) in col.into_iter().enumerate() {\\n                histogram[i] = if c == \\'0\\' { 0 } else { histogram[i] + 1 }\\n            }\\n            max_area = i32::max(max_area, Self::max_rect(&histogram));\\n        }\\n        max_area\\n    }\\n\\n    fn max_rect(histogram: &Vec<i32>) -> i32 {\\n        let (mut max_area, mut width, n) = (0, 0, histogram.len());\\n        let mut stack = Vec::with_capacity(n);\\n\\n        (0..n).for_each(|cur| {\\n            while let Some(&last) = stack.last() {\\n                if histogram[last] > histogram[cur] {\\n                    stack.pop();\\n                    width = if let Some(&prev) = stack.last() { cur - prev - 1 } else { cur };\\n                    max_area = i32::max(max_area, width as i32 * histogram[last]);\\n                } else { break; }\\n            }\\n            stack.push(cur);\\n        });\\n\\n        while let Some(last) = stack.pop() {\\n            width = if let Some(&prev) = stack.last() { n - prev - 1 } else { n };\\n            max_area = i32::max(max_area, width as i32 * histogram[last]);\\n        }\\n\\n        max_area\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2999576,
                "title": "java-solution-easiest-solution-build-on-top-of-leetcode84",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1,\\n        // we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = yourLeetCode84Method(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }  \\n}\\n\\n// Output -\\n/*\\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\\nOutput: 6\\nExplanation: The maximal rectangle is shown in the above picture.\\n*/\\n\\n// Algorithm -\\n/*\\nUse Largest Rectangle in Histogram\\n1. We first initialize the heights array with all zeros.\\n2. We then iterate through the matrix and for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell.\\n3. We then calculate the area of the rectangle with the largest area.\\n*/\\n\\n// Time & Space Complexity -\\n/*\\nTime - O(R x C), Only one traversal of the matrix is required, so the time complexity is O(R X C)\\nSpace - O(C), Stack is required to store the columns, so space complexity is O(C)\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        // for each cell with value=1,\\n        // we look upward (north), the number of continuous \\'1\\' is the height of cell\\n        int[] heights = new int[matrix[0].length];\\n        int maxArea=-1;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j]==\\'0\\'){\\n                    heights[j] = 0;\\n                } else {\\n                    heights[j] ++;\\n                }\\n            }            \\n            int area = yourLeetCode84Method(heights);\\n            maxArea = Math.max(maxArea, area);\\n        }\\n        return maxArea;\\n    }  \\n}\\n\\n// Output -\\n/*\\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\\nOutput: 6\\nExplanation: The maximal rectangle is shown in the above picture.\\n*/\\n\\n// Algorithm -\\n/*\\nUse Largest Rectangle in Histogram\\n1. We first initialize the heights array with all zeros.\\n2. We then iterate through the matrix and for each cell with value=1, we look upward (north), the number of continuous \\'1\\' is the height of cell.\\n3. We then calculate the area of the rectangle with the largest area.\\n*/\\n\\n// Time & Space Complexity -\\n/*\\nTime - O(R x C), Only one traversal of the matrix is required, so the time complexity is O(R X C)\\nSpace - O(C), Stack is required to store the columns, so space complexity is O(C)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893444,
                "title": "brute-force-tle-and-optimal-dp-in-python",
                "content": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix):\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        max_area = 0\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                for width in range(1, cols-j+1):\\n                    for height in range(1, rows-i+1):\\n                        is_rectangle = True # is composed only of 1\\'s\\n                        for k in range(i, i+height):\\n                            for l in range(j, j+width):\\n                                if matrix[k][l] != \"1\": # If we find a cell that is not 1, rectangle is not valid\\n                                    is_rectangle = False\\n                                    break\\n                                if not is_rectangle:\\n                                    break\\n                        if is_rectangle:\\n                            area = width * height\\n                            max_area = max(max_area, area)\\n        return max_area\\n```\\n\\t\\n\\n1.  DP\\n\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix: # Return 0 if the matrix is empty\\n            return 0\\n\\n        m, n = len(matrix), len(matrix[0]) # Get the number of rows and columns in the matrix\\n\\n        # Initialize three arrays to store the number of consecutive 1\\'s to the left of each cell,\\n        # the number of consecutive 1\\'s to the right of each cell, and the height of each cell\\n        left, right, height = [0] * n, [n] * n, [0] * n\\n\\n        # Initialize the maximum possible area to 0\\n        max_area = 0\\n\\n        # Iterate over each row in the matrix\\n        for i in range(m):\\n            # Initialize the current left and right indices to 0 and n respectively\\n            cur_left, cur_right = 0, n\\n\\n            # Iterate over each column in the matrix to compute the height of each cell\\n            for j in range(n):\\n                # If the cell is a 1, increment the height of the cell\\n                if matrix[i][j] == \"1\":\\n                    height[j] += 1\\n                else:\\n                    height[j] = 0\\n\\n            # Iterate over each column in the matrix to compute the number of consecutive 1\\'s\\n            # to the left of each cell\\n            for j in range(n):\\n                # If the cell is a 1, update the number of consecutive 1\\'s to the left of the cell\\n                # to be the maximum of the current value and the current left index\\n                if matrix[i][j] == \"1\":\\n                    left[j] = max(left[j], cur_left)\\n                else:\\n                    # If the cell is a 0, reset the number of consecutive 1\\'s to the left of the cell to 0\\n                    # and update the current left index to be the current column index plus 1\\n                    left[j] = 0\\n                    cur_left = j + 1\\n\\n            # Iterate over each column in the matrix to compute the number of consecutive 1\\'s\\n            # to the right of each cell\\n            for j in range(n - 1, -1, -1):\\n                # If the cell is a 1, update the number of consecutive 1\\'s to the right of the cell\\n                # to be the minimum of the current value and the current right index\\n                if matrix[i][j] == \"1\":\\n                    right[j] = min(right[j], cur_right)\\n                else:\\n                    # If the cell is a 0, reset the number of consecutive 1\\'s to the right of the cell to n\\n                    # and update\\n                    # the current right index to be the current column index\\n                    right[j] = n\\n                    cur_right = j\\n\\n            # Iterate over each column in the matrix to compute the maximum possible area of a rectangle\\n            # with the given heights\\n            for j in range(n):\\n                # Update the maximum possible area to be the maximum of the current value and the area of\\n                # the rectangle with the given height, left, and right values\\n                max_area = max(max_area, (right[j] - left[j]) * height[j])\\n\\n        # Return the maximum possible area\\n        return max_area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix):\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        max_area = 0\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                for width in range(1, cols-j+1):\\n                    for height in range(1, rows-i+1):\\n                        is_rectangle = True # is composed only of 1\\'s\\n                        for k in range(i, i+height):\\n                            for l in range(j, j+width):\\n                                if matrix[k][l] != \"1\": # If we find a cell that is not 1, rectangle is not valid\\n                                    is_rectangle = False\\n                                    break\\n                                if not is_rectangle:\\n                                    break\\n                        if is_rectangle:\\n                            area = width * height\\n                            max_area = max(max_area, area)\\n        return max_area\\n```\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        if not matrix: # Return 0 if the matrix is empty\\n            return 0\\n\\n        m, n = len(matrix), len(matrix[0]) # Get the number of rows and columns in the matrix\\n\\n        # Initialize three arrays to store the number of consecutive 1\\'s to the left of each cell,\\n        # the number of consecutive 1\\'s to the right of each cell, and the height of each cell\\n        left, right, height = [0] * n, [n] * n, [0] * n\\n\\n        # Initialize the maximum possible area to 0\\n        max_area = 0\\n\\n        # Iterate over each row in the matrix\\n        for i in range(m):\\n            # Initialize the current left and right indices to 0 and n respectively\\n            cur_left, cur_right = 0, n\\n\\n            # Iterate over each column in the matrix to compute the height of each cell\\n            for j in range(n):\\n                # If the cell is a 1, increment the height of the cell\\n                if matrix[i][j] == \"1\":\\n                    height[j] += 1\\n                else:\\n                    height[j] = 0\\n\\n            # Iterate over each column in the matrix to compute the number of consecutive 1\\'s\\n            # to the left of each cell\\n            for j in range(n):\\n                # If the cell is a 1, update the number of consecutive 1\\'s to the left of the cell\\n                # to be the maximum of the current value and the current left index\\n                if matrix[i][j] == \"1\":\\n                    left[j] = max(left[j], cur_left)\\n                else:\\n                    # If the cell is a 0, reset the number of consecutive 1\\'s to the left of the cell to 0\\n                    # and update the current left index to be the current column index plus 1\\n                    left[j] = 0\\n                    cur_left = j + 1\\n\\n            # Iterate over each column in the matrix to compute the number of consecutive 1\\'s\\n            # to the right of each cell\\n            for j in range(n - 1, -1, -1):\\n                # If the cell is a 1, update the number of consecutive 1\\'s to the right of the cell\\n                # to be the minimum of the current value and the current right index\\n                if matrix[i][j] == \"1\":\\n                    right[j] = min(right[j], cur_right)\\n                else:\\n                    # If the cell is a 0, reset the number of consecutive 1\\'s to the right of the cell to n\\n                    # and update\\n                    # the current right index to be the current column index\\n                    right[j] = n\\n                    cur_right = j\\n\\n            # Iterate over each column in the matrix to compute the maximum possible area of a rectangle\\n            # with the given heights\\n            for j in range(n):\\n                # Update the maximum possible area to be the maximum of the current value and the area of\\n                # the rectangle with the given height, left, and right values\\n                max_area = max(max_area, (right[j] - left[j]) * height[j])\\n\\n        # Return the maximum possible area\\n        return max_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863424,
                "title": "dp-python-solution-o-m-n-2",
                "content": "# Intuition\\nDP\\n\\n# Approach\\nReduce overlapping counting\\n\\n# Complexity\\n- Time complexity:\\nO(M * N ^ 2)\\n\\n- Space complexity:\\nO(M * N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        # 1 0 1 2 3        \\n        # 0 1 0 1 0       \\n        # 1 2 0 1 2\\n        # 1 2 0 1 2\\n        # 0 1 2 3 4\\n\\n        M, N = len(matrix), len(matrix[0])\\n        dp = [[0] * N for _  in range(M)]\\n\\n        for i in range(M):\\n            dp[i][0] = 1 if matrix[i][0] == \\'1\\' else 0\\n        \\n        for i in range(M):\\n            for j in range(1, N):\\n                if matrix[i][j] == \\'1\\':\\n                    if dp[i][j - 1]:\\n                        dp[i][j] = dp[i][j - 1] + 1\\n                    else:\\n                        dp[i][j] = 1\\n        \\n        ret = 0\\n        for j in range(N):\\n            column = []\\n            for i in range(M):\\n                column.append(dp[i][j])\\n            \\n            for p in range(len(column)):\\n                left = right = p\\n                val = column[p]\\n\\n                cnt = 1\\n                while left >= 0 and column[left] >= val:\\n                    if left != p:\\n                        cnt += 1\\n                    left -= 1\\n                \\n                while right < len(column) and column[right] >= val:\\n                    if right != p:\\n                        cnt += 1\\n                    right += 1\\n                \\n                ret = max(ret, val * cnt)\\n                        \\n        return ret\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        # 1 0 1 2 3        \\n        # 0 1 0 1 0       \\n        # 1 2 0 1 2\\n        # 1 2 0 1 2\\n        # 0 1 2 3 4\\n\\n        M, N = len(matrix), len(matrix[0])\\n        dp = [[0] * N for _  in range(M)]\\n\\n        for i in range(M):\\n            dp[i][0] = 1 if matrix[i][0] == \\'1\\' else 0\\n        \\n        for i in range(M):\\n            for j in range(1, N):\\n                if matrix[i][j] == \\'1\\':\\n                    if dp[i][j - 1]:\\n                        dp[i][j] = dp[i][j - 1] + 1\\n                    else:\\n                        dp[i][j] = 1\\n        \\n        ret = 0\\n        for j in range(N):\\n            column = []\\n            for i in range(M):\\n                column.append(dp[i][j])\\n            \\n            for p in range(len(column)):\\n                left = right = p\\n                val = column[p]\\n\\n                cnt = 1\\n                while left >= 0 and column[left] >= val:\\n                    if left != p:\\n                        cnt += 1\\n                    left -= 1\\n                \\n                while right < len(column) and column[right] >= val:\\n                    if right != p:\\n                        cnt += 1\\n                    right += 1\\n                \\n                ret = max(ret, val * cnt)\\n                        \\n        return ret\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634280,
                "title": "simple-cpp-o-r-c-solution-using-largest-rectangle-in-histogram-function",
                "content": "\\n```\\n int maxRectangleHistogram(vector<int>h,int n){\\n        stack<int>s;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            while(s.empty()==false && h[s.top()]>=h[i]){\\n                int tp=s.top();\\n                s.pop();\\n                int curr=h[tp]*(s.empty()? i : (i-1-s.top()));\\n                res=max(curr,res);\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty()){\\n            int tp=s.top();\\n            s.pop();\\n            int curr=h[tp]*(s.empty()? n : (n-1-s.top()));\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& mat) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        for(int i=0;i<c;i++){\\n            if(mat[0][i]==\\'1\\')\\n                v.push_back(1);\\n            else v.push_back(0);\\n        }\\n        ans.push_back(v);\\n        for(int i=1;i<r;i++){\\n            vector<int>k;\\n            for(int j=0;j<c;j++){\\n                if(mat[i][j]==\\'1\\')\\n                    k.push_back(1+ans[i-1][j]);\\n                else k.push_back(0);\\n            }\\n            ans.push_back(k);\\n        }\\n        int res=0;\\n        for(int i=0;i<ans.size();i++){\\n           int curr=maxRectangleHistogram(ans[i], ans[i].size());\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n int maxRectangleHistogram(vector<int>h,int n){\\n        stack<int>s;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            while(s.empty()==false && h[s.top()]>=h[i]){\\n                int tp=s.top();\\n                s.pop();\\n                int curr=h[tp]*(s.empty()? i : (i-1-s.top()));\\n                res=max(curr,res);\\n            }\\n            s.push(i);\\n        }\\n        while(!s.empty()){\\n            int tp=s.top();\\n            s.pop();\\n            int curr=h[tp]*(s.empty()? n : (n-1-s.top()));\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    int maximalRectangle(vector<vector<char>>& mat) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        for(int i=0;i<c;i++){\\n            if(mat[0][i]==\\'1\\')\\n                v.push_back(1);\\n            else v.push_back(0);\\n        }\\n        ans.push_back(v);\\n        for(int i=1;i<r;i++){\\n            vector<int>k;\\n            for(int j=0;j<c;j++){\\n                if(mat[i][j]==\\'1\\')\\n                    k.push_back(1+ans[i-1][j]);\\n                else k.push_back(0);\\n            }\\n            ans.push_back(k);\\n        }\\n        int res=0;\\n        for(int i=0;i<ans.size();i++){\\n           int curr=maxRectangleHistogram(ans[i], ans[i].size());\\n            res=max(curr,res);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492426,
                "title": "simple-concise-c-solution-based-on-histogram-o-n-2-time-complexity",
                "content": "### Simple C++ Solution based on histogram question\\n---\\n\\nIf you haven\\'t done histogram question then complete it first because it concept is same just with one extra loop.\\n\\nTime Complexity - O(N^2)\\n\\nSpace Complexity -  O(N)\\n\\n```\\n    int maximalRectangle(vector<vector<char>> &m)\\n    {\\n        int ans = 0;\\n        vector<int> sums(m[0].size(), 0);\\n        for (int i = 0; i < m.size(); i++)\\n        {\\n            // From here histogram solution starts\\n            stack<int> st;\\n            for (int j = 0; j <= sums.size(); j++)\\n            {\\n                // Summing up each row in sums vector but replacing with zero if current element is zero\\n                if(j != sums.size())\\n                    sums[j] += (m[i][j] == \\'0\\') ? -sums[j] : m[i][j] - \\'0\\';\\n                \\n                // Simple increasing Montonic Stack\\n                while (!st.empty() && (j == sums.size() || sums[st.top()] >= sums[j]))\\n                {\\n                    int height = sums[st.top()], width;\\n                    st.pop();\\n                    width = (st.empty()) ? j : j - st.top() - 1;\\n                    ans = max(ans, width * height);\\n                }\\n                st.push(j);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int maximalRectangle(vector<vector<char>> &m)\\n    {\\n        int ans = 0;\\n        vector<int> sums(m[0].size(), 0);\\n        for (int i = 0; i < m.size(); i++)\\n        {\\n            // From here histogram solution starts\\n            stack<int> st;\\n            for (int j = 0; j <= sums.size(); j++)\\n            {\\n                // Summing up each row in sums vector but replacing with zero if current element is zero\\n                if(j != sums.size())\\n                    sums[j] += (m[i][j] == \\'0\\') ? -sums[j] : m[i][j] - \\'0\\';\\n                \\n                // Simple increasing Montonic Stack\\n                while (!st.empty() && (j == sums.size() || sums[st.top()] >= sums[j]))\\n                {\\n                    int height = sums[st.top()], width;\\n                    st.pop();\\n                    width = (st.empty()) ? j : j - st.top() - 1;\\n                    ans = max(ans, width * height);\\n                }\\n                st.push(j);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2355547,
                "title": "c-solution-maximal-rectangle",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(int *arr , int n){\\n        stack<int> st;\\n        st.push(-1);\\n        vector<int> ans(n);\\n        \\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            int curr = arr[i];\\n            \\n            while(st.top() != -1 && arr[st.top()] >= curr){\\n                st.pop();\\n            }\\n            \\n            ans[i] = st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(int *arr , int n){\\n        stack<int> st;\\n        st.push(-1);\\n        vector<int> ans(n);\\n        \\n        for(int i = 0; i < n ; i++){\\n            int curr = arr[i];\\n            \\n            while(st.top() != -1 && arr[st.top()] >= curr){\\n                st.pop();\\n            }\\n            \\n            ans[i] = st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int largestRectangleArea(int * heights , int n){\\n        int area = INT_MIN;\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights , n);\\n        \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights , n);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int length = heights[i];\\n            \\n            if(next[i] == -1)\\n                next[i] = n;\\n            \\n            int breadth = next[i] - prev[i] - 1;\\n            int newArea = length * breadth;\\n            area = max(area , newArea);\\n        }\\n        return area;\\n    }\\n    \\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int M[n][m];\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                M[i][j] = matrix[i][j] - \\'0\\';\\n            }\\n        }\\n                \\n        //step 1 : compute area of 1st row\\n        int area = largestRectangleArea(M[0] , m);\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                \\n        //step 2 : add upar wala element if it is 1\\n                if(M[i][j] != 0)\\n                    M[i][j] = M[i][j] + M[i-1][j];\\n                    \\n                else\\n                    M[i][j] = 0;\\n            }\\n            \\n            area = max(area , largestRectangleArea(M[i] , m));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> nextSmallerElement(int *arr , int n){\\n        stack<int> st;\\n        st.push(-1);\\n        vector<int> ans(n);\\n        \\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            int curr = arr[i];\\n            \\n            while(st.top() != -1 && arr[st.top()] >= curr){\\n                st.pop();\\n            }\\n            \\n            ans[i] = st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement(int *arr , int n){\\n        stack<int> st;\\n        st.push(-1);\\n        vector<int> ans(n);\\n        \\n        for(int i = 0; i < n ; i++){\\n            int curr = arr[i];\\n            \\n            while(st.top() != -1 && arr[st.top()] >= curr){\\n                st.pop();\\n            }\\n            \\n            ans[i] = st.top();\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    int largestRectangleArea(int * heights , int n){\\n        int area = INT_MIN;\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights , n);\\n        \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights , n);\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int length = heights[i];\\n            \\n            if(next[i] == -1)\\n                next[i] = n;\\n            \\n            int breadth = next[i] - prev[i] - 1;\\n            int newArea = length * breadth;\\n            area = max(area , newArea);\\n        }\\n        return area;\\n    }\\n    \\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int M[n][m];\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                M[i][j] = matrix[i][j] - \\'0\\';\\n            }\\n        }\\n                \\n        //step 1 : compute area of 1st row\\n        int area = largestRectangleArea(M[0] , m);\\n        \\n        for(int i = 1 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                \\n        //step 2 : add upar wala element if it is 1\\n                if(M[i][j] != 0)\\n                    M[i][j] = M[i][j] + M[i-1][j];\\n                    \\n                else\\n                    M[i][j] = 0;\\n            }\\n            \\n            area = max(area , largestRectangleArea(M[i] , m));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320046,
                "title": "c-simple-and-easy-approach-problem-similar-to-max-area-rectangle-histogram",
                "content": "Comment down if you have any questions! \\n```\\nclass Solution {\\npublic:\\n      int f(vector<int>& histo) {\\n      stack < int > st;\\n      int maxA = 0;\\n      int n = histo.size();\\n      for (int i = 0; i <= n; i++) {\\n        while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {\\n          int height = histo[st.top()];\\n          st.pop();\\n          int width;\\n          if (st.empty())\\n            width = i;\\n          else\\n            width = i - st.top() - 1;\\n          maxA = max(maxA, width * height);\\n        }\\n        st.push(i);\\n      }\\n      return maxA;\\n \\n\\n        \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int size=matrix[0].size(); \\n        vector<int>v(size,0);\\n        int maxi=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    int ans=v[j]; \\n                    v[j]=ans+1;\\n                }\\n                else{\\n                    v[j]=0;\\n                }\\n            }\\n            \\n            maxi=max(maxi,f(v));\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n      int f(vector<int>& histo) {\\n      stack < int > st;\\n      int maxA = 0;\\n      int n = histo.size();\\n      for (int i = 0; i <= n; i++) {\\n        while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {\\n          int height = histo[st.top()];\\n          st.pop();\\n          int width;\\n          if (st.empty())\\n            width = i;\\n          else\\n            width = i - st.top() - 1;\\n          maxA = max(maxA, width * height);\\n        }\\n        st.push(i);\\n      }\\n      return maxA;\\n \\n\\n        \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int size=matrix[0].size(); \\n        vector<int>v(size,0);\\n        int maxi=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    int ans=v[j]; \\n                    v[j]=ans+1;\\n                }\\n                else{\\n                    v[j]=0;\\n                }\\n            }\\n            \\n            maxi=max(maxi,f(v));\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187181,
                "title": "c-using-maximum-area-rectangle-in-histogram-stack",
                "content": "```\\nclass Solution {\\npublic:\\nint largestRectangleInHistogram(vector<int>& heights) {    \\n        stack<pair<int,int>> s1;\\n        \\n        int n=heights.size();\\n        \\n        //We Will Find Next Smaller element to left and right for all elements in heights vector\\n        \\n        //Nearest Smallest To Left\\n        vector<int> nsl(n,-1);  //To store index to nsl\\n        //if nsl not present default value is -1\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s1.empty() && s1.top().second>=heights[i])\\n                s1.pop();\\n            \\n            if(s1.empty())\\n                nsl[i]=-1;\\n            else \\n                nsl[i]=s1.top().first;\\n            \\n            s1.push({i,heights[i]});\\n        }\\n        \\n        //Nearest Smallest To Right\\n        stack<pair<int,int>> s2;\\n        \\n        vector<int> nsr(n,n);  //To store index to nsr\\n        //if nsr not present default value is n\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s2.empty() && s2.top().second>=heights[i])\\n                s2.pop();\\n            \\n            if(s2.empty())\\n                nsr[i]=n;\\n            else \\n                nsr[i]=s2.top().first;\\n            \\n            s2.push({i,heights[i]});\\n        }\\n        \\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int h=heights[i];\\n            int w=nsr[i]-nsl[i]-1; //Width\\n            int largestArea=w*h;  //Minus Beacuse it is added 2 times \\n            ans=max(ans,largestArea);\\n        }\\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();  //Number of Rows\\n        int n=matrix[0].size();  //size of every row\\n        vector<int> h(n,0);  //Stores 1-d histogram of level row in matrix\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\') h[j]=0;\\n                else h[j]+=1;\\n            }\\n             int area=largestRectangleInHistogram(h);\\n             ans=max(ans,area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint largestRectangleInHistogram(vector<int>& heights) {    \\n        stack<pair<int,int>> s1;\\n        \\n        int n=heights.size();\\n        \\n        //We Will Find Next Smaller element to left and right for all elements in heights vector\\n        \\n        //Nearest Smallest To Left\\n        vector<int> nsl(n,-1);  //To store index to nsl\\n        //if nsl not present default value is -1\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s1.empty() && s1.top().second>=heights[i])\\n                s1.pop();\\n            \\n            if(s1.empty())\\n                nsl[i]=-1;\\n            else \\n                nsl[i]=s1.top().first;\\n            \\n            s1.push({i,heights[i]});\\n        }\\n        \\n        //Nearest Smallest To Right\\n        stack<pair<int,int>> s2;\\n        \\n        vector<int> nsr(n,n);  //To store index to nsr\\n        //if nsr not present default value is n\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!s2.empty() && s2.top().second>=heights[i])\\n                s2.pop();\\n            \\n            if(s2.empty())\\n                nsr[i]=n;\\n            else \\n                nsr[i]=s2.top().first;\\n            \\n            s2.push({i,heights[i]});\\n        }\\n        \\n        \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int h=heights[i];\\n            int w=nsr[i]-nsl[i]-1; //Width\\n            int largestArea=w*h;  //Minus Beacuse it is added 2 times \\n            ans=max(ans,largestArea);\\n        }\\n        return ans;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();  //Number of Rows\\n        int n=matrix[0].size();  //size of every row\\n        vector<int> h(n,0);  //Stores 1-d histogram of level row in matrix\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\') h[j]=0;\\n                else h[j]+=1;\\n            }\\n             int area=largestRectangleInHistogram(h);\\n             ans=max(ans,area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148614,
                "title": "c-simple-histogram-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int max(int a,int b) {\\n        return a>b ? a: b;\\n    }\\n    int max_histgram_area(int *arr,int n) {\\n        int ans=0;\\n        stack<int>s;\\n        int tp,max_area_with_tp;\\n        int i=0;\\n        while(i<n) {\\n            if(s.empty() || arr[s.top()]<=arr[i]) {\\n                s.push(i++);\\n            } else {\\n                tp=s.top(); \\n                s.pop();\\n                max_area_with_tp = arr[tp] * (s.empty() ? i : i-s.top()-1);\\n                ans= max(ans,max_area_with_tp);\\n            }\\n        }\\n        \\n        while(s.empty() == false) {\\n            tp=s.top(); \\n            s.pop();\\n            max_area_with_tp = arr[tp] * (s.empty() ? i : i-s.top()-1);\\n            ans= max(ans,max_area_with_tp);\\n        }\\n        return ans;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        long long int ans=0;\\n        int arr[201]= {0};\\n        for(int i=0;i<matrix.size();i++) {\\n            for(int j=0;j<matrix[0].size();j++) {\\n                if(matrix[i][j] == \\'0\\') {\\n                    arr[j]=0;\\n                }\\n                else {\\n                    arr[j]++;\\n                }\\n            }\\n            int tmp = max_histgram_area(arr, matrix[0].size());\\n            if(tmp>ans) ans=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max(int a,int b) {\\n        return a>b ? a: b;\\n    }\\n    int max_histgram_area(int *arr,int n) {\\n        int ans=0;\\n        stack<int>s;\\n        int tp,max_area_with_tp;\\n        int i=0;\\n        while(i<n) {\\n            if(s.empty() || arr[s.top()]<=arr[i]) {\\n                s.push(i++);\\n            } else {\\n                tp=s.top(); \\n                s.pop();\\n                max_area_with_tp = arr[tp] * (s.empty() ? i : i-s.top()-1);\\n                ans= max(ans,max_area_with_tp);\\n            }\\n        }\\n        \\n        while(s.empty() == false) {\\n            tp=s.top(); \\n            s.pop();\\n            max_area_with_tp = arr[tp] * (s.empty() ? i : i-s.top()-1);\\n            ans= max(ans,max_area_with_tp);\\n        }\\n        return ans;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        long long int ans=0;\\n        int arr[201]= {0};\\n        for(int i=0;i<matrix.size();i++) {\\n            for(int j=0;j<matrix[0].size();j++) {\\n                if(matrix[i][j] == \\'0\\') {\\n                    arr[j]=0;\\n                }\\n                else {\\n                    arr[j]++;\\n                }\\n            }\\n            int tmp = max_histgram_area(arr, matrix[0].size());\\n            if(tmp>ans) ans=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127018,
                "title": "using-stack-with-reference-to-nearest-smallest-element-to-left-right",
                "content": "*Time : O(Mx2N) & space O(N)*\\n\\n```\\nclass Solution {\\nprivate:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<pair<int, int>> st;\\n        int n = heights.size();\\n        vector<int> nsl(n), nsr(n), area;\\n        for(int i=0; i<n; i++) {  // Nearest Smallest Element to Left\\n            while(!st.empty() && st.top().first >= heights[i]) st.pop();\\n            if(st.empty()) nsl[i] = -1;\\n            else nsl[i] = st.top().second;\\n            st.push({heights[i], i});\\n        }\\n        while(!st.empty()) st.pop();\\n        for(int i=n-1; i>=0; i--) { // Nearest Smallest Element to Right\\n            while(!st.empty() && st.top().first >= heights[i]) st.pop();\\n            if(st.empty()) nsr[i] = n;\\n            else nsr[i] = st.top().second;\\n            st.push({heights[i], i});\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            int width = nsr[i]-nsl[i]-1;\\n            area.push_back(heights[i]*width);\\n            ans = max(ans, area[i]);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int area = 0;\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> heights(n, 0);\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(matrix[i][j] == \\'1\\') heights[j]++;\\n                else heights[j] = 0;\\n            }\\n            area = max(area, largestRectangleArea(heights));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<pair<int, int>> st;\\n        int n = heights.size();\\n        vector<int> nsl(n), nsr(n), area;\\n        for(int i=0; i<n; i++) {  // Nearest Smallest Element to Left\\n            while(!st.empty() && st.top().first >= heights[i]) st.pop();\\n            if(st.empty()) nsl[i] = -1;\\n            else nsl[i] = st.top().second;\\n            st.push({heights[i], i});\\n        }\\n        while(!st.empty()) st.pop();\\n        for(int i=n-1; i>=0; i--) { // Nearest Smallest Element to Right\\n            while(!st.empty() && st.top().first >= heights[i]) st.pop();\\n            if(st.empty()) nsr[i] = n;\\n            else nsr[i] = st.top().second;\\n            st.push({heights[i], i});\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            int width = nsr[i]-nsl[i]-1;\\n            area.push_back(heights[i]*width);\\n            ans = max(ans, area[i]);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int area = 0;\\n        int m = matrix.size(), n = matrix[0].size();\\n        vector<int> heights(n, 0);\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(matrix[i][j] == \\'1\\') heights[j]++;\\n                else heights[j] = 0;\\n            }\\n            area = max(area, largestRectangleArea(heights));\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106878,
                "title": "c-easy-solution-extension-to-largest-rectangle-in-histogram",
                "content": "```\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n        \\n  vector<int> prevNearestSmaller(vector<int>&arr,int &n){\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            while(s.top()!=-1 && arr[s.top()]>=arr[i])s.pop();\\n            \\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n     vector<int> nextNearestSmaller(vector<int>&arr,int &n){\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int>ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(s.top()!=-1 && arr[s.top()]>=arr[i])s.pop();\\n            \\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n\\n    int MAH(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int>prev(n);\\n        prev = prevNearestSmaller(arr,n);\\n        \\n        vector<int>next(n);\\n        next=nextNearestSmaller(arr,n);\\n        int area = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int l =arr[i];\\n            \\n            if(next[i]==-1)next[i]=n;\\n            int b = next[i]-prev[i]-1;\\n            area = max(area,l*b);\\n        }\\n        return area;\\n        \\n    }\\n   int maximalRectangle(vector<vector<char>>& v) {\\n        \\n        vector<int> l(v[0].size(), 0);\\n        int mx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[0].size();j++)\\n            {\\n                if(v[i][j]==\\'0\\')\\n                   l[j]=0;\\n                else\\n                {\\n                    l[j]=l[j]+1;\\n                }\\n            }\\n            mx=max(mx,MAH(l));\\n        }\\n         return mx;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n        \\n  vector<int> prevNearestSmaller(vector<int>&arr,int &n){\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            while(s.top()!=-1 && arr[s.top()]>=arr[i])s.pop();\\n            \\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n     vector<int> nextNearestSmaller(vector<int>&arr,int &n){\\n        stack<int>s;\\n        s.push(-1);\\n        vector<int>ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(s.top()!=-1 && arr[s.top()]>=arr[i])s.pop();\\n            \\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n        \\n    }\\n\\n    int MAH(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int>prev(n);\\n        prev = prevNearestSmaller(arr,n);\\n        \\n        vector<int>next(n);\\n        next=nextNearestSmaller(arr,n);\\n        int area = INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int l =arr[i];\\n            \\n            if(next[i]==-1)next[i]=n;\\n            int b = next[i]-prev[i]-1;\\n            area = max(area,l*b);\\n        }\\n        return area;\\n        \\n    }\\n   int maximalRectangle(vector<vector<char>>& v) {\\n        \\n        vector<int> l(v[0].size(), 0);\\n        int mx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[0].size();j++)\\n            {\\n                if(v[i][j]==\\'0\\')\\n                   l[j]=0;\\n                else\\n                {\\n                    l[j]=l[j]+1;\\n                }\\n            }\\n            mx=max(mx,MAH(l));\\n        }\\n         return mx;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095042,
                "title": "efficient-c-solution-using-histogram-area-stack",
                "content": "***Solution using Largest Histogram Area Concept :*** \\n```\\nclass Solution {\\n    int maxHistogramArea(vector<int>& heights,int n){\\n\\t\\n\\t// TC -> O(M*(N+M))\\n\\t// SC -> O(N)\\n\\n    stack<int>stk;\\n    int maxArea{};\\n    \\n    for(int i=0;i<=n;i++){\\n        while(!stk.empty() && (i==n || (heights[stk.top()]>=heights[i]))){\\n            int height=heights[stk.top()];\\n            stk.pop();\\n            \\n            int width;\\n            if(stk.empty()) width=i;\\n            else width=i-stk.top()-1;\\n            \\n            maxArea=max(maxArea, height*width);\\n        }\\n        stk.push(i);\\n    }\\n    return maxArea;\\n}\\npublic:\\n    int maximalRectangle(vector<vector<char>>& mat) {\\n        int maxArea{};\\n        int n=mat.size(), m=mat[0].size();\\n        vector<int> dp(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==\\'1\\') dp[j]++;\\n                else dp[j]=0;\\n            }\\n            maxArea=max(maxArea,maxHistogramArea(dp,m));\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    int maxHistogramArea(vector<int>& heights,int n){\\n\\t\\n\\t// TC -> O(M*(N+M))\\n\\t// SC -> O(N)\\n\\n    stack<int>stk;\\n    int maxArea{};\\n    \\n    for(int i=0;i<=n;i++){\\n        while(!stk.empty() && (i==n || (heights[stk.top()]>=heights[i]))){\\n            int height=heights[stk.top()];\\n            stk.pop();\\n            \\n            int width;\\n            if(stk.empty()) width=i;\\n            else width=i-stk.top()-1;\\n            \\n            maxArea=max(maxArea, height*width);\\n        }\\n        stk.push(i);\\n    }\\n    return maxArea;\\n}\\npublic:\\n    int maximalRectangle(vector<vector<char>>& mat) {\\n        int maxArea{};\\n        int n=mat.size(), m=mat[0].size();\\n        vector<int> dp(m,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==\\'1\\') dp[j]++;\\n                else dp[j]=0;\\n            }\\n            maxArea=max(maxArea,maxHistogramArea(dp,m));\\n        }\\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935921,
                "title": "short-and-simple-using-largest-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\nprivate:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size(), maxA = 0, h, w;\\n        stack<int> s;\\n\\n        for (int i = 0; i <= n; i++) {\\n            while (!s.empty() && (i == n || heights[i] <= heights[s.top()])) {\\n                h = heights[s.top()];   s.pop();\\n                if (s.empty())  w = i;\\n                else    w = i - s.top() - 1;\\n                maxA = max(maxA, h * w);\\n            }\\n            s.push(i);\\n        }\\n        return maxA;\\n    }\\n\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int ans = INT_MIN, r = matrix.size(), c = matrix[0].size();\\n        vector<int> heights(c);\\n\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == \\'1\\')  heights[j]++;\\n                else    heights[j] = 0;\\n            }\\n            int area = largestRectangleArea(heights);\\n            ans = max(ans, area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size(), maxA = 0, h, w;\\n        stack<int> s;\\n\\n        for (int i = 0; i <= n; i++) {\\n            while (!s.empty() && (i == n || heights[i] <= heights[s.top()])) {\\n                h = heights[s.top()];   s.pop();\\n                if (s.empty())  w = i;\\n                else    w = i - s.top() - 1;\\n                maxA = max(maxA, h * w);\\n            }\\n            s.push(i);\\n        }\\n        return maxA;\\n    }\\n\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int ans = INT_MIN, r = matrix.size(), c = matrix[0].size();\\n        vector<int> heights(c);\\n\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == \\'1\\')  heights[j]++;\\n                else    heights[j] = 0;\\n            }\\n            int area = largestRectangleArea(heights);\\n            ans = max(ans, area);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872578,
                "title": "brute-force-to-optimal",
                "content": "**Brute Force** :- \\n\\n**Time Complexity** :- O((n * m) ^ 3)\\n\\n**Java Code** :- \\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        // create all rectangles\\n        // check whether there is a zero in that or not\\n        // if not, calculate its area\\n        // return the maximum area out of it\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        \\n        int maxArea = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                // coordinates of the top left corner of the rectangle\\n                int startingX = i;\\n                int startingY = j;\\n                \\n                for(int k = i; k < n; k++) {\\n                    for(int l = j ; l < m; l++) {\\n                        // coordinates of the bottom right corner of the rectangle\\n                        int endingX = k;\\n                        int endingY = l;\\n                        \\n                        // check whether its contains only one\\n                        if(isEligible(matrix, startingX, startingY, endingX, endingY)) {\\n                            maxArea = Math.max(maxArea, (endingX - startingX + 1) * (endingY - startingY + 1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public static boolean isEligible(char[][] arr, int startingX, int startingY, int endingX, int endingY) {\\n        for(int i = startingX; i <= endingX; i++) {\\n            for(int j = startingY; j <= endingY; j++) {\\n                if(arr[i][j] == \\'0\\') {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\n**Optimal** :- use Max Area of rectangle in a histogram logic on each row but after adding all the top 1\\'s in the current value if current value  is not zero.\\n\\n**Time Complexity** :- O(n * m)\\n\\n**Java Code** :- \\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        \\n        int maxArea = 0;\\n        \\n        // calculate the max area of rectangle for the topmost row\\n        int[] initialRow = new int[m];\\n        for(int i = 0; i < m; i++) {\\n            initialRow[i] = matrix[0][i] - \\'0\\';\\n        }\\n       \\n        maxArea = Math.max(maxAreaOfHistogram(initialRow), maxArea);\\n        \\n        // calculate max area of rectangle for all the remaining row\\n        for(int i = 1; i < n; i++) {\\n            int[] currentRow = new int[m];\\n            \\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] != \\'0\\')\\n                currentRow[j] = matrix[i][j] - \\'0\\' + initialRow[j];\\n            }\\n            \\n            maxArea = Math.max(maxArea, maxAreaOfHistogram(currentRow));\\n            \\n            // to reduce the time complexity for adding all the previous 1\\'s\\n            initialRow = currentRow;\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public static int maxAreaOfHistogram(int[] arr) {\\n        \\n        int[] leftSmallerIndex = findLeftSmallerIndex(arr);\\n        int[] rightSmallerIndex = findRightSmallerIndex(arr);\\n        \\n        int maxArea = 0;\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            maxArea = Math.max(maxArea, (rightSmallerIndex[i] - leftSmallerIndex[i] - 1) * arr[i]);\\n        }\\n        return maxArea;\\n    }\\n    \\n    public static int[] findLeftSmallerIndex(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        st.push(0);\\n        \\n        ans[0] = -1;\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            while(st.size() != 0 && arr[st.peek()] >= arr[i]) {\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0) {\\n                ans[i] = -1;\\n            } else {\\n                ans[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public static int[] findRightSmallerIndex(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        st.push(arr.length - 1);\\n        \\n        ans[arr.length - 1] = arr.length;\\n        \\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            while(st.size() != 0 && arr[st.peek()] >= arr[i]) {\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0) {\\n                ans[i] = arr.length;\\n            } else {\\n                ans[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**Need to convert char array into int array** :- \\n* let say if the no. of ones above a particular point is >= 10 then if we will put this into a char array then our ans will not be correct",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        // create all rectangles\\n        // check whether there is a zero in that or not\\n        // if not, calculate its area\\n        // return the maximum area out of it\\n        \\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        \\n        int maxArea = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                // coordinates of the top left corner of the rectangle\\n                int startingX = i;\\n                int startingY = j;\\n                \\n                for(int k = i; k < n; k++) {\\n                    for(int l = j ; l < m; l++) {\\n                        // coordinates of the bottom right corner of the rectangle\\n                        int endingX = k;\\n                        int endingY = l;\\n                        \\n                        // check whether its contains only one\\n                        if(isEligible(matrix, startingX, startingY, endingX, endingY)) {\\n                            maxArea = Math.max(maxArea, (endingX - startingX + 1) * (endingY - startingY + 1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public static boolean isEligible(char[][] arr, int startingX, int startingY, int endingX, int endingY) {\\n        for(int i = startingX; i <= endingX; i++) {\\n            for(int j = startingY; j <= endingY; j++) {\\n                if(arr[i][j] == \\'0\\') {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        \\n        int maxArea = 0;\\n        \\n        // calculate the max area of rectangle for the topmost row\\n        int[] initialRow = new int[m];\\n        for(int i = 0; i < m; i++) {\\n            initialRow[i] = matrix[0][i] - \\'0\\';\\n        }\\n       \\n        maxArea = Math.max(maxAreaOfHistogram(initialRow), maxArea);\\n        \\n        // calculate max area of rectangle for all the remaining row\\n        for(int i = 1; i < n; i++) {\\n            int[] currentRow = new int[m];\\n            \\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] != \\'0\\')\\n                currentRow[j] = matrix[i][j] - \\'0\\' + initialRow[j];\\n            }\\n            \\n            maxArea = Math.max(maxArea, maxAreaOfHistogram(currentRow));\\n            \\n            // to reduce the time complexity for adding all the previous 1\\'s\\n            initialRow = currentRow;\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    public static int maxAreaOfHistogram(int[] arr) {\\n        \\n        int[] leftSmallerIndex = findLeftSmallerIndex(arr);\\n        int[] rightSmallerIndex = findRightSmallerIndex(arr);\\n        \\n        int maxArea = 0;\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            maxArea = Math.max(maxArea, (rightSmallerIndex[i] - leftSmallerIndex[i] - 1) * arr[i]);\\n        }\\n        return maxArea;\\n    }\\n    \\n    public static int[] findLeftSmallerIndex(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        st.push(0);\\n        \\n        ans[0] = -1;\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            while(st.size() != 0 && arr[st.peek()] >= arr[i]) {\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0) {\\n                ans[i] = -1;\\n            } else {\\n                ans[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public static int[] findRightSmallerIndex(int[] arr) {\\n        int[] ans = new int[arr.length];\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        st.push(arr.length - 1);\\n        \\n        ans[arr.length - 1] = arr.length;\\n        \\n        for(int i = arr.length - 2; i >= 0; i--) {\\n            while(st.size() != 0 && arr[st.peek()] >= arr[i]) {\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0) {\\n                ans[i] = arr.length;\\n            } else {\\n                ans[i] = st.peek();\\n            }\\n            \\n            st.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788708,
                "title": "my-dp-solution-using-largest-rectangle-in-histogram",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestArea(vector<int> &A){\\n        A.push_back(0);\\n        int n = A.size();\\n        stack<int> s;\\n        int i=0;\\n        int max_area = 0;\\n        while(i<n){\\n            if(s.empty()||A[i]>=A[s.top()]) s.push(i++);\\n            else{\\n                int h = s.top();\\n                s.pop();\\n                max_area = max(max_area, A[h]*(s.empty()?i:i-s.top()-1));\\n             }\\n        }\\n        return max_area;\\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int largestArea(vector<int> &A){\\n        A.push_back(0);\\n        int n = A.size();\\n        stack<int> s;\\n        int i=0;\\n        int max_area = 0;\\n        while(i<n){\\n            if(s.empty()||A[i]>=A[s.top()]) s.push(i++);\\n            else{\\n                int h = s.top();\\n                s.pop();\\n                max_area = max(max_area, A[h]*(s.empty()?i:i-s.top()-1));\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1785827,
                "title": "maximal-rectangle-solution-java",
                "content": "class Solution {\\n  public int maximalRectangle(char[][] matrix) {\\n    if (matrix.length == 0)\\n      return 0;\\n\\n    int ans = 0;\\n    int[] hist = new int[matrix[0].length];\\n\\n    for (char[] row : matrix) {\\n      for (int i = 0; i < row.length; ++i)\\n        hist[i] = row[i] == \\'0\\' ? 0 : hist[i] + 1;\\n      ans = Math.max(ans, largestRectangleArea(hist));\\n    }\\n\\n    return ans;\\n  }\\n\\n  private int largestRectangleArea(int[] heights) {\\n    int ans = 0;\\n    Stack<Integer> stack = new Stack<>();\\n\\n    for (int i = 0; i <= heights.length; ++i) {\\n      while (!stack.isEmpty() && (i == heights.length || heights[stack.peek()] > heights[i])) {\\n        final int h = heights[stack.pop()];\\n        final int w = stack.isEmpty() ? i : i - stack.peek() - 1;\\n        ans = Math.max(ans, h * w);\\n      }\\n      stack.push(i);\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Stack",
                    "Matrix",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n  public int maximalRectangle(char[][] matrix) {\\n    if (matrix.length == 0)\\n      return 0;\\n\\n    int ans = 0;\\n    int[] hist = new int[matrix[0].length];\\n\\n    for (char[] row : matrix) {\\n      for (int i = 0; i < row.length; ++i)\\n        hist[i] = row[i] == \\'0\\' ? 0 : hist[i] + 1;\\n      ans = Math.max(ans, largestRectangleArea(hist));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1757359,
                "title": "converting-2d-array-to-1d-and-checking-maximus",
                "content": "```\\nclass Solution {\\npublic:\\n    // copy pasting from 84. Largest Rectangle in Histogram\\n    int largestRectangleArea(vector<int>& heights) {\\n        vector<int>NSL(heights.size());\\n        stack<int>st;\\n        \\n        //for next smaller left(indexes)\\n        for(int i=0;i<heights.size();i++){\\n        while( !st.empty() && heights[i] <= heights[st.top()] ) st.pop();\\n            (st.empty()) ? NSL[i]=-1 : NSL[i]= st.top();\\n            st.push(i);\\n        }\\n        stack<int>t;\\n        st=t;\\n        int ans = 0;\\n        for(int i=heights.size()-1;i>=0;i--){\\n        while( !st.empty() && heights[i] <= heights[st.top()] ) st.pop();\\n            \\n            if(st.empty()) {\\n                int m = heights.size() - NSL[i] - 1;\\n            ans = max(ans , m*heights[i]);\\n            }\\n                 \\n            else{\\n                int m = st.top()-NSL[i]-1;\\n                ans= max(ans,m*heights[i] );\\n            } \\n            st.push(i);\\n        }\\n            return ans;\\n    }\\n    ///\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        vector<int>Temp(matrix[0].size(),0);\\n        int ans = 0 ;\\n        // converting 2d matrix to a 1d array(Temp) and checking maximum\\n        for(auto row : matrix){\\n            for(int i = 0; i<row.size();i++){\\n                (row[i]==\\'0\\')?Temp[i]=0 : Temp[i]++;\\n            }\\n                ans = max(ans,largestRectangleArea(Temp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // copy pasting from 84. Largest Rectangle in Histogram\\n    int largestRectangleArea(vector<int>& heights) {\\n        vector<int>NSL(heights.size());\\n        stack<int>st;\\n        \\n        //for next smaller left(indexes)\\n        for(int i=0;i<heights.size();i++){\\n        while( !st.empty() && heights[i] <= heights[st.top()] ) st.pop();\\n            (st.empty()) ? NSL[i]=-1 : NSL[i]= st.top();\\n            st.push(i);\\n        }\\n        stack<int>t;\\n        st=t;\\n        int ans = 0;\\n        for(int i=heights.size()-1;i>=0;i--){\\n        while( !st.empty() && heights[i] <= heights[st.top()] ) st.pop();\\n            \\n            if(st.empty()) {\\n                int m = heights.size() - NSL[i] - 1;\\n            ans = max(ans , m*heights[i]);\\n            }\\n                 \\n            else{\\n                int m = st.top()-NSL[i]-1;\\n                ans= max(ans,m*heights[i] );\\n            } \\n            st.push(i);\\n        }\\n            return ans;\\n    }\\n    ///\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        \\n        vector<int>Temp(matrix[0].size(),0);\\n        int ans = 0 ;\\n        // converting 2d matrix to a 1d array(Temp) and checking maximum\\n        for(auto row : matrix){\\n            for(int i = 0; i<row.size();i++){\\n                (row[i]==\\'0\\')?Temp[i]=0 : Temp[i]++;\\n            }\\n                ans = max(ans,largestRectangleArea(Temp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736123,
                "title": "c-code-time-o-row-col",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& arr) {\\n       int n = arr.size();\\n       int m = arr[0].size();\\n       int dp[n][m+1];\\n       for(int i = 0; i<n; i++)\\n       {\\n           for(int j=0; j<m; j++)\\n           {\\n               if(i == 0)\\n               {\\n                   dp[i][j] = arr[i][j]-\\'0\\';\\n               }\\n               else\\n               {\\n                   if(arr[i][j] == \\'0\\')\\n                   dp[i][j] = 0;\\n                   else\\n                   dp[i][j] = dp[i-1][j] +1; \\n               }\\n           }\\n       }\\n       for(int i=0; i<n; i++)\\n       {\\n         dp[i][m] = 0;\\n       }\\n\\n       int ans = 0;\\n       for(int i=0; i<n; i++)\\n       {\\n           stack<int> st;\\n           for(int j = 0; j<=m; j++)\\n           {\\n               while(!st.empty() && dp[i][st.top()]>dp[i][j])\\n               {\\n                  int t = st.top();\\n                  st.pop();\\n                  int h = dp[i][t];\\n                  if(st.empty())\\n                  ans = max(ans, h*j);\\n                  else\\n                  {\\n                      int len = j - st.top() - 1;\\n                      ans = max(ans, len*h);\\n                  }\\n               }\\n               st.push(j);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& arr) {\\n       int n = arr.size();\\n       int m = arr[0].size();\\n       int dp[n][m+1];\\n       for(int i = 0; i<n; i++)\\n       {\\n           for(int j=0; j<m; j++)\\n           {\\n               if(i == 0)\\n               {\\n                   dp[i][j] = arr[i][j]-\\'0\\';\\n               }\\n               else\\n               {\\n                   if(arr[i][j] == \\'0\\')\\n                   dp[i][j] = 0;\\n                   else\\n                   dp[i][j] = dp[i-1][j] +1; \\n               }\\n           }\\n       }\\n       for(int i=0; i<n; i++)\\n       {\\n         dp[i][m] = 0;\\n       }\\n\\n       int ans = 0;\\n       for(int i=0; i<n; i++)\\n       {\\n           stack<int> st;\\n           for(int j = 0; j<=m; j++)\\n           {\\n               while(!st.empty() && dp[i][st.top()]>dp[i][j])\\n               {\\n                  int t = st.top();\\n                  st.pop();\\n                  int h = dp[i][t];\\n                  if(st.empty())\\n                  ans = max(ans, h*j);\\n                  else\\n                  {\\n                      int len = j - st.top() - 1;\\n                      ans = max(ans, len*h);\\n                  }\\n               }\\n               st.push(j);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702443,
                "title": "c-o-n-m-time-o-n-m-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& A) {\\n        int n = A.size(), m = A[0].size();\\n        \\n        // dp[i][j] denotes the number of consecutive ones below (i, j) starting from (i, j)\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for (int j = 0; j < m; j++) {\\n            for (int i = n - 1; i >= 0; i--) {\\n                if (A[i][j] == \\'0\\')\\n                    dp[i][j] = 0;\\n                else\\n                    dp[i][j] = 1 + (i + 1 < n ? dp[i + 1][j] : 0);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for (auto &row : dp) {\\n            \\n            stack<int> st;\\n            \\n            // left[j] = k, is the closest element to the left of j such that row[k] < row[j]\\n            vector<int> left(m);\\n            for (int j = 0; j < m; j++) {\\n                \\n                // get rid of all the equal or larger elements for we need the smaller element to the left\\n                while (!st.empty() && row[st.top()] >= row[j]) {\\n                    st.pop();\\n                }\\n            \\n                left[j] = st.empty() ? -1 : st.top();\\n                st.push(j);\\n            }\\n            \\n            // empty the stack for further usage\\n            while (!st.empty()) {\\n                st.pop();\\n            }\\n            \\n            // right[j] = k, is the closest element to the right of j such that row[k] < row[j]\\n            vector<int> right(m);\\n            for (int j = m - 1; j >= 0; j--) {\\n                \\n                // get rid of all the equal or larger elements for we need the smaller element to the right\\n                while (!st.empty() && row[st.top()] >= row[j]) {\\n                    st.pop();\\n                }\\n                \\n                right[j] = st.empty() ? m : st.top();\\n\\n                st.push(j);\\n            }\\n            \\n            for (int j = 0; j < m; j++) {\\n                \\n                // height of the rectangle is row[j]\\n                // width of the rectangle is right[j] - left[j] - 1 \\n                // both right[j] and left[j] are not included\\n                int cur = row[j] * (right[j] - left[j] - 1);\\n                ans = max(ans, cur);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& A) {\\n        int n = A.size(), m = A[0].size();\\n        \\n        // dp[i][j] denotes the number of consecutive ones below (i, j) starting from (i, j)\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for (int j = 0; j < m; j++) {\\n            for (int i = n - 1; i >= 0; i--) {\\n                if (A[i][j] == \\'0\\')\\n                    dp[i][j] = 0;\\n                else\\n                    dp[i][j] = 1 + (i + 1 < n ? dp[i + 1][j] : 0);\\n            }\\n        }\\n        \\n        int ans = 0;\\n        \\n        for (auto &row : dp) {\\n            \\n            stack<int> st;\\n            \\n            // left[j] = k, is the closest element to the left of j such that row[k] < row[j]\\n            vector<int> left(m);\\n            for (int j = 0; j < m; j++) {\\n                \\n                // get rid of all the equal or larger elements for we need the smaller element to the left\\n                while (!st.empty() && row[st.top()] >= row[j]) {\\n                    st.pop();\\n                }\\n            \\n                left[j] = st.empty() ? -1 : st.top();\\n                st.push(j);\\n            }\\n            \\n            // empty the stack for further usage\\n            while (!st.empty()) {\\n                st.pop();\\n            }\\n            \\n            // right[j] = k, is the closest element to the right of j such that row[k] < row[j]\\n            vector<int> right(m);\\n            for (int j = m - 1; j >= 0; j--) {\\n                \\n                // get rid of all the equal or larger elements for we need the smaller element to the right\\n                while (!st.empty() && row[st.top()] >= row[j]) {\\n                    st.pop();\\n                }\\n                \\n                right[j] = st.empty() ? m : st.top();\\n\\n                st.push(j);\\n            }\\n            \\n            for (int j = 0; j < m; j++) {\\n                \\n                // height of the rectangle is row[j]\\n                // width of the rectangle is right[j] - left[j] - 1 \\n                // both right[j] and left[j] are not included\\n                int cur = row[j] * (right[j] - left[j] - 1);\\n                ans = max(ans, cur);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605532,
                "title": "java-visually-explained-reuse-largest-rectangle-in-histogram",
                "content": "**Idea:** Bottom-Up DP. Reuse [LC 84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1604136/Java-or-Linear-Time-and-Space)\\n* Maximal rectangle (MR) is formed by 1s in rectangles\\n* Moving from top to bottom rows, if a 0 is found in any row then that column will break the rectangle formation, therefore the area for that MR will be 0 i.e. there will be no MR\\n* However if a 1 is found, then size of the column increases by 1\\n* Considering this problem row wise, columns of 1s are formed in the table with certain heights. We need to find the MR across these columns. Now this problem reduces to [LC 84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1604136/Java-or-Linear-Time-and-Space). Please solve that before this one.\\n* Since we need to find the heights of columns of 1s, with rows accumulating in each iteration, we have both overlapping sub-problems and optimals substructure\\n* IMO, in matrix problems, tabulation (bottom-up DP) is more intuitive than memoization.\\n\\n![image](https://assets.leetcode.com/users/images/64bd1b7e-86cb-4ef7-8460-92a53cb3a17d_1638338198.604553.png)\\n> **T/S:** O(mn)/O(n), where m and n are row and colum size of the matrix\\n ```\\npublic int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0 || matrix[0].length == 0)\\n                return 0;\\n        var dp = new int[matrix[0].length];\\n        var maxArea = 0;\\n\\n        for (var row : matrix) {\\n                for (var j = 0; j < matrix[0].length; j++)\\n                        dp[j] = (row[j] == \\'1\\') ? dp[j] + 1 : 0;\\n                maxArea = Math.max(maxArea, largestRectangleArea(dp));\\n        }\\n        return maxArea;\\n}\\n\\n// This method is straight copied from LC 84\\nprivate int largestRectangleArea(int[] heights) {\\n        var n = heights.length;\\n        var leftSmaller = new int[n];\\n        var rightSmaller = new int[n];\\n        leftSmaller[0] = -1;\\n        rightSmaller[n - 1] = n;\\n\\n        for (var i = 1; i < n; i++) {\\n\\t\\t\\tvar j = i - 1;\\n\\t\\t\\twhile (j >= 0 && heights[j] >= heights[i])\\n\\t\\t\\t\\tj = leftSmaller[j];\\n\\t\\t\\tleftSmaller[i] = j;\\n        }\\n\\n        for (var i = n - 2; i >= 0; i--) {\\n\\t\\t\\tvar j = i + 1;\\n\\t\\t\\twhile (j < n && heights[j] >= heights[i])\\n\\t\\t\\t\\tj = rightSmaller[j];\\n\\t\\t\\trightSmaller[i] = j;\\n        }\\n\\n        var maxArea = 0;\\n        for (var i = 0; i < n; i++)\\n\\t\\t\\tmaxArea = Math.max(maxArea, heights[i] * (rightSmaller[i] - leftSmaller[i] - 1));\\n        return maxArea;\\n}\\n```\\n***Please upvote if this helps***\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximalRectangle(char[][] matrix) {\\n        if (matrix.length == 0 || matrix[0].length == 0)\\n                return 0;\\n        var dp = new int[matrix[0].length];\\n        var maxArea = 0;\\n\\n        for (var row : matrix) {\\n                for (var j = 0; j < matrix[0].length; j++)\\n                        dp[j] = (row[j] == \\'1\\') ? dp[j] + 1 : 0;\\n                maxArea = Math.max(maxArea, largestRectangleArea(dp));\\n        }\\n        return maxArea;\\n}\\n\\n// This method is straight copied from LC 84\\nprivate int largestRectangleArea(int[] heights) {\\n        var n = heights.length;\\n        var leftSmaller = new int[n];\\n        var rightSmaller = new int[n];\\n        leftSmaller[0] = -1;\\n        rightSmaller[n - 1] = n;\\n\\n        for (var i = 1; i < n; i++) {\\n\\t\\t\\tvar j = i - 1;\\n\\t\\t\\twhile (j >= 0 && heights[j] >= heights[i])\\n\\t\\t\\t\\tj = leftSmaller[j];\\n\\t\\t\\tleftSmaller[i] = j;\\n        }\\n\\n        for (var i = n - 2; i >= 0; i--) {\\n\\t\\t\\tvar j = i + 1;\\n\\t\\t\\twhile (j < n && heights[j] >= heights[i])\\n\\t\\t\\t\\tj = rightSmaller[j];\\n\\t\\t\\trightSmaller[i] = j;\\n        }\\n\\n        var maxArea = 0;\\n        for (var i = 0; i < n; i++)\\n\\t\\t\\tmaxArea = Math.max(maxArea, heights[i] * (rightSmaller[i] - leftSmaller[i] - 1));\\n        return maxArea;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604047,
                "title": "c-stack-using-nse-same-as-leetcode-84th-prob",
                "content": "```\\nclass Solution {\\npublic:\\n      void NSER(vector<int>& v,vector<int>& height){\\n          stack<int> st;\\n          st.push(0);\\n\\n          int i=1;\\n          while(i<height.size()){\\n              if(height[i]>=height[st.top()]){st.push(i++);}\\n              else{\\n                  while(!st.empty() && height[st.top()]>height[i]){\\n                      v[st.top()]=i-1;\\n                      st.pop();\\n                  }\\n                    st.push(i++);\\n              }\\n          }\\n               if(st.size()){\\n                   while(!st.empty()){\\n                       v[st.top()]=height.size()-1;\\n                       st.pop();\\n                   }\\n               }\\n\\n}\\n\\nvoid NSEL(vector<int>& v1, vector<int>&height){\\n        stack<int> st;\\n          st.push(height.size()-1);\\n\\n          int i=height.size()-2;\\n          while(i>=0){\\n              if(height[i]>=height[st.top()]){st.push(i--);}\\n              else{\\n                  while(!st.empty() && height[st.top()]>height[i]){\\n                      v1[st.top()]=i+1;\\n                      st.pop();\\n                  }\\n                    st.push(i--);\\n              }\\n          }\\n               if(st.size()){\\n                   while(!st.empty()){\\n                       v1[st.top()]=0;\\n                       st.pop();\\n                   }\\n               }\\n}\\n    int larRectInHisto(vector<int>& heights){\\n         int res=0;\\n      int n=heights.size();\\n        if(n==1) return heights[0];\\n        vector<int> rmIdx(n,0);\\n        vector<int> lmIdx(n,0);\\n        \\n        NSER(rmIdx,heights);\\n        NSEL(lmIdx,heights);\\n        \\n        for(int i=0; i<n; i++){\\n            res=max(res,heights[i]*abs(rmIdx[i]-lmIdx[i]+1));\\n        }\\n          return res;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(!matrix.size()) return 0;\\n        vector<int>v(matrix[0].size(),0);\\n        int ans=0;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==\\'1\\') v[j]+=1;\\n                else v[j]=0;\\n            }\\n            ans=max(ans,larRectInHisto(v));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n      void NSER(vector<int>& v,vector<int>& height){\\n          stack<int> st;\\n          st.push(0);\\n\\n          int i=1;\\n          while(i<height.size()){\\n              if(height[i]>=height[st.top()]){st.push(i++);}",
                "codeTag": "Java"
            },
            {
                "id": 1458014,
                "title": "c-maximum-histogram-problem-based-solution",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n  // code for largest rectangle in Hologram\\n  int maxisumhistogram(vector<int> &arr)\\n    {\\n         int n = arr.size(),maxi=0;\\n\\n         stack<int>st;\\n         int left[n],right[n];\\n        \\n         for(int i=0;i<n;i++)\\n         {\\n            while(!st.empty()&& arr[st.top()]>=arr[i])\\n                st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else left[i]= st.top()+1;\\n            \\n            st.push(i);\\n         }\\n        \\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty()&& arr[st.top()]>=arr[i])\\n                st.pop();\\n            if(st.empty())\\n                right[i]=n-1;\\n            else right[i]= st.top()-1;\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++)\\n            maxi=max(maxi,(right[i]-left[i]+1)*arr[i]);\\n        \\n        return maxi;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0)\\n            return 0;\\n        int maxi =0;\\n        vector<int> arr(matrix[0].size(),0);\\n        \\n      for(int i=0;i<matrix.size();i++)\\n      {\\n          for(int j=0;j<matrix[i].size();j++)\\n          {\\n              if(matrix[i][j]!=\\'0\\')\\n              {\\n                  arr[j]+= matrix[i][j]-\\'0\\';\\n              }\\n              else {\\n                 arr[j] = matrix[i][j]-\\'0\\';  \\n              }\\n          }\\n          maxi= max(maxi,maxisumhistogram(arr) );\\n      }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n  // code for largest rectangle in Hologram\\n  int maxisumhistogram(vector<int> &arr)\\n    {\\n         int n = arr.size(),maxi=0;\\n\\n         stack<int>st;\\n         int left[n],right[n];\\n        \\n         for(int i=0;i<n;i++)\\n         {\\n            while(!st.empty()&& arr[st.top()]>=arr[i])\\n                st.pop();\\n            if(st.empty())\\n                left[i]=0;\\n            else left[i]= st.top()+1;\\n            \\n            st.push(i);\\n         }\\n        \\n        while(!st.empty())\\n            st.pop();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty()&& arr[st.top()]>=arr[i])\\n                st.pop();\\n            if(st.empty())\\n                right[i]=n-1;\\n            else right[i]= st.top()-1;\\n            st.push(i);\\n        }\\n        for(int i=0;i<n;i++)\\n            maxi=max(maxi,(right[i]-left[i]+1)*arr[i]);\\n        \\n        return maxi;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0)\\n            return 0;\\n        int maxi =0;\\n        vector<int> arr(matrix[0].size(),0);\\n        \\n      for(int i=0;i<matrix.size();i++)\\n      {\\n          for(int j=0;j<matrix[i].size();j++)\\n          {\\n              if(matrix[i][j]!=\\'0\\')\\n              {\\n                  arr[j]+= matrix[i][j]-\\'0\\';\\n              }\\n              else {\\n                 arr[j] = matrix[i][j]-\\'0\\';  \\n              }\\n          }\\n          maxi= max(maxi,maxisumhistogram(arr) );\\n      }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346443,
                "title": "c-stack-max-area-in-histogram-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row=matrix.size();\\n        if(row==0) return 0;\\n        int col=matrix[0].size();\\n        \\n        int area=0;\\n        \\n        vector<vector<int>> grid(row,vector<int>(col));\\n        \\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                if(i==0){\\n                    grid[i][j]=matrix[i][j]-\\'0\\';\\n                }else{\\n                    if(matrix[i][j]==\\'0\\'){\\n                        grid[i][j]=0;\\n                    }else{\\n                        grid[i][j]=grid[i-1][j]+1;\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//code below is similar to \"MAX AREA IN HISTOGRAM\" problem\\n            vector<int> left, right;\\n            stack<int> stk;\\n\\n            for(int j=0;j<col;++j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) left.push_back(-1);\\n                else left.push_back(stk.top());\\n                stk.push(j);\\n            }\\n\\n            while(!stk.empty()) stk.pop();\\n\\n            for(int j=col-1;j>=0;--j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) right.push_back(col);\\n                else right.push_back(stk.top());\\n                stk.push(j);\\n            }\\n            reverse(right.begin(),right.end());\\n\\n            for(int j=0;j<col;++j){\\n                area=max(area, (grid[i][j]*(right[j]-left[j]-1)));\\n            }\\n        }\\n    \\n        return area;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int row=matrix.size();\\n        if(row==0) return 0;\\n        int col=matrix[0].size();\\n        \\n        int area=0;\\n        \\n        vector<vector<int>> grid(row,vector<int>(col));\\n        \\n        for(int i=0;i<row;++i){\\n            for(int j=0;j<col;++j){\\n                if(i==0){\\n                    grid[i][j]=matrix[i][j]-\\'0\\';\\n                }else{\\n                    if(matrix[i][j]==\\'0\\'){\\n                        grid[i][j]=0;\\n                    }else{\\n                        grid[i][j]=grid[i-1][j]+1;\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//code below is similar to \"MAX AREA IN HISTOGRAM\" problem\\n            vector<int> left, right;\\n            stack<int> stk;\\n\\n            for(int j=0;j<col;++j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) left.push_back(-1);\\n                else left.push_back(stk.top());\\n                stk.push(j);\\n            }\\n\\n            while(!stk.empty()) stk.pop();\\n\\n            for(int j=col-1;j>=0;--j){\\n                int cur = grid[i][j];\\n                while(!stk.empty() && grid[i][stk.top()]>=cur) stk.pop();\\n                if(stk.empty()) right.push_back(col);\\n                else right.push_back(stk.top());\\n                stk.push(j);\\n            }\\n            reverse(right.begin(),right.end());\\n\\n            for(int j=0;j<col;++j){\\n                area=max(area, (grid[i][j]*(right[j]-left[j]-1)));\\n            }\\n        }\\n    \\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290331,
                "title": "solution-using-stack",
                "content": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        def mah(t):    \\n            n= len(t)\\n            #next smaller element in right\\n            stack1=[]\\n            nsr = []\\n            \\n            for j in range(n-1,-1,-1):\\n                if len(stack1)==0:\\n                    nsr.append(t[j]*1)\\n                else:\\n                    while stack1 and t[stack1[-1]]>=t[j]:\\n                        stack1.pop()\\n                        \\n                    if len(stack1)==0:\\n                        nsr.append((n-j)*t[j])\\n                    else:\\n                        nsr.append((stack1[-1]-j)*t[j])\\n                stack1.append(j)\\n            \\n            # next smaller element in left\\n            \\n            stack2=[]\\n            nsl=[]\\n            \\n            for i in range(n):\\n                if len(stack2)==0:\\n                    nsl.append((i+1)*t[i])\\n                else:\\n                    \\n                    while stack2 and t[stack2[-1]]>=t[i]:\\n                        stack2.pop()\\n                    \\n                    if len(stack2)==0:\\n                        nsl.append((i+1)*t[i])\\n                    else:\\n                        nsl.append((i-stack2[-1])*t[i])\\n                stack2.append(i)\\n                \\n            ans=0\\n            for i in range(n):\\n                ans = max(ans,   nsl[i]+nsr[-(i+1)]-t[i])\\n            return ans\\n        \\n        if not matrix:\\n            return 0\\n        n=len(matrix)\\n        m= len(matrix[0])\\n        \\n        g=[0]*(m)\\n        \\n        u=0\\n        ans=0\\n        while u<n:\\n            \\n            for i in range(m):\\n                x=int(matrix[u][i])\\n                if x==0:\\n                    g[i]=0\\n                else:\\n                    g[i]+=x\\n            ans=max(mah(g),ans)\\n            u+=1\\n        return ans\\n    \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \\n        def mah(t):    \\n            n= len(t)\\n            #next smaller element in right\\n            stack1=[]\\n            nsr = []\\n            \\n            for j in range(n-1,-1,-1):\\n                if len(stack1)==0:\\n                    nsr.append(t[j]*1)\\n                else:\\n                    while stack1 and t[stack1[-1]]>=t[j]:\\n                        stack1.pop()\\n                        \\n                    if len(stack1)==0:\\n                        nsr.append((n-j)*t[j])\\n                    else:\\n                        nsr.append((stack1[-1]-j)*t[j])\\n                stack1.append(j)\\n            \\n            # next smaller element in left\\n            \\n            stack2=[]\\n            nsl=[]\\n            \\n            for i in range(n):\\n                if len(stack2)==0:\\n                    nsl.append((i+1)*t[i])\\n                else:\\n                    \\n                    while stack2 and t[stack2[-1]]>=t[i]:\\n                        stack2.pop()\\n                    \\n                    if len(stack2)==0:\\n                        nsl.append((i+1)*t[i])\\n                    else:\\n                        nsl.append((i-stack2[-1])*t[i])\\n                stack2.append(i)\\n                \\n            ans=0\\n            for i in range(n):\\n                ans = max(ans,   nsl[i]+nsr[-(i+1)]-t[i])\\n            return ans\\n        \\n        if not matrix:\\n            return 0\\n        n=len(matrix)\\n        m= len(matrix[0])\\n        \\n        g=[0]*(m)\\n        \\n        u=0\\n        ans=0\\n        while u<n:\\n            \\n            for i in range(m):\\n                x=int(matrix[u][i])\\n                if x==0:\\n                    g[i]=0\\n                else:\\n                    g[i]+=x\\n            ans=max(mah(g),ans)\\n            u+=1\\n        return ans\\n    \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204207,
                "title": "using-2-stack-max-area-histogram-variation-by-aditya-verma",
                "content": "// If any one wants to do DSA and competitive coding from scratch you can visit my Github Repository\\n// https://github.com/skjha1/Data-Structure-Algorithm-Programs\\n// https://github.com/skjha1/Competitive-Coding\\n```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);// taking max after finding area\\n    }\\n    return m;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestRectangleArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> left,right;\\n    stack<pair<int,int>> s1,s2;\\n    int pseudo_index =-1;\\n    int pseudo_index1 =n;\\n    for (int i=0;i<n;i++)\\n    {\\n      if (s1.size()==0)\\n      {\\n        left.push_back(pseudo_index);\\n      }\\n      else if (s1.size()>0 && s1.top().first<heights[i])\\n      {\\n        left.push_back(s1.top().second);\\n      }\\n      else if (s1.size()>0 && s1.top().first>=heights[i])\\n      {\\n         while(s1.size()>0 && s1.top().first>=heights[i])\\n         {\\n           s1.pop();\\n         }\\n        if (s1.size()==0)\\n        {\\n          left.push_back(pseudo_index);\\n        }\\n        else\\n        {\\n          left.push_back(s1.top().second);\\n        }\\n      }\\n      s1.push({heights[i],i});\\n    }\\n    for (int i=n-1;i>=0;i--)\\n    {\\n      if (s2.size()==0)\\n      {\\n        right.push_back(pseudo_index1);\\n      }\\n      else if (s2.size()>0 && s2.top().first<heights[i])\\n      {\\n        right.push_back(s2.top().second);\\n      }\\n      else if (s2.size()>0 && s2.top().first >= heights[i])\\n      {\\n        while(s2.size()>0 && s2.top().first >= heights[i])\\n        {\\n          s2.pop();\\n        }\\n        if (s2.size()==0)\\n        {\\n          right.push_back(pseudo_index1);\\n        }\\n        else\\n        {\\n          right.push_back(s2.top().second);\\n        }\\n      }\\n      s2.push({heights[i],i});\\n    }\\n    reverse(right.begin(),right.end());\\n    int m=INT_MIN;\\n    for (long long i=0;i<n;i++)\\n    {\\n      m=max(m,(right[i]-left[i]-1)*heights[i]);// taking max after finding area\\n    }\\n    return m;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestRectangleArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1179059,
                "title": "a-solutin-based-on-prefix-sum-and-binary-search",
                "content": "Most of solution in discuss is DP, in here I use `prefix sum + binary search`, of course it\\' slow...but maybe new way for your. Hope it\\'s helpful for you.\\n```c++\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()||matrix[0].empty()) return 0;\\n\\t\\tint n=matrix.size(),m =matrix[0].size();\\n        printf(\"%d,%d\\\\n\",n,m);\\n\\t\\tvector<vector<int>> sum(n+1,vector<int>(m+1,0));\\n\\t\\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++){\\n\\t\\t\\tint tmp = matrix[i-1][j-1]==\\'1\\'?1:0;\\n\\t\\t    // prefix sum\\n\\t\\t\\tsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + tmp;\\n\\t\\t}\\n        \\n\\t\\tint ans=0,cnt=0;\\n        for(int i=n;i>=1;i--){\\n            if(ans>=i*m) break;\\n            for(int j=m;j>=1;j--){\\n                if(ans>=i*j) break;\\n                if(matrix[i-1][j-1]!=\\'1\\') continue;\\n                for(int d=min(m,j);d>=1;d--){\\n                    int l=0, r= n,mid,t=0;\\n                    // binary search\\n                    while(l<=r){\\n                        mid = l + (r-l)/2;\\n                        if(i-mid<0||j-d<0||sum[i][j]-sum[i-mid][j]-sum[i][j-d]+sum[i-mid][j-d]<d*mid) r=mid-1;\\n                        else l = mid+1;\\n                    }\\n                    ans = max(ans,r*d);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        if(matrix.empty()||matrix[0].empty()) return 0;\\n\\t\\tint n=matrix.size(),m =matrix[0].size();\\n        printf(\"%d,%d\\\\n\",n,m);\\n\\t\\tvector<vector<int>> sum(n+1,vector<int>(m+1,0));\\n\\t\\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++){\\n\\t\\t\\tint tmp = matrix[i-1][j-1]==\\'1\\'?1:0;\\n\\t\\t    // prefix sum\\n\\t\\t\\tsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + tmp;\\n\\t\\t}\\n        \\n\\t\\tint ans=0,cnt=0;\\n        for(int i=n;i>=1;i--){\\n            if(ans>=i*m) break;\\n            for(int j=m;j>=1;j--){\\n                if(ans>=i*j) break;\\n                if(matrix[i-1][j-1]!=\\'1\\') continue;\\n                for(int d=min(m,j);d>=1;d--){\\n                    int l=0, r= n,mid,t=0;\\n                    // binary search\\n                    while(l<=r){\\n                        mid = l + (r-l)/2;\\n                        if(i-mid<0||j-d<0||sum[i][j]-sum[i-mid][j]-sum[i][j-d]+sum[i-mid][j-d]<d*mid) r=mid-1;\\n                        else l = mid+1;\\n                    }\\n                    ans = max(ans,r*d);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154976,
                "title": "c-solution-by-accumulation",
                "content": "#### Idea\\nAccumulate the number from left to right. Then iterate the new table column by column. Pick the smallest `width` and largest `height` before encountering 0.\\n**Time complexity** : O(n * m)\\uFF0Cm=rowNumOf(matrix)\\n**Space complexity** : O(n^2)\\n\\n#### Cost\\n28 ms\\t11.5 MB\\n\\n#### Code\\n```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n\\tif (matrix.empty())return 0;\\n\\tint r = 0, m = matrix.size(), n = matrix[0].size();\\n\\n\\tvector<vector<int>> dp(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i][j] = (matrix[i][j] == \\'1\\') ? (j == 0 ? 1 : dp[i][j - 1] + 1) : 0;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int j = 0; j < n; j++)\\n\\t{\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t{\\n\\t\\t\\tint width = dp[i][j];\\n\\t\\t\\tfor (int k = i; k < m; k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (dp[k][j] == 0) break;\\n\\t\\t\\t\\tif (dp[k][j] < width)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twidth = dp[k][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tr = max(r, width * (k - i + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn r;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n\\tif (matrix.empty())return 0;\\n\\tint r = 0, m = matrix.size(), n = matrix[0].size();\\n\\n\\tvector<vector<int>> dp(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i][j] = (matrix[i][j] == \\'1\\') ? (j == 0 ? 1 : dp[i][j - 1] + 1) : 0;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int j = 0; j < n; j++)\\n\\t{\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t{\\n\\t\\t\\tint width = dp[i][j];\\n\\t\\t\\tfor (int k = i; k < m; k++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (dp[k][j] == 0) break;\\n\\t\\t\\t\\tif (dp[k][j] < width)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twidth = dp[k][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tr = max(r, width * (k - i + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145856,
                "title": "c-change-the-problem-to-be-using-problem-84",
                "content": "```\\npublic class Solution {\\n    public int MaximalRectangle(char[][] matrix) {\\n        if (matrix == null || matrix.Length == 0) return 0;\\n        int m = matrix.Length;\\n        int n = matrix[0].Length;\\n        int max = 0;\\n        \\n        // we can solve this problem with problem 84\\n        // make it line by line\\n        var heights = new int[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    heights[j] = 0; // reset, start from 0 again\\n                } else {\\n                    heights[j]++;\\n                }\\n            }\\n            \\n            max = Math.Max(max, LargestRectangle(heights));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int LargestRectangle(int[] heights) {\\n        var stack = new Stack<int>(); // keep increasing stack with index in it\\n        int len = heights.Length;\\n        int index = 0;\\n        int maxArea = 0;\\n        \\n        while (index < len) {\\n            if (stack.Count == 0 || heights[stack.Peek()] <= heights[index]) {\\n                stack.Push(index);\\n                index++;\\n            } else {\\n                // start processing the smallest bar\\n                var tp = stack.Pop();\\n                var area = heights[tp] * (stack.Count == 0 ? index : (index - stack.Peek()-1));\\n                maxArea = Math.Max(maxArea, area);\\n            }\\n        }\\n        \\n        while (stack.Count > 0) {\\n            var tp = stack.Pop();\\n            var area = heights[tp] * (stack.Count == 0 ? index : (index - stack.Peek() -1 ));\\n            maxArea = Math.Max(maxArea, area);\\n        }\\n        \\n        return maxArea;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaximalRectangle(char[][] matrix) {\\n        if (matrix == null || matrix.Length == 0) return 0;\\n        int m = matrix.Length;\\n        int n = matrix[0].Length;\\n        int max = 0;\\n        \\n        // we can solve this problem with problem 84\\n        // make it line by line\\n        var heights = new int[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    heights[j] = 0; // reset, start from 0 again\\n                } else {\\n                    heights[j]++;\\n                }\\n            }\\n            \\n            max = Math.Max(max, LargestRectangle(heights));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int LargestRectangle(int[] heights) {\\n        var stack = new Stack<int>(); // keep increasing stack with index in it\\n        int len = heights.Length;\\n        int index = 0;\\n        int maxArea = 0;\\n        \\n        while (index < len) {\\n            if (stack.Count == 0 || heights[stack.Peek()] <= heights[index]) {\\n                stack.Push(index);\\n                index++;\\n            } else {\\n                // start processing the smallest bar\\n                var tp = stack.Pop();\\n                var area = heights[tp] * (stack.Count == 0 ? index : (index - stack.Peek()-1));\\n                maxArea = Math.Max(maxArea, area);\\n            }\\n        }\\n        \\n        while (stack.Count > 0) {\\n            var tp = stack.Pop();\\n            var area = heights[tp] * (stack.Count == 0 ? index : (index - stack.Peek() -1 ));\\n            maxArea = Math.Max(maxArea, area);\\n        }\\n        \\n        return maxArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104867,
                "title": "c-code-using-largest-rectangle-in-histogram",
                "content": "\\nDo Upvote if you like this solution\\n\\nclass Solution {\\npublic:\\n    \\n    void MAH(vector<int>col ,int& res2)\\n    {\\n        int n=col.size();\\n        stack<pair<int,int>>s;\\n        vector<int>left(n),right(n);\\n        \\n        // Nearest Samller to left\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.empty())\\n            {\\n                left[i]=-1;\\n            }\\n            else\\n            {\\n                if(s.top().first<col[i])\\n                {\\n                    left[i]=s.top().second;\\n                }\\n                else\\n                {\\n                    while(!s.empty() && s.top().first>=col[i])\\n                    {\\n                        s.pop();\\n                    }\\n                    if(s.empty())\\n                    {\\n                        left[i]=-1;\\n                    }\\n                    else\\n                    {\\n                       left[i]=s.top().second;   \\n                    }\\n                }\\n                \\n            }\\n            \\n            s.push({col[i],i});\\n        }\\n        \\n        // Clearing the Stack for the Right\\n        \\n        while(!s.empty())\\n        {\\n            s.pop();\\n        }\\n        \\n        // Nearest smallest right\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s.empty())\\n            {\\n                right[i]=n;\\n            }\\n            else\\n            {\\n                if(s.top().first<col[i])\\n                {\\n                    right[i]=s.top().second;\\n                }\\n                else\\n                {\\n                    while(!s.empty() && s.top().first>=col[i])\\n                    {\\n                        s.pop();\\n                    }\\n                    if(s.empty())\\n                    {\\n                        right[i]=n;\\n                    }\\n                    else\\n                    {\\n                        right[i]=s.top().second;\\n                    }\\n                }\\n            }\\n            \\n            s.push({col[i],i});\\n        }\\n        \\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int x=right[i]-left[i]-1;\\n            ans=max(ans,x*col[i]);\\n        }\\n        \\n        res2=max(res2,ans);\\n    \\n    }\\n    int maximalRectangle(vector<vector<char>>& matrix)\\n    {\\n        if(matrix.empty())\\n        {\\n            return 0;\\n        }\\n        \\n        int res=INT_MIN;\\n        vector<int>col(matrix[0].size(),0);\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                if((matrix[i][j]-\\'0\\')==0)\\n                {\\n                    col[j]=0;\\n                }\\n                else\\n                {\\n                    col[j]+=1;\\n                }\\n            }\\n            \\n            MAH(col,res);\\n        }\\n            \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void MAH(vector<int>col ,int& res2)\\n    {\\n        int n=col.size();\\n        stack<pair<int,int>>s;\\n        vector<int>left(n),right(n);\\n        \\n        // Nearest Samller to left\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.empty())\\n            {\\n                left[i]=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 982255,
                "title": "c-solution-using-the-concept-of-max-area-histogram",
                "content": "```\\nint MAH(vector<int>& arr) {\\n     int n = arr.size();\\n    vector<int> leftindex;\\n    stack<pair<int,int>> s1;\\n    vector<int> rightindex;\\n    stack<pair<int,int>> s2;\\n    vector<int> width(n);\\n        if(n==0)\\n            return 0;\\n    for(int i = n-1;i>=0;i--)\\n    {\\n        if(s1.size() == 0)\\n            rightindex.push_back(n);\\n        else if(s1.size() > 0 && s1.top().first<arr[i])\\n        {\\n            rightindex.push_back(s1.top().second);\\n        }\\n        else if(s1.size() > 0  && s1.top().first>=arr[i])\\n        {\\n            while(s1.size()>0 && s1.top().first>=arr[i])\\n            {\\n                s1.pop();\\n            }\\n            if(s1.size() == 0 )\\n                rightindex.push_back(n);\\n            else\\n                rightindex.push_back(s1.top().second);\\n        }\\n      s1.push({arr[i],i});\\n    } \\n    reverse(rightindex.begin(),rightindex.end());\\n    for(int i =0;i<n;i++)\\n    {\\n        if(s2.size() == 0)\\n            leftindex.push_back(-1);\\n        else if(s2.size() > 0 && s2.top().first<arr[i])\\n        {\\n            leftindex.push_back(s2.top().second);\\n        }\\n        else if(s2.size() > 0  && s2.top().first>=arr[i])\\n        {\\n            while(s2.size()>0 && s2.top().first>=arr[i])\\n            {\\n                s2.pop();\\n            }\\n            if(s2.size() == 0 )\\n                leftindex.push_back(-1);\\n            else\\n                leftindex.push_back(s2.top().second);\\n        }\\n      s2.push({arr[i],i});\\n    } \\n    for(int i = 0;i<n;i++)\\n    {\\n        width[i] = (rightindex[i] - leftindex[i]) - 1;\\n        width[i] = width[i] * arr[i];\\n    }\\n    int max  = *max_element(width.begin(),width.end());\\n  return max;  \\n}\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n    if(matrix.size() == 0) return 0;\\n    int row = matrix.size();\\n    int col = matrix[0].size();\\n    vector<int> nums;\\n    int ans = 0;\\n    int temp = 0;\\n    for(int i = 0;i<col;i++)\\n    \\tnums.push_back((int)matrix[0][i] - \\'0\\');\\n    ans = MAH(nums);\\n    for(int i = 1;i<row;i++)\\n    {\\n    \\tfor(int j = 0;j<col;j++)\\n    \\t{\\n    \\t\\tif(matrix[i][j] == \\'0\\')\\n    \\t\\t\\tnums[j] = 0;\\n    \\t\\telse\\n    \\t\\t\\tnums[j] = (nums[j] + (int) matrix[i][j]) - \\'0\\';\\n    \\t}\\n    \\t temp = MAH(nums);\\n         ans = max(ans,temp);\\n    }\\n        \\nreturn ans;\\n}",
                "solutionTags": [],
                "code": "```\\nint MAH(vector<int>& arr) {\\n     int n = arr.size();\\n    vector<int> leftindex;\\n    stack<pair<int,int>> s1;\\n    vector<int> rightindex;\\n    stack<pair<int,int>> s2;\\n    vector<int> width(n);\\n        if(n==0)\\n            return 0;\\n    for(int i = n-1;i>=0;i--)\\n    {\\n        if(s1.size() == 0)\\n            rightindex.push_back(n);\\n        else if(s1.size() > 0 && s1.top().first<arr[i])\\n        {\\n            rightindex.push_back(s1.top().second);\\n        }\\n        else if(s1.size() > 0  && s1.top().first>=arr[i])\\n        {\\n            while(s1.size()>0 && s1.top().first>=arr[i])\\n            {\\n                s1.pop();\\n            }\\n            if(s1.size() == 0 )\\n                rightindex.push_back(n);\\n            else\\n                rightindex.push_back(s1.top().second);\\n        }\\n      s1.push({arr[i],i});\\n    } \\n    reverse(rightindex.begin(),rightindex.end());\\n    for(int i =0;i<n;i++)\\n    {\\n        if(s2.size() == 0)\\n            leftindex.push_back(-1);\\n        else if(s2.size() > 0 && s2.top().first<arr[i])\\n        {\\n            leftindex.push_back(s2.top().second);\\n        }\\n        else if(s2.size() > 0  && s2.top().first>=arr[i])\\n        {\\n            while(s2.size()>0 && s2.top().first>=arr[i])\\n            {\\n                s2.pop();\\n            }\\n            if(s2.size() == 0 )\\n                leftindex.push_back(-1);\\n            else\\n                leftindex.push_back(s2.top().second);\\n        }\\n      s2.push({arr[i],i});\\n    } \\n    for(int i = 0;i<n;i++)\\n    {\\n        width[i] = (rightindex[i] - leftindex[i]) - 1;\\n        width[i] = width[i] * arr[i];\\n    }\\n    int max  = *max_element(width.begin(),width.end());\\n  return max;  \\n}\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n    if(matrix.size() == 0) return 0;\\n    int row = matrix.size();\\n    int col = matrix[0].size();\\n    vector<int> nums;\\n    int ans = 0;\\n    int temp = 0;\\n    for(int i = 0;i<col;i++)\\n    \\tnums.push_back((int)matrix[0][i] - \\'0\\');\\n    ans = MAH(nums);\\n    for(int i = 1;i<row;i++)\\n    {\\n    \\tfor(int j = 0;j<col;j++)\\n    \\t{\\n    \\t\\tif(matrix[i][j] == \\'0\\')\\n    \\t\\t\\tnums[j] = 0;\\n    \\t\\telse\\n    \\t\\t\\tnums[j] = (nums[j] + (int) matrix[i][j]) - \\'0\\';\\n    \\t}\\n    \\t temp = MAH(nums);\\n         ans = max(ans,temp);\\n    }\\n        \\nreturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 979263,
                "title": "c-dp-solution-99-07-faster-using-the-idea-of-largest-rect-in-histogram",
                "content": "```\\n int maximalRectangle(vector<vector<char> > &matrix) {\\n    if(matrix.empty()) return 0;\\n    \\n    // Since r and c dont change we use a constant sized array instead of vector\\n    const int r = matrix.size();\\n    const int c = matrix[0].size();\\n       \\n    /* height[j] stores the height of the possible rectangle at col=j for any row i\\n       left[j] stores the index of the col havin the leftMost edge of the rect at col=j for any row i\\n       right[j] stores the index of the col havin the rightMost edge of the rect at col=j for any row i\\n       Rect Area = (right[j]-left[j])*height[j]\\n    */\\n    \\n    // We find the largest rectangle for every triplet values in the order of rows:\\n     /*          0      1      2     3      4\\n     Index 0: (0 1 1)(0 0 5)(2 1 3)(0 0 5)(0 0 5)\\n     Index 1: (0 2 1)(0 0 5)(2 2 3)(2 1 5)(2 1 5)\\n     Index 2: (0 3 1)(0 1 5)(2 3 3)(2 2 5)(2 2 5)\\n     Index 3: (0 4 1)(0 0 5)(0 0 5)(3 3 4)(0 0 5)\\n     */\\n     // Note: At any index (i,j), triplet = (left, height, right)\\n     \\n    int left[c], right[c], height[c];\\n    \\n    // filling the arrays with default values\\n    fill_n(left,c,0);\\n    fill_n(right,c,c); // default value is not zero\\n    fill_n(height,c,0);\\n       \\n    int ans = 0;\\n    for(int i=0; i<r; i++) {\\n        \\n        int cur_left=0, cur_right=c; \\n        \\n        /*\\n        height of rect at current (row,col) = height of rect at prev row on the same col + 1\\n        height[i][j] = height[i-1][j] + 1, if matrix[i][j] = 1\\n                     = 0, otherwise\\n        */\\n        for(int j=0; j<c; j++) {\\n            if(matrix[i][j]==\\'1\\') height[j]++; \\n            else height[j]=0;\\n        }\\n        \\n        \\n        /*\\n        leftEdge of current Row = max(leftEdge of prev row, currentRowLeftEdge)\\n        leftEdge[i][j] = max(leftEdge[i-1][j], currenLeftEdge), if matrix[i][j] = 1;\\n                       = 0, otherwise, Also update the currentLeftEdge to next index because current matrix[i][j] is 0.\\n        */\\n        for(int j=0; j<c; j++) {\\n            if(matrix[i][j]==\\'1\\') left[j]=max(left[j],cur_left);\\n            else {\\n                left[j]=0;\\n                cur_left=j+1;\\n            }\\n        }\\n        \\n        /*\\n        RightEdge of current Row = min(rightEdge of prev row, currentRowRightEdge)\\n        rightEdge[i][j] = min(rightEdge[i-1][j], currentRowRightEdge), if matrix[i][j] = 1;\\n                       = col, otherwise. Also update the currentRightEdge to current index because current matrix[i][j] is 0.\\n        */\\n        for(int j=c-1; j>=0; j--) {\\n            if(matrix[i][j]==\\'1\\') right[j]=min(right[j],cur_right);\\n            else {\\n                right[j]=c;\\n                cur_right=j;\\n            }    \\n        }\\n        \\n        // For Debug Purpose:\\n        // cout<<\"Index: \"<<i<<\" \";\\n        // for(int j = 0; j<c; j++) {\\n        //     cout<<\"(\"<<left[j]<<\" \"<<height[j]<<\" \"<<right[j]<<\")\";\\n        // }\\n        // cout<<\"\\\\n\";\\n        \\n        // compute the area of rectangle using (left, height, right), Area = (right-left)*height\\n        for(int j=0; j<c; j++) {\\n            ans = max(ans,(right[j]-left[j])*height[j]);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n int maximalRectangle(vector<vector<char> > &matrix) {\\n    if(matrix.empty()) return 0;\\n    \\n    // Since r and c dont change we use a constant sized array instead of vector\\n    const int r = matrix.size();\\n    const int c = matrix[0].size();\\n       \\n    /* height[j] stores the height of the possible rectangle at col=j for any row i\\n       left[j] stores the index of the col havin the leftMost edge of the rect at col=j for any row i\\n       right[j] stores the index of the col havin the rightMost edge of the rect at col=j for any row i\\n       Rect Area = (right[j]-left[j])*height[j]\\n    */\\n    \\n    // We find the largest rectangle for every triplet values in the order of rows:\\n     /*          0      1      2     3      4\\n     Index 0: (0 1 1)(0 0 5)(2 1 3)(0 0 5)(0 0 5)\\n     Index 1: (0 2 1)(0 0 5)(2 2 3)(2 1 5)(2 1 5)\\n     Index 2: (0 3 1)(0 1 5)(2 3 3)(2 2 5)(2 2 5)\\n     Index 3: (0 4 1)(0 0 5)(0 0 5)(3 3 4)(0 0 5)\\n     */\\n     // Note: At any index (i,j), triplet = (left, height, right)\\n     \\n    int left[c], right[c], height[c];\\n    \\n    // filling the arrays with default values\\n    fill_n(left,c,0);\\n    fill_n(right,c,c); // default value is not zero\\n    fill_n(height,c,0);\\n       \\n    int ans = 0;\\n    for(int i=0; i<r; i++) {\\n        \\n        int cur_left=0, cur_right=c; \\n        \\n        /*\\n        height of rect at current (row,col) = height of rect at prev row on the same col + 1\\n        height[i][j] = height[i-1][j] + 1, if matrix[i][j] = 1\\n                     = 0, otherwise\\n        */\\n        for(int j=0; j<c; j++) {\\n            if(matrix[i][j]==\\'1\\') height[j]++; \\n            else height[j]=0;\\n        }\\n        \\n        \\n        /*\\n        leftEdge of current Row = max(leftEdge of prev row, currentRowLeftEdge)\\n        leftEdge[i][j] = max(leftEdge[i-1][j], currenLeftEdge), if matrix[i][j] = 1;\\n                       = 0, otherwise, Also update the currentLeftEdge to next index because current matrix[i][j] is 0.\\n        */\\n        for(int j=0; j<c; j++) {\\n            if(matrix[i][j]==\\'1\\') left[j]=max(left[j],cur_left);\\n            else {\\n                left[j]=0;\\n                cur_left=j+1;\\n            }\\n        }\\n        \\n        /*\\n        RightEdge of current Row = min(rightEdge of prev row, currentRowRightEdge)\\n        rightEdge[i][j] = min(rightEdge[i-1][j], currentRowRightEdge), if matrix[i][j] = 1;\\n                       = col, otherwise. Also update the currentRightEdge to current index because current matrix[i][j] is 0.\\n        */\\n        for(int j=c-1; j>=0; j--) {\\n            if(matrix[i][j]==\\'1\\') right[j]=min(right[j],cur_right);\\n            else {\\n                right[j]=c;\\n                cur_right=j;\\n            }    \\n        }\\n        \\n        // For Debug Purpose:\\n        // cout<<\"Index: \"<<i<<\" \";\\n        // for(int j = 0; j<c; j++) {\\n        //     cout<<\"(\"<<left[j]<<\" \"<<height[j]<<\" \"<<right[j]<<\")\";\\n        // }\\n        // cout<<\"\\\\n\";\\n        \\n        // compute the area of rectangle using (left, height, right), Area = (right-left)*height\\n        for(int j=0; j<c; j++) {\\n            ans = max(ans,(right[j]-left[j])*height[j]);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 975142,
                "title": "clean-fully-explained-python-solution-o-n-2-explains-every-step",
                "content": "This problem is definitely trickier than it looks and took me a while to comprehend. First, I strongly recommend that you read this [explanation for finding the maximum area of a rectangle in a histogram](https://abhinandandubey.github.io/posts/2019/12/15/Largest-Rectangle-In-Histogram.html), which we will use. \\n\\nEffectively, this problem is **identical to finding max rectangle in a histogram**, and here\\'s how. First, in problems that ask to find subarrays or submatrices that satisfy a certain condition, it is usually convenient to use a prefix sum. Suppose our matrix had just one row `mat = [1,0,1,1,1,0]`, then we can use a prefix sum to count the number of consecutive ones `prefixSum = [1,0,1,2,3,0]`.\\n\\nIf we have a matrix `mat = [[1,0,1],[1,1,1],[0,1,1]]` then `prefixSum = [[1,0,1],[1,2,3],[0,1,2]]`. So we\\'ve counted consecutive ones in each row, but how can we use this information to find the maximal rectangle?\\n\\n**Here\\'s the trick:**\\n\\nSince we\\'ve preprocessed the rows, we need to iterate over the columns somehow to compute the maximal rectangle. But how? The trick is to notice that each column in the prefix sum can be interpreted as a histogram. In the above example `col1 = [1,1,0] col2 =[0,2,3] col3 = [1,3,2]`.  *Finding the maximal rectangle for each column is equivalent to finding the maximal rectangle in the column histogram*. Once you understand this, then you just find the maximal rectangle for each column and return the largest one.\\n\\n```\\n\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \"\"\"\\n        This code \\n        a) computes prefix sums for each row\\n        b) iterates through the cols of the prefix sum matrix\\n        c) treats these cols as histogram\\n        d) computes largest rectangle within the histogram\\n        https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        https://abhinandandubey.github.io/posts/2019/12/15/Largest-Rectangle-In-Histogram.html\\n        \"\"\"\\n        if len(matrix) < 1: return 0\\n        hist = [self.prefixSum(m) for m in matrix]\\n        rows,cols = len(hist),len(hist[0])\\n        maxarea = 0\\n        for i in range(cols):\\n            h = [row[i] for row in hist]\\n            area = self.maxHistRec(h)\\n            maxarea = max(maxarea,area)\\n        return maxarea\\n        \\n    def prefixSum(self,row):\\n        dp = [0 for _ in row]\\n        for i,v in enumerate(row):\\n            dp[i] = dp[i-1] + 1 if int(v) == 1 else 0\\n        return dp       \\n        \\n    def maxHistRec(self,hist):\\n        h = [-1] + hist + [-1]\\n        # use a stack\\n        stack = [0]\\n        area = 0\\n        for i in range(len(h)):\\n            while h[stack[-1]] > h[i]:\\n                j = stack.pop()\\n                area = max(area,h[j]*(i-stack[-1]-1))\\n            stack.append(i)\\n        return area\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        \"\"\"\\n        This code \\n        a) computes prefix sums for each row\\n        b) iterates through the cols of the prefix sum matrix\\n        c) treats these cols as histogram\\n        d) computes largest rectangle within the histogram\\n        https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        https://abhinandandubey.github.io/posts/2019/12/15/Largest-Rectangle-In-Histogram.html\\n        \"\"\"\\n        if len(matrix) < 1: return 0\\n        hist = [self.prefixSum(m) for m in matrix]\\n        rows,cols = len(hist),len(hist[0])\\n        maxarea = 0\\n        for i in range(cols):\\n            h = [row[i] for row in hist]\\n            area = self.maxHistRec(h)\\n            maxarea = max(maxarea,area)\\n        return maxarea\\n        \\n    def prefixSum(self,row):\\n        dp = [0 for _ in row]\\n        for i,v in enumerate(row):\\n            dp[i] = dp[i-1] + 1 if int(v) == 1 else 0\\n        return dp       \\n        \\n    def maxHistRec(self,hist):\\n        h = [-1] + hist + [-1]\\n        # use a stack\\n        stack = [0]\\n        area = 0\\n        for i in range(len(h)):\\n            while h[stack[-1]] > h[i]:\\n                j = stack.pop()\\n                area = max(area,h[j]*(i-stack[-1]-1))\\n            stack.append(i)\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964501,
                "title": "o-n-2-faster-than-99",
                "content": "* h(r, c): if we start at (r, c) and go upwards, how many 1 cells do we find before the first 0?\\n* l(r, c): how far left can we extend a rectangle with bottom-right corner at (r, c) and height h(r, c)?\\n* r(r,c): how far right can we extend a rectangle with bottom-left corner at (r, c) and height h(r, c)?\\n* The three recurrence relations are:\\n\\n* h(0, c) = 0\\n* h(r, c) = 0 if matrix[r][c] == 0\\n* h(r, c) = h(r-1, c)+1 otherwise\\n* l(r, 0) = 0\\n* l(r, c) = c-p if matrix[r-1][c] == 0\\n* l(r, c) = min(l(r \\u2212 1, c), c \\u2212 p) otherwise\\n* r(r,C+1) = 0\\n* r(r,c) = p-c if matrix[r-1][c] == 0\\n* r(r,c) = min(r(r \\u2212 1, c), p \\u2212 c) otherwise\\nwhere p is the column of the previous 0 as we populate l from left-right and r from right-left.\\n\\nThe answer is then:\\n\\nmax_r,c(h(r, c) \\u2217 (l(r, c) + r(r, c) \\u2212 1))\\nThis works because of the observation that the largest rectangle will always touch a 0 (considering the edge as being covered in 0\\'s) on all four sides. By considering all rectangles with at least top, left and right touching a 0, we cover all candidate rectangles. Generate every possible rectangle. You can do this by iterating through every pair of points (r1,c1) (r2,c2) with r1 \\u2264 r2 and c1 \\u2264 c2 (can be done with 4 for loops). If a rectangle does not contain a 0, you compare the area to the largest area found so far.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int left[201][201], right[201][201], height[201][201];\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size();\\n        if(n == 0)return 0;\\n        int m = matrix[0].size();\\n        if(m == 0)return 0;\\n        for(int i = 0; i < n; ++i){\\n            int l = -1;\\n            for(int j = 0; j < m; ++j){\\n                if(matrix[i][j] == \\'0\\'){\\n                    left[i][j] = j;\\n                    l = j;\\n                }else{\\n                    left[i][j] = l;\\n                }\\n            }\\n            int r = m;\\n            for(int j = m - 1; j >= 0; --j){\\n                if(matrix[i][j] == \\'0\\'){\\n                    right[i][j] = j;\\n                    r = j;\\n                }else right[i][j] = r;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < m; ++i){\\n            if(matrix[0][i] == \\'1\\'){\\n                height[0][i] = 1;\\n            }\\n            ans = max(ans, height[0][i] * (right[0][i] - left[0][i] - 1));\\n        }\\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(matrix[i][j] == \\'1\\'){\\n                    height[i][j] = height[i - 1][j] + 1;\\n                    if(height[i - 1][j] != 0){\\n                        left[i][j] = max(left[i][j], left[i - 1][j]);\\n                        right[i][j] = min(right[i][j], right[i - 1][j]);\\n                    } \\n                    ans = max(ans, height[i][j] * (right[i][j] - left[i][j] - 1));\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int left[201][201], right[201][201], height[201][201];\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int n = matrix.size();\\n        if(n == 0)return 0;\\n        int m = matrix[0].size();\\n        if(m == 0)return 0;\\n        for(int i = 0; i < n; ++i){\\n            int l = -1;\\n            for(int j = 0; j < m; ++j){\\n                if(matrix[i][j] == \\'0\\'){\\n                    left[i][j] = j;\\n                    l = j;\\n                }else{\\n                    left[i][j] = l;\\n                }\\n            }\\n            int r = m;\\n            for(int j = m - 1; j >= 0; --j){\\n                if(matrix[i][j] == \\'0\\'){\\n                    right[i][j] = j;\\n                    r = j;\\n                }else right[i][j] = r;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < m; ++i){\\n            if(matrix[0][i] == \\'1\\'){\\n                height[0][i] = 1;\\n            }\\n            ans = max(ans, height[0][i] * (right[0][i] - left[0][i] - 1));\\n        }\\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(matrix[i][j] == \\'1\\'){\\n                    height[i][j] = height[i - 1][j] + 1;\\n                    if(height[i - 1][j] != 0){\\n                        left[i][j] = max(left[i][j], left[i - 1][j]);\\n                        right[i][j] = min(right[i][j], right[i - 1][j]);\\n                    } \\n                    ans = max(ans, height[i][j] * (right[i][j] - left[i][j] - 1));\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836988,
                "title": "python-stack-solution-with-walk-through-example",
                "content": "**This solution can be broken down into two steps:**\\n1. Find the height of each column of ones for reach row.\\n2. Calculate the area of the largest rectangle whose top edge is touching the current row.  \\n\\nThese two steps are explained in the annotations of the code, but feel free to leave a comment if you have any questions.  \\n\\n```python\\ndef maximalRectangle(self, matrix: List[List[str]]) -> int:\\n\\n\\tdef update_heights(row: int) -> None:\\n\\t\\t\\'\\'\\'\\n\\t\\tUpdates heights in place.\\n\\t\\tInitially heights[col] represents the height at index (col) from the previous row.  \\n\\t\\tIf heights[col] IS NOT zero, then heights[col] of the current row will just be heights[col] - 1.\\n\\t\\tIf heights[col] IS zero, then traverse up column matrix[row:][col] to find the height of the column.  \\n\\t\\t\\'\\'\\'\\n\\t\\tnonlocal heights, matrix\\n\\n\\t\\tfor col,h in enumerate(heights):\\n\\t\\t\\tif h:\\n\\t\\t\\t\\theights[col] -= 1\\n\\t\\t\\telif matrix[row][col] == \\'0\\':\\n\\t\\t\\t\\theights[col] = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\twhile (count + row < R) and matrix[count+row][col] == \\'1\\':\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\theights[col] = count\\n\\n\\tdef largest_rectangle() -> int:\\n\\t\\t\\'\\'\\'\\n\\t\\tReturns the area of the largest rectangle.  \\n\\t\\tOnly rectangles whose top edge is in the current row are considered.\\n\\t\\t\\'\\'\\'\\n\\t\\tnonlocal heights, matrix\\n\\n\\t\\t# 1. Find the index of the first column to the RIGHT of (i) that is shorter than heights[i]\\n\\t\\tright = [len(heights)]*len(heights)\\n\\t\\tstack = []\\n\\t\\tfor i,h1 in enumerate(heights):\\n\\t\\t\\twhile stack and (h1 < stack[-1][1]):\\n\\t\\t\\t\\tj,h2 = stack.pop()\\n\\t\\t\\t\\tright[j] = i\\n\\t\\t\\tstack.append((i,h1))\\n\\n\\t\\t# 2. Find the index of the first column to the LEFT of (i) that is shorter than heights[i]\\n\\t\\tleft = [-1]*len(heights)\\n\\t\\tstack = []\\n\\t\\tfor i in range(len(heights)-1,-1,-1):\\n\\t\\t\\th1 = heights[i]\\n\\t\\t\\twhile stack and (h1 < stack[-1][1]):\\n\\t\\t\\t\\tj,h2 = stack.pop()\\n\\t\\t\\t\\tleft[j] = i\\n\\t\\t\\tstack.append((i,h1))\\n\\n\\t\\t# 3. The largest rectangle at each location will be height (h) times the width (right[i] - left[i] - 1)\\n\\t\\treturn max(h * (right[i] - left[i] - 1) for i,h in enumerate(heights))\\n\\n\\tres = 0\\n\\tif not matrix: return res\\n\\tR, C = len(matrix), len(matrix[0])\\n\\theights = [0]*C # 1\\n\\n\\tfor row in range(R):\\n\\t\\tupdate_heights(row)                 # 2.1\\n\\t\\tres = max(res, largest_rectangle()) # 2.2\\n\\n\\treturn res     \\n```\\n\\n**Here is a walk-through of the example in the description:**\\n\\n(#1) Heights is initialized to [0, 0, 0, 0, 0] meaning the height of every column still needs to be calculated.  \\n\\n(#2.1) Update heights for the first row:\\n**Row 0: heights = [4, 0, 3, 0, 0] ; area = 4 ; res = max(0, 4)**\\n\\n  [<b>\"1\"</b>,\"0\",<b>\"1\"</b>,\"0\",\"0\"]\\n  [<b>\"1\"</b>,\"0\",<b>\"1\"</b>,\"1\",\"1\"]\\n  [<b>\"1\"</b>,\"1\",<b>\"1\"</b>,\"1\",\"1\"]\\n  [<b>\"1\"</b>,\"0\",\"0\", \"1\",\"0\"]\\n\\n(#2.2) Calculate the largest rectangle area, of rectangles whose top is at row 0.  \\n```\\ni.e. Column 0 has an area of 4 # largest area is 4\\n     Column 1 has an area of 0\\n     Column 2 has an area of 3\\n     Column 3 has an area of 0\\n     Column 4 has an area of 0\\n```\\n(#3) Repeat steps (#2.1) and (#2.2) for the remaining rows, updating **res** at each step:\\n\\n**Row 1: heights = [3, 0, 2, 3, 2] ; area = 6 ; res = max(4, 6)**\\n  [\"1\", \"0\",\"1\", \"0\", \"0\"]\\n  [<b>\"1\"</b>,\"0\",<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>]\\n  [<b>\"1\"</b>,\"1\",<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>]\\n  [<b>\"1\"</b>,\"0\",\"0\", <b>\"1\"</b>, \"0\"]\\n  \\n```\\n                          # height * (right_index - left_index - 1) = area\\nColumn 0 has an area of 3 # 3 * (1 - (-1) - 1) = 3\\nColumn 1 has an area of 0 # 0 * (5 - (-1) - 1) = 0\\nColumn 2 has an area of 6 # 2 * (5 - 1 - 1) = 6\\nColumn 3 has an area of 3 # 3 * (4 - 2 - 1) = 3\\nColumn 4 has an area of 6 # 2 * (5 - 1 - 1) = 6\\n```\\n  \\n**Row 2: heights = [2, 1, 1, 2, 1] ; area = 5 ; res = max(6, 5)**\\n  [\"1\", \"0\", \"1\", \"0\", \"0\"]\\n  [\"1\", \"0\", \"1\", \"1\", \"1\"]\\n  [<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>,<b>\"1\"</b>]\\n  [<b>\"1\"</b>, \"0\", \"0\",<b>\"1\"</b>, \"0\"]\\n  \\n**Row 3: heights = [1, 0, 0, 1, 0] ; area = 1 ; res = max(6, 1)**\\n  [\"1\", \"0\",\"1\",\"0\", \"0\"]\\n  [\"1\", \"0\",\"1\",\"1\", \"1\"]\\n  [\"1\", \"1\",\"1\",\"1\", \"1\"]\\n  [<b>\"1\"</b>,\"0\",\"0\",<b>\"1\"</b>,\"0\"]",
                "solutionTags": [],
                "code": "```python\\ndef maximalRectangle(self, matrix: List[List[str]]) -> int:\\n\\n\\tdef update_heights(row: int) -> None:\\n\\t\\t\\'\\'\\'\\n\\t\\tUpdates heights in place.\\n\\t\\tInitially heights[col] represents the height at index (col) from the previous row.  \\n\\t\\tIf heights[col] IS NOT zero, then heights[col] of the current row will just be heights[col] - 1.\\n\\t\\tIf heights[col] IS zero, then traverse up column matrix[row:][col] to find the height of the column.  \\n\\t\\t\\'\\'\\'\\n\\t\\tnonlocal heights, matrix\\n\\n\\t\\tfor col,h in enumerate(heights):\\n\\t\\t\\tif h:\\n\\t\\t\\t\\theights[col] -= 1\\n\\t\\t\\telif matrix[row][col] == \\'0\\':\\n\\t\\t\\t\\theights[col] = 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\twhile (count + row < R) and matrix[count+row][col] == \\'1\\':\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\theights[col] = count\\n\\n\\tdef largest_rectangle() -> int:\\n\\t\\t\\'\\'\\'\\n\\t\\tReturns the area of the largest rectangle.  \\n\\t\\tOnly rectangles whose top edge is in the current row are considered.\\n\\t\\t\\'\\'\\'\\n\\t\\tnonlocal heights, matrix\\n\\n\\t\\t# 1. Find the index of the first column to the RIGHT of (i) that is shorter than heights[i]\\n\\t\\tright = [len(heights)]*len(heights)\\n\\t\\tstack = []\\n\\t\\tfor i,h1 in enumerate(heights):\\n\\t\\t\\twhile stack and (h1 < stack[-1][1]):\\n\\t\\t\\t\\tj,h2 = stack.pop()\\n\\t\\t\\t\\tright[j] = i\\n\\t\\t\\tstack.append((i,h1))\\n\\n\\t\\t# 2. Find the index of the first column to the LEFT of (i) that is shorter than heights[i]\\n\\t\\tleft = [-1]*len(heights)\\n\\t\\tstack = []\\n\\t\\tfor i in range(len(heights)-1,-1,-1):\\n\\t\\t\\th1 = heights[i]\\n\\t\\t\\twhile stack and (h1 < stack[-1][1]):\\n\\t\\t\\t\\tj,h2 = stack.pop()\\n\\t\\t\\t\\tleft[j] = i\\n\\t\\t\\tstack.append((i,h1))\\n\\n\\t\\t# 3. The largest rectangle at each location will be height (h) times the width (right[i] - left[i] - 1)\\n\\t\\treturn max(h * (right[i] - left[i] - 1) for i,h in enumerate(heights))\\n\\n\\tres = 0\\n\\tif not matrix: return res\\n\\tR, C = len(matrix), len(matrix[0])\\n\\theights = [0]*C # 1\\n\\n\\tfor row in range(R):\\n\\t\\tupdate_heights(row)                 # 2.1\\n\\t\\tres = max(res, largest_rectangle()) # 2.2\\n\\n\\treturn res     \\n```\n```\\ni.e. Column 0 has an area of 4 # largest area is 4\\n     Column 1 has an area of 0\\n     Column 2 has an area of 3\\n     Column 3 has an area of 0\\n     Column 4 has an area of 0\\n```\n```\\n                          # height * (right_index - left_index - 1) = area\\nColumn 0 has an area of 3 # 3 * (1 - (-1) - 1) = 3\\nColumn 1 has an area of 0 # 0 * (5 - (-1) - 1) = 0\\nColumn 2 has an area of 6 # 2 * (5 - 1 - 1) = 6\\nColumn 3 has an area of 3 # 3 * (4 - 2 - 1) = 3\\nColumn 4 has an area of 6 # 2 * (5 - 1 - 1) = 6\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 769455,
                "title": "python-dp-soln-on-largest-rect-in-histogram-faster-than-91",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def histogramArea(self,A):\\n        n = len(A)\\n        stack = deque()\\n        \\n        max_area = 0\\n        i = 0\\n        \\n        while i < n:\\n            if not stack or A[stack[-1]] <= A[i]:\\n                stack.append(i)\\n                i += 1\\n            else:\\n                top = stack.pop()\\n                area = A[top] * ((i - stack[-1] -1) if stack else i)\\n                max_area = max(area, max_area)\\n        \\n        while stack:\\n            top = stack.pop()\\n            area = A[top] * ((i - stack[-1] -1) if stack else i)\\n            max_area = max(area, max_area)\\n        \\n        return max_area\\n            \\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0: return 0\\n        n = len(matrix[0])\\n        \\n        dp = [int(i) for i in matrix[0]]\\n        ans = 0\\n        \\n        area = self.histogramArea(dp)\\n        ans = max(ans,area)\\n        \\n        for i in range(1,m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    dp[j] += 1\\n                else:\\n                    dp[j] = 0\\n                    \\n            area = self.histogramArea(dp)\\n            ans = max(ans,area)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def histogramArea(self,A):\\n        n = len(A)\\n        stack = deque()\\n        \\n        max_area = 0\\n        i = 0\\n        \\n        while i < n:\\n            if not stack or A[stack[-1]] <= A[i]:\\n                stack.append(i)\\n                i += 1\\n            else:\\n                top = stack.pop()\\n                area = A[top] * ((i - stack[-1] -1) if stack else i)\\n                max_area = max(area, max_area)\\n        \\n        while stack:\\n            top = stack.pop()\\n            area = A[top] * ((i - stack[-1] -1) if stack else i)\\n            max_area = max(area, max_area)\\n        \\n        return max_area\\n            \\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0: return 0\\n        n = len(matrix[0])\\n        \\n        dp = [int(i) for i in matrix[0]]\\n        ans = 0\\n        \\n        area = self.histogramArea(dp)\\n        ans = max(ans,area)\\n        \\n        for i in range(1,m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    dp[j] += 1\\n                else:\\n                    dp[j] = 0\\n                    \\n            area = self.histogramArea(dp)\\n            ans = max(ans,area)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679232,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        if(matrix ==null || matrix.length==0)\\n            return 0;\\n        \\n        int[] dp = new int[matrix[0].length];\\n        int res = 0;\\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                if(matrix[i][j] == \\'0\\') {\\n                    dp[j] = 0;\\n                    continue;\\n                }\\n                dp[j] = dp[j] + matrix[i][j]-\\'0\\';\\n            }\\n            res = Math.max(res, histogra(dp));\\n        }\\n        return res;\\n    }\\n    \\n    private int histogra(int[] dp) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for(int i=0;i<dp.length;i++) {\\n            \\n            while(!st.isEmpty() && dp[i] <= dp[st.peek()] ) {\\n                \\n                int top = st.pop();\\n                int area = (i-(st.isEmpty() ? -1 : st.peek())-1)*dp[top];\\n                res = Math.max(area, res);\\n            }   \\n            st.push(i);\\n        }\\n        while(!st.isEmpty()) {\\n            int top = st.pop();\\n            int area = (dp.length-(st.isEmpty() ? -1 : st.peek())-1)*dp[top];\\n            res = Math.max(area, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        \\n        if(matrix ==null || matrix.length==0)\\n            return 0;\\n        \\n        int[] dp = new int[matrix[0].length];\\n        int res = 0;\\n        for(int i=0;i<matrix.length;i++) {\\n            for(int j=0;j<matrix[0].length;j++) {\\n                if(matrix[i][j] == \\'0\\') {\\n                    dp[j] = 0;\\n                    continue;\\n                }\\n                dp[j] = dp[j] + matrix[i][j]-\\'0\\';\\n            }\\n            res = Math.max(res, histogra(dp));\\n        }\\n        return res;\\n    }\\n    \\n    private int histogra(int[] dp) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for(int i=0;i<dp.length;i++) {\\n            \\n            while(!st.isEmpty() && dp[i] <= dp[st.peek()] ) {\\n                \\n                int top = st.pop();\\n                int area = (i-(st.isEmpty() ? -1 : st.peek())-1)*dp[top];\\n                res = Math.max(area, res);\\n            }   \\n            st.push(i);\\n        }\\n        while(!st.isEmpty()) {\\n            int top = st.pop();\\n            int area = (dp.length-(st.isEmpty() ? -1 : st.peek())-1)*dp[top];\\n            res = Math.max(area, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623207,
                "title": "c-simple-o-nm-time-space-solution",
                "content": "```\\n// note that there are 2 published O(M) space solutions \\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {\\n        if (matrix.empty ())\\n            return 0;\\n        \\n        vector <vector <pair <int,int>>> dp (matrix.size ()+1, vector <pair <int,int>> (matrix [0].size ()+1)); // largest rectangle with (i-1, j-1) as bottom right vertex.\\n        vector <vector <int>> dpr (matrix.size ()+1, vector <int> (matrix [0].size ()+1)); // longest horizontal line with (i-1, j-1) as right end point.\\n        vector <vector <int>> dpc = dpr; // tallent vertical line with (i-1, j-1) as bottom end point.\\n        int ret = 0;\\n        \\n        for (int i = 0; i < matrix.size (); i++)\\n            for (int j = 0; j < matrix [0].size (); j++)\\n                if (matrix [i][j] == \\'1\\')\\n                {\\n                    // build out horizontal, vertical lines.\\n                    dpr [i+1][j+1] = 1 + dpr [i+1][j];\\n                    dpc [i+1][j+1] = 1 + dpc [i][j+1];\\n                    \\n                    // build out rectangle.\\n                    // 1. based on contained rectangle with current row, column taken out.\\n                    dp [i+1][j+1] = {1 + min (dp [i][j].first, dpc [i][j+1]), 1 + min (dp [i][j].second, dpr [i+1][j])};\\n                    \\n                    // 2. based on horizontal line.\\n                    if (dpr [i+1][j+1] > dp [i+1][j+1].first * dp [i+1][j+1].second)\\n                        dp [i+1][j+1] = {1, dpr [i+1][j+1]};\\n                    \\n                    // 3. based on veritical line.\\n                    if (dpc [i+1][j+1] > dp [i+1][j+1].first * dp [i+1][j+1].second)\\n                        dp [i+1][j+1] = {dpc [i+1][j+1], 1};\\n                    \\n                    // maintain return value.\\n                    ret = max (ret, dp [i+1][j+1].first * dp [i+1][j+1].second);\\n                }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// note that there are 2 published O(M) space solutions \\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) \\n    {\\n        if (matrix.empty ())\\n            return 0;\\n        \\n        vector <vector <pair <int,int>>> dp (matrix.size ()+1, vector <pair <int,int>> (matrix [0].size ()+1)); // largest rectangle with (i-1, j-1) as bottom right vertex.\\n        vector <vector <int>> dpr (matrix.size ()+1, vector <int> (matrix [0].size ()+1)); // longest horizontal line with (i-1, j-1) as right end point.\\n        vector <vector <int>> dpc = dpr; // tallent vertical line with (i-1, j-1) as bottom end point.\\n        int ret = 0;\\n        \\n        for (int i = 0; i < matrix.size (); i++)\\n            for (int j = 0; j < matrix [0].size (); j++)\\n                if (matrix [i][j] == \\'1\\')\\n                {\\n                    // build out horizontal, vertical lines.\\n                    dpr [i+1][j+1] = 1 + dpr [i+1][j];\\n                    dpc [i+1][j+1] = 1 + dpc [i][j+1];\\n                    \\n                    // build out rectangle.\\n                    // 1. based on contained rectangle with current row, column taken out.\\n                    dp [i+1][j+1] = {1 + min (dp [i][j].first, dpc [i][j+1]), 1 + min (dp [i][j].second, dpr [i+1][j])};\\n                    \\n                    // 2. based on horizontal line.\\n                    if (dpr [i+1][j+1] > dp [i+1][j+1].first * dp [i+1][j+1].second)\\n                        dp [i+1][j+1] = {1, dpr [i+1][j+1]};\\n                    \\n                    // 3. based on veritical line.\\n                    if (dpc [i+1][j+1] > dp [i+1][j+1].first * dp [i+1][j+1].second)\\n                        dp [i+1][j+1] = {dpc [i+1][j+1], 1};\\n                    \\n                    // maintain return value.\\n                    ret = max (ret, dp [i+1][j+1].first * dp [i+1][j+1].second);\\n                }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616182,
                "title": "python-same-idea-as-leetcode-84-largest-histogram-area",
                "content": "```python\\nclass Solution(object):\\n    def maxArea(self, bar):\\n        if not bar:\\n            return 0\\n        bar.append(0)\\n        s, ret = [], 0\\n        for i in range(len(bar)):\\n            while s and bar[i] <= bar[s[-1]]:\\n                h = bar[s[-1]]\\n                s.pop()\\n                if s:\\n                    w = i -1 - s[-1]\\n                else:\\n                    w = i\\n                ret = max(ret, h*w)\\n            s.append(i)\\n        return ret\\n    def maximalRectangle(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        M, N = len(matrix), len(matrix[0])\\n        bar = [0]*N\\n        ret = 0\\n        for i in range(M):\\n            for j in range(N):\\n                if matrix[i][j] == \\'1\\':\\n                    bar[j]+=1\\n                else:\\n                    bar[j] = 0\\n            ret = max(ret, self.maxArea(bar))\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxArea(self, bar):\\n        if not bar:\\n            return 0\\n        bar.append(0)\\n        s, ret = [], 0\\n        for i in range(len(bar)):\\n            while s and bar[i] <= bar[s[-1]]:\\n                h = bar[s[-1]]\\n                s.pop()\\n                if s:\\n                    w = i -1 - s[-1]\\n                else:\\n                    w = i\\n                ret = max(ret, h*w)\\n            s.append(i)\\n        return ret\\n    def maximalRectangle(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        M, N = len(matrix), len(matrix[0])\\n        bar = [0]*N\\n        ret = 0\\n        for i in range(M):\\n            for j in range(N):\\n                if matrix[i][j] == \\'1\\':\\n                    bar[j]+=1\\n                else:\\n                    bar[j] = 0\\n            ret = max(ret, self.maxArea(bar))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562266,
                "title": "5-ms-sec-java-solution-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int row=matrix.length;\\n        if(row==0)\\n            return 0;\\n        int col=matrix[0].length;\\n        int[][] left=new int[row][col];//to keep track of max left.->->->\\n        int[][] up=new int[row][col];//to keep track of max top.^\\n        int max=0;\\n        if(matrix[0][0]==\\'1\\')\\n        {\\n            left[0][0]=1;\\n            up[0][0]=1;\\n            max=1;\\n        }\\n        for(int i=1;i<row;i++)\\n        {\\n            if(matrix[i][0]==\\'1\\'){\\n                up[i][0]=up[i-1][0]+1;\\n                left[i][0]=1;\\n                max=Math.max(up[i][0],max);\\n            }\\n        }\\n        \\n        for(int j=1;j<col;j++)\\n        {\\n            if(matrix[0][j]==\\'1\\'){\\n                left[0][j]=left[0][j-1]+1;\\n                up[0][j]=1;\\n                max=Math.max(left[0][j],max);\\n            }\\n        }\\n        for(int i=1;i<row;i++)\\n        {\\n            for(int j=1;j<col;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    int upto=0;\\n                    left[i][j]=left[i][j-1]+1;\\n                    up[i][j]=up[i-1][j]+1;\\n                    \\n                    if(left[i][j]>1 && up[i][j]>1)\\n                    {\\n                        int val=0; \\n                        int track=i;\\n                        int min=left[i][j];\\n                        while(track>=0 && left[track][j]>1 && up[track][j]>=1)//this is important when both top and left are\\n                        {                                                     //non zero\\n                            if(min>left[track][j])\\n                                min=left[track][j];\\n                            val++;\\n                            upto=Math.max(min*val,upto);\\n                            track--;\\n                        }\\n                    }\\n                    \\n                    max=Math.max(max,Math.max(left[i][j],Math.max(up[i][j],upto)));\\n                }\\n                else\\n                {\\n                    left[i][j]=0;\\n                    up[i][j]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int row=matrix.length;\\n        if(row==0)\\n            return 0;\\n        int col=matrix[0].length;\\n        int[][] left=new int[row][col];//to keep track of max left.->->->\\n        int[][] up=new int[row][col];//to keep track of max top.^\\n        int max=0;\\n        if(matrix[0][0]==\\'1\\')\\n        {\\n            left[0][0]=1;\\n            up[0][0]=1;\\n            max=1;\\n        }\\n        for(int i=1;i<row;i++)\\n        {\\n            if(matrix[i][0]==\\'1\\'){\\n                up[i][0]=up[i-1][0]+1;\\n                left[i][0]=1;\\n                max=Math.max(up[i][0],max);\\n            }\\n        }\\n        \\n        for(int j=1;j<col;j++)\\n        {\\n            if(matrix[0][j]==\\'1\\'){\\n                left[0][j]=left[0][j-1]+1;\\n                up[0][j]=1;\\n                max=Math.max(left[0][j],max);\\n            }\\n        }\\n        for(int i=1;i<row;i++)\\n        {\\n            for(int j=1;j<col;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    int upto=0;\\n                    left[i][j]=left[i][j-1]+1;\\n                    up[i][j]=up[i-1][j]+1;\\n                    \\n                    if(left[i][j]>1 && up[i][j]>1)\\n                    {\\n                        int val=0; \\n                        int track=i;\\n                        int min=left[i][j];\\n                        while(track>=0 && left[track][j]>1 && up[track][j]>=1)//this is important when both top and left are\\n                        {                                                     //non zero\\n                            if(min>left[track][j])\\n                                min=left[track][j];\\n                            val++;\\n                            upto=Math.max(min*val,upto);\\n                            track--;\\n                        }\\n                    }\\n                    \\n                    max=Math.max(max,Math.max(left[i][j],Math.max(up[i][j],upto)));\\n                }\\n                else\\n                {\\n                    left[i][j]=0;\\n                    up[i][j]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544591,
                "title": "java-dp",
                "content": "\\t// Induction Rule: dp[i][j] represents the cur largest length at row i, from 0 to j\\n\\t// Base case: j == 0 && matrix[i][j] == 1  --> length == 1\\n\\t// Time: O(rows * cols * rows) --> O(rows * rows * cols) = O(N^2 * M)\\n\\t// Space: 2d array : O(rows * cols) -> O(N * M)\\n\\tclass Solution {\\n\\t\\tpublic int maximalRectangle(char[][] matrix) {\\n\\t\\t\\tif (matrix == null || matrix.length == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint maxArea = 0;\\n\\t\\t\\tint rows = matrix.length;\\n\\t\\t\\tint cols = matrix[0].length;\\n\\t\\t\\tint[][] dp = new int[rows][cols];\\n\\t\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\t\\tif (matrix[i][j] == \\'1\\') {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1; \\n\\t\\t\\t\\t\\t\\tint length = dp[i][j];\\n\\t\\t\\t\\t\\t\\tfor (int k = i; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\t\\tlength = Math.min(length, dp[k][j]);  // horizontal \\n\\t\\t\\t\\t\\t\\t\\tint width = i - k + 1; // vertical\\n\\t\\t\\t\\t\\t\\t\\tmaxArea = Math.max(maxArea, length * width);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\treturn maxArea;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int maximalRectangle(char[][] matrix) {\\n\\t\\t\\tif (matrix == null || matrix.length == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 495606,
                "title": "easy-solution-based-on-leetcode-84-largest-rectangle-in-histogram-beats-78-15",
                "content": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalRectangle = function(matrix) {\\n    if (!matrix || !matrix.length) {\\n        return 0;\\n    }\\n    \\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    const heights = Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            heights[j] = matrix[i][j] == \\'1\\' ? heights[j] + 1 : 0;\\n        }\\n        max = Math.max(max, maximalRectangleInHistogram(heights));\\n    }\\n    \\n    return max;\\n};\\n\\nfunction maximalRectangleInHistogram(heights) {\\n    const n = heights.length;\\n    const left = Array(n).fill(0);\\n    const right = Array(n).fill(n-1);\\n    let max = 0;\\n    \\n    for (let i = 1; i < n; i++) {\\n        let j = i - 1;\\n        while (j >= 0 && heights[j] >= heights[i]) {\\n            j = left[j] - 1;\\n        }\\n        left[i] = j + 1;\\n    }\\n    \\n    for (let i = n - 2; i >= 0; i--) {\\n        let j = i + 1;\\n        while (j < n && heights[j] >= heights[i]) {\\n            j = right[j] + 1;\\n        }\\n        right[i] = j - 1;\\n    }\\n    \\n    for (let i = 0; i < n; i++) {\\n        max = Math.max(max, heights[i] * (right[i] - left[i] + 1));\\n    }\\n    \\n    return max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalRectangle = function(matrix) {\\n    if (!matrix || !matrix.length) {\\n        return 0;\\n    }\\n    \\n    const m = matrix.length;\\n    const n = matrix[0].length;\\n    const heights = Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            heights[j] = matrix[i][j] == \\'1\\' ? heights[j] + 1 : 0;\\n        }\\n        max = Math.max(max, maximalRectangleInHistogram(heights));\\n    }\\n    \\n    return max;\\n};\\n\\nfunction maximalRectangleInHistogram(heights) {\\n    const n = heights.length;\\n    const left = Array(n).fill(0);\\n    const right = Array(n).fill(n-1);\\n    let max = 0;\\n    \\n    for (let i = 1; i < n; i++) {\\n        let j = i - 1;\\n        while (j >= 0 && heights[j] >= heights[i]) {\\n            j = left[j] - 1;\\n        }\\n        left[i] = j + 1;\\n    }\\n    \\n    for (let i = n - 2; i >= 0; i--) {\\n        let j = i + 1;\\n        while (j < n && heights[j] >= heights[i]) {\\n            j = right[j] + 1;\\n        }\\n        right[i] = j - 1;\\n    }\\n    \\n    for (let i = 0; i < n; i++) {\\n        max = Math.max(max, heights[i] * (right[i] - left[i] + 1));\\n    }\\n    \\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494079,
                "title": "c-reuse-code-in-question-84",
                "content": "```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        const int m = matrix.size();\\n        if (m == 0) return 0;\\n        const int n = matrix[0].size();\\n        if (n == 0) return 0;\\n        vector<vector<int>> vert_dp(m, vector<int>(n)); // height of vertical segmanet whose bottom point is [i][j]\\n        \\n        for (int j = 0; j < n; j++){\\n            vert_dp[0][j] = (matrix[0][j] == \\'1\\');\\n            for (int i = 1; i < m; i++){\\n                vert_dp[i][j] = (matrix[i][j] == \\'1\\') ? vert_dp[i-1][j]+1 : 0;\\n            }\\n        }\\n        \\n        int cur_max = 0;\\n        for (int i = 0; i < m; i++){\\n            cur_max = max(cur_max, largestRectangleArea(vert_dp[i]));\\n        }\\n        \\n        return cur_max;\\n    }\\n    \\n    \\n    // 84.largestRectangleArea() by:\\n    // https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/492959/C%2B%2B-easy-using-stack\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> s;\\n        if(heights.size()==0)return 0;\\n        int ans = heights[0];\\n        int n = heights.size();\\n        int i = 0;\\n        int tp = 0;\\n        while(i<n) {\\n            if(s.empty() || heights[s.top()] <= heights[i]) { // ensure the heights in stack is ascending\\n                s.push(i++);\\n                //cout << s.top()  << \": \" << heights[s.top()] << endl;\\n            } else { // drive out all the previous heights that is greater than heights[i]\\n                tp = s.top();\\n                s.pop();\\n                ans = max(ans, heights[tp] * (s.empty()?i: i - s.top() - 1)); \\n                // indexes from s.top() to i-1, because heights[i-1] >= s.top()\\n            }\\n        }\\n        \\n        while(!s.empty()) {\\n            tp = s.top();\\n            s.pop();\\n            ans = max(ans,heights[tp] *  (s.empty()?i: i - s.top() - 1));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        const int m = matrix.size();\\n        if (m == 0) return 0;\\n        const int n = matrix[0].size();\\n        if (n == 0) return 0;\\n        vector<vector<int>> vert_dp(m, vector<int>(n)); // height of vertical segmanet whose bottom point is [i][j]\\n        \\n        for (int j = 0; j < n; j++){\\n            vert_dp[0][j] = (matrix[0][j] == \\'1\\');\\n            for (int i = 1; i < m; i++){\\n                vert_dp[i][j] = (matrix[i][j] == \\'1\\') ? vert_dp[i-1][j]+1 : 0;\\n            }\\n        }\\n        \\n        int cur_max = 0;\\n        for (int i = 0; i < m; i++){\\n            cur_max = max(cur_max, largestRectangleArea(vert_dp[i]));\\n        }\\n        \\n        return cur_max;\\n    }\\n    \\n    \\n    // 84.largestRectangleArea() by:\\n    // https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/492959/C%2B%2B-easy-using-stack\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> s;\\n        if(heights.size()==0)return 0;\\n        int ans = heights[0];\\n        int n = heights.size();\\n        int i = 0;\\n        int tp = 0;\\n        while(i<n) {\\n            if(s.empty() || heights[s.top()] <= heights[i]) { // ensure the heights in stack is ascending\\n                s.push(i++);\\n                //cout << s.top()  << \": \" << heights[s.top()] << endl;\\n            } else { // drive out all the previous heights that is greater than heights[i]\\n                tp = s.top();\\n                s.pop();\\n                ans = max(ans, heights[tp] * (s.empty()?i: i - s.top() - 1)); \\n                // indexes from s.top() to i-1, because heights[i-1] >= s.top()\\n            }\\n        }\\n        \\n        while(!s.empty()) {\\n            tp = s.top();\\n            s.pop();\\n            ans = max(ans,heights[tp] *  (s.empty()?i: i - s.top() - 1));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 474014,
                "title": "accepted-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        //https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        private int LargestRectangleArea(int[] heights)\\n        {\\n            if (heights.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            if (heights.Length == 1)\\n            {\\n                return heights[0];\\n            }\\n\\n            int res = heights[0];\\n            Stack<int> indices = new Stack<int>();\\n            for (int i = 0; i < heights.Length; i++)\\n            {\\n                while (indices.Count > 0 && heights[indices.Peek()] >= heights[i])\\n                {\\n                    var pop = indices.Pop();\\n                    var leftMost = indices.Count > 0 ? indices.Peek() + 1 : 0;\\n                    res = Math.Max(res, heights[pop] * (i - leftMost));\\n                }\\n                indices.Push(i);\\n            }\\n\\n            while (indices.Count > 0)\\n            {\\n                var pop = indices.Pop();\\n                var leftMost = indices.Count > 0 ? indices.Peek() + 1 : 0;\\n                res = Math.Max(res, heights[pop] * (heights.Length - leftMost));\\n            }\\n            return res;\\n        }\\n\\n        public int MaximalRectangle(char[][] matrix)\\n        {\\n            if (matrix.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            int res = 0;\\n\\n            int[] heights = null;\\n            for (int i = 0; i < matrix.Length; i++)\\n            {\\n                if (heights == null)\\n                {\\n                    heights = matrix[i].Select(c => c - \\'0\\').ToArray();\\n                }\\n                else\\n                {\\n                    for (int j = 0; j < matrix[i].Length; j++)\\n                    {\\n                        if (matrix[i][j] == \\'0\\')\\n                        {\\n                            heights[j] = 0;\\n                        }\\n                        else\\n                        {\\n                            heights[j]++;\\n                        }\\n                    }\\n                }\\n\\n                res = Math.Max(res, LargestRectangleArea(heights));\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        //https://leetcode.com/problems/largest-rectangle-in-histogram/\\n        private int LargestRectangleArea(int[] heights)\\n        {\\n            if (heights.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            if (heights.Length == 1)\\n            {\\n                return heights[0];\\n            }\\n\\n            int res = heights[0];\\n            Stack<int> indices = new Stack<int>();\\n            for (int i = 0; i < heights.Length; i++)\\n            {\\n                while (indices.Count > 0 && heights[indices.Peek()] >= heights[i])\\n                {\\n                    var pop = indices.Pop();\\n                    var leftMost = indices.Count > 0 ? indices.Peek() + 1 : 0;\\n                    res = Math.Max(res, heights[pop] * (i - leftMost));\\n                }\\n                indices.Push(i);\\n            }\\n\\n            while (indices.Count > 0)\\n            {\\n                var pop = indices.Pop();\\n                var leftMost = indices.Count > 0 ? indices.Peek() + 1 : 0;\\n                res = Math.Max(res, heights[pop] * (heights.Length - leftMost));\\n            }\\n            return res;\\n        }\\n\\n        public int MaximalRectangle(char[][] matrix)\\n        {\\n            if (matrix.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            int res = 0;\\n\\n            int[] heights = null;\\n            for (int i = 0; i < matrix.Length; i++)\\n            {\\n                if (heights == null)\\n                {\\n                    heights = matrix[i].Select(c => c - \\'0\\').ToArray();\\n                }\\n                else\\n                {\\n                    for (int j = 0; j < matrix[i].Length; j++)\\n                    {\\n                        if (matrix[i][j] == \\'0\\')\\n                        {\\n                            heights[j] = 0;\\n                        }\\n                        else\\n                        {\\n                            heights[j]++;\\n                        }\\n                    }\\n                }\\n\\n                res = Math.Max(res, LargestRectangleArea(heights));\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391679,
                "title": "python-solution-using-stack-and-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        mat = matrix\\n        if mat==[]:\\n            return 0\\n        else:\\n            def histogram_area(arr):\\n                stack = []\\n                max_area,index = 0,0\\n                while index<len(arr):\\n                    if (not stack) or (arr[stack[-1]])<=arr[index]:\\n                        stack.append(index)\\n                        index+=1\\n                    else:\\n                        top = stack.pop()\\n                        if stack:\\n                            area = arr[top]*(index-stack[-1]-1)\\n                        else:\\n                            area = arr[top]*index\\n                        max_area = max(area,max_area)\\n                while stack:\\n                    top = stack.pop()\\n                    if stack:\\n                        area = arr[top]*(index-stack[-1]-1)\\n                    else:\\n                        area = arr[top]*index\\n                    max_area = max(area,max_area)\\n                return max_area\\n            for i in range(len(mat)):\\n                if i==0:\\n                    arr = []\\n                    for j in mat[i]:\\n                        if j==\\'0\\':\\n                            arr.append(0)\\n                        else:\\n                            arr.append(1)\\n                    max_area = histogram_area(arr)\\n                else:\\n                    temp = []\\n                    for j in range(len(mat[i])):\\n                        if mat[i][j] == \\'0\\':\\n                            temp.append(0)\\n                        else:\\n                            temp.append(arr[j]+1)\\n                    area = histogram_area(temp)\\n                    max_area = max(area,max_area)\\n                    arr = temp\\n            return max_area\\n                        \\n                        \\n        \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        mat = matrix\\n        if mat==[]:\\n            return 0\\n        else:\\n            def histogram_area(arr):\\n                stack = []\\n                max_area,index = 0,0\\n                while index<len(arr):\\n                    if (not stack) or (arr[stack[-1]])<=arr[index]:\\n                        stack.append(index)\\n                        index+=1\\n                    else:\\n                        top = stack.pop()\\n                        if stack:\\n                            area = arr[top]*(index-stack[-1]-1)\\n                        else:\\n                            area = arr[top]*index\\n                        max_area = max(area,max_area)\\n                while stack:\\n                    top = stack.pop()\\n                    if stack:\\n                        area = arr[top]*(index-stack[-1]-1)\\n                    else:\\n                        area = arr[top]*index\\n                    max_area = max(area,max_area)\\n                return max_area\\n            for i in range(len(mat)):\\n                if i==0:\\n                    arr = []\\n                    for j in mat[i]:\\n                        if j==\\'0\\':\\n                            arr.append(0)\\n                        else:\\n                            arr.append(1)\\n                    max_area = histogram_area(arr)\\n                else:\\n                    temp = []\\n                    for j in range(len(mat[i])):\\n                        if mat[i][j] == \\'0\\':\\n                            temp.append(0)\\n                        else:\\n                            temp.append(arr[j]+1)\\n                    area = histogram_area(temp)\\n                    max_area = max(area,max_area)\\n                    arr = temp\\n            return max_area\\n                        \\n                        \\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 369948,
                "title": "solved-with-largest-rectangle-area-as-base-algorithm-ruby-94",
                "content": "check following videos if you couldn\\'t figure out, \\nTo solve this challenge, first need to solve the challenge 84 - largest rectangle area, once it solve, this challenge become very simple. \\n\\n### Explaination for Maximal Rectangle\\nhttps://www.youtube.com/watch?v=g8bSdXCG-lA\\n\\n### Exlaination for Largest Rectangle Area\\nhttps://www.youtube.com/watch?v=ZmnqCZp9bBs\\n\\n```ruby\\ndef maximal_rectangle(matrix)\\n  row = matrix.size\\n  return 0 if row == 0\\n  col = matrix.first.size\\n  max_area = 0\\n  heights = Array.new(col, 0)\\n\\n  for i in 0...row do\\n    for j in 0...col do\\n      matrix[i][j] == \"0\" ? (heights[j] = 0) : (heights[j] += 1)\\n    end\\n    area = largest_rectangle_area(heights)\\n    max_area = area if max_area < area\\n  end\\n  max_area\\nend\\n\\ndef largest_rectangle_area(heights)\\n  max_area = area = 0\\n  stack = []\\n  i = 0\\n\\n  while i < heights.size do \\n    if stack.empty? || heights[stack.last] <= heights[i]\\n      stack << i\\n      i += 1\\n    else\\n      top = stack.pop\\n      area = stack.empty? ? heights[top]*i : heights[top]*(i - stack.last - 1)\\n      max_area = area if max_area < area\\n    end\\n  end\\n\\n  while !stack.empty?\\n    top = stack.pop\\n    area = stack.empty? ? heights[top]*i : heights[top]*(i - stack.last - 1)\\n    max_area = area if max_area < area\\n  end\\n  max_area\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef maximal_rectangle(matrix)\\n  row = matrix.size\\n  return 0 if row == 0\\n  col = matrix.first.size\\n  max_area = 0\\n  heights = Array.new(col, 0)\\n\\n  for i in 0...row do\\n    for j in 0...col do\\n      matrix[i][j] == \"0\" ? (heights[j] = 0) : (heights[j] += 1)\\n    end\\n    area = largest_rectangle_area(heights)\\n    max_area = area if max_area < area\\n  end\\n  max_area\\nend\\n\\ndef largest_rectangle_area(heights)\\n  max_area = area = 0\\n  stack = []\\n  i = 0\\n\\n  while i < heights.size do \\n    if stack.empty? || heights[stack.last] <= heights[i]\\n      stack << i\\n      i += 1\\n    else\\n      top = stack.pop\\n      area = stack.empty? ? heights[top]*i : heights[top]*(i - stack.last - 1)\\n      max_area = area if max_area < area\\n    end\\n  end\\n\\n  while !stack.empty?\\n    top = stack.pop\\n    area = stack.empty? ? heights[top]*i : heights[top]*(i - stack.last - 1)\\n    max_area = area if max_area < area\\n  end\\n  max_area\\nend\\n\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1573583,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565570,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1567501,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1821428,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565343,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565830,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566882,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566474,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566070,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1898438,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1573583,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565570,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1567501,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1821428,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565343,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1565830,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566882,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566474,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1566070,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1898438,
                "content": [
                    {
                        "username": "samuelong168",
                        "content": "Not posting my solution here, but I just wanted to say what a genius question this is. \\n\\nIts one thing to be able to find the solution built on the solution of another problem (the largest histogram rectangle), its another level of creativity to come up with such a simple-looking question that uses that property (of having to use the other solution).\\n\\nKudos to whoever came up with this. Real brain teaser :D"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximal-rectangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming - Better Brute Force on Histograms\n\n  \n**Approach 3:** Using Histograms - Stack\n\n  \n**Approach 4:** Dynamic Programming - Maximum Height at Each Point\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "eggplantkiller",
                        "content": "The best way to approach this solution is to break it down into smaller parts. Let\\'s start with the first array in the matrix: `[\"1\",\"0\",\"1\",\"0\",\"0\"]`\\n\\nWe can demonstrate this visually using a histogram:\\n![image](https://assets.leetcode.com/users/images/efb944be-cc09-417f-a04a-a60ed30ff28b_1592675600.0213525.png)\\n\\nAs we can see, we can\\'t represent a rectangle from this dataset.\\n\\nNow let\\'s go to the next array in the matrix: `[\"1\",\"0\",\"1\",\"1\",\"1\"]`\\n\\nFor each value in this array, we want to add it to the value of the previous array, *unless* we encounter a zero. Then we swap it with a zero. So our array becomes: `[\"2\",\"0\",\"2\",\"1\",\"1\"]`\\n\\nWhich is represented by the following histogram:\\n![image](https://assets.leetcode.com/users/images/6a5cf231-850f-471f-869f-d90ccb054074_1592675695.6978054.png)\\n\\nAs we can see, this represents a rectangle (outlined in red) with a max size of 3. Let\\'s keep iterating through the matrix, adding the values where we can and setting them to 0 otherwise. \\n\\nNext array:  `[\"1\",\"1\",\"1\",\"1\",\"1\"]`\\n\\nReflected against our previous array, we get: `[\"3\",\"1\",\"3\",\"2\",\"2\"]`\\n\\nAnd the associated histogram: \\n![image](https://assets.leetcode.com/users/images/4748208c-af4f-4183-bc3d-bf1d4beb4c06_1592675782.2834144.png)\\n\\nA 2x3 rectangle is represented here. Now our max size is at 6. \\n\\nLet\\'s move on to the last array in the matrix:  `[\"1\",\"0\",\"0\",\"1\",\"0\"]`\\n\\nReflcted against our previous array, we get: `[\"4\",\"0\",\"0\",\"3\",\"0\"]`\\n\\nAnd the histogram: \\n![image](https://assets.leetcode.com/users/images/3e7781ca-91a4-4d5e-9882-3867575564bf_1592675868.676209.png)\\n\\nSince a rectangle isn\\'t represented in the histogram, our max size remains 6.  \\n\\n----\\n\\nI\\'ll update this with a Javascript solution soon."
                    },
                    {
                        "username": "Pawansinghrawat",
                        "content": "[@TheMarvelFan](/TheMarvelFan)  it will work if you do lie this:\\n if(dp[i][j]>0 && i>0)dp[i][j]+=dp[i-1][j];\\nAdd above(i-1) value only if (i) value is not 0"
                    },
                    {
                        "username": "neel19",
                        "content": "Very nicely explained. Thanks! "
                    },
                    {
                        "username": "likith__rg",
                        "content": "[@TheMarvelFan](/TheMarvelFan)\\n In the question the vector is given in char which means elements in matrix are char \\'0\\' & \\'1\\' insted of integers 0 & 1\\nyou can convert them by subtracting \\'0\\' from char(which means char has some ASCII value and we are converting that into int without changing its value )\\n\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "Nice appraoch but this does not work on testcases like {{1, 0}, {0, 1}} as it brings originally diagonal cells to be represented as adjacent, which will return the max area as 2 instead of 1."
                    },
                    {
                        "username": "sawamura",
                        "content": "Am I the only one who thought the array was int[][] instead of char and struggled for half hr xD"
                    },
                    {
                        "username": "PaarthCodes",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "us bro us"
                    },
                    {
                        "username": "yanggao",
                        "content": "I am confused about the requirement. If it is maximal rectangle that contains all the 1s, I could just return the size of the input if any 1 is detected anywhere..."
                    },
                    {
                        "username": "blswami",
                        "content": "It is maximal rectangle that contains only 1s"
                    },
                    {
                        "username": "douglasleer",
                        "content": "Since the input is a two dimensional char array, I wrote my test case as:\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\n\\nI got the following results:\\n\"\\nRun Code Status: Runtime Error\\n\\nRun Code Result:\\n\\nYour input\\n\\n[['1', '0', '0', '0'], ['0', '1', '1', '1'], ['0', '0', '1', '0'], ['0', '0', '0', '1']]\\nYour answer\\n\\n\\nExpected answer\\n\\n\\nRuntime: N/A\\n\"\\n\\nThen, I changed the input to: [\\u201c1000\\u201d, \\u201c0111\\u201d, \\u201c0010\\u201d, \\u201c0010\\u201d]; this time everything is good. It did not take me too much time to realize that the input should be changed as so, because I encountered similar issues before for other problems.\\n\\nThough the first format for two dimensional char array is correct, I personally prefer the second format, because the second format requres less typing.\\n\\nMy concern is that, LeetCode should indicate somewhere that, the second format is what LeetCode accepts. Otherwise, people who think the first format is the only correct format will get confused, especially the people who first encountered this issue."
                    },
                    {
                        "username": "ooliinyk",
                        "content": "O(1) space since all replacements could be done inside source matrix. Also no additional arrays are required for calculations.\\n\\u041E(N*sqrt(N)) complexity since shrinks are done sqrt(N) times with N iterations inside\\n![image](https://assets.leetcode.com/users/ooliinyk/image_1567158866.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "raviteja_ksva",
                        "content": "because largest rectangle would be one covering whole matrix, which is trivial."
                    },
                    {
                        "username": "shingcao",
                        "content": "this problem have hash table tag. How to solve it using hash table?"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "It is solved completely different way from [maximal-square](https://leetcode.com/problems/maximal-square/)  Problem.\nHighly recommend starting from [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)"
                    },
                    {
                        "username": "anandsharma1905736",
                        "content": "thanks for the tip. i was constantly trying to modify the maximal-square ans to solve this ques. thanks for the heads up, really appreciate. i was actually looking for similar comments in the discuss threads.\\n"
                    },
                    {
                        "username": "web_master_01",
                        "content": "thanx for info\\n"
                    }
                ]
            },
            {
                "id": 1790833,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1650012,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1574794,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1567844,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1568905,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 1571192,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2061475,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2046166,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2028564,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2027005,
                "content": [
                    {
                        "username": "Mansi_Soni",
                        "content": "Please find mistake in my code used MAH(v,n) maximum area of histogram function    method . divided 2d vector into four 1-D vectors. and find max area out of all 4 histograms.\\n\\nint maximalRectangle(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> v;\\n        for(int j=0;j<m;j++){\\n            v.push_back(matrix[0][j]);\\n        }\\n        int mx=MAH(v,m);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    v[j]=0;\\n                }\\n                else\\n                v[j]=v[j]+matrix[i][j];\\n            }\\n            mx=max(mx, MAH(v,m));\\n        }\\n        return mx;\\n    }"
                    },
                    {
                        "username": "ps715620",
                        "content": "solution using histogram approach || C++\nclass Solution {\n     private:\n    vector<int> nearestSmallerLeft(vector<int> &arr){\n        int n = arr.size();\n        vector<int> ans;\n        stack<pair<int, int>> s;\n       \n        \n        for(int i=0;i<n;i++){\n            if(s.size() == 0){\n                ans.push_back(-1);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(-1);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        return ans;\n    }\n\n    vector<int> nearestSmallerRight(vector<int> &arr){\n         vector<int> ans;\n        stack<pair<int, int>> s;\n        int n = arr.size();\n        \n        for(int i=n-1;i>=0;i--){\n            if(s.size() == 0){\n                ans.push_back(n);\n            }\n            else if(s.size() > 0 && s.top().first < arr[i]){\n                ans.push_back(s.top().second);\n            }\n            else {\n                while(s.size() > 0 && s.top().first >= arr[i]){\n                    s.pop();\n                }\n                if(s.size() == 0){\n                    ans.push_back(n);\n                }\n                else{\n                    ans.push_back(s.top().second);\n                }\n            }\n            s.push({arr[i], i});\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n\n        vector<int> left(n);\n        left = nearestSmallerLeft(heights);\n        \n        vector<int> right(n);\n        right = nearestSmallerRight(heights);\n        \n       vector<int>v;\n       for(int i=0;i<n;i++){\n           v.push_back((right[i]-left[i]-1)*heights[i]);   //(n-p-1)*length\n       }\n      int area=*max_element(v.begin(), v.end());\n          \n       return area;\n    }\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n\n          if(matrix.empty())\n            return 0;\n\n     int m=matrix.size();  //Number of Rows\n    int n=matrix[0].size();  //size of every row\n        vector<int> v(n,0);  //Stores 1-d histogram of level row in matrix\n     \n        int ans = 0;\n        \n        //add next rows in vector\n        for(int i=0;i<m;i++){  //row\n            for(int j=0;j<n;j++){   //col\n                //copy if 0 to 0 dalo else add krdo if 1 ha than add first array ele to another\n                if(matrix[i][j] == '0')\n                    v[j] = 0;\n                \n                else\n                  v[j] += 1;\n            }          \n            \n            //call maximumAreaHistogram function for other vectors to find maximum\n             int area = largestRectangleArea(v);\n             ans = max(ans, area);\n        }\n        \n        return ans;\n    }\n};"
                    },
                    {
                        "username": "coolgod",
                        "content": "Given a maximal rectangle with height `h`, left bound `l`, and right bound `r`, there must be a point on the interval `[l, r]` on the rectangle\\'s base where the number of consecutive ones (height) above the point is `<=h`. If this point exists, then the rectangle defined by the point in the above manner will be the maximal rectangle, as it will reach height h iterating upward and then expand to the bounds of [l, r] as all heights within those bounds must accommodate h for the rectangle to exist.\\n\\nIf this point does not exist, then the rectangle cannot be maximum, as you would be able to create a bigger rectangle by simply increasing the height of original rectangle, since all heights on the interval `[l, r]` would be greater than `h`.\\n\\nFor the above explanation, I drew a picture:\\n\\n![image](https://assets.leetcode.com/users/images/5d70da7d-1b83-4b21-80b4-f61627a61fa9_1610238989.2434196.png)\\n"
                    },
                    {
                        "username": "8326369",
                        "content": "What's the \"containing\" means? Why the expect output of \"01\" \"10\" is 1?"
                    },
                    {
                        "username": "adityabhadauria1108",
                        "content": "every independent \\'1\\' corresponds to the area 1"
                    },
                    {
                        "username": "hebele",
                        "content": "    If your answer is:\\n\\n        yes ->  show a solution \\n\\n        no  ->  prove it or state why you think it should be that way"
                    },
                    {
                        "username": "weishu",
                        "content": "In this question, we need to find the largest rectangle containing all ones.\\nBut what is the largest rectangle in the following matrix?\\n\\n0 0 1 0\\n\\n1 1 1 0\\n\\n0 1 1 1\\n\\n0 1 0 0\\n\\nPersonal speaking, I think it should contain all ones in the matrix."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "they given a matrix of characters\\ncheck if you are getting  WA"
                    },
                    {
                        "username": "tucha",
                        "content": "Everybody says about maximum rectangle in histogram... Well, it is possible to solve problem in O(n^3)"
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "why 0 and 1 are characters here? Why not considering int as a data type for this? It only increasing steps to solve this problem, nothing more."
                    },
                    {
                        "username": "thanir10",
                        "content": "Whoever came up with this solution and answer must be some genius"
                    }
                ]
            },
            {
                "id": 2021639,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1978903,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1866614,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1855963,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1815150,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1808667,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1790831,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1754146,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1707493,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            },
            {
                "id": 1665120,
                "content": [
                    {
                        "username": "vanshdhawan60",
                        "content": "my solution is only failing on the last test case. i can\\'t seem to find any error in the code. anyone else experiencing the same?"
                    },
                    {
                        "username": "anayp",
                        "content": "Why is the input matrix a matrix of chars rather than ints? This is unnecessary."
                    },
                    {
                        "username": "piyuzh",
                        "content": "i made the solution in Integer value only to lookup to the test cases were in char :("
                    },
                    {
                        "username": "garvit_17",
                        "content": "class Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        if(matrix[0][0]==\\'1\\')return 1;\\n        if(matrix[0][0]==\\'0\\')return 0;\\n        vector<int>arr(n,0);\\n        int count=0,ans=0,val;\\n        for(int i=0;i<m;i++)\\n        {\\n          for(int j=0;j<n;j++)\\n          {\\n            if(arr[j]!=0 and matrix[i][j]==\\'0\\'){\\n              arr[j]=0;\\n            }\\n            else if(matrix[i][j]==\\'1\\'){\\n              arr[j]+=1;\\n            }\\n          }\\n          for(int k=0;k<n;k++)\\n          {\\n            if(arr[k]!=0){\\n              if(count==0){\\n                count++;\\n                val=arr[k];\\n              }\\n              else{\\n                count++;\\n                val=min(val,arr[k]);\\n              }\\n              ans=max(ans,count*val);\\n            }\\n            else{\\n              count=0;\\n            }\\n          }\\n          count=0;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHELP NEEDED TO FIND THE BUG"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "can anyone tell what is the space complexity of my solution? is it O(n*m)??\\n   vector<int> NextSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(n);\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--){\\n            while(st.top()!=n && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> PrevSmaller(vector<int>& heights){\\n        stack<int> st;\\n        int n= heights.size();\\n        st.push(-1);\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            while(st.top()!=-1 && heights[st.top()]>=heights[i]){\\n                st.pop();\\n            }\\n                ans[i]=st.top();\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n= heights.size();\\n        vector<int> next(n);\\n        vector<int> prev(n);\\n        next = NextSmaller(heights);\\n        prev = PrevSmaller(heights);\\n        int maxarea=-1;\\n        for(int i=0;i<heights.size();i++){\\n            maxarea= max(maxarea, (next[i] - prev[i]-1)*heights[i] );\\n        }\\n        return maxarea;\\n    }\\n\\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        vector<int> heights(matrix[0].size(),0);\\n        int maxarea=-1;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==\\'0\\'){\\n\\n                heights[j]=0;\\n                }\\n                else{\\n                    heights[j] += 1;\\n                }\\n            }\\n            maxarea=max(maxarea, largestRectangleArea(heights));\\n        }\\n        return maxarea;\\n    }"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    \\n    int largestArea(vector<int>& histogram){\\n        int n=histogram.size(), area=0;\\n        stack<int> s;\\n        \\n        for(int i=0; i<n; i++){\\n            while(!s.empty() && histogram[s.top()]>=histogram[i]){\\n                int top = s.top();\\n                s.pop();\\n                \\n                int start;\\n                if(s.empty())\\n                    start = -1;\\n                else\\n                    start = s.top();\\n                    \\n                \\n                int curr_area = histogram[top] * (i - start -1);\\n                area = max(area, curr_area);\\n            }\\n            s.push(i);\\n        }\\n        \\n        while(!s.empty()){\\n            int top = s.top();\\n            s.pop();\\n\\n            int start;\\n            if(s.empty())\\n                start = -1;\\n            else\\n                start = s.top();\\n            \\n            int curr_area = histogram[top] * (n - start -1);\\n            area = max(area, curr_area);\\n        }\\n        \\n        return area;\\n    }\\n    \\n    int maximalRectangle(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0) return 0;\\n        int n=matrix[0].size(), result=0;\\n        vector<int> histogram(n, 0);\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(matrix[i][j]==\\'1\\')\\n                    histogram[j]+=1;\\n                else\\n                    histogram[j]=0;\\n            }\\n            \\n            result = max(result, largestArea(histogram));\\n            cout<<result<<\" \";\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "SAPAN_SIDHWANI",
                        "content": "This code works finely in my computer but I don't know why this code gives me the error when I try to pass the test cases on leetcode.\n\nclass Solution {\npublic:\nvector<int> nextSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=n-1;i>=0;i--){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nvector<int> prevSmallerElement(vector<int> arr,int n){\n    \n    vector<int> ans(n);\n    \n    stack<int> st;\n    st.push(-1);\n    \n    for(int i=0;i<n;i++){\n        int value = arr[i];\n        while(arr[st.top()] >= value && st.top() != -1){\n            st.pop();\n        }\n        ans[i] = st.top();\n        st.push(i);\n    }\n    return ans;\n}\nint largestRectangleArea(vector<int> heights) {\n    int n = heights.size();\n    \n    vector<int> prev(n); \n    prev = prevSmallerElement(heights,n);\n    \n    vector<int> next(n);\n    next = nextSmallerElement(heights,n);\n    \n    int area = INT_MIN;\n    \n    for(int i=0;i<n;i++){\n        \n        int l = heights[i];\n        if(next[i] == -1){\n            next[i] = n;\n        }\n        \n        int b = next[i] - prev[i] - 1;\n        \n        int newArea = l * b;\n        area = max(newArea,area);\n    }\n    return area;\n}\nint maximalRectangle(vector<vector<char>>& matrix) {\n    \n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    vector<int> height(m,0);\n    int maxi = INT_MIN;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(matrix[i][j] == '1')\n                height[j]++ ;\n            else\n                height[j] = 0;\n        }\n        maxi = max(maxi,largestRectangleArea(height));\n    }\n    return maxi;\n} \n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shubham2912",
                        "content": "I approached this question using Maximum Area of Histogram approach. But it failed for 2 of the test cases i.e. Failed Test Case : \\n\\nmatrix =\\n[[\"1\",\"0\",\"1\",\"1\",\"1\",\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"0\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"1\",\"0\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"1\",\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]]\\n\\nAny suggestions why this approach failed?"
                    },
                    {
                        "username": "barstow123",
                        "content": "I have to say. This one was really challenging. I\\'m glad I spent multiple days working to this problem and ultimately solving it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Department Top Three Salaries",
        "question_content": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference column) of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A company&#39;s executives are interested in seeing who earns the most money in each of the company&#39;s departments. A <strong>high earner</strong> in a department is an employee who has a salary in the <strong>top three unique</strong> salaries for that department.</p>\n\n<p>Write a solution to find the employees who are <strong>high earners</strong> in each of the departments.</p>\n\n<p>Return the result table <strong>in any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> \nIn the IT department:\n- Max earns the highest unique salary\n- Both Randy and Joe earn the second-highest unique salary\n- Will earns the third-highest unique salary\n\nIn the Sales department:\n- Henry earns the highest salary\n- Sam earns the second-highest salary\n- There is no third-highest salary as there are only two employees\n</pre>\n",
        "solutions": [
            {
                "id": 53692,
                "title": "accepted-solution-without-group-by-or-order-by",
                "content": "    select d.Name Department, e1.Name Employee, e1.Salary\\n    from Employee e1 \\n    join Department d\\n    on e1.DepartmentId = d.Id\\n    where 3 > (select count(distinct(e2.Salary)) \\n                      from Employee e2 \\n                      where e2.Salary > e1.Salary \\n                      and e1.DepartmentId = e2.DepartmentId\\n                      );",
                "solutionTags": [],
                "code": "    select d.Name Department, e1.Name Employee, e1.Salary\\n    from Employee e1 \\n    join Department d\\n    on e1.DepartmentId = d.Id\\n    where 3 > (select count(distinct(e2.Salary)) \\n                      from Employee e2 \\n                      where e2.Salary > e1.Salary \\n                      and e1.DepartmentId = e2.DepartmentId\\n                      );",
                "codeTag": "Unknown"
            },
            {
                "id": 3203554,
                "title": "sql-department-top-three-salaries",
                "content": "\\n# Approach\\nselect the department name, employee name and salary of employee from the employee tables and the department tables such that they are joined on the joining condition that the department id and the id of the department in each table are mapped.\\n\\nthe where condition is that the number of distinct salaries from employee table for that particular department mapped using the corelated query and that the salary of this table is higher than the the main query salary.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect d.name as department , e1.name as employee, e1.salary as Salary\\nfrom Employee e1 join Department d on e1.DepartmentId = d.Id\\nwhere  3 > (select count(distinct (e2.Salary))\\n        from  Employee e2\\n        where e2.Salary > e1.Salary\\n            and e1.DepartmentId = e2.DepartmentId)\\n```\\nPOV : you took a lot of time and some help from solutions to do this and now contemplating life decisions\\n\\n# a like would be appreciated",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect d.name as department , e1.name as employee, e1.salary as Salary\\nfrom Employee e1 join Department d on e1.DepartmentId = d.Id\\nwhere  3 > (select count(distinct (e2.Salary))\\n        from  Employee e2\\n        where e2.Salary > e1.Salary\\n            and e1.DepartmentId = e2.DepartmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919919,
                "title": "mysql-order-salary-dense-rank-function",
                "content": "If you're familiar with window function, this problem would be quite easy for you.\n\nFor those who are interested, here is a great [YouTube](https://www.youtube.com/watch?v=7S_tz1z_5bA) video on MySQL window function.\n\n```sql\nSELECT Department, employee, salary FROM (\n    SELECT d.name AS Department\n        , e.name AS employee\n        , e.salary\n        , DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS drk\n    FROM Employee e JOIN Department d ON e.DepartmentId= d.Id\n) t WHERE t.drk <= 3\n```",
                "solutionTags": [],
                "code": "```sql\nSELECT Department, employee, salary FROM (\n    SELECT d.name AS Department\n        , e.name AS employee\n        , e.salary\n        , DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS drk\n    FROM Employee e JOIN Department d ON e.DepartmentId= d.Id\n) t WHERE t.drk <= 3\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53701,
                "title": "simple-solution-easy-to-understand",
                "content": "    Select dep.Name as Department, emp.Name as Employee, emp.Salary from Department dep, \\n    Employee emp where emp.DepartmentId=dep.Id and \\n    (Select count(distinct Salary) From Employee where DepartmentId=dep.Id and Salary>emp.Salary)<3",
                "solutionTags": [],
                "code": "    Select dep.Name as Department, emp.Name as Employee, emp.Salary from Department dep, \\n    Employee emp where emp.DepartmentId=dep.Id and \\n    (Select count(distinct Salary) From Employee where DepartmentId=dep.Id and Salary>emp.Salary)<3",
                "codeTag": "Unknown"
            },
            {
                "id": 797620,
                "title": "three-solutions-window-function-subquery-and-join",
                "content": "Method1: Using window function\\n```\\nSELECT res.Department, res.Employee, res.Salary FROM\\n(\\n    SELECT d.Name AS Department, e.Name AS Employee, e.Salary,\\n           DENSE_Rank() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS Ranking\\n    FROM Employee e JOIN Department d ON e.DepartmentId = d.ID\\n) res WHERE Ranking <= 3;\\n```\\n\\nMethod2 Subquery\\n```\\nSELECT d.Name AS Department, e1.Name AS Employee, e1.Salary FROM Employee e1\\nJOIN Department d \\nON e1.DepartmentID = d.Id\\nWHERE 3 > (select count(distinct(e2.Salary)) \\n                  from Employee e2 \\n                  where e2.Salary > e1.Salary \\n                  and e1.DepartmentId = e2.DepartmentId)\\n```\\n\\nMethod 3 Join\\n```\\nSELECT D.Name as Department, E.Name as Employee, E.Salary \\nFROM Department D, Employee E, Employee E2  \\nWHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\nE.Salary <= E2.Salary\\ngroup by D.ID,E.Name having count(distinct E2.Salary) <= 3\\norder by D.Name, E.Salary desc\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT res.Department, res.Employee, res.Salary FROM\\n(\\n    SELECT d.Name AS Department, e.Name AS Employee, e.Salary,\\n           DENSE_Rank() OVER (PARTITION BY d.Name ORDER BY e.Salary DESC) AS Ranking\\n    FROM Employee e JOIN Department d ON e.DepartmentId = d.ID\\n) res WHERE Ranking <= 3;\\n```\n```\\nSELECT d.Name AS Department, e1.Name AS Employee, e1.Salary FROM Employee e1\\nJOIN Department d \\nON e1.DepartmentID = d.Id\\nWHERE 3 > (select count(distinct(e2.Salary)) \\n                  from Employee e2 \\n                  where e2.Salary > e1.Salary \\n                  and e1.DepartmentId = e2.DepartmentId)\\n```\n```\\nSELECT D.Name as Department, E.Name as Employee, E.Salary \\nFROM Department D, Employee E, Employee E2  \\nWHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\nE.Salary <= E2.Salary\\ngroup by D.ID,E.Name having count(distinct E2.Salary) <= 3\\norder by D.Name, E.Salary desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53699,
                "title": "my-tidy-solution",
                "content": "    select D.Name as Department, E.Name as Employee, E.Salary as Salary \\n      from Employee E, Department D\\n       where (select count(distinct(Salary)) from Employee \\n               where DepartmentId = E.DepartmentId and Salary > E.Salary) in (0, 1, 2)\\n             and \\n               E.DepartmentId = D.Id \\n             order by E.DepartmentId, E.Salary DESC;",
                "solutionTags": [],
                "code": "    select D.Name as Department, E.Name as Employee, E.Salary as Salary \\n      from Employee E, Department D\\n       where (select count(distinct(Salary)) from Employee \\n               where DepartmentId = E.DepartmentId and Salary > E.Salary) in (0, 1, 2)\\n             and \\n               E.DepartmentId = D.Id \\n             order by E.DepartmentId, E.Salary DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 2722024,
                "title": "beats-98-easy-simple-solution",
                "content": "```\\nSELECT Department, employee, salary FROM (\\n    SELECT d.name AS Department\\n        , e.name AS employee\\n        , e.salary\\n        , DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS drk\\n    FROM Employee e JOIN Department d ON e.DepartmentId= d.Id\\n) t WHERE t.drk <= 3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Department, employee, salary FROM (\\n    SELECT d.name AS Department\\n        , e.name AS employee\\n        , e.salary\\n        , DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS drk\\n    FROM Employee e JOIN Department d ON e.DepartmentId= d.Id\\n) t WHERE t.drk <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1154107,
                "title": "simple-join-with-explanation-no-subquery-or-window-function",
                "content": "```\\nselect\\n    d.name department,\\n    e1.name employee,\\n    e1.salary salary\\nfrom\\n    employee e1\\n    join employee e2\\n    join department d on e1.departmentid = e2.departmentid\\n    and e1.salary <= e2.salary\\n    and d.id = e2.departmentid\\ngroup by\\n    1, 2, 3\\nhaving\\n    count(distinct(e2.salary)) <= 3\\n```\\nExplanation:\\n\\nIn big data analytics, using a subquery is not efficient to process millions of rows of data. Using joins would be a better approach as most RDBMS\\'s are optimized for joins.\\n\\nWe are doing triple join in above statement. \\nFirst join is two same employee tables joined on department ids. \\n```\\ne1.departmentid = e2.departmentid\\n```\\nThis will give us cross join (cartesian product where each e1.department id has as many rows as the e2.department ids. Basically, x * y rows if x is the number of rows ine1 table and y is the number of rows in e2 table). This cross join will be useful in the next steps.\\n```\\ne1.salary <= e2.salary\\n```\\nThis join filters/removes any e1.salary rows that are smaller than or equal to e2.salary.\\nHere is a visual explanation:\\n![image](https://assets.leetcode.com/users/images/866c659e-a19a-4518-8aa5-beb4097c132a_1618179935.7289424.jpeg)\\nin the parts where the condition is \\'no\\', the result of sql will not include them in the final result.\\nNext comes department table join:\\n```\\nd.id = e2.departmentid\\n```\\nThis makes sure we have department names in our final table.\\n```\\ngroup by\\n    1, 2, 3\\n```\\nThis makes sure we have unique records for each department, employee, salary row and also helps us to filter out only top 3 in the next step.\\n```\\nhaving count(distinct(e2.salary)) <= 3\\n```\\nSince we cross joined, filtered salaries and grouped them into buckets, we will use the having clause to further filter rows that have only 3 or less cross joins. Meaning, if there are 3 values equal to or greater than this salary, then this must be top 3 salary. You can refer to the illustration above to see how sql is getting count of each salary based on cross joins.\\nThank you for reading! \\nHappy learning!\\nSaid\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    d.name department,\\n    e1.name employee,\\n    e1.salary salary\\nfrom\\n    employee e1\\n    join employee e2\\n    join department d on e1.departmentid = e2.departmentid\\n    and e1.salary <= e2.salary\\n    and d.id = e2.departmentid\\ngroup by\\n    1, 2, 3\\nhaving\\n    count(distinct(e2.salary)) <= 3\\n```\n```\\ne1.departmentid = e2.departmentid\\n```\n```\\ne1.salary <= e2.salary\\n```\n```\\nd.id = e2.departmentid\\n```\n```\\ngroup by\\n    1, 2, 3\\n```\n```\\nhaving count(distinct(e2.salary)) <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421108,
                "title": "mysql-2-different-approach-beginner-level-faster-than-99-42-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n**Runtime**: 599 ms, faster than 99.42% of MySQL online submissions for Department Top Three Salaries.\\n```\\nSELECT Department,Employee,Salary\\nFROM\\n(SELECT\\nd.name AS Department,\\ne.name AS Employee,\\ne.Salary AS Salary,\\ndense_rank() over(PARTITION BY e.departmentId ORDER BY e.Salary DESC) AS rk\\nFROM Employee e\\nLEFT JOIN Department d ON e.departmentId = d.id) a\\nWHERE rk <= 3\\n```\\n__________________________________\\n***Approach 2***:\\n```\\nSELECT d.Name Department, e1.Name Employee, e1.Salary\\nFROM Employee e1 \\nJOIN Department d\\nON e1.DepartmentId = d.Id\\nWHERE 3 > (SELECT COUNT(DISTINCT(e2.Salary)) \\n                  FROM Employee e2 \\n                  WHERE e2.Salary > e1.Salary \\n                  AND e1.DepartmentId = e2.DepartmentId\\n                  );\\n```\\t  \\n___________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Department,Employee,Salary\\nFROM\\n(SELECT\\nd.name AS Department,\\ne.name AS Employee,\\ne.Salary AS Salary,\\ndense_rank() over(PARTITION BY e.departmentId ORDER BY e.Salary DESC) AS rk\\nFROM Employee e\\nLEFT JOIN Department d ON e.departmentId = d.id) a\\nWHERE rk <= 3\\n```\n```\\nSELECT d.Name Department, e1.Name Employee, e1.Salary\\nFROM Employee e1 \\nJOIN Department d\\nON e1.DepartmentId = d.Id\\nWHERE 3 > (SELECT COUNT(DISTINCT(e2.Salary)) \\n                  FROM Employee e2 \\n                  WHERE e2.Salary > e1.Salary \\n                  AND e1.DepartmentId = e2.DepartmentId\\n                  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3214925,
                "title": "185-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nThe given problem is to find the high earners in each department. In other words, we need to find employees in each department with the top three unique salaries.\\n\\nTo solve this problem, we can use the following query:\\n\\n```\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary\\nFROM Department d, Employee e\\nWHERE (\\n    SELECT COUNT(DISTINCT Salary)\\n    FROM Employee\\n    WHERE Salary > e.Salary AND DepartmentId = d.Id\\n) < 3 AND e.DepartmentId = d.Id\\nORDER BY d.Id, e.Salary DESC;\\n\\n```\\nThis query first performs a cross join between the Department and Employee tables to get all possible combinations of departments and employees.\\n\\nThen, the WHERE clause filters out the employees who do not have a top three unique salary in their department. The subquery in the WHERE clause returns the count of distinct salaries greater than the employee\\'s salary for the employee\\'s department. If this count is less than 3, the employee\\'s salary is in the top three unique salaries for the department.\\n\\nFinally, the query selects the department name, employee name, and salary for the high earners and orders the result by department ID and employee salary in descending order.\\n\\nOverall, this query efficiently finds the high earners in each department by utilizing a subquery and avoiding the use of expensive self-joins.",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary\\nFROM Department d, Employee e\\nWHERE (\\n    SELECT COUNT(DISTINCT Salary)\\n    FROM Employee\\n    WHERE Salary > e.Salary AND DepartmentId = d.Id\\n) < 3 AND e.DepartmentId = d.Id\\nORDER BY d.Id, e.Salary DESC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557594,
                "title": "mysql-join-correlated-query",
                "content": "Do Upvote, if it Helped :)\\n\\n```\\nSELECT \\n    dep.name AS \\'Department\\',\\n    emp.name AS \\'Employee\\',\\n    emp.salary AS \\'Salary\\'\\nFROM\\n    Employee emp \\n        JOIN\\n    Department dep\\n        ON emp.departmentId = dep.id\\nWHERE\\n    3 > ( SELECT\\n            COUNT(DISTINCT(emp2.salary))\\n          FROM\\n            Employee emp2\\n          WHERE\\n            emp2.salary > emp.salary\\n                    AND\\n            emp2.DepartmentId = emp.DepartmentId        \\n        )\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    dep.name AS \\'Department\\',\\n    emp.name AS \\'Employee\\',\\n    emp.salary AS \\'Salary\\'\\nFROM\\n    Employee emp \\n        JOIN\\n    Department dep\\n        ON emp.departmentId = dep.id\\nWHERE\\n    3 > ( SELECT\\n            COUNT(DISTINCT(emp2.salary))\\n          FROM\\n            Employee emp2\\n          WHERE\\n            emp2.salary > emp.salary\\n                    AND\\n            emp2.DepartmentId = emp.DepartmentId        \\n        )\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827137,
                "title": "100-easy-fast-clean-solution",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary \\n\\nAS Salary FROM Department DEPT JOIN Employee EMP ON \\n\\nEMP.DepartmentId=DEPT.id WHERE 3 > (SELECT COUNT(DISTINCT EMP1.salary)\\n \\nFROM Employee EMP1 WHERE EMP1.salary > EMP.salary AND \\n\\nEMP.departmentId = EMP1.departmentId)\\n```\\nIF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE!\\n\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/f7194662-4407-4e9d-a5aa-9e2df156c12a_1690524625.4627185.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary \\n\\nAS Salary FROM Department DEPT JOIN Employee EMP ON \\n\\nEMP.DepartmentId=DEPT.id WHERE 3 > (SELECT COUNT(DISTINCT EMP1.salary)\\n \\nFROM Employee EMP1 WHERE EMP1.salary > EMP.salary AND \\n\\nEMP.departmentId = EMP1.departmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 631849,
                "title": "mysql-simple-dense-rank",
                "content": "```\\nselect b.Name as Department, a.Name as Employee, Salary\\nfrom\\n(select *, dense_rank() over(partition by DepartmentId order by Salary DESC) as ranks\\nfrom Employee) a\\njoin Department b\\non a.DepartmentId = b.Id\\nwhere ranks <= 3\\n```\\nlogic: \\n1. use dense rank if we want to match same value as one rank and the following one followed by previous rank\\n2. Then select the rank <= 3\\n3. Join Department Table to get solution",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect b.Name as Department, a.Name as Employee, Salary\\nfrom\\n(select *, dense_rank() over(partition by DepartmentId order by Salary DESC) as ranks\\nfrom Employee) a\\njoin Department b\\non a.DepartmentId = b.Id\\nwhere ranks <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853452,
                "title": "easy-and-small-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing ranking functions\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirstly join the two tables\\nsort the rows by thier dense_rank as a new table\\nthen select top 3 of every department \\n\\n\\n# Code\\n```\\nselect department , employee , salary \\nfrom (\\n  select e.name employee , e.salary salary, d.name department, dense_rank() over (partition by d.id order by e.salary desc) rank\\n  from employee e inner join Department d\\n  on e.departmentId = d.id\\n) newTable\\nwhere rank <= 3\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect department , employee , salary \\nfrom (\\n  select e.name employee , e.salary salary, d.name department, dense_rank() over (partition by d.id order by e.salary desc) rank\\n  from employee e inner join Department d\\n  on e.departmentId = d.id\\n) newTable\\nwhere rank <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 409614,
                "title": "mysql-faster-than-94-88-example",
                "content": "\\nKey point (bottom-up):\\n1. Within each department, we need to select out the Top 3 Salary (possible ties), our thinking is **for each salary which is among Top 3, it must be less than or equal to at most 3 other salaries in that department**. Hence we can **utilize JOIN to compare the salaries**\\n2. In order to **consider the ties**, for the compared table b (vs. selected table Employee a), we need to **select the distinct DepartmentId, Salary**, hence each salary in table a will only be compared with unique salaries in table b\\n3. Then we need a **GROUP BY ... HAVING ...** manipulation to realize the logic in Step 1\\n4. Add another simply **JOIN Department x** to take into account the department names. \\n\\nNow enjoy the code.\\n```\\nselect\\nx.Name as Department,\\na.Name as Employee,\\na.Salary as Salary\\nfrom Employee a\\njoin (select distinct DepartmentId, Salary from Employee) b\\non a.DepartmentId = b.DepartmentId and a.Salary <= b.Salary\\njoin Department x\\non a.DepartmentId = x.Id\\ngroup by a.DepartmentId, a.Name, a.Salary\\nhaving count(a.Salary) <= 3;\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\nx.Name as Department,\\na.Name as Employee,\\na.Salary as Salary\\nfrom Employee a\\njoin (select distinct DepartmentId, Salary from Employee) b\\non a.DepartmentId = b.DepartmentId and a.Salary <= b.Salary\\njoin Department x\\non a.DepartmentId = x.Id\\ngroup by a.DepartmentId, a.Name, a.Salary\\nhaving count(a.Salary) <= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53688,
                "title": "query-with-2-variables-beats-99-of-submissions-737-ms",
                "content": " Note: for each department, if there exists duplicate 1st/2nd/3rd highest salaries, all entries should be returned.\\n```\\nselect d.Name as Department, e.Name as Employee, computed.Salary as Salary\\nfrom Employee e, \\n\\t(\\n\\t\\tselect Salary, DepartmentId, @row := IF(DepartmentId=@did, @row + 1,1) as Rank , @did:=DepartmentId\\n\\t\\tfrom (\\n\\t\\t\\tselect distinct Salary, DepartmentId\\n\\t\\t\\tfrom Employee\\n\\t\\t\\torder by DepartmentId, Salary desc\\n\\t\\t\\t) ordered, (select @row:=0, @did:=0) variables\\n\\t) computed,\\n\\tDepartment d\\nwhere e.Salary=computed.Salary \\nand e.DepartmentId=computed.DepartmentId \\nand computed.DepartmentId=d.Id\\nand computed.Rank<=3\\norder by computed.DepartmentId, Salary desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect d.Name as Department, e.Name as Employee, computed.Salary as Salary\\nfrom Employee e, \\n\\t(\\n\\t\\tselect Salary, DepartmentId, @row := IF(DepartmentId=@did, @row + 1,1) as Rank , @did:=DepartmentId\\n\\t\\tfrom (\\n\\t\\t\\tselect distinct Salary, DepartmentId\\n\\t\\t\\tfrom Employee\\n\\t\\t\\torder by DepartmentId, Salary desc\\n\\t\\t\\t) ordered, (select @row:=0, @did:=0) variables\\n\\t) computed,\\n\\tDepartment d\\nwhere e.Salary=computed.Salary \\nand e.DepartmentId=computed.DepartmentId \\nand computed.DepartmentId=d.Id\\nand computed.Rank<=3\\norder by computed.DepartmentId, Salary desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605563,
                "title": "mysql-solution-for-department-top-three-salaries-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to identify the high earners in each department based on their salaries. We want to find employees whose salary ranks among the top three unique salaries within their respective departments.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Join the Employee and Department tables based on the departmentId foreign key.\\n1. Use a subquery to count the number of distinct salaries that are higher than the current employee\\'s salary within the same department.\\n1. Filter the result to include only employees whose count is less than 3, indicating that they have one of the top three unique salaries in their department.\\n1. Order the result by department name and employee salary in descending order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the number of rows in the Employee table, denoted as \"n\". The JOIN operation and subquery involve accessing and comparing the salaries for each employee, resulting in a time complexity of O(n). The overall time complexity is also affected by the sorting operation, which has a time complexity of O(n log n) in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is determined by the size of the result set, which consists of the high earners in each department. Assuming there are m departments and k high earners in total, the space complexity is O(m + k).\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\nWHERE (\\n  SELECT COUNT(DISTINCT salary)\\n  FROM Employee\\n  WHERE departmentId = e.departmentId AND salary > e.salary\\n) < 3\\nORDER BY d.name, e.salary DESC;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\nWHERE (\\n  SELECT COUNT(DISTINCT salary)\\n  FROM Employee\\n  WHERE departmentId = e.departmentId AND salary > e.salary\\n) < 3\\nORDER BY d.name, e.salary DESC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53748,
                "title": "simple-solution-for-1112-ms",
                "content": "        \\n    SELECT\\n        d.Name Department, e.Name Employee, e.Salary Salary\\n    FROM\\n        (\\n            SELECT DepartmentId, Name, Salary \\n            FROM Employee \\n            WHERE 3 > (\\n                SELECT COUNT(e1.Salary)\\n                FROM (\\n                    SELECT DISTINCT Salary, DepartmentId \\n                    FROM Employee \\n                ) e1\\n                WHERE\\n                    Employee.DepartmentId = e1.DepartmentId \\n                AND\\n                    Employee.Salary < e1.Salary\\n            )\\n            ORDER BY DepartmentId ASC, Salary DESC\\n        ) e \\n    LEFT JOIN\\n        Department d\\n    ON \\n        e.DepartmentId = d.Id\\n    WHERE\\n        d.Name IS NOT NULL",
                "solutionTags": [],
                "code": "        \\n    SELECT\\n        d.Name Department, e.Name Employee, e.Salary Salary\\n    FROM\\n        (\\n            SELECT DepartmentId, Name, Salary \\n            FROM Employee \\n            WHERE 3 > (\\n                SELECT COUNT(e1.Salary)\\n                FROM (\\n                    SELECT DISTINCT Salary, DepartmentId \\n                    FROM Employee \\n                ) e1\\n                WHERE\\n                    Employee.DepartmentId = e1.DepartmentId \\n                AND\\n                    Employee.Salary < e1.Salary\\n            )\\n            ORDER BY DepartmentId ASC, Salary DESC\\n        ) e \\n    LEFT JOIN\\n        Department d\\n    ON \\n        e.DepartmentId = d.Id\\n    WHERE\\n        d.Name IS NOT NULL",
                "codeTag": "Unknown"
            },
            {
                "id": 53713,
                "title": "solution-using-3-variables-to-rank-salaries-within-each-department",
                "content": "One variable is to limit the ranking in department, and second to handle salary ties, the third to assign a rank to each row, and we will use this rank to get top n salaries.\\n\\nThe 2nd variable, @PrevSalary, could be avoided by first doing a DISTINCT on Employee table, but then will need to join Employee table back to get the name, which makes the SQL more complex than this approach.\\n\\n    SELECT d.Name AS Department, se.Name AS Employee, se.Salary \\n    FROM Department d,\\n     ( SELECT e.Name, e.DepartmentId, e.Salary,\\n              @Rank := (CASE \\n\\t\\t\\t\\t\\t\\tWHEN @PrevDept != e.DepartmentId THEN 1\\n                        WHEN @PrevSalary = e.Salary THEN @Rank\\n\\t\\t\\t\\t\\t\\tELSE @Rank + 1 END) AS Rank, \\n\\t\\t\\t  @PrevDept := e.DepartmentId,\\n              @PrevSalary := e.Salary\\n\\t\\tFROM Employee e, (SELECT @Rank := 0, @PrevDept := 0, @PrevSalary := 0) r\\n \\t\\tORDER BY DepartmentId ASC, Salary DESC\\n\\t  ) se\\n    WHERE d.Id = se.DepartmentId AND se.Rank <= 3\\n\\n\\nQuestions, comments are always welcome.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "One variable is to limit the ranking in department, and second to handle salary ties, the third to assign a rank to each row, and we will use this rank to get top n salaries.\\n\\nThe 2nd variable, @PrevSalary, could be avoided by first doing a DISTINCT on Employee table, but then will need to join Employee table back to get the name, which makes the SQL more complex than this approach.\\n\\n    SELECT d.Name AS Department, se.Name AS Employee, se.Salary \\n    FROM Department d,\\n     ( SELECT e.Name, e.DepartmentId, e.Salary,\\n              @Rank := (CASE \\n\\t\\t\\t\\t\\t\\tWHEN @PrevDept != e.DepartmentId THEN 1\\n                        WHEN @PrevSalary = e.Salary THEN @Rank\\n\\t\\t\\t\\t\\t\\tELSE @Rank + 1 END) AS Rank, \\n\\t\\t\\t  @PrevDept := e.DepartmentId,\\n              @PrevSalary := e.Salary\\n\\t\\tFROM Employee e, (SELECT @Rank := 0, @PrevDept := 0, @PrevSalary := 0) r\\n \\t\\tORDER BY DepartmentId ASC, Salary DESC\\n\\t  ) se\\n    WHERE d.Id = se.DepartmentId AND se.Rank <= 3\\n\\n\\nQuestions, comments are always welcome.",
                "codeTag": "Unknown"
            },
            {
                "id": 4007924,
                "title": "using-dense-rank-detailed-explanation",
                "content": "\\n# Approach\\n\\nIn this scenario, we want to identify the top 3 highest salaried employees within each department. To achieve this, we\\'ll utilize the DENSE_RANK() window function, which works similar to ROW_NUMBER() but with a slight difference in handling tied values. DENSE_RANK() assigns the same rank to rows with identical ORDER_BY values, ensuring that we can have multiple employees with the same salary but still rank them appropriately.\\n\\nHere are the steps we will follow:\\n\\n**Partition by Department**: We will partition our dataset by the departmentid column. This means that DENSE_RANK() will reset its ranking for each department, treating them as separate groups.\\n\\n**Order by Salary (Descending):** Next, we will order the rows within each department by salary in descending order. This ensures that employees with the highest salaries receive the lowest DENSE_RANK() values within their respective departments.\\n\\n**Apply DENSE_RANK():** Finally, we will apply the DENSE_RANK() function to assign a rank to each employee within their department based on their salary. Since we\\'ve partitioned by department and ordered by salary, employees with the same salary will receive the same rank.\\n\\nBy doing this, we can easily identify the top 3 highest salaried employees in each department, as their DENSE_RANK() values will be 1, 2, and 3 within their respective departments.\\n\\nThis approach ensures that tied values (employees with the same salary) are handled correctly while still allowing us to determine the highest earners within each department.\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT t.d_name AS Department\\n\\t,t.e_name AS Employee\\n\\t,t.Salary\\nFROM (\\n\\tSELECT e.name AS e_name\\n\\t\\t,e.salary\\n\\t\\t,d.Name AS d_name\\n\\t\\t,DENSE_RANK() OVER (\\n\\t\\t\\tPARTITION BY departmentid ORDER BY salary DESC\\n\\t\\t\\t) AS row_num\\n\\tFROM employee AS e\\n\\tINNER JOIN department AS d ON e.departmentid = d.id\\n\\t) t\\nWHERE row_num <= 3\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT t.d_name AS Department\\n\\t,t.e_name AS Employee\\n\\t,t.Salary\\nFROM (\\n\\tSELECT e.name AS e_name\\n\\t\\t,e.salary\\n\\t\\t,d.Name AS d_name\\n\\t\\t,DENSE_RANK() OVER (\\n\\t\\t\\tPARTITION BY departmentid ORDER BY salary DESC\\n\\t\\t\\t) AS row_num\\n\\tFROM employee AS e\\n\\tINNER JOIN department AS d ON e.departmentid = d.id\\n\\t) t\\nWHERE row_num <= 3\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3716378,
                "title": "mysql-easiest-understandable-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT d.name AS Department, e.name AS Employee, e.salary \\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON d.id = e.departmentId\\nWHERE (\\n    SELECT\\n    COUNT(DISTINCT(salary))\\n    FROM Employee\\n    WHERE salary > e.salary\\n    AND DepartmentId = e.DepartmentId        \\n) < 3;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT d.name AS Department, e.name AS Employee, e.salary \\nFROM Employee AS e\\nINNER JOIN Department AS d\\nON d.id = e.departmentId\\nWHERE (\\n    SELECT\\n    COUNT(DISTINCT(salary))\\n    FROM Employee\\n    WHERE salary > e.salary\\n    AND DepartmentId = e.DepartmentId        \\n) < 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2635354,
                "title": "optimal-and-easy-solution",
                "content": "select d.name as department , e.name as employee, e.salary from \\n(select departmentID,name,salary,dense_rank() over(Partition by DepartmentID order by salary desc) as rnk\\n from employee) as e  \\njoin Department d on e.DepartmentId = d.Id where \\nrnk <= 3",
                "solutionTags": [],
                "code": "select d.name as department , e.name as employee, e.salary from \\n(select departmentID,name,salary,dense_rank() over(Partition by DepartmentID order by salary desc) as rnk\\n from employee) as e  \\njoin Department d on e.DepartmentId = d.Id where \\nrnk <= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 677336,
                "title": "syntax-error-even-with-the-official-solution-broken-test-cases",
                "content": "Is anyone getting a syntax error for everything they submit? Here\\'s my solution:\\n\\n```sql\\n# Write your MySQL query statement below\\nSELECT Department, Employee, Salary\\nFROM (\\n    SELECT\\n        e.Name AS Employee,\\n        d.Name AS Department,\\n        e.Salary AS Salary,\\n        DENSE_RANK() OVER (PARTITION BY d.Id ORDER BY e.Salary) AS rnk\\n    FROM Employee e JOIN Department d ON e.DepartmentId = d.Id\\n) t\\nWHERE rnk <= 3;\\n```\\nwhich gives the following cryptic error:\\n\\n```\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n```\\n\\nAt first I thought there was something wrong with my code, but even if I just copy and paste the accepted solution I get exactly the same error! In fact, even this will reproduce the exact same error:\\n\\n```\\nSELECT * FROM Employee;\\n```\\n\\n...I\\'m pretty sure this isn\\'t my fault now! Are the test cases broken?",
                "solutionTags": [],
                "code": "```sql\\n# Write your MySQL query statement below\\nSELECT Department, Employee, Salary\\nFROM (\\n    SELECT\\n        e.Name AS Employee,\\n        d.Name AS Department,\\n        e.Salary AS Salary,\\n        DENSE_RANK() OVER (PARTITION BY d.Id ORDER BY e.Salary) AS rnk\\n    FROM Employee e JOIN Department d ON e.DepartmentId = d.Id\\n) t\\nWHERE rnk <= 3;\\n```\n```\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n```\n```\\nSELECT * FROM Employee;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 357461,
                "title": "no-window-function-no-local-variable-easy-to-understand-beats-95-mysql",
                "content": "Key: using the middle subquery to construct the dense rank of salaries within each department. \\n\\n```\\nselect Department.Name as Department, Employee.Name as Employee, Salary\\nfrom (  \\n\\t\\t\\tselect e1.Id as Id, count(distinct e2.Salary) as Rank\\n\\t\\t\\tfrom Employee e1, Employee e2\\n\\t\\t\\twhere e1.Salary <= e2.Salary and e1.departmentId = e2.departmentId\\n\\t\\t\\tgroup by e1.Id \\n\\t\\t) r\\njoin Employee on Employee.Id = r.Id\\njoin Department on Employee.DepartmentId = Department.Id\\nwhere r.Rank <= 3\\n```\\n\\n**Hint**: within each department, make a cross product of salaries where the left salaries are no greater than the right. The top salary has only one possible pair. The second highest salary has two pairs (it equals itself and it is less than the top salary)... etc.  The usage of ***distinct*** makes it dense rank instead.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect Department.Name as Department, Employee.Name as Employee, Salary\\nfrom (  \\n\\t\\t\\tselect e1.Id as Id, count(distinct e2.Salary) as Rank\\n\\t\\t\\tfrom Employee e1, Employee e2\\n\\t\\t\\twhere e1.Salary <= e2.Salary and e1.departmentId = e2.departmentId\\n\\t\\t\\tgroup by e1.Id \\n\\t\\t) r\\njoin Employee on Employee.Id = r.Id\\njoin Department on Employee.DepartmentId = Department.Id\\nwhere r.Rank <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289376,
                "title": "using-rank",
                "content": "```\\nselect Dept.name as Department, Sub.name as Employee, Sub.salary as Salary from\\n\\n(select dense_rank() over (partition by departmentid order by salary desc) as rank,\\n id, name, salary, departmentid from employee) Sub\\n\\ninner join Department Dept on Sub.departmentid = Dept.id\\nwhere rank<4\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect Dept.name as Department, Sub.name as Employee, Sub.salary as Salary from\\n\\n(select dense_rank() over (partition by departmentid order by salary desc) as rank,\\n id, name, salary, departmentid from employee) Sub\\n\\ninner join Department Dept on Sub.departmentid = Dept.id\\nwhere rank<4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3074004,
                "title": "using-basic-utilities-of-sql",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect d.Name as \\'Department\\', e1.Name as \\'Employee\\', e1.Salary\\nfrom Employee e1\\njoin Department d \\non e1.DepartmentId = d.Id\\nwhere 3 > (select count(distinct e2.Salary)\\n            from Employee e2\\n            where e2.Salary > e1.Salary\\n                and e1.DepartmentId = e2.DepartmentId)\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect d.Name as \\'Department\\', e1.Name as \\'Employee\\', e1.Salary\\nfrom Employee e1\\njoin Department d \\non e1.DepartmentId = d.Id\\nwhere 3 > (select count(distinct e2.Salary)\\n            from Employee e2\\n            where e2.Salary > e1.Salary\\n                and e1.DepartmentId = e2.DepartmentId)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1698407,
                "title": "2-easiest-sqls",
                "content": "Classic\\n```\\nWITH src AS(\\n            SELECT d.name       AS Department\\n                 , e.name       AS Employee\\n                 , e.salary     AS Salary\\n                 , DENSE_RANK() OVER(PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rn\\n              FROM employee   e\\n                   INNER JOIN\\n                   department d\\n                    ON e.departmentId = d.id\\n           )\\nSELECT Department, Employee, Salary\\n  FROM src\\n WHERE rn < 4\\n```\\nUse on the interview if your interviewer doesn\\'t know or hates window functions :)\\n\\n```\\nWITH m_01 AS(\\nSELECT MAX(e.salary) AS salary\\n     , e.departmentId\\n  FROM Employee e\\n GROUP BY e.departmentId\\n),\\nm_02 AS(\\nSELECT MAX(e.salary) AS salary\\n     , e.departmentId\\n  FROM Employee e\\n WHERE NOT EXISTS (\\n                   SELECT 1\\n                     FROM m_01\\n                    WHERE m_01.departmentId = e.departmentId\\n                      AND m_01.salary       = e.salary\\n                  )\\n GROUP BY e.departmentId\\n),\\nm_03 AS(\\nSELECT MAX(e.salary) AS salary\\n     , e.departmentId\\n  FROM Employee e\\n WHERE NOT EXISTS (\\n                   SELECT 1\\n                     FROM m_02\\n                    WHERE m_02.departmentId = e.departmentId\\n                      AND m_02.salary       = e.salary\\n                  )\\n   AND NOT EXISTS (\\n                   SELECT 1\\n                     FROM m_01\\n                    WHERE m_01.departmentId = e.departmentId\\n                      AND m_01.salary       = e.salary\\n                  )\\n GROUP BY e.departmentId\\n),\\ntop3 AS (\\nSELECT salary, departmentId FROM m_01\\nUNION ALL\\nSELECT salary, departmentId FROM m_02\\nUNION ALL\\nSELECT salary, departmentId FROM m_03\\n)\\nSELECT d.name       AS Department\\n     , e.name       AS Employee\\n     , e.salary     AS Salary\\n  FROM employee   e\\n       INNER JOIN\\n       top3       t            \\n        ON e.salary       = t.salary\\n       AND e.departmentId = t.departmentId\\n       INNER JOIN\\n       department d\\n        ON e.departmentId = d.id\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nWITH src AS(\\n            SELECT d.name       AS Department\\n                 , e.name       AS Employee\\n                 , e.salary     AS Salary\\n                 , DENSE_RANK() OVER(PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rn\\n              FROM employee   e\\n                   INNER JOIN\\n                   department d\\n                    ON e.departmentId = d.id\\n           )\\nSELECT Department, Employee, Salary\\n  FROM src\\n WHERE rn < 4\\n```\n```\\nWITH m_01 AS(\\nSELECT MAX(e.salary) AS salary\\n     , e.departmentId\\n  FROM Employee e\\n GROUP BY e.departmentId\\n),\\nm_02 AS(\\nSELECT MAX(e.salary) AS salary\\n     , e.departmentId\\n  FROM Employee e\\n WHERE NOT EXISTS (\\n                   SELECT 1\\n                     FROM m_01\\n                    WHERE m_01.departmentId = e.departmentId\\n                      AND m_01.salary       = e.salary\\n                  )\\n GROUP BY e.departmentId\\n),\\nm_03 AS(\\nSELECT MAX(e.salary) AS salary\\n     , e.departmentId\\n  FROM Employee e\\n WHERE NOT EXISTS (\\n                   SELECT 1\\n                     FROM m_02\\n                    WHERE m_02.departmentId = e.departmentId\\n                      AND m_02.salary       = e.salary\\n                  )\\n   AND NOT EXISTS (\\n                   SELECT 1\\n                     FROM m_01\\n                    WHERE m_01.departmentId = e.departmentId\\n                      AND m_01.salary       = e.salary\\n                  )\\n GROUP BY e.departmentId\\n),\\ntop3 AS (\\nSELECT salary, departmentId FROM m_01\\nUNION ALL\\nSELECT salary, departmentId FROM m_02\\nUNION ALL\\nSELECT salary, departmentId FROM m_03\\n)\\nSELECT d.name       AS Department\\n     , e.name       AS Employee\\n     , e.salary     AS Salary\\n  FROM employee   e\\n       INNER JOIN\\n       top3       t            \\n        ON e.salary       = t.salary\\n       AND e.departmentId = t.departmentId\\n       INNER JOIN\\n       department d\\n        ON e.departmentId = d.id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002470,
                "title": "mysql-using-dense-rank",
                "content": "```\\nselect\\ntemp.Employee,\\ntemp.Department,\\ntemp.Salary\\nfrom (select\\nE.Salary,\\nE.Name as Employee,\\nD.Name as Department,\\ndense_rank() over( partition by E.DepartmentId order by E.Salary desc) as rnk\\nfrom Employee E\\ninner join Department D\\non E.DepartmentId = D.Id\\n)temp\\nwhere temp.rnk <4\\n```",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```\\nselect\\ntemp.Employee,\\ntemp.Department,\\ntemp.Salary\\nfrom (select\\nE.Salary,\\nE.Name as Employee,\\nD.Name as Department,\\ndense_rank() over( partition by E.DepartmentId order by E.Salary desc) as rnk\\nfrom Employee E\\ninner join Department D\\non E.DepartmentId = D.Id\\n)temp\\nwhere temp.rnk <4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676561,
                "title": "default-testcase-broken",
                "content": "Defaut testcase throws out the same error message as long as the query is syntactically correct, i.e. even with `SELECT * FROM Employees`, it would give:\\n```\\nLine 5: SyntaxError: near \\'row_number,\\n@dep := DepartmentId as dummy,\\n@salary := Salary as dummy2\\nfr\\n```\\nPlease fix, Thanks!",
                "solutionTags": [],
                "code": "```\\nLine 5: SyntaxError: near \\'row_number,\\n@dep := DepartmentId as dummy,\\n@salary := Salary as dummy2\\nfr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 339865,
                "title": "faster-than-99-85-of-submissions",
                "content": "```\\nSELECT d.Name as \\'Department\\'\\n      ,e.Name as \\'Employee\\'\\n      ,e.Salary\\n  FROM Employee e\\n  JOIN \\n        (SELECT DepartmentId\\n               ,GROUP_CONCAT(DISTINCT Salary\\n                             ORDER BY Salary DESC) as salary_by_dept\\n           FROM Employee \\n          GROUP BY DepartmentId) as salaries\\n    ON salaries.DepartmentId = e.DepartmentId\\n  JOIN Department d on d.Id = e.DepartmentId\\n WHERE FIND_IN_SET(Salary, salary_by_dept) BETWEEN 1 and 3\\n ORDER BY 1,3 DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT d.Name as \\'Department\\'\\n      ,e.Name as \\'Employee\\'\\n      ,e.Salary\\n  FROM Employee e\\n  JOIN \\n        (SELECT DepartmentId\\n               ,GROUP_CONCAT(DISTINCT Salary\\n                             ORDER BY Salary DESC) as salary_by_dept\\n           FROM Employee \\n          GROUP BY DepartmentId) as salaries\\n    ON salaries.DepartmentId = e.DepartmentId\\n  JOIN Department d on d.Id = e.DepartmentId\\n WHERE FIND_IN_SET(Salary, salary_by_dept) BETWEEN 1 and 3\\n ORDER BY 1,3 DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53702,
                "title": "clear-simple-solution-beat-90",
                "content": "```\\nSELECT D.Name as Department, E1.Name as Employee, E1.Salary\\nFROM Employee E1\\nINNER JOIN Employee E2 ON E1.DepartmentId = E2.DepartmentId\\nINNER JOIN Department D ON E1.DepartmentId = D.Id\\nWHERE E1.Salary <= E2.Salary\\nGROUP BY E1.Id\\nHAVING count(DISTINCT E2.Salary) < 4;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT D.Name as Department, E1.Name as Employee, E1.Salary\\nFROM Employee E1\\nINNER JOIN Employee E2 ON E1.DepartmentId = E2.DepartmentId\\nINNER JOIN Department D ON E1.DepartmentId = D.Id\\nWHERE E1.Salary <= E2.Salary\\nGROUP BY E1.Id\\nHAVING count(DISTINCT E2.Salary) < 4;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867441,
                "title": "window-functions-dense-rank-cte-intuitive-solution",
                "content": "```\\nwith temporary_table(name,salary,departmentId,row_number) as (select e.name,e.salary,e.departmentId, dense_rank() over(partition by departmentId order by salary desc) as row_number from Employee e)\\n\\nselect d.name as Department, t.name as Employee, t.salary as Salary \\nfrom temporary_table t join Department d on t.departmentId=d.id\\nwhere t.row_number<4;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nwith temporary_table(name,salary,departmentId,row_number) as (select e.name,e.salary,e.departmentId, dense_rank() over(partition by departmentId order by salary desc) as row_number from Employee e)\\n\\nselect d.name as Department, t.name as Employee, t.salary as Salary \\nfrom temporary_table t join Department d on t.departmentId=d.id\\nwhere t.row_number<4;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538902,
                "title": "solution-with-simple-dense-rank-sql-server-or-simple-count-mysql",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS(\\r\\nSELECT\\r\\n    E.id,\\r\\n    D.name Department,\\r\\n\\tE.name EmployeeName,\\r\\n\\tE.salary,\\r\\n\\tDENSE_RANK() OVER(PARTITION BY D.name ORDER BY E.salary DESC) RANKED\\r\\nFROM\\r\\n\\tEmployee E\\r\\nINNER JOIN\\r\\n\\tDepartment D ON E.departmentId = D.id\\r\\n)\\r\\nSELECT\\r\\n    D.name Department,\\r\\n\\tE.name Employee,\\r\\n    E.Salary Salary\\r\\nFROM\\r\\n\\tEmployee E\\r\\nINNER JOIN\\r\\n    Department D ON E.departmentId = D.id\\r\\nWHERE\\r\\n\\tEXISTS (\\r\\n\\t\\tSELECT\\t\\r\\n\\t\\t\\t1\\r\\n\\t\\tFROM\\r\\n\\t\\t\\tCTE C\\r\\n\\t\\tWHERE\\r\\n\\t\\t\\tE.id = C.id\\r\\n\\t\\tAND\\r\\n\\t\\t\\tC.RANKED BETWEEN 1 AND 3\\r\\n\\t)\\r\\n```\\r\\n\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\n\\r\\nSELECT\\r\\n    D.name  Department ,\\r\\n    E.name Employee,\\r\\n    E.Salary\\r\\nFROM\\r\\n    Employee E\\r\\nLEFT JOIN\\r\\n    Department D ON E.departmentId = D.id\\r\\nWHERE\\r\\n    (\\r\\n\\r\\n        SELECT\\r\\n            COUNT( DISTINCT E1.Salary) Counted\\r\\n        FROM\\r\\n            Employee E1\\r\\n        WHERE\\r\\n            E1.departmentId = E.departmentId\\r\\n        AND\\r\\n            E1.Salary > E.Salary\\r\\n\\r\\n    ) < 3\\r\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\nWITH CTE AS(\\r\\nSELECT\\r\\n    E.id,\\r\\n    D.name Department,\\r\\n\\tE.name EmployeeName,\\r\\n\\tE.salary,\\r\\n\\tDENSE_RANK() OVER(PARTITION BY D.name ORDER BY E.salary DESC) RANKED\\r\\nFROM\\r\\n\\tEmployee E\\r\\nINNER JOIN\\r\\n\\tDepartment D ON E.departmentId = D.id\\r\\n)\\r\\nSELECT\\r\\n    D.name Department,\\r\\n\\tE.name Employee,\\r\\n    E.Salary Salary\\r\\nFROM\\r\\n\\tEmployee E\\r\\nINNER JOIN\\r\\n    Department D ON E.departmentId = D.id\\r\\nWHERE\\r\\n\\tEXISTS (\\r\\n\\t\\tSELECT\\t\\r\\n\\t\\t\\t1\\r\\n\\t\\tFROM\\r\\n\\t\\t\\tCTE C\\r\\n\\t\\tWHERE\\r\\n\\t\\t\\tE.id = C.id\\r\\n\\t\\tAND\\r\\n\\t\\t\\tC.RANKED BETWEEN 1 AND 3\\r\\n\\t)\\r\\n```\n```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\n\\r\\nSELECT\\r\\n    D.name  Department ,\\r\\n    E.name Employee,\\r\\n    E.Salary\\r\\nFROM\\r\\n    Employee E\\r\\nLEFT JOIN\\r\\n    Department D ON E.departmentId = D.id\\r\\nWHERE\\r\\n    (\\r\\n\\r\\n        SELECT\\r\\n            COUNT( DISTINCT E1.Salary) Counted\\r\\n        FROM\\r\\n            Employee E1\\r\\n        WHERE\\r\\n            E1.departmentId = E.departmentId\\r\\n        AND\\r\\n            E1.Salary > E.Salary\\r\\n\\r\\n    ) < 3\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569096,
                "title": "clean-code-with-dense-rank-mysql",
                "content": "Logic:\\n* Join Employee and Department on department id to get department name.\\n* Partition over department name or id & order by salary in decreasing order (as we need to get only top 3 ranks with unique values). Get the dense_rank() for the same window. Read more on dense_rank here: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_dense-rank\\n* Get Departent, Employee, and Salary having the dense rank <= 3 as **we\\'ve to get unique top 3 salaried employees for each department.**\\n\\n```\\nselect\\n    Department,\\n    Employee,\\n    Salary\\nFrom (\\n    select\\n        d.name as \\'Department\\',\\n        e.name as \\'Employee\\',\\n        Salary,\\n        dense_rank() over (partition by d.name order by e.salary desc) drank\\n    from employee e join department d on e.departmentId=d.id\\n) t\\nwhere t.drank <=3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    Department,\\n    Employee,\\n    Salary\\nFrom (\\n    select\\n        d.name as \\'Department\\',\\n        e.name as \\'Employee\\',\\n        Salary,\\n        dense_rank() over (partition by d.name order by e.salary desc) drank\\n    from employee e join department d on e.departmentId=d.id\\n) t\\nwhere t.drank <=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555675,
                "title": "185-department-top-three-salaries",
                "content": "```\\nSELECT d1.Name AS \"Department\", e1.Name AS \"Employee\", e1.Salary\\nFROM Department d1\\n\\nINNER JOIN Employee e1 ON d1.Id = e1.departmentId\\nINNER JOIN Department d2 ON d1.Id = d2.Id\\n\\nLEFT JOIN Employee E2 ON d2.Id = e2.departmentId AND e1.Salary < e2.Salary\\nGROUP BY d1.Name, e1.Name, e1.Salary\\nHAVING COUNT(DISTINCT(e2.Salary)) < 3",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT d1.Name AS \"Department\", e1.Name AS \"Employee\", e1.Salary\\nFROM Department d1\\n\\nINNER JOIN Employee e1 ON d1.Id = e1.departmentId\\nINNER JOIN Department d2 ON d1.Id = d2.Id\\n\\nLEFT JOIN Employee E2 ON d2.Id = e2.departmentId AND e1.Salary < e2.Salary\\nGROUP BY d1.Name, e1.Name, e1.Salary\\nHAVING COUNT(DISTINCT(e2.Salary)) < 3",
                "codeTag": "Unknown"
            },
            {
                "id": 574452,
                "title": "simple-window-function",
                "content": "```\\n\\nselect \\n    Department, Employee, Salary\\n    \\nfrom\\n(\\nselect\\n    D.name as Department, E.name as Employee, E.salary as Salary,\\n    dense_rank() over (partition by DepartmentId order by salary desc) as salary_rank\\nfrom\\n    employee E join Department D on E.departmentid = D.id\\n) as new_table\\n\\nwhere\\n    new_table.salary_rank <= 3\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect \\n    Department, Employee, Salary\\n    \\nfrom\\n(\\nselect\\n    D.name as Department, E.name as Employee, E.salary as Salary,\\n    dense_rank() over (partition by DepartmentId order by salary desc) as salary_rank\\nfrom\\n    employee E join Department D on E.departmentid = D.id\\n) as new_table\\n\\nwhere\\n    new_table.salary_rank <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369861,
                "title": "no-subquery-two-join-with-explanation",
                "content": "```\\nSELECT d.Name AS Department, e.Name AS Employee, e.Salary\\nFROM Employee e\\nJOIN Department d\\nON e.DepartmentId = d.Id\\nJOIN Employee tmp\\nWHERE tmp.DepartmentId = e.DepartmentId\\nAND tmp.Salary >= e.Salary\\nGROUP BY d.Name, e.Name, e.Salary\\nHAVING COUNT(DISTINCT tmp.Salary) <=3\\nORDER BY e.Salary DESC\\n```\\n\\nExplanation\\n```\\nJOIN Department d\\n```\\nis to get a full table\\n```\\nJOIN Employee tmp\\n```\\nis to a get a table where all each employee from the same department with salary higher than each is joined.\\nE.g.: Max\\'s Salary vs rest\\nand count the number of people who has salary higher than Max\\nthus \\n```\\nHAVING COUNT(DISTINCT tmp.Salary) <=3\\n```\\nis to chose the top three people from each department, because fewer than 3 people have salaries higher than them.\\n\\nI am personally more familiar with Postgre than mysql. I am so used to \\n```\\nWITH TABLE xxx \\n```\\nformat.",
                "solutionTags": [],
                "code": "```\\nSELECT d.Name AS Department, e.Name AS Employee, e.Salary\\nFROM Employee e\\nJOIN Department d\\nON e.DepartmentId = d.Id\\nJOIN Employee tmp\\nWHERE tmp.DepartmentId = e.DepartmentId\\nAND tmp.Salary >= e.Salary\\nGROUP BY d.Name, e.Name, e.Salary\\nHAVING COUNT(DISTINCT tmp.Salary) <=3\\nORDER BY e.Salary DESC\\n```\n```\\nJOIN Department d\\n```\n```\\nJOIN Employee tmp\\n```\n```\\nHAVING COUNT(DISTINCT tmp.Salary) <=3\\n```\n```\\nWITH TABLE xxx \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123094,
                "title": "window-function-rank-over",
                "content": "Things are much simplier with postgresql, with WINDOW FUNCTION\\nJust a proof of concept below - you can create a rank of the top 3 salaries\\n```\\nSELECT id, salary, department FROM (\\nSELECT RANK() OVER(PARTITION by department ORDER BY salary), id , salary, department\\nFROM mimi) AS sub\\nWHERE rank <=3\\nORDER BY department, salary DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id, salary, department FROM (\\nSELECT RANK() OVER(PARTITION by department ORDER BY salary), id , salary, department\\nFROM mimi) AS sub\\nWHERE rank <=3\\nORDER BY department, salary DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53735,
                "title": "two-solutions-1-count-join-2-three-variables-join",
                "content": "1) count + join:\\n\\n      select d.Name as Department, e.Name as Employee, e.Salary from Employee as e \\n      inner join Department d on e.DepartmentId = d.Id\\n      where (select count(distinct e1.Salary) from Employee e1 where e1.Salary > e.Salary \\n            and e1.DepartmentId = e.DepartmentId) < 3\\n      order by d.Name, e.Salary DESC;\\n\\n\\n2) Three variables + join :\\n\\n    select d.Name Department, t.Name Employee, t.Salary\\n    from (select Name, Salary, DepartmentId,\\n                 @rank := IF(@prev_department = DepartmentId, @rank + (@prev_salary <> Salary), 1) AS rank,\\n                 @prev_department := DepartmentId,\\n                 @prev_salary := Salary\\n                 from Employee, (select @prev_department := -1, @prev_salary := 0.0, @rank := 1) as init \\n                 ORDER BY DepartmentId, Salary DESC) t \\n                 inner join Department d on d.Id = t.DepartmentId\\n                 where t.rank <= 3 ORDER BY d.Name, t.Salary DESC;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "1) count + join:\\n\\n      select d.Name as Department, e.Name as Employee, e.Salary from Employee as e \\n      inner join Department d on e.DepartmentId = d.Id\\n      where (select count(distinct e1.Salary) from Employee e1 where e1.Salary > e.Salary \\n            and e1.DepartmentId = e.DepartmentId) < 3\\n      order by d.Name, e.Salary DESC;\\n\\n\\n2) Three variables + join :\\n\\n    select d.Name Department, t.Name Employee, t.Salary\\n    from (select Name, Salary, DepartmentId,\\n                 @rank := IF(@prev_department = DepartmentId, @rank + (@prev_salary <> Salary), 1) AS rank,\\n                 @prev_department := DepartmentId,\\n                 @prev_salary := Salary\\n                 from Employee, (select @prev_department := -1, @prev_salary := 0.0, @rank := 1) as init \\n                 ORDER BY DepartmentId, Salary DESC) t \\n                 inner join Department d on d.Id = t.DepartmentId\\n                 where t.rank <= 3 ORDER BY d.Name, t.Salary DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 53758,
                "title": "my-solution-without-fancy-syntax",
                "content": "    select d.Name, r.Name, r.Salary \\n    from (\\n      select DepartmentId, Name, Salary,(\\n        select count(*)+1 from (\\n          select distinct salary, DepartmentId from Employee \\n          ) as uniq\\n         where DepartmentId = e.DepartmentId and Salary > e.Salary   \\n        ) as rank\\n      from Employee e\\n      ) as r, Department d\\n    where r.DepartmentId = d.Id and r.rank <= 3",
                "solutionTags": [],
                "code": "    select d.Name, r.Name, r.Salary \\n    from (\\n      select DepartmentId, Name, Salary,(\\n        select count(*)+1 from (\\n          select distinct salary, DepartmentId from Employee \\n          ) as uniq\\n         where DepartmentId = e.DepartmentId and Salary > e.Salary   \\n        ) as rank\\n      from Employee e\\n      ) as r, Department d\\n    where r.DepartmentId = d.Id and r.rank <= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 3960171,
                "title": "mysql-easy-solution-using-join-subquery",
                "content": "\\n\\n# Code\\n```\\nSELECT D.name AS \\'Department\\', E.name AS \\'Employee\\', E.salary AS \\'Salary\\' \\nFROM Employee E\\nJOIN Department D\\nON E.departmentId = D.id \\nWHERE\\n    3 > (SELECT COUNT(DISTINCT e2.salary)\\n        FROM Employee e2\\n        WHERE e2.salary > E.salary AND E.departmentId = e2.departmentId);\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT D.name AS \\'Department\\', E.name AS \\'Employee\\', E.salary AS \\'Salary\\' \\nFROM Employee E\\nJOIN Department D\\nON E.departmentId = D.id \\nWHERE\\n    3 > (SELECT COUNT(DISTINCT e2.salary)\\n        FROM Employee e2\\n        WHERE e2.salary > E.salary AND E.departmentId = e2.departmentId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917317,
                "title": "using-dense-rank-and-join-not-hard",
                "content": "\\n\\n# Code\\n```\\n\\nwith cte as\\n(\\nselect *, dense_rank() over(partition by departmentid order by salary desc) \\nas rnk    from employee\\n)\\n\\nselect d.name as Department, c.name as Employee, c.salary AS Salary\\nfrom cte c \\njoin department d \\non c.departmentid = d.id  where c.rnk < 4; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nwith cte as\\n(\\nselect *, dense_rank() over(partition by departmentid order by salary desc) \\nas rnk    from employee\\n)\\n\\nselect d.name as Department, c.name as Employee, c.salary AS Salary\\nfrom cte c \\njoin department d \\non c.departmentid = d.id  where c.rnk < 4; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3105339,
                "title": "solution-using-dense-rank-in-mysql",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDense Rank by salary and query the top 3 rank entries.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Department, Employee, Salary\\nfrom \\n (select \\n d.name as Department,\\n e.name as Employee,\\n e.salary as salary,\\n dense_rank() over(partition by d.id order by e.salary desc) `rank`\\n from employee as e, department as d where e.departmentId = d.id\\n ) t\\n where t.rank <= 3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Department, Employee, Salary\\nfrom \\n (select \\n d.name as Department,\\n e.name as Employee,\\n e.salary as salary,\\n dense_rank() over(partition by d.id order by e.salary desc) `rank`\\n from employee as e, department as d where e.departmentId = d.id\\n ) t\\n where t.rank <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2614204,
                "title": "simple-sql",
                "content": "```\\nwith T as (\\n\\n    select name as Employee, \\n            salary,\\n            departmentId,\\n            dense_rank () over(partition by departmentId order by salary desc) rnk\\n    from Employee )\\n    \\nselect d.name as Department, t.Employee, t.salary as Salary\\nfrom T t\\njoin Department d\\non t.departmentId = d.id\\nwhere t.rnk <= 3\\n```",
                "solutionTags": [],
                "code": "```\\nwith T as (\\n\\n    select name as Employee, \\n            salary,\\n            departmentId,\\n            dense_rank () over(partition by departmentId order by salary desc) rnk\\n    from Employee )\\n    \\nselect d.name as Department, t.Employee, t.salary as Salary\\nfrom T t\\njoin Department d\\non t.departmentId = d.id\\nwhere t.rnk <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505090,
                "title": "simple-solution-cte-and-dense-rank",
                "content": "```\\nWITH cte AS(\\n    SELECT e.name AS Employee, e.salary AS Salary, d.name AS Department , \\n        DENSE_RANK() OVER (PARTITION BY d.name ORDER BY salary DESC) AS RANKK\\n    FROM Employee e\\n    JOIN Department d ON e.departmentId = d.id\\n)\\nSELECT Department, Employee, Salary\\nFROM cte\\nWHERE RANKK <= 3\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nWITH cte AS(\\n    SELECT e.name AS Employee, e.salary AS Salary, d.name AS Department , \\n        DENSE_RANK() OVER (PARTITION BY d.name ORDER BY salary DESC) AS RANKK\\n    FROM Employee e\\n    JOIN Department d ON e.departmentId = d.id\\n)\\nSELECT Department, Employee, Salary\\nFROM cte\\nWHERE RANKK <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2498417,
                "title": "mysql-solution-using-dense-rank-faster-than-99-82",
                "content": "### General Steps: \\n#### 1. Merge two tables\\n#### 2. Use dense_rank to group employees by department (Do not use group_by)\\n#### 3. Use dense_rank to rank salaries\\n#### 4. Filter out employees with salary rank < 4\\n\\n```\\nWITH rankings AS (\\n\\n    SELECT \\n    e.name AS Employee,\\n    e.salary AS Salary,\\n    d.name AS Department,\\n    DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) AS ranking\\n    FROM Employee e\\n    INNER JOIN Department d\\n        ON e.departmentId = d.id\\n\\n)\\n\\nSELECT Department, Employee, Salary\\nFROM rankings\\nWHERE ranking < 4\\nORDER BY ranking ASC, Department ASC;\\n\\n```\\n**Let me know if you have any questions. Thanks!**\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH rankings AS (\\n\\n    SELECT \\n    e.name AS Employee,\\n    e.salary AS Salary,\\n    d.name AS Department,\\n    DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) AS ranking\\n    FROM Employee e\\n    INNER JOIN Department d\\n        ON e.departmentId = d.id\\n\\n)\\n\\nSELECT Department, Employee, Salary\\nFROM rankings\\nWHERE ranking < 4\\nORDER BY ranking ASC, Department ASC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482530,
                "title": "mysql-solution-using-limit",
                "content": "My solution using `LIMIT` :\\n```\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d ON e.departmentId = d.id\\nWHERE e.salary IN\\n(\\n    SELECT *\\n    FROM\\n    (\\n        SELECT DISTINCT salary\\n        FROM Employee\\n        WHERE departmentId = e.departmentId\\n        ORDER BY salary DESC\\n        LIMIT 3\\n    ) AS t\\n)\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee AS e\\nINNER JOIN Department AS d ON e.departmentId = d.id\\nWHERE e.salary IN\\n(\\n    SELECT *\\n    FROM\\n    (\\n        SELECT DISTINCT salary\\n        FROM Employee\\n        WHERE departmentId = e.departmentId\\n        ORDER BY salary DESC\\n        LIMIT 3\\n    ) AS t\\n)\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403529,
                "title": "simple-sql-solution-dense-rank",
                "content": "```\\nselect Department, Employee, Salary from \\n(select D.name as Department,E.name as Employee,E.Salary, dense_rank() over(partition by E.departmentId order by E.salary Desc) as rn from Employee E inner join Department D on E.DepartmentID=D.id)A where rn<=3\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect Department, Employee, Salary from \\n(select D.name as Department,E.name as Employee,E.Salary, dense_rank() over(partition by E.departmentId order by E.salary Desc) as rn from Employee E inner join Department D on E.DepartmentID=D.id)A where rn<=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2337608,
                "title": "4-lines-solution",
                "content": "```\\nSelect tab.Department,tab.Employee, tab.Salary\\nFROM (SELECT D.name As Department,E.name AS Employee, Salary,dense_rank() over(partition by departmentId ORDER BY salary Desc) As m_rank\\n\\t\\tFROM Employee E join Department D ON departmentId=D.id) As tab\\nWHERE tab.m_rank<4\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSelect tab.Department,tab.Employee, tab.Salary\\nFROM (SELECT D.name As Department,E.name AS Employee, Salary,dense_rank() over(partition by departmentId ORDER BY salary Desc) As m_rank\\n\\t\\tFROM Employee E join Department D ON departmentId=D.id) As tab\\nWHERE tab.m_rank<4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2315460,
                "title": "mysql-easy-understand-subquery-using-top-3-salary-from-that-department",
                "content": "```\\nselect d.name as Department, e.name as Employee, e.salary\\nfrom department as d\\nleft join employee as e on d.id = e.departmentId\\nwhere e.salary in (\\n    select * from \\n    (\\n        select distinct salary \\n        from employee\\n        where departmentId = d.id\\n        order by salary  desc\\n        limit 3\\n    ) as top_3_salary\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.name as Department, e.name as Employee, e.salary\\nfrom department as d\\nleft join employee as e on d.id = e.departmentId\\nwhere e.salary in (\\n    select * from \\n    (\\n        select distinct salary \\n        from employee\\n        where departmentId = d.id\\n        order by salary  desc\\n        limit 3\\n    ) as top_3_salary\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226001,
                "title": "mysql-solution",
                "content": "**NOTE:** I had to wrap the subquery in another select statement to get around the `this version of MySQL doesn\\'t yet support \\'LIMIT & IN/ALL/ANY/SOME subquery\\'` error.\\n\\n```\\nSELECT\\n    dep.name AS `Department`,\\n    emp.name AS `Employee`,\\n    salary\\nFROM\\n    Employee emp\\nINNER JOIN\\n    Department dep\\n    ON\\n    dep.id = emp.departmentId\\nWHERE\\n    salary IN (SELECT * FROM (SELECT DISTINCT salary FROM Employee WHERE departmentId = dep.id ORDER BY salary DESC LIMIT 3) top_three_salaries);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    dep.name AS `Department`,\\n    emp.name AS `Employee`,\\n    salary\\nFROM\\n    Employee emp\\nINNER JOIN\\n    Department dep\\n    ON\\n    dep.id = emp.departmentId\\nWHERE\\n    salary IN (SELECT * FROM (SELECT DISTINCT salary FROM Employee WHERE departmentId = dep.id ORDER BY salary DESC LIMIT 3) top_three_salaries);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119588,
                "title": "mysql-simple-solution-faster-than-50-38",
                "content": "**note :  i used (SELECT * FROM( your subquery )) because cannot use limit direct with subquery**\\n```\\nselect Department.name as Department , Employee.name as Employee ,Salary \\nfrom Employee \\njoin Department on Department.id = Employee.departmentId\\n\\nwhere  (salary,departmentId) IN (SELECT * FROM  (\\nselect  distinct Salary ,departmentId\\n    from Employee\\n    where Employee.departmentId = Department.id\\n    order by salary DESC \\n    limit 3\\n) as t)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect Department.name as Department , Employee.name as Employee ,Salary \\nfrom Employee \\njoin Department on Department.id = Employee.departmentId\\n\\nwhere  (salary,departmentId) IN (SELECT * FROM  (\\nselect  distinct Salary ,departmentId\\n    from Employee\\n    where Employee.departmentId = Department.id\\n    order by salary DESC \\n    limit 3\\n) as t)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959724,
                "title": "my-sql-dense-rank-with-join",
                "content": "```\\nwith dep\\nas\\n(\\nselect d.name as department,e.name as Employee,e.salary,DENSE_RANK() OVER(partition by d.name order by salary desc) r\\nfrom\\nemployee e\\nleft join\\ndepartment d\\non\\ne.departmentId=d.id\\n)\\nselect department,employee,salary\\nfrom\\ndep\\nwhere\\nr<=3\\norder by salary desc\\n```",
                "solutionTags": [],
                "code": "```\\nwith dep\\nas\\n(\\nselect d.name as department,e.name as Employee,e.salary,DENSE_RANK() OVER(partition by d.name order by salary desc) r\\nfrom\\nemployee e\\nleft join\\ndepartment d\\non\\ne.departmentId=d.id\\n)\\nselect department,employee,salary\\nfrom\\ndep\\nwhere\\nr<=3\\norder by salary desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1900019,
                "title": "my-solution-is-faster-than-95",
                "content": "select Department,Employee,Salary\\nfrom\\n(select \\n     d.name as Department,\\n     e.name as Employee,\\n     e.Salary as Salary,\\n     dense_rank() over(partition by e.departmentId order by e.Salary desc) as rk\\nfrom Employee e\\nleft join Department d on e.departmentId = d.id) a\\nwhere rk <= 3",
                "solutionTags": [],
                "code": "select Department,Employee,Salary\\nfrom\\n(select \\n     d.name as Department,\\n     e.name as Employee,\\n     e.Salary as Salary,\\n     dense_rank() over(partition by e.departmentId order by e.Salary desc) as rk\\nfrom Employee e\\nleft join Department d on e.departmentId = d.id) a\\nwhere rk <= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 1845870,
                "title": "solution-without-using-dense-rank-and-partition",
                "content": "Although it is very slow, it is different than most solutions. Hope you\\'ll learn something new.\\n```\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee e\\nJOIN Department d\\n    ON (e.departmentId = d.id)\\nWHERE salary >= (\\n    SELECT salary\\n    FROM (\\n        SELECT salary\\n        FROM Employee\\n        WHERE departmentId = e.departmentId\\n        GROUP BY salary\\n        ORDER BY salary DESC\\n        LIMIT 3\\n    ) AS top_sal\\n    ORDER BY salary ASC\\n    LIMIT 1\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT d.name AS Department, e.name AS Employee, e.salary AS Salary\\nFROM Employee e\\nJOIN Department d\\n    ON (e.departmentId = d.id)\\nWHERE salary >= (\\n    SELECT salary\\n    FROM (\\n        SELECT salary\\n        FROM Employee\\n        WHERE departmentId = e.departmentId\\n        GROUP BY salary\\n        ORDER BY salary DESC\\n        LIMIT 3\\n    ) AS top_sal\\n    ORDER BY salary ASC\\n    LIMIT 1\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546934,
                "title": "mysql-simple-solution-with-dense-rank",
                "content": "here is my solution\\n```\\nwith cte as (\\n\\tselect\\n\\t\\td.name as Department,\\n\\t\\te.name as Employee,\\n\\t\\te.salary as Salary,\\n\\t    dense_rank() over(partition by d.id order by e.salary desc) as drank\\n\\tfrom department d\\n\\tleft join employee e on e.departmentid = d.id\\n)\\nselect\\n\\tDepartment,\\n\\tEmployee,\\n\\tSalary\\nfrom cte\\nwhere cte.drank <=3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte as (\\n\\tselect\\n\\t\\td.name as Department,\\n\\t\\te.name as Employee,\\n\\t\\te.salary as Salary,\\n\\t    dense_rank() over(partition by d.id order by e.salary desc) as drank\\n\\tfrom department d\\n\\tleft join employee e on e.departmentid = d.id\\n)\\nselect\\n\\tDepartment,\\n\\tEmployee,\\n\\tSalary\\nfrom cte\\nwhere cte.drank <=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010831,
                "title": "oracle-solution",
                "content": "```\\nselect p2.name as \"Department\",\\n       p1.name as \"Employee\",\\n       p1.salary as \"Salary\"\\nfrom\\n(select name,\\n       departmentid,\\n       salary,\\n       dense_rank() over(partition by departmentid order by salary desc) as rank\\nfrom employee ) p1,\\n(select id, name from department) p2\\nwhere p1.departmentid = p2.id\\nand rank <= 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect p2.name as \"Department\",\\n       p1.name as \"Employee\",\\n       p1.salary as \"Salary\"\\nfrom\\n(select name,\\n       departmentid,\\n       salary,\\n       dense_rank() over(partition by departmentid order by salary desc) as rank\\nfrom employee ) p1,\\n(select id, name from department) p2\\nwhere p1.departmentid = p2.id\\nand rank <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766532,
                "title": "simple-of-simple",
                "content": "```sql\\n# Write your MySQL query statement below\\n\\nSELECT \\n    department,\\n    employee,\\n    salary\\nFROM (\\n    SELECT\\n        departmentId,\\n        d.name department,\\n        e.name employee,\\n        salary,\\n        DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) rnk\\n    FROM employee e JOIN department d\\n        ON e.departmentId = d.id\\n) t\\nWHERE rnk <= 3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\n# Write your MySQL query statement below\\n\\nSELECT \\n    department,\\n    employee,\\n    salary\\nFROM (\\n    SELECT\\n        departmentId,\\n        d.name department,\\n        e.name employee,\\n        salary,\\n        DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) rnk\\n    FROM employee e JOIN department d\\n        ON e.departmentId = d.id\\n) t\\nWHERE rnk <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698869,
                "title": "ms-sql-solution",
                "content": "```\\nselect department, employee, salary\\nfrom(\\nselect d.name as Department, e.name as Employee, e.salary as Salary,\\n        dense_rank() over (partition by d.name order by e.salary desc) as rank\\nfrom employee e\\njoin department d on e.departmentId = d.Id) a\\nwhere a.rank <= 3\\norder by department asc, salary desc\\n```",
                "solutionTags": [],
                "code": "```\\nselect department, employee, salary\\nfrom(\\nselect d.name as Department, e.name as Employee, e.salary as Salary,\\n        dense_rank() over (partition by d.name order by e.salary desc) as rank\\nfrom employee e\\njoin department d on e.departmentId = d.Id) a\\nwhere a.rank <= 3\\norder by department asc, salary desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530284,
                "title": "mysql-1100ms-solution",
                "content": "```SQL\\nSELECT d.Name AS Department, e.Name AS Employee, e.Salary AS Salary\\nFROM Employee e\\nINNER JOIN Department d\\nON e.DepartmentId = d.Id\\nWHERE\\n    (\\n        SELECT COUNT(DISTINCT e2.Salary)\\n        FROM Employee e2\\n        WHERE e2.Salary > e.Salary AND e.DepartmentId = e2.DepartmentId\\n    ) < 3\\nORDER BY e.DepartmentId, e.Salary DESC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```SQL\\nSELECT d.Name AS Department, e.Name AS Employee, e.Salary AS Salary\\nFROM Employee e\\nINNER JOIN Department d\\nON e.DepartmentId = d.Id\\nWHERE\\n    (\\n        SELECT COUNT(DISTINCT e2.Salary)\\n        FROM Employee e2\\n        WHERE e2.Salary > e.Salary AND e.DepartmentId = e2.DepartmentId\\n    ) < 3\\nORDER BY e.DepartmentId, e.Salary DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226151,
                "title": "salary-higher-than-current-salary-3",
                "content": "```\\nselect d.Name as Department, e.Name as Employee, e.Salary\\nfrom Employee e join Department d on e.DepartmentId = d.Id\\nwhere (select count(distinct Salary) from Employee where Salary > e.Salary and DepartmentId = d.Id) < 3 \\norder by d.Name, e.Salary desc\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.Name as Department, e.Name as Employee, e.Salary\\nfrom Employee e join Department d on e.DepartmentId = d.Id\\nwhere (select count(distinct Salary) from Employee where Salary > e.Salary and DepartmentId = d.Id) < 3 \\norder by d.Name, e.Salary desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 214287,
                "title": "solution-with-rank-function-vs-without-rank-function",
                "content": "When I tested the performance (with a small dataset) of following 2 solutions in MS SQL Server, one with DENSE_RANK and the other without any rank function, I found the later is bit more performant. When compared, the solution with DENSE_RANK has much simpler query plan but it is not as performant as the one without any rank function. Can someone explain why this happens?\\n\\nSolution1 (with Dense Rank)\\n```\\nselect q.Department, q.Employee, q.Salary from\\n(select \\nd.name as Department, \\ne.name as Employee, e.Salary, DENSE_RANK() over(partition by d.name order by salary desc) as drank\\nfrom Employee e\\ninner join Department d on e.DepartmentID=d.Id\\n) q\\nwhere q.drank<=3\\n```\\n\\nSolution 2 (without any rank function)\\n```\\nSELECT\\n    d.Name AS \\'Department\\', e1.Name AS \\'Employee\\', e1.Salary\\nFROM\\n    Employee e1\\n        JOIN\\n    Department d ON e1.DepartmentId = d.Id\\nWHERE\\n    3 > (SELECT\\n            COUNT(DISTINCT e2.Salary)\\n        FROM\\n            Employee e2\\n        WHERE\\n            e2.Salary > e1.Salary\\n                AND e1.DepartmentId = e2.DepartmentId\\n        )\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nselect q.Department, q.Employee, q.Salary from\\n(select \\nd.name as Department, \\ne.name as Employee, e.Salary, DENSE_RANK() over(partition by d.name order by salary desc) as drank\\nfrom Employee e\\ninner join Department d on e.DepartmentID=d.Id\\n) q\\nwhere q.drank<=3\\n```\n```\\nSELECT\\n    d.Name AS \\'Department\\', e1.Name AS \\'Employee\\', e1.Salary\\nFROM\\n    Employee e1\\n        JOIN\\n    Department d ON e1.DepartmentId = d.Id\\nWHERE\\n    3 > (SELECT\\n            COUNT(DISTINCT e2.Salary)\\n        FROM\\n            Employee e2\\n        WHERE\\n            e2.Salary > e1.Salary\\n                AND e1.DepartmentId = e2.DepartmentId\\n        )\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170496,
                "title": "sql-solution-in-mysql",
                "content": "```\\nSELECT\\n\\td.NAME AS Department,\\n\\te.NAME AS Employee,\\n\\te.Salary AS Salary \\nFROM\\n\\tEmployee e\\n\\tJOIN Department d ON e.DepartmentId = d.Id \\nWHERE\\n\\t( SELECT count( DISTINCT Salary ) FROM Employee WHERE Salary > e.Salary AND DepartmentId = e.DepartmentId ) < 3 \\nORDER BY\\n\\td.NAME,\\n\\te.Salary DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n\\td.NAME AS Department,\\n\\te.NAME AS Employee,\\n\\te.Salary AS Salary \\nFROM\\n\\tEmployee e\\n\\tJOIN Department d ON e.DepartmentId = d.Id \\nWHERE\\n\\t( SELECT count( DISTINCT Salary ) FROM Employee WHERE Salary > e.Salary AND DepartmentId = e.DepartmentId ) < 3 \\nORDER BY\\n\\td.NAME,\\n\\te.Salary DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53751,
                "title": "distinct-word-should-not-be-used",
                "content": "    select d.Name as Department , e.Name as Employee , e.Salary from Employee e join Department d on e.DepartmentId = d.Id \\n    where 3>(select count(t.Salary) from Employee  t where e.Salary < t.Salary and t.DepartmentId = e.DepartmentId ) order by Department,Salary desc",
                "solutionTags": [],
                "code": "    select d.Name as Department , e.Name as Employee , e.Salary from Employee e join Department d on e.DepartmentId = d.Id \\n    where 3>(select count(t.Salary) from Employee  t where e.Salary < t.Salary and t.DepartmentId = e.DepartmentId ) order by Department,Salary desc",
                "codeTag": "Unknown"
            },
            {
                "id": 4009141,
                "title": "easy-sql-cte-solution",
                "content": "# Intuition\\nEasy solution to the problem with a cte\\n\\n# Approach\\nUsing a cte\\n\\n# Complexity\\n- Time complexity:\\n5 mins ish\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith test as (\\nselect distinct id, name, salary, departmentId,\\ndense_rank() over(partition by departmentId order by salary desc) as salary_rank\\nfrom employee\\n) \\n\\nselect d.name as department, t.name as Employee , t.salary as Salary from test t\\nleft join department d on t.departmentId = d.id\\nwhere salary_rank < 4\\norder by department, Salary\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith test as (\\nselect distinct id, name, salary, departmentId,\\ndense_rank() over(partition by departmentId order by salary desc) as salary_rank\\nfrom employee\\n) \\n\\nselect d.name as department, t.name as Employee , t.salary as Salary from test t\\nleft join department d on t.departmentId = d.id\\nwhere salary_rank < 4\\norder by department, Salary\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888314,
                "title": "short-and-simple-pandas-solution-beats-100-in-memory-and-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to sort the values in a descending manner and pull the top 3 for each department. I considered using a for loop to iterate through each department value and chunk the dataframe that way, but realized I could instead use groupby and head().\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBecause we want the top three unique salaries, drop duplicate values of salary <> department ID. Then sort the values highest to lowest and take the top 3 values for each value of department ID. Merge this with the department dataframe to get the department\\'s full name.\\n\\nMerge the resulting set of up to 3 top salaries for each department with the employee dataframe on salary and departmentId. This is an inner join, and so the result will include only those employees in each department with a salary equivalent to one in the top 3 for that department.\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    salaries = employee[[\\'salary\\', \\'departmentId\\']].drop_duplicates()\\n    top_salaries = salaries.sort_values(by=\\'salary\\', ascending=False).groupby(\\'departmentId\\').head(3)\\n    top_salaries = pd.merge(top_salaries, department, left_on=\\'departmentId\\', right_on = \\'id\\').rename(columns={\\'name\\': \\'Department\\'}).drop(columns=\\'id\\')\\n    return pd.merge(top_salaries, employee, on=[\\'salary\\', \\'departmentId\\'])[[\\'Department\\', \\'name\\', \\'salary\\']].rename(columns={\\'name\\': \\'Employee\\', \\'salary\\': \\'Salary\\'})\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    salaries = employee[[\\'salary\\', \\'departmentId\\']].drop_duplicates()\\n    top_salaries = salaries.sort_values(by=\\'salary\\', ascending=False).groupby(\\'departmentId\\').head(3)\\n    top_salaries = pd.merge(top_salaries, department, left_on=\\'departmentId\\', right_on = \\'id\\').rename(columns={\\'name\\': \\'Department\\'}).drop(columns=\\'id\\')\\n    return pd.merge(top_salaries, employee, on=[\\'salary\\', \\'departmentId\\'])[[\\'Department\\', \\'name\\', \\'salary\\']].rename(columns={\\'name\\': \\'Employee\\', \\'salary\\': \\'Salary\\'})\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3882086,
                "title": "pandas-dense-rank-o-n-log-n-or-nlargest-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe short way is to `rank()` by salary all employees within each department. However, this invokes sorting at $O(n \\\\log n)$ cost. Since we are only interested in top 3 ranks, we can improve to $O(n)$ using quickselect at the cost of slightly more code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each Department we need to find employees with salaries in the top 3. The quickest way is to group by Dept and `rank(method=\\'dense\\')`. Then we just filter out employees with `rank > 3` and do the cosmetics to comply with the output format (the code is at the bottom of this Solution).\\n\\nHowever, `rank` sorts the data, leading to $O(n \\\\log n)$ time cost. This is unneccessary since we don\\'t need to know everyones rank, we just need to partition salaries to retain top three. This only requires $O(n)$ using the quickselect algorithm. This is implemented in pandas with the `nlargest()` method. \\n\\nUnfortunately `nlargest()` does not have the flexibility of `rank()` and offers no `\\'dense\\'` option. Therefore we first drop duplicates in `[\\'salary\\',\\'departmentId\\']` values, then keep 3 largest within each Department, then take the minimum of these (up to) 3 values. If you know a way to pick the third-highest without doing the second `groupby()` and `min()` combo, please let me know in the comments! \\n\\nNow we have `salary_cutoff` which lists the 3-rd highest salary for each Department. The rest is quite straight-forward.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$ using `nlargest()` or $$O(n \\\\log n)$$ using `rank()`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ bound by output size\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    salary_cutoff = (employee\\n        .drop_duplicates([\\'salary\\',\\'departmentId\\'])\\n        .groupby(\\'departmentId\\')[\\'salary\\']\\n        .nlargest(3)\\n        .groupby(\\'departmentId\\')\\n        .min()\\n    )\\n    employee[\\'Department\\'] = department.set_index(\\'id\\')[\\'name\\'][employee[\\'departmentId\\']].values\\n    employee[\\'cutoff\\'] = salary_cutoff[employee[\\'departmentId\\']].values\\n    return employee[employee[\\'salary\\'] >= employee[\\'cutoff\\']]\\\\\\n        .rename(columns={\\'name\\':\\'Employee\\', \\'salary\\':\\'Salary\\'})\\\\\\n        [[\\'Department\\',\\'Employee\\',\\'Salary\\']]\\n```\\n# Shorter but asymptotically slower code using `rank()`\\n```\\nimport pandas as pd\\n\\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    employee[\\'rank\\'] = employee.groupby(\\'departmentId\\').salary.rank(method=\\'dense\\', ascending=False)\\n    return (employee\\n        .assign(departmentId = department.set_index(\\'id\\')[\\'name\\'][employee[\\'departmentId\\']].values)\\n        [employee[\\'rank\\'] <= 3]\\n        .rename(columns={\\'name\\':\\'Employee\\', \\'salary\\':\\'Salary\\', \\'departmentId\\':\\'Department\\'})\\n        [[\\'Department\\',\\'Employee\\',\\'Salary\\']] \\n    )\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    salary_cutoff = (employee\\n        .drop_duplicates([\\'salary\\',\\'departmentId\\'])\\n        .groupby(\\'departmentId\\')[\\'salary\\']\\n        .nlargest(3)\\n        .groupby(\\'departmentId\\')\\n        .min()\\n    )\\n    employee[\\'Department\\'] = department.set_index(\\'id\\')[\\'name\\'][employee[\\'departmentId\\']].values\\n    employee[\\'cutoff\\'] = salary_cutoff[employee[\\'departmentId\\']].values\\n    return employee[employee[\\'salary\\'] >= employee[\\'cutoff\\']]\\\\\\n        .rename(columns={\\'name\\':\\'Employee\\', \\'salary\\':\\'Salary\\'})\\\\\\n        [[\\'Department\\',\\'Employee\\',\\'Salary\\']]\\n```\n```\\nimport pandas as pd\\n\\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\\n    employee[\\'rank\\'] = employee.groupby(\\'departmentId\\').salary.rank(method=\\'dense\\', ascending=False)\\n    return (employee\\n        .assign(departmentId = department.set_index(\\'id\\')[\\'name\\'][employee[\\'departmentId\\']].values)\\n        [employee[\\'rank\\'] <= 3]\\n        .rename(columns={\\'name\\':\\'Employee\\', \\'salary\\':\\'Salary\\', \\'departmentId\\':\\'Department\\'})\\n        [[\\'Department\\',\\'Employee\\',\\'Salary\\']] \\n    )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2865333,
                "title": "dense-rank",
                "content": "To understand this, you need to understand rank and dense rank.\\n# Rank\\nSay you have these `(name,salary)` rows in table T as\\n```\\n(A,100), (B,200), (C,200)\\n```\\nThen\\nthe result of query\\n```\\nselect *,rank() over(order by salary desc) as sal_rank from T\\n```\\nwill be\\n```\\n(B,200,1),(C,200,1),(A,100,3)\\n```\\nie in case of clash same rank is given to all clashing and some ranks will be skipped.\\n\\nHowever `dense_rank` query\\n```\\nselect *,dense_rank() over(order by salary desc) as sal_rank from T\\n```\\nwill give following output\\n```\\n(B,200,1),(C,200,1),(A,100,2)\\n```\\nie same rank is given for clash similar to `rank()` but no ranks are skipped.\\n\\nOther trick to know is `partition by` inside the `over()` argument in `dense_rank()` function, just add `partition by dept` then, the ranks will be for people having same value of `dept`.\\n\\n# SQL code:\\n\\n```\\nselect department,employee,salary from (\\nselect *, dense_rank() over (partition by department order by salary desc) as sal_rank from \\n(select E.name as employee,D.name as department,E.salary from employee E inner join department D on E.departmentid = D.id) as T1\\n) as T2\\nwhere T2.sal_rank<=3\\n```",
                "solutionTags": [],
                "code": "```\\n(A,100), (B,200), (C,200)\\n```\n```\\nselect *,rank() over(order by salary desc) as sal_rank from T\\n```\n```\\n(B,200,1),(C,200,1),(A,100,3)\\n```\n```\\nselect *,dense_rank() over(order by salary desc) as sal_rank from T\\n```\n```\\n(B,200,1),(C,200,1),(A,100,2)\\n```\n```\\nselect department,employee,salary from (\\nselect *, dense_rank() over (partition by department order by salary desc) as sal_rank from \\n(select E.name as employee,D.name as department,E.salary from employee E inner join department D on E.departmentid = D.id) as T1\\n) as T2\\nwhere T2.sal_rank<=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613406,
                "title": "my-sql-solution-using-dense-rank-and-left-join",
                "content": "select Department,Employee,Salary from\\n(select d.name as Department ,e.name as Employee,e.salary as Salary ,\\n dense_rank() over(partition by d.name order by e.salary desc ) as rnk \\n from employee e left join department d on e.departmentid=d.id) as f \\n where rnk<=3;",
                "solutionTags": [],
                "code": "select Department,Employee,Salary from\\n(select d.name as Department ,e.name as Employee,e.salary as Salary ,\\n dense_rank() over(partition by d.name order by e.salary desc ) as rnk \\n from employee e left join department d on e.departmentid=d.id) as f \\n where rnk<=3;",
                "codeTag": "Unknown"
            },
            {
                "id": 2458923,
                "title": "solution-with-detail-explanation-easy-to-understand",
                "content": "**Please Upvote me ^ Thanks,**\\n\\nHERE first arrange Employee rank base on salary\\n```\\nSELECT departmentId,name,salary,DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC) as r FROM Employee\\n```\\nNow we have rank ,Now make above statement a Table and JOIN it to Department table to get Department name\\nAND condition r<=3 because we need top 3 of each Department.\\n\\n**Code**\\n```\\nSELECT Department.name AS Department,e.name AS Employee,e.salary AS Salary\\nFROM (SELECT departmentId,name,salary,DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC) as r FROM Employee) e\\nJOIN Department ON e.departmentId=Department.id\\nWHERE r<=3;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT departmentId,name,salary,DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC) as r FROM Employee\\n```\n```\\nSELECT Department.name AS Department,e.name AS Employee,e.salary AS Salary\\nFROM (SELECT departmentId,name,salary,DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC) as r FROM Employee) e\\nJOIN Department ON e.departmentId=Department.id\\nWHERE r<=3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450645,
                "title": "simple-solution-using-dense-rank-100-fast",
                "content": "This Problem is similar to [184. Department Highest Salary](https://leetcode.com/problems/department-highest-salary/)\\nDo checkout my solution to above problem [Click Here!!](https://leetcode.com/problems/department-highest-salary/discuss/2450611/Using-Rank-and-Partition-by!!-100-Fast) \\n \\nSimple Solution!!!\\n* Partitioned the rows by departmentId and ordered it by salary in desc order.\\n* Made a new column for rank using func dense_rank() .\\n* Now where-ever the rank is < 4 (to select top 3).\\n**That is our answer!**\\n```\\nselect\\n  Department,\\n  Employee,\\n  Salary\\nfrom\\n  (\\n    select\\n      Employee.name as Employee,\\n      Employee.salary as Salary,\\n      Department.name as Department,\\n      DENSE_RANK() OVER(\\n        partition by departmentId\\n        order by\\n          salary desc\\n      ) as rankk\\n    from\\n      Employee\\n      inner join Department on Department.id = Employee.departmentId\\n  ) as tab1\\nwhere\\n  rankk < 4;\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n  Department,\\n  Employee,\\n  Salary\\nfrom\\n  (\\n    select\\n      Employee.name as Employee,\\n      Employee.salary as Salary,\\n      Department.name as Department,\\n      DENSE_RANK() OVER(\\n        partition by departmentId\\n        order by\\n          salary desc\\n      ) as rankk\\n    from\\n      Employee\\n      inner join Department on Department.id = Employee.departmentId\\n  ) as tab1\\nwhere\\n  rankk < 4;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2315124,
                "title": "95-fast-and-easy-solution-using-dense-rank",
                "content": "```\\nwith highsalary as (\\nSelect departmentId,name,salary,\\n    dense_rank() over(partition by departmentId order by salary desc ) as ranking\\n    from employee\\n)\\nSelect d.name as department, h.name as employee, h.salary \\nfrom highsalary h left Join department d \\non h.departmentId = d.id\\nwhere h.ranking<=3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith highsalary as (\\nSelect departmentId,name,salary,\\n    dense_rank() over(partition by departmentId order by salary desc ) as ranking\\n    from employee\\n)\\nSelect d.name as department, h.name as employee, h.salary \\nfrom highsalary h left Join department d \\non h.departmentId = d.id\\nwhere h.ranking<=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2296741,
                "title": "oracle-sol",
                "content": "select d.name as Department, s.name as Employee, s.salary as Salary\\nfrom\\n(select name, salary, departmentId, dense_rank() over(partition by departmentId order by salary desc) salary_rank\\nfrom Employee) s, Department d\\nwhere s.departmentId = d.id\\nand s.salary_rank <= 3",
                "solutionTags": [],
                "code": "select d.name as Department, s.name as Employee, s.salary as Salary\\nfrom\\n(select name, salary, departmentId, dense_rank() over(partition by departmentId order by salary desc) salary_rank\\nfrom Employee) s, Department d\\nwhere s.departmentId = d.id\\nand s.salary_rank <= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 2263656,
                "title": "ms-sql-server-using-subquery",
                "content": "```\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom employee e join department d\\non e.departmentId = d.id\\nwhere e.salary in (select distinct top(3) salary from employee where departmentId=d.id order by salary desc) \\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.name as Department, e.name as Employee, e.salary as Salary\\nfrom employee e join department d\\non e.departmentId = d.id\\nwhere e.salary in (select distinct top(3) salary from employee where departmentId=d.id order by salary desc) \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2144618,
                "title": "mysql-using-left-join-with-dense-rank",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT\\n    dept.name AS \\'Department\\',\\n    dept_sal_rank.name AS \\'Employee\\',\\n    dept_sal_rank.salary AS \\'Salary\\'\\nFROM Department AS dept\\nLEFT JOIN \\n    (SELECT\\n        *,\\n        DENSE_RANK() OVER (\\n            PARTITION BY departmentId\\n            ORDER BY salary DESC\\n            ) AS salary_rank\\n     FROM Employee\\n    ) AS dept_sal_rank\\n    ON dept.id = dept_sal_rank.departmentId\\nWHERE dept_sal_rank.salary_rank <= 3;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    dept.name AS \\'Department\\',\\n    dept_sal_rank.name AS \\'Employee\\',\\n    dept_sal_rank.salary AS \\'Salary\\'\\nFROM Department AS dept\\nLEFT JOIN \\n    (SELECT\\n        *,\\n        DENSE_RANK() OVER (\\n            PARTITION BY departmentId\\n            ORDER BY salary DESC\\n            ) AS salary_rank\\n     FROM Employee\\n    ) AS dept_sal_rank\\n    ON dept.id = dept_sal_rank.departmentId\\nWHERE dept_sal_rank.salary_rank <= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987762,
                "title": "tsql-clean-and-fast-solution-window-functions-are-your-friends",
                "content": "Simple solution below using a window function. I cannot recommend window functions enough. **Whenever you are in a job and have data requests for I need X for each Y, or X by Y, the neurons in your brain dedicated to window functions should be lighting up. **\\n\\nEven better, window functions tend to scale by nature -- less rewriting code for hardcoded logic. Additionally, what I love about this example, is that the subquery sort of \"shows your work\" and can be used to help demonstrate the \\'magic\\' of how this function works. Sometimes non-technical people don\\'t trust the SQL magic, and showing them the results of the subquery gives them their \"ohhhh!\" or \"ah ha!\" moment that allows them to trust your result set.\\n\\n**Tricky spots for people to watch out for:**  Use DENSE_RANK() instead of RANK(), and alias both of the \\'name\\' fields in the subquery to avoid execution or downstream issues.\\n\\n\\nSELECT\\n    SR.Department\\n    ,SR.Employee\\n    ,SR.Salary\\n\\nFROM\\n    (\\n        SELECT\\n             D.name AS [Department]\\n            ,E.name AS [Employee]\\n            ,E.salary\\n            ,DENSE_RANK() OVER (PARTITION BY D.name ORDER BY E.Salary DESC) AS [DepartmentSalaryRank]\\n        FROM Employee E\\n        LEFT JOIN Department D ON D.id = E.departmentID\\n     ) SR\\n \\n WHERE SR.DepartmentSalaryRank <= 3\\n \\n ORDER BY 1,2,3",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "Simple solution below using a window function. I cannot recommend window functions enough. **Whenever you are in a job and have data requests for I need X for each Y, or X by Y, the neurons in your brain dedicated to window functions should be lighting up. **\\n\\nEven better, window functions tend to scale by nature -- less rewriting code for hardcoded logic. Additionally, what I love about this example, is that the subquery sort of \"shows your work\" and can be used to help demonstrate the \\'magic\\' of how this function works. Sometimes non-technical people don\\'t trust the SQL magic, and showing them the results of the subquery gives them their \"ohhhh!\" or \"ah ha!\" moment that allows them to trust your result set.\\n\\n**Tricky spots for people to watch out for:**  Use DENSE_RANK() instead of RANK(), and alias both of the \\'name\\' fields in the subquery to avoid execution or downstream issues.\\n\\n\\nSELECT\\n    SR.Department\\n    ,SR.Employee\\n    ,SR.Salary\\n\\nFROM\\n    (\\n        SELECT\\n             D.name AS [Department]\\n            ,E.name AS [Employee]\\n            ,E.salary\\n            ,DENSE_RANK() OVER (PARTITION BY D.name ORDER BY E.Salary DESC) AS [DepartmentSalaryRank]\\n        FROM Employee E\\n        LEFT JOIN Department D ON D.id = E.departmentID\\n     ) SR\\n \\n WHERE SR.DepartmentSalaryRank <= 3\\n \\n ORDER BY 1,2,3",
                "codeTag": "Unknown"
            },
            {
                "id": 1948686,
                "title": "a-short-query",
                "content": "```\\nwith t as (select *, \\n           dense_rank() over(partition by departmentId\\n                              order by salary desc) as Ranks\\n           from Employee)\\nselect t.name Employee, salary, d.name Department \\nfrom t\\n    join Department d\\n    on d.id = t.departmentId\\nwhere Ranks <= 3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith t as (select *, \\n           dense_rank() over(partition by departmentId\\n                              order by salary desc) as Ranks\\n           from Employee)\\nselect t.name Employee, salary, d.name Department \\nfrom t\\n    join Department d\\n    on d.id = t.departmentId\\nwhere Ranks <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1923443,
                "title": "mssql-with-dense-rank-join-faster-than-99-88",
                "content": "```\\nselect d.name as Department, s.Employee, s.Salary\\nfrom Department d JOIN (\\n    select\\n        name as Employee,\\n        salary as Salary,\\n        departmentId as did,\\n        dense_rank() OVER (PARTITION BY departmentId ORDER BY salary DESC) as Rank\\n    from employee\\n) s\\nON d.id = s.did and Rank BETWEEN 1 AND 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.name as Department, s.Employee, s.Salary\\nfrom Department d JOIN (\\n    select\\n        name as Employee,\\n        salary as Salary,\\n        departmentId as did,\\n        dense_rank() OVER (PARTITION BY departmentId ORDER BY salary DESC) as Rank\\n    from employee\\n) s\\nON d.id = s.did and Rank BETWEEN 1 AND 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861832,
                "title": "cte-dense-rank-function",
                "content": "```\\nwith ranking as(\\nselect emp.name as Employee,\\nd.name as Department,\\nsalary,\\ndense_rank() over(partition by d.name order by emp.salary desc) as salary_rank\\nfrom Employee emp join Department d on emp.departmentId = d.id\\n    ) \\nselect Department,\\nEmployee,\\nsalary as Salary\\nfrom ranking\\nwhere salary_rank between 1 and 3\\n```",
                "solutionTags": [],
                "code": "```\\nwith ranking as(\\nselect emp.name as Employee,\\nd.name as Department,\\nsalary,\\ndense_rank() over(partition by d.name order by emp.salary desc) as salary_rank\\nfrom Employee emp join Department d on emp.departmentId = d.id\\n    ) \\nselect Department,\\nEmployee,\\nsalary as Salary\\nfrom ranking\\nwhere salary_rank between 1 and 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833341,
                "title": "use-two-with",
                "content": "WITH BASE_1 AS (\\n    SELECT E.name, E.salary, E.departmentId, D.name AS department_name\\n    FROM Employee E\\n    LEFT JOIN Department D ON E.departmentId=D.id\\n),\\n\\nBASE_2 AS (\\n    SELECT department_name,name,salary,DENSE_RANK()OVER(PARTITION BY department_name ORDER BY salary DESC) AS ranking\\n    FROM BASE_1\\n)\\n\\nSELECT department_name AS Department, name AS Employee, salary AS Salary\\nFROM BASE_2\\nWHERE ranking <=3",
                "solutionTags": [],
                "code": "WITH BASE_1 AS (\\n    SELECT E.name, E.salary, E.departmentId, D.name AS department_name\\n    FROM Employee E\\n    LEFT JOIN Department D ON E.departmentId=D.id\\n),\\n\\nBASE_2 AS (\\n    SELECT department_name,name,salary,DENSE_RANK()OVER(PARTITION BY department_name ORDER BY salary DESC) AS ranking\\n    FROM BASE_1\\n)\\n\\nSELECT department_name AS Department, name AS Employee, salary AS Salary\\nFROM BASE_2\\nWHERE ranking <=3",
                "codeTag": "Unknown"
            },
            {
                "id": 1826733,
                "title": "solution-with-dense-rank-easy",
                "content": "```\\nselect Department, Employee, Salary from (\\nselect d.name as Department, e.name as Employee,e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rk\\nfrom employee e join department d on\\ne.departmentId = d.id ) a\\nwhere a.rk < 4\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect Department, Employee, Salary from (\\nselect d.name as Department, e.name as Employee,e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rk\\nfrom employee e join department d on\\ne.departmentId = d.id ) a\\nwhere a.rk < 4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799081,
                "title": "oracle-sql-dense-rank-easy-to-understand",
                "content": "```\\nSELECT Department, Employee, Salary\\nFROM (\\nSELECT e.id, e.name AS Employee, e.salary AS Salary, e.departmentid, d.name AS Department, \\nDENSE_RANK() OVER (PARTITION BY e.departmentid ORDER BY e.salary DESC) AS rank\\nFROM Employee e\\nJOIN \\nDepartment d\\nON\\ne.departmentid = d.id)a\\nWHERE\\na.rank <4; \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Department, Employee, Salary\\nFROM (\\nSELECT e.id, e.name AS Employee, e.salary AS Salary, e.departmentid, d.name AS Department, \\nDENSE_RANK() OVER (PARTITION BY e.departmentid ORDER BY e.salary DESC) AS rank\\nFROM Employee e\\nJOIN \\nDepartment d\\nON\\ne.departmentid = d.id)a\\nWHERE\\na.rank <4; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741829,
                "title": "mysql-solution-easy-approach",
                "content": "```\\n  select b.name Department, a.name Employee, a.salary\\nfrom\\n   (select name, departmentId, DENSE_RANK() OVER(partition by departmentId order by salary desc) as rak, salary\\n    from Employee) a join Department b on a.departmentId = b.id\\nwhere rak in (1, 2, 3)\\n```",
                "solutionTags": [],
                "code": "```\\n  select b.name Department, a.name Employee, a.salary\\nfrom\\n   (select name, departmentId, DENSE_RANK() OVER(partition by departmentId order by salary desc) as rak, salary\\n    from Employee) a join Department b on a.departmentId = b.id\\nwhere rak in (1, 2, 3)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672242,
                "title": "dense-rank",
                "content": "```\\nselect\\n    Department,Employee,salary\\nfrom (\\n    select\\n        t2.name as Department,t1.name as Employee,salary,\\n        dense_rank()over(partition by t2.name order by salary desc) as \\'rank\\'\\n    from Employee as t1 join Department as t2 on t1.departmentId = t2.id \\n)t\\nwhere t.rank <=3\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    Department,Employee,salary\\nfrom (\\n    select\\n        t2.name as Department,t1.name as Employee,salary,\\n        dense_rank()over(partition by t2.name order by salary desc) as \\'rank\\'\\n    from Employee as t1 join Department as t2 on t1.departmentId = t2.id \\n)t\\nwhere t.rank <=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1655532,
                "title": "100-memory-efficient-in-mysql",
                "content": "```\\nwith t1 as(\\nselect d.name as Department ,e.name as Employee, salary,dense_rank() over(partition by departmentId order by Salary desc)  as rn\\nfrom Employee as e\\njoin Department as d\\non e.departmentId = d.id\\n)\\n\\nselect Department,Employee,salary from t1\\nwhere rn<=3\\n\\t\\t\\t",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith t1 as(\\nselect d.name as Department ,e.name as Employee, salary,dense_rank() over(partition by departmentId order by Salary desc)  as rn\\nfrom Employee as e\\njoin Department as d\\non e.departmentId = d.id\\n)\\n\\nselect Department,Employee,salary from t1\\nwhere rn<=3\\n\\t\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1631958,
                "title": "faster-than-97-6",
                "content": "select\\n    new.depart as Department,\\n    new.employ as Employee,\\n    new.Salary\\nfrom(\\n    select \\n         d.name as depart,\\n         e.name as employ,\\n         e.Salary,\\n         DENSE_RANK()OVER(partition by e.departmentId ORDER BY e.salary DESC) salary_rank\\n    from Employee as e left join Department as d\\n    on d.id = e.DepartmentId) new\\nwhere salary_rank <= 3;",
                "solutionTags": [],
                "code": "select\\n    new.depart as Department,\\n    new.employ as Employee,\\n    new.Salary\\nfrom(\\n    select \\n         d.name as depart,\\n         e.name as employ,\\n         e.Salary,\\n         DENSE_RANK()OVER(partition by e.departmentId ORDER BY e.salary DESC) salary_rank\\n    from Employee as e left join Department as d\\n    on d.id = e.DepartmentId) new\\nwhere salary_rank <= 3;",
                "codeTag": "Unknown"
            },
            {
                "id": 1598748,
                "title": "dense-rank-3",
                "content": "```\\nselect  d.name as department, sub.name as employee, sub.salary from (\\nselect *, dense_rank() over (partition by departmentId order by salary desc) as \\'s\\' from employee ) sub \\njoin department d on s <=3 and d.id = sub.departmentId\\n```",
                "solutionTags": [],
                "code": "```\\nselect  d.name as department, sub.name as employee, sub.salary from (\\nselect *, dense_rank() over (partition by departmentId order by salary desc) as \\'s\\' from employee ) sub \\njoin department d on s <=3 and d.id = sub.departmentId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522476,
                "title": "use-dense-rank",
                "content": "```\\nSelect t2.Name as \\'Department\\', t1.Name as \\'Employee\\', t1.Salary\\nfrom Employee t1 join Department t2 on t1.DepartmentId = t2.Id\\nwhere (t1.Salary, t1.DepartmentId) in (\\nselect Salary, DepartmentId\\nfrom (select Salary, DepartmentId, dense_rank() over(partition by DepartmentId order by Salary DESC) as \\'Rank\\' \\nfrom Employee) as T\\nwhere T.Rank <= 3\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nSelect t2.Name as \\'Department\\', t1.Name as \\'Employee\\', t1.Salary\\nfrom Employee t1 join Department t2 on t1.DepartmentId = t2.Id\\nwhere (t1.Salary, t1.DepartmentId) in (\\nselect Salary, DepartmentId\\nfrom (select Salary, DepartmentId, dense_rank() over(partition by DepartmentId order by Salary DESC) as \\'Rank\\' \\nfrom Employee) as T\\nwhere T.Rank <= 3\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1509017,
                "title": "mssql-dense-rank",
                "content": "```\\nSELECT Department, Employee, Salary \\nFROM\\n(\\n    SELECT D.Name Department, E.Name Employee, Salary, \\n    DENSE_RANK() OVER (PARTITION BY D.Name ORDER BY Salary DESC) Ranks\\n    FROM Employee E\\n    JOIN Department D ON D.Id = E.DepartmentId\\n) A \\nWHERE A.Ranks < 4\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Department, Employee, Salary \\nFROM\\n(\\n    SELECT D.Name Department, E.Name Employee, Salary, \\n    DENSE_RANK() OVER (PARTITION BY D.Name ORDER BY Salary DESC) Ranks\\n    FROM Employee E\\n    JOIN Department D ON D.Id = E.DepartmentId\\n) A \\nWHERE A.Ranks < 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1495019,
                "title": "simple-solution-with-mysql",
                "content": "```\\nwith t as (\\n    select *, dense_rank() over (partition by DepartmentId order by Salary desc) as r\\n    from Employee\\n), \\nranked as (    \\n    select * from t \\n    where r <= 3\\n)\\nselect d.Name as Department, r.Name as Employee, r.Salary from ranked r\\njoin Department d\\non r.DepartmentId = d.Id\\n```",
                "solutionTags": [],
                "code": "```\\nwith t as (\\n    select *, dense_rank() over (partition by DepartmentId order by Salary desc) as r\\n    from Employee\\n), \\nranked as (    \\n    select * from t \\n    where r <= 3\\n)\\nselect d.Name as Department, r.Name as Employee, r.Salary from ranked r\\njoin Department d\\non r.DepartmentId = d.Id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1465425,
                "title": "using-dense-rank-window-function",
                "content": "WITH Top_Salary AS\\n    (SELECT Name AS Emp_Name,\\n     Salary,\\n     DepartmentId,\\n     DENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS Top_Three\\n    FROM Employee)\\nSELECT \\n    d.Name AS Department, \\n    t.Emp_Name AS Employee, \\n    t.Salary\\nFROM \\n    Top_Salary t JOIN Department d\\nON \\n    t.DepartmentId = d.Id\\nWHERE \\n    t.Top_Three <= 3;",
                "solutionTags": [],
                "code": "WITH Top_Salary AS\\n    (SELECT Name AS Emp_Name,\\n     Salary,\\n     DepartmentId,\\n     DENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS Top_Three\\n    FROM Employee)\\nSELECT \\n    d.Name AS Department, \\n    t.Emp_Name AS Employee, \\n    t.Salary\\nFROM \\n    Top_Salary t JOIN Department d\\nON \\n    t.DepartmentId = d.Id\\nWHERE \\n    t.Top_Three <= 3;",
                "codeTag": "Unknown"
            },
            {
                "id": 1387247,
                "title": "with-simple-corelated-subqueries",
                "content": "```\\nSelect D.Name As \"Department\", E.Name As \"Employee\", E.Salary As \"Salary\" from \\n        (Select e1.Name, e1.Salary, e1.DepartmentId from employee e1\\n         where 3>= (select count(distinct e2.Salary) from employee e2\\n                        where e1.departmentId = e2.departmentId\\n                        AND e1.salary<=e2.salary)\\n        ) E, Department D\\nwhere D.Id = E.DepartmentId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect D.Name As \"Department\", E.Name As \"Employee\", E.Salary As \"Salary\" from \\n        (Select e1.Name, e1.Salary, e1.DepartmentId from employee e1\\n         where 3>= (select count(distinct e2.Salary) from employee e2\\n                        where e1.departmentId = e2.departmentId\\n                        AND e1.salary<=e2.salary)\\n        ) E, Department D\\nwhere D.Id = E.DepartmentId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342567,
                "title": "using-dense-rank-to-pick-up-the-distinct-top-3-high-earners",
                "content": "SELECT Department, Employee, Salary \\nFROM\\n(SELECT D.Name as Department, E.Name as Employee, E.Salary, (DENSE_rank ( ) over (PARTITION BY E.DepartmentId Order by E.Salary DESC)) as `rank`\\nFROM Employee E left join Department D on E.DepartmentId=D.Id\\nGroup by E.Id) AS View\\nWhere View.Rank <=3\\n",
                "solutionTags": [],
                "code": "SELECT Department, Employee, Salary \\nFROM\\n(SELECT D.Name as Department, E.Name as Employee, E.Salary, (DENSE_rank ( ) over (PARTITION BY E.DepartmentId Order by E.Salary DESC)) as `rank`\\nFROM Employee E left join Department D on E.DepartmentId=D.Id\\nGroup by E.Id) AS View\\nWhere View.Rank <=3\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1342195,
                "title": "sql-group-by-having-solution-nested-query-solution",
                "content": "Solution 1: Group by + Having count distinct\\n```\\nselect d.name as \"Department\",e1.Name as \"Employee\", e1.Salary as \"Salary\"\\nfrom employee e1, employee e2, department d\\nwhere e1.DepartmentId = e2.DepartmentId\\nand e1.Salary <= e2.Salary\\nand e2.DepartmentId = d.Id\\ngroup by d.Name, e1.Name\\nhaving count(distinct(e2.salary)) <= 3;\\n```\\nSolution 2: Nested Query\\n```\\nselect d.Name as \\'Department\\', e1.Name as \\'Employee\\', e1.Salary\\nfrom Employee e1 join Department d on e1.DepartmentId = d.Id\\nwhere 3 > (select count(distinct e2.Salary)\\n           from Employee e2\\n           where e2.Salary > e1.Salary\\n           and e1.DepartmentId = e2.DepartmentId);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect d.name as \"Department\",e1.Name as \"Employee\", e1.Salary as \"Salary\"\\nfrom employee e1, employee e2, department d\\nwhere e1.DepartmentId = e2.DepartmentId\\nand e1.Salary <= e2.Salary\\nand e2.DepartmentId = d.Id\\ngroup by d.Name, e1.Name\\nhaving count(distinct(e2.salary)) <= 3;\\n```\n```\\nselect d.Name as \\'Department\\', e1.Name as \\'Employee\\', e1.Salary\\nfrom Employee e1 join Department d on e1.DepartmentId = d.Id\\nwhere 3 > (select count(distinct e2.Salary)\\n           from Employee e2\\n           where e2.Salary > e1.Salary\\n           and e1.DepartmentId = e2.DepartmentId);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1323927,
                "title": "using-dense-rank",
                "content": "SELECT DEPARTMENT,EMPLOYEE,SALARY \\nFROM \\n(SELECT D.NAME AS DEPARTMENT,E.NAME AS EMPLOYEE,E.SALARY,DENSE_RANK() OVER (PARTITION BY E.DEPARTMENTID ORDER BY E.SALARY DESC) AS DRANK \\nFROM \\nEMPLOYEE E, DEPARTMENT D WHERE D.ID=E.DEPARTMENTID) W \\nWHERE DRANK<4;",
                "solutionTags": [],
                "code": "SELECT DEPARTMENT,EMPLOYEE,SALARY \\nFROM \\n(SELECT D.NAME AS DEPARTMENT,E.NAME AS EMPLOYEE,E.SALARY,DENSE_RANK() OVER (PARTITION BY E.DEPARTMENTID ORDER BY E.SALARY DESC) AS DRANK \\nFROM \\nEMPLOYEE E, DEPARTMENT D WHERE D.ID=E.DEPARTMENTID) W \\nWHERE DRANK<4;",
                "codeTag": "Unknown"
            },
            {
                "id": 1303993,
                "title": "dense-rank-solution-beats-91",
                "content": "```SELECT department, employee, salary\\nFROM(\\nSELECT d.name as department, e.name as employee, salary,\\nDENSE_RANK() OVER (PARTITION BY e.DepartmentId ORDER BY e.salary DESC) as rnk\\nFROM employee e JOIN department d\\nON e.departmentid = d.id) x\\nWHERE rnk < 4\\n```",
                "solutionTags": [],
                "code": "```SELECT department, employee, salary\\nFROM(\\nSELECT d.name as department, e.name as employee, salary,\\nDENSE_RANK() OVER (PARTITION BY e.DepartmentId ORDER BY e.salary DESC) as rnk\\nFROM employee e JOIN department d\\nON e.departmentid = d.id) x\\nWHERE rnk < 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286411,
                "title": "faster-than-99-66-using-dense-rank",
                "content": "```\\nselect department,employee,salary from\\n(select d.name as department, e.name as employee, e.salary, \\n        dense_rank() over(partition by e.departmentid order by e.salary desc) as ranking\\nfrom employee e left join department d\\non e.departmentid = d.id) raw\\nwhere ranking <=3\\norder by department, ranking\\n```",
                "solutionTags": [],
                "code": "```\\nselect department,employee,salary from\\n(select d.name as department, e.name as employee, e.salary, \\n        dense_rank() over(partition by e.departmentid order by e.salary desc) as ranking\\nfrom employee e left join department d\\non e.departmentid = d.id) raw\\nwhere ranking <=3\\norder by department, ranking\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1243626,
                "title": "clear-dense-rank-solution-beating-98-14",
                "content": "```\\nwith r1 as (\\nselect name, departmentid, salary, dense_rank() over(partition by departmentid order by salary desc) as sal_rank \\nfrom employee\\n)\\nselect d.name as department,r1.name as employee, r1.salary\\nfrom r1 \\n  join department d\\n    on r1.departmentid = d.id\\n   and sal_rank<=3\\norder by 1,3 desc   \\n\\n```",
                "solutionTags": [],
                "code": "```\\nwith r1 as (\\nselect name, departmentid, salary, dense_rank() over(partition by departmentid order by salary desc) as sal_rank \\nfrom employee\\n)\\nselect d.name as department,r1.name as employee, r1.salary\\nfrom r1 \\n  join department d\\n    on r1.departmentid = d.id\\n   and sal_rank<=3\\norder by 1,3 desc   \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235220,
                "title": "mysql-solution-faster-than-83-17-0b-memory",
                "content": "select\\nd.name as department,\\nr.name as employee,\\nr.salary as salary\\nfrom\\n(select\\ne.id,\\ne.name,\\ne.salary,\\ne.departmentid,\\ndense_rank()over(partition by e.departmentid order by e.salary desc) as rk\\nfrom employee as e) as r\\ninner join department as d\\non r.departmentid = d.id\\nwhere r.rk<=3;",
                "solutionTags": [],
                "code": "select\\nd.name as department,\\nr.name as employee,\\nr.salary as salary\\nfrom\\n(select\\ne.id,\\ne.name,\\ne.salary,\\ne.departmentid,\\ndense_rank()over(partition by e.departmentid order by e.salary desc) as rk\\nfrom employee as e) as r\\ninner join department as d\\non r.departmentid = d.id\\nwhere r.rk<=3;",
                "codeTag": "Unknown"
            },
            {
                "id": 1213432,
                "title": "using-dense-rank",
                "content": "****\\n```select d.Name as Department , r1.Name as Employee, r1.Salary as Salary from \\n(\\nselect Name, DepartmentId, Salary,\\nDense_rank() over (PARTITION by DepartmentId \\n                   order by Salary desc) as Rank_Sal\\nfrom Employee) r1\\ninner join \\nDepartment d\\non d.Id = r1.DepartmentId\\nwhere Rank_Sal IN (1,2,3)```",
                "solutionTags": [],
                "code": "```select d.Name as Department , r1.Name as Employee, r1.Salary as Salary from \\n(\\nselect Name, DepartmentId, Salary,\\nDense_rank() over (PARTITION by DepartmentId \\n                   order by Salary desc) as Rank_Sal\\nfrom Employee) r1\\ninner join \\nDepartment d\\non d.Id = r1.DepartmentId\\nwhere Rank_Sal IN (1,2,3)```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158594,
                "title": "mysql-easy-solution-using-dense-rank",
                "content": "```\\nSELECT\\n    Department,\\n    Employee,\\n    Salary\\nFROM (\\n    SELECT\\n        d.Name AS Department,\\n        e.Name AS Employee,\\n        e.Salary,\\n        DENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS SalaryRnk\\n    FROM Employee e\\n    JOIN Department d\\n        ON e.DepartmentId = d.Id) a\\n    WHERE SalaryRnk < 4\\n\\t```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    Department,\\n    Employee,\\n    Salary\\nFROM (\\n    SELECT\\n        d.Name AS Department,\\n        e.Name AS Employee,\\n        e.Salary,\\n        DENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS SalaryRnk\\n    FROM Employee e\\n    JOIN Department d\\n        ON e.DepartmentId = d.Id) a\\n    WHERE SalaryRnk < 4\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1107141,
                "title": "92-68-faster-using-dense-rank-partiton-by-order-by",
                "content": "```\\nselect d.name Department, Employee, Salary from (\\n    select name as Employee, salary, DepartmentId, dense_rank() over(PARTITION BY DepartmentId order by Salary desc) d_rank from Employee\\n) as e\\njoin Department as d on e.DepartmentId = d.Id\\nwhere e.d_rank < 4;\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.name Department, Employee, Salary from (\\n    select name as Employee, salary, DepartmentId, dense_rank() over(PARTITION BY DepartmentId order by Salary desc) d_rank from Employee\\n) as e\\njoin Department as d on e.DepartmentId = d.Id\\nwhere e.d_rank < 4;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067359,
                "title": "mysql-use-dense-rank-and-partition-by-easy-to-understand",
                "content": "select d.Name as Department, t1.Name as Employee, t1.Salary\\nfrom\\n(select Id, Name, Salary, DepartmentId, DENSE_RANK() over (partition by DepartmentId order by Salary desc) as rank1\\nfrom Employee\\norder by Id) t1 join Department d\\non t1.DepartmentId = d.Id\\nwhere t1.rank1=1 or t1.rank1=2 or t1.rank1=3",
                "solutionTags": [],
                "code": "select d.Name as Department, t1.Name as Employee, t1.Salary\\nfrom\\n(select Id, Name, Salary, DepartmentId, DENSE_RANK() over (partition by DepartmentId order by Salary desc) as rank1\\nfrom Employee\\norder by Id) t1 join Department d\\non t1.DepartmentId = d.Id\\nwhere t1.rank1=1 or t1.rank1=2 or t1.rank1=3",
                "codeTag": "Unknown"
            },
            {
                "id": 1023867,
                "title": "clear-solution",
                "content": "```\\nWITH tab1 AS (SELECT d.Name AS Department, \\n                e.name AS Employee,\\n                e.Salary\\n            FROM Department as d\\n            JOIN Employee as e\\n                on e.DepartmentId = d.Id)\\n\\n\\nSELECT tab2.Department, tab2.Employee, tab2.Salary\\nFROM (SELECT Department, Employee, Salary, \\n            DENSE_RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS DRANK\\n            FROM tab1) AS tab2\\nWHERE tab2.DRANK < 4\\n```\\n\\nI was trying to use two WITH:\\n\\n```\\nWITH tab1 AS (SELECT d.Department, \\n                e.name AS Employee,\\n                e.Salary\\n            FROM Department as d\\n            JOIN Employee as e\\n                on e.DepartmentId = d.Id)\\n\\nWITH tab2 AS (SELECT *, \\n            DENSE_RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS DRANK\\n            FROM tab1)\\n\\n\\nSELECT Department, Employee, Salary\\nFROM tab2\\nWHERE DRANK <= 3\\n```\\nBut this has an error, do not know why...",
                "solutionTags": [],
                "code": "```\\nWITH tab1 AS (SELECT d.Name AS Department, \\n                e.name AS Employee,\\n                e.Salary\\n            FROM Department as d\\n            JOIN Employee as e\\n                on e.DepartmentId = d.Id)\\n\\n\\nSELECT tab2.Department, tab2.Employee, tab2.Salary\\nFROM (SELECT Department, Employee, Salary, \\n            DENSE_RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS DRANK\\n            FROM tab1) AS tab2\\nWHERE tab2.DRANK < 4\\n```\n```\\nWITH tab1 AS (SELECT d.Department, \\n                e.name AS Employee,\\n                e.Salary\\n            FROM Department as d\\n            JOIN Employee as e\\n                on e.DepartmentId = d.Id)\\n\\nWITH tab2 AS (SELECT *, \\n            DENSE_RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS DRANK\\n            FROM tab1)\\n\\n\\nSELECT Department, Employee, Salary\\nFROM tab2\\nWHERE DRANK <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995771,
                "title": "ms-sql-simple-solution-using-dense-rank",
                "content": "```\\nselect t.Department, t.Employee, t.Salary\\nfrom\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\n    DENSE_RANK() OVER (partition by d.Name\\n        order BY e.Salary DESC) rank\\nfrom Employee e, Department d\\nwhere e. DepartmentId = d.Id) t\\nwhere rank <4;\\n```",
                "solutionTags": [],
                "code": "```\\nselect t.Department, t.Employee, t.Salary\\nfrom\\n(select d.Name as Department, e.Name as Employee, e.Salary as Salary, \\n    DENSE_RANK() OVER (partition by d.Name\\n        order BY e.Salary DESC) rank\\nfrom Employee e, Department d\\nwhere e. DepartmentId = d.Id) t\\nwhere rank <4;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 985078,
                "title": "simple-mysql-solution-using-dense-rank",
                "content": "select department,employee,salary\\nfrom \\n(select d.name as department,e.name as employee,e.salary,\\n\\tdense_rank() over(partition by departmentid order by salary desc)rm from employee e join department d on e.departmentid=d.id)a\\nwhere rm <4",
                "solutionTags": [],
                "code": "select department,employee,salary\\nfrom \\n(select d.name as department,e.name as employee,e.salary,\\n\\tdense_rank() over(partition by departmentid order by salary desc)rm from employee e join department d on e.departmentid=d.id)a\\nwhere rm <4",
                "codeTag": "Unknown"
            },
            {
                "id": 966144,
                "title": "cte-and-dense-rank",
                "content": "\\twith Salaries (RankOfSalary, Salary, Department, Employee)\\n\\tas\\n\\t(\\n\\t\\tselect dense_rank() over (partition by departmentID order by salary desc), \\n\\t\\tsalary, d.[Name], e.Name\\n\\t\\tfrom Employee e\\n\\t\\tjoin department d on e.DepartmentID = d.ID\\n\\t)\\n\\n\\tselect Department, Employee, Salary\\n\\tfrom Salaries\\n\\twhere RankOfSalary <= 3",
                "solutionTags": [],
                "code": "\\twith Salaries (RankOfSalary, Salary, Department, Employee)\\n\\tas\\n\\t(\\n\\t\\tselect dense_rank() over (partition by departmentID order by salary desc), \\n\\t\\tsalary, d.[Name], e.Name\\n\\t\\tfrom Employee e\\n\\t\\tjoin department d on e.DepartmentID = d.ID\\n\\t)\\n\\n\\tselect Department, Employee, Salary\\n\\tfrom Salaries\\n\\twhere RankOfSalary <= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 945007,
                "title": "video-explanation",
                "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/OsMuAspJAkc](https://youtu.be/OsMuAspJAkc)\\n\\nHere\\u2019s the code I\\u2019m going through for this problem:\\n\\n```\\nSELECT Department.Name AS \"Department\", e.Name AS \"Employee\", e.Salary FROM\\n(SELECT DepartmentId, Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS r\\nFROM Employee) e\\nJOIN Department ON e.DepartmentId = Department.Id\\nWHERE r <= 3\\n```\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Department.Name AS \"Department\", e.Name AS \"Employee\", e.Salary FROM\\n(SELECT DepartmentId, Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS r\\nFROM Employee) e\\nJOIN Department ON e.DepartmentId = Department.Id\\nWHERE r <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878504,
                "title": "faster-than-99-no-join",
                "content": "```\\nselect \\n\\tdName Department, \\n\\teName Employee, \\n\\teSalary Salary \\nfrom \\n\\t(select \\n\\t\\td.Name dName, \\n\\t\\te.Name eName, \\n\\t\\te.Salary eSalary, \\n\\t\\tDENSE_RANK() OVER(\\n\\t\\t\\tpartition by e.DepartmentId\\n\\t\\t\\torder by e.Salary desc\\n\\t\\t) salaryRank\\n\\t\\tfrom \\n\\t\\t\\tEmployee e, \\n\\t\\t\\tDepartment d \\n\\t\\twhere d.Id = e.DepartmentId\\n\\t) sub\\nwhere salaryRank < 4;\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n\\tdName Department, \\n\\teName Employee, \\n\\teSalary Salary \\nfrom \\n\\t(select \\n\\t\\td.Name dName, \\n\\t\\te.Name eName, \\n\\t\\te.Salary eSalary, \\n\\t\\tDENSE_RANK() OVER(\\n\\t\\t\\tpartition by e.DepartmentId\\n\\t\\t\\torder by e.Salary desc\\n\\t\\t) salaryRank\\n\\t\\tfrom \\n\\t\\t\\tEmployee e, \\n\\t\\t\\tDepartment d \\n\\t\\twhere d.Id = e.DepartmentId\\n\\t) sub\\nwhere salaryRank < 4;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876725,
                "title": "easy-way-using-dense-rank",
                "content": "SELECT Department,Employee, Salary FROM \\n(\\nSELECT e.Name AS Employee, e.Salary,d.Name AS Department ,DENSE_RANK() over(PARTITION BY e.DepartmentId ORDER BY e.Salary desc) RANK \\nFROM Employee e\\nINNER JOIN \\nDepartment d \\nON e.DepartmentId=d.Id)\\nWHERE RANK<=3;",
                "solutionTags": [],
                "code": "SELECT Department,Employee, Salary FROM \\n(\\nSELECT e.Name AS Employee, e.Salary,d.Name AS Department ,DENSE_RANK() over(PARTITION BY e.DepartmentId ORDER BY e.Salary desc) RANK \\nFROM Employee e\\nINNER JOIN \\nDepartment d \\nON e.DepartmentId=d.Id)\\nWHERE RANK<=3;",
                "codeTag": "Unknown"
            },
            {
                "id": 860399,
                "title": "solution-using-window-function",
                "content": "select Department,employee,salary from  (\\nselect b.name as Department,a.name as employee ,a.Salary,dense_rank() Over(partition by a.departmentid order by salary desc) as rnk from employee a join department b on a.departmentid=b.id ) st where \\nrnk= 1 or rnk=2 or rnk = 3",
                "solutionTags": [],
                "code": "select Department,employee,salary from  (\\nselect b.name as Department,a.name as employee ,a.Salary,dense_rank() Over(partition by a.departmentid order by salary desc) as rnk from employee a join department b on a.departmentid=b.id ) st where \\nrnk= 1 or rnk=2 or rnk = 3",
                "codeTag": "Unknown"
            },
            {
                "id": 837347,
                "title": "easy-solution-with-partition",
                "content": "**Every easy solution with Dense_rank() and partition**\\n\\n```\\nselect \\nd.name as Department, \\ntmp.name as Employee, \\nsalary \\nfrom\\n    (\\n        select \\n        name, \\n        salary, \\n        DepartmentId, \\n        dense_rank() over (partition by DepartmentId order by salary desc) rn \\n        from Employee\\n    ) tmp\\njoin Department d on tmp.DepartmentId = d.id\\nwhere rn <= 3\\n```\\n\\n===========================================================================================\\n**Logic walk thro**\\n\\n\\nFirstly, use dense_rank() and partition to get rank of top 3 salaries for each department from `Employee` table\\n```\\n(select \\n        name, \\n        salary, \\n        DepartmentId, \\n        dense_rank() over (partition by DepartmentId order by salary desc) rn \\n from Employee) as tmp\\n...\\nwhere rn <= 3\\n\\n```\\n\\nSecondly, in outter query, join with `Department` table to get department_name.\\n```\\nselect \\nd.name as Department, \\ntmp.name as Employee, \\nsalary \\nfrom (...) tmp\\njoin Department d on tmp.DepartmentId = d.id\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\nd.name as Department, \\ntmp.name as Employee, \\nsalary \\nfrom\\n    (\\n        select \\n        name, \\n        salary, \\n        DepartmentId, \\n        dense_rank() over (partition by DepartmentId order by salary desc) rn \\n        from Employee\\n    ) tmp\\njoin Department d on tmp.DepartmentId = d.id\\nwhere rn <= 3\\n```\n```\\n(select \\n        name, \\n        salary, \\n        DepartmentId, \\n        dense_rank() over (partition by DepartmentId order by salary desc) rn \\n from Employee) as tmp\\n...\\nwhere rn <= 3\\n\\n```\n```\\nselect \\nd.name as Department, \\ntmp.name as Employee, \\nsalary \\nfrom (...) tmp\\njoin Department d on tmp.DepartmentId = d.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 834802,
                "title": "using-partition-by-order-by",
                "content": "```\\nwith t as (\\n    select *, dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) rk\\n    from Employee\\n)\\nselect d.Name \\'Department\\', t.Name \\'Employee\\', Salary\\nfrom t join Department d on DepartmentId = d.Id\\nwhere t.rk <= 3\\n```\\nuse partition and dense_rank to generate a rank table t, which contains seperate rank for different departments.",
                "solutionTags": [],
                "code": "```\\nwith t as (\\n    select *, dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) rk\\n    from Employee\\n)\\nselect d.Name \\'Department\\', t.Name \\'Employee\\', Salary\\nfrom t join Department d on DepartmentId = d.Id\\nwhere t.rk <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823387,
                "title": "mysql-faster-than-98-51-725ms",
                "content": "```\\nselect d.Name as `Department`, e.Name as `Employee`, e.Salary as `Salary`\\nfrom Employee as e inner join Department as d on e.DepartmentId=d.Id \\nwhere e.Salary in (\\n    select * from (\\n        select distinct(e1.Salary)\\n        from Employee e1\\n        where e1.DepartmentId=d.Id \\n        order by e1.Salary desc\\n        limit 3\\n    ) as _\\n)\\ngroup by d.Name, e.Name\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.Name as `Department`, e.Name as `Employee`, e.Salary as `Salary`\\nfrom Employee as e inner join Department as d on e.DepartmentId=d.Id \\nwhere e.Salary in (\\n    select * from (\\n        select distinct(e1.Salary)\\n        from Employee e1\\n        where e1.DepartmentId=d.Id \\n        order by e1.Salary desc\\n        limit 3\\n    ) as _\\n)\\ngroup by d.Name, e.Name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801389,
                "title": "faster-than-90-simple-ranking-using-dense-rank",
                "content": "```\\nselect name as \"Employee\", salary, dname as \"Department\"\\nfrom\\n    (\\n    select e.id,e.name, e.salary , d.name as dname,\\n    dense_rank() over(partition by departmentid order by salary desc) as rnk\\n    from Employee e join department d\\n    on e.departmentid = d.id\\n    ) a\\nwhere a.rnk <=3 \\norder by dname asc, salary desc\\n```",
                "solutionTags": [],
                "code": "```\\nselect name as \"Employee\", salary, dname as \"Department\"\\nfrom\\n    (\\n    select e.id,e.name, e.salary , d.name as dname,\\n    dense_rank() over(partition by departmentid order by salary desc) as rnk\\n    from Employee e join department d\\n    on e.departmentid = d.id\\n    ) a\\nwhere a.rnk <=3 \\norder by dname asc, salary desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765780,
                "title": "simple-solution-using-dense-rank",
                "content": "```\\nselect\\n    a.Department\\n    , a.Employee\\n    , a.Salary\\nfrom\\n    (\\n    select\\n        e.DepartmentId\\n        , d.Name as \\'Department\\'\\n        , e.Name as \\'Employee\\'\\n        , e.Salary\\n        , Dense_Rank() over (partition by e.DepartmentId order by e.Salary desc) as \\'ranking\\'\\n    from\\n        Employee e\\n        join Department d\\n        on e.DepartmentId = d.Id\\n    ) a \\nwhere\\n    a.ranking <=3\\norder by\\n    Department\\n    , Salary DESC\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    a.Department\\n    , a.Employee\\n    , a.Salary\\nfrom\\n    (\\n    select\\n        e.DepartmentId\\n        , d.Name as \\'Department\\'\\n        , e.Name as \\'Employee\\'\\n        , e.Salary\\n        , Dense_Rank() over (partition by e.DepartmentId order by e.Salary desc) as \\'ranking\\'\\n    from\\n        Employee e\\n        join Department d\\n        on e.DepartmentId = d.Id\\n    ) a \\nwhere\\n    a.ranking <=3\\norder by\\n    Department\\n    , Salary DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764144,
                "title": "simple-solution-faster-than-93-30",
                "content": "```\\nSELECT d.Name AS Department, e.Name AS Employee, e.Salary\\nFROM \\n(SELECT DepartmentId, Name, Salary, dense_rank() OVER (PARTITION BY DepartmentId ORDER BY Salary DESC) AS rank\\nFROM Employee) e, Department d\\nWHERE e.DepartmentId=d.Id AND e.rank<=3\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT d.Name AS Department, e.Name AS Employee, e.Salary\\nFROM \\n(SELECT DepartmentId, Name, Salary, dense_rank() OVER (PARTITION BY DepartmentId ORDER BY Salary DESC) AS rank\\nFROM Employee) e, Department d\\nWHERE e.DepartmentId=d.Id AND e.rank<=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751908,
                "title": "mssql-using-cte-and-dense-rank-to-find-out-solution",
                "content": "using CTE find the salary ranking for each employee and then select the requirement  \\n```sql\\n;with PartitionRanking as (\\nselect b.Name as Department\\n      ,a.Name\\n\\t  ,a.Salary\\n\\t  ,DENSE_RANK() over(partition by b.id order by a.salary desc) as ranking   \\nfrom Employee as a\\ninner join Department as b\\non a.DepartmentId=b.Id\\n)\\n\\nselect i.Department as Department\\n      ,i.Name as Employee\\n\\t  ,i.Salary as Salary\\nfrom PartitionRanking as i\\nwhere i.ranking between 1 and 3 \\n```\\n",
                "solutionTags": [],
                "code": "```sql\\n;with PartitionRanking as (\\nselect b.Name as Department\\n      ,a.Name\\n\\t  ,a.Salary\\n\\t  ,DENSE_RANK() over(partition by b.id order by a.salary desc) as ranking   \\nfrom Employee as a\\ninner join Department as b\\non a.DepartmentId=b.Id\\n)\\n\\nselect i.Department as Department\\n      ,i.Name as Employee\\n\\t  ,i.Salary as Salary\\nfrom PartitionRanking as i\\nwhere i.ranking between 1 and 3 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751023,
                "title": "oracle-solution",
                "content": "```\\nSELECT temp.department AS Department,\\n       temp.employee AS Employee,\\n       temp.salary AS Salary\\nFROM (\\n    SELECT e.name AS employee, \\n           e.salary AS salary, \\n           d.name AS department,\\n           DENSE_RANK() OVER (PARTITION BY e.departmentid ORDER BY e.salary DESC) AS rank\\n    FROM Employee e \\n    JOIN Department d\\n    ON e.departmentid = d.id\\n) temp\\nWHERE temp.rank <= 3;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT temp.department AS Department,\\n       temp.employee AS Employee,\\n       temp.salary AS Salary\\nFROM (\\n    SELECT e.name AS employee, \\n           e.salary AS salary, \\n           d.name AS department,\\n           DENSE_RANK() OVER (PARTITION BY e.departmentid ORDER BY e.salary DESC) AS rank\\n    FROM Employee e \\n    JOIN Department d\\n    ON e.departmentid = d.id\\n) temp\\nWHERE temp.rank <= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750208,
                "title": "sql-server-simple-query-using-dense-rank",
                "content": "```\\nselect Department,Employee, salary from (\\nselect d.Name as Department, e.name as Employee,e.salary,\\n       dense_rank() over (partition by d.id order by salary desc) as RANK\\nfrom  employee e, department d\\nwhere e.departmentId = d.id\\n) t\\nwhere t.RANK <= 3",
                "solutionTags": [],
                "code": "```\\nselect Department,Employee, salary from (\\nselect d.Name as Department, e.name as Employee,e.salary,\\n       dense_rank() over (partition by d.id order by salary desc) as RANK\\nfrom  employee e, department d\\nwhere e.departmentId = d.id\\n) t\\nwhere t.RANK <= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 743035,
                "title": "simple-cte-with-dense-rank-in-mssql",
                "content": "```\\n;WITH CTE_TopThreeByDepartment AS\\n(   \\n    SELECT D.Name AS Department,\\n        E.Name AS Employee,\\n        E.Salary,\\n        DENSE_RANK() OVER (PARTITION BY D.Name ORDER BY Salary DESC) AS RowNum\\n    FROM Employee E\\n    JOIN DEpartment D\\n        ON E.DepartmentId=D.Id    \\n )\\nSELECT Department,Employee,Salary\\nFROM CTE_TopThreeByDepartment\\nWHERE RowNum <=3\\n```",
                "solutionTags": [],
                "code": "```\\n;WITH CTE_TopThreeByDepartment AS\\n(   \\n    SELECT D.Name AS Department,\\n        E.Name AS Employee,\\n        E.Salary,\\n        DENSE_RANK() OVER (PARTITION BY D.Name ORDER BY Salary DESC) AS RowNum\\n    FROM Employee E\\n    JOIN DEpartment D\\n        ON E.DepartmentId=D.Id    \\n )\\nSELECT Department,Employee,Salary\\nFROM CTE_TopThreeByDepartment\\nWHERE RowNum <=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689220,
                "title": "window-function-not-working",
                "content": "```\\nselect b.name, a.Name as Employee, a.Salary from\\n(select Name, Salary, DepartmentId, dense_rank() over(partition by DepartmentId order by Salary desc) ranker from employee) a\\njoin department b on a.DepartmentId = b.Id\\nwhere ranker between 1 and 3;\\n```\\n\\nHey Guys why is this not a correct solution?",
                "solutionTags": [],
                "code": "```\\nselect b.name, a.Name as Employee, a.Salary from\\n(select Name, Salary, DepartmentId, dense_rank() over(partition by DepartmentId order by Salary desc) ranker from employee) a\\njoin department b on a.DepartmentId = b.Id\\nwhere ranker between 1 and 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 679903,
                "title": "clean-and-scalable-mysql-solution",
                "content": "Select Department\\n      ,Employee\\n      ,Salary\\nFrom (\\n        Select   B.Name As Department\\n                ,A.Name As Employee\\n                ,A.Salary\\n                ,Dense_Rank() Over(Partition By A.DepartmentId Order By Salary Desc) As Salary_Order\\n        From Employee As A\\n        Inner Join Department As B On A.DepartmentId = B.Id\\n    ) As C\\nWhere Salary_Order <= 3;",
                "solutionTags": [],
                "code": "Select Department\\n      ,Employee\\n      ,Salary\\nFrom (\\n        Select   B.Name As Department\\n                ,A.Name As Employee\\n                ,A.Salary\\n                ,Dense_Rank() Over(Partition By A.DepartmentId Order By Salary Desc) As Salary_Order\\n        From Employee As A\\n        Inner Join Department As B On A.DepartmentId = B.Id\\n    ) As C\\nWhere Salary_Order <= 3;",
                "codeTag": "Unknown"
            },
            {
                "id": 638143,
                "title": "mssql-dense-rank",
                "content": "select d.name as Department,e.name as Employee,Salary\\nfrom\\n(select DepartmentId,name,salary,dense_rank() over (partition by DepartmentId order by salary desc) as holder\\n from employee) e\\n join department d on DepartmentId=d.id\\nwhere holder<=3\\n\\n",
                "solutionTags": [],
                "code": "select d.name as Department,e.name as Employee,Salary\\nfrom\\n(select DepartmentId,name,salary,dense_rank() over (partition by DepartmentId order by salary desc) as holder\\n from employee) e\\n join department d on DepartmentId=d.id\\nwhere holder<=3\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 626757,
                "title": "using-dense-rank-and-partition-by-mysql",
                "content": "```sql\\nselect d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary from \\n(\\n\\tselect Id, Name, Salary, DepartmentId, DENSE_RANK() over (\\n\\t\\tpartition by DepartmentId \\n\\t\\torder by Salary desc \\n\\t) my_rank from \\nEmployee\\n) e\\ninner join Department d on d.Id = e.DepartmentId\\nwhere e.my_rank < 4\\norder by e.Salary desc;\\n```",
                "solutionTags": [],
                "code": "```sql\\nselect d.Name as \\'Department\\', e.Name as \\'Employee\\', e.Salary from \\n(\\n\\tselect Id, Name, Salary, DepartmentId, DENSE_RANK() over (\\n\\t\\tpartition by DepartmentId \\n\\t\\torder by Salary desc \\n\\t) my_rank from \\nEmployee\\n) e\\ninner join Department d on d.Id = e.DepartmentId\\nwhere e.my_rank < 4\\norder by e.Salary desc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618909,
                "title": "70-faster-using-window-function",
                "content": "```\\n\\nselect t.department, t.employee, t.salary from \\n(select department.name department, employee.name employee, salary, dense_rank() over( partition by departmentid order by salary desc) as rnk\\nfrom employee join department on departmentid=department.id) t where t.rnk <=3;\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect t.department, t.employee, t.salary from \\n(select department.name department, employee.name employee, salary, dense_rank() over( partition by departmentid order by salary desc) as rnk\\nfrom employee join department on departmentid=department.id) t where t.rnk <=3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 603295,
                "title": "mysql-solution-faster-than-86-52",
                "content": "```\\nselect Department, Employee, Salary\\nfrom\\n(select c.Name as Department, a.Name as Employee, a.Salary,\\n    (select count(distinct b.Salary)\\n    from Employee b\\n    where b.Salary >= a.Salary and a.DepartmentId = b.DepartmentId) as rank\\nfrom Employee a\\ninner join Department c\\non a.DepartmentId = c.Id) temp_Table\\nwhere rank <= 3\\norder by Department, rank;\\n```",
                "solutionTags": [],
                "code": "```\\nselect Department, Employee, Salary\\nfrom\\n(select c.Name as Department, a.Name as Employee, a.Salary,\\n    (select count(distinct b.Salary)\\n    from Employee b\\n    where b.Salary >= a.Salary and a.DepartmentId = b.DepartmentId) as rank\\nfrom Employee a\\ninner join Department c\\non a.DepartmentId = c.Id) temp_Table\\nwhere rank <= 3\\norder by Department, rank;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 581556,
                "title": "mysql-use-join-solution",
                "content": "```\\nSELECT c.Name Department, a.Name Employee, a.Salary\\nFROM Employee a\\nLEFT JOIN Employee b ON a.DepartmentId = b.DepartmentId AND a.Salary < b.Salary\\nINNER JOIN Department c ON a.DepartmentId = c.Id\\nGROUP BY a.Id\\nHAVING COUNT(DISTINCT b.Salary) + 1 <= 3\\n```\\n\\nRuntime: 503 ms, faster than 92.07% of MySQL online submissions for Department Top Three Salaries.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Department Top Three Salaries.",
                "solutionTags": [],
                "code": "```\\nSELECT c.Name Department, a.Name Employee, a.Salary\\nFROM Employee a\\nLEFT JOIN Employee b ON a.DepartmentId = b.DepartmentId AND a.Salary < b.Salary\\nINNER JOIN Department c ON a.DepartmentId = c.Id\\nGROUP BY a.Id\\nHAVING COUNT(DISTINCT b.Salary) + 1 <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 522179,
                "title": "oracle-pl-sql-solution",
                "content": "```\\nSELECT details.Department \"Department\", details.Employee \"Employee\", details.Salary \"Salary\" FROM\\n(SELECT e.Name AS Employee, e.Salary AS Salary, e.DepartmentId, d.Name AS Department, DENSE_RANK() OVER (PARTITION BY e.DepartmentId ORDER BY e.Salary DESC) AS dense_rank\\nFROM Employee e, Department d\\nWHERE e.DepartmentId = d.Id) details\\nWHERE dense_rank <=3;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT details.Department \"Department\", details.Employee \"Employee\", details.Salary \"Salary\" FROM\\n(SELECT e.Name AS Employee, e.Salary AS Salary, e.DepartmentId, d.Name AS Department, DENSE_RANK() OVER (PARTITION BY e.DepartmentId ORDER BY e.Salary DESC) AS dense_rank\\nFROM Employee e, Department d\\nWHERE e.DepartmentId = d.Id) details\\nWHERE dense_rank <=3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520536,
                "title": "ms-sql-using-dense-rank-faster-than-80-88",
                "content": "```\\nSELECT  Department,\\n        Employee,\\n        Salary\\n        FROM\\n(   \\nSELECT \\n       E.Name \\'Employee\\',\\n       E.Salary \\'Salary\\',\\n       D.Name AS \\'Department\\',\\n       DENSE_RANK() OVER (PARTITION BY E.DepartmentId ORDER BY E.Salary DESC) AS Rank\\n FROM Employee E\\n   INNER JOIN Department D on D.Id = E.DepartmentId\\n) T\\nWHERE T.Rank <= 3 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT  Department,\\n        Employee,\\n        Salary\\n        FROM\\n(   \\nSELECT \\n       E.Name \\'Employee\\',\\n       E.Salary \\'Salary\\',\\n       D.Name AS \\'Department\\',\\n       DENSE_RANK() OVER (PARTITION BY E.DepartmentId ORDER BY E.Salary DESC) AS Rank\\n FROM Employee E\\n   INNER JOIN Department D on D.Id = E.DepartmentId\\n) T\\nWHERE T.Rank <= 3 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506769,
                "title": "mysql-using-self-join-and-having",
                "content": "```\\nSELECT d.Name AS Department,\\n       e1.Name AS Employee,\\n       e1.Salary AS Salary\\nFROM employee e1\\nLEFT JOIN department d\\n  ON e1.DepartmentId = d.Id\\nJOIN employee e2\\n  ON e1.DepartmentId = e2.DepartmentId\\n  AND e1.Salary <= e2.Salary\\n\\nWHERE d.Name is not null\\nGROUP BY e1.Name, \\n         e1.Salary,\\n         e1.DepartmentId\\nHAVING count(distinct e2.Salary) <= 3\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT d.Name AS Department,\\n       e1.Name AS Employee,\\n       e1.Salary AS Salary\\nFROM employee e1\\nLEFT JOIN department d\\n  ON e1.DepartmentId = d.Id\\nJOIN employee e2\\n  ON e1.DepartmentId = e2.DepartmentId\\n  AND e1.Salary <= e2.Salary\\n\\nWHERE d.Name is not null\\nGROUP BY e1.Name, \\n         e1.Salary,\\n         e1.DepartmentId\\nHAVING count(distinct e2.Salary) <= 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501487,
                "title": "4-solutions-for-the-problem-with-fastest-447-ms-beats-99-02",
                "content": "1. Use dense_rank(). As long as you know this window function, this should be the most straightforward solution. 1332 ms\\n```\\nselect d.Name as Department, t.Name as Employee, t.Salary\\nfrom (select Name, Salary, DepartmentId, dense_rank() over (partition by DepartmentId order by Salary desc) as rank from Employee) t join Department d \\non t.DepartmentId = d.Id\\nwhere t.rank <= 3\\n```\\n\\n2. Mysql version on leetcode doesn\\'t have dense_rank(). But we can emulate dense_rank() by the following. 1186 ms\\n```\\nselect d.Name as Department, t.Name as Employee, t.Salary from\\n(select Name, Salary, DepartmentId, @rank := (\\n    case \\n        when @prev_dpt_id=DepartmentId  then\\n            case \\n                when @salary != Salary then @rank + 1 else @rank \\n            end \\n        else 1 \\n    end) as rank, @prev_dpt_id := DepartmentId, @salary := Salary\\nfrom Employee e1 join (SELECT @prev_dpt_id := 0, @salary := 0, @rank := 0) vars\\norder by DepartmentId, Salary desc) t join Department d on t.DepartmentId = d.Id\\nwhere t.rank <= 3\\n```\\n\\n3. Correlated subquery(a correlated subquery, also known as a synchronized subquery is a subquery that uses values from the outer query), I\\'m copying the highest vote answer by @baiji here. 1412 ms\\n```\\nselect d.Name Department, e1.Name Employee, e1.Salary\\nfrom Employee e1 \\njoin Department d\\non e1.DepartmentId = d.Id\\nwhere 3 > (select count(distinct(e2.Salary)) \\n                  from Employee e2 \\n                  where e2.Salary > e1.Salary \\n                  and e1.DepartmentId = e2.DepartmentId\\n                  );\\n```\\n\\n4. Because the subquery may be evaluated once for each row processed by the outer query, it can be slow. The effect of correlated subqueries can in some cases be obtained using joins(by Wikipedia). 447 ms\\t\\n```\\nselect d.Name as Department, t.Name as Employee, t.Salary\\nfrom (select count(distinct e2.Salary) as cnt, e1.Salary, e1.DepartmentId, e1.Name\\nfrom Employee e1 left join Employee e2 on e2.Salary > e1.Salary and e1.DepartmentId = e2.DepartmentId\\ngroup by e1.Salary, e1.DepartmentId, e1.Name\\nhaving cnt < 3) t join Department d on t.DepartmentId = d.Id\\n```",
                "solutionTags": [],
                "code": "```\\nselect d.Name as Department, t.Name as Employee, t.Salary\\nfrom (select Name, Salary, DepartmentId, dense_rank() over (partition by DepartmentId order by Salary desc) as rank from Employee) t join Department d \\non t.DepartmentId = d.Id\\nwhere t.rank <= 3\\n```\n```\\nselect d.Name as Department, t.Name as Employee, t.Salary from\\n(select Name, Salary, DepartmentId, @rank := (\\n    case \\n        when @prev_dpt_id=DepartmentId  then\\n            case \\n                when @salary != Salary then @rank + 1 else @rank \\n            end \\n        else 1 \\n    end) as rank, @prev_dpt_id := DepartmentId, @salary := Salary\\nfrom Employee e1 join (SELECT @prev_dpt_id := 0, @salary := 0, @rank := 0) vars\\norder by DepartmentId, Salary desc) t join Department d on t.DepartmentId = d.Id\\nwhere t.rank <= 3\\n```\n```\\nselect d.Name Department, e1.Name Employee, e1.Salary\\nfrom Employee e1 \\njoin Department d\\non e1.DepartmentId = d.Id\\nwhere 3 > (select count(distinct(e2.Salary)) \\n                  from Employee e2 \\n                  where e2.Salary > e1.Salary \\n                  and e1.DepartmentId = e2.DepartmentId\\n                  );\\n```\n```\\nselect d.Name as Department, t.Name as Employee, t.Salary\\nfrom (select count(distinct e2.Salary) as cnt, e1.Salary, e1.DepartmentId, e1.Name\\nfrom Employee e1 left join Employee e2 on e2.Salary > e1.Salary and e1.DepartmentId = e2.DepartmentId\\ngroup by e1.Salary, e1.DepartmentId, e1.Name\\nhaving cnt < 3) t join Department d on t.DepartmentId = d.Id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468519,
                "title": "accepted-window-function-dense-rank-difference-between-rank-and-dense-rank-function",
                "content": "RANK function skips the next N-1 ranks if there is a tie between N previous ranks. On the other hand, the DENSE_RANK function does not skip ranks if there is a tie between ranks.\\n\\nfor eg:\\nsalary rank\\n1000    1\\n1000    1\\n800       3\\n\\nDense rank does not skip a rank in case there is a tie.\\n1000   1\\n1000   1\\n800     2\\n\\n\\n\\n```\\nSELECT\\n    Department, Employee, Salary\\nFROM\\n    (SELECT\\n        b.name as Department, a.name as Employee , a.salary as Salary, DENSE_RANK() OVER(PARTITION BY                   a.DepartmentId ORDER BY a.salary desc) as rank_sal\\n    FROM\\n        employee a INNER JOIN Department b on a.DepartmentId = b.id ) \\nWHERE \\n    rank_sal in (1,2,3)\\nORDER BY 1 asc,3 desc\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    Department, Employee, Salary\\nFROM\\n    (SELECT\\n        b.name as Department, a.name as Employee , a.salary as Salary, DENSE_RANK() OVER(PARTITION BY                   a.DepartmentId ORDER BY a.salary desc) as rank_sal\\n    FROM\\n        employee a INNER JOIN Department b on a.DepartmentId = b.id ) \\nWHERE \\n    rank_sal in (1,2,3)\\nORDER BY 1 asc,3 desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442447,
                "title": "easy-mysql-solution",
                "content": "```\\nSELECT \\n    d.Name AS Department, e.Name AS Employee, e.Salary AS Salary\\nFROM\\n    Department AS d,\\n    Employee AS e\\nWHERE\\n    e.DepartmentId = d.Id\\n    AND\\n    (\\n        e.Salary = (\\n                    SELECT Salary \\n                    FROM Employee\\n                    WHERE DepartmentId = d.Id\\n                    GROUP BY Salary\\n                    ORDER BY Salary DESC\\n                    LIMIT 0, 1\\n                   )\\n        OR\\n        e.Salary = (\\n                    SELECT Salary \\n                    FROM Employee\\n                    WHERE DepartmentId = d.Id\\n                    GROUP BY Salary\\n                    ORDER BY Salary DESC\\n                    LIMIT 1, 1\\n                   )\\n        OR\\n        e.Salary = (\\n                    SELECT Salary \\n                    FROM Employee\\n                    WHERE DepartmentId = d.Id\\n                    GROUP BY Salary\\n                    ORDER BY Salary DESC\\n                    LIMIT 2, 1\\n                   )\\n    )\\n\\t```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    d.Name AS Department, e.Name AS Employee, e.Salary AS Salary\\nFROM\\n    Department AS d,\\n    Employee AS e\\nWHERE\\n    e.DepartmentId = d.Id\\n    AND\\n    (\\n        e.Salary = (\\n                    SELECT Salary \\n                    FROM Employee\\n                    WHERE DepartmentId = d.Id\\n                    GROUP BY Salary\\n                    ORDER BY Salary DESC\\n                    LIMIT 0, 1\\n                   )\\n        OR\\n        e.Salary = (\\n                    SELECT Salary \\n                    FROM Employee\\n                    WHERE DepartmentId = d.Id\\n                    GROUP BY Salary\\n                    ORDER BY Salary DESC\\n                    LIMIT 1, 1\\n                   )\\n        OR\\n        e.Salary = (\\n                    SELECT Salary \\n                    FROM Employee\\n                    WHERE DepartmentId = d.Id\\n                    GROUP BY Salary\\n                    ORDER BY Salary DESC\\n                    LIMIT 2, 1\\n                   )\\n    )\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 418886,
                "title": "ms-sql-97-69-window-function",
                "content": "/* Write your T-SQL query statement below */\\n-- dense_Rank() partition by DepartmentId order by Salary, rank <4\\n--join to get department name\\n\\n\\nWith salary_rank as (\\nSELECT \\n    e.Name as Employee,\\n    e.Salary,\\n    d.name as Department,\\n    DENSE_RANK()Over(Partition by e.DepartmentId Order by Salary desc) as rank\\nFROM Employee e Inner join Department d\\nON e.DepartmentId = d.id\\n)\\n\\nSELECT \\n    Department,\\n    Employee,\\n    Salary\\nFROM salary_rank\\nWHERE rank <4\\nOrder by Department, Salary desc",
                "solutionTags": [],
                "code": "/* Write your T-SQL query statement below */\\n-- dense_Rank() partition by DepartmentId order by Salary, rank <4\\n--join to get department name\\n\\n\\nWith salary_rank as (\\nSELECT \\n    e.Name as Employee,\\n    e.Salary,\\n    d.name as Department,\\n    DENSE_RANK()Over(Partition by e.DepartmentId Order by Salary desc) as rank\\nFROM Employee e Inner join Department d\\nON e.DepartmentId = d.id\\n)\\n\\nSELECT \\n    Department,\\n    Employee,\\n    Salary\\nFROM salary_rank\\nWHERE rank <4\\nOrder by Department, Salary desc",
                "codeTag": "Unknown"
            },
            {
                "id": 383256,
                "title": "my-368ms-solution",
                "content": "My method is as below:\\n\\n1. Extract the distinct DepartmentId-Salary Table S and S1 (In fact, they are the same, but I do not know how to omit one of the definition, any suggestions?)\\n2. Find the top three salaries in each department, and put the values into Table T\\n3. Join Table Employee, Department and Table T to get the answer.\\n\\nThe time comsumption is 368ms and beat 98.24% of the submissions.\\n\\n```\\nSELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\nFROM\\n\\tEmployee E,\\n\\t(\\n      SELECT S.DepartmentId, S.Salary\\n      FROM \\n        (\\n          SELECT DISTINCT DepartmentId, Salary\\n          FROM Employee\\n        ) S\\n      WHERE \\n        (\\n        SELECT count(*) \\n        FROM \\n        (\\n          SELECT DISTINCT DepartmentId, Salary\\n          FROM Employee\\n        ) S1\\n        WHERE \\n          S.DepartmentId = S1.DepartmentId AND \\n          S.Salary < S1.Salary\\n        ) < 3\\n    ) T,\\n\\tDepartment D\\nWHERE E.DepartmentId = T.DepartmentId \\n  AND E.Salary = T.Salary\\n  AND E.DepartmentId = D.id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT D.Name AS Department ,E.Name AS Employee ,E.Salary \\nFROM\\n\\tEmployee E,\\n\\t(\\n      SELECT S.DepartmentId, S.Salary\\n      FROM \\n        (\\n          SELECT DISTINCT DepartmentId, Salary\\n          FROM Employee\\n        ) S\\n      WHERE \\n        (\\n        SELECT count(*) \\n        FROM \\n        (\\n          SELECT DISTINCT DepartmentId, Salary\\n          FROM Employee\\n        ) S1\\n        WHERE \\n          S.DepartmentId = S1.DepartmentId AND \\n          S.Salary < S1.Salary\\n        ) < 3\\n    ) T,\\n\\tDepartment D\\nWHERE E.DepartmentId = T.DepartmentId \\n  AND E.Salary = T.Salary\\n  AND E.DepartmentId = D.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 380689,
                "title": "99-66-mysql-solution",
                "content": "```\\nSELECT yy.Name as Department, xx.Name as Employee, xx.Salary as Salary\\nFROM (\\n       SELECT DepartmentId,\\n              Name,\\n              Salary,\\n              IF(@prevDp <> @prevDp := DepartmentId\\n                , IF(@rk := 1 AND @prevSalary := Salary, 1, 1)\\n                , IF(@prevSalary <> @prevSalary := Salary, @rk := @rk + 1, @rk)) AS rk\\n       FROM Employee a,\\n            (SELECT @rk := 0, @prevSalary := 0, @prevDp := -1) init\\n       ORDER BY DepartmentId, salary DESC\\n     ) xx\\n       JOIN Department yy\\n            ON xx.DepartmentId = yy.Id\\n              AND rk <= 3\\nORDER BY xx.DepartmentId, xx.rk\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT yy.Name as Department, xx.Name as Employee, xx.Salary as Salary\\nFROM (\\n       SELECT DepartmentId,\\n              Name,\\n              Salary,\\n              IF(@prevDp <> @prevDp := DepartmentId\\n                , IF(@rk := 1 AND @prevSalary := Salary, 1, 1)\\n                , IF(@prevSalary <> @prevSalary := Salary, @rk := @rk + 1, @rk)) AS rk\\n       FROM Employee a,\\n            (SELECT @rk := 0, @prevSalary := 0, @prevDp := -1) init\\n       ORDER BY DepartmentId, salary DESC\\n     ) xx\\n       JOIN Department yy\\n            ON xx.DepartmentId = yy.Id\\n              AND rk <= 3\\nORDER BY xx.DepartmentId, xx.rk\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374572,
                "title": "2-simple-approches",
                "content": "--Method 1: using a correlated sub query approach\\n```\\nSELECT dept.name AS \\'Department\\', emp.name AS \\'Employee\\', emp.salary as \\'Salary\\'\\nFROM employee emp\\nJOIN Department dept\\nON emp.DepartmentId = dept.id\\nWHERE 3 > (SELECT COUNT(DISTINCT salary) FROM Employee emp2 WHERE emp2.salary>emp.salary AND emp.DepartmentId = emp2.DepartmentId);\\n```\\n--Method 2: Using window functions\\n```\\nSELECT dept.Name as \\'Department\\', sub.name as \\'Employee\\', sub.salary AS \\'Salary\\'\\nFROM (SELECT name, salary, DepartmentId, dense_rank() over(PARTITION BY DepartmentId ORDER BY salary DESC) AS \\'dense_rank\\' FROM employee)\\nAS sub JOIN Department dept ON sub.DepartmentId = dept.Id\\nWHERE sub.dense_rank<=3;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT dept.name AS \\'Department\\', emp.name AS \\'Employee\\', emp.salary as \\'Salary\\'\\nFROM employee emp\\nJOIN Department dept\\nON emp.DepartmentId = dept.id\\nWHERE 3 > (SELECT COUNT(DISTINCT salary) FROM Employee emp2 WHERE emp2.salary>emp.salary AND emp.DepartmentId = emp2.DepartmentId);\\n```\n```\\nSELECT dept.Name as \\'Department\\', sub.name as \\'Employee\\', sub.salary AS \\'Salary\\'\\nFROM (SELECT name, salary, DepartmentId, dense_rank() over(PARTITION BY DepartmentId ORDER BY salary DESC) AS \\'dense_rank\\' FROM employee)\\nAS sub JOIN Department dept ON sub.DepartmentId = dept.Id\\nWHERE sub.dense_rank<=3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336713,
                "title": "department-top-three-salaries-accepted-solution-for-664ms",
                "content": "\\n```\\nSELECT \\n    d.Name as Department, emp.Name as Employee, emp.Salary\\nFROM\\n    (\\n    SELECT \\n        DepartmentId\\n        ,Name\\n        ,Salary\\n        ,(\\n            SELECT \\n                COUNT(DISTINCT Salary) \\n                FROM Employee\\n                WHERE Salary >= e.salary AND DepartmentId = e.DepartmentId\\n            ) as rank\\n    FROM \\n        Employee e\\n        ) emp\\nJOIN Department d ON (emp.DepartmentId = d.Id)\\nWHERE emp.rank <= 3\\nOrder by 1,3 desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    d.Name as Department, emp.Name as Employee, emp.Salary\\nFROM\\n    (\\n    SELECT \\n        DepartmentId\\n        ,Name\\n        ,Salary\\n        ,(\\n            SELECT \\n                COUNT(DISTINCT Salary) \\n                FROM Employee\\n                WHERE Salary >= e.salary AND DepartmentId = e.DepartmentId\\n            ) as rank\\n    FROM \\n        Employee e\\n        ) emp\\nJOIN Department d ON (emp.DepartmentId = d.Id)\\nWHERE emp.rank <= 3\\nOrder by 1,3 desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327298,
                "title": "solution-with-dense-rank",
                "content": "```sql\\nSELECT D.Name as \"Department\",\\n       E.Name as \"Employee\",\\n       Salary as \"Salary\"\\nFROM (SELECT Name, \\n       Salary,\\n       DepartmentId,\\n        RANK() OVER (\\n            PARTITION BY DepartmentId \\n            ORDER BY Salary DESC) as Rank\\n        FROM Employee) E,\\n        Department D\\nWHERE D.Id = E.DepartmentId\\nAND E.Rank <=3;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT D.Name as \"Department\",\\n       E.Name as \"Employee\",\\n       Salary as \"Salary\"\\nFROM (SELECT Name, \\n       Salary,\\n       DepartmentId,\\n        RANK() OVER (\\n            PARTITION BY DepartmentId \\n            ORDER BY Salary DESC) as Rank\\n        FROM Employee) E,\\n        Department D\\nWHERE D.Id = E.DepartmentId\\nAND E.Rank <=3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311158,
                "title": "with-cte",
                "content": "---\\n\\n    with cte as\\n    \\n        (Select \\n         d.name as Department , e.name as Employee, e.salary,\\n         dense_rank() over(partition by departmentid order by salary desc) as rank\\n         from employee e\\n         join department d\\n         on e.departmentid = d.id\\n         )\\n         \\n     select department, employee, salary\\n     from cte\\n     where rank in (1,2,3)\\n\\n---",
                "solutionTags": [],
                "code": "---\\n\\n    with cte as\\n    \\n        (Select \\n         d.name as Department , e.name as Employee, e.salary,\\n         dense_rank() over(partition by departmentid order by salary desc) as rank\\n         from employee e\\n         join department d\\n         on e.departmentid = d.id\\n         )\\n         \\n     select department, employee, salary\\n     from cte\\n     where rank in (1,2,3)\\n\\n---",
                "codeTag": "Unknown"
            },
            {
                "id": 307286,
                "title": "simple-dence-rank-solution",
                "content": "select a.employee, a.salary, a.department\\nfrom\\n(Select e.name as employee, e.salary as salary, d.name as department, dense_rank() over(partition by e.departmentID order by e.salary desc) as rank\\nfrom employee as e inner join department as d on e.departmentID= d.id) a\\nwhere a.rank < 4",
                "solutionTags": [],
                "code": "select a.employee, a.salary, a.department\\nfrom\\n(Select e.name as employee, e.salary as salary, d.name as department, dense_rank() over(partition by e.departmentID order by e.salary desc) as rank\\nfrom employee as e inner join department as d on e.departmentID= d.id) a\\nwhere a.rank < 4",
                "codeTag": "Unknown"
            },
            {
                "id": 286022,
                "title": "simple-mysql",
                "content": "select d.name as Department,temp.name as Employee,temp.salary as Salary\\nfrom department d join\\n(select departmentid,name,salary from employee a\\nwhere 3>=(select count(distinct salary) \\n        from employee \\n        where salary>=a.salary\\n         and departmentid=a.departmentid))temp\\non temp.departmentid=d.id\\norder by 1,3 desc",
                "solutionTags": [],
                "code": "select d.name as Department,temp.name as Employee,temp.salary as Salary\\nfrom department d join\\n(select departmentid,name,salary from employee a\\nwhere 3>=(select count(distinct salary) \\n        from employee \\n        where salary>=a.salary\\n         and departmentid=a.departmentid))temp\\non temp.departmentid=d.id\\norder by 1,3 desc",
                "codeTag": "Unknown"
            },
            {
                "id": 273036,
                "title": "94-9-faster-mysql",
                "content": "sql:\\n```\\nselect\\n    a.Department,\\n    a.Employee,\\n    a.Salary\\nfrom\\n(\\n    select\\n        a.Department_Name as Department,\\n        a.Name as Employee,\\n        a.Salary as Salary,\\n        (case \\n            when a.Salary = @salary and a.Department_Name = @dept then @rank:=@rank+0\\n            when a.Salary != @salary and a.Department_Name = @dept then @rank:=@rank+1\\n            when a.Department_Name != @dept then @rank:=0\\n            else @rank:=@rank+1 end) + 1 as rank,\\n        @salary := Salary,\\n        @dept := a.Department_Name\\n    from\\n    (\\n            select  \\n                a.Id as Id,\\n                a.Name as Name,\\n                a.Salary as Salary,\\n                b.Name as Department_Name\\n            from `Employee` a\\n            left join `Department` b on a.DepartmentId = b.Id\\n            where b.Name is not null\\n            order by 4 asc,3 desc\\n    )a, (select @rank :=0, @salary := 0, @dept:=\\'no\\')r\\n    order by 1 asc, 3 desc\\n)a\\nwhere a.rank<=3.0\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    a.Department,\\n    a.Employee,\\n    a.Salary\\nfrom\\n(\\n    select\\n        a.Department_Name as Department,\\n        a.Name as Employee,\\n        a.Salary as Salary,\\n        (case \\n            when a.Salary = @salary and a.Department_Name = @dept then @rank:=@rank+0\\n            when a.Salary != @salary and a.Department_Name = @dept then @rank:=@rank+1\\n            when a.Department_Name != @dept then @rank:=0\\n            else @rank:=@rank+1 end) + 1 as rank,\\n        @salary := Salary,\\n        @dept := a.Department_Name\\n    from\\n    (\\n            select  \\n                a.Id as Id,\\n                a.Name as Name,\\n                a.Salary as Salary,\\n                b.Name as Department_Name\\n            from `Employee` a\\n            left join `Department` b on a.DepartmentId = b.Id\\n            where b.Name is not null\\n            order by 4 asc,3 desc\\n    )a, (select @rank :=0, @salary := 0, @dept:=\\'no\\')r\\n    order by 1 asc, 3 desc\\n)a\\nwhere a.rank<=3.0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260106,
                "title": "ms-sql-faster-than-59-with-dense-rank",
                "content": "```\\n\\n\\nWITH test AS(\\n    SELECT \\n    Department = D.Name,\\n    Employee = E.Name,\\n    E.Salary,\\n    DENSE_RANK() OVER (PARTITION BY E.DepartmentID\\n               ORDER BY E.Salary DESC) Salary_Rank\\n    FROM Employee E\\n    INNER JOIN Department D ON D.Id = E.DepartmentId \\n    )\\n    \\nSELECT Department, Employee, Salary\\nFROM test\\nWHERE Salary_Rank <= 3\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nWITH test AS(\\n    SELECT \\n    Department = D.Name,\\n    Employee = E.Name,\\n    E.Salary,\\n    DENSE_RANK() OVER (PARTITION BY E.DepartmentID\\n               ORDER BY E.Salary DESC) Salary_Rank\\n    FROM Employee E\\n    INNER JOIN Department D ON D.Id = E.DepartmentId \\n    )\\n    \\nSELECT Department, Employee, Salary\\nFROM test\\nWHERE Salary_Rank <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256459,
                "title": "sql-server-dense-rank-is-all-we-need",
                "content": "```\\n\\nSELECT d.Name as Department,\\n       e.Name as Employee, \\n       e.Salary\\nFROM Department d\\nJOIN(\\nSELECT *,\\n    dense_rank = DENSE_RANK() OVER (partition by DepartmentId ORDER BY Salary DESC)\\nFROM Employee) e ON e.DepartmentId = d.Id\\nWHERE e.dense_rank < 4",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n\\nSELECT d.Name as Department,\\n       e.Name as Employee, \\n       e.Salary\\nFROM Department d\\nJOIN(\\nSELECT *,\\n    dense_rank = DENSE_RANK() OVER (partition by DepartmentId ORDER BY Salary DESC)\\nFROM Employee) e ON e.DepartmentId = d.Id\\nWHERE e.dense_rank < 4",
                "codeTag": "Unknown"
            },
            {
                "id": 250013,
                "title": "solution-using-group-by-and-having",
                "content": "```\\nselect c.Name as Department, a.Name as Employee, a.Salary as Salary \\nfrom Employee as a\\njoin\\n(select distinct Salary, DepartmentId from Employee) as b\\non a.Salary <= b.Salary\\nand a.DepartmentId = b.DepartmentId\\njoin Department c\\non a.DepartmentId = c.Id\\ngroup by a.Id\\nhaving count(b.salary) <= 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect c.Name as Department, a.Name as Employee, a.Salary as Salary \\nfrom Employee as a\\njoin\\n(select distinct Salary, DepartmentId from Employee) as b\\non a.Salary <= b.Salary\\nand a.DepartmentId = b.DepartmentId\\njoin Department c\\non a.DepartmentId = c.Id\\ngroup by a.Id\\nhaving count(b.salary) <= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248395,
                "title": "mysql-easy-no-group-by-no-join",
                "content": "```\\nSELECT D.Name as Department, E.Name as Employee, E.Salary \\nFROM Department as D, \\n(SELECT *, (SELECT count(distinct a.salary)from Employee as a WHERE a.Salary >= b.salary AND a.DepartmentId  = b.DepartmentId ) as Rank from Employee as b) as E\\nWHERE D.ID = E.DepartmentId and E.Rank < 4;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT D.Name as Department, E.Name as Employee, E.Salary \\nFROM Department as D, \\n(SELECT *, (SELECT count(distinct a.salary)from Employee as a WHERE a.Salary >= b.salary AND a.DepartmentId  = b.DepartmentId ) as Rank from Employee as b) as E\\nWHERE D.ID = E.DepartmentId and E.Rank < 4;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236447,
                "title": "simple-sql-server-solution",
                "content": "SELECT Department, Employee,   Salary from (SELECT d.Name as Department,  e.Name as Employee,  e.Salary,  dense_rank() over(partition by d.Name order by salary desc) as rn\\n  from Employee as e inner join Department d on d.Id=e.DepartmentId)t where  rn<4",
                "solutionTags": [],
                "code": "SELECT Department, Employee,   Salary from (SELECT d.Name as Department,  e.Name as Employee,  e.Salary,  dense_rank() over(partition by d.Name order by salary desc) as rn\\n  from Employee as e inner join Department d on d.Id=e.DepartmentId)t where  rn<4",
                "codeTag": "Unknown"
            },
            {
                "id": 217703,
                "title": "two-working-solutions-using-window-function",
                "content": "Very simple two steps solution: \\n1) add a column rank the salary in each department and join with department to add department info\\n2) filter top 3 \\n```\\ndrop view if exists EmployeeRanked; \\ncreate view EmployeeRanked as \\nselect Salary, DepartmentId, Employee.Name as EmployeeName, dense_rank()over(partition by DepartmentId order by Salary Desc) as MyRank, Department.Name\\nfrom Employee \\njoin Department \\non Employee.DepartmentId=Department.Id; \\nselect er.Name, er.EmployeeName, Salary\\nfrom EmployeeRanked er\\nwhere MyRank <=3; \\n```\\n\\n```\\nselect Name, Salary, Department \\nfrom \\n(\\nselect e.* , d. Name as Department, dense_rank() over (partition by DepartmentId order by Salary desc) MyRank from Employee e \\njoin Department d\\non e. DepartmentId=d. Id \\n) dt1\\nwhere MyRank between 1 and 3\\norder by Department desc, Salary desc; \\n```\\nUse window function along with CTE for better readibility \\n```\\nwith cte1 as(\\nselect e.*, rank()over(partition by DepartmentId order by Salary Desc) myrank\\nfrom Employee e \\n)\\nselect cte1.Name as Employee, cte1. Salary, cte1. myrank, d. Name\\nfrom cte1 \\nLeft Join Department d on d. Id=cte1. DepartmentId \\nwhere cte1. myrank<=3\\norder by d. id desc; \\n```\\nWithout using window function\\n```\\nselect d.Name as Department, e. Name as Employee, e. Salary\\nfrom Employee e\\njoin Department d on d.Id=e.DepartmentId \\nwhere 3>(select count(distinct Salary) from Employee e2 where e.DepartmentId=e2.DepartmentId and e2.Salary>e.Salary)\\norder by Department, Salary desc; \\n```",
                "solutionTags": [],
                "code": "```\\ndrop view if exists EmployeeRanked; \\ncreate view EmployeeRanked as \\nselect Salary, DepartmentId, Employee.Name as EmployeeName, dense_rank()over(partition by DepartmentId order by Salary Desc) as MyRank, Department.Name\\nfrom Employee \\njoin Department \\non Employee.DepartmentId=Department.Id; \\nselect er.Name, er.EmployeeName, Salary\\nfrom EmployeeRanked er\\nwhere MyRank <=3; \\n```\n```\\nselect Name, Salary, Department \\nfrom \\n(\\nselect e.* , d. Name as Department, dense_rank() over (partition by DepartmentId order by Salary desc) MyRank from Employee e \\njoin Department d\\non e. DepartmentId=d. Id \\n) dt1\\nwhere MyRank between 1 and 3\\norder by Department desc, Salary desc; \\n```\n```\\nwith cte1 as(\\nselect e.*, rank()over(partition by DepartmentId order by Salary Desc) myrank\\nfrom Employee e \\n)\\nselect cte1.Name as Employee, cte1. Salary, cte1. myrank, d. Name\\nfrom cte1 \\nLeft Join Department d on d. Id=cte1. DepartmentId \\nwhere cte1. myrank<=3\\norder by d. id desc; \\n```\n```\\nselect d.Name as Department, e. Name as Employee, e. Salary\\nfrom Employee e\\njoin Department d on d.Id=e.DepartmentId \\nwhere 3>(select count(distinct Salary) from Employee e2 where e.DepartmentId=e2.DepartmentId and e2.Salary>e.Salary)\\norder by Department, Salary desc; \\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564843,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1567906,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1566011,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1566619,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1576545,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1567288,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1576988,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1697831,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1947718,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1569987,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1564843,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1567906,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1566011,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1566619,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1576545,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1567288,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1576988,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1697831,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1947718,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1569987,
                "content": [
                    {
                        "username": "Joy4fun",
                        "content": "Some interviewer just don't like you use subquery\\n\\n\\t  SELECT D.Name as Department, E.Name as Employee, E.Salary \\n\\t  FROM Department D, Employee E, Employee E2  \\n\\t  WHERE D.ID = E.DepartmentId and E.DepartmentId = E2.DepartmentId and \\n\\t  E.Salary <= E2.Salary\\n\\t  group by D.ID,E.Name having count(distinct E2.Salary) <= 3\\n      order by D.Name, E.Salary desc"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@Tmakinde](/Tmakinde) \\nYou can reference my solution with subquery for easier to understand the solution\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "WITH emp_salary as\n(select name, salary, departmentID, DENSE_RANK() OVER(partition by departmentID order by salary desc) as rownum from Employee)\n\nselect d.name department,e.name Employee, Salary from emp_salary e \nJOIN Department d ON e.departmentID = d.ID where rownum<4\n\n"
                    },
                    {
                        "username": "Tmakinde",
                        "content": "Can anyone explain this solution in simple term? even though it works, I am finding it difficult to understand it."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "I have a question for the WHERE clause. It may seem a little bit stupid, but I am just curious. What if all the employees are sharing the same salaries within one of the department. Then will the condition \\'E.Salary <= E2.Salary\\' filter out all the employees of that entire department?"
                    },
                    {
                        "username": "thakurss",
                        "content": "Why can't we still use window functions to solve this problem?"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "We can solve using window functions. We should make sure the headings of the columns are same as in the testcase.\\n\\n"
                    },
                    {
                        "username": "GoribManush",
                        "content": "Hitting \"Run Code\" gives \"Invalid Test Case\"."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "maulik20",
                        "content": "Hi,\\nI am getting invalid testcase error when running any query.\\nFor example, simple queries like:\\nselect *\\nfrom employee \\nCan you please tell what can be the problem and solution here."
                    },
                    {
                        "username": "bossbhai",
                        "content": "Use this bro\\nwith sub as (select e.name as Employee, salary, d.name as Department,\\ndense_rank() over(partition by d.name order by salary desc) as rn\\nfrom employee e\\nleft join department d \\non e.departmentId=d.id  order by Department)\\nselect Department,Employee, salary  from sub\\nwhere rn<=3"
                    },
                    {
                        "username": "chiaolynn007",
                        "content": "with temp as (select d.name as \\'Department\\', e.name as \\'Employee\\', e.salary as \\'Salary\\', dense_rank() over (partition by d.name order by e.salary desc) as \\'ranking\\'\\nfrom employee e\\nleft join department d\\non e.departmentid = d.id) \\nselect Department, Employee, Salary from temp where ranking between 1 and 3;\\n"
                    },
                    {
                        "username": "leonmu",
                        "content": "Here is the test case I think it's wrong.\\nInput\\n{\"headers\": {\"Employee\": [\"Id\", \"Name\", \"Salary\", \"DepartmentId\"], \"Department\": [\"Id\", \"Name\"]}, \"rows\": {\"Employee\": [[1, \"Joe\", 60000, 1], [2, \"Ralph\", 50000, 1], [3, \"Joel\", 60000, 1], [4, \"Tracy\", 75000, 1]], \"Department\": [[1, \"IT\"]]}}\\nExpected:\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n\\n\\nWe can see there are **four** employee are chosen from data, But the question request us to  ***find employees who earn the top three salaries in each of the department.***\\n\\nSo, is this a wrong test case ?"
                    },
                    {
                        "username": "jabbekeipert",
                        "content": "I think, its talking about top three distinct salaries. Joel and Joe both have 60000 Salary so there are 3 distinct salaries: 75k, 60k, 50k so its right i think"
                    },
                    {
                        "username": "breezegeek",
                        "content": "/* Write your PL/SQL query statement below */\\n\\nselect Department,Employee,Salary from(    \\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by  E.salary desc) as rank\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\norder by  E.salary desc\\n    )\\n    where rank<4\\n\\n"
                    },
                    {
                        "username": "hero4future",
                        "content": "dense rank was such an interesting addition now i know what its for"
                    },
                    {
                        "username": "aloaa1",
                        "content": "should be medium, not hard problem"
                    },
                    {
                        "username": "rj6033618",
                        "content": "select d.name as Department,\\ne. name as Employee,\\ne.salary\\nfrom Employee as e join department as d\\non e.departmentId = d.id\\nwhere 3> (select count(distinct e1.salary) from Employee as e1\\nwhere e1.salary>e.salary and e1.departmentId = e.departmentId )\\norder by 1, 3 desc"
                    },
                    {
                        "username": "xs020340",
                        "content": "Invalid Testcase\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nfr\\'\\n"
                    }
                ]
            },
            {
                "id": 1569971,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1569328,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1571391,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1845163,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1574904,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1573814,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1573701,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1572973,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1572294,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1571984,
                "content": [
                    {
                        "username": "Codyszu",
                        "content": "Even I used basic select from statement\\nit still shows:\\n\\nLine 5: SyntaxError: near \\'row_number,\\n  @dep := DepartmentId as dummy,\\n  @salary := Salary as dummy2\\nf"
                    },
                    {
                        "username": "Bang25",
                        "content": "Working solution on MySQL 8\\n\\nWITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, row_number () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d  JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num < 4\\nORDER BY Department, Salary DESC"
                    },
                    {
                        "username": "yang6n",
                        "content": "Input:\\n`\\n{\"headers\": {\"Employee\": [\"Id\"\\n\"Name\"\\n\"Salary\"\\n\"DepartmentId\"]\\n\"Department\": [\"Id\"\\n\"Name\"]}\\n\"rows\": {\"Employee\": [[1\\n\"Joe\"\\n60000\\n1]\\n[2\\n\"Ralph\"\\n50000\\n1]\\n[3\\n\"Joel\"\\n60000\\n1]\\n[4\\n\"Tracy\"\\n75000\\n1]]\\n\"Department\": [[1\\n\"IT\"]]}}`\\n\\nOutput:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000]]}\\n`\\n\\nExpected:\\n`\\n{\"headers\": [\"Department\", \"Employee\", \"Salary\"], \"values\": [[\"IT\", \"Tracy\", 75000], [\"IT\", \"Joe\", 60000], [\"IT\", \"Joel\", 60000], [\"IT\", \"Ralph\", 50000]]}\\n`\\n\\nThe expectation is 4 rows under 'IT' department, which should be top 3. Isn't it?"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "Select Department,Employee,Salary from\\n(\\nselect D.name as Department,E.name as Employee,E.salary as Salary, dense_rank() over(partition by E.departmentId order by E.salary desc) as \\'rank\\'\\n\\nfrom Employee E, Department D\\nwhere E.departmentId=D.id\\n)a\\nwhere a.rank<4\\n\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "Has this got accepted for you?"
                    },
                    {
                        "username": "AyoubSmina",
                        "content": "with DepMAx as \\n(\\n\\tselect DepartmentId,Id,[max] = Salary,[row] = dense_rank() \\n\\tover(partition by DepartmentId order by Salary desc) \\n\\t\\tfrom Employee \\n)\\n\\nselect distinct\\n[Department] = d.Name,\\n[Employee] = em.Name,\\n[Salary] = m.max\\nfrom DepMAx m \\njoin Department d on m.DepartmentId = d.Id \\njoin Employee em on m.Id = em.Id \\nwhere m.row <=3"
                    },
                    {
                        "username": "rbagga",
                        "content": "\\'\\'\\'\\nSELECT Department,Employee,Salary from \\n(SELECT d.NAME as Department,e.Name as Employee, e.Salary as Salary,DENSE_RANK() over (partition by d.NAME order by e.SALARY Desc) as RANK  from Employee e\\nLEFT JOIN Department d \\nON e.DepartmentID=d.ID ) as a \\nWHERE RANK<=3\\n\\'\\'\\'\\n\\n"
                    },
                    {
                        "username": "SamikshyaM",
                        "content": "WITH CTE\\nAS\\n(\\nSELECT e.Id, e.Name, e.Salary, e.DepartmentId\\nFROM Employee AS e\\nINNER JOIN\\n(\\nSELECT e1.Id, COALESCE(COUNT(DISTINCT(e2.Salary)),0) + 1 AS rank\\n  FROM Employee AS e1\\nLEFT JOIN Employee AS e2 ON e1.Salary < e2.Salary AND e1.DepartmentId = e2.DepartmentId\\nGROUP BY e1.Id, e1.Salary) AS t1 ON e.Id = t1.Id\\nWHERE t1.rank IN (1,2,3))\\n\\nSELECT d.name AS Department, c.Name AS Employee, c.Salary AS Salary\\n  FROM CTE AS c\\nINNER JOIN Department AS d ON c.DepartmentId = d.Id;"
                    },
                    {
                        "username": "yududdd",
                        "content": "WITH rank_t as (SELECT Name, Salary, DENSE_RANK() OVER(PARTITION BY DepartmentID ORDER BY Salary desc) as rank, DepartmentId\\n                   FROM Employee)\\n\\nSELECT d.Name as Department, r.Name as Employee, r.Salary as Salary\\nFROM rank_t r\\nINNER JOIN Department d\\nON r.DepartmentId = d.Id\\nWHERE r.rank <= 3;"
                    },
                    {
                        "username": "pythony1432",
                        "content": "Write a SQL query to find employees who earn the top THREE salaries in each of the department.\\n\\nExpected:\\n{\"headers\":[\"Department\",\"Employee\",\"Salary\"],\"values\":[[\"IT\",\"Tracy\",75000],[\"IT\",\"Joe\",60000],[\"IT\",\"Joel\",60000],[\"IT\",\"Ralph\",50000]]}\\n\\nThis has 4 values from IT department.  My output had top 3 but was still rejected."
                    },
                    {
                        "username": "francescode",
                        "content": "Which ones should I display?"
                    }
                ]
            },
            {
                "id": 1571390,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 2062409,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 2060699,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 2055983,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 2051323,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 2047734,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 2017608,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 2017143,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 2010028,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 1999628,
                "content": [
                    {
                        "username": "xxxxxxxx330",
                        "content": "select * from (\\nselect row_number() over(partition by e.departmentid order by e.Salary desc) as rank, d.name as Department, e.name as Employee, e.Salary\\nfrom Employee e, Department d\\nwhere e.DepartmentId =d.id  ) t\\nwhere rank <=3"
                    },
                    {
                        "username": "srjefers",
                        "content": "-- ORACLE\\n```\\n/* Write your PL/SQL query statement below */\\nwith employee_tmp as (\\n    select \\n        name,\\n        salary,\\n        departmentId,\\n        dense_rank() over (partition by departmentId order by salary desc) rnk\\n    from Employee\\n    order by rnk\\n)\\n,final as (\\n    select \\n        d.name as Department,\\n        e.name as Employee,\\n        e.salary\\n    from employee_tmp e\\n    inner join Department d \\n        on e.departmentId = d.id\\n    where rnk between 1 and 3\\n)\\nselect * from final\\n```"
                    },
                    {
                        "username": "Ayush1695",
                        "content": "  `WITH CTE\nAS\n(SELECT a.id, a.name as Employee, a.salary, b.name as Department, DENSE_RANK() OVER(PARTITION BY a.departmentId ORDER BY Salary DESC) as rnk\nFROM Employee a\nJOIN department b\nON a.departmentId = b.id)\n\nSELECT Department, Employee, Salary\nFROM CTE\nWHERE rnk <=3`\n\nI think its easy level not hard at all."
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "why output in description and in _result are different?"
                    },
                    {
                        "username": "sandeepagrawal8875",
                        "content": "it\\'s not hard if you know the \"dense_rank\" function in MS sql server."
                    },
                    {
                        "username": "qiaoyuanchan",
                        "content": "testcase broken again"
                    },
                    {
                        "username": "pankajmaheshwari128",
                        "content": "select Department, Employee , Salary from\\n(select e.name as Employee, department.name as Department , e.salary as Salary,\\ndense_rank() over(partition by e.departmentId order by e.salary desc) as rn\\nfrom employee e \\njoin department on department.id = e.departmentid) temp where rn < 4;"
                    },
                    {
                        "username": "ManFromNowhere2000",
                        "content": "# Write your MySQL query statement below\\n\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary\\nFROM Employee e\\nINNER JOIN Department d ON e.departmentId = d.id\\nWHERE e.salary > (\\n    SELECT DISTINCT emp.salary\\n    FROM Employee emp\\n    WHERE emp.departmentId = e.departmentId\\n    ORDER BY emp.salary DESC\\n    LIMIT 1 OFFSET 3\\n)\\nwhats wrong in this query"
                    },
                    {
                        "username": "Najam_Shahzad",
                        "content": " with rank_cte AS (\\n SELECT\\n        e.name AS Employee,\\n        e.salary AS Salary,\\n        d.name AS Department,\\n        Dense_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS rank_over\\nFROM Employee e\\nJOIN Department d ON e.departmentId = d.id\\n )\\n\\n select Department,\\n        Employee,\\n        Salary\\nfrom rank_cte\\nwhere rank_over <= 3"
                    },
                    {
                        "username": "NaRaNo",
                        "content": "try dense_rank() function for oracle"
                    }
                ]
            },
            {
                "id": 1996640,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1967855,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1961652,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1961208,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1935031,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1913620,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1890758,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1869320,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1868968,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1848271,
                "content": [
                    {
                        "username": "Pk_nirwan14",
                        "content": "with  top as  \\n(\\n    select d.name as department,\\n    e.name as employee,\\n    e.salary as salary \\n    from employee as e join department as d \\n    on e.departmentId = d.id\\n),\\ntop2 as \\n(\\n    select department, employee, salary , dense_rank() over ( partition by department order  by salary desc) as rank1 from top\\n)\\nselect department, employee, salary from top2\\nwhere rank1 <= 3\\ngroup by  department, employee, salary ;"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect d.name as Department, e.name as Employee, salary as Salary\\nfrom department d join employee e on d.id = e.departmentId\\nwhere (\\n    select count(distinct e2.salary)\\n    from employee e2\\n    where e2.departmentId = d.id and e2.salary > e.salary\\n) <= 2"
                    },
                    {
                        "username": "RodrigoGesuatto",
                        "content": "I think the testcase 19 is wrong, because when I create the table of the test and run my query, the output is the same of the expected sections, but it displays \"Wrong Answer\".  The query passed 18 out 19 tests, a pity it doesn\\'t work in the last one.\\n\\nI hope the test is indeed mistyped. Any feedback on that would be great!\\n\\nThanks!"
                    },
                    {
                        "username": "affex_16",
                        "content": "with cte as (\\n    select e.id, e.name as Employee, e.salary as Salary , d.name as Department,\\n    dense_rank() over (partition by d.name order by e.salary desc) rnk\\n    from employee e\\n    left join department d on e.departmentId=d.id\\n)\\nselect Department, Employee, Salary\\nfrom cte\\nwhere rnk<=3"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "For some reason nor LeetCode nor my local server allow corellated subqueries now. Anyone having same issue?"
                    },
                    {
                        "username": "Arin_Maity",
                        "content": "WITH cte\\nAS(SELECT *,Ranking = DENSE_RANK() OVER(PARTITION BY departmentId ORDER BY salary DESC)\\nFROM Employee)\\n\\nSELECT Department.name As \\'Department\\',cte.name As \\'Employee\\',cte.salary \\nFROM cte JOIN Department ON cte.departmentId = Department.id\\nWHERE cte.Ranking <=3"
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "It\\'s saying my output is incorrect but the results are showing exactly the same as the expected just in a different order. The instructions clearly state it doesn\\'t matter what the order is. Here\\'s my code: \\nWITH CTE1 as (\\n    SELECT departmentId, name, salary, \\n    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY salary DESC) as \"rank\"\\n    FROM employee\\n)\\n\\nSELECT d.name , e.name , e.salary \\nFROM CTE1 as e\\n    JOIN department as d\\n        ON e.departmentId = d.id\\nWHERE \\ne.rank <= 3;"
                    },
                    {
                        "username": "bhakti_234",
                        "content": "select Department, Employee,Salary from(\\nselect d.name as Department,e.name as Employee,e.Salary as Salary,\\ndense_rank()over(partition by d.name order by e.salary desc ) as r\\nfrom Employee as e inner join Department as d\\non e.departmentid=d.id) as k\\nwhere r<4"
                    },
                    {
                        "username": "shivamj11",
                        "content": "Create a cte table and in this select all columns of employee and create a new column of rank using dense_rank() window function.\\nJoin cte with department table on department id.\\nThen use where clause on rank and mention 1,2,3 to fetch employees whose salary is top 3.\\n[SOLUTION](https://leetcode.com/problems/department-top-three-salaries/solutions/3436924/cte-dense-rank-join-beats-95/)"
                    },
                    {
                        "username": "sgodbole11",
                        "content": "with temp as\\n(select d.name as Department, e.name as Employee, e.salary as Salary, \\ndense_rank() over (partition by d.name order by e.salary desc) as ranking\\nfrom employee e, department d\\nwhere  e.departmentid = d.id)\\nselect Department, Employee, Salary from temp where ranking between 1 and 3;"
                    }
                ]
            },
            {
                "id": 1840902,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1840521,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1806988,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1804425,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1800661,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1796059,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1776174,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1763213,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1751751,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1743916,
                "content": [
                    {
                        "username": "Dysania",
                        "content": "I would think you could do something like the following: \\n\\n```\\nSELECT d.name as Department, e.name as Employee, e.salary as Salary \\n  FROM employee e\\n  LEFT JOIN department d\\n  ON e.departmentId = d.id\\n  WHERE e.salary IN (SELECT DISTINCT salary FROM Employee WHERE e.departmentId = d.id ORDER BY salary DESC LIMIT 3);\\n```\\nBut LIMIT for subqueryies isn\\'t valid in this version of mysql. *goes looking for another solution*"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select name,salary,departmentId from Employee),\\ncte2 as (select id ,name from Department)\\n\\nselect Department,Employee,Salary\\nfrom \\n(select b.name as Department,a.name as Employee,a.salary,dense_rank() over (partition by b.name order by salary desc) as rnk \\n\\nfrom cte a\\nleft join cte2 b on \\na.departmentId=b.id) a where rnk<4"
                    },
                    {
                        "username": "rishabhk0409",
                        "content": "I found easy CTE \n`with \ncte as\n(Select d.name Dname, e.Name Ename, salary , \ndense_rank() over (partition by d.id order by salary desc) [Rank]\n from Employee e\n join department d \non e.departmentId = d.id) \n Select  Dname Department,Ename Employee,Salary from Cte where [Rank] < 4`"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with top_three as (select d.name as Department, e.name as \\'Employee\\', e.salary as salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as value_rank FROM Employee e JOIN Department d on e.departmentId = d.id ORDER BY salary desc)\\n\\n\\nSELECT Department, Employee, Salary FROM top_three WHERE value_rank <= 3;`"
                    },
                    {
                        "username": "sourabhgarai_98",
                        "content": "with cte1 as  (select d.name as Department,e.name as Employee,e.salary,dense_rank() over(partition by \\ne.departmentId order by \\ne.salary desc) as rnk from Employee e,Department d where d.id=e.departmentId)\\n\\nselect Department,Employee,salary from cte1 where rnk<4;"
                    },
                    {
                        "username": "nishdhana15",
                        "content": "USING WITH clause\\n\\nWITH ranks as\\n(SELECT d.name as Department, e.name as Employee,Salary, DENSE_RANK() OVER(PARTITION BY d.name ORDER BY salary DESC)sranks \\nFROM employee as e\\nLEFT JOIN department as d\\nON e.departmentid=d.id)\\n\\n\\nSELECT Department,Employee,Salary\\nFROM ranks\\nWHERE sranks<4\\n"
                    },
                    {
                        "username": "Irinajiajia",
                        "content": "Remember to use DESC!!!! in order by "
                    },
                    {
                        "username": "tomar_sahab07",
                        "content": "MY SQL CODE USING DENSE_RANK :)\\n\\nWITH CTE AS\\n    (SELECT d.name as Department , e.name as Employee,e.salary as Salary,\\n     DENSE_RANK() OVER(PARTITION BY d.name ORDER BY e.salary DESC) as rnk FROM Employee e JOIN Department d ON e.departmentId=d.id)\\n\\nSELECT Department ,  Employee  ,  Salary FROM CTE WHERE rnk BETWEEN 1 AND 3     \\n"
                    },
                    {
                        "username": "joeybosa",
                        "content": "using CTE and window function\n\nwith base as \n(\nselect d.name as Department, e.name as Employee, e.salary as Salary, dense_rank () over (partition by d.name order by e.salary desc) as rnk\nfrom Employee as e\njoin Department as d\non e.departmentId = d.id\n)\n\nselect Department, Employee, Salary\nfrom base\nwhere rnk <= 3\n"
                    },
                    {
                        "username": "291831388",
                        "content": "# SELECT Department.name as Department, Employee.name, Employee.salary\\nSELECT *\\nFROM Employee INNER JOIN  Department ON Employee.departmentId = Department.id\\nGROUP BY Department.name\\nwhy this query only give me rows less than rows in rows in table  employee (the number of rows in table department )"
                    }
                ]
            },
            {
                "id": 1742449,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1733663,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1723303,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1719145,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1716487,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1715914,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1713276,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1708596,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1708138,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            },
            {
                "id": 1701288,
                "content": [
                    {
                        "username": "asifanas",
                        "content": "WITH top3 AS(\\nSELECT d.Name as Department, e.Name as Employee, e.Salary as Salary, dense_rank () Over (Partition by d.Name Order by e.salary desc) row_num\\nFROM Department d inner JOIN Employee e\\nON d.Id = e.departmentId)\\n\\nSELECT Department, Employee, Salary\\nFROM top3\\nWHERE row_num in (1, 2, 3)\\nORDER BY Salary desc;"
                    },
                    {
                        "username": "navitadev22",
                        "content": "SELECT Department.name AS \\'Department\\', e.name AS \\'Employee\\', e.salary FROM\\n(SELECT DepartmentId, name, salary,\\nDENSE_RANK() OVER(PARTITION BY DepartmentId ORDER BY salary DESC) AS R\\nFROM Employee) AS e\\nJOIN Department ON\\ne.departmentId = Department.id\\nWHERE R <= 3;\\n"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.Department, sq.Employee, sq.Salary from(\nSelect d.name as Department, e.name as Employee, e.salary as Salary,\ndense_rank() over(partition by e.departmentId order by salary desc) as rn\nfrom Employee e\njoin Department d\non e.departmentId = d.id\norder by e.id\n) sq\nwhere sq.rn <= 3"
                    },
                    {
                        "username": "jinghongchenxxx",
                        "content": "# USING WINDOW FUNCTION  DENSE_RANK\\nSELECT Department, Employee, Salary\\nFROM \\n(SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\\n    DENSE_RANK() OVER(PARTITION BY E.departmentId ORDER BY E.salary DESC) R\\nFROM Employee E\\nLEFT JOIN Department D ON E.departmentId = D.id) t\\nWHERE R <= 3"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select \\ndense_rank() over(partition by departmentId order by salary desc) as \\'rnk\\',e.name as \\'Employee\\',e.salary as \\'Salary\\',d.name as \\'Department\\'\\nfrom Employee e\\njoin Department d on e.departmentId=d.id)\\nselect Department,Employee,Salary\\nfrom cte\\nwhere rnk in (1,2,3)"
                    },
                    {
                        "username": "jannatultasnim",
                        "content": "something wrong with the test case... may be"
                    },
                    {
                        "username": "gau2cool",
                        "content": "\\nselect third.departmentId as Department, third.name as Employee, third.salary as Salary from\\n       (select e.id, e.departmentId ,e.salary, e.name, dense_rank() over (partition by departmentId order by salary desc) as r from Employee e left join Department d on e.departmentID=d.id) third where r<=3;\\n\\n\\n\\nMy query is correct according to me and also showing the right output with different test cases on leetcode itself but, still leetcode saying wrong answer"
                    },
                    {
                        "username": "u_l_i",
                        "content": "id in field \\'Department\\', but should be name of department."
                    },
                    {
                        "username": "rawalm",
                        "content": "/* Write your T-SQL query statement below */\\n\\nwith sol as (\\nselect *, \\nDense_rank() over (partition by departmentId order by salary desc ) as Rn \\nfrom Employee\\n\\n)\\n\\nselect d.name Department ,s.name Employee , salary Salary from sol s inner join Department d \\non s.departmentId=d.id \\nwhere Rn<=3"
                    },
                    {
                        "username": "ParisssssTian",
                        "content": "select temp.DName as Department,temp.EName as Employee ,temp.salary as Salary\\nfrom(\\n    select d.name as DName ,e.name as EName, salary, \\ndense_rank() over(partition by departmentId order by salary desc) as rk\\nfrom Employee e\\ninner join Department d\\non e.departmentId = d.id\\n\\n) as temp\\nwhere temp.rk <= 3\\n"
                    },
                    {
                        "username": "AnanyaSharma",
                        "content": "why doesnt this solution pass?\\n `with salary as\\n(select d.name as departmentname,e.name as employee\\n, e.salary\\n, dense_rank() over (partition by d.name order by e.Salary desc) as rank\\nfrom employee e\\nleft join department d on e.departmentId = d.id\\n)\\nselect  departmentname, employee, salary\\nfrom salary\\nwhere rank <=3`"
                    },
                    {
                        "username": "u_l_i",
                        "content": "columnname for department is wrong, also upper case needed"
                    }
                ]
            }
        ]
    }
]