[
    {
        "title": "Count Prefixes of a Given String",
        "question_content": "You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.\nReturn the number of strings in words that are a prefix of s.\nA prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"\nOutput: 3\nExplanation:\nThe strings in words which are a prefix of s = \"abc\" are:\n\"a\", \"ab\", and \"abc\".\nThus the number of strings in words which are a prefix of s is 3.\nExample 2:\n\nInput: words = [\"a\",\"a\"], s = \"aa\"\nOutput: 2\nExplanation:\nBoth of the strings are a prefix of s. \nNote that the same string can occur multiple times in words, and it should be counted each time.\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length, s.length <= 10\n\twords[i] and s consist of lowercase English letters only.",
        "solutions": [
            {
                "id": 1994777,
                "title": "java-c-python-starts-with",
                "content": "# **Explanation**\\nfor each word `w` in `words` list,\\ncheck if word `w` `startsWith` the string `s`\\n<br>\\n\\n# **Complexity**\\nTime `O(NS)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countPrefixes(String[] words, String s) {\\n        int res = 0;\\n        for (String w : words)\\n            if (s.startsWith(w))\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**C++**\\nTime O(NWS)\\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += s.find(w) < 1;\\n        return res; \\n    }\\n```\\n\\n**C++**\\nSuggested by @mzchen\\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += !s.compare(0, w.size(), w);\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countPrefixes(self, words, s):\\n        return sum(map(s.startswith, words))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countPrefixes(String[] words, String s) {\\n        int res = 0;\\n        for (String w : words)\\n            if (s.startsWith(w))\\n                res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += s.find(w) < 1;\\n        return res; \\n    }\\n```\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += !s.compare(0, w.size(), w);\\n        return res;\\n    }\\n```\n```py\\n    def countPrefixes(self, words, s):\\n        return sum(map(s.startswith, words))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994746,
                "title": "c-easy-o-nxs-solution-string",
                "content": "```\\nclass Solution {\\npublic:\\n    //iterate over each words[i] and take the sub-string str from s of size equals to words[i].\\n    //and compare str with words[i] if both are equal increase count by 1.\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int count=0;\\n        for(auto it: words)\\n        {\\n            string str = s.substr(0, it.size());\\n            if(str == it) count++;            \\n        }\\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //iterate over each words[i] and take the sub-string str from s of size equals to words[i].\\n    //and compare str with words[i] if both are equal increase count by 1.\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int count=0;\\n        for(auto it: words)\\n        {\\n            string str = s.substr(0, it.size());\\n            if(str == it) count++;            \\n        }\\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997418,
                "title": "java-1-liner",
                "content": "```java\\npublic int countPrefixes(String[] words, String s) {\\n        return (int) Arrays.stream(words).filter(s::startsWith).count();\\n    }\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int countPrefixes(String[] words, String s) {\\n        return (int) Arrays.stream(words).filter(s::startsWith).count();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076295,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if (s[:len(i)]==i):\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if (s[:len(i)]==i):\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994712,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int counter = 0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i] == s.substr(0,words[i].size()))  \\n                counter++;\\n        }\\n\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int counter = 0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i] == s.substr(0,words[i].size()))  \\n                counter++;\\n        }\\n\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999377,
                "title": "count-if",
                "content": "**C++**\\n```cpp\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(begin(words), end(words), [&](const auto &w){ return s.compare(0, w.size(), w) == 0; });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(begin(words), end(words), [&](const auto &w){ return s.compare(0, w.size(), w) == 0; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994767,
                "title": "2-lines-c-java",
                "content": "Apply **find()** in case of c++ and **indexof()** in case of java on every word and check if return position is 0.\\nReturn the count of such strings.\\n# C++\\n    int countPrefixes(vector<string>& words, string s, int cnt=0){\\n        for(auto i:words) if(s.find(i)==0) cnt++;\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt=0;\\n        for(var i:words) if(s.indexOf(i)==0) cnt++;\\n        return cnt;\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "Apply **find()** in case of c++ and **indexof()** in case of java on every word and check if return position is 0.\\nReturn the count of such strings.\\n# C++\\n    int countPrefixes(vector<string>& words, string s, int cnt=0){\\n        for(auto i:words) if(s.find(i)==0) cnt++;\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt=0;\\n        for(var i:words) if(s.indexOf(i)==0) cnt++;\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1994720,
                "title": "c-basic-string-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt = 0;\\n        int i, j;\\n        for(i=0; i<words.size(); i++){\\n            j = 0;\\n            while(j< words[i].size()){\\n                if(words[i][j] != s[j])\\n                    break;\\n                j++;\\n            }\\n            if(j == words[i].size())\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt = 0;\\n        int i, j;\\n        for(i=0; i<words.size(); i++){\\n            j = 0;\\n            while(j< words[i].size()){\\n                if(words[i][j] != s[j])\\n                    break;\\n                j++;\\n            }\\n            if(j == words[i].size())\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003590,
                "title": "python-simple-solution",
                "content": "# Approach\\nCheck for each word if is prefix of s.\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        res = 0\\n\\n        for word in words:\\n            if s.startswith(word):\\n                res += 1\\n\\n        return res\\n```\\n\\nLike it? Please upvote!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        res = 0\\n\\n        for word in words:\\n            if s.startswith(word):\\n                res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726605,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n        public int countPrefixes(String[] words, String s) {\\n        \\n        int result = 0;\\n        for (int i=0; i<=s.length(); i++) {\\n            String x = s.substring(0, i);\\n            for (int j = 0; j<words.length; j++) {\\n                if (x.equals(words[j]))\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int countPrefixes(String[] words, String s) {\\n        \\n        int result = 0;\\n        for (int i=0; i<=s.length(); i++) {\\n            String x = s.substring(0, i);\\n            for (int j = 0; j<words.length; j++) {\\n                if (x.equals(words[j]))\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461131,
                "title": "3-different-fastest-approaches-with-javascript-including-one-liner",
                "content": "// approach 1 \\n\\n```\\nvar countPrefixes = function(words, s) {\\n     let counter = 0\\n     for (let i = 0; i < words.length; i++) {\\n         if (words[i]) === s.slice(0,words[i].length)) {\\n            counter++\\n        }\\n     }\\n    return counter\\n};\\n```\\n\\n// one liner approach - 2\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter((word) => word === s.slice(0,word.length)).length;\\n};\\n```\\n\\n// approach 3\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter(data=> s.indexOf(data) == 0).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n     let counter = 0\\n     for (let i = 0; i < words.length; i++) {\\n         if (words[i]) === s.slice(0,words[i].length)) {\\n            counter++\\n        }\\n     }\\n    return counter\\n};\\n```\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter((word) => word === s.slice(0,word.length)).length;\\n};\\n```\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter(data=> s.indexOf(data) == 0).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084421,
                "title": "straightforward-javascript-solution-faster-than-96-67",
                "content": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for (let word of words) {\\n        if (s.startsWith(word)) count++\\n    } return count;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/9ebdaad0-0ac6-40e8-98da-26c37a70fab5_1653758537.70002.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for (let word of words) {\\n        if (s.startsWith(word)) count++\\n    } return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008421,
                "title": "js-easiest-way",
                "content": "```\\nvar countPrefixes = function(words, s) {\\n  \\n    let cont = 0;\\n    \\n    for(i = 0; i < words.length; i++){\\n        for(j = 1; j <= s.length; j++){\\n            if(words[i] == s.slice(0, j)){\\n                cont++;\\n            }\\n        }        \\n    }\\n     return cont;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n  \\n    let cont = 0;\\n    \\n    for(i = 0; i < words.length; i++){\\n        for(j = 1; j <= s.length; j++){\\n            if(words[i] == s.slice(0, j)){\\n                cont++;\\n            }\\n        }        \\n    }\\n     return cont;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994686,
                "title": "python-straightforward-with-startswith",
                "content": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n\\n    c = 0\\n    for w in words:\\n        if s.startswith(w):\\n            c += 1\\n\\n    return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n\\n    c = 0\\n    for w in words:\\n        if s.startswith(w):\\n            c += 1\\n\\n    return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3955799,
                "title": "java-100-beats-2-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n\\n//                          Another solution\\n\\n        // int count = 0;\\n        // int low = 0;\\n        // for(int i=1; i<=s.length(); i++){\\n        //    for(int j=0; j<words.length; j++){\\n        //        if(words[j].equals(s.substring(low,i))){\\n        //           count++;\\n        //        } \\n        //    }\\n        // }\\n        // return count;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n\\n//                          Another solution\\n\\n        // int count = 0;\\n        // int low = 0;\\n        // for(int i=1; i<=s.length(); i++){\\n        //    for(int j=0; j<words.length; j++){\\n        //        if(words[j].equals(s.substring(low,i))){\\n        //           count++;\\n        //        } \\n        //    }\\n        // }\\n        // return count;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994877,
                "title": "c-simple-solution-using-substr",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            string str = words[i];\\n            if(str == s.substr(0, str.size())) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            string str = words[i];\\n            if(str == s.substr(0, str.size())) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994683,
                "title": "java-easy-appraoch",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        for(int k = 0; k < words.length; k++){\\n            if(words[k].length() > s.length()){\\n                continue;\\n            }\\n            \\n            while(i < words[k].length() && words[k].charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            if(i == words[k].length()){\\n                count++;\\n            }\\n            i = 0;\\n            j = 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        for(int k = 0; k < words.length; k++){\\n            if(words[k].length() > s.length()){\\n                continue;\\n            }\\n            \\n            while(i < words[k].length() && words[k].charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            if(i == words[k].length()){\\n                count++;\\n            }\\n            i = 0;\\n            j = 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994652,
                "title": "best-solution-using-set-easy-to-understand",
                "content": "Approach\\nStep 1 : Define a map and empty stirng\\nStep2 : insert prefixes in map\\nStep3 : check how many array of words element is present in map\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> mp;\\n        string st = \"\";\\n        for(int i=0;i<s.length();i++){\\n            st += s[i];\\n            mp.insert(st);\\n        }\\n        int k=0;\\n        for(auto it:words){\\n            if(mp.count(it)){\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> mp;\\n        string st = \"\";\\n        for(int i=0;i<s.length();i++){\\n            st += s[i];\\n            mp.insert(st);\\n        }\\n        int k=0;\\n        for(auto it:words){\\n            if(mp.count(it)){\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864115,
                "title": "c-3-line-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t//time:O(n), space: O(1)\\n\\t\\tint countPrefixes(vector<string>& words, string s) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(s.find(wd) < 1) count++; //if first occurrence of sub-string is in the specified string\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//time:O(n), space: O(1)\\n\\t\\tint countPrefixes(vector<string>& words, string s) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(s.find(wd) < 1) count++; //if first occurrence of sub-string is in the specified string\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3583196,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n       return sum(1 for x in words if s.startswith(x))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n       return sum(1 for x in words if s.startswith(x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965007,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([word for word in words if s.startswith(word)])\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/7ded423d-5651-41aa-8a7e-b8343efb856e_1672271463.1473987.png)\\n![image.png](https://assets.leetcode.com/users/images/65605e1b-564a-4ea3-8bf0-acad0d5862ea_1672271490.074425.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([word for word in words if s.startswith(word)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938964,
                "title": "easy-and-fast-c-solution",
                "content": "# Approach\\nUsing **s.find(words[i])** function which returns the index of words[i] if it is present in the string s , and to check whether words[i] occurs as a prefix use **s.find(words[i])==0**  ( since prefix always occurs at index 0).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n      int countPrefix = 0;\\n\\n      for(int i=0;i<words.size();++i){\\n          if(s.find(words[i])!=string::npos && s.find(words[i])==0){\\n              countPrefix++;\\n          }\\n      }  \\n      return countPrefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n      int countPrefix = 0;\\n\\n      for(int i=0;i<words.size();++i){\\n          if(s.find(words[i])!=string::npos && s.find(words[i])==0){\\n              countPrefix++;\\n          }\\n      }  \\n      return countPrefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768430,
                "title": "easy-o-n-maintain-a-set",
                "content": "We maintian a set called seen and add all the prefixes in the set and then simply check if the word in word list is present in the set or not\\n\\n***Leave an upvote if this helps!!!***\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        seen=set()\\n        count=0\\n        for i in range(1,len(s)+1):\\n            seen.add(s[:i])\\n        for i in words:\\n            if i in seen:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        seen=set()\\n        count=0\\n        for i in range(1,len(s)+1):\\n            seen.add(s[:i])\\n        for i in words:\\n            if i in seen:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048968,
                "title": "easy-python-solution",
                "content": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in words:\\n            l=len(i)\\n            if i==s[:l]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in words:\\n            l=len(i)\\n            if i==s[:l]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995252,
                "title": "c-online-with-std-count-if-and-string-rfind",
                "content": "This [stackover flow post](https://stackoverflow.com/questions/1878001/how-do-i-check-if-a-c-stdstring-starts-with-a-certain-string-and-convert-a) descrives how to you ```string::rfind``` to implement ```startsWith```, which leads to following over all code to solve to problem.\\n\\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) { return s.rfind(w, 0) == 0; });\\n}\\n```\\n\\nOne might was well could use ```string::compare``` to solve the problem as well:\\n\\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) {\\n        return s.compare(0, size(w), w) == 0;\\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```string::rfind```\n```startsWith```\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) { return s.rfind(w, 0) == 0; });\\n}\\n```\n```string::compare```\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) {\\n        return s.compare(0, size(w), w) == 0;\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995152,
                "title": "c-5-lines-code-very-easy-o-n-solution",
                "content": "```\\nint countPrefixes(vector<string>& words, string s) {\\n       int c=0;\\n       for(string str:words){\\n            int len=str.length();\\n           string subs=s.substr(0,len);\\n           if(str==subs){\\n                c++;\\n           }\\n       } \\n       return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n       int c=0;\\n       for(string str:words){\\n            int len=str.length();\\n           string subs=s.substr(0,len);\\n           if(str==subs){\\n                c++;\\n           }\\n       } \\n       return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994752,
                "title": "java",
                "content": "int ans=0;\\n        HashMap<String,Integer> l=new HashMap<>();\\n        for(String str:words)\\n            l.put(str,l.getOrDefault(str,0)+1);\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            String st=s.substring(0,i);\\n            if(l.containsKey(st))\\n                ans=ans+l.get(st);\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "int ans=0;\\n        HashMap<String,Integer> l=new HashMap<>();\\n        for(String str:words)\\n            l.put(str,l.getOrDefault(str,0)+1);\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            String st=s.substring(0,i);\\n            if(l.containsKey(st))\\n                ans=ans+l.get(st);\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 3827383,
                "title": "python-one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([i for i in words if s.startswith(i)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([i for i in words if s.startswith(i)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534504,
                "title": "simple-easy-100-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450978,
                "title": "easy-to-understand",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        if it starts with element present in array count++;\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443668,
                "title": "simple-using-substr-c",
                "content": "`Please Upvote If you Like the Solution !!!`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans = 0;\\n        for(auto &w : words) {\\n            int n = w.size();\\n            if(s.substr(0,n) == w) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans = 0;\\n        for(auto &w : words) {\\n            int n = w.size();\\n            if(s.substr(0,n) == w) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362962,
                "title": "simple-java-3-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i =0; i<words.length; i++){\\n            if(s.startsWith(words[i])) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i =0; i<words.length; i++){\\n            if(s.startsWith(words[i])) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337621,
                "title": "esay-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        while(s.length()!=0){\\n        for(String y:words){\\n             if(y.equals(s))\\n             c++;\\n        }\\n        s=s.substring(0,s.length()-1); //Decreasing the length by 1\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        while(s.length()!=0){\\n        for(String y:words){\\n             if(y.equals(s))\\n             c++;\\n        }\\n        s=s.substring(0,s.length()-1); //Decreasing the length by 1\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278881,
                "title": "c-easy-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for (string word : words)\\n        {\\n            if(s.find(word) == 0) \\n            { \\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for (string word : words)\\n        {\\n            if(s.find(word) == 0) \\n            { \\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176731,
                "title": "simple-c-code-easy-beats-100",
                "content": "\\n\\nRuntime: Beats 100%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto j:words){\\n            int b=1;\\n            for(int i=0;i<j.size();i++){\\n                if(j[i]!=s[i]){\\n                    b=0;\\n                    break;\\n                }\\n            }\\n            if(b==1){\\n                    c++;\\n                }\\n        }\\n        return c;\\n    }\\n};\\n```\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto j:words){\\n            int b=1;\\n            for(int i=0;i<j.size();i++){\\n                if(j[i]!=s[i]){\\n                    b=0;\\n                    break;\\n                }\\n            }\\n            if(b==1){\\n                    c++;\\n                }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174986,
                "title": "c-o-n-simple-approach-using-string-s-find-func",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868501,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s)\\n    {\\n        string w = \"\" ;\\n        int count = 0 ;\\n        for(int i=0 ; i<words.size() ; i++)\\n        {\\n            w = words[i] ;\\n            int j ;\\n            for(j=0 ; j<w.size() ; j++)\\n            {\\n                if(w[j]!=s[j])\\n                {\\n                    break ;\\n                }\\n            }\\n            if(j==w.size())\\n            {\\n                count++ ;\\n            }\\n        }   \\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s)\\n    {\\n        string w = \"\" ;\\n        int count = 0 ;\\n        for(int i=0 ; i<words.size() ; i++)\\n        {\\n            w = words[i] ;\\n            int j ;\\n            for(j=0 ; j<w.size() ; j++)\\n            {\\n                if(w[j]!=s[j])\\n                {\\n                    break ;\\n                }\\n            }\\n            if(j==w.size())\\n            {\\n                count++ ;\\n            }\\n        }   \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701416,
                "title": "c-easy-approach-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) { \\n        int ans = 0;\\n        for(int i = 0 ; i<words.size() ; i++){\\n            string element = words[i];\\n            int len = element.length();\\n            \\n            for(int j = 0 ; j<len ; j++){\\n               \\n                if(element[j] != s[j]){\\n                    break;      \\n                }     \\n                if(j==len-1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) { \\n        int ans = 0;\\n        for(int i = 0 ; i<words.size() ; i++){\\n            string element = words[i];\\n            int len = element.length();\\n            \\n            for(int j = 0 ; j<len ; j++){\\n               \\n                if(element[j] != s[j]){\\n                    break;      \\n                }     \\n                if(j==len-1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651729,
                "title": "startswith-in-java-java",
                "content": "```\\nif(you like)\\n\\tplease upvote;\\n```\\n![image.png](https://assets.leetcode.com/users/images/c46bfd5c-cd60-4a0f-a3af-d56e67ae236a_1664727810.0896583.png)\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt = 0;\\n        for(String str:words)        \\n        {\\n            if(s.startsWith(str) == true)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nif(you like)\\n\\tplease upvote;\\n```\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt = 0;\\n        for(String str:words)        \\n        {\\n            if(s.startsWith(str) == true)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649512,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif s[:len(word)] == word: res += 1\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif s[:len(word)] == word: res += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2566238,
                "title": "python-straight-forward-one-liner",
                "content": "Here is what I did:\\n\\n```python\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2229509,
                "title": "javascript-straightforward-solution-simple-understandable-fast",
                "content": "**Runtime: 68 ms, faster than 91.85% of JavaScript online submissions for Count Prefixes of a Given String.\\nMemory Usage: 43 MB, less than 40.00% of JavaScript online submissions for Count Prefixes of a Given String.**\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    let count = 0\\n    for (i of words) {\\n        if (s.startsWith(i)) {\\n            count++\\n        }\\n    } \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0\\n    for (i of words) {\\n        if (s.startsWith(i)) {\\n            count++\\n        }\\n    } \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2007119,
                "title": "c-linq-one-line",
                "content": "```\\n\\tpublic int CountPrefixes(string[] words, string s) \\n        => words.Count(w => s.StartsWith(w));    \\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int CountPrefixes(string[] words, string s) \\n        => words.Count(w => s.StartsWith(w));    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997642,
                "title": "rust-solutions",
                "content": "1. Simle use of `starts_with`:\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words.iter().filter(|w| s.starts_with(w.as_str())).count() as _\\n    }\\n}\\n```\\n2. Slice comparison\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.as_str() == &s[..w.len()])\\n            .count() as _\\n    }\\n}\\n```\\n3. Functional solution with `zip`:\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.chars().zip(s.chars()).all(|(a, b)| a == b))\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words.iter().filter(|w| s.starts_with(w.as_str())).count() as _\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.as_str() == &s[..w.len()])\\n            .count() as _\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.chars().zip(s.chars()).all(|(a, b)| a == b))\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995303,
                "title": "c-very-easy-to-understand-solution-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> st;\\n        int size = s.size();\\n        for(int i = 0;i<size;i++){\\n            string temp = \"\";\\n            for(int j = 0;j<=i;j++){\\n                temp+=s[j];\\n            }\\n            st.insert(temp);\\n        }\\n        int ans = 0;\\n        for(int i = 0;i<words.size();i++){\\n            if(st.find(words[i])!=st.end())\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> st;\\n        int size = s.size();\\n        for(int i = 0;i<size;i++){\\n            string temp = \"\";\\n            for(int j = 0;j<=i;j++){\\n                temp+=s[j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1994612,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto word:words)\\n        {\\n                string str=word;\\n                int l=word.size();\\n                string s2=s.substr(0,l);\\n                if(s2==word)\\n                    c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto word:words)\\n        {\\n                string str=word;\\n                int l=word.size();\\n                string s2=s.substr(0,l);\\n                if(s2==word)\\n                    c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994558,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n    \\n       int preFixCount=0;\\n       for(String curr:words){\\n           int i=0;\\n           \\n           if(curr.length()>s.length())     // if current  string length greater than s length invalid prefix\\n           continue; \\n           int j;\\n           for(j=0;j<curr.length();j++,i++){\\n               if(curr.charAt(j)==s.charAt(i))\\n               continue;\\n               else \\n               break;\\n                   \\n           }\\n           if(j==curr.length())             // if all character matches than mark valid \\n           preFixCount++;\\n       }\\n     return preFixCount;     \\n    }\\n   \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n    \\n       int preFixCount=0;\\n       for(String curr:words){\\n           int i=0;\\n           \\n           if(curr.length()>s.length())     // if current  string length greater than s length invalid prefix\\n           continue; \\n           int j;\\n           for(j=0;j<curr.length();j++,i++){\\n               if(curr.charAt(j)==s.charAt(i))\\n               continue;\\n               else \\n               break;\\n                   \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3972694,
                "title": "javascript-easy-one-line-solution",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function (words, s) {\\n  return words.filter((item) => s.startsWith(item)).length\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function (words, s) {\\n  return words.filter((item) => s.startsWith(item)).length\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917786,
                "title": "go-easy",
                "content": "\\n\\n# Code\\n```\\nfunc countPrefixes(words []string, s string) int {\\n\\tvar count int\\n\\n\\tfor _, v := range words {\\n\\t\\tif strings.HasPrefix(s, v) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countPrefixes(words []string, s string) int {\\n\\tvar count int\\n\\n\\tfor _, v := range words {\\n\\t\\tif strings.HasPrefix(s, v) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297434,
                "title": "count-prefixes-of-a-given-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int i, j, count=0;\\n        string str=\"\";\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            str += s[i];\\n            for(j=0 ; j<words.size() ; j++)\\n            {\\n                if(str==words[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int i, j, count=0;\\n        string str=\"\";\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            str += s[i];\\n            for(j=0 ; j<words.size() ; j++)\\n            {\\n                if(str==words[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249714,
                "title": "pyhton3-oneliner-using-startswith",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if s.startswith(i):\\n                count += 1\\n        return count\\n\\n        #One Liner\\n\\n        return sum(1 for i in words if s.startswith(i))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if s.startswith(i):\\n                count += 1\\n        return count\\n\\n        #One Liner\\n\\n        return sum(1 for i in words if s.startswith(i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149760,
                "title": "pooping-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPoop the loop\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c = 0\\n        for i in words:\\n            if i in s[:len(i)]:\\n                c+=1\\n        return c \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c = 0\\n        for i in words:\\n            if i in s[:len(i)]:\\n                c+=1\\n        return c \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114743,
                "title": "count-prefixes-of-a-given-string",
                "content": "```\\nint count=0;\\n        for(auto it:words){\\n            string str=s.substr(0,it.size());\\n            if(str==it)\\n            count++;\\n        }\\n        \\n        return count;\\n\\t\\t\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nint count=0;\\n        for(auto it:words){\\n            string str=s.substr(0,it.size());\\n            if(str==it)\\n            count++;\\n        }\\n        \\n        return count;\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804300,
                "title": "count-prefixes-of-a-given-string-solution-java",
                "content": "class Solution {\\n  public int countPrefixes(String[] words, String s) {\\n    return (int) Arrays.stream(words).filter(word -> s.startsWith(word)).count();\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n  public int countPrefixes(String[] words, String s) {\\n    return (int) Arrays.stream(words).filter(word -> s.startsWith(word)).count();\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2672445,
                "title": "java-solution-startswith-or-indexof",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        \\n        for (String str : words) {\\n            // if (s.indexOf(str) == 0) count++;\\n            if (s.startsWith(str)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        \\n        for (String str : words) {\\n            // if (s.indexOf(str) == 0) count++;\\n            if (s.startsWith(str)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651727,
                "title": "c-short-97-faster-than-all",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(auto word:words){\\n            bool isPrefix = true;\\n            for(int i=0; i<word.length(); i++){\\n                if(word[i] != s[i]){\\n                    isPrefix = false;\\n                    break;\\n                }\\n            }\\n            if(isPrefix) count++;\\n        }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(auto word:words){\\n            bool isPrefix = true;\\n            for(int i=0; i<word.length(); i++){\\n                if(word[i] != s[i]){\\n                    isPrefix = false;\\n                    break;\\n                }\\n            }\\n            if(isPrefix) count++;\\n        }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626764,
                "title": "python-o-n",
                "content": "Time Complexcity O(N)\\nspace Complexcity O(1)\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            n=len(word)\\n            if s[0:n]==word:\\n                count+=1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            n=len(word)\\n            if s[0:n]==word:\\n                count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612849,
                "title": "java-soln",
                "content": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        for(int i=0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n             count++;\\n         }\\n        } \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        for(int i=0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n             count++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2601418,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(words[i] === s.slice(0, words[i].length)) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(words[i] === s.slice(0, words[i].length)) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561291,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ct=0;\\n        for(string&word:words){\\n          bool flag=true;\\n          if(word.length()<=s.length()){\\n             for(int i=0; i<min(word.length(),s.length()); ++i){\\n                if(word[i]!=s[i]){\\n                   flag=false;\\n                   break;\\n                }\\n             }\\n            flag?ct++:ct+=0;\\n          }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ct=0;\\n        for(string&word:words){\\n          bool flag=true;\\n          if(word.length()<=s.length()){\\n             for(int i=0; i<min(word.length(),s.length()); ++i){\\n                if(word[i]!=s[i]){\\n                   flag=false;\\n                   break;\\n                }\\n             }\\n            flag?ct++:ct+=0;\\n          }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545761,
                "title": "count-prefixes-of-a-given-string",
                "content": "python3 sol\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count= 0 \\n        for i in words:\\n            if i ==s:\\n                count+=1\\n            else:\\n                if i ==s[:len(i)]:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count= 0 \\n        for i in words:\\n            if i ==s:\\n                count+=1\\n            else:\\n                if i ==s[:len(i)]:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502759,
                "title": "easy-fast-short-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int count = 0;\\n        for(String temp: words)\\n            if (s.indexOf(temp) == 0)\\n                count++;\\n        return count;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2500078,
                "title": "c-solution-count-prefixes-of-a-given-string",
                "content": "```\\nclass Solution {\\nprivate:\\n    int linear_search(vector<string>& words , string prefix){\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(prefix == words[i])\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        vector<string> prefix;\\n        int count = 0;\\n        \\n        for(int i = 1 ; i <= s.length() ; i++){\\n            prefix.push_back(s.substr(0,i));\\n        }\\n        \\n        \\n        for(int i = 0 ; i < prefix.size() ; i++){\\n            count = count + linear_search(words , prefix[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int linear_search(vector<string>& words , string prefix){\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(prefix == words[i])\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        vector<string> prefix;\\n        int count = 0;\\n        \\n        for(int i = 1 ; i <= s.length() ; i++){\\n            prefix.push_back(s.substr(0,i));\\n        }\\n        \\n        \\n        for(int i = 0 ; i < prefix.size() ; i++){\\n            count = count + linear_search(words , prefix[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498493,
                "title": "java-solution-easy-100",
                "content": "public static int prefixcount(String[] words, String s) {\\n        int out = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.startsWith(words[i])) {\\n                out++;\\n            }\\n        }\\n        return out;",
                "solutionTags": [],
                "code": "public static int prefixcount(String[] words, String s) {\\n        int out = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.startsWith(words[i])) {\\n                out++;\\n            }\\n        }\\n        return out;",
                "codeTag": "Unknown"
            },
            {
                "id": 2488556,
                "title": "runtime-22-ms-faster-than-18-45-of-c-online-submissions-for-count-prefixes-of-a-given-string",
                "content": "\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n//   upvote if you like\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n//   upvote if you like\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2471556,
                "title": "java-solution-0ms-100-faster-easy-to-understand-linear-search-o-n",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] arr, String s) {\\n        int cnt = 0;\\n        for (String str : arr) {\\n            if (s.startsWith(str)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] arr, String s) {\\n        int cnt = 0;\\n        for (String str : arr) {\\n            if (s.startsWith(str)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402405,
                "title": "easy-and-clear-solution-python3",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            if word == s[:len(word)]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            if word == s[:len(word)]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346554,
                "title": "c-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string sk;\\n        bool istrue;\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n            sk=words[i];\\n            for(int j=0;j<sk.length();j++){\\n                if(sk[j]!=s[j]){\\n                    istrue=false; \\n                    break;\\n                }\\n                else{\\n                     istrue=true;\\n                }\\n            }\\n            \\n            if(istrue==true){\\n                cout<<sk<<endl;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string sk;\\n        bool istrue;\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n            sk=words[i];\\n            for(int j=0;j<sk.length();j++){\\n                if(sk[j]!=s[j]){\\n                    istrue=false; \\n                    break;\\n                }\\n                else{\\n                     istrue=true;\\n                }\\n            }\\n            \\n            if(istrue==true){\\n                cout<<sk<<endl;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2326109,
                "title": "one-liner-python",
                "content": "```\\nreturn sum([1 for word in words if s.startswith(word)])\\n```\\n**Please upvote if you want to see more one liners and simple solutions**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn sum([1 for word in words if s.startswith(word)])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2308148,
                "title": "c-solution-easy-to-understand-one-line",
                "content": "```C#\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) => words.Count(x => s.StartsWith(x));\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) => words.Count(x => s.StartsWith(x));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303504,
                "title": "cpp-trie-solution",
                "content": "```\\n class Trie{\\n        public:\\n        char c;\\n        Trie* ch[26];\\n        int we;\\n        Trie(char d){\\n            c=d;\\n            for(int i=0;i<26;i++) ch[i]=NULL;\\n            we=0;\\n        }\\n    };\\n    Trie* r=new Trie(\\'0\\');\\n    \\n    void add(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            h->ch[ind]=new Trie(s[i]);\\n            h=h->ch[ind];\\n        }\\n        h->we=1;\\n    }\\n    \\n    bool check(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            if(h->ch[ind]==NULL) return 0;\\n            h=h->ch[ind];\\n        }\\n        return 1;\\n    }\\n    int countPrefixes(vector<string>& words, string s) {\\n        add(s);\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            if(check(words[i])){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Trie"
                ],
                "code": "```\\n class Trie{\\n        public:\\n        char c;\\n        Trie* ch[26];\\n        int we;\\n        Trie(char d){\\n            c=d;\\n            for(int i=0;i<26;i++) ch[i]=NULL;\\n            we=0;\\n        }\\n    };\\n    Trie* r=new Trie(\\'0\\');\\n    \\n    void add(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            h->ch[ind]=new Trie(s[i]);\\n            h=h->ch[ind];\\n        }\\n        h->we=1;\\n    }\\n    \\n    bool check(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            if(h->ch[ind]==NULL) return 0;\\n            h=h->ch[ind];\\n        }\\n        return 1;\\n    }\\n    int countPrefixes(vector<string>& words, string s) {\\n        add(s);\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            if(check(words[i])){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200749,
                "title": "python-straightforward",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        countPrefixe = 0\\n        for word in words:\\n            if word in s and word == s[:len(word)]:\\n                countPrefixe += 1\\n        return countPrefixe\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        countPrefixe = 0\\n        for word in words:\\n            if word in s and word == s[:len(word)]:\\n                countPrefixe += 1\\n        return countPrefixe\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197461,
                "title": "javascript-solution-with-foreach",
                "content": "```\\nvar countPrefixes = function(words, s) {    \\n\\n    let count = 0; \\n\\t\\n    words.forEach((word) => {\\n        if( s.startsWith(word) ) \\n\\t\\t\\tcount++;\\n    });\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {    \\n\\n    let count = 0; \\n\\t\\n    words.forEach((word) => {\\n        if( s.startsWith(word) ) \\n\\t\\t\\tcount++;\\n    });\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191967,
                "title": "my-easy-to-understand-2ms-java-code",
                "content": "```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c=0;\\n        for(String i:words)\\n        {\\n            if(s.startsWith(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c=0;\\n        for(String i:words)\\n        {\\n            if(s.startsWith(i))\\n            {\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2181067,
                "title": "python-trie-for-fast-queries",
                "content": "Prefix Tree aka Trie might be an overkill for this easy problem, but when you are not allowed to use startswith and need to reduce time complexity of multiple queries it\\'s a good option - linear scan of path to get sum of all words on the path.\\n\\n```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        self.count = 0\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        root = Node()\\n        \\n        # build a trie\\n        for w in words:\\n            node = root\\n            for c in w:\\n                if c not in node.children:\\n                    node.children[c] = Node()\\n                node = node.children[c]\\n            node.count = 1 if not node.is_word else node.count + 1\\n            node.is_word = True\\n        \\n        # count prefix-words in s\\n        node = root\\n\\n        res = 0\\n        for c in s:\\n            if c in node.children:\\n                node = node.children[c]\\n                res += node.count if node.is_word else 0\\n            else:\\n                break\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        self.count = 0\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        root = Node()\\n        \\n        # build a trie\\n        for w in words:\\n            node = root\\n            for c in w:\\n                if c not in node.children:\\n                    node.children[c] = Node()\\n                node = node.children[c]\\n            node.count = 1 if not node.is_word else node.count + 1\\n            node.is_word = True\\n        \\n        # count prefix-words in s\\n        node = root\\n\\n        res = 0\\n        for c in s:\\n            if c in node.children:\\n                node = node.children[c]\\n                res += node.count if node.is_word else 0\\n            else:\\n                break\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147734,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans=0;\\n        for(auto w : words)\\n        {\\n            int count=0;\\n            for(int i=0;i<w.length();i++)\\n            {\\n               if(w[i]==s[i])\\n                   count++; \\n            }\\n            if(count==w.length())\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans=0;\\n        for(auto w : words)\\n        {\\n            int count=0;\\n            for(int i=0;i<w.length();i++)\\n            {\\n               if(w[i]==s[i])\\n                   count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2143292,
                "title": "c-very-easy-solution-using-sets",
                "content": "```\\nint countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        set<string>ss;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ss.insert(s.substr(0,i+1));\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(ss.find(words[i])!=ss.end())\\n                count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        set<string>ss;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ss.insert(s.substr(0,i+1));\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(ss.find(words[i])!=ss.end())\\n                count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2140038,
                "title": "c-easy-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n       unordered_map<string,int>harsh;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            harsh[s.substr(0,i+1)]++;\\n        }\\n        int cnt=0;\\n        for(auto val:words)\\n        {\\n            if(harsh.find(val) != harsh.end())\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n       unordered_map<string,int>harsh;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            harsh[s.substr(0,i+1)]++;\\n        }\\n        int cnt=0;\\n        for(auto val:words)\\n        {\\n            if(harsh.find(val) != harsh.end())\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132698,
                "title": "easy-java-solution-faster-100",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int sum = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                sum++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int sum = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                sum++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098364,
                "title": "python-easy-beginer-friendly",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, a: List[str], s: str) -> int:\\n        r=0\\n        for i in a:\\n            if len(i)<=len(s) and i==s[:len(i)]:\\n                r+=1\\n        return r\\n```\\n![image](https://assets.leetcode.com/users/images/c570329e-69a5-4674-aff5-3562d8a29ea8_1654088247.904313.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, a: List[str], s: str) -> int:\\n        r=0\\n        for i in a:\\n            if len(i)<=len(s) and i==s[:len(i)]:\\n                r+=1\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070262,
                "title": "fastest-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c = 0;\\n        for(String word:words)\\n            if(s.startsWith(word))\\n                c++;\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c = 0;\\n        for(String word:words)\\n            if(s.startsWith(word))\\n                c++;\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2048287,
                "title": "python3-two-1-liners",
                "content": "class Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        return sum(word == s[:len(word)] for word in words)\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\n        return sum(s.find(word) == 0 for word in words)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        return sum(word == s[:len(word)] for word in words)\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\n        return sum(s.find(word) == 0 for word in words)",
                "codeTag": "Java"
            },
            {
                "id": 2037971,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int res=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int flag=0;\\n            for(int j=0;j<w[i].size();j++)\\n            {\\n                if(w[i][j]!=s[j])\\n                    flag=1;\\n            }\\n            if (flag==0)\\n                res++;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int res=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int flag=0;\\n            for(int j=0;j<w[i].size();j++)\\n            {\\n                if(w[i][j]!=s[j])\\n                    flag=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2022531,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([1 for w in words if w == s[:len(w)]])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([1 for w in words if w == s[:len(w)]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014637,
                "title": "3ms-beats-95-c-submissions-easytounderstand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(auto it:a){\\n            int m=it.size();\\n            if(m<=n){\\n                int f=1;\\n                int k=0;\\n                for(auto i:it)\\n                    if(i!=s[k++])\\n                        {\\n                            f=0;\\n                            break;\\n                        }\\n                if(f)ans++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(auto it:a){\\n            int m=it.size();\\n            if(m<=n){\\n                int f=1;\\n                int k=0;\\n                for(auto i:it)\\n                    if(i!=s[k++])\\n                        {\\n                            f=0;\\n                            break;\\n                        }\\n                if(f)ans++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013095,
                "title": "runtime-12-ms-c-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string str=\"\";\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            str+=s[i];\\n            for(int j=0;j<words.size();j++)\\n            {\\n                if(words[j]==str)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string str=\"\";\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            str+=s[i];\\n            for(int j=0;j<words.size();j++)\\n            {\\n                if(words[j]==str)\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2006744,
                "title": "c-efficient-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool contains(vector<string> vec, string & elem){\\n    bool result = false;\\n    if( find(vec.begin(), vec.end(), elem) != vec.end() )\\n    {\\n        result = true;\\n    }\\n    return result;\\n    }\\n    \\n    vector<string> vec;\\n    string temp=\"\";\\n    int c=0;\\n    int countPrefixes(vector<string>& words, string s) {\\n        for(int i=0;i<s.size();i++){\\n            temp+=s[i];\\n            vec.push_back(temp);\\n        }\\n        for(int i=0;i<words.size();i++){\\n            if(contains(vec,words[i])) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool contains(vector<string> vec, string & elem){\\n    bool result = false;\\n    if( find(vec.begin(), vec.end(), elem) != vec.end() )\\n    {\\n        result = true;\\n    }\\n    return result;\\n    }\\n    \\n    vector<string> vec;\\n    string temp=\"\";\\n    int c=0;\\n    int countPrefixes(vector<string>& words, string s) {\\n        for(int i=0;i<s.size();i++){\\n            temp+=s[i];\\n            vec.push_back(temp);\\n        }\\n        for(int i=0;i<words.size();i++){\\n            if(contains(vec,words[i])) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998165,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if s.startswith(words[i]):\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if s.startswith(words[i]):\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997765,
                "title": "c-using-substr",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans1 = 0;\\n        for(int i=0;i<=s.size();i++){\\n            string h = s.substr(0,i);\\n            int x = count(words.begin(),words.end(),h);\\n            if(x>0)    ans1+=x;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans1 = 0;\\n        for(int i=0;i<=s.size();i++){\\n            string h = s.substr(0,i);\\n            int x = count(words.begin(),words.end(),h);\\n            if(x>0)    ans1+=x;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995903,
                "title": "go-golang-solution",
                "content": "```go\\nfunc countPrefixes(words []string, s string) int {\\n    ans := 0\\n    for _, word := range words {\\n        n := len(word)\\n        if n > len(s) { continue }\\n        if word == s[:n] { ans++ }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc countPrefixes(words []string, s string) int {\\n    ans := 0\\n    for _, word := range words {\\n        n := len(word)\\n        if n > len(s) { continue }\\n        if word == s[:n] { ans++ }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995794,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        \\n        for(String str : words){\\n \\xA0 \\xA0 \\xA0 \\xA0 if\\xA0(s.indexOf(str)==0) count++;\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n \\xA0 \\xA0 \\xA0 \\xA0return count;\\n \\xA0 \\xA0}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        \\n        for(String str : words){\\n \\xA0 \\xA0 \\xA0 \\xA0 if\\xA0(s.indexOf(str)==0) count++;\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n \\xA0 \\xA0 \\xA0 \\xA0return count;\\n \\xA0 \\xA0}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995491,
                "title": "c-3-lines-no-substr-copy-or-global-find",
                "content": "Use `string::compare` to avoid substring copy and whole string scanning.\\n```\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(words.begin(), words.end(), [&](string &w) {\\n        return !s.compare(0, w.size(), w);\\n    });\\n}\\n```\\n\\nEven better if LeetCode allows C++20 so that we could use the standard `string::starts_with`.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(words.begin(), words.end(), [&](string &w) {\\n        return !s.compare(0, w.size(), w);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995485,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(w == s[:len(w)] for w in words)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(w == s[:len(w)] for w in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995010,
                "title": "ruby-solution",
                "content": "```\\n# @param {String[]} words\\n# @param {String} s\\n# @return {Integer}\\ndef count_prefixes(words, s)\\n    count = 0\\n    words.each {|word| count += 1 if word == s[0...word.length]}\\n    count\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {String[]} words\\n# @param {String} s\\n# @return {Integer}\\ndef count_prefixes(words, s)\\n    count = 0\\n    words.each {|word| count += 1 if word == s[0...word.length]}\\n    count\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1994972,
                "title": "c",
                "content": "Just use substring to check is the same or not,\\nprefix must be a substring of string and length will be prefix self length.\\n[C# testcase](https://github.com/AhChao/OnceLeetCodePerDay/blob/main/OnceLeetCodePerDay/Contest/0430/Tests/L6051CountPrefixesOfAGivenStringTests.cs)\\n```\\npublic int CountPrefixes(string[] words, string s) {\\n\\tvar result = 0;\\n\\tforeach(var i in words)\\n\\t{\\n\\t\\tif(i.Length > s.Length) continue;\\n\\t\\tresult += s.Substring(0,i.Length) == i ? 1 : 0;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int CountPrefixes(string[] words, string s) {\\n\\tvar result = 0;\\n\\tforeach(var i in words)\\n\\t{\\n\\t\\tif(i.Length > s.Length) continue;\\n\\t\\tresult += s.Substring(0,i.Length) == i ? 1 : 0;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994856,
                "title": "python-hashset",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        c = 0 \\n        n = len(words)\\n        d = []\\n        for i in range(len(s)):\\n            d.append(s[:i+1])\\n        \\n        dd = set(d)\\n        \\n        for i in words:\\n            if i in dd:\\n                c += 1 \\n        return c\\n```\\n\\nDont miss to **Upvote** Coders, wish your very **great journey of coding**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        c = 0 \\n        n = len(words)\\n        d = []\\n        for i in range(len(s)):\\n            d.append(s[:i+1])\\n        \\n        dd = set(d)\\n        \\n        for i in words:\\n            if i in dd:\\n                c += 1 \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994706,
                "title": "easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        map<string, int> mpp;\\n        int ans = 0;\\n        string str;\\n        for(auto str : words) mpp[str]++;\\n        for(int i = 0; i < s.size(); i++){\\n                str += s[i];\\n                ans += mpp[str];\\n                cout << str << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        map<string, int> mpp;\\n        int ans = 0;\\n        string str;\\n        for(auto str : words) mpp[str]++;\\n        for(int i = 0; i < s.size(); i++){\\n                str += s[i];\\n                ans += mpp[str];\\n                cout << str << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994667,
                "title": "3-liner-easy-to-implement",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++) if(words[i] == s.substr(0,words[i].size())) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++) if(words[i] == s.substr(0,words[i].size())) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994641,
                "title": "one-liner-easy-c-substr",
                "content": "```\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0; i < words.size(); i++)\\n            if(words[i].substr(0,words[i].size()) == s.substr(0,words[i].size()))\\n                count++;\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0; i < words.size(); i++)\\n            if(words[i].substr(0,words[i].size()) == s.substr(0,words[i].size()))\\n                count++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994629,
                "title": "very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c = 0;\\n        unordered_map<string,int> hmp;\\n        int l = s.length();\\n        for(int i=0; i<words.size(); i++) {\\n            hmp[words[i]]++;\\n        }\\n        for(int i=1; i<=l; i++) {\\n            string str = s.substr(0,i);\\n            if(hmp.find(str)!=hmp.end())\\n                c += hmp[str];\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c = 0;\\n        unordered_map<string,int> hmp;\\n        int l = s.length();\\n        for(int i=0; i<words.size(); i++) {\\n            hmp[words[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1994607,
                "title": "simple-c-substring",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        int num = 0;\\n        for(auto str:words){\\n            int len = str.size();\\n            string sub = s.substr(0,len);\\n            if(str == sub)\\n                num++;\\n        }\\n        \\n        return num;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        int num = 0;\\n        for(auto str:words){\\n            int len = str.size();\\n            string sub = s.substr(0,len);\\n            if(str == sub)\\n                num++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1994580,
                "title": "java-startswith-easiest",
                "content": "```\\nclass Solution\\n{\\n    public int countPrefixes(String[] words, String s)\\n    {\\n        int count = 0;\\n        for(String word : words)\\n            if(s.startsWith(word))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countPrefixes(String[] words, String s)\\n    {\\n        int count = 0;\\n        for(String word : words)\\n            if(s.startsWith(word))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994576,
                "title": "c-3-lines-find-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int a=0;\\n        for(auto i:words)   a += s.find(i)==0;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int a=0;\\n        for(auto i:words)   a += s.find(i)==0;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994564,
                "title": "c-4-lines-elegant-solution-using-std-mismatch",
                "content": "Built in C++ functions always comes handy in contests \\uD83D\\uDCAF\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int res = 0;\\n        for(auto i: a)\\n            if(mismatch(i.begin(), i.end(), s.begin(), s.end()).first == i.end()) res++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int res = 0;\\n        for(auto i: a)\\n            if(mismatch(i.begin(), i.end(), s.begin(), s.end()).first == i.end()) res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994561,
                "title": "simple-elegant-4-line-cpp-code-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int ct=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.substr(0,w[i].length())==w[i]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLet me know if you\\'d like to add any point of if I have missed anything.\\nHappy Coding!",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int ct=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.substr(0,w[i].length())==w[i]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093620,
                "title": "easy-one-liner-c",
                "content": "\\n# Approach\\nUsing Count and StartsWith\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) {\\n        return words.Count(i => s.StartsWith(i));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) {\\n        return words.Count(i => s.StartsWith(i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088337,
                "title": "java-best-ever-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085650,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n\\n        for(int i=0; i<words.size(); i++){\\n            if (s.rfind(words[i], 0) == 0) { \\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n\\n        for(int i=0; i<words.size(); i++){\\n            if (s.rfind(words[i], 0) == 0) { \\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083046,
                "title": "detailed-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to find how many the elements in a words(list) can be prefixes to the string **S.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have to take a variabe named counter.\\nstr\\n```python []\\ncount=0\\n\\n```\\nThen iterate through the loop to find whether the **elements in list  will match to the string S.** \\n```python []\\n    s[:len(i)]==i:\\n\\n```\\nthen increase the count value by 1\\n```python []\\ncount+=1\\n\\n```\\nFinally return the value of the count.\\n```python []\\nreturn count\\n\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if s[:len(i)]==i:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```python []\\ncount=0\\n\\n```\n```python []\\n    s[:len(i)]==i:\\n\\n```\n```python []\\ncount+=1\\n\\n```\n```python []\\nreturn count\\n\\n```\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if s[:len(i)]==i:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081682,
                "title": "easy-to-understand-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIteratively check if each words is prefix or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the count.\\n2. Iterate through each word.\\n3. If the word is the prefix of s, increment count.\\n4. Return count.\\n\\n# Complexity\\n- Time complexity: O(n*m) , n=number of words, m=size of each word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        count=0\\n        for w in words:\\n            n=len(w)\\n            if n<=len(s) and w==s[:n]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        count=0\\n        for w in words:\\n            n=len(w)\\n            if n<=len(s) and w==s[:n]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079643,
                "title": "simple-java-solution-100-beats-4-lines-of-code-with-expanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please Upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        // Variable to store the value of answer.\\n        int ans=0;\\n        // Iterate through all the strings of the array.\\n        for(String word:words){\\n            // If \\'s\\' starts with the current string then increse the answer count by one.\\n            if(s.startsWith(word)) ans++;\\n        }\\n        // Finaly return the answer.\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        // Variable to store the value of answer.\\n        int ans=0;\\n        // Iterate through all the strings of the array.\\n        for(String word:words){\\n            // If \\'s\\' starts with the current string then increse the answer count by one.\\n            if(s.startsWith(word)) ans++;\\n        }\\n        // Finaly return the answer.\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079160,
                "title": "c-100-faster-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    \\tint countOfPattern = 0;\\n\\n    \\tint inputSize = words.size();\\n\\n    \\tfor (int i = 0; i < inputSize; ++i)\\n    \\t{\\n    \\t\\tif(isPrefix(s,words[i])){\\n                countOfPattern++;\\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn countOfPattern;\\n\\n    }\\n\\n\\tbool isPrefix(string str,string pattern){\\n\\n\\t\\tint size = pattern.size();\\n\\n\\t\\tfor (int i = 0; i < size; ++i)\\n\\t\\t{\\n\\t\\t\\tif(str[i] != pattern[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    \\tint countOfPattern = 0;\\n\\n    \\tint inputSize = words.size();\\n\\n    \\tfor (int i = 0; i < inputSize; ++i)\\n    \\t{\\n    \\t\\tif(isPrefix(s,words[i])){\\n                countOfPattern++;\\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn countOfPattern;\\n\\n    }\\n\\n\\tbool isPrefix(string str,string pattern){\\n\\n\\t\\tint size = pattern.size();\\n\\n\\t\\tfor (int i = 0; i < size; ++i)\\n\\t\\t{\\n\\t\\t\\tif(str[i] != pattern[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077227,
                "title": "beats-100-only-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])) count ++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])) count ++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076286,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073928,
                "title": "beats-100-00-of-users-with-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n         int count=0;\\n        for(String word: words)\\n        {\\n            if(s.indexOf(word)==0)\\n            {\\n                  count++;\\n            }\\n        }\\n        \\n    return count;}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n         int count=0;\\n        for(String word: words)\\n        {\\n            if(s.indexOf(word)==0)\\n            {\\n                  count++;\\n            }\\n        }\\n        \\n    return count;}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071268,
                "title": "naive-method-96-beats-simple-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if len(i)<=len(s):\\n                c=0\\n                for j in range(len(i)):\\n                    if s[j]!=i[j]:\\n                        c=1\\n                        break\\n                if c==0:\\n                    count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if len(i)<=len(s):\\n                c=0\\n                for j in range(len(i)):\\n                    if s[j]!=i[j]:\\n                        c=1\\n                        break\\n                if c==0:\\n                    count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069485,
                "title": "easy-c-soln",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int m = s.size();\\n        int count = 0;\\n        string str = \"\";\\n        for(int i=0; i<m; i++){\\n            str += s[i];\\n            for(int j=0; j<n; j++){\\n                if(words[j] == str){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int m = s.size();\\n        int count = 0;\\n        string str = \"\";\\n        for(int i=0; i<m; i++){\\n            str += s[i];\\n            for(int j=0; j<n; j++){\\n                if(words[j] == str){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067888,
                "title": "1-line-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int CountPrefixes(string[] words, string s)\\n    {\\n        return words.Count(s.StartsWith);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int CountPrefixes(string[] words, string s)\\n    {\\n        return words.Count(s.StartsWith);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064105,
                "title": "1-line-of-code-beast-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n func countPrefixes(_ words: [String], _ s: String) -> Int {\\n    \\n    return words.filter {s.hasPrefix($0)}.count\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n func countPrefixes(_ words: [String], _ s: String) -> Int {\\n    \\n    return words.filter {s.hasPrefix($0)}.count\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063523,
                "title": "c-solution-by-ajeet20-iit-kanpur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n        int count = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            string str = s.substr(0, i+1);\\n            for(int j = 0; j < words.size(); j++) {\\n                if(words[j] == str) count++;\\n            }\\n        }    \\n        return count;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n        int count = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            string str = s.substr(0, i+1);\\n            for(int j = 0; j < words.size(); j++) {\\n                if(words[j] == str) count++;\\n            }\\n        }    \\n        return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062738,
                "title": "hash-map-unordered-set-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        unordered_map<string,int> map;\\n        for(auto it :words)\\n        {\\n            map[it]++;\\n        }\\n        int ans  = 0;\\n        unordered_set<string> seti(words.begin(), words.end());\\n        for(int j = 1;j <= s.size();j++)\\n        {\\n            string temp = s.substr(0,j);\\n            if(seti.find(temp) != seti.end())\\n            {\\n                seti.erase(temp);\\n                ans += map[temp]++;\\n                map.erase(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        unordered_map<string,int> map;\\n        for(auto it :words)\\n        {\\n            map[it]++;\\n        }\\n        int ans  = 0;\\n        unordered_set<string> seti(words.begin(), words.end());\\n        for(int j = 1;j <= s.size();j++)\\n        {\\n            string temp = s.substr(0,j);\\n            if(seti.find(temp) != seti.end())\\n            {\\n                seti.erase(temp);\\n                ans += map[temp]++;\\n                map.erase(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061412,
                "title": "using-hashset-without-any-in-build-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0 ; \\n        Set<String> hs = new HashSet<>() ;\\n        for(int j=1;j<=s.length();j++) {\\n               hs.add(s.substring(0,j)) ; \\n            }\\n        for(int i = 0 ; i<words.length ; i++){\\n            if(words[i].length()>s.length())continue ; \\n            // for(int j=1;j<=s.length();j++) {\\n            //     if(words[i].equals(s.substring(0,j))) {count++ ; break ;}\\n            // }\\n            if(hs.contains(words[i]))count++ ; \\n        }\\n        return count ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0 ; \\n        Set<String> hs = new HashSet<>() ;\\n        for(int j=1;j<=s.length();j++) {\\n               hs.add(s.substring(0,j)) ; \\n            }\\n        for(int i = 0 ; i<words.length ; i++){\\n            if(words[i].length()>s.length())continue ; \\n            // for(int j=1;j<=s.length();j++) {\\n            //     if(words[i].equals(s.substring(0,j))) {count++ ; break ;}\\n            // }\\n            if(hs.contains(words[i]))count++ ; \\n        }\\n        return count ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050484,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n      return words.filter((item) => s.startsWith(item)).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n      return words.filter((item) => s.startsWith(item)).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050311,
                "title": "simple-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n   let count = 0\\n    for(let i = 0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n            count = count + 1\\n         }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n   let count = 0\\n    for(let i = 0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n            count = count + 1\\n         }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037732,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c = 0;\\n        for(int i = 1; i<=s.length(); i++)\\n        {\\n            String s1 = s.substring(0,i);\\n            for(int j = 0; j<words.length; j++)\\n            {\\n                if(words[j].equals(s1))\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c = 0;\\n        for(int i = 1; i<=s.length(); i++)\\n        {\\n            String s1 = s.substring(0,i);\\n            for(int j = 0; j<words.length; j++)\\n            {\\n                if(words[j].equals(s1))\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031001,
                "title": "100-beats-in-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023312,
                "title": "begineers-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {int a=0;\\n    for(int j=0;j<s.length();j++){\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals (s.substring(0,j+1)))a++;\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {int a=0;\\n    for(int j=0;j<s.length();j++){\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals (s.substring(0,j+1)))a++;\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014679,
                "title": "3lines-code-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String str:words)\\n        {\\n            if(s.indexOf(str)==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String str:words)\\n        {\\n            if(s.indexOf(str)==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011936,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        String temp = \"\";\\n        for(int i =0;i<s.length();i++){\\n            temp+=Character.toString(s.charAt(i));\\n            for(String x:words)\\n                if(temp.equals(x))\\n                    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        String temp = \"\";\\n        for(int i =0;i<s.length();i++){\\n            temp+=Character.toString(s.charAt(i));\\n            for(String x:words)\\n                if(temp.equals(x))\\n                    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011673,
                "title": "easy-python-linear-search-82-72-faster",
                "content": "faster than\\xA082.72%\\n\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0        \\n        # make s into tree.\\n        \\n        # traverse for each to see. If not, then not. \\n        for word in words:\\n            \\n            # word longer, cannot be prefix\\n            if len(word) > len(s):\\n                continue\\n                \\n            for i, ch in enumerate(word):\\n                \\n                if ch != s[i]:\\n                    break\\n                    \\n                if i == len(word) - 1:\\n                    count += 1\\n        \\n        return count\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0        \\n        # make s into tree.\\n        \\n        # traverse for each to see. If not, then not. \\n        for word in words:\\n            \\n            # word longer, cannot be prefix\\n            if len(word) > len(s):\\n                continue\\n                \\n            for i, ch in enumerate(word):\\n                \\n                if ch != s[i]:\\n                    break\\n                    \\n                if i == len(word) - 1:\\n                    count += 1\\n        \\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007127,
                "title": "easy-java-solution-0-ms-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i]))\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i]))\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005419,
                "title": "world-easy-solution-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let number=0;\\n    for(let i = 0 ; i< words.length; i++){\\n        let a = checkme(words[i], s);\\n        if(a){\\n            number++;\\n        }\\n    }\\n    return number;\\n    \\n};\\nfunction checkme(word, s){\\n    // if(word.length>s.length){\\n        for(let i = 0 ; i< word.length; i++){\\n            if(word[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let number=0;\\n    for(let i = 0 ; i< words.length; i++){\\n        let a = checkme(words[i], s);\\n        if(a){\\n            number++;\\n        }\\n    }\\n    return number;\\n    \\n};\\nfunction checkme(word, s){\\n    // if(word.length>s.length){\\n        for(let i = 0 ; i< word.length; i++){\\n            if(word[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    // }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004148,
                "title": "easy-c-solution-using-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            if(s.find(str)==0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            if(s.find(str)==0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000672,
                "title": "typescript-1-line-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nconst countPrefixes = (words: string[], s: string): number => words.reduce((a, w) => s.startsWith(w) ? a + 1 : a, 0)\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nconst countPrefixes = (words: string[], s: string): number => words.reduce((a, w) => s.startsWith(w) ? a + 1 : a, 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989630,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n int countPrefixes(List<String> words, String s) {\\n  int result = 0;\\n\\n  for (int i = 0; i < words.length; i++) {\\n    if (s.startsWith(words[i])) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n int countPrefixes(List<String> words, String s) {\\n  int result = 0;\\n\\n  for (int i = 0; i < words.length; i++) {\\n    if (s.startsWith(words[i])) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986090,
                "title": "simple-java-solution-no-sms-nor-registration-required",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a word is a prefix of the string s, it means the string s starts with that word. The Java String class provides a method startsWith() that can be used to determine if a string starts with a certain prefix. We can use this method to simplify our solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a Counter: Start by initializing a counter to zero. This will keep track of how many words from the array are prefixes of s.\\n\\n2. Iterate Over the Words: Go through each word in the words array.\\n\\n3. Check for Prefix: For each word, check if s starts with that word using the startsWith() method. If it does, increment the counter.\\n\\n4. Return the Counter: After checking all the words, return the counter.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the number of words and m is the average length of a word. This is because the startsWith() method compares characters of the word with the string s and, in the worst case, this can be O(m).\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nas we are using only a fixed amount of extra space (the counter) regardless of the size of the input.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n\\n        for (int i = 0; i < words.length; i++){\\n            if (s.startsWith(words[i])){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n\\n        for (int i = 0; i < words.length; i++){\\n            if (s.startsWith(words[i])){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981590,
                "title": "easy-python-solution-slicing-string",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        output = 0 \\n        for i in words :\\n            if i == s[:len(i)] :\\n                output += 1\\n        return output\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        output = 0 \\n        for i in words :\\n            if i == s[:len(i)] :\\n                output += 1\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974113,
                "title": "check-prefix-java-o-n",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countPrefixes(String[] words, String s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(String word: words){\\n\\t\\t\\t\\tint temp = word.length(); // substring length\\n\\t\\t\\t\\tif((s.length() >= temp) && word.equals(s.substring(0,temp))) count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\t\\tpublic int countPrefixes(String[] words, String s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(String word: words){\\n\\t\\t\\t\\tint temp = word.length(); // substring length\\n\\t\\t\\t\\tif((s.length() >= temp) && word.equals(s.substring(0,temp))) count++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3971387,
                "title": "one-line-solution-using-list-comprehensions",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([words.count(s[:i]) for i in range(1, len(s)+1)])\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([words.count(s[:i]) for i in range(1, len(s)+1)])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954226,
                "title": "easy",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if i == s[0:len(i)]: \\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if i == s[0:len(i)]: \\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946446,
                "title": "easy-php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function countPrefixes($words, $s) {\\n        $count = 0;\\n        $sLen = strlen($s);\\n        for($i=1; $i<=$sLen; $i++){\\n            $str = substr($s,0,$i);\\n            foreach($words as $word){\\n                if($word == $str){\\n                    $count++;\\n                }\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function countPrefixes($words, $s) {\\n        $count = 0;\\n        $sLen = strlen($s);\\n        for($i=1; $i<=$sLen; $i++){\\n            $str = substr($s,0,$i);\\n            foreach($words as $word){\\n                if($word == $str){\\n                    $count++;\\n                }\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941401,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n  const hasPrefix = words.filter( string => {\\n    return s.startsWith(string)\\n  })\\n\\n  return hasPrefix.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n  const hasPrefix = words.filter( string => {\\n    return s.startsWith(string)\\n  })\\n\\n  return hasPrefix.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941261,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int countPrefixes(List<String> words, String s) {\\n      var c = 0;\\n      for (int i = 0; i < words.length; i++) {\\n          if (s.startsWith(words[i])) {\\n              c += 1;\\n          }\\n      }\\n\\n      return c;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int countPrefixes(List<String> words, String s) {\\n      var c = 0;\\n      for (int i = 0; i < words.length; i++) {\\n          if (s.startsWith(words[i])) {\\n              c += 1;\\n          }\\n      }\\n\\n      return c;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940064,
                "title": "javascript-single-line-functional-declarative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    return words.filter(word => s.startsWith(word)).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    return words.filter(word => s.startsWith(word)).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937084,
                "title": "javascript-beats-32-51",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count=0;\\n   for (let index = 0; index < words.length; index++) if (s.startsWith(words[index])) count += 1;\\n   return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count=0;\\n   for (let index = 0; index < words.length; index++) if (s.startsWith(words[index])) count += 1;\\n   return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936190,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def countPrefixes(self, words, s):\\n        count = 0\\n        for i in range(len(words)):\\n            item = words[i]\\n            if s[0 : len(item)] == item:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPrefixes(self, words, s):\\n        count = 0\\n        for i in range(len(words)):\\n            item = words[i]\\n            if s[0 : len(item)] == item:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932521,
                "title": "simple-approach-runtime-60ms-beat-93-in-runtime-and-memory",
                "content": "# Intuition\\n=>check prefix of each string in word if equal then increment the count otherwise pass on\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n=>create count equal to zero and iterate a loop and check for each string in word if its string equal to starting elements of prefix string increment the count otherwise pass\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        cnt=0\\n        for i in words:\\n            if i==s[:len(i)]:\\n                cnt+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        cnt=0\\n        for i in words:\\n            if i==s[:len(i)]:\\n                cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931816,
                "title": "ez-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int sum=0;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i].size()>s.size()){\\n                continue;\\n            }\\n            else {\\n                if(words[i]==s.substr(0,words[i].size())){\\n                    sum++;\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int sum=0;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i].size()>s.size()){\\n                continue;\\n            }\\n            else {\\n                if(words[i]==s.substr(0,words[i].size())){\\n                    sum++;\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923639,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n# - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923636,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1732909,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 2039571,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1908446,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1875133,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1676289,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if Number Has Equal Digit Count and Digit Value",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string <code>num</code> of length <code>n</code> consisting of digits.</p>\n\n<p>Return <code>true</code> <em>if for <strong>every</strong> index </em><code>i</code><em> in the range </em><code>0 &lt;= i &lt; n</code><em>, the digit </em><code>i</code><em> occurs </em><code>num[i]</code><em> times in </em><code>num</code><em>, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;1210&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\nnum[0] = &#39;1&#39;. The digit 0 occurs once in num.\nnum[1] = &#39;2&#39;. The digit 1 occurs twice in num.\nnum[2] = &#39;1&#39;. The digit 2 occurs once in num.\nnum[3] = &#39;0&#39;. The digit 3 occurs zero times in num.\nThe condition holds true for every index in &quot;1210&quot;, so return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;030&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\nnum[0] = &#39;0&#39;. The digit 0 should occur zero times, but actually occurs twice in num.\nnum[1] = &#39;3&#39;. The digit 1 should occur three times, but actually occurs zero times in num.\nnum[2] = &#39;0&#39;. The digit 2 occurs zero times in num.\nThe indices 0 and 1 both violate the condition, so return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == num.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>num</code> consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2083839,
                "title": "brute-force-and-one-liner",
                "content": "I am sure some clever solution exists, but I did not want to spend too much time.\\n\\nYou can realize that the number of strings that match the criteria is very small - 7, to be exact (see the second solution below).\\n\\n#### Brute-Force\\n**C++**\\n```cpp\\nbool digitCount(string num) {\\n    int cnt[10] = {};\\n    for (auto n : num)\\n        ++cnt[n - \\'0\\'];\\n    for (int i = 0; i < num.size(); ++i)\\n        if (cnt[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n}\\n```\\n\\n#### One-Liner\\n```cpp\\nbool digitCount(string &num) {\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool digitCount(string num) {\\n    int cnt[10] = {};\\n    for (auto n : num)\\n        ++cnt[n - \\'0\\'];\\n    for (int i = 0; i < num.size(); ++i)\\n        if (cnt[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n}\\n```\n```cpp\\nbool digitCount(string &num) {\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084196,
                "title": "java-using-freq-array-easy-straightforward-solution",
                "content": "***UpVote if u find this Solution Useful***\\n\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArr = new int[10];  // n = 10 given in constraints;\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArr[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';  //freq of each indexValue;\\n            freqArr[i] = freqArr[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArr[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArr = new int[10];  // n = 10 given in constraints;\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArr[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';  //freq of each indexValue;\\n            freqArr[i] = freqArr[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArr[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083864,
                "title": "java-python-3-simple-code",
                "content": "```java\\n    public boolean digitCount(String num) {\\n        int[] cnt = new int[11];\\n        char[] charArr = num.toCharArray();\\n        for (char d : charArr) {\\n            ++cnt[d - \\'0\\'];\\n        }\\n        for (int i = 0; i < charArr.length; ++i) {\\n            if (cnt[i] != charArr[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(map(int, num))\\n        return all(c[i] == int(d) for i, d in enumerate(num))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean digitCount(String num) {\\n        int[] cnt = new int[11];\\n        char[] charArr = num.toCharArray();\\n        for (char d : charArr) {\\n            ++cnt[d - \\'0\\'];\\n        }\\n        for (int i = 0; i < charArr.length; ++i) {\\n            if (cnt[i] != charArr[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(map(int, num))\\n        return all(c[i] == int(d) for i, d in enumerate(num))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2083791,
                "title": "confusing-yet-simple-hashmap-solution-c",
                "content": "This question was really easy, but head scratching at the same time. I had to waste so much time only because of the confusion to chose number or character type hashmap.\\nSo, for simplicity we will maintain a int to int hashmap, which will store the frequency of a particular number.\\nThen for every index, **we have to check if the frequency of that index in hashmap is equal to the number at that index**.\\nHere is the solution too \\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mpp;\\n        int n= num.length();\\n        for(auto it:num){\\n            int x = it - \\'0\\';\\n            mpp[x]++; // Store the frequency of the char as a number\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = num[i] - \\'0\\'; // get the char as number\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(mpp[i] != x) // f the number is not equal to its frequency we return false\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n\\n**Approach 2:**\\nWe just count the occurences of that index in the string. Thanks to @VisD566 for this approach.\\n\\n```\\nbool digitCount(string s) {\\n    for(int i=0; i<s.size(); i++){\\n        if(count(s.begin(), s.end(), i+\\'0\\') !=  s[i]-\\'0\\')\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mpp;\\n        int n= num.length();\\n        for(auto it:num){\\n            int x = it - \\'0\\';\\n            mpp[x]++; // Store the frequency of the char as a number\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = num[i] - \\'0\\'; // get the char as number\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(mpp[i] != x) // f the number is not equal to its frequency we return false\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```\\nbool digitCount(string s) {\\n    for(int i=0; i<s.size(); i++){\\n        if(count(s.begin(), s.end(), i+\\'0\\') !=  s[i]-\\'0\\')\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083892,
                "title": "c-map-solution-o-n-easy-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char, int> mpp;\\n        \\n        for(int i=0; i<num.size(); i++)\\n            mpp[num[i]]++;\\n        \\n\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            // cout<<c<<endl;\\n            if(num[i] != \\'0\\' + mpp[c]){\\n                // cout<<num[i]<<\" \"<<mpp[c]<<endl;\\n                return false;\\n            }\\n                \\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**Check out my youtube channel for related content\\nhttps://www.youtube.com/@ignition548/featured**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char, int> mpp;\\n        \\n        for(int i=0; i<num.size(); i++)\\n            mpp[num[i]]++;\\n        \\n\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            // cout<<c<<endl;\\n            if(num[i] != \\'0\\' + mpp[c]){\\n                // cout<<num[i]<<\" \"<<mpp[c]<<endl;\\n                return false;\\n            }\\n                \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3164855,
                "title": "easy-python3-solution-using-count",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if int(num[i]) != num.count(str(i)):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if int(num[i]) != num.count(str(i)):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083889,
                "title": "straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            umap[n]++;\\n        }\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            \\n            //Number of times expected != Number of times occured \\n            if(n!=umap[i])\\n                return false;\\n                \\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            umap[n]++;\\n        }\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            \\n            //Number of times expected != Number of times occured \\n            if(n!=umap[i])\\n                return false;\\n                \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083808,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         \\n        int  indexCount[] = new int[10];\\n        \\n        for(char c:num.toCharArray()){\\n            indexCount[c-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(Character.getNumericValue(num.charAt(i)) != indexCount[i])\\n            return false;   \\n        }\\n            \\n        return true;\\n    }\\n}\\n   \\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         \\n        int  indexCount[] = new int[10];\\n        \\n        for(char c:num.toCharArray()){\\n            indexCount[c-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(Character.getNumericValue(num.charAt(i)) != indexCount[i])\\n            return false;   \\n        }\\n            \\n        return true;\\n    }\\n}\\n   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132635,
                "title": "simple-and-fast-javascript-typescript-solution",
                "content": "My simple and fast JS/TS solution:\\n```\\nfunction digitCount(num: string): boolean {\\n    const arr = Array(num.length).fill(0);\\n    for (const char of num) {\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```\\n\\nResult:\\nRuntime:\\xA073 ms, faster than\\xA097.44%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Check if Number Has Equal Digit Count and Digit Value.\\nMemory Usage:\\xA044.5 MB, less than\\xA053.85%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Check if Number Has Equal Digit Count and Digit Value.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction digitCount(num: string): boolean {\\n    const arr = Array(num.length).fill(0);\\n    for (const char of num) {\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083994,
                "title": "python-3-using-counter-fast-solution-one-liner",
                "content": "Approach: Create a dict storing frequency of each number and then just compare the index with frequency.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```\\n\\nTwo-Liner:\\n\\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.Counter(num)\\n        return all([int(num[i])==d.get(str(i), 0) for i in range(len(num))])\\n```\\n\\nOne Liner (slight modification):\\n\\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return all([int(num[i])==Counter(num)[f\\'{i}\\'] for i in range(len(num))])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.Counter(num)\\n        return all([int(num[i])==d.get(str(i), 0) for i in range(len(num))])\\n```\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return all([int(num[i])==Counter(num)[f\\'{i}\\'] for i in range(len(num))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084001,
                "title": "brute-force-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n             mp[num[i]]++;\\n        }\\n        for(auto ele: mp)\\n        {\\n            \\n            if(ele.second!=num[ele.first-\\'0\\']-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n             mp[num[i]]++;\\n        }\\n        for(auto ele: mp)\\n        {\\n            \\n            if(ele.second!=num[ele.first-\\'0\\']-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730033,
                "title": "c-easy-explained-map",
                "content": "1. create a map to calculate the frequency\\n2. iterate the string & check if frequncy is same with index+1 if not matched return false\\n3. else return true\\n\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string s) {\\n        unordered_map<char, int>mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            char c=i+\\'0\\';\\n            if(mp[c]!=s[i]-\\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string s) {\\n        unordered_map<char, int>mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            char c=i+\\'0\\';\\n            if(mp[c]!=s[i]-\\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322016,
                "title": "easy-python-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        h = {}\\n        n = len(num)\\n        \\n        for i in range(n):\\n            h[i] = num[i]\\n            \\n        for i in h:\\n            if(num.count(str(i))!=int(h[i])):\\n                return 0\\n        \\n        return 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        h = {}\\n        n = len(num)\\n        \\n        for i in range(n):\\n            h[i] = num[i]\\n            \\n        for i in h:\\n            if(num.count(str(i))!=int(h[i])):\\n                return 0\\n        \\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100089,
                "title": "easy-python-solution",
                "content": "```\\ndef digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2089906,
                "title": "o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n          HashMap<Integer,Integer> map = new HashMap<>();\\n//        First we are marking the frequency for the number. As we are given in the question, num.charAt(i) is the\\n//        frequency of the number i in the num String.\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n//        Now we are traversing through the string.\\n        for(int index = 0; index< num.length(); index++) {\\n//            If character at index i is less than num.length(), then only we need to know its frequency.\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n//                Get the frequency of the number and subtract 1 from it if it is present.\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n//      If all the values are 0 , then only it is right otherwise , the frequency is either more or less than the\\n//        specified frequency, hence return false;\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\nIf you liked the solution or found the solution unique , please upvote :)\\nThank you",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n          HashMap<Integer,Integer> map = new HashMap<>();\\n//        First we are marking the frequency for the number. As we are given in the question, num.charAt(i) is the\\n//        frequency of the number i in the num String.\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n//        Now we are traversing through the string.\\n        for(int index = 0; index< num.length(); index++) {\\n//            If character at index i is less than num.length(), then only we need to know its frequency.\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n//                Get the frequency of the number and subtract 1 from it if it is present.\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n//      If all the values are 0 , then only it is right otherwise , the frequency is either more or less than the\\n//        specified frequency, hence return false;\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084112,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter=Counter(num)\\n        for i in range(len(num)):\\n            if counter[f\\'{i}\\'] != int(num[i]):\\n                return False\\n        return True\\n```\\n\\n**Time - O(n)\\nSpace - O(n)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter=Counter(num)\\n        for i in range(len(num)):\\n            if counter[f\\'{i}\\'] != int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363169,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[]arr = new int[10];\\n\\n      for(int i=0;i<num.length();i++){\\n          arr[num.charAt(i)-\\'0\\']+=1;\\n      }\\n      //System.out.println(Arrays.toString(arr));\\n   \\n\\n      for(int i=0;i<num.length();i++){\\n          if(arr[i]!=num.charAt(i)-\\'0\\'){\\n              return false;\\n          }\\n      }\\n     return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[]arr = new int[10];\\n\\n      for(int i=0;i<num.length();i++){\\n          arr[num.charAt(i)-\\'0\\']+=1;\\n      }\\n      //System.out.println(Arrays.toString(arr));\\n   \\n\\n      for(int i=0;i<num.length();i++){\\n          if(arr[i]!=num.charAt(i)-\\'0\\'){\\n              return false;\\n          }\\n      }\\n     return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282316,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean digitCount(String num) {\\n    final char[] digit = num.toCharArray(); // convert string to char array\\n    final int n = digit.length; // length of char array\\n    int[] count = new int[10]; // count arr length 10 because constraint 1<=n<=10\\n    for (char c : digit) {\\n      count[c - \\'0\\']++; // count of digits \\n    }\\n    for (int i = 0; i < n; i++) {\\n      if (digit[i] - \\'0\\' != count[i]) { // check \\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n// DRY RUN TO CLEARLY UNDERSTAND THE WORKING OF CODE \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean digitCount(String num) {\\n    final char[] digit = num.toCharArray(); // convert string to char array\\n    final int n = digit.length; // length of char array\\n    int[] count = new int[10]; // count arr length 10 because constraint 1<=n<=10\\n    for (char c : digit) {\\n      count[c - \\'0\\']++; // count of digits \\n    }\\n    for (int i = 0; i < n; i++) {\\n      if (digit[i] - \\'0\\' != count[i]) { // check \\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n// DRY RUN TO CLEARLY UNDERSTAND THE WORKING OF CODE \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600012,
                "title": "java-hashmap-string-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            int n = Character.getNumericValue(num.charAt(i));\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)){\\n                int nn = map.get(i);\\n                if(nn!=Character.getNumericValue(num.charAt(i)))\\n                    return false;\\n            }\\n            else{\\n                if(Character.getNumericValue(num.charAt(i))>0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            int n = Character.getNumericValue(num.charAt(i));\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)){\\n                int nn = map.get(i);\\n                if(nn!=Character.getNumericValue(num.charAt(i)))\\n                    return false;\\n            }\\n            else{\\n                if(Character.getNumericValue(num.charAt(i))>0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115384,
                "title": "python-fast-solution-faster-than-93",
                "content": "![image](https://assets.leetcode.com/users/images/2cc0a03a-545f-4144-a1be-d86804fc0d45_1654452047.1386557.png)\\n\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        base = {}\\n        for i in range(len(num)):\\n            if base.get(num[i], None) is None:\\n                base[num[i]]=1\\n            else:\\n                base[num[i]]+=1\\n            if base.get(str(i), None) is None:\\n                base[str(i)]=0\\n                \\n        for i in range(len(num)):\\n            if str(base[str(i)])!=num[i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        base = {}\\n        for i in range(len(num)):\\n            if base.get(num[i], None) is None:\\n                base[num[i]]=1\\n            else:\\n                base[num[i]]+=1\\n            if base.get(str(i), None) is None:\\n                base[str(i)]=0\\n                \\n        for i in range(len(num)):\\n            if str(base[str(i)])!=num[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084818,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n=num.length();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n=num.length();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084006,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        \\n        int[] result = new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            result[num.charAt(i)-\\'0\\']++;\\n        }\\n      \\n       for(int i=0;i<num.length();i++)\\n       {\\n           if(num.charAt(i)-\\'0\\'!=result[i])\\n              return false;\\n       }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        \\n        int[] result = new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            result[num.charAt(i)-\\'0\\']++;\\n        }\\n      \\n       for(int i=0;i<num.length();i++)\\n       {\\n           if(num.charAt(i)-\\'0\\'!=result[i])\\n              return false;\\n       }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083852,
                "title": "javascript-map",
                "content": "```js\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const numLength = num.length;\\n    const numArray = num.split(\\'\\').map(Number);\\n    let result = \"\";\\n    \\n    const numFreq = numArray.reduce((acc,item)=>acc.set(item,acc.get(item) + 1 || 1),new Map())\\n    \\n    for(let i=0;i<numLength;i++){\\n        result+=numFreq.get(i) || \"0\";        \\n    }\\n    \\n    return result === num\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const numLength = num.length;\\n    const numArray = num.split(\\'\\').map(Number);\\n    let result = \"\";\\n    \\n    const numFreq = numArray.reduce((acc,item)=>acc.set(item,acc.get(item) + 1 || 1),new Map())\\n    \\n    for(let i=0;i<numLength;i++){\\n        result+=numFreq.get(i) || \"0\";        \\n    }\\n    \\n    return result === num\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955024,
                "title": "java-100-beats-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char temp[] = new char[11];\\n        int temp1 = 0 , temp2 = 0;\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp1 = ch-\\'0\\';\\n            temp[temp1]++;\\n        }\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp2 = ch-\\'0\\';\\n            if(temp[i]!=temp2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char temp[] = new char[11];\\n        int temp1 = 0 , temp2 = 0;\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp1 = ch-\\'0\\';\\n            temp[temp1]++;\\n        }\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp2 = ch-\\'0\\';\\n            if(temp[i]!=temp2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437755,
                "title": "easy-java-beats-99",
                "content": "# Intuition\\nconsidering {1210}\\n\\n    HASHMAP :\\n\\n    {\\n        0:1\\n        1:2\\n        2:3\\n    }\\n\\n    index : 0 1 2 3\\n    number: 1 2 1 0\\n\\n    according to the question,\\n\\n    num[i] should be equal to frequency of index i\\n\\n    let x = num.charAt(i)\\n    convert character to integer using -\\n    int a = x - \\'0\\';\\n\\n    thus, if(a != frequency of a) i.e if(a != map.get(i)) return false;\\n\\n\\n    but to avoid null pointer exception, we must check if the hashmap contains all indices or not, if it doesnt, then num[i] must be 0 as in this case,\\n\\nindex 3 is not in hashmap {\\n        0:1\\n        1:2\\n        2:3\\n    }\\n\\nso , if it doesnot contain in hashmap (! map.containsKey(i))\\n\\nthen check if num[i] must be 0, else return false;,\\nif it is 0, then continue\\n\\n# Time Complexity - O(n)\\n# Space Complexity - O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n        //creating an integer - integer hashmap\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < num.length(); i++)\\n        {\\n            char x = num.charAt(i);\\n\\n            int a = x - \\'0\\'; // to create character to integer\\n\\n            if(map.containsKey(a))\\n                map.put(a,map.get(a)+1);\\n\\n            else\\n                map.put(a,1);\\n\\n        }\\n\\n        for(int i = 0; i<num.length(); i++)\\n        {\\n\\n            // to avoid nullPointerException\\n\\n            if(!map.containsKey(i))\\n            {\\n                if(num.charAt(i)!=\\'0\\') //it must be 0, else false\\n                    return false;\\n                else //if it is 0, then continue\\n                    continue;\\n            }\\n            char x = num.charAt(i); //let num[i] = x\\n            int a = x - \\'0\\'; //convert x to int\\n            if(a!=map.get(i)) //check if its equal to frequency\\n                return false;\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n        //creating an integer - integer hashmap\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < num.length(); i++)\\n        {\\n            char x = num.charAt(i);\\n\\n            int a = x - \\'0\\'; // to create character to integer\\n\\n            if(map.containsKey(a))\\n                map.put(a,map.get(a)+1);\\n\\n            else\\n                map.put(a,1);\\n\\n        }\\n\\n        for(int i = 0; i<num.length(); i++)\\n        {\\n\\n            // to avoid nullPointerException\\n\\n            if(!map.containsKey(i))\\n            {\\n                if(num.charAt(i)!=\\'0\\') //it must be 0, else false\\n                    return false;\\n                else //if it is 0, then continue\\n                    continue;\\n            }\\n            char x = num.charAt(i); //let num[i] = x\\n            int a = x - \\'0\\'; //convert x to int\\n            if(a!=map.get(i)) //check if its equal to frequency\\n                return false;\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359639,
                "title": "easy-beginner-friendly-solution-using-frequency-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        dic=Counter(num)\\n        c=0\\n        for i in range(len(num)):\\n            if dic[str(i)]==int(num[i]):\\n                c+=1\\n                \\n        if c==len(num):\\n            return 1\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        dic=Counter(num)\\n        c=0\\n        for i in range(len(num)):\\n            if dic[str(i)]==int(num[i]):\\n                c+=1\\n                \\n        if c==len(num):\\n            return 1\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312486,
                "title": "c-solution-brute-force-hash-table",
                "content": "# Approach : Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    vector<int> v(10,0);\\n    for (int i = 0; i < num.size(); i++)\\n        v[num[i] - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (num[i] - \\'0\\' != v[i])\\n           return false;\\n\\n    return true;\\n\\n    }\\n};\\n```\\n# Approach : Hash Table\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    unordered_map<int, int> m;\\n    for (auto e : num)\\n        m[e - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (m[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    vector<int> v(10,0);\\n    for (int i = 0; i < num.size(); i++)\\n        v[num[i] - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (num[i] - \\'0\\' != v[i])\\n           return false;\\n\\n    return true;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    unordered_map<int, int> m;\\n    for (auto e : num)\\n        m[e - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (m[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278845,
                "title": "c-easy-simple",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237543,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852794,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        checked = set()\\n        i = 0\\n        while i < len(num):\\n            if num[i] not in checked:\\n                count = num.count(str(i))\\n                if int(num[i]) != count:\\n                    return False\\n                else:\\n                    checked.add(num[i])\\n                    i += 1\\n            else:\\n                i += 1\\n        \\n        return True\\n``",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        checked = set()\\n        i = 0\\n        while i < len(num):\\n            if num[i] not in checked:\\n                count = num.count(str(i))\\n                if int(num[i]) != count:\\n                    return False\\n                else:\\n                    checked.add(num[i])\\n                    i += 1\\n            else:\\n                i += 1\\n        \\n        return True\\n``",
                "codeTag": "Java"
            },
            {
                "id": 2561099,
                "title": "java-c-one-liner-100-00-0-ms-o-1",
                "content": "**UPVOTE PLEASE**\\n```\\ncpp:\\n\\n\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n\\t\\n\\tjava:\\n\\t\\n\\treturn new HashSet<String>(List.of(\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\")).contains(num); \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\ncpp:\\n\\n\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n\\t\\n\\tjava:\\n\\t\\n\\treturn new HashSet<String>(List.of(\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\")).contains(num); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530024,
                "title": "here-is-my-solution",
                "content": "*****plz upvote if you find my solution helpful*****\\n```\\nclass Solution:\\n    def digitCount(self, n: str) -> bool:\\n        l=len(n)\\n        for i in range(l):\\n            if n.count(str(i))!=int(n[i]):\\n                \\n                return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, n: str) -> bool:\\n        l=len(n)\\n        for i in range(l):\\n            if n.count(str(i))!=int(n[i]):\\n                \\n                return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210762,
                "title": "java-easy-to-understand-2-hashmaps",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        // Create a map for given frequencies\\n        HashMap<Character, Integer> givenFreqMap = new HashMap<>();\\n        \\n        // Create a map to count frequencies manually\\n        HashMap<Character, Integer> countFreqMap = new HashMap<>();\\n        \\n        // Loop through num\\n        for(int i = 0; i < num.length(); i++){\\n            \\n            // We only want to put in map if value at index is not equals to 0\\n            // because 0 means it\\'s not in the string so we do not need that\\n            if(num.charAt(i) != \\'0\\'){\\n                // Add to givenFreqMap convert the index to char and it\\'s value from char to int\\n                givenFreqMap.put((char)(i+\\'0\\'), num.charAt(i) - \\'0\\');\\n            }\\n        }\\n        \\n        // Loop through num     \\n        for(char c : num.toCharArray()){\\n            \\n            // Add to countFreqMap and count thier frequencies\\n            countFreqMap.put(c, countFreqMap.getOrDefault(c, 0) + 1);\\n        }\\n                 \\n        // If the characters and its frequencies are same in both map then return true, else false\\n        return givenFreqMap.equals(countFreqMap);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        // Create a map for given frequencies\\n        HashMap<Character, Integer> givenFreqMap = new HashMap<>();\\n        \\n        // Create a map to count frequencies manually\\n        HashMap<Character, Integer> countFreqMap = new HashMap<>();\\n        \\n        // Loop through num\\n        for(int i = 0; i < num.length(); i++){\\n            \\n            // We only want to put in map if value at index is not equals to 0\\n            // because 0 means it\\'s not in the string so we do not need that\\n            if(num.charAt(i) != \\'0\\'){\\n                // Add to givenFreqMap convert the index to char and it\\'s value from char to int\\n                givenFreqMap.put((char)(i+\\'0\\'), num.charAt(i) - \\'0\\');\\n            }\\n        }\\n        \\n        // Loop through num     \\n        for(char c : num.toCharArray()){\\n            \\n            // Add to countFreqMap and count thier frequencies\\n            countFreqMap.put(c, countFreqMap.getOrDefault(c, 0) + 1);\\n        }\\n                 \\n        // If the characters and its frequencies are same in both map then return true, else false\\n        return givenFreqMap.equals(countFreqMap);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194225,
                "title": "python-easy-2-liner-faster-than-93",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:            \\n        for i in range(len(num)):\\n            if(num.count(str(i))!=int(num[i])): return False\\n        return True\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:            \\n        for i in range(len(num)):\\n            if(num.count(str(i))!=int(num[i])): return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122515,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) \\n    {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(char ch:num.toCharArray())\\n            hmap.put(Character.getNumericValue(ch),hmap.getOrDefault(Character.getNumericValue(ch),0)+1);\\n        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(hmap.get(i)!=null && hmap.get(i)!=Character.getNumericValue(num.charAt(i)))\\n                return false;\\n            else if(hmap.get(i)==null && Character.getNumericValue(num.charAt(i))!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean digitCount(String num) \\n    {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(char ch:num.toCharArray())\\n            hmap.put(Character.getNumericValue(ch),hmap.getOrDefault(Character.getNumericValue(ch),0)+1);\\n        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(hmap.get(i)!=null && hmap.get(i)!=Character.getNumericValue(num.charAt(i)))\\n                return false;\\n            else if(hmap.get(i)==null && Character.getNumericValue(num.charAt(i))!=0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2087105,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut counter = [0; 10];\\n        let num_it = num.bytes().map(|b| (b - b\\'0\\') as usize);\\n        num_it.clone().for_each(|idx| counter[idx] += 1);\\n        num_it.enumerate().all(|(i, idx)| counter[i] == idx)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut counter = [0; 10];\\n        let num_it = num.bytes().map(|b| (b - b\\'0\\') as usize);\\n        num_it.clone().for_each(|idx| counter[idx] += 1);\\n        num_it.enumerate().all(|(i, idx)| counter[i] == idx)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085306,
                "title": "very-easy-c-solution-using-1-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.length();i++){\\n\\t\\t\\t// int to char\\n            char ch =  i + \\'0\\';\\n\\t\\t\\t\\n\\t\\t\\t// count no. of occurance\\n            int req = count(num.begin(),num.end(),ch);\\n\\t\\t\\t\\n\\t\\t\\t// check the given condtion\\n            if(req!=(num[i]-\\'0\\'))     return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.length();i++){\\n\\t\\t\\t// int to char\\n            char ch =  i + \\'0\\';\\n\\t\\t\\t\\n\\t\\t\\t// count no. of occurance\\n            int req = count(num.begin(),num.end(),ch);\\n\\t\\t\\t\\n\\t\\t\\t// check the given condtion\\n            if(req!=(num[i]-\\'0\\'))     return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084641,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        n=len(num)\\n        \\n        for i in range(n):\\n            if(num.count(str(i))!=int(num[i])):\\n                return False\\n            \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        n=len(num)\\n        \\n        for i in range(n):\\n            if(num.count(str(i))!=int(num[i])):\\n                return False\\n            \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2084158,
                "title": "o-n-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> m;\\n        int n=num.size();\\n        for(int i=0;i<n;i++){\\n            m[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++ ){\\n            if(num[i]==\\'0\\'&&m.find(i)==m.end())continue;\\n            if(m.find(i)!=m.end()&&m[i]==(num[i]-\\'0\\'))continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> m;\\n        int n=num.size();\\n        for(int i=0;i<n;i++){\\n            m[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++ ){\\n            if(num[i]==\\'0\\'&&m.find(i)==m.end())continue;\\n            if(m.find(i)!=m.end()&&m[i]==(num[i]-\\'0\\'))continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084130,
                "title": "javascript-counter-105ms",
                "content": "```\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst digitCount = (a) => {\\n    let m = counter(a), n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let cnt = m.get(i + \\'\\') || 0\\n        if (a[i] != cnt) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst digitCount = (a) => {\\n    let m = counter(a), n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let cnt = m.get(i + \\'\\') || 0\\n        if (a[i] != cnt) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084121,
                "title": "python3-very-elegant-and-straightforward",
                "content": "\\n```\\n        c = Counter(num)\\n        for idx, x in enumerate(num):\\n            if c[str(idx)] != int(x):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        c = Counter(num)\\n        for idx, x in enumerate(num):\\n            if c[str(idx)] != int(x):\\n                return False\\n        return True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084061,
                "title": "brute-force-c-100",
                "content": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int count=0;\\n        bool ans=true;\\n        for(int i=0;i<num.size();i++){\\n            for(int j=0;j<num.size();j++){\\n                if((num[j]-\\'0\\')==i){\\n                    count=count+1;\\n                }\\n            }\\n            if((num[i]-\\'0\\')!=count){\\n                ans=false; \\n            }\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int count=0;\\n        bool ans=true;\\n        for(int i=0;i<num.size();i++){\\n            for(int j=0;j<num.size();j++){\\n                if((num[j]-\\'0\\')==i){\\n                    count=count+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2083804,
                "title": "2-liner-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.size();i++) if(count(num.begin(),num.end(),(i+\\'0\\')) != num[i]-\\'0\\') return false;\\n        return true;\\n    }\\n};\\n```\\n\\n\\n\\n**With Using Extra space :** \\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mpp;\\n        for(auto c : num) mpp[c]++;\\n        for(int i=0;i<num.size();i++){\\n            char c = (char)i+\\'0\\';\\n            if(num[i]-\\'0\\' != mpp[c]) return false;\\n        }\\n         return true;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.size();i++) if(count(num.begin(),num.end(),(i+\\'0\\')) != num[i]-\\'0\\') return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mpp;\\n        for(auto c : num) mpp[c]++;\\n        for(int i=0;i<num.size();i++){\\n            char c = (char)i+\\'0\\';\\n            if(num[i]-\\'0\\' != mpp[c]) return false;\\n        }\\n         return true;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936222,
                "title": "python-beginner-friendly-explanation-beats-91",
                "content": "# Approach\\nSimple Compare the count of current index with value at corrent index\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904905,
                "title": "easy-approach-for-beginners-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577641,
                "title": "java-simple-solution-hashmap-counting-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> occurrence = new HashMap<>(num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            occurrence.put(currentDigit, occurrence.getOrDefault(currentDigit, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            int count = 0;\\n            if (occurrence.containsKey(i)) {\\n                count = occurrence.get(i);\\n            }\\n            if (count != currentDigit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> occurrence = new HashMap<>(num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            occurrence.put(currentDigit, occurrence.getOrDefault(currentDigit, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            int count = 0;\\n            if (occurrence.containsKey(i)) {\\n                count = occurrence.get(i);\\n            }\\n            if (count != currentDigit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573736,
                "title": "check-if-number-has-equal-digit-count-and-digit-value-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int i, j, count=0;\\n        for(i=0 ; i<num.length() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<num.length() ; j++)\\n            {\\n                if(i==(int)num[j]-48)\\n                {\\n                    count++;\\n                }\\n            }\\n            if((int)num[i]-48!=count)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/98f8d2dd-d2eb-4f98-991a-e52107e37b08_1685332542.106816.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int i, j, count=0;\\n        for(i=0 ; i<num.length() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<num.length() ; j++)\\n            {\\n                if(i==(int)num[j]-48)\\n                {\\n                    count++;\\n                }\\n            }\\n            if((int)num[i]-48!=count)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548379,
                "title": "simplest-efficient-c-code-time-o-n-2-space-o-1",
                "content": "# Intuition\\nThe code aims to compare the count of each digit in the string with the actual digit itself.\\n\\n# Approach\\nThe code iterates through each digit in the given string and compares its count with the actual digit itself. If any count doesn\\'t match, it returns false; otherwise, it returns true. \\n\\n# Complexity\\n- Time complexity: Let\\'s consider the length of the string num as n. The code uses two nested loops, with each loop iterating over the entire string. Therefore, the time complexity of the code is $O(n^2)$.\\n\\n- Space complexity: The code uses a constant amount of additional space to store variables l, i, j, and count. Hence, the space complexity is $O(1)$.\\n\\n# Code\\n```\\nbool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }\\n        if(count != num[i]-\\'0\\')\\n        return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }\\n        if(count != num[i]-\\'0\\')\\n        return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464006,
                "title": "easy-understanding-hash-java-99-85-beats-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        for(int i=0;i<num.length();i++){\\n            int ch=num.charAt(i)-\\'0\\';\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        // StringBuilder sb=new StringBuilder();\\n        int count=0;\\n        for(int i=0;i<num.length();i++){\\n\\n            if(map.containsKey(i)){\\n                count=map.get(i);\\n            }\\n            else{\\n                count=0;\\n            }\\n          int x=num.charAt(i)-\\'0\\';\\n            if(x!=count){\\n                return false;\\n            }\\n        }\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        for(int i=0;i<num.length();i++){\\n            int ch=num.charAt(i)-\\'0\\';\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        // StringBuilder sb=new StringBuilder();\\n        int count=0;\\n        for(int i=0;i<num.length();i++){\\n\\n            if(map.containsKey(i)){\\n                count=map.get(i);\\n            }\\n            else{\\n                count=0;\\n            }\\n          int x=num.charAt(i)-\\'0\\';\\n            if(x!=count){\\n                return false;\\n            }\\n        }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404476,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395513,
                "title": "easy-go-solution",
                "content": "```\\nfunc digitCount(num string) bool {\\n        var counters [10]int\\n\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                counters[int(val-\\'0\\')]++\\n        }\\n\\n        isMatch := true\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                if counters[i] != int(val-\\'0\\') {\\n                        isMatch = false\\n                        break\\n                }\\n        }\\n\\n        return isMatch\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc digitCount(num string) bool {\\n        var counters [10]int\\n\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                counters[int(val-\\'0\\')]++\\n        }\\n\\n        isMatch := true\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                if counters[i] != int(val-\\'0\\') {\\n                        isMatch = false\\n                        break\\n                }\\n        }\\n\\n        return isMatch\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3309058,
                "title": "java-hashmap-frequency-array-easy",
                "content": "## Solution 1: Using HashMap:\\n``` \\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (char c : num.toCharArray()) {\\n            int n = c - \\'0\\';\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != map.getOrDefault(i, 0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\nSize will be at max $$10$$ so its very small.\\n\\n**Time complexity:** $$O(1)$$\\n**Space complexity:** $$O(1)$$\\n\\n---\\n## Solution 2: Using Frequency array:\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for (char c : num.toCharArray()) {\\n            freq[c - \\'0\\']++;\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != freq[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\nSize will be at max $$10$$ so its very small.\\n\\n**Time complexity:** $$O(1)$$\\n**Space complexity:** $$O(1)$$\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "``` \\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (char c : num.toCharArray()) {\\n            int n = c - \\'0\\';\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != map.getOrDefault(i, 0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for (char c : num.toCharArray()) {\\n            freq[c - \\'0\\']++;\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != freq[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096491,
                "title": "python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->First we have allocated a an empty string for storing the value. Now a loop upto length of the given string is generated and stored the value of that place (count of that place in num string) if the new formed string is equal to the given sting nums, return True else False.\\n# Code\\n```\\nclass Solution(object):\\n    def digitCount(self, num):\\n        \"\"\"\\n        :type num: str\\n        :rtype: bool\\n        \"\"\"\\n        s=\\'\\'\\n        for i in range(len(num)):\\n            s+=str(num.count(str(i)))\\n        if num==s:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def digitCount(self, num):\\n        \"\"\"\\n        :type num: str\\n        :rtype: bool\\n        \"\"\"\\n        s=\\'\\'\\n        for i in range(len(num)):\\n            s+=str(num.count(str(i)))\\n        if num==s:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918316,
                "title": "c-hashing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int>v(10,0);   //to keep track of frequency of each digit\\n        int n=num.size();\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';  //convert char to int\\n            v[k]++;   //hashing\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';\\n            if(v[i]!=k)return false;  //check if frequency of digit is equal to integer at that index\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int>v(10,0);   //to keep track of frequency of each digit\\n        int n=num.size();\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';  //convert char to int\\n            v[k]++;   //hashing\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';\\n            if(v[i]!=k)return false;  //check if frequency of digit is equal to integer at that index\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833980,
                "title": "easy-js-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet digitCount = function(num) {\\n    let map = new Map();\\n\\n    // Set Key:Value To Map\\n    for(let val of num) {\\n        // Covert string to number\\n        let n = Number(val)\\n        map.set(n, map.get(n) + 1 || 1);\\n    }\\n\\n    // Compare\\n    for(let i = 0; i < num.length; i++) {\\n        if(map.get(i) === Number(num[i])) {\\n            continue;\\n        } else if(!map.get(i) && Number(num[i]) === 0) {\\n            continue;\\n        }\\n        return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nlet digitCount = function(num) {\\n    let map = new Map();\\n\\n    // Set Key:Value To Map\\n    for(let val of num) {\\n        // Covert string to number\\n        let n = Number(val)\\n        map.set(n, map.get(n) + 1 || 1);\\n    }\\n\\n    // Compare\\n    for(let i = 0; i < num.length; i++) {\\n        if(map.get(i) === Number(num[i])) {\\n            continue;\\n        } else if(!map.get(i) && Number(num[i]) === 0) {\\n            continue;\\n        }\\n        return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778905,
                "title": "simple-solution",
                "content": "simple solution in java using hash table\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq=new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            int c=num.charAt(i)-\\'0\\';\\n            freq[c]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int a=num.charAt(i)-\\'0\\';\\n            if(a!=freq[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq=new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            int c=num.charAt(i)-\\'0\\';\\n            freq[c]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int a=num.charAt(i)-\\'0\\';\\n            if(a!=freq[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778836,
                "title": "java-using-hash-maps",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            char a=num.charAt(i);\\n            if(map.containsKey(Integer.parseInt(String.valueOf(a))))\\n            {\\n                map.put(Integer.parseInt(String.valueOf(a)),map.get(Integer.parseInt(String.valueOf(a)))+1);\\n            }\\n            else{\\n                map.put(Integer.parseInt(String.valueOf(a)),1);\\n            }\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)) {\\n                if (Integer.parseInt(String.valueOf(num.charAt(i))) != map.get(i)) {\\n                    return false;\\n                }\\n            }\\n            else{\\n                if(Integer.parseInt(String.valueOf(num.charAt(i)))!=0)\\n                    return false;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            char a=num.charAt(i);\\n            if(map.containsKey(Integer.parseInt(String.valueOf(a))))\\n            {\\n                map.put(Integer.parseInt(String.valueOf(a)),map.get(Integer.parseInt(String.valueOf(a)))+1);\\n            }\\n            else{\\n                map.put(Integer.parseInt(String.valueOf(a)),1);\\n            }\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)) {\\n                if (Integer.parseInt(String.valueOf(num.charAt(i))) != map.get(i)) {\\n                    return false;\\n                }\\n            }\\n            else{\\n                if(Integer.parseInt(String.valueOf(num.charAt(i)))!=0)\\n                    return false;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760627,
                "title": "beats-98-60-in-time",
                "content": "#### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- convert to char array using `toCharArray()`;\\n- to convert char to int -> `num[i]-\\'0\\'`\\n- can use the opp. approach,  *i.e* int to char -> `num[i]+\\'0\\'`\\n#### Approach\\n<!-- Describe your approach to solving the problem. -->\\nloop through the char array\\nanother loop to count the frequency of each char `num[j] == i`\\nif `num[i] == freq` return true\\nreturn false when loop finishes.\\n##### Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char[] numx = num.toCharArray();\\n        int freq = 0;\\n        for(int i=0; i<numx.length; i++){\\n            freq = 0;\\n            for(int j=0; j<numx.length; j++){\\n                if(i == (numx[j]-\\'0\\')){\\n                    freq++;\\n                }\\n            }\\n            if((numx[i]-\\'0\\') != freq) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char[] numx = num.toCharArray();\\n        int freq = 0;\\n        for(int i=0; i<numx.length; i++){\\n            freq = 0;\\n            for(int j=0; j<numx.length; j++){\\n                if(i == (numx[j]-\\'0\\')){\\n                    freq++;\\n                }\\n            }\\n            if((numx[i]-\\'0\\') != freq) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710543,
                "title": "easty-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- wrost O(N^2)\\n- best O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, s: str) -> bool:\\n        for i in range(len(s)):\\n            c=s.count(str(i))\\n            if c==int(s[i]):\\n                continue\\n            else:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, s: str) -> bool:\\n        for i in range(len(s)):\\n            c=s.count(str(i))\\n            if c==int(s[i]):\\n                continue\\n            else:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619170,
                "title": "super-easy-c-soln-hash-table",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for(auto it: num){\\n          v[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(v[i] != num[i]-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for(auto it: num){\\n          v[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(v[i] != num[i]-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571171,
                "title": "java-solution-for-beginners-without-hashmap",
                "content": "class Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[num.length()];\\n        for(int i = 0;i<num.length();i++){\\n            for(int j = 0;j<num.length();j++){\\n                if(i == num.charAt(j)-\\'0\\'){\\n                    count[i]++;\\n                }\\n            }\\n        }\\n        boolean bo = true;\\n        for(int i = 0;i<num.length();i++){\\n            if(count[i] == num.charAt(i)-\\'0\\'){\\n                bo = true;\\n            }\\n            else{\\n                bo = false;\\n                break;\\n            }\\n        }\\n        \\n        return bo;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[num.length()];\\n        for(int i = 0;i<num.length();i++){\\n            for(int j = 0;j<num.length();j++){\\n                if(i == num.charAt(j)-\\'0\\'){\\n                    count[i]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2501744,
                "title": "62-ms-faster-than-99-15-easy-intuitive-js-solution",
                "content": "```\\nvar digitCount = function(num) {\\n    let map = new Map();\\n        \\n    for(let i = 0; i < num.length; i++) {\\n        map.has(num.charAt(i)) ? map.set(num.charAt(i), map.get(num.charAt(i))+1) : map.set(num.charAt(i), 1)\\n    }\\n\\n    let value;\\n    for(let i = 0; i < num.length; i++) {\\n        value = map.has(i.toString()) ? map.get(i.toString()) : 0;\\n        if(value != num.charAt(i)){\\n            return false\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar digitCount = function(num) {\\n    let map = new Map();\\n        \\n    for(let i = 0; i < num.length; i++) {\\n        map.has(num.charAt(i)) ? map.set(num.charAt(i), map.get(num.charAt(i))+1) : map.set(num.charAt(i), 1)\\n    }\\n\\n    let value;\\n    for(let i = 0; i < num.length; i++) {\\n        value = map.has(i.toString()) ? map.get(i.toString()) : 0;\\n        if(value != num.charAt(i)){\\n            return false\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484276,
                "title": "c-0ms-unordered-map-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) \\n    {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n            mp[num[i]]++;\\t\\n        }        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            char currnum=i+\\'0\\';\\n            int freq=num[i]-\\'0\\';\\n\\n            if(mp[currnum]!=freq)\\n            {\\n               return false;    \\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) \\n    {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n            mp[num[i]]++;\\t\\n        }        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            char currnum=i+\\'0\\';\\n            int freq=num[i]-\\'0\\';\\n\\n            if(mp[currnum]!=freq)\\n            {\\n               return false;    \\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332877,
                "title": "python3-o-n-o-n-runtime-47ms-62-83-memory-13-8mb-56-99",
                "content": "```\\nfrom collections import Counter as c\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 62.83% || Memory: 13.8mb 56.99%\\n    def digitCount(self, num: str) -> bool:\\n        if not num:\\n            return num\\n\\n        numFreq = c(num)\\n\\n        for idx, val in enumerate(num):\\n            if numFreq[f\\'{idx}\\'] != int(val):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as c\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 62.83% || Memory: 13.8mb 56.99%\\n    def digitCount(self, num: str) -> bool:\\n        if not num:\\n            return num\\n\\n        numFreq = c(num)\\n\\n        for idx, val in enumerate(num):\\n            if numFreq[f\\'{idx}\\'] != int(val):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320976,
                "title": "java-runtime-1ms-time-o-n-space-n",
                "content": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnum = \"1210\"\\n*/\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Character, Integer> map = new HashMap<>() ;\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            map.put(num.charAt(i), map.getOrDefault(num.charAt(i), 0)+1) ;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            char ch = (char)(48+i) ;\\n            \\n            if (map.containsKey(ch)) {\\n                if ((int)(num.charAt(i))-48 != map.get(ch)) {\\n                    return false ;\\n                }\\n            }\\n            else if (num.charAt(i) != \\'0\\'){\\n                return false ;\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnum = \"1210\"\\n*/\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Character, Integer> map = new HashMap<>() ;\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            map.put(num.charAt(i), map.getOrDefault(num.charAt(i), 0)+1) ;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            char ch = (char)(48+i) ;\\n            \\n            if (map.containsKey(ch)) {\\n                if ((int)(num.charAt(i))-48 != map.get(ch)) {\\n                    return false ;\\n                }\\n            }\\n            else if (num.charAt(i) != \\'0\\'){\\n                return false ;\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269284,
                "title": "simple-c-solution",
                "content": "```\\n        int n = num.length();\\n        vector<int> v(10,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if((num[i]-\\'0\\') != v[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        int n = num.length();\\n        vector<int> v(10,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if((num[i]-\\'0\\') != v[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246289,
                "title": "python-simple-solution-easy-2-liner-faster-than-93-easy-to-understand",
                "content": "```\\nst = \\'\\'\\nfor i in range(len(num)):\\n\\tst = st+str(num.count(str(i)))\\nreturn(st == num)\\n```\\n***Please Do Upvote, if you found my code helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nst = \\'\\'\\nfor i in range(len(num)):\\n\\tst = st+str(num.count(str(i)))\\nreturn(st == num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243800,
                "title": "java",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Hashtable<Integer, Integer> ht = new Hashtable<Integer, Integer>();\\n        for(int i = 0; i<num.length(); i++){\\n            ht.put(i, num.charAt(i)-\\'0\\'); \\n        }\\n        \\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(num.charAt(i)-\\'0\\')== null){\\n                return false;\\n            }\\n            ht.replace(num.charAt(i)-\\'0\\', ht.get(num.charAt(i)-\\'0\\')-1);\\n        }\\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(i)!=0){\\n                return false;\\n            }\\t\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Hashtable<Integer, Integer> ht = new Hashtable<Integer, Integer>();\\n        for(int i = 0; i<num.length(); i++){\\n            ht.put(i, num.charAt(i)-\\'0\\'); \\n        }\\n        \\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(num.charAt(i)-\\'0\\')== null){\\n                return false;\\n            }\\n            ht.replace(num.charAt(i)-\\'0\\', ht.get(num.charAt(i)-\\'0\\')-1);\\n        }\\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(i)!=0){\\n                return false;\\n            }\\t\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218421,
                "title": "kotlin-1-line",
                "content": "```\\nfun digitCount(s: String) = s.withIndex().all { it.value - \\'0\\' == s.count { c -> c == \\'0\\' + it.index } }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun digitCount(s: String) = s.withIndex().all { it.value - \\'0\\' == s.count { c -> c == \\'0\\' + it.index } }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195712,
                "title": "java-easiest-solution-with-steps-explained",
                "content": "**STEPS**\\n\\n**Here we are using Frequency Array**\\n\\n**Step 1:** Initialising the Frequency Array with size 10 (**because 1 <= n <= 10 was given in the constraints**)\\n**Step 2:** Take each characters from the string and make it into character array\\n**Step 3:**  Store the frequency of characters in frequency Array.\\n**Step 4:** Now find frequency of each index value and update the frequency array.\\n**Step 5:** Now within a loop check upto constraint value check if frequency is zero or not .If zero then return false otherwise the function will return true.\\n\\n**Code**\\n\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArray = new int[10];\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArray[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';\\n            freqArray[i] = freqArray[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArray[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArray = new int[10];\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArray[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';\\n            freqArray[i] = freqArray[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArray[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189195,
                "title": "javascript-using-regex",
                "content": "```\\nvar digitCount = function(num) {    \\n    const res = [...num].filter((element, index) => {\\n        const reg = new RegExp(index, \"g\");\\n        const count = (num.match(reg) || []).length;\\n        \\n        return Number(element) === count\\n    })\\n    \\n    return res.length === num.length    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar digitCount = function(num) {    \\n    const res = [...num].filter((element, index) => {\\n        const reg = new RegExp(index, \"g\");\\n        const count = (num.match(reg) || []).length;\\n        \\n        return Number(element) === count\\n    })\\n    \\n    return res.length === num.length    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178551,
                "title": "easy-javascript-solution",
                "content": "```\\nvar digitCount = function(num) {\\n    let arr= Array(num.length).fill(0);\\n    for(const char of num){\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```\\n\\nRuntime: 113 ms, faster than 31.20% of JavaScript online submissions for Check if Number Has Equal Digit Count and Digit Value.\\nMemory Usage: 43.8 MB, less than 16.45% of JavaScript online submissions for Check if Number Has Equal Digit Count and Digit Value.",
                "solutionTags": [],
                "code": "```\\nvar digitCount = function(num) {\\n    let arr= Array(num.length).fill(0);\\n    for(const char of num){\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171618,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>mp;\\n        for(int i=0;i<num.size();i++)\\n            mp[num[i]]++;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=num[i]-\\'0\\';\\n           /// cout<<mp[(i+\\'0\\')]<<\" \"<<temp<<endl;\\n            if(mp[(i+\\'0\\')]!=temp)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>mp;\\n        for(int i=0;i<num.size();i++)\\n            mp[num[i]]++;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=num[i]-\\'0\\';\\n           /// cout<<mp[(i+\\'0\\')]<<\" \"<<temp<<endl;\\n            if(mp[(i+\\'0\\')]!=temp)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2124375,
                "title": "java-sol-using-counter-array",
                "content": "Java solution to use counter array because we will only have 10 digits\\n\\n```\\npublic boolean digitCount(String num) {\\n        int[] digit_counter = new int[10];\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            digit_counter[Character.getNumericValue(num.charAt(i))]++;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            if (digit_counter[i] != Character.getNumericValue(num.charAt(i)))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Java solution to use counter array because we will only have 10 digits\\n\\n```\\npublic boolean digitCount(String num) {\\n        int[] digit_counter = new int[10];\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            digit_counter[Character.getNumericValue(num.charAt(i))]++;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            if (digit_counter[i] != Character.getNumericValue(num.charAt(i)))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2112937,
                "title": "c-solution-without-using-vector-array-map-for-beginners",
                "content": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int count=0;\\n        int i=0;\\n        int a=0;\\n        for(int c=0;c<num.size();c++)\\n        {\\n            count=0;\\n            for(i=0;i<num.size();i++)\\n            {\\n                if(num[i]==char(c+48))\\n                {\\n                    count++;\\n                }\\n            }\\n            // cout<<count<<endl;\\n            if(count!=(int)num[a]-48)\\n            {\\n                return false;\\n            }\\n            a++;\\n        }\\n       \\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int count=0;\\n        int i=0;\\n        int a=0;\\n        for(int c=0;c<num.size();c++)\\n        {\\n            count=0;\\n            for(i=0;i<num.size();i++)\\n            {\\n                if(num[i]==char(c+48))\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2100275,
                "title": "kotlin-short-easy-solution-264ms-faster-than-50-00",
                "content": "just do what the problem says, along with 1 edge case\\n```\\nclass Solution {\\n    fun digitCount(num: String): Boolean {\\n        val map = num.groupingBy { it }.eachCount()\\n        return num.indices.all {\\n            val count = map[(\\'0\\'..\\'9\\').toList()[it]] ?: 0\\n            count == num[it].toString().toInt()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun digitCount(num: String): Boolean {\\n        val map = num.groupingBy { it }.eachCount()\\n        return num.indices.all {\\n            val count = map[(\\'0\\'..\\'9\\').toList()[it]] ?: 0\\n            count == num[it].toString().toInt()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093748,
                "title": "python-count-and-check-with-explanation-45ms",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        #Find the length\\n        LENGTH = len( num )\\n            \\n        #Count the occurences\\n        counter = Counter( num )\\n\\n        #Go through each number index\\n        for i in range( LENGTH ):\\n            #The index is the current digit\\n            current_digit = i\\n            \\n            #Cast it as a string for comparison\\n            str_current = str( i ) \\n            \\n            #Use the index to find the expected number in num\\n            expected_number = int ( num[ i ] )\\n            \\n            #Use the stringified number to find its occurences in counter\\n            if str_current in counter:\\n                digit_count = int( counter[ str_current ] )\\n                \\n            #If it is not found, the count is zero\\n            else:\\n                digit_count = 0\\n            \\n            #If we don\\'t find the expected number as the count, we return False\\n            if expected_number != digit_count:\\n                return False\\n            \\n        #Otherwise, all that are checked are valid\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        #Find the length\\n        LENGTH = len( num )\\n            \\n        #Count the occurences\\n        counter = Counter( num )\\n\\n        #Go through each number index\\n        for i in range( LENGTH ):\\n            #The index is the current digit\\n            current_digit = i\\n            \\n            #Cast it as a string for comparison\\n            str_current = str( i ) \\n            \\n            #Use the index to find the expected number in num\\n            expected_number = int ( num[ i ] )\\n            \\n            #Use the stringified number to find its occurences in counter\\n            if str_current in counter:\\n                digit_count = int( counter[ str_current ] )\\n                \\n            #If it is not found, the count is zero\\n            else:\\n                digit_count = 0\\n            \\n            #If we don\\'t find the expected number as the count, we return False\\n            if expected_number != digit_count:\\n                return False\\n            \\n        #Otherwise, all that are checked are valid\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092793,
                "title": "rust-hashmap-counter-o-n",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut dc = HashMap::new();\\n        for c in num.chars() {\\n            let d: usize = c.to_digit(10).unwrap_or(88) as usize;\\n            *dc.entry(d).or_insert(0) += 1;\\n        }\\n        \\n        for (i, c) in num.chars().enumerate() {\\n            let cnt: usize = c.to_digit(10).unwrap_or(99) as usize;\\n            if !dc.contains_key(&i) {\\n                if cnt == 0 {\\n                    continue\\n                } else {\\n                    return false;\\n                }\\n            } else if dc[&i] != cnt {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut dc = HashMap::new();\\n        for c in num.chars() {\\n            let d: usize = c.to_digit(10).unwrap_or(88) as usize;\\n            *dc.entry(d).or_insert(0) += 1;\\n        }\\n        \\n        for (i, c) in num.chars().enumerate() {\\n            let cnt: usize = c.to_digit(10).unwrap_or(99) as usize;\\n            if !dc.contains_key(&i) {\\n                if cnt == 0 {\\n                    continue\\n                } else {\\n                    return false;\\n                }\\n            } else if dc[&i] != cnt {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087358,
                "title": "c-easy-0ms-100-beats-beginner-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int>ans;\\n        for(int i=0; i<num.size(); i++)\\n            ans[num[i]]++;\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            if(num[i] != \\'0\\' + ans[c]){\\n                return false;\\n                \\n\\n            }\\n        }  \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int>ans;\\n        for(int i=0; i<num.size(); i++)\\n            ans[num[i]]++;\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            if(num[i] != \\'0\\' + ans[c]){\\n                return false;\\n                \\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2086477,
                "title": "javascript-soln",
                "content": "```\\nvar digitCount = function(num) {\\n\\n    const numArray = num.split(\"\");\\n    for(let i=0;i<num.length;i++){\\n      if (!(num[i] == countFreq(numArray,`${i}`))) {\\n          return false;\\n      }\\n    }\\n    return true;\\n};\\n\\nconst countFreq = (arr,index) => {\\n   return( (arr.filter( (n) => {return n===index && n})).length );\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar digitCount = function(num) {\\n\\n    const numArray = num.split(\"\");\\n    for(let i=0;i<num.length;i++){\\n      if (!(num[i] == countFreq(numArray,`${i}`))) {\\n          return false;\\n      }\\n    }\\n    return true;\\n};\\n\\nconst countFreq = (arr,index) => {\\n   return( (arr.filter( (n) => {return n===index && n})).length );\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086252,
                "title": "javascript-solution-using-replace",
                "content": "```\\n    for(let i = 0; i < num.length; i++) {\\n        const temp = num.replace(new RegExp(`${i}`, \"g\"), \"\");\\n        if (num.length - temp.length !== num.charAt(i) - \\'0\\') {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n```",
                "solutionTags": [],
                "code": "```\\n    for(let i = 0; i < num.length; i++) {\\n        const temp = num.replace(new RegExp(`${i}`, \"g\"), \"\");\\n        if (num.length - temp.length !== num.charAt(i) - \\'0\\') {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085920,
                "title": "cpp-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            char t=nums[i];\\n            auto it=m.find(i+\\'0\\');\\n            if(it!=m.end())\\n            {\\n                if(it->second!=t-\\'0\\')\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(it==m.end()&&(t)!=\\'0\\')\\n            {\\n                return false;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            char t=nums[i];\\n            auto it=m.find(i+\\'0\\');\\n            if(it!=m.end())\\n            {\\n                if(it->second!=t-\\'0\\')\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(it==m.end()&&(t)!=\\'0\\')\\n            {\\n                return false;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085579,
                "title": "cpp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i = 0  ; i < num.size() ; i++){\\n                int a = count(num.begin() , num.end() , i+\\'0\\'); // Make sure you actually convert those integers to characters by manipulating those ASCII values , here we count the occurances of the i th indice.\\n                if(a!=(num[i]-\\'0\\')) \\n                        return false;\\n        }\\n            return true;\\n    }\\n};\\n```\\n**Please upvote if you find this helpful**",
                "solutionTags": [
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i = 0  ; i < num.size() ; i++){\\n                int a = count(num.begin() , num.end() , i+\\'0\\'); // Make sure you actually convert those integers to characters by manipulating those ASCII values , here we count the occurances of the i th indice.\\n                if(a!=(num[i]-\\'0\\')) \\n                        return false;\\n        }\\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085435,
                "title": "0-ms-faster-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=\\'0\\') //if any number is occuring zero times then do not add that number into map\\n                mp[i] = nums[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i]-\\'0\\') == mp.end())\\n                return false;\\n            \\n            mp[nums[i]-\\'0\\']--;\\n            if(mp[nums[i]-\\'0\\']==0) //if value become zero then remove it from the map.\\n                mp.erase(nums[i]-\\'0\\');\\n        }\\n        if(mp.size()==0) // if map is empty then return true.\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=\\'0\\') //if any number is occuring zero times then do not add that number into map\\n                mp[i] = nums[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i]-\\'0\\') == mp.end())\\n                return false;\\n            \\n            mp[nums[i]-\\'0\\']--;\\n            if(mp[nums[i]-\\'0\\']==0) //if value become zero then remove it from the map.\\n                mp.erase(nums[i]-\\'0\\');\\n        }\\n        if(mp.size()==0) // if map is empty then return true.\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085302,
                "title": "go-golang-solution",
                "content": "```go\\nfunc digitCount(num string) bool {\\n    n := len(num)\\n    var a [10]int\\n    var b [10]int\\n    for i := 0; i < n; i++ {\\n        a[num[i] - \\'0\\']++\\n        b[i] = int(num[i] - \\'0\\')\\n    }\\n    return a == b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc digitCount(num string) bool {\\n    n := len(num)\\n    var a [10]int\\n    var b [10]int\\n    for i := 0; i < n; i++ {\\n        a[num[i] - \\'0\\']++\\n        b[i] = int(num[i] - \\'0\\')\\n    }\\n    return a == b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085072,
                "title": "hasmap-counting-c-sort-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n      map<int,int>mp;\\n        for(auto it:num){\\n            mp[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n      map<int,int>mp;\\n        for(auto it:num){\\n            mp[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084831,
                "title": "c-array",
                "content": "```\\n    public bool DigitCount(string num)\\n    {\\n        int[] freq = new int[10];\\n        foreach (char n in num)\\n            freq[n - \\'0\\']++;\\n\\n        for (int i = 0; i < num.Length; i++)\\n            if (num[i] - \\'0\\' != freq[i])\\n                return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n    public bool DigitCount(string num)\\n    {\\n        int[] freq = new int[10];\\n        foreach (char n in num)\\n            freq[n - \\'0\\']++;\\n\\n        for (int i = 0; i < num.Length; i++)\\n            if (num[i] - \\'0\\' != freq[i])\\n                return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084695,
                "title": "c-solution",
                "content": "**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public bool DigitCount(string num) {\\n        \\n        if(string.IsNullOrEmpty(num))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int[] freq = new int[10];\\n        foreach(var c in num)\\n            freq[c - \\'0\\']++;\\n        \\n        for(int i = 0; i < num.Length; i++)\\n        {\\n            if(freq[i] != num[i] - \\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool DigitCount(string num) {\\n        \\n        if(string.IsNullOrEmpty(num))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int[] freq = new int[10];\\n        foreach(var c in num)\\n            freq[c - \\'0\\']++;\\n        \\n        for(int i = 0; i < num.Length; i++)\\n        {\\n            if(freq[i] != num[i] - \\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084574,
                "title": "python-counter-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counts = Counter(num)\\n        for i in range(len(num)):\\n            if counts[str(i)] != int(num[i]):\\n                return False\\n        return True \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counts = Counter(num)\\n        for i in range(len(num)):\\n            if counts[str(i)] != int(num[i]):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084512,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int n = num.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(num[j] - \\'0\\' == i)\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            mp[i] = count;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp[i] != num[i] - \\'0\\')\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int n = num.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(num[j] - \\'0\\' == i)\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            mp[i] = count;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp[i] != num[i] - \\'0\\')\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084315,
                "title": "clean-python-code-using-counter",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for idx, val in enumerate(num):\\n            if int(val) != d[str(idx)]:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for idx, val in enumerate(num):\\n            if int(val) != d[str(idx)]:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084106,
                "title": "c-simple",
                "content": "\\n\\n    class Solution {\\n\\n    public:\\n    bool digitCount(string num) {\\n       vector<int>v(11,0);\\n        for(int i=0;i<num.size();i++){\\n          v[num[i]-\\'0\\']++;\\n            //cout<<v[num[i]-\\'0\\']<<\" \";\\n        }\\n        for(int i=0;i<num.size();i++){\\n            int x=num[i]-\\'0\\';\\n            if(v[i]!=x){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public:\\n    bool digitCount(string num) {\\n       vector<int>v(11,0);\\n        for(int i=0;i<num.size();i++){\\n          v[num[i]-\\'0\\']++;\\n            //cout<<v[num[i]-\\'0\\']<<\" \";\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2083968,
                "title": "simple-c-using-map-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mp;\\n        for(auto x:num) mp[x-\\'0\\']++;\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]-\\'0\\'!=mp[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**If you like this, Do Upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mp;\\n        for(auto x:num) mp[x-\\'0\\']++;\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]-\\'0\\'!=mp[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083919,
                "title": "easy-short-efficient-solution",
                "content": "```\\nclass Solution {\\n#define ln ListNode\\n#define tn TreeNode\\n    typedef long long ll;\\n    typedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    bool digitCount(string& s) {\\n        vi hash(10);\\n        for (char& ch : s)\\n            ++hash[ch - \\'0\\'];\\n        for (ll i = 0;i < s.length();++i)\\n            if (hash[i] != (s[i] - \\'0\\'))return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define ln ListNode\\n#define tn TreeNode\\n    typedef long long ll;\\n    typedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    bool digitCount(string& s) {\\n        vi hash(10);\\n        for (char& ch : s)\\n            ++hash[ch - \\'0\\'];\\n        for (ll i = 0;i < s.length();++i)\\n            if (hash[i] != (s[i] - \\'0\\'))return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083886,
                "title": "solution-using-hash-map-in-python",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        leng = len(num)\\n        freq = {}\\n        \\n        for i in range(leng):\\n            freq[str(i)] = 0\\n            \\n        for i in range(leng):\\n            if num[i] in freq:\\n                freq[num[i]] += 1\\n        \\n        for i in range(leng):\\n            if num[i] == str(freq[str(i)]):\\n                continue\\n            else:\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        leng = len(num)\\n        freq = {}\\n        \\n        for i in range(leng):\\n            freq[str(i)] = 0\\n            \\n        for i in range(leng):\\n            if num[i] in freq:\\n                freq[num[i]] += 1\\n        \\n        for i in range(leng):\\n            if num[i] == str(freq[str(i)]):\\n                continue\\n            else:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083855,
                "title": "c-easy-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> mp1,mp2;\\n        int i=0;\\n        for(char ch:num)\\n        {\\n            if(ch!=\\'0\\')\\n            mp1[i]=ch-\\'0\\';\\n                i++;\\n        }\\n        for(char ch:num)\\n        {\\n            mp2[ch-\\'0\\']++;\\n        }\\n        return mp1==mp2;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> mp1,mp2;\\n        int i=0;\\n        for(char ch:num)\\n        {\\n            if(ch!=\\'0\\')\\n            mp1[i]=ch-\\'0\\';\\n                i++;\\n        }\\n        for(char ch:num)\\n        {\\n            mp2[ch-\\'0\\']++;\\n        }\\n        return mp1==mp2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083835,
                "title": "c-easy-with-explanation",
                "content": "```\\n// Easy solution. We\\'ll first populate the array by string elements and then check if they \\n//are equal or not.\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n = num.size();\\n        vector<int> arr(10,0);\\n        for(auto &it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        bool ans = 1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] != num[i]-\\'0\\'){\\n                ans = 0;\\n                break;\\n            }\\n        }\\n        if(ans)\\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Easy solution. We\\'ll first populate the array by string elements and then check if they \\n//are equal or not.\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n = num.size();\\n        vector<int> arr(10,0);\\n        for(auto &it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        bool ans = 1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] != num[i]-\\'0\\'){\\n                ans = 0;\\n                break;\\n            }\\n        }\\n        if(ans)\\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083824,
                "title": "java-do-as-they-ask",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] bucket = new int[10];\\n        for (char c : num.toCharArray()) {\\n            bucket[c - \\'0\\']++;\\n        }\\n        int i = 0;\\n        for (; i < num.length(); i++) {\\n            if (bucket[i] != num.charAt(i) - \\'0\\') return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] bucket = new int[10];\\n        for (char c : num.toCharArray()) {\\n            bucket[c - \\'0\\']++;\\n        }\\n        int i = 0;\\n        for (; i < num.length(); i++) {\\n            if (bucket[i] != num.charAt(i) - \\'0\\') return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083772,
                "title": "c-using-10-size-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int arr[10] = {0};\\n        for(auto it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(arr[i]!=(num[i])-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int arr[10] = {0};\\n        for(auto it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(arr[i]!=(num[i])-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083762,
                "title": "python-java-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef digitCount(self, num: str) -> bool:\\n\\t\\t\\tcnt = collections.Counter(num)\\n\\t\\t\\tfor i, digit in enumerate(num):\\n\\t\\t\\t\\tif cnt[str(i)] != int(digit):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean digitCount(String num) {\\n\\t\\t\\tint[] cnt = new int[10];\\n\\t\\t\\tfor (char c: num.toCharArray()) {\\n\\t\\t\\t\\tcnt[c - \\'0\\'] += 1;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < num.length(); i ++) {\\n\\t\\t\\t\\tif (cnt[i] != num.charAt(i) - \\'0\\') {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef digitCount(self, num: str) -> bool:\\n\\t\\t\\tcnt = collections.Counter(num)\\n\\t\\t\\tfor i, digit in enumerate(num):\\n\\t\\t\\t\\tif cnt[str(i)] != int(digit):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean digitCount(String num) {\\n\\t\\t\\tint[] cnt = new int[10];\\n\\t\\t\\tfor (char c: num.toCharArray()) {\\n\\t\\t\\t\\tcnt[c - \\'0\\'] += 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4084293,
                "title": "check-if-number-has-equal-digit-count",
                "content": "# Approach\\n1. Split number into an array by converting it into a string and the split methods.\\n2. By default, set all numbers to be true. \\n3. Use a for loop to iterate through the array. \\n4. For each loop, get the length of the filtered array - count. \\n5. Filter the array to find if the string \\'x\\' is equal to stringified index \\'i\\'. \\n6. If count does not equal the value at arr[i], switch isValid to false and break the loop. \\n7. return isValid\\n\\n\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const arr = num.toString().split(\\'\\');\\n    let isValid = true;\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const count = arr.filter((x) => x === i.toString()).length;\\n        if (count !== parseInt(arr[i])) {\\n            isValid = false;\\n            break;\\n        }\\n    }\\n\\n    return isValid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const arr = num.toString().split(\\'\\');\\n    let isValid = true;\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const count = arr.filter((x) => x === i.toString()).length;\\n        if (count !== parseInt(arr[i])) {\\n            isValid = false;\\n            break;\\n        }\\n    }\\n\\n    return isValid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079858,
                "title": "python-dictionary-solution-beats-99-in-memory-70-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = {}\\n        n = list(map(int, num))\\n        for i in n:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        res = True\\n        for i in range(len(n)):\\n            if i in d:\\n                if d[i] != n[i]:\\n                    res = False\\n                    break\\n            elif i not in d:\\n                if n[i] > 0:\\n                    res = False\\n                    break\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = {}\\n        n = list(map(int, num))\\n        for i in n:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        res = True\\n        for i in range(len(n)):\\n            if i in d:\\n                if d[i] != n[i]:\\n                    res = False\\n                    break\\n            elif i not in d:\\n                if n[i] > 0:\\n                    res = False\\n                    break\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079441,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[10];\\n\\n        for (final char c : num.toCharArray())\\n        ++count[c - \\'0\\'];\\n\\n        for (int i = 0; i < num.length(); ++i)\\n        if (count[i] != num.charAt(i) - \\'0\\')\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[10];\\n\\n        for (final char c : num.toCharArray())\\n        ++count[c - \\'0\\'];\\n\\n        for (int i = 0; i < num.length(); ++i)\\n        if (count[i] != num.charAt(i) - \\'0\\')\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078817,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously try to avoid n2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPutting the digits and their associated occurence in the map. You need to go through the num string again and decrease every time you see a digit. If the map holds digits for which the number of occurence left is not 0, than we have a problem.\\nCould be optmized.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) Map has a maximum of 10 entries.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> myMap;\\n\\n        for (int i=0; i<num.size(); i++) {\\n            myMap[i] = (int) num[i] -48; \\n        }\\n\\n        for (int i=0; i<num.size(); i++) { \\n            myMap[(int) num[i] -48]--;\\n        }\\n\\n        for (const auto & [key, value] : myMap)\\n            if (value != 0) return false;\\n\\n        return true;\\n    }\\n};\\n\\n// 0 apparait 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> myMap;\\n\\n        for (int i=0; i<num.size(); i++) {\\n            myMap[i] = (int) num[i] -48; \\n        }\\n\\n        for (int i=0; i<num.size(); i++) { \\n            myMap[(int) num[i] -48]--;\\n        }\\n\\n        for (const auto & [key, value] : myMap)\\n            if (value != 0) return false;\\n\\n        return true;\\n    }\\n};\\n\\n// 0 apparait 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078556,
                "title": "two-lines-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        cnt = Counter(map(int, num))\\n        return all(cnt[i] == int(n) for i, n in enumerate(num))      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        cnt = Counter(map(int, num))\\n        return all(cnt[i] == int(n) for i, n in enumerate(num))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071840,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for(int i=0;i<num.length();i++){\\n            freq[num.charAt(i)-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(i)-\\'0\\' != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for(int i=0;i<num.length();i++){\\n            freq[num.charAt(i)-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(i)-\\'0\\' != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071042,
                "title": "easy-c-solution",
                "content": "# Approach\\n- Build dictionary - cahr and number of occurencies of tthe char\\n- Check if ther condiction holds for each index\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool DigitCount(string num)\\n    {\\n        var dictionary = new Dictionary<char, int>();\\n        foreach (var c in num)\\n        {\\n            dictionary[c] = dictionary.GetValueOrDefault(c) + 1;\\n        }\\n\\n        return !num.Where((t, i) => dictionary.GetValueOrDefault((char) (\\'0\\' + i)) != t - \\'0\\').Any();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool DigitCount(string num)\\n    {\\n        var dictionary = new Dictionary<char, int>();\\n        foreach (var c in num)\\n        {\\n            dictionary[c] = dictionary.GetValueOrDefault(c) + 1;\\n        }\\n\\n        return !num.Where((t, i) => dictionary.GetValueOrDefault((char) (\\'0\\' + i)) != t - \\'0\\').Any();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058408,
                "title": "c-100-faster-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(|hashTable|)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tbool digitCount(string num) {\\n\\n\\t\\tint count[10] = {0};\\n\\n\\t\\tint inputSize = num.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tcount[num[i]-48]++;\\n\\t\\t}\\n\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif( (num[i]-48) !=  count[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool digitCount(string num) {\\n\\n\\t\\tint count[10] = {0};\\n\\n\\t\\tint inputSize = num.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tcount[num[i]-48]++;\\n\\t\\t}\\n\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif( (num[i]-48) !=  count[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047491,
                "title": "python-o-1-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        \\n        return True\\n           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        \\n        return True\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046356,
                "title": "easy-and-understandable-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n       \\n       vector<int>v;\\n       unordered_map<int,int>mp;\\n\\n       for(auto it:num)\\n       v.push_back(it-48);\\n\\n       for(auto it:v)\\n       mp[it]++;\\n\\n       for(int i=0;i<v.size();i++){\\n           if(mp[i]!=v[i])\\n            return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n       \\n       vector<int>v;\\n       unordered_map<int,int>mp;\\n\\n       for(auto it:num)\\n       v.push_back(it-48);\\n\\n       for(auto it:v)\\n       mp[it]++;\\n\\n       for(int i=0;i<v.size();i++){\\n           if(mp[i]!=v[i])\\n            return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045126,
                "title": "2283-check-if-number-has-equal-digit-count-and-digit-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n           HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n\\n        for(int index = 0; index< num.length(); index++) {\\n\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n           HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n\\n        for(int index = 0; index< num.length(); index++) {\\n\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042268,
                "title": "easiest-approach-beats-100-c-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> san;\\n        for(auto &x:num)\\n            san[x]++;\\n        int k=0;\\n        int desh=num.size();\\n        while(desh--){\\n            if(san[(char)(k+48)]!=(num[k]-\\'0\\'))\\n                return false;\\n            k++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> san;\\n        for(auto &x:num)\\n            san[x]++;\\n        int k=0;\\n        int desh=num.size();\\n        while(desh--){\\n            if(san[(char)(k+48)]!=(num[k]-\\'0\\'))\\n                return false;\\n            k++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032741,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to check if a given string num satisfies a specific condition where each digit i must occur exactly i times in the string. If this condition is met for every digit, the function returns true; otherwise, it returns false. The code uses a HashMap to count the occurrences of each digit in the string and compares the counts with the expected values.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the first character of the string is \\'0\\'. If it is, return false because \\'0\\' cannot be the first character if every digit should occur at least once.\\n\\n2. Initialize a HashMap<Integer, Integer> called map to store the counts of each digit.\\n\\n3. Iterate through each character ch in the string num:\\n\\n4. Calculate the numeric value k of the current character by subtracting \\'0\\' from it.\\nUpdate the count of digit k in the map by using map.put(k, map.getOrDefault(k, 0) + 1).\\nIterate through the indices i from 0 to n-1, where n is the length of the string num:\\n\\n5. Calculate the numeric value m of the digit at index i in num.\\nCheck if m is equal to the count of digit i in the map using map.getOrDefault(i, 0).\\nIf m is not equal to the expected count, return false.\\nIf the code reaches this point without returning false, it means that the condition is satisfied for every digit, so return true.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the string num twice, once to count the occurrences of each digit and once to check if the counts match the expected values. Therefore, the time complexity is O(2n), which simplifies to O(n), where n is the length of the input string num.\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a HashMap to store the counts of digits, which can have a maximum of 10 entries (0 to 9). Therefore, the space complexity is O(10), which simplifies to O(1) as it\\'s a constant space requirement.\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        if (num.charAt(0) == \\'0\\') return false;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = num.length();\\n\\n        for (char ch : num.toCharArray()){\\n            int k = ch - \\'0\\';\\n            map.put(k, map.getOrDefault(k, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            int m = num.charAt(i) - \\'0\\';\\n            if (m != map.getOrDefault(i, 0)){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n![Frame 76.png](https://assets.leetcode.com/users/images/31fa458e-ca66-4725-8967-2f81fdd2ed8f_1694460428.0372012.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        if (num.charAt(0) == \\'0\\') return false;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = num.length();\\n\\n        for (char ch : num.toCharArray()){\\n            int k = ch - \\'0\\';\\n            map.put(k, map.getOrDefault(k, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            int m = num.charAt(i) - \\'0\\';\\n            if (m != map.getOrDefault(i, 0)){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031271,
                "title": "python3-easy-2-liner-upvote-if-you-like",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter = Counter(num)\\n        return all(str(counter.get(str(index), 0)) == digit for index, digit in enumerate(num))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter = Counter(num)\\n        return all(str(counter.get(str(index), 0)) == digit for index, digit in enumerate(num))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023967,
                "title": "100-beats-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String nums) {\\n\\n\\n        int[] flag = new int[10];\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            flag[nums.charAt(i)-\\'0\\']++;\\n        }\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            if(nums.charAt(i)-\\'0\\'!=flag[i]) return false;\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String nums) {\\n\\n\\n        int[] flag = new int[10];\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            flag[nums.charAt(i)-\\'0\\']++;\\n        }\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            if(nums.charAt(i)-\\'0\\'!=flag[i]) return false;\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021280,
                "title": "check-if-number-has-equal-digit-count-and-digit-value-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(num.charAt(i)-\\'0\\' != Freq(num,(char)(i + \\'0\\')))\\n            return false;\\n        }\\n        return true;\\n    }\\n    public int Freq(String s , char ch)\\n    {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        if(s.charAt(i)==ch)\\n        f++;\\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(num.charAt(i)-\\'0\\' != Freq(num,(char)(i + \\'0\\')))\\n            return false;\\n        }\\n        return true;\\n    }\\n    public int Freq(String s , char ch)\\n    {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        if(s.charAt(i)==ch)\\n        f++;\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014663,
                "title": "1ms-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014504,
                "title": "1ms-easy-code-java-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012973,
                "title": "one-line-solution-using-list-comprehensions",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return len([x for i, x in enumerate(num) if int(x) == num.count(str(i))]) == len(num)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return len([x for i, x in enumerate(num) if int(x) == num.count(str(i))]) == len(num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009684,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n       int n = num.length();\\n        int count[10] = {0};\\n        for (int i = 0; i < n; i++) {\\n            count[num[i] - \\'0\\']++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (count[i] != num[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n       int n = num.length();\\n        int count[10] = {0};\\n        for (int i = 0; i < n; i++) {\\n            count[num[i] - \\'0\\']++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (count[i] != num[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009618,
                "title": "simple-java-solution-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int arr[]=new int[num.length()];\\n        int c=0;\\n        for(int i=0;i<num.length();i++)\\n            arr[i]=num.charAt(i)-\\'0\\';\\n        for(int i=0;i<arr.length;i++){\\n            int n=arr[i];\\n            for(int j=0;j<arr.length;j++){\\n                if(arr[j]==i)\\n                    c++;\\n            }\\n            if(c!=n)\\n                return false;\\n            c=0;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int arr[]=new int[num.length()];\\n        int c=0;\\n        for(int i=0;i<num.length();i++)\\n            arr[i]=num.charAt(i)-\\'0\\';\\n        for(int i=0;i<arr.length;i++){\\n            int n=arr[i];\\n            for(int j=0;j<arr.length;j++){\\n                if(arr[j]==i)\\n                    c++;\\n            }\\n            if(c!=n)\\n                return false;\\n            c=0;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007228,
                "title": "beats-82-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n     let n = new Map();\\n    let numArray = num.split(\\'\\');\\n    for (i = 0; i < numArray.length; i++) {\\n        let val = 0;\\n        let index = Number(numArray[i]);\\n        n.get(index) ? val = n.get(index) + 1 : val = 1\\n        n.set(index, val);\\n    }\\n    for (i = 0; i < num.length; i++) {\\n        const a = Number(n.get(i)) || 0\\n        const b = Number(numArray[i])\\n        if (a !== b) {\\n            return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n     let n = new Map();\\n    let numArray = num.split(\\'\\');\\n    for (i = 0; i < numArray.length; i++) {\\n        let val = 0;\\n        let index = Number(numArray[i]);\\n        n.get(index) ? val = n.get(index) + 1 : val = 1\\n        n.set(index, val);\\n    }\\n    for (i = 0; i < num.length; i++) {\\n        const a = Number(n.get(i)) || 0\\n        const b = Number(numArray[i])\\n        if (a !== b) {\\n            return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004424,
                "title": "java-easy-solution-hashing-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean digitCount(String num) {\\n        int[] hash = new int[10];\\n        for(int n : num.toCharArray())\\n            hash[n-\\'0\\'-0]++;\\n        for(int i=0; i<num.length(); i++) \\n        \\tif(num.charAt(i)-\\'0\\'-0 != hash[i]) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean digitCount(String num) {\\n        int[] hash = new int[10];\\n        for(int n : num.toCharArray())\\n            hash[n-\\'0\\'-0]++;\\n        for(int i=0; i<num.length(); i++) \\n        \\tif(num.charAt(i)-\\'0\\'-0 != hash[i]) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001639,
                "title": "runtime-0ms-beats-100-00-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for (int i=0;i<num.size();i++){\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for (int j=0;j<num.size();j++){\\n            if (v[j]!=(int)num[j]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for (int i=0;i<num.size();i++){\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for (int j=0;j<num.size();j++){\\n            if (v[j]!=(int)num[j]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999682,
                "title": "python3-just-count-and-compare",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        N = len(num)\\n        cnts = [0]*10\\n        for n in num:\\n            cnts[int(n)]+=1\\n\\n        for i in range(N):\\n            if cnts[i] != int(num[i]):\\n                return False\\n\\n        return True            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        N = len(num)\\n        cnts = [0]*10\\n        for n in num:\\n            cnts[int(n)]+=1\\n\\n        for i in range(N):\\n            if cnts[i] != int(num[i]):\\n                return False\\n\\n        return True            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994411,
                "title": "typescript-simple-solution-100-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/63c37f02-c7f7-477b-9b62-9d963e8f500a_1693692919.8918602.png)\\n\\n# Code (100% speed)\\n```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994410,
                "title": "typescript-simple-solution-100-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/63c37f02-c7f7-477b-9b62-9d963e8f500a_1693692919.8918602.png)\\n\\n# Code (100% speed)\\n```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991812,
                "title": "0-ms-beats-100-00-of-users-with-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> ans; \\n        for(int i=0;i<num.size();i++)\\n        {\\n            int temp=num[i]-48;\\n            ans.push_back(temp);\\n        }\\n        int f=0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n        }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            int c=count(ans.begin(),ans.end(),i);\\n            if(c==ans[i])\\n            {\\n                f=1;\\n            }\\n            else\\n            {\\n                f=0;\\n                break;\\n            }\\n        }\\n        if(f==1)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> ans; \\n        for(int i=0;i<num.size();i++)\\n        {\\n            int temp=num[i]-48;\\n            ans.push_back(temp);\\n        }\\n        int f=0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n        }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            int c=count(ans.begin(),ans.end(),i);\\n            if(c==ans[i])\\n            {\\n                f=1;\\n            }\\n            else\\n            {\\n                f=0;\\n                break;\\n            }\\n        }\\n        if(f==1)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3981858,
                "title": "java-easy-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++){\\n            int m=Integer.parseInt(String.valueOf(num.charAt(i)));\\n            int c=0;\\n            for(int j=0;j<num.length();j++){\\n                int n=Integer.parseInt(String.valueOf(num.charAt(j)));\\n                if(n==i){\\n                    c++;\\n                }\\n            }\\n            if(c!=m){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++){\\n            int m=Integer.parseInt(String.valueOf(num.charAt(i)));\\n            int c=0;\\n            for(int j=0;j<num.length();j++){\\n                int n=Integer.parseInt(String.valueOf(num.charAt(j)));\\n                if(n==i){\\n                    c++;\\n                }\\n            }\\n            if(c!=m){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970056,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> vec(10,0);\\n        char c;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            c=num[i];\\n            vec[c-\\'0\\']++;\\n        }\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(num[i]-\\'0\\'!=vec[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> vec(10,0);\\n        char c;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            c=num[i];\\n            vec[c-\\'0\\']++;\\n        }\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(num[i]-\\'0\\'!=vec[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969137,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969134,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965992,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] c= new int[10];\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[n]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[i]-=n;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(c[i]!=0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] c= new int[10];\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[n]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[i]-=n;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(c[i]!=0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960239,
                "title": "easy-to-read-python-solution-with-explanation-in-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        #convert the num into a string\\n\\n        strNum = str(num)\\n\\n        #build a freq map of the digits in the num\\n\\n        digitCounter = Counter()\\n\\n        for digit in strNum:\\n            digitCounter[digit] += 1\\n        \\n        #now start parsing thru the number again\\n        # for each index, check if the frequency of the index\\n        # equal the digit at the index\\n\\n        for i in range(0, len(strNum)):\\n            indexStr = str(i) #converting the index into a str so we can look it up in the dict\\n            digitInt = int(strNum[i]) #converting the digit to an Int so we can compare it to indexStr\\'s frequency\\n            if digitCounter[indexStr] != digitInt:\\n                return False\\n        \\n        #if we come out of the loop, this means that all digits met the condition\\n        # so return true\\n\\n        return True\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        #convert the num into a string\\n\\n        strNum = str(num)\\n\\n        #build a freq map of the digits in the num\\n\\n        digitCounter = Counter()\\n\\n        for digit in strNum:\\n            digitCounter[digit] += 1\\n        \\n        #now start parsing thru the number again\\n        # for each index, check if the frequency of the index\\n        # equal the digit at the index\\n\\n        for i in range(0, len(strNum)):\\n            indexStr = str(i) #converting the index into a str so we can look it up in the dict\\n            digitInt = int(strNum[i]) #converting the digit to an Int so we can compare it to indexStr\\'s frequency\\n            if digitCounter[indexStr] != digitInt:\\n                return False\\n        \\n        #if we come out of the loop, this means that all digits met the condition\\n        # so return true\\n\\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960089,
                "title": "easy-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nbool digitCount(String num) {\\n for (int i = 0; i < num.length; i++) {\\n    int count = 0;\\n\\n    for (int j = 0; j < num.length; j++) {\\n      if (int.parse(num[j]) == i) {\\n        count++;\\n      }\\n    }\\n\\n    if (count != int.parse(num[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\nbool digitCount(String num) {\\n for (int i = 0; i < num.length; i++) {\\n    int count = 0;\\n\\n    for (int j = 0; j < num.length; j++) {\\n      if (int.parse(num[j]) == i) {\\n        count++;\\n      }\\n    }\\n\\n    if (count != int.parse(num[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947496,
                "title": "simple-solution-for-beginners-using-arraylist-java",
                "content": "# Intuition\\nBy understanding the problem one thing is clear that the first index is 0 and therefore for a single digit number input output will always be false as a single digit number has a frequency of one and index is 0. I found a way to separate the digit after checking for the above condition and after separating the digits i just checked remaining conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter checking the single digit condition, I used logic of reversal of digit to separate the digits and stored the output in an ArrayList. After that I reversed the ArrayList as our digit was reversed it would have given wrong output if not reversed. Now we have the original number ... we will just use two for loops one for index digit and  another for traversing through the arraylist for the occurences. Then after counting the occurences I just compared it with the actual frequency we must have and after repeating this process if at some point occurrences and the given frequency is not equal we return false and breakout of the loop or return true as default value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nit has a 2ms runtime and code is bit heavy but as a beginner it was easy for me ....I do admit the hashmap makes this stuff easies and char to int conversion methods can also be used but as I was solving i came up with this solution as a beginner.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Long k = Long.valueOf(num);\\n        return digitCount(k);\\n    }\\n    private boolean digitCount(long numb){\\n        ArrayList<Long> list1 = new ArrayList<Long>();\\n        boolean res = true;\\n        if(numb>=10){\\n        long temp = numb;\\n        while(temp>0){\\n            list1.add(temp%10);\\n            temp=temp/10;\\n        }\\n        Collections.reverse(list1);\\n        for(int i=0;i<list1.size();i++){\\n            int count = 0;\\n            for(int k=0;k<list1.size();k++)\\n            {\\n                if(i==list1.get(k))\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count==list1.get(i))\\n            {\\n                res = true;\\n            }\\n            else\\n            {\\n                res = false;\\n                break;\\n            }\\n        }\\n        }\\n        else\\n        {\\n         res = false;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Long k = Long.valueOf(num);\\n        return digitCount(k);\\n    }\\n    private boolean digitCount(long numb){\\n        ArrayList<Long> list1 = new ArrayList<Long>();\\n        boolean res = true;\\n        if(numb>=10){\\n        long temp = numb;\\n        while(temp>0){\\n            list1.add(temp%10);\\n            temp=temp/10;\\n        }\\n        Collections.reverse(list1);\\n        for(int i=0;i<list1.size();i++){\\n            int count = 0;\\n            for(int k=0;k<list1.size();k++)\\n            {\\n                if(i==list1.get(k))\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count==list1.get(i))\\n            {\\n                res = true;\\n            }\\n            else\\n            {\\n                res = false;\\n                break;\\n            }\\n        }\\n        }\\n        else\\n        {\\n         res = false;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942507,
                "title": "python-2-lines",
                "content": "# Approach\\nNot the best option as we need to iterate over all **num** in all cases. Without 2 lines we can return False as soon as one condition is False.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        return all(1 if str(d[str(i)]) == num[i] else 0 for i in range(len(num)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        return all(1 if str(d[str(i)]) == num[i] else 0 for i in range(len(num)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942332,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] digit = new int[10];\\n        for(char c :num.toCharArray()){\\n            digit[c-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n = num.charAt(i) - \\'0\\';\\n            if(n!=digit[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] digit = new int[10];\\n        for(char c :num.toCharArray()){\\n            digit[c-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n = num.charAt(i) - \\'0\\';\\n            if(n!=digit[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933004,
                "title": "beats-93-85-of-users-with-javascript-easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function (num) {\\n\\n    // initialize function checkCount with parameter index\\n    function checkCount(index) {\\n\\n        // initialize count to zero\\n        let count = 0;\\n\\n        // loop through every character of string num\\n        for (let j = 0; j < num.length; j++) {\\n\\n            // if index is equal to every character of string num then increment count\\n            if (index == num[j]) {\\n\\n                count++;\\n            }\\n        }\\n\\n        // return count\\n        return count;\\n    }\\n\\n    // loop through every character of string num\\n    for (let i = 0; i < num.length; i++) {\\n\\n        // invoke the function checkCount with argument index i\\n        let digitCount = checkCount(i);\\n\\n        // if every character of num is not equal to digitCount then return false\\n        if (num[i] != digitCount) {\\n\\n            return false;\\n        }\\n    }\\n\\n    // return true\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function (num) {\\n\\n    // initialize function checkCount with parameter index\\n    function checkCount(index) {\\n\\n        // initialize count to zero\\n        let count = 0;\\n\\n        // loop through every character of string num\\n        for (let j = 0; j < num.length; j++) {\\n\\n            // if index is equal to every character of string num then increment count\\n            if (index == num[j]) {\\n\\n                count++;\\n            }\\n        }\\n\\n        // return count\\n        return count;\\n    }\\n\\n    // loop through every character of string num\\n    for (let i = 0; i < num.length; i++) {\\n\\n        // invoke the function checkCount with argument index i\\n        let digitCount = checkCount(i);\\n\\n        // if every character of num is not equal to digitCount then return false\\n        if (num[i] != digitCount) {\\n\\n            return false;\\n        }\\n    }\\n\\n    // return true\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932535,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>m;\\n       for(int i=0;i<num.length();i++){\\n         m[num[i]]+=1;\\n       } \\n       for(auto i:m){\\n           \\n           if(num[i.first-\\'0\\']-\\'0\\' != i.second){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>m;\\n       for(int i=0;i<num.length();i++){\\n         m[num[i]]+=1;\\n       } \\n       for(auto i:m){\\n           \\n           if(num[i.first-\\'0\\']-\\'0\\' != i.second){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929865,
                "title": "python-easy-for-loop-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def strCount(self, num, i):\\n        return num.count(i)\\n\\n    def digitCount(self, num):\\n        output = \\'\\'\\n        for i in range(len(num)):\\n            total = self.strCount(num, str(i))\\n            output += str(total)\\n        return output == num\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strCount(self, num, i):\\n        return num.count(i)\\n\\n    def digitCount(self, num):\\n        output = \\'\\'\\n        for i in range(len(num)):\\n            total = self.strCount(num, str(i))\\n            output += str(total)\\n        return output == num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924050,
                "title": "python3-solution-with-using-hashmap",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.defaultdict(int)\\n\\n        for char in num:\\n            d[int(char)] += 1\\n\\n        for i in range(len(num)):\\n            if d[i] != int(num[i]): return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.defaultdict(int)\\n\\n        for char in num:\\n            d[int(char)] += 1\\n\\n        for i in range(len(num)):\\n            if d[i] != int(num[i]): return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923038,
                "title": "digit-count-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914807,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] arr = new int[10];\\n        for(char c:num.toCharArray()){\\n            arr[c - \\'0\\']++;\\n        }\\n        for(int i = 0; i < num.length(); i++){\\n            if(num.charAt(i) - \\'0\\' != arr[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] arr = new int[10];\\n        for(char c:num.toCharArray()){\\n            arr[c - \\'0\\']++;\\n        }\\n        for(int i = 0; i < num.length(); i++){\\n            if(num.charAt(i) - \\'0\\' != arr[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911698,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) ~ O(1) since n can be max 10\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int i,j,l=num.length();\\n        int a[10];\\n        memset(a,0,sizeof(a));\\n        bool b = true;\\n        for(i=0;i<l;++i)\\n        {\\n            int c=int(num[i])-48;\\n            a[c]+=1;\\n        }\\n        for(i=0;i<l;++i)\\n        {\\n            if(int(num[i]-48)!=(a[i]))\\n            b=0;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int i,j,l=num.length();\\n        int a[10];\\n        memset(a,0,sizeof(a));\\n        bool b = true;\\n        for(i=0;i<l;++i)\\n        {\\n            int c=int(num[i])-48;\\n            a[c]+=1;\\n        }\\n        for(i=0;i<l;++i)\\n        {\\n            if(int(num[i]-48)!=(a[i]))\\n            b=0;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911306,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nlinear 2n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool digitCount(char * num){\\n\\n    int *fre = (int*)calloc(4, 10);\\n\\n    for(int i = 0; i < strlen(num); i++){\\n        fre[num[i] -\\'0\\']++;\\n    }\\n    for(int i = 0; i < strlen(num); i++){\\n        if(fre[i] !=num[i] - \\'0\\'){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool digitCount(char * num){\\n\\n    int *fre = (int*)calloc(4, 10);\\n\\n    for(int i = 0; i < strlen(num); i++){\\n        fre[num[i] -\\'0\\']++;\\n    }\\n    for(int i = 0; i < strlen(num); i++){\\n        if(fre[i] !=num[i] - \\'0\\'){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906374,
                "title": "easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i]) != c[str(i)]:\\n                return False\\n        return True\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i]) != c[str(i)]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905020,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range (len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range (len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1792237,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 1845321,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 2046477,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 2009175,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            }
        ]
    },
    {
        "title": "Successful Pairs of Spells and Potions",
        "question_content": "<p>You are given two positive integer arrays <code>spells</code> and <code>potions</code>, of length <code>n</code> and <code>m</code> respectively, where <code>spells[i]</code> represents the strength of the <code>i<sup>th</sup></code> spell and <code>potions[j]</code> represents the strength of the <code>j<sup>th</sup></code> potion.</p>\n\n<p>You are also given an integer <code>success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code>success</code>.</p>\n\n<p>Return <em>an integer array </em><code>pairs</code><em> of length </em><code>n</code><em> where </em><code>pairs[i]</code><em> is the number of <strong>potions</strong> that will form a successful pair with the </em><code>i<sup>th</sup></code><em> spell.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [5,1,3], potions = [1,2,3,4,5], success = 7\n<strong>Output:</strong> [4,0,3]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 5 * [1,2,3,4,5] = [5,<u><strong>10</strong></u>,<u><strong>15</strong></u>,<u><strong>20</strong></u>,<u><strong>25</strong></u>]. 4 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n- 2<sup>nd</sup> spell: 3 * [1,2,3,4,5] = [3,6,<u><strong>9</strong></u>,<u><strong>12</strong></u>,<u><strong>15</strong></u>]. 3 pairs are successful.\nThus, [4,0,3] is returned.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [3,1,2], potions = [8,5,8], success = 16\n<strong>Output:</strong> [2,0,2]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 3 * [8,5,8] = [<u><strong>24</strong></u>,15,<u><strong>24</strong></u>]. 2 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n- 2<sup>nd</sup> spell: 2 * [8,5,8] = [<strong><u>16</u></strong>,10,<u><strong>16</strong></u>]. 2 pairs are successful. \nThus, [2,0,2] is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == spells.length</code></li>\n\t<li><code>m == potions.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3367914,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each spell, we need to find the number of potions that can form a successful pair with it. A pair is successful if the product of their strengths is at least the given success value. To find the number of successful pairs for each spell, we can iterate through the potions array and check if the product of the spell strength and the potion strength is greater than or equal to the success value. If it is, we can increment a counter for that spell. We can then return the counters as an array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We start by initializing the output array `pairs` with all zeros, and sorting the `potions` array in ascending order.\\n \\n2. For each `spell` in `spells`, we perform a binary search on the `potions` array to find the number of `potions` that form a successful pair with the current `spell`. We maintain two pointers `left` and `right` that initially point to the first and last indices\\nof the `potions` array, respectively.\\n\\n3. We repeat the binary search until the `left` and `right` pointers meet or cross each other. In each iteration, we compute the product of the current `spell` and the middle `potion` using long integer multiplication to avoid integer overflow. If the product is greater than or equal to the `success` threshold, we move the `right` pointer to the left of the middle index. Otherwise, we move the `left` pointer to the right of the middle index.\\n\\n4. Once the binary search is complete, we set the corresponding element of `pairs` to the number of `potions` that come after the `left` pointer in the sorted `potions` array, which are guaranteed to form a successful pair with the current `spell`.\\n\\n5. Finally, we return the `pairs` array as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is $$O(n log m)$$, where n is the length of `spells` and m is the length of `potions`, due to the binary search. The space complexity is O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is $$O(1)$$, since we only use a constant amount of extra memory to store the `pairs` array and the binary search pointers.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> pairs(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long long product = (long long)spell * (long long)potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> pairs(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long long product = (long long)spell * (long long)potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138875,
                "title": "javac-python-straignt-forward-with-explantion",
                "content": "# **Explanation**\\nFor each `spell`,\\nit needs ceil integer of `need = success * 1.0 / spell`.\\n\\nBinary search the `index` of first `potion >= need` in the sorted `potions`.\\nThe number of potions that are successful are `potions.length - index`\\n\\nAccumulate the result `res` and finally return it.\\n<br>\\n\\n# **Complexity**\\nTime `O(mlogm + nlogm)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n\\tpublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n```\\n**C++**\\n```cpp\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int a: spells) {\\n            long need = (success + a - 1) / a;\\n            auto it = lower_bound(potions.begin(), potions.end(), need);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def successfulPairs(self, spells, potions, success):\\n        potions.sort()\\n        return [len(potions) - bisect_left(potions, (success + a - 1) // a) for a in spells]\\n```\\n<br>\\n\\n# Solution II: Two Sum\\nSort `spells`\\nSort `potions`\\nNow it\\'s basic two sum question, though it\\'s two mulplication.\\n\\nTime `O(nlogn + mlogm)`\\nSpace `O(n)`\\n\\n**Java**\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] spells0 = spells.clone();\\n        Arrays.sort(potions);\\n        Arrays.sort(spells);\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        int n = spells.length, m = potions.length, j = m - 1, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            while (j >= 0 && 1L * spells[i] * potions[j] >= success)\\n                j--;\\n            count.put(spells[i], m - j - 1);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            res[i] = count.get(spells0[i]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n\\tpublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n```\n```cpp\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int a: spells) {\\n            long need = (success + a - 1) / a;\\n            auto it = lower_bound(potions.begin(), potions.end(), need);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def successfulPairs(self, spells, potions, success):\\n        potions.sort()\\n        return [len(potions) - bisect_left(potions, (success + a - 1) // a) for a in spells]\\n```\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] spells0 = spells.clone();\\n        Arrays.sort(potions);\\n        Arrays.sort(spells);\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        int n = spells.length, m = potions.length, j = m - 1, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            while (j >= 0 && 1L * spells[i] * potions[j] >= success)\\n                j--;\\n            count.put(spells[i], m - j - 1);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            res[i] = count.get(spells0[i]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2139028,
                "title": "c-clean-easy",
                "content": "\\u2764 Please Upvote if you find helpful \\u2764\\n\\n**Explanation (Step by Step)**\\n\\n**Step 1.** \\nThe function starts by initializing the vector `v` with `zeros` and then `sorting` the vector `p` in `non-decreasing` order.\\n\\n**Step 2.** \\nFor each element `s[i]` in vector `s`, a `binary search` is performed on vector `p` to find the index of the `largest` element whose product with `s[i]` is `less than eqaul` to `suc`. The binary search is performed by maintaining two indices `l` and `h` representing the lower and upper bounds of the search range, respectively. The search continues until `l` is `less than equal` to `h`.\\n\\n**Step 3** \\nInside the loop, the middle index `mid` is computed as the average of `l` and `h`. If the product of `s[i]` and `p[mid]` is greater than or equal to suc, the upper bound `h` is adjusted to search the `left half` of the array, otherwise the lower bound `l` is adjusted to search the `right half` of the array.\\n\\n**Step 4**\\nAfter the binary search, the number of successful pairs for the element `s[i]` is calculated by `subtracting` the `index of the last element` found in the search from the `size of p`. This is because all elements in `p` starting from this index `satisfy` the condition for a successful pair.\\n\\n**Step 5**\\nFinally, the vector `v` is returned, containing the number of `successful pairs` for each element in `s`. \\n\\n**FAQ** : `Why binary search is used ?` \\n=> By using binary search, the code avoids the need to compare the current element in s with all elements in p, which would have a time complexity of $$O(n\\xB2)$$. Instead, the binary search algorithm efficiently reduces the search space by dividing it in half at each step, resulting in a much faster search time $$O(nlog(n))$$.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long suc) {\\n        \\n        vector<int> v(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            int h=p.size()-1;\\n            int l=0;\\n            int mid;\\n            while(l<=h)\\n            {\\n                mid = l + (h-l)/2;\\n                \\n                if((long long int)s[i]*(long long int)p[mid] >= suc)\\n                    h = mid-1;\\n                \\n                else\\n                    l = mid+1;\\n            }\\n            \\n            v[i] = p.size()-1-h;\\n        }\\n        \\n        return v;\\n    }\\n};\\n```\\n![IMG_20230402_115743.jpg](https://assets.leetcode.com/users/images/4d144a01-19ce-4def-8200-2c2ca9987f29_1680416869.6585193.jpeg)\\n  \\u2227,,,\\u2227\\n(  \\u0333\\u2022 \\xB7 \\u2022 \\u0333)\\n/    \\u3065\\u2661\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long suc) {\\n        \\n        vector<int> v(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            int h=p.size()-1;\\n            int l=0;\\n            int mid;\\n            while(l<=h)\\n            {\\n                mid = l + (h-l)/2;\\n                \\n                if((long long int)s[i]*(long long int)p[mid] >= suc)\\n                    h = mid-1;\\n                \\n                else\\n                    l = mid+1;\\n            }\\n            \\n            v[i] = p.size()-1-h;\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367922,
                "title": "image-explanation-binary-search-with-without-inbuild-libraries-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Successful Pairs of Spells and Potions` by `Aryan Mittal`\\n![thumb.png](https://assets.leetcode.com/users/images/5857de7f-4a28-4d73-80e0-117e42178bf3_1680402420.5635715.png)\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/99a332e2-1f9b-42b1-9f38-d328ba555a0d_1680397450.5684943.png)\\n![image.png](https://assets.leetcode.com/users/images/95fd5621-491c-49ec-b02a-b7fb09792299_1680397462.2408035.png)\\n![image.png](https://assets.leetcode.com/users/images/5db5d26c-ddce-4df1-8bac-d09eba7231fa_1680397482.1739225.png)\\n![image.png](https://assets.leetcode.com/users/images/e0c85a7d-6300-4e09-99bc-7501984344ef_1680397494.6180933.png)\\n![image.png](https://assets.leetcode.com/users/images/f420160f-7384-4baf-991b-44f7a5b79dfc_1680397503.9567719.png)\\n![image.png](https://assets.leetcode.com/users/images/fb798d7d-2669-44d6-ac56-3af7fc5eec20_1680397511.739848.png)\\n![image.png](https://assets.leetcode.com/users/images/55723900-7dea-43b9-bbf5-8a183d663fd7_1680397521.3559468.png)\\n![image.png](https://assets.leetcode.com/users/images/39a8bc71-7920-4397-a37a-c6fa82d3b416_1680398553.798697.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            long potion_needed = (success + spell - 1) / spell;\\n            auto it = lower_bound(potions.begin(), potions.end(), potion_needed);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n        \\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n}\\n```\\n```Python []\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n```\\n\\n\\n# Code Without Inbuild Libraries\\nExact same [Generalized Binary Search code](https://leetcode.com/problems/binary-search/solutions/3363888/image-explanation-most-generalized-binary-search-cjavapython/) discussed for C++/Java/Python.\\n```C++ []\\nclass Solution {\\npublic:\\n    int valid_pos(vector<int>& potions, long long success, int spell){\\n        long potion_needed = (success + spell - 1) / spell;\\n\\n        int l=0,r=potions.size();\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            if(potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            res.push_back(potions.size()- valid_pos(potions, success, spell));\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int valid_pos(int[] potions, long success, int spell) {\\n        long potion_needed = (success + spell - 1) / spell;\\n        int l = 0, r = potions.length;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] res = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            res[i] = potions.length - valid_pos(potions, success, spells[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def valid_pos(self, potions: List[int], success: int, spell: int) -> int:\\n        potion_needed = (success + spell - 1) // spell\\n        l, r = 0, len(potions)\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if potions[mid] >= potion_needed:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        res = []\\n        for spell in spells:\\n            res.append(len(potions) - self.valid_pos(potions, success, spell))\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            long potion_needed = (success + spell - 1) / spell;\\n            auto it = lower_bound(potions.begin(), potions.end(), potion_needed);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n        \\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n}\\n```\n```Python []\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int valid_pos(vector<int>& potions, long long success, int spell){\\n        long potion_needed = (success + spell - 1) / spell;\\n\\n        int l=0,r=potions.size();\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            if(potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            res.push_back(potions.size()- valid_pos(potions, success, spell));\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int valid_pos(int[] potions, long success, int spell) {\\n        long potion_needed = (success + spell - 1) / spell;\\n        int l = 0, r = potions.length;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] res = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            res[i] = potions.length - valid_pos(potions, success, spells[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def valid_pos(self, potions: List[int], success: int, spell: int) -> int:\\n        potion_needed = (success + spell - 1) // spell\\n        l, r = 0, len(potions)\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if potions[mid] >= potion_needed:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        res = []\\n        for spell in spells:\\n            res.append(len(potions) - self.valid_pos(potions, success, spell))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367934,
                "title": "why-and-how-binary-search-intuition-explained",
                "content": "![image](https://assets.leetcode.com/users/images/4bde32d2-e235-415d-8602-368016c3acdb_1680397806.4855666.png)\\n![image](https://assets.leetcode.com/users/images/32b4d538-b79a-414b-b799-5195c4622a93_1680398342.075346.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        //=============================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //================================================================\\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>ans(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        //=============================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //================================================================\\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>ans(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368203,
                "title": "java-easy-solution-with-detailed-explaination-and-similar-problems-binary-search",
                "content": "# Intuition\\nQuestion reduces to finding no of potions for each spell which have \\n***product greater than success*** where product is (each spell * potions[i])\\n\\nNow decision is whether to keep the potions array sorted or not.\\n\\n- ***NON-SORTED*** Another is to traverse entire array of potions and count no of products(spell * potions[i]) greater than success. But this will take more time as for each spell we will need to traverse entire potions array.\\n\\n- ***SORTED*** Immediate thought to reduce time complexity of above case is to keep potions array sorted, then question reduces to finding the first occurrence of the product( each spell * potions[i]) which is greater than success, so we go with ***Binary search***\\n\\n---\\n\\n\\n# Approach\\n1) Sort potions array.\\n2) For every spell we will find min Index where the product( spell * potion[i]) is greater than success\\n3) Once we find such an index via binary search anser for that spell is \\npotions.length - minIndex\\n4) It is ***important*** how we choose left and right pointers of binary search\\n5) I intialised with left = 0, *right = potion.length and not potion.length-1*, since we can have a case where we donot find any minIndex in that case the minIndex will be potion.length and hence result[i] of such spell[i] = potion.length -minIndex = 0\\n\\n**Similar question[ LC 35 Search and Insert](https://leetcode.com/problems/search-insert-position/) to make you understand point 5 better and how to choose boundaries wisely depending on the question type.**\\n\\n***Generic binary search [understanding](https://leetcode.com/problems/binary-search/solutions/3364223/java-easy-solution-explained-why-leftright-left2-instead-of-leftright2/)***\\n\\n\\n---\\n- Time Complexity\\nO(nlogm): where m is the length of potions array and n of spells array\\n\\n***NOTE***: Reason why 1l is done in ***long product = (1l * spell) * potions[mid];*** because (spell * potions[i]) both being integer will overflow and will result in wrong product value. \\nI wasted a lot of time in this.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/0cb8949f-630b-4e16-b2c8-2f4e7d2007fb_1680404247.5368462.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        \\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n            if(product<success){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        \\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n            if(product<success){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368209,
                "title": "prefix-postfix-sum-c-99-faster-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find out the number of potion values that has product with a specific spell value which is greater than (or equal to) a threshold.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we have to find the amount of values that is greater than a value, the easiest way is to sort the whole array, then do binary search to find out the position that has the smallest element that satisfy the problem. However, since this approach takes `O(nlogn)` times, which might not be the best idea (in my opinion), for the input with size of 10^5, so I got another idea.\\n\\nMy idea was, couting occurences of all numbers, then add from the end, using postfix sum, so that, `postfix[n]` is the number of numbers that has value greater than or equal to value `n` in `potions`. Then, that would take `O(1)`, instead of `O(log n)` for each time do searching for each spell, and `O(n)` for counting, instead of `O(nlogn)` do sorting.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int postfix[100001] = {0};\\n        for(auto potion: potions) postfix[potion]++;\\n        for(int i=99999; i>=0; --i) postfix[i] += postfix[i+1];\\n\\n        //No need extra space at all for storing final result\\n        for(int i=0; i<spells.size(); ++i){\\n            long long val = success / (long long) spells[i];\\n            if(success % (long long) spells[i] != 0) val++;\\n\\n            spells[i] = val <= 1e5 ? postfix[val] : 0;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int postfix[100001] = {0};\\n        for(auto potion: potions) postfix[potion]++;\\n        for(int i=99999; i>=0; --i) postfix[i] += postfix[i+1];\\n\\n        //No need extra space at all for storing final result\\n        for(int i=0; i<spells.size(); ++i){\\n            long long val = success / (long long) spells[i];\\n            if(success % (long long) spells[i] != 0) val++;\\n\\n            spells[i] = val <= 1e5 ? postfix[val] : 0;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138867,
                "title": "binary-search",
                "content": "\\n***If ith potion is successful then all the potions after will be successful.\\n    So find the first potion which is successful using Binary Search.***\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n(size(potions));\\n        sort(begin(potions), end(potions));\\n        \\n        for (auto& spell : spells) {\\n            int start(0), end(n);\\n            while (start < end) {\\n                int mid = start + (end-start)/2;\\n                ((long long)spell*potions[mid] >= success) ? end = mid : start = mid+1;\\n            }\\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n(size(potions));\\n        sort(begin(potions), end(potions));\\n        \\n        for (auto& spell : spells) {\\n            int start(0), end(n);\\n            while (start < end) {\\n                int mid = start + (end-start)/2;\\n                ((long long)spell*potions[mid] >= success) ? end = mid : start = mid+1;\\n            }\\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370925,
                "title": "python-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\n# Video Solution\\n**Search \\uD83D\\uDC49 `Successful Pairs of Spells and Potions by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (7).png](https://assets.leetcode.com/users/images/a66c9634-0226-498d-b8b9-b69647afc108_1680441461.1699626.png)\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\nThe approach for solving the problem is fairly straightforward. We start by sorting the potions list in non-decreasing order. Next, we loop through each spell strength a in the spells list. For each spell, we calculate the minimum strength required for a successful pair by using the formula (success + a - 1) // a. This formula ensures that the result is rounded up to the nearest integer. Once we have the minimum strength required, we use the bisect_left function to find the index of the first potion in the sorted potions list that has strength greater than or equal to the minimum strength required for a successful pair. Finally, we subtract this index from the length of potions to get the number of potions that can form a successful pair for the given spell strength. We repeat this process for each spell strength and store the counts in the result list. Finally, we return the result list.\\n\\n# Intuition:\\n\\nThe problem requires us to find the number of successful pairs of spells and potions. The key to finding a successful pair is to ensure that the strength of the potion is greater than or equal to the minimum strength required for a successful pair for the given spell strength. This minimum strength is calculated by using the formula (success + a - 1) // a, which ensures that the result is rounded up to the nearest integer. Sorting the potions list in non-decreasing order makes it easier to find the right potion for each spell. We use the bisect_left function to find the index of the first potion in the sorted potions list that has strength greater than or equal to the minimum strength required for a successful pair. The difference between the length of potions and this index gives the number of potions that can form a successful pair for the given spell strength. We repeat this process for each spell strength, and the counts are stored in the result list.\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138921,
                "title": "java-python-3-sort-and-binary-search-w-brief-explanation-and-analysis",
                "content": "**Q & A**\\n\\nQ1: Why and how do we need to compute the factor?\\nA1: \\n1) We need a factor from `potions` to multiply with current `spells[i]` in order to get a product at least `success`. Therefore, computing before hand will obtain a key (the factor) for binary search.\\n2) `(success + s) // s = success / s + 1`, which is not ceiling of `success / s`; In contrast, `success / s <= (success + s - 1) // s < success / s + 1`, and therefore `(success + s - 1) // s` is the ceiling. \\n\\nQ2: Why in Python 3 code do we need to compute the ceiling `(success + s - 1) // s`, not `success / s`?\\nA2: For this problem we can use either. ~~~However, if `potions` is a float array then the ceiling way is a must. `success / s` is a float, which has a limited precision. In extreme case it may cause error; Use the ceiling, an int, will guarantee the correctness of the code.~~~\\n\\n~~~e.g., `success = 10, s = 3`, `potions[i] = 3.3333333333...33` (there are `k + 1` 3\\'s) is in `potions`.~~~\\n\\n~~~If we use float `factor = success / s = 10 / 3 = 3.3333333333...3` (there are `k` 3\\'s), then we will miss the correct `potions[i]` in binary search;~~~\\n~~~In contrast, `(success + s - 1) // s = (10 + 3 - 1) // 3 = 4` will guarantee to obtain correct result.~~~\\n\\n**End of Q & A**\\n\\n----\\n\\n1. Sort `potions` for binary search;\\n2. Traverse `spells`, for each element `s`, compute the ceiling of the quotient of `success / s`, `(success + s - 1) / s`;\\n3. Binary search the corresponding ceiling of each quotient in 2. to find out how many pairs with a product at least `success`.\\n\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            if ((success + spells[i] - 1) / spells[i] > 100_000) { // boundary check to avoid int overflow.\\n                int s = spells[i], factor = (int)((success + s - 1) / s);\\n                pairs[i] = potions.length - binarySearch(potions, factor);\\n            } \\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, int key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\\nWe can modify signature of `binarySearch(int[], int)` to `binarySearch(int[], long)` to avoid int overflow problem.\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            long factor = (success + spells[i] - 1) / spells[i];\\n            pairs[i] = potions.length - binarySearch(potions, factor);\\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, long key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\\n\\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        pairs = []\\n        for s in spells:\\n            factor = (success + s - 1) // s\\n            pairs.append(len(potions) - bisect.bisect_left(potions, factor))\\n        return pairs\\n```\\n\\nFor Python 3 code, we can use `success / s` as key for binary search:\\n\\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        return [len(potions) - bisect.bisect_left(potions, success / s) for s in spells]\\n```\\n\\n**Analysis:**\\n\\nTime: `O((m + n)logm)`, space: `O(n + m)` - including sorting space, where `n = spells.length, m = potions.length`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            if ((success + spells[i] - 1) / spells[i] > 100_000) { // boundary check to avoid int overflow.\\n                int s = spells[i], factor = (int)((success + s - 1) / s);\\n                pairs[i] = potions.length - binarySearch(potions, factor);\\n            } \\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, int key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            long factor = (success + spells[i] - 1) / spells[i];\\n            pairs[i] = potions.length - binarySearch(potions, factor);\\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, long key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        pairs = []\\n        for s in spells:\\n            factor = (success + s - 1) // s\\n            pairs.append(len(potions) - bisect.bisect_left(potions, factor))\\n        return pairs\\n```\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        return [len(potions) - bisect.bisect_left(potions, success / s) for s in spells]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2139342,
                "title": "binary-search-vs-two-pointers",
                "content": "In the first approach, we sort `potions`, and use binary search to find the position of the weakest potion that produces a success. All potions to the right would work also.\\n\\nIn the second approach, we sort both `potions` and `spells` (we actually sort indexes `idx` to preserve the order of spells). Then, we use two pointers to track the weakest  `potions[j]` that works for `spells[i]`. Since we process spells from weakest to the strongest, pointer `j` is moved in one direction - from strongest to weakest.\\n\\n#### Binary Search\\n**C++**\\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort(begin(potions), end(potions));\\n    for (int i = 0; i < spells.size(); ++i) {\\n        long long comp = (success + spells[i] - 1) / spells[i];\\n        spells[i] = potions.size() - (lower_bound(begin(potions), end(potions), comp) - begin(potions));\\n    }\\n    return spells;\\n}\\n```\\n#### Two Pointers\\n**C++**\\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    vector<int> idx(spells.size());\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(potions), end(potions), greater<int>());\\n    sort(begin(idx), end(idx), [&](int i, int j){ return spells[i] < spells[j]; });\\n    for (int i = 0, j = 0; i < idx.size(); ++i) {\\n        while (j < potions.size() && (long long)potions[j] * spells[idx[i]] >= success)\\n            ++j;\\n        spells[idx[i]] = j;\\n    }\\n    return spells;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort(begin(potions), end(potions));\\n    for (int i = 0; i < spells.size(); ++i) {\\n        long long comp = (success + spells[i] - 1) / spells[i];\\n        spells[i] = potions.size() - (lower_bound(begin(potions), end(potions), comp) - begin(potions));\\n    }\\n    return spells;\\n}\\n```\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    vector<int> idx(spells.size());\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(potions), end(potions), greater<int>());\\n    sort(begin(idx), end(idx), [&](int i, int j){ return spells[i] < spells[j]; });\\n    for (int i = 0, j = 0; i < idx.size(); ++i) {\\n        while (j < potions.size() && (long long)potions[j] * spells[idx[i]] >= success)\\n            ++j;\\n        spells[idx[i]] = j;\\n    }\\n    return spells;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3369048,
                "title": "java-sorting-binary-search-approach",
                "content": "```\\n// Approach 2: Sorting  + Binary Search (Lower Bound)\\n\\n// Time complexity: O((m + n) log m)\\n// Space complexity: O(log m)\\n\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\tint n = spells.length;\\n\\tint m = potions.length;\\n\\tint[] pairs = new int[n];\\n\\n\\tArrays.sort(potions); // m log m\\n\\n\\tfor (int i = 0; i < n; i++) { // n log m\\n\\t\\tint left = 0, right = m;\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\t\\tif ((long) spells[i] * (long) potions[mid] >= success)\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\n\\t\\tpairs[i] = m - left;\\n\\t}\\n\\n\\treturn pairs;\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n// Approach 2: Sorting  + Binary Search (Lower Bound)\\n\\n// Time complexity: O((m + n) log m)\\n// Space complexity: O(log m)\\n\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\tint n = spells.length;\\n\\tint m = potions.length;\\n\\tint[] pairs = new int[n];\\n\\n\\tArrays.sort(potions); // m log m\\n\\n\\tfor (int i = 0; i < n; i++) { // n log m\\n\\t\\tint left = 0, right = m;\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\t\\tif ((long) spells[i] * (long) potions[mid] >= success)\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\n\\t\\tpairs[i] = m - left;\\n\\t}\\n\\n\\treturn pairs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368113,
                "title": "c-beginner-friendly-explanation-brute-force-to-optimized-intuition",
                "content": "# Brute Force [Time Limit Exceeded]\\n\\n## Intuition\\nInitially, it sounds like we can just multiply each `spell` for each `potion`, but this is not fast enough.\\n\\n## Algorithm Design\\n- Loop for each `spell`\\n   - Loop for each `potion`\\n       - Increase count if the product is $$>=$$ `success`\\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n*m), S:O(1)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            int spell = spells[i];\\n            int count = 0;\\n\\n            // Loop through all potions for each spell\\n            for(int potion: potions) { // O(m)\\n\\n                // Increment count if it exceeds success\\n                long long pair = (long long)potion * (long long)spell;\\n                if(pair >= success) count++;\\n            }\\n            numPairs[i] = count;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O(n*m)$$\\n- Space Complexity: $$O(1)$$\\n  - The resulting array is not considered as space.\\n\\n# Binary Search [Accepted]\\n\\n## Intuition\\nTo reduce search time, we can almost always use binary search. However, the prequisite is sorting. Here, we only need to sort `potions` and find the minimum potion needed to be $$>=$$ `success`.\\n\\n## Algorithm Design\\n- Sort potions\\n- Loop for each `spell`\\n    - Find index of the minimum potion needed\\n    - Calculate the distance since every greater idx is $$>=$$ `success`\\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(m log m + n log m), S:O(log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Sort potions\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            // Find the minimum potion needed for success\\n            long long potionNeeded = ceil(static_cast<double>(success) / spells[i]);\\n\\n            // Find the smallest idx position\\n            auto it = lower_bound(potions.begin(), potions.end(), potionNeeded); // O(log m)\\n            int idx = it - potions.begin();\\n\\n            // Calculate count based on the index\\n            int numPair = potions.size() - (it - potions.begin());\\n            numPairs[i] = max(0, numPair);\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O((m + n)log m)$$\\n- Space Complexity: $$O(log m)$$\\n    - Sorting in C++ takes $$O(log m)$$ space.\\n    - The resulting array is not considered as space.\\n    \\n# Two Pointers [Accepted]\\n\\n## Intuition\\nSince a larger number will always be able to form products $$>=$$ `success` compared to a smaller number, we can use a greedy two pointer approach. \\n\\n#### For example:\\nspells: [1,2,3]\\npotions: [1,2]\\nsuccess: 4\\n\\nIf we take the leftmost `spell` (1) and multiply with rightmost `potion` (2), we get a product of 2. This means any potion of a smaller index will not be possible. If we are able to form a product $$>=$$ `success`, that means any greater `spell` number can form it too.\\n\\n## Algorithm Design\\n- Remember the index of `spells` since we will be sorting\\n- Sort `potions` and `spells`\\n- Initialize two pointers:\\n    - Leftmost of `spells`\\n    - Rightmost of `potions`\\n- While we can form product $$>=$$ `success`, we should decrement `potion` pointer. \\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n log n + m log m), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        unordered_map<int, pair<int, int>> pairsMap; // {spells[i], {idx, numPair}}\\n\\n        // Copy spells into numPairs\\n        vector<int> numPairs(spells); // O(n)\\n        \\n        // Add each number into the map\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            pairsMap[spells[i]] = {i, -1};\\n        }\\n\\n        // Sort both spells and potion\\n        sort(spells.begin(), spells.end()); // O(n log n)\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Two pointer approach\\n        // Spell pointer starts from the left\\n        // Potion pointer starts from the right\\n        int potionPtr = potions.size() - 1;\\n        for(int i = 0; i < spells.size(); i++) { // O(m)\\n            int spell = spells[i];\\n            while(potionPtr >= 0 && (long long) spell * potions[potionPtr] >= success) {\\n                potionPtr--;\\n            }\\n            pairsMap[spell] = {pairsMap[spell].first, potions.size() - 1 - potionPtr};\\n        }\\n\\n        // Put data into vector\\n        int idx = 0;\\n        for(int spell: numPairs) { // O(n)\\n            numPairs[idx++] = pairsMap[spell].second;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O(n log n + m log m)$$\\n- Space Complexity: $$O(n + log m)$$\\n    - Sorting in C++ takes $$O(log n)$$ space.\\n    - The resulting array is not considered as space.",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // T:O(n*m), S:O(1)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            int spell = spells[i];\\n            int count = 0;\\n\\n            // Loop through all potions for each spell\\n            for(int potion: potions) { // O(m)\\n\\n                // Increment count if it exceeds success\\n                long long pair = (long long)potion * (long long)spell;\\n                if(pair >= success) count++;\\n            }\\n            numPairs[i] = count;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(m log m + n log m), S:O(log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Sort potions\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            // Find the minimum potion needed for success\\n            long long potionNeeded = ceil(static_cast<double>(success) / spells[i]);\\n\\n            // Find the smallest idx position\\n            auto it = lower_bound(potions.begin(), potions.end(), potionNeeded); // O(log m)\\n            int idx = it - potions.begin();\\n\\n            // Calculate count based on the index\\n            int numPair = potions.size() - (it - potions.begin());\\n            numPairs[i] = max(0, numPair);\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n log n + m log m), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        unordered_map<int, pair<int, int>> pairsMap; // {spells[i], {idx, numPair}}\\n\\n        // Copy spells into numPairs\\n        vector<int> numPairs(spells); // O(n)\\n        \\n        // Add each number into the map\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            pairsMap[spells[i]] = {i, -1};\\n        }\\n\\n        // Sort both spells and potion\\n        sort(spells.begin(), spells.end()); // O(n log n)\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Two pointer approach\\n        // Spell pointer starts from the left\\n        // Potion pointer starts from the right\\n        int potionPtr = potions.size() - 1;\\n        for(int i = 0; i < spells.size(); i++) { // O(m)\\n            int spell = spells[i];\\n            while(potionPtr >= 0 && (long long) spell * potions[potionPtr] >= success) {\\n                potionPtr--;\\n            }\\n            pairsMap[spell] = {pairsMap[spell].first, potions.size() - 1 - potionPtr};\\n        }\\n\\n        // Put data into vector\\n        int idx = 0;\\n        for(int spell: numPairs) { // O(n)\\n            numPairs[idx++] = pairsMap[spell].second;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369016,
                "title": "linear-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find maximum Spell power.\\n2. Create an array `counts` of length `max spell power` filled with zeros.\\n3. For each potion calculate minimum required spell. If required spell <= maximum spell power, increment counts of required Spell.\\n4. Update `counts` , so `counts[i] = sum(counts[0]...counts[i])`. So `counts` now contains total number of \"good\" potions.\\n5. Fill the results, so `results[i] = counts[spells[i]]`. To save some space, we can use spells as results.\\n\\n# Complexity\\n- Time complexity: O(n + m + k)\\n    spells.size() = n\\n    potions.size() = m\\n    max spells power = k\\n\\n    It can be optimized a little bit. `k` could be `max spells power` - `min spells power`\\n\\n- Space complexity: O(k)\\n  We only use additional space for `counts` array. If we consider `results` as additional space, then O(k+n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367908,
                "title": "day-92-binary-search-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n \\n**NOTE 2 - I WILL HIGHLY RECOMMEND YOU GUYS BEFORE SOLVING THIS PROBLEM PLEASE SOLVE BINARY SEARCH PROBLEM.**\\n\\n**704. Binary Search Problem -** https://leetcode.com/problems/binary-search/\\n**704. Binary Search Solution -** https://leetcode.com/problems/binary-search/solutions/3364016/day-91-binary-search-o-logn-time-easiest-beginner-friendly-sol/\\n\\n# Intuition of this Problem :\\n*The problem is asking to find the number of successful pairings between the spells and potions arrays such that the product of their strengths is at least a given integer \"success\".*\\n\\n***To solve this problem, we can iterate through each spell and for each spell, we can find the index of the first potion whose strength is at least \"success\". This can be done using binary search since the potions array is sorted. Once we have the index, the number of successful pairings can be calculated by subtracting the index from the total number of potions. We can repeat this process for each spell and store the number of successful pairings in an array.***\\n\\n*Finally, we return the array containing the number of successful pairings for each spell.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Define a function binarySearch which takes the input integer spell, a vector of integers potions, and a long integer success and returns an integer value.\\n2. Initialize the integer startIndex to 0, lastIndex to potions.size() - 1, and ansIndex to -1.\\n3. Run a while loop until startIndex is less than or equal to lastIndex.\\n4. Within the loop, calculate the midIndex using (startIndex + (lastIndex - startIndex) / 2) to avoid integer overflow.\\n5. If the product of spell and the midIndex element of potions is greater than or equal to success, then set ansIndex to midIndex and update lastIndex to midIndex - 1.\\n6. Else, update startIndex to midIndex + 1.\\n7. Return ansIndex.\\n8. Initialize an integer m to the size of the potions vector and create an empty vector ans.\\n9. Sort the potions vector in ascending order using sort.\\n10. Iterate through each element spell in the spells vector.\\n11. Initialize an integer countPair to 0.\\n12. Call the binarySearch function with spell, potions, and success as arguments and store the result in the index variable.\\n13. If index is equal to -1, then add 0 to countPair, else add m - index to countPair.\\n14. Append countPair to ans.\\n15. Return ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n//1st Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int countPair = 0;\\n            int index = binarySearch(spell, potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans.push_back(countPair);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```C++ []\\n//2nd Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return lastIndex + 1;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int index = binarySearch(spell, potions, success);\\n            ans.push_back(m - index);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int binarySearch(int spell, int[] potions, long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.length - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int m = potions.length;\\n        int[] ans = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int countPair = 0;\\n            int index = binarySearch(spells[i], potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans[i] = countPair;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def binarySearch(self, spell: int, potions: List[int], success: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(potions) - 1\\n        ansIndex = -1\\n        while startIndex <= lastIndex:\\n            midIndex = (startIndex + (lastIndex - startIndex) // 2)\\n            if spell * potions[midIndex] >= success:\\n                ansIndex = midIndex\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return ansIndex\\n    \\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        ans = []\\n        for spell in spells:\\n            countPair = 0\\n            index = self.binarySearch(spell, potions, success)\\n            if index == -1:\\n                countPair += 0\\n            else:\\n                countPair += (m - index)\\n            ans.append(countPair)\\n        return ans\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O((n + m) log m)**, where n is the length of the spells vector and m is the length of the potions vector.\\n\\n*The sort function takes O(m log m) time where \\'m\\' is the size of the potions vector.\\nFor each spell, the binarySearch function is called which takes O(log m) time.\\nTherefore, the time complexity of the entire solution is O(n log m + m log m), where \\'n\\' is the size of the spells vector.*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(m + n)**, since we need to store the result in the ans vector.\\n\\n*The space complexity of the solution is O(m) to store the sorted potions vector, and O(n) to store the output vector of size \\'n\\'.\\nTherefore, the total space complexity of the solution is O(m + n).*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\n//1st Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int countPair = 0;\\n            int index = binarySearch(spell, potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans.push_back(countPair);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\n//2nd Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return lastIndex + 1;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int index = binarySearch(spell, potions, success);\\n            ans.push_back(m - index);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int binarySearch(int spell, int[] potions, long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.length - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int m = potions.length;\\n        int[] ans = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int countPair = 0;\\n            int index = binarySearch(spells[i], potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans[i] = countPair;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def binarySearch(self, spell: int, potions: List[int], success: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(potions) - 1\\n        ansIndex = -1\\n        while startIndex <= lastIndex:\\n            midIndex = (startIndex + (lastIndex - startIndex) // 2)\\n            if spell * potions[midIndex] >= success:\\n                ansIndex = midIndex\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return ansIndex\\n    \\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        ans = []\\n        for spell in spells:\\n            countPair = 0\\n            index = self.binarySearch(spell, potions, success)\\n            if index == -1:\\n                countPair += 0\\n            else:\\n                countPair += (m - index)\\n            ans.append(countPair)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370613,
                "title": "simple-c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- the approach that is used here is `binary search`.\\n- So first we `sort` the potions.\\n- then we traverse through `every element in spell` and multiply it to the potions.\\n- and because our potions is `sorted` we can apply binary search now.\\n- so by doing that we can get the minimum element in `potions` which has multiplication `>=` to our success.\\n- when we get that element then every element from its right or is bigger than that element is gonna pass.\\n- so we push the `total size of potions - index of minimum success element`.\\n- after doing it for all the elements in `spells`, we return the answer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(nlog(n+m))` #correct me if i\\'m wrong cause not sure perfectly :)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n`Upvote ! It just takes 1 click :)`\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n= spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        for (int i=0;i<n;i++){\\n            int spell = spells[i];\\n            int start = 0;\\n            int end = m-1;\\n            while(start<=end){\\n                int mid = start + (end-start)/2;\\n                long long product = (long) spell * potions[mid];\\n                if(product>=success){\\n                    end = mid-1;\\n                } \\n                else{\\n                    start = mid+1;\\n                }\\n            }\\n            ans.push_back(m-start);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/1b85f3f9-1fb4-466e-8a35-8dd5e22e1a9f_1680437696.0481274.jpeg)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n= spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        for (int i=0;i<n;i++){\\n            int spell = spells[i];\\n            int start = 0;\\n            int end = m-1;\\n            while(start<=end){\\n                int mid = start + (end-start)/2;\\n                long long product = (long) spell * potions[mid];\\n                if(product>=success){\\n                    end = mid-1;\\n                } \\n                else{\\n                    start = mid+1;\\n                }\\n            }\\n            ans.push_back(m-start);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138901,
                "title": "binary-search",
                "content": "```\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            int l=0,h=potions.length;\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                if(1L*spells[i]*potions[mid]>=success){\\n                    h=mid;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            spells[i]=potions.length-l;\\n        }\\n        return spells;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            int l=0,h=potions.length;\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                if(1L*spells[i]*potions[mid]>=success){\\n                    h=mid;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            spells[i]=potions.length-l;\\n        }\\n        return spells;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3369922,
                "title": "c-easy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long c) {\\n        sort(p.begin(),p.end());\\n        vector<int>an;\\n        for(int i=0;i<s.size();i++){\\n            int d=0;\\n            ll g=c/s[i];\\n            if(c%s[i])g++;\\n            int f=lower_bound(p.begin(),p.end(),g)-p.begin();\\n            d += p.size()-f;\\n            an.push_back(d);\\n        }\\n        return an;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/c97c664a-5d0e-4880-8c56-ee876fe9d057_1680426069.3153875.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long c) {\\n        sort(p.begin(),p.end());\\n        vector<int>an;\\n        for(int i=0;i<s.size();i++){\\n            int d=0;\\n            ll g=c/s[i];\\n            if(c%s[i])g++;\\n            int f=lower_bound(p.begin(),p.end(),g)-p.begin();\\n            d += p.size()-f;\\n            an.push_back(d);\\n        }\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369191,
                "title": "c-easy-explanation-beginner-friendly-without-bs",
                "content": "# Intuition\\nWE WILL SORT SPELLS IN DESCENDING ORDER AND POTIONS IN ASCENDING ORDER . SO THAT EVERY TIME I CHECK FOR A GIVEN SPELL ,I DON\\'T HAVE TO TRAVERSE FROM BEGINNING . It will start from some index k .\\n\\nAND ALSO.\\nIF ANY GREATER SPELL IS NOT ABLE TO MAKE SUCCESS FROM POTIONS ,THEN \\nNO SPELL AFTER THAT WILL GIVE ANY SUCCESS . THEREFORE \\n\\n```\\nif(flag==0)break;\\n```\\n\\n# Approach\\nSEE CODE WITH COMMENTS . YOU WILL SURELY GET IT .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& ss, vector<int>& p, long long suc) {\\n        vector<int>s=ss;// TO MAKE USE OF ITS SORTED(DESCENDING) FORM .\\n        unordered_map<int,int>mpp;// TO STORE SPELL WITH THEIR SUCCESS.\\n        vector<int>ans; // FINAL RESULT WILL BE STORED .\\n\\n        sort(p.begin(),p.end());\\n\\n        sort(s.begin(),s.end(),greater<int>()); // SORTING IN DESCENDING .\\n\\n        int n=s.size();int n2=p.size();\\n // K IS USED FOR NEW INDEX FROM WHERE NEXT SPELL SHOULD CHECK IN POTION FOR THEIR SUCCESS .\\n        int k=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            bool flag=0;// for check if any spell is making success or not.\\n\\n            for(int j=k;j<n2;j++){\\n                // 1LL for avoiding overflow of int .\\n                if(1LL*s[i]*p[j]>=suc){\\n                    k=j; // storing new index for next spell to traverse.\\n                    flag=1;\\n                    mpp[s[i]]=n2-j;// storing success of current spell.\\n                    break;\\n                }\\n            }\\n            // if spell is not making success ,break;\\n            if(flag==0){  break; } \\n        }\\n\\n        for(int i=0;i<n;i++){\\n            // if spell was making any success .It had stored in mpp.\\n            if(mpp.count(ss[i]))ans.push_back(mpp[ss[i]]);\\n\\n            else ans.push_back(0);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nCODE BY :) AMAN MAURYA \\nTHANK YOU \\n\\nUPVOTE IF YOU FOUND IT EASY OR DIFFERENT .\\n![UPVOTE.jpeg](https://assets.leetcode.com/users/images/920b2dc1-352a-4f35-a497-d3016f8a562a_1680415841.5855615.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(flag==0)break;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& ss, vector<int>& p, long long suc) {\\n        vector<int>s=ss;// TO MAKE USE OF ITS SORTED(DESCENDING) FORM .\\n        unordered_map<int,int>mpp;// TO STORE SPELL WITH THEIR SUCCESS.\\n        vector<int>ans; // FINAL RESULT WILL BE STORED .\\n\\n        sort(p.begin(),p.end());\\n\\n        sort(s.begin(),s.end(),greater<int>()); // SORTING IN DESCENDING .\\n\\n        int n=s.size();int n2=p.size();\\n // K IS USED FOR NEW INDEX FROM WHERE NEXT SPELL SHOULD CHECK IN POTION FOR THEIR SUCCESS .\\n        int k=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            bool flag=0;// for check if any spell is making success or not.\\n\\n            for(int j=k;j<n2;j++){\\n                // 1LL for avoiding overflow of int .\\n                if(1LL*s[i]*p[j]>=suc){\\n                    k=j; // storing new index for next spell to traverse.\\n                    flag=1;\\n                    mpp[s[i]]=n2-j;// storing success of current spell.\\n                    break;\\n                }\\n            }\\n            // if spell is not making success ,break;\\n            if(flag==0){  break; } \\n        }\\n\\n        for(int i=0;i<n;i++){\\n            // if spell was making any success .It had stored in mpp.\\n            if(mpp.count(ss[i]))ans.push_back(mpp[ss[i]]);\\n\\n            else ans.push_back(0);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147091,
                "title": "java-easy-solution-using-binary-search-o-n-logn",
                "content": "**O(n*log(n)) / O(1)**\\n```\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        \\n        for(int i = 0; i < spells.length; i++) {\\n            int l = 0, r = potions.length;\\n            \\n            while(l < r) {\\n                int m = l + (r - l) / 2;\\n                \\n                if((long)spells[i]*potions[m]  >= success)\\n                    r = m;\\n                else\\n                    l = m + 1;\\n            }\\n            \\n            spells[i] = potions.length - l;\\n        }\\n        \\n        return spells;\\n    }\\n```\\n*Comment down, If you have any doubt.*\\n**Upvote^, If you liked it.**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        \\n        for(int i = 0; i < spells.length; i++) {\\n            int l = 0, r = potions.length;\\n            \\n            while(l < r) {\\n                int m = l + (r - l) / 2;\\n                \\n                if((long)spells[i]*potions[m]  >= success)\\n                    r = m;\\n                else\\n                    l = m + 1;\\n            }\\n            \\n            spells[i] = potions.length - l;\\n        }\\n        \\n        return spells;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139570,
                "title": "python-solution-explained",
                "content": "\\'\\'\\'\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], s: int) -> List[int]:\\n        q=[]\\n        potions.sort()                                      #Sort the potion array\\n        a=len(potions)\\n        for i in spells:\\n            count=0\\n            l=0                                   #We have to find a value which is less than (success/i) in sorted array  \\n             r=len(potions)                # binary seach will give index of that point and onwards that index all are \\n            x=s/i                                #greater values \\n            while l<r:\\n                mid=l+(r-l)//2\\n                if potions[mid]>=x:\\n                    r=mid\\n                else:\\n                    l=mid+1\\n            \\n            count=(a-l)                                      #Last - index that came with binary search\\n            q.append(count)\\n        return q\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "\\'\\'\\'\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], s: int) -> List[int]:\\n        q=[]\\n        potions.sort()                                      #Sort the potion array\\n        a=len(potions)\\n        for i in spells:\\n            count=0\\n            l=0                                   #We have to find a value which is less than (success/i) in sorted array  \\n             r=len(potions)                # binary seach will give index of that point and onwards that index all are \\n            x=s/i                                #greater values \\n            while l<r:\\n                mid=l+(r-l)//2\\n                if potions[mid]>=x:\\n                    r=mid\\n                else:\\n                    l=mid+1\\n            \\n            count=(a-l)                                      #Last - index that came with binary search\\n            q.append(count)\\n        return q\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3369205,
                "title": "binary-search-intuition-explained-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we sort the potions array and find the minimum index where the product is greater than or equal to success, then we can be sure that the rest of the potions array will give product greater than or equal to success only.\\n\\nTo solve this kind of problem, we can use Binary Search. We can search in the range 0 to potions.size() and update the range according to whether the mid-value is enough or not.\\n\\n![image.png](https://assets.leetcode.com/users/images/9b20c1e9-0b07-4d87-9031-9d9a79afb50e_1680414955.5710003.png)\\n\\nThe condition would be:\\n``` \\nspell[i]*potions[j]>=success\\n=> potions[j]>=success/spell[i] (as success can be a large number)\\n```\\nNow we need to find the index where this condition is satisfied for the first time.\\n# Example\\nLet\\'s say we have the following inputs:\\n```\\nspells = [2, 3, 4]\\npotions = [1, 2, 3, 4, 5]\\nsuccess = 5\\n```\\n\\nAfter sorting potions, we have:\\n```\\npotions = [1, 2, 3, 4, 5]\\n```\\n\\nFor num = spell[0] = 2, we call binary search. \\n```\\nsuccess/num = 2.5 \\nThe index of the first element in potions that is >= 2.5 is 2.\\nTherefore, we append size-idx = 5-2 = 3 to the ans vector.\\n```\\nFor num = 3:\\n```\\nsuccess/num = 1.67\\nThe index of the first element in potions that is >= 1.67 is 1.\\nTherefore, we append n-idx = 5-1 = 4 to the ans vector.\\n```\\n\\nFor num = 4:\\n```\\nThe index of the first element in potions that is g>= 1.25 is 0.\\nTherefore, we append n-idx = 5-0 = 5 to the ans vector.\\n```\\nThe final ans vector:\\n```\\n[3, 4, 5]\\nindicating that there are 3 successful pairs for num = 2, \\n4 successful pairs for num = 3, \\nand 5 successful pairs for num = 4.\\n```\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int num, vector<int>& potions, long long success){\\n        int left=0, right=potions.size()-1;\\n        double curr=(double)success/num; \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(potions[mid]>=curr){ \\n                right=mid;  // set right to mid to search for lower indices\\n            }\\n            else left=mid+1;  // else set left to mid+1 to search for higher indices\\n        }\\n        if(potions[right]>=curr) return right;  // if any element has product greater than or equal to success\\n        else return -1;  // else potion with success probability not fount\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end()); \\n        for(int num:spells){\\n            int idx=binarySearch(num,potions,success);  // find index where condition is satisfied for the first time\\n            if(idx==-1) ans.push_back(0);  // if potion with success probability not found, add 0\\n            else  ans.push_back(n-idx);  // else, n-idx would be the number of pairs that satisfy the condition\\n        }\\n        return ans;  \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "``` \\nspell[i]*potions[j]>=success\\n=> potions[j]>=success/spell[i] (as success can be a large number)\\n```\n```\\nspells = [2, 3, 4]\\npotions = [1, 2, 3, 4, 5]\\nsuccess = 5\\n```\n```\\npotions = [1, 2, 3, 4, 5]\\n```\n```\\nsuccess/num = 2.5 \\nThe index of the first element in potions that is >= 2.5 is 2.\\nTherefore, we append size-idx = 5-2 = 3 to the ans vector.\\n```\n```\\nsuccess/num = 1.67\\nThe index of the first element in potions that is >= 1.67 is 1.\\nTherefore, we append n-idx = 5-1 = 4 to the ans vector.\\n```\n```\\nThe index of the first element in potions that is g>= 1.25 is 0.\\nTherefore, we append n-idx = 5-0 = 5 to the ans vector.\\n```\n```\\n[3, 4, 5]\\nindicating that there are 3 successful pairs for num = 2, \\n4 successful pairs for num = 3, \\nand 5 successful pairs for num = 4.\\n```\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int num, vector<int>& potions, long long success){\\n        int left=0, right=potions.size()-1;\\n        double curr=(double)success/num; \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(potions[mid]>=curr){ \\n                right=mid;  // set right to mid to search for lower indices\\n            }\\n            else left=mid+1;  // else set left to mid+1 to search for higher indices\\n        }\\n        if(potions[right]>=curr) return right;  // if any element has product greater than or equal to success\\n        else return -1;  // else potion with success probability not fount\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end()); \\n        for(int num:spells){\\n            int idx=binarySearch(num,potions,success);  // find index where condition is satisfied for the first time\\n            if(idx==-1) ans.push_back(0);  // if potion with success probability not found, add 0\\n            else  ans.push_back(n-idx);  // else, n-idx would be the number of pairs that satisfy the condition\\n        }\\n        return ans;  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367920,
                "title": "java-easy-solution-using-binary-search-beginner-friendly-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    \\n    Map<Integer, int[]> duplicates;\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] pairs = new int[spells.length];\\n        Arrays.sort(potions);\\n        int ind = 0;\\n        duplicates = new HashMap<>();\\n        for (int i = 0; i < potions.length; i++) {\\n            if (duplicates.containsKey(potions[i])) {\\n                int[] idx = duplicates.get(potions[i]);\\n                duplicates.put(potions[i], new int[]{idx[0], i});\\n            } else duplicates.put(potions[i], new int[]{i});\\n        }\\n\\n        for (int s : spells) {\\n            int idx = bs(potions, (long) Math.ceil((double) success / s));\\n            if (idx >= 0) {\\n                pairs[ind++] = potions.length - idx;\\n            } else {\\n                pairs[ind++] = 0;\\n            }\\n        }\\n        return pairs;\\n    }\\n\\n    private int bs(int[] potions, long value) {\\n        int l = 0, h = potions.length - 1;\\n        while (l < h) {\\n            int mid = l + (h - l) / 2;\\n            if (value < potions[mid]) {\\n                h = mid;\\n            } else if (value > potions[mid]) {\\n                l = mid + 1;\\n            } else if (value == potions[mid]) {\\n                return duplicates.get(potions[mid])[0];\\n            }\\n        }\\n\\n        return potions[l] < value ? -1 : l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, int[]> duplicates;\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] pairs = new int[spells.length];\\n        Arrays.sort(potions);\\n        int ind = 0;\\n        duplicates = new HashMap<>();\\n        for (int i = 0; i < potions.length; i++) {\\n            if (duplicates.containsKey(potions[i])) {\\n                int[] idx = duplicates.get(potions[i]);\\n                duplicates.put(potions[i], new int[]{idx[0], i});\\n            } else duplicates.put(potions[i], new int[]{i});\\n        }\\n\\n        for (int s : spells) {\\n            int idx = bs(potions, (long) Math.ceil((double) success / s));\\n            if (idx >= 0) {\\n                pairs[ind++] = potions.length - idx;\\n            } else {\\n                pairs[ind++] = 0;\\n            }\\n        }\\n        return pairs;\\n    }\\n\\n    private int bs(int[] potions, long value) {\\n        int l = 0, h = potions.length - 1;\\n        while (l < h) {\\n            int mid = l + (h - l) / 2;\\n            if (value < potions[mid]) {\\n                h = mid;\\n            } else if (value > potions[mid]) {\\n                l = mid + 1;\\n            } else if (value == potions[mid]) {\\n                return duplicates.get(potions[mid])[0];\\n            }\\n        }\\n\\n        return potions[l] < value ? -1 : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141703,
                "title": "c-use-binary-search-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        int sn = spells.size();\\n        int pn = potions.size();\\n        vector<int> ans; //stores answer\\n        \\n        sort(potions.begin(), potions.end()); //sort potions for binary search\\n        \\n        for(auto it : spells)\\n        {\\n            int left=0, right=pn-1, mid; //define left, right and mid pointers\\n            \\n            while(left<=right) //iterate until right is lesser than left\\n            {\\n                mid = (left+right)>>1; \\n                \\n                if((long long)it*potions[mid] >= success) right=mid-1;\\n                \\n                else left=mid+1;\\n            }\\n            ans.push_back(pn-left);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# Please upvote if you like this approach :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        int sn = spells.size();\\n        int pn = potions.size();\\n        vector<int> ans; //stores answer\\n        \\n        sort(potions.begin(), potions.end()); //sort potions for binary search\\n        \\n        for(auto it : spells)\\n        {\\n            int left=0, right=pn-1, mid; //define left, right and mid pointers\\n            \\n            while(left<=right) //iterate until right is lesser than left\\n            {\\n                mid = (left+right)>>1; \\n                \\n                if((long long)it*potions[mid] >= success) right=mid-1;\\n                \\n                else left=mid+1;\\n            }\\n            ans.push_back(pn-left);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139547,
                "title": "python-3-math-binary-search-explanation",
                "content": "### Explanation\\n- The order of `potions` doesn\\'t matter, we just need to find out how many potion can form a *successful* pair with the current *spell*\\n\\t- Thus, we can sort `potions` to make a faster binary search\\n- We can\\'t use spell to multiply each potion, it takes a long time `O(mn)`; \\n\\t- Instead, we can use `success` to divided by the current *spell*, which is a `O(1)` operation\\n- If `success % spell == 0`, then we want to include `success // spell`\\n\\t- Thus, we will use a `bisect_left`\\n- Otherwise, we don\\'t want to include  `success // spell`\\n\\t- Thus, we will use a `bisect_right`\\n- `n - idx` is the number of *successful* potions with the current *spell*\\n- Time: `O(nlgm), n = len(spells), m = len(potions)`\\n### Implementation\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans, n = [], len(potions)\\n        for spell in spells:\\n            val = success // spell\\n            if success % spell == 0:\\n                idx = bisect.bisect_left(potions, val)\\n            else:    \\n                idx = bisect.bisect_right(potions, val)\\n            ans.append(n - idx)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans, n = [], len(potions)\\n        for spell in spells:\\n            val = success // spell\\n            if success % spell == 0:\\n                idx = bisect.bisect_left(potions, val)\\n            else:    \\n                idx = bisect.bisect_right(potions, val)\\n            ans.append(n - idx)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375724,
                "title": "powerful-binary-search-approach",
                "content": "\\n# Time Complexity----->O(NLogN)\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        list1=[]\\n        potions.sort()\\n        // some test cases are not sorted\\n        for s in spells:\\n            // binary search on left most value i.e greater than success\\n            left,right,index=0,len(potions)-1,len(potions)# index is len(potions) in worst case where no values matches with potions values\\n            while left<=right:\\n                mid=(left+right)//2\\n                if s*potions[mid]>=success:\\n                    right=mid-1\\n                    index=mid\\n                else:\\n                    left=mid+1\\n            // add all possible values by total length -index\\n            list1.append(len(potions)-index)\\n        return list1\\n        \\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        list1=[]\\n        potions.sort()\\n        // some test cases are not sorted\\n        for s in spells:\\n            // binary search on left most value i.e greater than success\\n            left,right,index=0,len(potions)-1,len(potions)# index is len(potions) in worst case where no values matches with potions values\\n            while left<=right:\\n                mid=(left+right)//2\\n                if s*potions[mid]>=success:\\n                    right=mid-1\\n                    index=mid\\n                else:\\n                    left=mid+1\\n            // add all possible values by total length -index\\n            list1.append(len(potions)-index)\\n        return list1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372355,
                "title": "python-two-pointers-solution-w-sorting-without-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to initially sort both the ```spells``` and ```potions``` array, and then initialize a variable called ```p``` at the last element of ```potions```. ```p``` will only move from right to left, while another pointer, ```s```, will iterate through ```spells``` from left to right. We will check if ``` spells[s]*potions[p] >= success ```. If so, keep on moving the ```p``` pointer to the left until that condition fails. Record the result once that condition fails for each iteration of ```spells```.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Since the order of our ```spells``` array is important in order to return the number of potions that will form a successful pair with each element in ```spell```, we will recreate the ```spells``` list as a nested list that stores each of its elements and its index.\\n```Ex. spells = [5,1,3] -> spells = [[5,0],[1,1],[3,2]]```\\n2. Sort both ```spells``` and ```potions```.\\n3. Initialize ```result``` and ```p``` to ```[0]*len(spells)``` and ```len(potions)-1```, respectively. The ```result``` array will be returned in the end.\\n4. Run a for-loop on ```spells``` and for each iteration, we run a while-loop that checks if ```spells[s][0]*potions[p] >= success```. If so, we decrement the ```p``` pointer until that condition fails. There\\'s no point in checking further since we already found the potion with the least strength that will form a successful pair for the ```spell[s]``` spell.\\n5. Once the while-loop breaks, we can compute the number of potions that will form a successful pair by doing ```len(potions)-p-1``` and replace the element\\'s value in ```result``` on the ```spells[s][1]``` index.\\n\\n# Complexity\\n- Time complexity: **O(nlog(n)+mlog(m)+n)** because we sorted both input lists and iterate through ```spells```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        spells = [[spells[i],i] for i in range(len(spells))]\\n        spells.sort()\\n        potions.sort()\\n\\n        result = [0]*len(spells)\\n        p = len(potions)-1\\n        for s in range(len(spells)):\\n            while p >= 0 and spells[s][0]*potions[p] >= success:\\n                p -= 1\\n            result[spells[s][1]] = len(potions)-p-1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting",
                    "Counting"
                ],
                "code": "```spells```\n```potions```\n```p```\n```potions```\n```p```\n```s```\n```spells```\n``` spells[s]*potions[p] >= success ```\n```p```\n```spells```\n```spells```\n```spell```\n```spells```\n```Ex. spells = [5,1,3] -> spells = [[5,0],[1,1],[3,2]]```\n```spells```\n```potions```\n```result```\n```p```\n```[0]*len(spells)```\n```len(potions)-1```\n```result```\n```spells```\n```spells[s][0]*potions[p] >= success```\n```p```\n```spell[s]```\n```len(potions)-p-1```\n```result```\n```spells[s][1]```\n```spells```\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        spells = [[spells[i],i] for i in range(len(spells))]\\n        spells.sort()\\n        potions.sort()\\n\\n        result = [0]*len(spells)\\n        p = len(potions)-1\\n        for s in range(len(spells)):\\n            while p >= 0 and spells[s][0]*potions[p] >= success:\\n                p -= 1\\n            result[spells[s][1]] = len(potions)-p-1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372002,
                "title": "binary-search-for-success",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Binary Search for suucess.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array.\\n- Binary Search to locate the dividing element.\\n- Dividing element is where the product is just started to get greater.\\n  For Ex.\\n  spell = 5,\\n  potions = [1,2,3,4,5]\\n  success = 16\\n  then, dividing element = 4 (index = 3);\\n- subtracting the index with the length.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(M) + MlogM)\\n*MlogM for Sorting.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n![leetcodeupvotetrick.png](https://assets.leetcode.com/users/images/8b7ef33d-9a39-409f-916e-353e6dd88607_1680463496.6290069.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] arr, int[] arr1, long suc) {\\n        int[] res = new int[arr.length];\\n        Arrays.sort(arr1);\\n        int l, r, mid;\\n        long t;\\n        for (int i = 0; i < arr.length; i++) {\\n            l = 0;\\n            r = arr1.length - 1;\\n            while (l <= r) {\\n                mid = (l + r) / 2;\\n                t = arr[i];\\n                if (arr1[mid] * t >= suc) {\\n                    r = mid - 1;\\n                    if(r==-1){\\n                        res[i] = arr1.length;\\n                    }\\n                } else if (arr1[mid] * t < suc) {\\n                    if (mid + 1 < arr1.length && arr1[mid + 1] * t >= suc) {\\n                        res[i] = arr1.length - (mid + 1);\\n                        break;\\n                    }\\n                    l = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] arr, int[] arr1, long suc) {\\n        int[] res = new int[arr.length];\\n        Arrays.sort(arr1);\\n        int l, r, mid;\\n        long t;\\n        for (int i = 0; i < arr.length; i++) {\\n            l = 0;\\n            r = arr1.length - 1;\\n            while (l <= r) {\\n                mid = (l + r) / 2;\\n                t = arr[i];\\n                if (arr1[mid] * t >= suc) {\\n                    r = mid - 1;\\n                    if(r==-1){\\n                        res[i] = arr1.length;\\n                    }\\n                } else if (arr1[mid] * t < suc) {\\n                    if (mid + 1 < arr1.length && arr1[mid + 1] * t >= suc) {\\n                        res[i] = arr1.length - (mid + 1);\\n                        break;\\n                    }\\n                    l = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371631,
                "title": "javascript-php-beats-100-binary-search-faster-than-other-solutions",
                "content": "\\n# Approach\\nHere is my approach to solving the problem using a binary search:\\n\\n* First, we sort the potions array in ascending order. This ensures that the smallest potions are at the front of the\\n  array.\\n\\n* Then, we iterate over the spells array. For each spell, we perform _a binary search_ on the potions array to find the\\n  first potion that is greater than or equal to the _success_ value.\\n\\n* The number of potions that are greater than or equal to the spell\\'s power is the number of successful pairs that can\\n  be formed with that spell.\\n* We add this number to the pairs result array.\\n* We continue this process until we have iterated over all of the spells.\\n* Finally, we return the pairs array.\\n\\n# Complexity\\n\\nThe **time complexity** of the algorithm is O(n log m), where n is the number of potions, and m is the number of spells.\\nThis is because the algorithm sorts the potions array in O(n log n) time and performs a binary search on the potions\\narray for each spell, which takes O(n*log m) time. => O( (n+m) * log m) => O(n log m)\\n\\nThe **space complexity** of the algorithm is O(1), since the algorithm only requires a constant amount of space to store\\nthe\\npotions array, the spells array, the success value, and the pairs array.\\n\\n```javascript []\\n/**\\n * Binary search approach O((n+m)*log(m))\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            // binary search\\n            let left = 0;\\n            let right = potionsLength - 1;\\n            while (left <= right) {\\n                // const mid = Math.floor((left + right) / 2);\\n                const mid = (left + right) >> 1;\\n                if (spells[i] * potions[mid] >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            count = potionsLength - left;\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\\n\\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $spells\\n     * @param Integer[] $potions\\n     * @param Integer $success\\n     * @return Integer[]\\n     */\\n    function successfulPairs(array $spells, array $potions, int $success): array {\\n        $pairsResult = [];\\n        $potionsCount = count($potions);\\n        $spellsCount = count($spells);\\n        sort($potions);\\n        // binary search\\n        for ($i = 0; $i < $spellsCount; $i++) {\\n            $left = 0;\\n            $right = $potionsCount - 1;\\n            while ($left <= $right) {\\n                $mid = ($left + $right) >> 1;\\n                if ($spells[$i] * $potions[$mid] >= $success) {\\n                    $right = $mid - 1;\\n                } else {\\n                    $left = $mid + 1;\\n                }\\n            }\\n            $pairsResult[$i] = $potionsCount - $left;\\n        }\\n        return $pairsResult;\\n    }\\n}\\n```\\n\\n```javascript []\\n/**\\n * Binary search approach with  with small optimization\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        let maxSpellValueWithZeroSuccess = 0; // Optimize -  max value of a spell that will never be successful\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            if (spells[i] > maxSpellValueWithZeroSuccess) {\\n                // binary search\\n                let left = 0;\\n                let right = potionsLength - 1;\\n                while (left <= right) {\\n                    const mid = (left + right) >> 1;\\n                    if (spells[i] * potions[mid] >= success) {\\n                        right = mid - 1;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                count = potionsLength - left;\\n                if (count == 0) maxSpellValueWithZeroSuccess = spells[i];\\n            }\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\\n\\n##### Thanks for reading! If you have any questions or suggestions, please leave a comment below. I would love to hear your thoughts! \\uD83D\\uDE0A\\n### **Please upvote if you found this post helpful! \\uD83D\\uDE4F**",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Binary Search"
                ],
                "code": "```javascript []\\n/**\\n * Binary search approach O((n+m)*log(m))\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            // binary search\\n            let left = 0;\\n            let right = potionsLength - 1;\\n            while (left <= right) {\\n                // const mid = Math.floor((left + right) / 2);\\n                const mid = (left + right) >> 1;\\n                if (spells[i] * potions[mid] >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            count = potionsLength - left;\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $spells\\n     * @param Integer[] $potions\\n     * @param Integer $success\\n     * @return Integer[]\\n     */\\n    function successfulPairs(array $spells, array $potions, int $success): array {\\n        $pairsResult = [];\\n        $potionsCount = count($potions);\\n        $spellsCount = count($spells);\\n        sort($potions);\\n        // binary search\\n        for ($i = 0; $i < $spellsCount; $i++) {\\n            $left = 0;\\n            $right = $potionsCount - 1;\\n            while ($left <= $right) {\\n                $mid = ($left + $right) >> 1;\\n                if ($spells[$i] * $potions[$mid] >= $success) {\\n                    $right = $mid - 1;\\n                } else {\\n                    $left = $mid + 1;\\n                }\\n            }\\n            $pairsResult[$i] = $potionsCount - $left;\\n        }\\n        return $pairsResult;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Binary search approach with  with small optimization\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        let maxSpellValueWithZeroSuccess = 0; // Optimize -  max value of a spell that will never be successful\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            if (spells[i] > maxSpellValueWithZeroSuccess) {\\n                // binary search\\n                let left = 0;\\n                let right = potionsLength - 1;\\n                while (left <= right) {\\n                    const mid = (left + right) >> 1;\\n                    if (spells[i] * potions[mid] >= success) {\\n                        right = mid - 1;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                count = potionsLength - left;\\n                if (count == 0) maxSpellValueWithZeroSuccess = spells[i];\\n            }\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370088,
                "title": "c-prefix-sum-o-m-n-time-o-1-space",
                "content": "# Intuition\\nTo get to ```success``` we need to check if we can compensate potion power with our spell power. So we need to calculate ```neededSpellCost``` for each potion. As it is an integer division we need to add 1 when it can\\'t be divided to satisfy the requirement. After that we can see which spell can be used with which potion to make needed power.\\n\\n# Approach\\n```neededSpellCost``` can be quite big, such that we won\\'t have any possible spell at all, such cases just ignored.\\n\\nDuring the calculation of ```neededSpellCost``` we starting to build up our ```prefixSum```. After the loop on potions we will have ```prefixSum``` sloted with the number of each spell required.\\n\\nBut any ```k``` spell power can also be used to cover any less powerful spell. So we are going through ```prefixSum``` and accumulate it.\\n\\nLast run just goes through potions and sees how many each potion can cover.\\n\\n# Complexity\\n- Time complexity: ```O(m + n + 100000)``` => ```O(m + n)```\\n\\n- Space complexity: ```O(100000)``` => ```O(1)```\\n\\n# Code C#\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success)\\n        {\\n            var limit = 100001;\\n            var prefixSum = new int[limit];\\n            for (var i = 0; i < potions.Length; i++)\\n            {\\n                var neededSpellCost = success % potions[i] == 0\\n                    ? success / potions[i]\\n                    : success / potions[i] + 1;\\n\\n                if (neededSpellCost < limit)\\n                    prefixSum[neededSpellCost]++;\\n            }\\n\\n            for (var i = 1; i < prefixSum.Length; i++)\\n                prefixSum[i] += prefixSum[i - 1];\\n\\n            var result = new int[spells.Length];\\n            for (var i = 0; i <  spells.Length; i++)\\n                result[i] = prefixSum[spells[i]];\\n\\n            return result;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Prefix Sum"
                ],
                "code": "```success```\n```neededSpellCost```\n```neededSpellCost```\n```neededSpellCost```\n```prefixSum```\n```prefixSum```\n```k```\n```prefixSum```\n```O(m + n + 100000)```\n```O(m + n)```\n```O(100000)```\n```O(1)```\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success)\\n        {\\n            var limit = 100001;\\n            var prefixSum = new int[limit];\\n            for (var i = 0; i < potions.Length; i++)\\n            {\\n                var neededSpellCost = success % potions[i] == 0\\n                    ? success / potions[i]\\n                    : success / potions[i] + 1;\\n\\n                if (neededSpellCost < limit)\\n                    prefixSum[neededSpellCost]++;\\n            }\\n\\n            for (var i = 1; i < prefixSum.Length; i++)\\n                prefixSum[i] += prefixSum[i - 1];\\n\\n            var result = new int[spells.Length];\\n            for (var i = 0; i <  spells.Length; i++)\\n                result[i] = prefixSum[spells[i]];\\n\\n            return result;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368509,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        N=len(potions)\\n        ans=[]\\n        for s in spells:\\n            target=(success-1)//s\\n            index=bisect.bisect_right(potions,target)\\n            ans.append(N-index)\\n            \\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        N=len(potions)\\n        ans=[]\\n        for s in spells:\\n            target=(success-1)//s\\n            index=bisect.bisect_right(potions,target)\\n            ans.append(N-index)\\n            \\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367853,
                "title": "daily-leetcoding-challenge-april-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2140055,
                "title": "c-binary-search-explanation-with-comments",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        // declare a vector of size spell that will store our ans\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> ans(n,0);\\n        \\n        // sort the potions fir applying the binary search\\n        sort(potions.begin(),potions.end());\\n        \\n        int i = 0;                    // it will help in storing the ans\\n        \\n        // start iterating over the spells\\n        for(auto& x : spells)\\n        {\\n            int l = 0;\\n            int r = m-1;\\n            int mid;\\n            \\n            // binary search\\n            while(l <= r)\\n            {\\n                mid = (l+r)>>1;\\n                \\n                // if it gives our need then reduce the window to the left side for cheking more \\n                if((long long)x*potions[mid] >= success)\\n                    r = mid-1;\\n                \\n                // if not then check to the right side\\n                else\\n                    l = mid+1;\\n            }\\n            ans[i] = m-l;            // storing the answer (total size - not needed size)\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        // declare a vector of size spell that will store our ans\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> ans(n,0);\\n        \\n        // sort the potions fir applying the binary search\\n        sort(potions.begin(),potions.end());\\n        \\n        int i = 0;                    // it will help in storing the ans\\n        \\n        // start iterating over the spells\\n        for(auto& x : spells)\\n        {\\n            int l = 0;\\n            int r = m-1;\\n            int mid;\\n            \\n            // binary search\\n            while(l <= r)\\n            {\\n                mid = (l+r)>>1;\\n                \\n                // if it gives our need then reduce the window to the left side for cheking more \\n                if((long long)x*potions[mid] >= success)\\n                    r = mid-1;\\n                \\n                // if not then check to the right side\\n                else\\n                    l = mid+1;\\n            }\\n            ans[i] = m-l;            // storing the answer (total size - not needed size)\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139528,
                "title": "c-binary-search-short-and-simple-logic",
                "content": "For each spell,\\n**need = success * 1.0 / spell**\\nBinary search the index of **first potion >= need** in the sorted potions.\\nThe number of potions that are successful are **potions.length - index**\\n```\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        long long need;\\n        vector<int> ans;\\n        for(int spell:spells){\\n            need=ceil(success*1.0/spell);\\n            ans.push_back(potions.end()-lower_bound(potions.begin(),potions.end(),need));\\n        }\\n        return ans;\\n    }\\n```\\n*-----please upvote-----*",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        long long need;\\n        vector<int> ans;\\n        for(int spell:spells){\\n            need=ceil(success*1.0/spell);\\n            ans.push_back(potions.end()-lower_bound(potions.begin(),potions.end(),need));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467543,
                "title": "python-simple-clean-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            ind = bisect_left(potions, success / s)\\n            ans.append(n - ind)\\n        return ans\\n```\\n\\n## Binary Search\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                mid = (l + r) >> 1\\n                if potions[mid] * s >= success:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            ans.append(n - l)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            ind = bisect_left(potions, success / s)\\n            ans.append(n - ind)\\n        return ans\\n```\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                mid = (l + r) >> 1\\n                if potions[mid] * s >= success:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            ans.append(n - l)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372191,
                "title": "java-binary-search-spells-and-potions",
                "content": "\\n```\\nclass Solution {\\n    public int search(int[] nums, long target, long sel) {\\n        int start = 0;\\n        int finish = nums.length - 1;\\n        int med;\\n        if (target < nums[start] * sel) return start;\\n        if (target > nums[finish] * sel) return nums.length;\\n\\n        while (start < finish && nums[start] < nums[finish])\\n        {\\n            if (target == nums[start] * sel) return start;\\n            med = (start + finish) / 2;\\n            if (target > nums[med] * sel)\\n                start = med + 1;\\n            else\\n                finish = med;\\n\\n        }\\n        if (nums[start] * sel == target) return start;\\n        if (nums[start] * sel < target)\\n            return start + 1;\\n        else\\n            return start;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        HashMap<Integer, Integer> dict = new HashMap<>();\\n        Arrays.sort(potions);\\n        int [] answ = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            if (!dict.containsKey(spells[i]))\\n                dict.put(spells[i], potions.length - search(potions, success, spells[i]));\\n            answ[i] = dict.get(spells[i]);\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, long target, long sel) {\\n        int start = 0;\\n        int finish = nums.length - 1;\\n        int med;\\n        if (target < nums[start] * sel) return start;\\n        if (target > nums[finish] * sel) return nums.length;\\n\\n        while (start < finish && nums[start] < nums[finish])\\n        {\\n            if (target == nums[start] * sel) return start;\\n            med = (start + finish) / 2;\\n            if (target > nums[med] * sel)\\n                start = med + 1;\\n            else\\n                finish = med;\\n\\n        }\\n        if (nums[start] * sel == target) return start;\\n        if (nums[start] * sel < target)\\n            return start + 1;\\n        else\\n            return start;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        HashMap<Integer, Integer> dict = new HashMap<>();\\n        Arrays.sort(potions);\\n        int [] answ = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            if (!dict.containsKey(spells[i]))\\n                dict.put(spells[i], potions.length - search(potions, success, spells[i]));\\n            answ[i] = dict.get(spells[i]);\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372160,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * log M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto x: spells) {\\n            int l = 0, r = n - 1;\\n            while(l <= r) {\\n                int mid = (l + r) / 2;\\n                if(1ll * potions[mid] * x < success) l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            ans.push_back(n - l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto x: spells) {\\n            int l = 0, r = n - 1;\\n            while(l <= r) {\\n                int mid = (l + r) / 2;\\n                if(1ll * potions[mid] * x < success) l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            ans.push_back(n - l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372059,
                "title": "java-binary-search-clean-code-beats-87",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O((m+n) * log(m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(m))$$ used by the sort algorithm in Java\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n    var n = spells.length;\\n    var m = potions.length;\\n    var pairs = new int[n];\\n    \\n    Arrays.sort(potions);\\n\\n    for (var i=0; i<n; i++) {\\n      var minPotion = (int) Math.ceil((double) success / spells[i]);\\n\\n      if (minPotion > potions[m-1]) continue;\\n\\n      var l = 0;\\n      var r = m-1;\\n\\n      while (l < r) {\\n        var mid = l + (r-l) / 2;\\n\\n        if (potions[mid] < minPotion) l = mid+1;\\n        else r = mid;\\n      }\\n      pairs[i] = m-l;\\n    }\\n    return pairs;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n    var n = spells.length;\\n    var m = potions.length;\\n    var pairs = new int[n];\\n    \\n    Arrays.sort(potions);\\n\\n    for (var i=0; i<n; i++) {\\n      var minPotion = (int) Math.ceil((double) success / spells[i]);\\n\\n      if (minPotion > potions[m-1]) continue;\\n\\n      var l = 0;\\n      var r = m-1;\\n\\n      while (l < r) {\\n        var mid = l + (r-l) / 2;\\n\\n        if (potions[mid] < minPotion) l = mid+1;\\n        else r = mid;\\n      }\\n      pairs[i] = m-l;\\n    }\\n    return pairs;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371519,
                "title": "c-easy-lower-bound-2023-short-sol-must-watch",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long t) {\\n        sort(p.begin(),p.end());\\n        vector<int> ans; \\n        int x; long long y;\\n        for(auto &it:s) {\\n            y = t / it;\\n            x = p.end() - lower_bound(p.begin(),p.end(),y * it >= t ? y : y + 1);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long t) {\\n        sort(p.begin(),p.end());\\n        vector<int> ans; \\n        int x; long long y;\\n        for(auto &it:s) {\\n            y = t / it;\\n            x = p.end() - lower_bound(p.begin(),p.end(),y * it >= t ? y : y + 1);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371258,
                "title": "python-3-7-lines-binary-search-t-m-97-70",
                "content": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        n, ans = len(potions), []\\n        potions.sort()\\n        \\n        for s in spells:\\n            num = success//s + bool(success%s)\\n            idx = bisect_left(potions, num)\\n            ans.append(n-idx)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/successful-pairs-of-spells-and-potions/submissions/926254122/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        n, ans = len(potions), []\\n        potions.sort()\\n        \\n        for s in spells:\\n            num = success//s + bool(success%s)\\n            idx = bisect_left(potions, num)\\n            ans.append(n-idx)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370628,
                "title": "binary-search-c-please-upvote",
                "content": "# Intuition\\nCan be done in binary search.\\n\\n# Approach\\nStarting with the sorting of potions  , After that getting the element till which (spells[i]*potions[mid]) is greater than success and store those elements in pairs[i].\\nThe submission shall be taken care of for long long type casting.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogm)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n       \\n       \\n       sort(potions.begin(),potions.end());\\n       vector<int> pairs(n);\\n      for(int i=0;i<n;i++){\\n          int c=0,l=0,r=m-1;\\n        while(l<=r){\\n            \\n            int mid=l+(r-l)/2;\\n            if((long long)spells[i]*(long long)potions[mid]>=success){\\n                r=mid-1;\\n                \\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        pairs[i]=m-1-r;\\n        }\\n\\n        \\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n       \\n       \\n       sort(potions.begin(),potions.end());\\n       vector<int> pairs(n);\\n      for(int i=0;i<n;i++){\\n          int c=0,l=0,r=m-1;\\n        while(l<=r){\\n            \\n            int mid=l+(r-l)/2;\\n            if((long long)spells[i]*(long long)potions[mid]>=success){\\n                r=mid-1;\\n                \\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        pairs[i]=m-1-r;\\n        }\\n\\n        \\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370295,
                "title": "simple-14-lines-of-code-in-o-n-logn",
                "content": "# NOTE:\\n**Please go through the Intution and Approach before jumping to the code. You will definitely get it!**\\nSuggested to write things on notebook while reading.\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the question, we can see a basic pattern that we have to search a value for every element in spell. If we do this searching linearly for all n elements of spell (m times).\\n\\nIt will give us complexity of `O(n*m)`. This complexity can be reduced to  `O(n * logm)`  by using binary search. But before that we have to sort the array potions.\\n```C++ []\\nsort(potions.begin(), potions.end());   // sorting array of potions\\n```\\n\\nNow, it is given in the question that we have to find the number of elements in potions that multiply with spell[i] to give value >= success.\\n\\nIn simple words: \\n$$spells[i] * potions[j]  >=  success$$\\n\\nTaking spells[i] on R.H.S. we get:\\n$$potions[j] >= success / spells[i]$$\\n\\nSo minimum possible value of potion for spells[i] is `success / spells[i]`. Now, it is clear that we have to find **$$lower bound$$** in our already sorted array of potions. And we know,  all the elements after this lower bound in the potions array will be greater (as the array is sorted in increasing order), so we will get the answer by doing m - lower bound.\\n```\\nans[i] = m - lower_bound_ind;\\n```\\nPlease check the code below.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n logm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote if it was helpfull.!\\uD83D\\uDE03\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans(n);\\n        for (int i{}; i<n; ++i){\\n            long long potion = ceil((double)success/spells[i]);\\n            int lower_bound_ind = lower_bound(potions.begin(), potions.end(), potion) - potions.begin();\\n            ans[i] = m-lower_bound_ind;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```C++ []\\nsort(potions.begin(), potions.end());   // sorting array of potions\\n```\n```\\nans[i] = m - lower_bound_ind;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans(n);\\n        for (int i{}; i<n; ++i){\\n            long long potion = ceil((double)success/spells[i]);\\n            int lower_bound_ind = lower_bound(potions.begin(), potions.end(), potion) - potions.begin();\\n            ans[i] = m-lower_bound_ind;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370276,
                "title": "easy-java-binary-search-beats-85",
                "content": "# Intuition\\nSolution using basic Binary Search\\n\\n# Approach\\n1. sort the potion array\\n2. now iterate for the spell array\\n3. binary search the index where the multiple of spell*potion>=success\\n4. now from that index onwards rest potions will be surely >=success because they are arranged in increasing order\\n# Complexity\\n- Time complexity:\\nO(NlogM)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] s, int[] p, long sus) {\\n        Arrays.sort(p);\\n        int n = s.length;\\n        int m = p.length;\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            ans[i] =m-search(p,sus,m,s[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int search(int[] p ,long t ,int size, int given){\\n        int s =0;\\n        int e = size-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            long mul = (long)given*p[mid];\\n            if(mul>=t){\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] s, int[] p, long sus) {\\n        Arrays.sort(p);\\n        int n = s.length;\\n        int m = p.length;\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            ans[i] =m-search(p,sus,m,s[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int search(int[] p ,long t ,int size, int given){\\n        int s =0;\\n        int e = size-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            long mul = (long)given*p[mid];\\n            if(mul>=t){\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369698,
                "title": "binary-search-approach-java-solution",
                "content": "\\n# Java Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int pairs[] = new int[spells.length];\\n\\n        Arrays.sort(potions);\\n\\n        for(int i = 0; i < spells.length; i++)\\n        {\\n            int start = 0, end = potions.length-1;\\n            while(start <= end)\\n            {\\n                int mid = start + (end - start)/2;\\n                if(potions[mid] * (long)spells[i] >= success)\\n                {\\n                    end = mid - 1;\\n                }\\n                else\\n                {\\n                    start = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - start;\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int pairs[] = new int[spells.length];\\n\\n        Arrays.sort(potions);\\n\\n        for(int i = 0; i < spells.length; i++)\\n        {\\n            int start = 0, end = potions.length-1;\\n            while(start <= end)\\n            {\\n                int mid = start + (end - start)/2;\\n                if(potions[mid] * (long)spells[i] >= success)\\n                {\\n                    end = mid - 1;\\n                }\\n                else\\n                {\\n                    start = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - start;\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369619,
                "title": "easy-explanation-binary-search-approach",
                "content": "# Approach\\n1. Brute Force approach to solve this problem is to use a **nested loop**, where the outer loop iterates over the \"spells\" vector and the inner loop iterates over the \"potions\" vector. For each pair (s, p), the product s * p is checked against the target. If the product is greater than or equal to the target, then the pair is considered successful and the count is incremented.\\nHowever, this approach has a time complexity of **O(n^2)**, which is inefficient for large values of n.\\n2. A more efficient approach is to first sort the \"potions\" vector in non-decreasing order. This allows us to perform ***binary search*** on the sorted \"potions\" vector to ***find the index of the last element*** that satisfies the condition ***s * p >= target*** for a given s->element.\\n Then, for each element s in the \"spells\" vector, we can use binary search to find the number of elements in the \"potions\" vector that satisfy the condition s * p >= target. This can be done by finding the index of the last element in the \"potions\" vector that satisfies the condition using binary search, and subtracting this index from the total number of elements in the \"potions\" vector.\\n\\n# Complexity\\n- Time complexity:    O(n log n)\\n- Space Complexity:   O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n       \\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>v(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n       \\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>v(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369587,
                "title": "python3-one-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return potions.sort() or [len(potions) - bisect_left(potions, -(-success // spell)) for spell in spells]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return potions.sort() or [len(potions) - bisect_left(potions, -(-success // spell)) for spell in spells]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369441,
                "title": "easy-and-fast-c-solution-with-full-explanation",
                "content": "# Intuition\\nsorting the potions array to reduce the number of operations to search(binary search) for the element whose product with ith spell is greater than or equal to the success.\\n\\n# Approach\\n1. sort `potions` array.\\n2. use `binary search` to search for the element whose product with that spell is equal or just greater than `success`.\\n3. count all the elements after that element *(including that element)* in `potions` array as all the elements after this element are greater than it and hence will result in greater product than `success`.\\n4. store that count in an `ans` vector.\\n5. return `ans`.\\n\\n# Complexity\\n- Time complexity:\\n`O(n*logm)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto &i: spells){\\n            int j = 0;\\n            int k = m-1;\\n            while(j<=k){\\n                int mid = (j+k)/2;\\n                int long x = potions[mid];\\n                if(i*x<success){\\n                    j = mid + 1;\\n                }\\n                else{\\n                    k = mid - 1;\\n                }\\n            }\\n            ans.push_back(m-k-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto &i: spells){\\n            int j = 0;\\n            int k = m-1;\\n            while(j<=k){\\n                int mid = (j+k)/2;\\n                int long x = potions[mid];\\n                if(i*x<success){\\n                    j = mid + 1;\\n                }\\n                else{\\n                    k = mid - 1;\\n                }\\n            }\\n            ans.push_back(m-k-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368952,
                "title": "c-solution-with-explanation-let-s-code-it",
                "content": "# Upvote if you found this solution helpful\\uD83D\\uDD25\\n\\n# Approach\\nThe first approach which comes to mind after reading the question is to traverse the Potions array for each spell and count the number of pairs which satisfies the given condition, but this method leads to TLE because the time complexity for this will be O(n x m) where both n and m are of order 10^5.\\nSo, the optimized approach is to reduce the number of calculations we are doing for each spell.\\nIf we think for second we can deduce that by sorting the list of potions and using binary search to traverse the list we can reduce our calculations in a significant way.\\n\\nNOTE: Keep in mind to convert the product of spell and potion to LONG LONG before further moving with calculations\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countPairs(int spell, vector<int> &potions, long long success){\\n        int n = potions.size();\\n        int index = n;\\n        int start = 0;\\n        int end = n-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\n            //if the product of potion and spell satisfies the condition, move the end pointer to mid-1 because we need to find the first element for which the product of spell and potion is greater than success\\n            if((long long)potions[mid]*spell >= success){\\n                index = mid;\\n                end = mid-1;\\n            }\\n\\n            //if the product is less than the success value move to start pointer to mid+1\\n            if((long long)potions[mid]*spell < success)\\n                start = mid+1;\\n        }\\n\\n        return n-index;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n\\n        //sorting the potions list\\n        sort(potions.begin(), potions.end());\\n\\n        //for each spell find the number of potions which can satisfy the condition\\n        for(int i=0; i<spells.size(); i++)\\n            ans[i] = countPairs(spells[i], potions, success);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countPairs(int spell, vector<int> &potions, long long success){\\n        int n = potions.size();\\n        int index = n;\\n        int start = 0;\\n        int end = n-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\n            //if the product of potion and spell satisfies the condition, move the end pointer to mid-1 because we need to find the first element for which the product of spell and potion is greater than success\\n            if((long long)potions[mid]*spell >= success){\\n                index = mid;\\n                end = mid-1;\\n            }\\n\\n            //if the product is less than the success value move to start pointer to mid+1\\n            if((long long)potions[mid]*spell < success)\\n                start = mid+1;\\n        }\\n\\n        return n-index;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n\\n        //sorting the potions list\\n        sort(potions.begin(), potions.end());\\n\\n        //for each spell find the number of potions which can satisfy the condition\\n        for(int i=0; i<spells.size(); i++)\\n            ans[i] = countPairs(spells[i], potions, success);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368830,
                "title": "python-short-and-clean-2-liner-functional-programming",
                "content": "# Approach\\n1. Sort `potions` into, say `s_potions`.\\n\\n2. For each `spells`, say `x`, binary-search for insertion index `i` in `s_potions`.\\n\\n3. Return `len(potions) - i`.\\n\\n# Complexity\\n- Time complexity: $$O((m + n) * log(n))$$\\n\\n- Space complexity: $$O(m + n)$$\\n\\nwhere,\\n`m is number of spells`,\\n`n is number of potions`.\\n\\n# Code\\nWIth currying (partial functions):\\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        f = partial(bisect.bisect_left, sorted(potions))\\n        return (len(potions) - f(success / x) for x in spells)\\n\\n\\n```\\nWithout using currying (partial functions):\\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        s_potions = sorted(potions)\\n        return (len(potions) - bisect.bisect_left(s_potions, success / x) for x in spells)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        f = partial(bisect.bisect_left, sorted(potions))\\n        return (len(potions) - f(success / x) for x in spells)\\n\\n\\n```\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        s_potions = sorted(potions)\\n        return (len(potions) - bisect.bisect_left(s_potions, success / x) for x in spells)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368195,
                "title": "clear-c-binary-search-beats-95-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter sort potions, this problem becomes to: for each spells[i], find the first index in potions that spells[i] * potions[index] >= success. Then the pair that spells[i] can form is potions.Length - index\\n\\nFind the first index match a condition is a typical binary search question.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mlogm + nlogm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n             Array.Sort(potions);\\n            int[] retval = new int[spells.Length];\\n            for(int i = 0; i < spells.Length; i++)\\n            {\\n                int l = 0, r = potions.Length - 1;\\n                int leftMostIdx = -1;\\n                while(l <= r)\\n                {\\n                    int m = (l + r) / 2;\\n                    if (((long)spells[i]) * potions[m] >= success)\\n                    {\\n                        leftMostIdx = m;\\n                        r = m - 1;\\n                    }\\n                    else l = m + 1;\\n                }\\n                retval[i] = leftMostIdx == -1 ? 0 : potions.Length - leftMostIdx;\\n            }\\n\\n            return retval;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n             Array.Sort(potions);\\n            int[] retval = new int[spells.Length];\\n            for(int i = 0; i < spells.Length; i++)\\n            {\\n                int l = 0, r = potions.Length - 1;\\n                int leftMostIdx = -1;\\n                while(l <= r)\\n                {\\n                    int m = (l + r) / 2;\\n                    if (((long)spells[i]) * potions[m] >= success)\\n                    {\\n                        leftMostIdx = m;\\n                        r = m - 1;\\n                    }\\n                    else l = m + 1;\\n                }\\n                retval[i] = leftMostIdx == -1 ? 0 : potions.Length - leftMostIdx;\\n            }\\n\\n            return retval;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367859,
                "title": "c-sort-and-lower-bound",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        int n = s.size(), m = p.size();\\n        sort(p.begin(), p.end());\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i += 1) {\\n            long long x = (success + s[i] - 1) / s[i];\\n            if (x > p.back()) continue;\\n            auto it = lower_bound(p.begin(), p.end(), (int)x);\\n            res[i] = m - (it - p.begin());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        int n = s.size(), m = p.size();\\n        sort(p.begin(), p.end());\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i += 1) {\\n            long long x = (success + s[i] - 1) / s[i];\\n            if (x > p.back()) continue;\\n            auto it = lower_bound(p.begin(), p.end(), (int)x);\\n            res[i] = m - (it - p.begin());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750229,
                "title": "easiest-best-solution-in-c-binarysearch",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogm)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n        vector<int> pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n            if(spells[i]>=success){\\n                pairs.push_back(m);\\n                continue;\\n            }\\n            int ll=0,ul=m-1,mid;\\n            while(ll<=ul){\\n                mid =ll+(ul-ll)/2;\\n                long long product=(long long)potions[mid]*spells[i];\\n                if(product>=success)\\n                    ul=mid-1;\\n                else\\n                    ll=mid+1;\\n            }\\n            pairs.push_back(m-ll);\\n        }\\n        return pairs;\\n    }\\n};\\n```\\n**Happy LeetCoding\\uD83D\\uDCAF\\nPlease Upvote**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n        vector<int> pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n            if(spells[i]>=success){\\n                pairs.push_back(m);\\n                continue;\\n            }\\n            int ll=0,ul=m-1,mid;\\n            while(ll<=ul){\\n                mid =ll+(ul-ll)/2;\\n                long long product=(long long)potions[mid]*spells[i];\\n                if(product>=success)\\n                    ul=mid-1;\\n                else\\n                    ll=mid+1;\\n            }\\n            pairs.push_back(m-ll);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444760,
                "title": "js-binary-search-runtime-83-33",
                "content": "```\\nvar successfulPairs = function(spells, potions, success) {\\n\\tlet res = [];\\n\\tpotions.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < spells.length; i++) {\\n\\t\\tlet h = potions.length-1, l = 0, mid;\\n\\t\\twhile (l <= h) {\\n\\t\\t\\tmid = ~~(l + (h-l)/2);\\n\\t\\t\\tif (spells[i] * potions[mid] >= success) h = mid-1;\\n\\t\\t\\telse l = mid+1;\\n\\t\\t}\\n\\t\\tres[i] = potions.length-1 - h;\\n\\t}\\n\\treturn res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar successfulPairs = function(spells, potions, success) {\\n\\tlet res = [];\\n\\tpotions.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < spells.length; i++) {\\n\\t\\tlet h = potions.length-1, l = 0, mid;\\n\\t\\twhile (l <= h) {\\n\\t\\t\\tmid = ~~(l + (h-l)/2);\\n\\t\\t\\tif (spells[i] * potions[mid] >= success) h = mid-1;\\n\\t\\t\\telse l = mid+1;\\n\\t\\t}\\n\\t\\tres[i] = potions.length-1 - h;\\n\\t}\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139975,
                "title": "o-n-m-approach-c-without-binary-search-and-sort-easy-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxi = 0;\\n        unordered_map<int,int> dp;\\n        for(int i = 0 ; i<potions.size() ; i++){\\n            dp[potions[i]]++;\\n            maxi = max(potions[i],maxi);\\n        }\\n        \\n        vector<int> refer(maxi+1);\\n        \\n        refer[refer.size()-1] = dp[refer.size()-1];\\n        \\n        for(int i = refer.size()-2 ; i >= 0 ; i--){\\n            refer[i] = refer[i+1] + dp[i];\\n        }\\n        \\n        vector<int> result(spells.size());\\n        \\n        for(int i = 0 ; i < spells.size() ; i++){\\n            double t1 = success;\\n            double t2 = spells[i];\\n            long long temp = ceil(t1/t2);\\n            if(temp > maxi){\\n                result[i] = 0;\\n                continue;\\n            }\\n            result[i]= refer[temp];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxi = 0;\\n        unordered_map<int,int> dp;\\n        for(int i = 0 ; i<potions.size() ; i++){\\n            dp[potions[i]]++;\\n            maxi = max(potions[i],maxi);\\n        }\\n        \\n        vector<int> refer(maxi+1);\\n        \\n        refer[refer.size()-1] = dp[refer.size()-1];\\n        \\n        for(int i = refer.size()-2 ; i >= 0 ; i--){\\n            refer[i] = refer[i+1] + dp[i];\\n        }\\n        \\n        vector<int> result(spells.size());\\n        \\n        for(int i = 0 ; i < spells.size() ; i++){\\n            double t1 = success;\\n            double t2 = spells[i];\\n            long long temp = ceil(t1/t2);\\n            if(temp > maxi){\\n                result[i] = 0;\\n                continue;\\n            }\\n            result[i]= refer[temp];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139392,
                "title": "java-clean-code-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Arrays.sort(potions);\\n        int[] res=new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int count=binarySearch(spells[i],potions,success);\\n            res[i]=count;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public static int binarySearch(int spell, int[] potions, long success)\\n    {\\n        int i=0;\\n        int j=potions.length-1;\\n        int n=potions.length;\\n        \\n        int res=0;\\n        \\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            \\n            if((spell*1.0)*potions[mid]>=success)\\n            {\\n                res=n-mid;\\n                j=mid-1;\\n            }\\n            \\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Arrays.sort(potions);\\n        int[] res=new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int count=binarySearch(spells[i],potions,success);\\n            res[i]=count;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public static int binarySearch(int spell, int[] potions, long success)\\n    {\\n        int i=0;\\n        int j=potions.length-1;\\n        int n=potions.length;\\n        \\n        int res=0;\\n        \\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            \\n            if((spell*1.0)*potions[mid]>=success)\\n            {\\n                res=n-mid;\\n                j=mid-1;\\n            }\\n            \\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139292,
                "title": "python-binary-search-explanation",
                "content": "I Was Also One Of The Person Who Got TLE At The First Attempt\\n\\nThe Straight Forward Approach was to multiply each and every value of potion with the every value of spell and count the values which are greater than success and append to the answer array. This was one of the common solution which every one thinks of..\\n\\nThe Solution For Me Which Got Accepted Was After Using Binary Search With Sorting Array.\\n\\nLet Us See How It Worked For Me..\\n\\nSuppose spell = [5,1,3] potions = [1,2,3,4,5]  success = 7\\n\\nConsider First Element Of Spell - 5  the least number that makes 5 after multiplying results to greater than or equal to  7 that is obviously 2 - So the resultant value will be 4 \\n\\nConsider Second Element Of Spell -1 The Smallest Number That Makes Greater Than or equal to 7 is 7 but it is not in the array so the resultant value will be 0\\n\\nConsider Last Element Of Spell - 3 The Smallest Number That Makes 3 Greater Than Or Equal To 7 is 3 - So the Resultant Value will be 3\\n\\nSimilarly For Every Value in Spell If We Are Able To Find The Smaller Value Which After Multiplying Makes Greater Than Success Value And Then We Had To Find The Left Most Index Which Will Be Suitable For Placing The Obtained Value In The Potions Will Result Us Answer.\\n\\nThis is my following Code For The Problem..\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        result = self.function(spells,potions,success)\\n        return result\\n    \\n    def function(self,arr1,arr2,success):\\n        n2 = len(arr2)\\n        arr2.sort() #Sorting Enables Us To Do Binary Search\\n        ans = []\\n        for i in arr1:\\n            val = math.ceil(success/i) #Finding the Value Of Portion With Least Strength So That It Can Be Greater Than Success\\n            idx = bisect.bisect_left(arr2,val) #Finding The Left Most Index So That The Value Can Be Inserted\\n            res = n2-idx+1  #Calculating the remaining numbers after finding the suitable index\\n            ans.append(res-1)\\n        return ans\\n```\\n\\nPlease Upvote If You Like The Explanation..\\uD83D\\uDE0A\\n\\n\\nHappy LeetCoding!!!!",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        result = self.function(spells,potions,success)\\n        return result\\n    \\n    def function(self,arr1,arr2,success):\\n        n2 = len(arr2)\\n        arr2.sort() #Sorting Enables Us To Do Binary Search\\n        ans = []\\n        for i in arr1:\\n            val = math.ceil(success/i) #Finding the Value Of Portion With Least Strength So That It Can Be Greater Than Success\\n            idx = bisect.bisect_left(arr2,val) #Finding The Left Most Index So That The Value Can Be Inserted\\n            res = n2-idx+1  #Calculating the remaining numbers after finding the suitable index\\n            ans.append(res-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139016,
                "title": "binary-search-python-easy-to-understand",
                "content": "Idea:\\nThe pretty straightforward solution, sort potions and for each spell find an index of minimal potions that will make success and we know that everything greater will make a success too. \\n\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans = []\\n        for i in spells:\\n            cur = success/i\\n            ans.append(len(potions)-bisect.bisect_left(potions, cur))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans = []\\n        for i in spells:\\n            cur = success/i\\n            ans.append(len(potions)-bisect.bisect_left(potions, cur))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138968,
                "title": "priority-queue-c-max-heap-easy-understanding-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        priority_queue<int> pq;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<potions.size();i++)\\n            pq.push(potions[i]);\\n        vector<int> spells1=spells;\\n        sort(spells.begin(),spells.end());\\n        int cnt=0;\\n        for(int i=0;i<=spells.size()-1;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n                int x=pq.top();\\n                if((long long) x* (long long) spells[i]>=success) {cnt++; pq.pop();}\\n                else\\n                  break;\\n            }\\n            mp[spells[i]]=cnt;\\n        }\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            ans.push_back(mp[spells1[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        priority_queue<int> pq;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<potions.size();i++)\\n            pq.push(potions[i]);\\n        vector<int> spells1=spells;\\n        sort(spells.begin(),spells.end());\\n        int cnt=0;\\n        for(int i=0;i<=spells.size()-1;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n                int x=pq.top();\\n                if((long long) x* (long long) spells[i]>=success) {cnt++; pq.pop();}\\n                else\\n                  break;\\n            }\\n            mp[spells[i]]=cnt;\\n        }\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            ans.push_back(mp[spells1[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138935,
                "title": "sort-potions-and-apply-binary-search-c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long k) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(), m = potions.size();\\n        int i = 0, j = 0;\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            int l = 0, h = m;\\n            long long c1 = spells[i];\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                long long c2 = potions[mid];\\n                long long cur = c1*c2;\\n                if(cur<k) l = mid+1;\\n                else if(cur>=k) h = mid;\\n            }\\n            res.push_back(m-h);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long k) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(), m = potions.size();\\n        int i = 0, j = 0;\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            int l = 0, h = m;\\n            long long c1 = spells[i];\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                long long c2 = potions[mid];\\n                long long cur = c1*c2;\\n                if(cur<k) l = mid+1;\\n                else if(cur>=k) h = mid;\\n            }\\n            res.push_back(m-h);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138781,
                "title": "ceil-binary-search",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& portions, long long success) {\\n\\t\\t\\tsort(begin(portions),end(portions));\\n\\t\\t\\tvector<int>res;\\n\\t\\t\\tint m = portions.size();\\n\\t\\t\\tfor(auto num:spells){\\n\\t\\t\\t\\tif(success/num>=100001){\\n\\t\\t\\t\\t\\tres.push_back(0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint n = success/num + (success%num!=0);\\n\\t\\t\\t\\tint i = lower_bound(begin(portions),end(portions),n)-begin(p);\\n\\t\\t\\t\\tres.push_back(m-i);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& portions, long long success) {\\n\\t\\t\\tsort(begin(portions),end(portions));\\n\\t\\t\\tvector<int>res;\\n\\t\\t\\tint m = portions.size();\\n\\t\\t\\tfor(auto num:spells){\\n\\t\\t\\t\\tif(success/num>=100001){\\n\\t\\t\\t\\t\\tres.push_back(0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4012507,
                "title": "successful-pairs-of-spells-and-potions-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777754,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374919,
                "title": "java-solution-binary-search-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code takes two arrays, spells and potions, and a success value as input. It then sorts the potions array and creates a new integer array pairs with the same length as the spells array.\\n\\nFor each element spells[i] in the spells array, the code performs a binary search on the potions array to find the largest index low such that the product of spells[i] and the potion at index low is less than success. This is done by comparing the product of spells[i] and the middle element of the remaining subarray with success, and narrowing the search space accordingly.\\n\\nOnce the binary search is completed, the code sets pairs[i] to the number of elements in the potions array that are greater than or equal to potions[low]. Since the potions array is sorted in ascending order, this value corresponds to the number of pairs of spells[i] and potions[j] such that their product is greater than or equal to success.\\n\\nThe pairs array is then returned as the result.\\n\\nIn summary, the code computes the number of successful pairs of spells and potions, where a pair is considered successful if the product of the two elements is greater than or equal to a given threshold success.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int low = 0, high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if ((long) spells[i] * potions[mid] >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - low;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int low = 0, high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if ((long) spells[i] * potions[mid] >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - low;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372258,
                "title": "using-binary-search-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you divide each element of potions from the success, you can get some information about how much the spell should be. Then by sorting the new array and using binary search you can find the number of element which is less than or equal to the spell\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n# If you like, please upvote!\\n\\n# Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    let arr = [];\\n    for(let potion of potions) {\\n        arr.push(Math.ceil(success / potion));\\n    }\\n    arr.sort((a,b) => a-b);\\n    const n = arr.length;\\n    console.log(arr);\\n\\n    const res = [];\\n    for(let spell of spells) {\\n        let l=0, r=n-1, M=0;\\n        while(l<=r) {\\n            let m = Math.floor((l+r)/2);\\n            if(arr[m] <= spell) {\\n                l = m+1;\\n                M = l;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        res.push(M);\\n    }  \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    let arr = [];\\n    for(let potion of potions) {\\n        arr.push(Math.ceil(success / potion));\\n    }\\n    arr.sort((a,b) => a-b);\\n    const n = arr.length;\\n    console.log(arr);\\n\\n    const res = [];\\n    for(let spell of spells) {\\n        let l=0, r=n-1, M=0;\\n        while(l<=r) {\\n            let m = Math.floor((l+r)/2);\\n            if(arr[m] <= spell) {\\n                l = m+1;\\n                M = l;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        res.push(M);\\n    }  \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3372158,
                "title": "easy-solutions-in-java-and-c-look-at-once-with-explanation",
                "content": "# Intuition\\nFor each spell, we need to find the number of potions that can form a succesfull pair with it means if we multiple the `spell[i]` with `potions[i]` and the value if `>=` success we can call it successful. We are iterating over all the spells and finding the particular potions from where all the upper potion can be successful and lower than that particular potion rest can\\'t make successful.\\nFor finding that particular point of potions vector we sort it and apply binary search as we can easily trim the search space in every turn.\\n\\n# Approach\\n1. Sort the `potions` in ascending order.\\n2. For each spell `s[i]`, calculate the maximum number of potions that can be paired with it such that their sum is less than or equal to success.\\n- I have created a maxNumber which hold the value of `(spell[i]/success)`, it tells us the minimum number which we should we multiply with `spell[i]` to get the success.\\n- if the `spell[i]` divides the success completely (for eg. 25 is success and we have `spell[i]` with a strength of 5 which mean we need minimum 5 to make success) that\\'s why i did `maxNumber - 1` in the case of `number % success == 0`\\n- else we simply take the ceil of `number / success`\\n- the `low` will has the the index of the number which is just greater than the required number so return `(potions.size() - low)` will gives the count of the number that are greater than it.\\n3. I have used binary search to find the number of potions in `potions` that have a value less than or equal to the maximum number of potions calculated in `step 2`.\\n4. Append the number of potions found in step 3 to the ans vector.\\n\\n# Complexity\\n- Time complexity:-\\nThe time complexity of the `successfulPairs` function is $$O(n log m)$$ where `n` is the length of the spells vector and `m` is the length of the potions vector. The time complexity of the `calculate` function is $$O(log m)$$ where `m` is the length of the potions \\n\\n- Space complexity:-\\nThe space complexity is $$O(1)$$ since they use constant extra space.\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n\\n    int calculate(int number, vector<int>& potions, long long success){\\n    long long maxNumber;\\n    if (success % number == 0){\\n        maxNumber = (success/number)-1;\\n    }\\n    else{\\n        maxNumber = ceil(success/number);\\n    }\\n    int low = 0;\\n    int high = potions.size() - 1;\\n    while(low <= high){\\n        int mid = (high + low) >> 1;\\n        if (potions[mid] <= maxNumber) low = mid+1;\\n        else high = mid - 1;\\n    }\\n    high = potions.size();\\n    return (high - low);\\n    }\\n\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(int i=0; i<spells.size(); i++){\\n            int pair = calculate(spells[i], potions, success);\\n            ans.push_back(pair);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```\\n### Read This \\uD83D\\uDC47\\n\\n**Hope it helps you \\uD83D\\uDE0A Keep Learning**\\n- If you didn\\'t understand anything ask in comment as no-one is perfect.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int calculate(int number, vector<int>& potions, long long success){\\n    long long maxNumber;\\n    if (success % number == 0){\\n        maxNumber = (success/number)-1;\\n    }\\n    else{\\n        maxNumber = ceil(success/number);\\n    }\\n    int low = 0;\\n    int high = potions.size() - 1;\\n    while(low <= high){\\n        int mid = (high + low) >> 1;\\n        if (potions[mid] <= maxNumber) low = mid+1;\\n        else high = mid - 1;\\n    }\\n    high = potions.size();\\n    return (high - low);\\n    }\\n\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(int i=0; i<spells.size(); i++){\\n            int pair = calculate(spells[i], potions, success);\\n            ans.push_back(pair);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372127,
                "title": "successful-pairs-of-spells-and-potions-python-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nBinary Search \\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [None] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [None] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371871,
                "title": "why-this-solution-is-not-accepted",
                "content": "Why This solution is not accepted, I see no TLE\\'s, \\nExactly want to know, why this TC is breaking the logic.\\n\\n\\nAlthough 48 passed out of 56 \\uD83E\\uDD72\\n\\n![Screenshot 2023-04-03 at 12.09.29 AM.png](https://assets.leetcode.com/users/images/caddea78-8146-444a-b0ea-a3215012d623_1680461180.6110756.png)\\n\\nRegards",
                "solutionTags": [
                    "Java"
                ],
                "code": "Why This solution is not accepted, I see no TLE\\'s, \\nExactly want to know, why this TC is breaking the logic.\\n\\n\\nAlthough 48 passed out of 56 \\uD83E\\uDD72\\n\\n![Screenshot 2023-04-03 at 12.09.29 AM.png](https://assets.leetcode.com/users/images/caddea78-8146-444a-b0ea-a3215012d623_1680461180.6110756.png)\\n\\nRegards",
                "codeTag": "Unknown"
            },
            {
                "id": 3371657,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N LOG M)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& arr, vector<int>& nums, long long success) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> msxans;\\n        for(int i = 0;i<arr.size();i++){\\n            int s = 0;\\n            int e = nums.size()-1;\\n            int ans = -1;\\n            while(s<=e){\\n            int mid = s + (e - s)/2;\\n            long long value = (long)nums[mid]*arr[i] ; \\n                if(value >= success){\\n                    ans = mid;\\n                    e = mid - 1;\\n                }\\n                else s = mid + 1;\\n            }\\n            if(ans != -1) {\\n               msxans.push_back(nums.size()-ans);\\n            }\\n            else msxans.push_back(0);\\n        }\\n        return msxans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& arr, vector<int>& nums, long long success) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> msxans;\\n        for(int i = 0;i<arr.size();i++){\\n            int s = 0;\\n            int e = nums.size()-1;\\n            int ans = -1;\\n            while(s<=e){\\n            int mid = s + (e - s)/2;\\n            long long value = (long)nums[mid]*arr[i] ; \\n                if(value >= success){\\n                    ans = mid;\\n                    e = mid - 1;\\n                }\\n                else s = mid + 1;\\n            }\\n            if(ans != -1) {\\n               msxans.push_back(nums.size()-ans);\\n            }\\n            else msxans.push_back(0);\\n        }\\n        return msxans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370989,
                "title": "day92-binary-search-very-easy-solution",
                "content": "# Intuition and Approach\\nWe have implemented Binary Search to Solve the problem\\n\\nSo, Condition to use binary tree is that array must be sorted\\n\\nSo, we used the inbuilt sort function.\\n\\nNow to solve the problem many of you have already tried to do it in O(n^2) order (Code given below) but it is giving the TLE.\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            for(int j=0;j<po.size();j++){\\n                if(s[i]*po[j] >= success){\\n                    count++;\\n                }\\n            }\\n            v.push_back(count);\\n            count=0;\\n        }\\n        return v;\\n    }\\n};\\n```\\n(In above approach we are simply calulating the product of two array and comparing it to Success)\\nSo, to overcome the TLE we have to think a way to minimize our search space and hence Binary Search came into play\\n\\nThere is an **Observation** for sorted array which is that if a current potion muliplied with current spell and if it greater than Success then all elements ahead of that position will be a satisfiable answer.\\n```\\ne.g. spells=[5,3,1] , potion=[1,2,3,4,5] , Success=7\\nAns: 5*1=5, 5*2=10, 5*3=15, 5*4=20, 5*5=25\\n              |\\n              |--from here, all ahead value will be greater than Success\\nSimilarly, 3*1=3, 3*2=6, 3*3=9...\\n                           |\\n                           |--from here, all value satisfy the Success\\n*Hence, we have to calculate or find the leftmost value which satisfies \\nthe relation.\\n```\\nSo, We are using binary search to find that value by using the condition you can check it in the code.\\n\\n**Upvote If you like.**\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        //sorting the potion array\\n        sort(po.begin(),po.end());\\n\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            int l=0,r=po.size()-1;\\n            int mid=l + (r-l)/2;\\n            //Using Binary Search on potion array\\n            while(l<=r){\\n                if(s[i]*1ll*po[mid] >= success){//1LL is securely integer overflow\\n                    count=po.size()-mid;\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n                mid= l + (r-l)/2;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            for(int j=0;j<po.size();j++){\\n                if(s[i]*po[j] >= success){\\n                    count++;\\n                }\\n            }\\n            v.push_back(count);\\n            count=0;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\ne.g. spells=[5,3,1] , potion=[1,2,3,4,5] , Success=7\\nAns: 5*1=5, 5*2=10, 5*3=15, 5*4=20, 5*5=25\\n              |\\n              |--from here, all ahead value will be greater than Success\\nSimilarly, 3*1=3, 3*2=6, 3*3=9...\\n                           |\\n                           |--from here, all value satisfy the Success\\n*Hence, we have to calculate or find the leftmost value which satisfies \\nthe relation.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        //sorting the potion array\\n        sort(po.begin(),po.end());\\n\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            int l=0,r=po.size()-1;\\n            int mid=l + (r-l)/2;\\n            //Using Binary Search on potion array\\n            while(l<=r){\\n                if(s[i]*1ll*po[mid] >= success){//1LL is securely integer overflow\\n                    count=po.size()-mid;\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n                mid= l + (r-l)/2;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370506,
                "title": "binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& S, vector<int>& P, long long k) {\\n        int n = size(P);\\n        sort(begin(P),end(P));\\n        vector<int> ans;\\n        for(long long&&s: S){\\n            long long req = k%s ? k/s+1 : k/s;\\n            int idx = lower_bound(begin(P),end(P),req) - begin(P);\\n            if(idx < n) ans.push_back(n-idx);\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& S, vector<int>& P, long long k) {\\n        int n = size(P);\\n        sort(begin(P),end(P));\\n        vector<int> ans;\\n        for(long long&&s: S){\\n            long long req = k%s ? k/s+1 : k/s;\\n            int idx = lower_bound(begin(P),end(P),req) - begin(P);\\n            if(idx < n) ans.push_back(n-idx);\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370172,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n -->\\nOnce you figure it out that if you get the smallest potion value multiply by the spell is greater than equal to success in sorted potion array. Then no need to calculate potion[i]*spell[j] for every index. And you can directly calculate number of potion by potion.length - (index of smallest potion greater than or equal to success)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the potion array in ascending order\\n2. Iterate orver all the spells value.\\n3. Apply binary search on potion array and find the value of mid such that index of smallest potion greater than or equal to success.\\n4. Caluculate answer for each index as potion.length - l(lower index)\\n5. Store the value in result array and return\\n# Complexity\\n- Time complexity: O(nlogm + mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) depending upon sorting algorithm\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int bs(int[] potions,int spell, long success){\\n        int l=0;\\n        int r=potions.length-1;\\n\\n        while(l<=r){\\n            int m = l - (l-r)/2;\\n            long mul =(long) potions[m]*spell;\\n            if(mul>=success){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return potions.length-l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int res[] = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            res[i] = bs(potions,spells[i],success);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int bs(int[] potions,int spell, long success){\\n        int l=0;\\n        int r=potions.length-1;\\n\\n        while(l<=r){\\n            int m = l - (l-r)/2;\\n            long mul =(long) potions[m]*spell;\\n            if(mul>=success){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return potions.length-l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int res[] = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            res[i] = bs(potions,spells[i],success);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370155,
                "title": "java-binary-search-explained",
                "content": "# Intuition:\\nA brute force would\\'ve been easy but the constraints don\\'t let us.\\n\\nWe just need the number of elements in `potions` which when multiplied by a particular number (from `spells`) gives the value greater than or equal to `success`.\\n\\nSo if we sort the array `potions`, we can apply a binary search to reach the starting index in `potions` from where onwards all the products yield value >= `success`.\\n\\nThe number of elements that yields product >= `success` is equal to:\\n`length of potions - starting index`\\n\\n---\\n\\n# Code:\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        // Initialise the start index as the length of potions array\\n        // because there might be a case when all the potion strengths\\n        // when multiplied by spell strength gave a less product value than success\\n        // so when we do potions.length - startIdx, it will automatically become 0\\n        // because start index will never get updated to a lesser value (mid)\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            // if product is >= success\\n            if (prod >= success) {\\n                // save this potential start index\\n                startIdx = mid;\\n                // look for a lesser potion strength\\n                hi = mid - 1;\\n            } else {\\n                // product was too less\\n                // go for a greater potion strength\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            if (prod >= success) {\\n                startIdx = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\\n---\\n##### Time complexity: $$O(2.n.logm)$$\\n\\n##### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        // Initialise the start index as the length of potions array\\n        // because there might be a case when all the potion strengths\\n        // when multiplied by spell strength gave a less product value than success\\n        // so when we do potions.length - startIdx, it will automatically become 0\\n        // because start index will never get updated to a lesser value (mid)\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            // if product is >= success\\n            if (prod >= success) {\\n                // save this potential start index\\n                startIdx = mid;\\n                // look for a lesser potion strength\\n                hi = mid - 1;\\n            } else {\\n                // product was too less\\n                // go for a greater potion strength\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            if (prod >= success) {\\n                startIdx = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370136,
                "title": "simple-solution-using-sorting-and-lower-bound-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter looking at the question the intuition that comes to my mind is to sort the potions vector and corresponding to every spell value will find the index of the minimum value in the potions vector whose value becomes equal to or greater than the success value given to us.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find how many potions are there whose multiplication with that particular spell value is greater than or equal to the success value given to us. \\n\\nThe first thing that comes to mind is to sort that potions vector. Now try to find the index of that minimum value in the potions vector whose multiplication with the particular spell value becomes equal to or surpasses the success value given to us. (Ofcourse the values after that particular index will satisfy the criteria because we already sorted the vector in the first place.)\\n\\nWe will use lower_bound function here, which returns the iterator of that particular value if that particular value is present in the vector. And if that particular value is not present in the vector it will give us the iterator of the value which is greater than that value. We\\'ll then subtract this iterator from the base iterator(potions.begin()) to find the index. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe for loop is running for n times where n = spells.size() and the lower bound function takes logN time where N - potions.size().\\n\\nSo the TOTAL TIME COMPLEXITY IS O(nlogN);\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using space to store the ans only. so the space complexity O(n) where n = spells.size()\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n\\n        \\n        for(int i=0; i<spells.size(); i++){\\n            long long value = ceil(success/(spells[i]*1.0));\\n            auto it = lower_bound(potions.begin(),potions.end(),value);\\n\\n            int res = 0;\\n\\n            if(it!=potions.end()){\\n                int ind = it-potions.begin();\\n                res += potions.size()-ind;\\n                ans.push_back(res);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n\\n        \\n        for(int i=0; i<spells.size(); i++){\\n            long long value = ceil(success/(spells[i]*1.0));\\n            auto it = lower_bound(potions.begin(),potions.end(),value);\\n\\n            int res = 0;\\n\\n            if(it!=potions.end()){\\n                int ind = it-potions.begin();\\n                res += potions.size()-ind;\\n                ans.push_back(res);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370096,
                "title": "binary-search-beats100-runtime-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote the solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe binSearch function is a recursive binary search algorithm that searches for a given element (the success variable) in a sorted array (the potions vector) based on a comparison between the product of the middle element of the array and a given integer (the pro variable) and the success variable. If the product is greater than or equal to success, the index variable is updated with the current index of the middle element and the algorithm continues the search on the left half of the array. If the product is less than success, the algorithm continues the search on the right half of the array. The function stops when the element is found or when the search range is empty.\\n\\nThe successfulPairs function takes in two vectors of integers, spells and potions, and a success variable of type long long. It first sorts the potions vector. Then, for each element in the spells vector, it calls the binSearch function to find the number of elements in the potions vector that form a successful pair with the current element in the spells vector, i.e., the number of elements in the potions vector whose product with the current element is greater than or equal to success. This number is then stored in the corresponding index of the spells vector. If no such elements exist, the corresponding index in the spells vector is set to 0. Finally, the spells vector is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int index=-1;\\n    void binSearch(vector<int>& potions,int low,int high,long long success,int pro){\\n        if(low>high){\\n            return;\\n        }\\n        int mid = low+(high-low)/2;\\n        if((long long)potions[mid]*(long long)pro>=success){\\n            index=mid;\\n            binSearch(potions,low,mid-1,success,pro);\\n        }\\n        else{\\n            binSearch(potions,mid+1,high,success,pro);\\n        }\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        ios_base::sync_with_stdio(false);\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            binSearch(potions,0,potions.size()-1,success,spells[i]);\\n            if(index==-1){\\n                spells[i]=0;\\n            }\\n            else{\\n                spells[i]=potions.size()-index;\\n            }\\n            index=-1;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int index=-1;\\n    void binSearch(vector<int>& potions,int low,int high,long long success,int pro){\\n        if(low>high){\\n            return;\\n        }\\n        int mid = low+(high-low)/2;\\n        if((long long)potions[mid]*(long long)pro>=success){\\n            index=mid;\\n            binSearch(potions,low,mid-1,success,pro);\\n        }\\n        else{\\n            binSearch(potions,mid+1,high,success,pro);\\n        }\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        ios_base::sync_with_stdio(false);\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            binSearch(potions,0,potions.size()-1,success,spells[i]);\\n            if(index==-1){\\n                spells[i]=0;\\n            }\\n            else{\\n                spells[i]=potions.size()-index;\\n            }\\n            index=-1;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370026,
                "title": "simple-commented-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array as we will use binary search here...\\n        sort(potions.begin(),potions.end());\\n        \\n        // Declaring the answer array...\\n        vector<int> ans(spells.size(),0);\\n        \\n        for(int i = 0; i < spells.size(); i++){\\n            long long n = spells[i];\\n            \\n            // the required element can be calculated as follows...\\n            long long int req = (success/n) + (success%n != 0);\\n            \\n            // if the required element is found then all the elements greater than \"req\" will satisfy the condition...\\n            int indx = lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            \\n            // taking all elements greater than  and equal to \"req\"...\\n            ans[i] = potions.size() - indx;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array as we will use binary search here...\\n        sort(potions.begin(),potions.end());\\n        \\n        // Declaring the answer array...\\n        vector<int> ans(spells.size(),0);\\n        \\n        for(int i = 0; i < spells.size(); i++){\\n            long long n = spells[i];\\n            \\n            // the required element can be calculated as follows...\\n            long long int req = (success/n) + (success%n != 0);\\n            \\n            // if the required element is found then all the elements greater than \"req\" will satisfy the condition...\\n            int indx = lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            \\n            // taking all elements greater than  and equal to \"req\"...\\n            ans[i] = potions.size() - indx;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3369972,
                "title": "easy-python-solution-using-bisect",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        lst=[]\\n        potions.sort()\\n        ln=len(potions)\\n        for i in spells:\\n            t = bisect_left(potions, success/i)\\n            lst.append(ln-t)\\n        return lst\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        lst=[]\\n        potions.sort()\\n        ln=len(potions)\\n        for i in spells:\\n            t = bisect_left(potions, success/i)\\n            lst.append(ln-t)\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369558,
                "title": "java-solution-for-beginners-with-simple-explanation-and-some-additional-tips",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\nStep 1 : Sort potions \\nStep 2 : get number of pair of successful potions and spells by using binary search. Try finding smallest element in potions which can give you successful pair by subtracting index of samllest element by length of potions.\\nStep 3 : store all the value in ans[] and return ans.\\n\\n\\n# Tips\\n1. In below code you can store ans[] values into spells[] which can help you reduce space complexity from O(n) to O(1). \\n\\n2. Instead of using function couSuc you can do binary search in for loop instead to save some more time. \\n\\n# Advantages\\n1. This approach gives you consistent result and it is favorable for very large array. \\n\\n2. This code can be done in space complexity of O(1) instead of O(n). which makes it space efficient. \\n\\n# Disadvantages\\n1. It is slower for small array. two Poiner method is favorable for smaler array\\n\\n# Complexity\\n- Time complexity:\\n O(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int ans[] = new int[spells.length];\\n        for(int i=0;i<spells.length;i++){\\n            ans[i]=couSuc(spells[i],potions,success);\\n        }\\n        return ans;\\n    }\\n    private int couSuc(int a, int[] arr, long b){\\n        int start=0,end=arr.length;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if((long)arr[mid]*a>=b){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return arr.length-start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int ans[] = new int[spells.length];\\n        for(int i=0;i<spells.length;i++){\\n            ans[i]=couSuc(spells[i],potions,success);\\n        }\\n        return ans;\\n    }\\n    private int couSuc(int a, int[] arr, long b){\\n        int start=0,end=arr.length;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if((long)arr[mid]*a>=b){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return arr.length-start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369472,
                "title": "easy-approach-sorting-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst Sort the potion array and then use the binary search in this array to find the first index whose product with the spells would be equal or grater than than the success.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] ans = new int[spells.length];\\n        for(int i = 0 ; i < spells.length; i++){\\n            int left = 0;\\n            int right = potions.length-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if((long)spells[i]*potions[mid] < success){\\n                    left = mid+1;\\n                }\\n                else{\\n                    right = mid-1;\\n                }\\n            }\\n            ans[i] = potions.length-right-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] ans = new int[spells.length];\\n        for(int i = 0 ; i < spells.length; i++){\\n            int left = 0;\\n            int right = potions.length-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if((long)spells[i]*potions[mid] < success){\\n                    left = mid+1;\\n                }\\n                else{\\n                    right = mid-1;\\n                }\\n            }\\n            ans[i] = potions.length-right-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369463,
                "title": "sorting-binary-search-explaination-easy-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the potions array and then use binary search on potions array to get the that element whose elements of right part of the array will be greater than or equal to success given because if that particular element excceds success then all element from right will be also excceds.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int ans[] = new int[n];\\n        Arrays.sort(potions);\\n        for(int i = 0 ; i < n; i ++){\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = m - 1;\\n            while(low <= high){\\n                int mid = (high - low)/2 + low;\\n                long product = (long)spell * (long)potions[mid];\\n                if(product >= success){\\n                    high = mid - 1;\\n                }else{\\n                    low = mid + 1;\\n                }\\n            }\\n            ans[i] = m - low;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int ans[] = new int[n];\\n        Arrays.sort(potions);\\n        for(int i = 0 ; i < n; i ++){\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = m - 1;\\n            while(low <= high){\\n                int mid = (high - low)/2 + low;\\n                long product = (long)spell * (long)potions[mid];\\n                if(product >= success){\\n                    high = mid - 1;\\n                }else{\\n                    low = mid + 1;\\n                }\\n            }\\n            ans[i] = m - low;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369207,
                "title": "best-simple-approach-java-solution",
                "content": "# Intuition\\nSort the array. Then apply binary search.\\n\\n# Approach\\nSort the array. Then apply binary search.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        //sorting array so that if once we find any value>= success then next values will be automatically >= success\\n        Arrays.sort(potions);\\n        int[] result = new int[spells.length];\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            //we find first value for which multiplication value >= success by binary search for reducing time complexity\\n            //then we store the number of values by calculating length- minimum index for which it satisfies\\n            result[i] = binarySearch(spells,potions,0,potions.length-1,spells[i],success);\\n        }\\n        return result;\\n    }\\n\\n    //binary search function\\n    public  int binarySearch(int[] spells,int potions[], int si, int ei,int val,long target)\\n    {\\n        while(si<=ei)\\n        {\\n            int mid = si + (ei-si)/2;\\n            if((long)val*(long)potions[mid]>=target)\\n            {\\n                if(mid==0)\\n                {\\n                    return potions.length-mid;\\n                }\\n                else if((long)val*(long)potions[mid-1]<target)\\n                {\\n                     return potions.length-mid;\\n                }\\n                else\\n                {\\n                    ei= mid-1;\\n                }\\n            }\\n            else\\n            si= mid+1;\\n        }\\n        return 0;\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        //sorting array so that if once we find any value>= success then next values will be automatically >= success\\n        Arrays.sort(potions);\\n        int[] result = new int[spells.length];\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            //we find first value for which multiplication value >= success by binary search for reducing time complexity\\n            //then we store the number of values by calculating length- minimum index for which it satisfies\\n            result[i] = binarySearch(spells,potions,0,potions.length-1,spells[i],success);\\n        }\\n        return result;\\n    }\\n\\n    //binary search function\\n    public  int binarySearch(int[] spells,int potions[], int si, int ei,int val,long target)\\n    {\\n        while(si<=ei)\\n        {\\n            int mid = si + (ei-si)/2;\\n            if((long)val*(long)potions[mid]>=target)\\n            {\\n                if(mid==0)\\n                {\\n                    return potions.length-mid;\\n                }\\n                else if((long)val*(long)potions[mid-1]<target)\\n                {\\n                     return potions.length-mid;\\n                }\\n                else\\n                {\\n                    ei= mid-1;\\n                }\\n            }\\n            else\\n            si= mid+1;\\n        }\\n        return 0;\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369194,
                "title": "c-solution-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMultiply each element of potions with each element of spells  and count number of number which is greater than or equal to success.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNaive approach is using two for loop  that is in O(N*N).  but it will not run as test case is large.\\nso a better approach is using binary search (logN). Run a for loop for spells and apply binary search in potions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n        int spells_size=spells.size();\\n        int potions_size=potions.size();\\n        vector<int>ans;\\n        for(int i=0;i<spells_size;i++)\\n        {\\n            int start=0;\\n            int end=potions_size-1;\\n            int max_number=0;\\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if((long long)spells[i]*(long long )potions[mid]>=success)\\n                {\\n                    end=mid-1;\\n                    max_number=max(max_number,(potions_size-mid));\\n                }\\n                else if((long long)spells[i]*(long long )potions[mid]<success)\\n                {\\n                    start=mid+1;\\n                }\\n            }\\n            ans.push_back(max_number);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n        int spells_size=spells.size();\\n        int potions_size=potions.size();\\n        vector<int>ans;\\n        for(int i=0;i<spells_size;i++)\\n        {\\n            int start=0;\\n            int end=potions_size-1;\\n            int max_number=0;\\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if((long long)spells[i]*(long long )potions[mid]>=success)\\n                {\\n                    end=mid-1;\\n                    max_number=max(max_number,(potions_size-mid));\\n                }\\n                else if((long long)spells[i]*(long long )potions[mid]<success)\\n                {\\n                    start=mid+1;\\n                }\\n            }\\n            ans.push_back(max_number);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369022,
                "title": "using-binary-search-problem-of-the-day-april-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the minimum element from where the potions element * spell element will be greater than the succes and store the number that is greater than that.\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Naive approach will be using the two for loop which will eventually give the TLE because of contraint.\\n\\nSo the next approach will be the Binary search, firstly we have to sort the potions array for finding the minimumn potions element from where the spells[i]*potions[ele] >= success. Then by intialising an vector we will store the number of element that will be larger than that element i.e. [potions.size()-start]. Using this the Time Complexity will be: O(nlogn);\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        vector<int> ans;\\n\\n        sort(potions.begin(),potions.end());\\n\\n        for(int ele: spells){\\n            // int ele = spells[i];\\n\\n            int start = 0;\\n            int end = potions.size();\\n\\n            while(start<end){\\n                int mid = (start + end) >> 1;\\n\\n                if(static_cast<long long>(ele) * potions[mid] >= success){\\n                    end = mid;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n\\n            ans.push_back(potions.size()-start);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        vector<int> ans;\\n\\n        sort(potions.begin(),potions.end());\\n\\n        for(int ele: spells){\\n            // int ele = spells[i];\\n\\n            int start = 0;\\n            int end = potions.size();\\n\\n            while(start<end){\\n                int mid = (start + end) >> 1;\\n\\n                if(static_cast<long long>(ele) * potions[mid] >= success){\\n                    end = mid;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n\\n            ans.push_back(potions.size()-start);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368961,
                "title": "c-fully-commented-simple-intuitive",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is explained with the code as comments\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        //firt sort the potions array\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;    //store the ans here\\n\\n        int n = potions.size();\\n        //iterate over the each spell\\n        for(int i = 0; i<spells.size(); i++){\\n            //check the minimum value for each spell. We are taking the ceil value. \\n            //Because as the question suggest we have to multiply that spell with potions \\n            //such that the multiplication should be greater than success.\\n            long long minLimit = success/spells[i];\\n            if(success%spells[i])\\n                minLimit++;\\n            //now find the starting position of minLimit and \\n            //add the total values larger than minLimit to your ans\\n            int cnt = lower_bound(potions.begin(), potions.end(), minLimit) - potions.begin();\\n            ans.push_back(n-cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        //firt sort the potions array\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;    //store the ans here\\n\\n        int n = potions.size();\\n        //iterate over the each spell\\n        for(int i = 0; i<spells.size(); i++){\\n            //check the minimum value for each spell. We are taking the ceil value. \\n            //Because as the question suggest we have to multiply that spell with potions \\n            //such that the multiplication should be greater than success.\\n            long long minLimit = success/spells[i];\\n            if(success%spells[i])\\n                minLimit++;\\n            //now find the starting position of minLimit and \\n            //add the total values larger than minLimit to your ans\\n            int cnt = lower_bound(potions.begin(), potions.end(), minLimit) - potions.begin();\\n            ans.push_back(n-cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368926,
                "title": "javascript-java-c-and-python-solution-with-time-complexity-of-o-n-log-m",
                "content": "\\n\\n# Approach\\nSort the potions array in descending order.\\nCreate an empty hash map map to store the results.\\nFor each element in the spells array:\\na. If the element is not in the map, calculate the value of success / spells[i] and find the position of the first element in the sorted potions array that is greater than or equal to this value using a binary search. Store this position in len and add it to the res array. Also store len in the map against spells[i].\\nb. If the element is already in the map, retrieve the value of len from the map and add it to the res array.\\nReturn the res array.\\n\\n# Complexity\\n- Time complexity: O(n log m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JavaCsript\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```\\n# Java\\n```\\npublic class SuccessfulPairs {\\n    public static int[] successfulPairs(int[] spells, int[] potions, int success) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int[] sortedPotions = potions.clone();\\n        Arrays.sort(sortedPotions);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<spells.length; i++){\\n            if(!map.containsKey(spells[i])){\\n                int s = success / spells[i];\\n                int len = search(sortedPotions, s);\\n                res.add(len);\\n                map.put(spells[i], len);\\n            }else{\\n                int len = map.get(spells[i]);\\n                res.add(len);\\n            }\\n        }\\n\\n        int[] result = new int[res.size()];\\n        for(int i=0; i<res.size(); i++){\\n            result[i] = res.get(i);\\n        }\\n        return result;\\n    }\\n\\n    public static int search(int[] potions, int target){\\n        int res = 0;\\n        int left = 0;\\n        int right = potions.length-1;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(potions[mid] < target){\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n                res = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n# C\\n```\\n\\n\\nint search(int* potions, int potionsSize, int target){\\n    int res = 0;\\n    int left = 0;\\n    int right = potionsSize-1;\\n    while(left <= right){\\n        int mid = (left + right) / 2;\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, int success, int* returnSize) {\\n    int* res = malloc(spellsSize * sizeof(int));\\n    int* sortedPotions = malloc(potionsSize * sizeof(int));\\n    memcpy(sortedPotions, potions, potionsSize * sizeof(int));\\n    qsort(sortedPotions, potionsSize, sizeof(int), (const void *)compare);\\n    int* map = calloc(spellsSize, sizeof(int));\\n\\n    for(int i=0; i<spellsSize; i++){\\n        if(map[spells[i]] == 0){\\n            int s = success / spells[i];\\n            int len = search(sortedPotions, potionsSize, s);\\n            res[i] = len;\\n            map[spells[i]] = len;\\n        }else{\\n            int len = map[spells[i]];\\n            res[i] = len;\\n        }\\n    }\\n    \\n    free(map);\\n    free(sortedPotions);\\n    *returnSize = spellsSize;\\n    return res;\\n}\\n\\nint compare(const void * a, const void * b) {\\n   return (*(int*)b - *(int*)a);\\n}\\n```\\n# Python\\n```\\nfrom typing import List\\nimport bisect\\n\\ndef successfulPairs(spells: List[int], potions: List[int], success: int) -> List[int]:\\n    res = []\\n    sortedPotions = sorted(potions, reverse=True)\\n    map = {}\\n\\n    for i in range(len(spells)):\\n        if spells[i] not in map:\\n            s = success / spells[i]\\n            len = bisect.bisect_left(sortedPotions, s)\\n            res.append(len)\\n            map[spells[i]] = len\\n        else:\\n            len = map[spells[i]]\\n            res.append(len)\\n\\n    return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```\n```\\npublic class SuccessfulPairs {\\n    public static int[] successfulPairs(int[] spells, int[] potions, int success) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int[] sortedPotions = potions.clone();\\n        Arrays.sort(sortedPotions);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<spells.length; i++){\\n            if(!map.containsKey(spells[i])){\\n                int s = success / spells[i];\\n                int len = search(sortedPotions, s);\\n                res.add(len);\\n                map.put(spells[i], len);\\n            }else{\\n                int len = map.get(spells[i]);\\n                res.add(len);\\n            }\\n        }\\n\\n        int[] result = new int[res.size()];\\n        for(int i=0; i<res.size(); i++){\\n            result[i] = res.get(i);\\n        }\\n        return result;\\n    }\\n\\n    public static int search(int[] potions, int target){\\n        int res = 0;\\n        int left = 0;\\n        int right = potions.length-1;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(potions[mid] < target){\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n                res = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\n\\n\\nint search(int* potions, int potionsSize, int target){\\n    int res = 0;\\n    int left = 0;\\n    int right = potionsSize-1;\\n    while(left <= right){\\n        int mid = (left + right) / 2;\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, int success, int* returnSize) {\\n    int* res = malloc(spellsSize * sizeof(int));\\n    int* sortedPotions = malloc(potionsSize * sizeof(int));\\n    memcpy(sortedPotions, potions, potionsSize * sizeof(int));\\n    qsort(sortedPotions, potionsSize, sizeof(int), (const void *)compare);\\n    int* map = calloc(spellsSize, sizeof(int));\\n\\n    for(int i=0; i<spellsSize; i++){\\n        if(map[spells[i]] == 0){\\n            int s = success / spells[i];\\n            int len = search(sortedPotions, potionsSize, s);\\n            res[i] = len;\\n            map[spells[i]] = len;\\n        }else{\\n            int len = map[spells[i]];\\n            res[i] = len;\\n        }\\n    }\\n    \\n    free(map);\\n    free(sortedPotions);\\n    *returnSize = spellsSize;\\n    return res;\\n}\\n\\nint compare(const void * a, const void * b) {\\n   return (*(int*)b - *(int*)a);\\n}\\n```\n```\\nfrom typing import List\\nimport bisect\\n\\ndef successfulPairs(spells: List[int], potions: List[int], success: int) -> List[int]:\\n    res = []\\n    sortedPotions = sorted(potions, reverse=True)\\n    map = {}\\n\\n    for i in range(len(spells)):\\n        if spells[i] not in map:\\n            s = success / spells[i]\\n            len = bisect.bisect_left(sortedPotions, s)\\n            res.append(len)\\n            map[spells[i]] = len\\n        else:\\n            len = map[spells[i]]\\n            res.append(len)\\n\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368832,
                "title": "easy-binary-search-using-constant-extra-space-java-solution-beats-99",
                "content": "# Intuition\\nWe can use binary search to find out which element is exactly greater than or equal to product of ```spells[i]``` and ```potions[i]```.\\n1) we just need to take care of long variable as product maybe go beyond int range.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Sort potions array ascending order. So that we can use binary search to find out minimum element that is less than success.\\n2) now we need to check for every element in spells, so let\\'s use a for loop and pass our binary Search.\\n```\\nfor(int i = 0; i < n; i++){\\n    arr[i] = bs(potions, spells[i], success, 0, m - 1);\\n}\\n```\\n3) In binary search if we found ```spells[i] * potions[mid] >= success``` it means there maybe other element in the left side that are maybe greater than or equal to success. So, we use ```end = mid - 1``` else ```start = mid + 1```.\\n4) Now for count all the numbers we just need to subtract ```potion.length - start```.\\n5) We can easily store these count in spells array as we don\\'t need previous values further. So we don\\'t need any extra space\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        for(int i = 0; i < n; i++){\\n            spells[i] = bs(potions, spells[i], success, 0, m - 1);\\n        }\\n        return spells;\\n    }\\n    int bs(int[] nums, long t, long succ, int start, int end){\\n        while(start <= end){\\n            int mid = (start + end) >> 1;\\n            if((long)(t * nums[mid]) >= succ){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return nums.length - start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```spells[i]```\n```potions[i]```\n```\\nfor(int i = 0; i < n; i++){\\n    arr[i] = bs(potions, spells[i], success, 0, m - 1);\\n}\\n```\n```spells[i] * potions[mid] >= success```\n```end = mid - 1```\n```start = mid + 1```\n```potion.length - start```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        for(int i = 0; i < n; i++){\\n            spells[i] = bs(potions, spells[i], success, 0, m - 1);\\n        }\\n        return spells;\\n    }\\n    int bs(int[] nums, long t, long succ, int start, int end){\\n        while(start <= end){\\n            int mid = (start + end) >> 1;\\n            if((long)(t * nums[mid]) >= succ){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return nums.length - start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368719,
                "title": "java-code-simple-explanation",
                "content": "## Brute Force\\n- you can solve this problem using brute force running two loops and get the `counter` and add it into the list or array and return for each element you can do same. \\n\\n## Using Sorting + Binary Search \\n- Idea behind it is simple once we get the min potion which can satisfy the success then all the greater of it will also form it \\n- so the task is to find the minimum potion. Now question is here how we gonna find that min right \\n- So to find that min we need to sort the array of potion why need to sort? - So that we can easily apply binary search and make this algo to `n` to `logn` \\n- once you sorted the array `spells = [5,1,3], potions = [1,2,3,4,5], success = 7` now see for 5 what is the min potion that is required to form success can you see it is 2 at index = 1 \\n- okay now what so can I get it by binary search how? you can do multi of it 1. if it get greater set the right pointer 2. else set the left pointer \\n- Now we get the index of it alright now what is the last or say size of it just substract this index with size and we get how much we can form to make it success. \\n- A case for 0 what is it? right the case for the 0 is simple like if we get the min potion and max postion suppose what will be the max potion the max potion will be the last one after the sorting this elements if we get required min potion greater than max potion.. simple mean we can\\'t make any just add 0 in it. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] S, int[] P, long suc) {\\n        int ans=0;\\n        List<Integer> ls = new ArrayList<>();\\n        Arrays.sort(P);\\n        int n = P.length;\\n        int maxpos = P[P.length-1];\\n        // finding first index whose satisfy the condition \\n        for(int i: S){\\n            long minpos = (long)Math.ceil((1.0*suc)/i);\\n            if(minpos>maxpos){\\n                ls.add(0);\\n            }else{\\n                int get = getI(i,P,suc);\\n                 get = n-get;\\n                ls.add(get);\\n            }\\n        }\\n        // converting to array \\n        int[] res = new int[ls.size()];\\n        for(int i=0; i<ls.size(); i++){\\n            res[i] = ls.get(i);\\n        }\\n        // returning the array\\n        return res; \\n    }\\n    public static int getI(int i, int[] P, long suc){\\n        int l = 0;\\n        int r = P.length-1;\\n        while(l<r){\\n            int mid = l+(r-l)/2;\\n            if((long)i*P[mid]>=suc){\\n                r = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n- you can remove list just simple array of `len(n)` will also work and because of return the Aux space will become $$O(1)$$ constant. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] S, int[] P, long suc) {\\n        int ans=0;\\n        List<Integer> ls = new ArrayList<>();\\n        Arrays.sort(P);\\n        int n = P.length;\\n        int maxpos = P[P.length-1];\\n        // finding first index whose satisfy the condition \\n        for(int i: S){\\n            long minpos = (long)Math.ceil((1.0*suc)/i);\\n            if(minpos>maxpos){\\n                ls.add(0);\\n            }else{\\n                int get = getI(i,P,suc);\\n                 get = n-get;\\n                ls.add(get);\\n            }\\n        }\\n        // converting to array \\n        int[] res = new int[ls.size()];\\n        for(int i=0; i<ls.size(); i++){\\n            res[i] = ls.get(i);\\n        }\\n        // returning the array\\n        return res; \\n    }\\n    public static int getI(int i, int[] P, long suc){\\n        int l = 0;\\n        int r = P.length-1;\\n        while(l<r){\\n            int mid = l+(r-l)/2;\\n            if((long)i*P[mid]>=suc){\\n                r = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368500,
                "title": "short-clean-and-optimal-solution-intuition-and-approach-explained",
                "content": "# Intuition\\nThe intuition behind the solution is to sort the potions array and then use binary search to find the index of the first potion whose strength multiplied by the spell\\'s strength is greater than or equal to the success threshold.\\n\\n# Approach\\nWe sort the potions array in non-decreasing order because we want to use binary search to find the index of the first potion that forms a successful pair with the current spell. Binary search can only be used on a sorted array.\\n\\nTo find the index of the first potion whose strength multiplied by the spell\\'s strength is greater than or equal to the success threshold, we divide the success threshold by the spell\\'s strength and round up to the nearest integer. This gives us the minimum potion strength required to form a successful pair with the spell.\\n\\nWe then use binary search to find the index of the first potion whose strength is greater than or equal to the minimum potion strength. All the potions from that index to the end of the array will form successful pairs with the spell.\\n\\nWe repeat this process for each spell in the spells array and add the number of successful pairs to the result vector.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n * log m), where n is the length of the spells array and m is the length of the potions array. Sorting the potions array takes O(m * log m) time, and the binary search for each spell takes O(log m) time.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> result;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++) {\\n            int index = lower_bound(potions.begin(), potions.end(), (success + spells[i] - 1) / spells[i]) - potions.begin();\\n            result.push_back(potions.size() - index);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> result;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++) {\\n            int index = lower_bound(potions.begin(), potions.end(), (success + spells[i] - 1) / spells[i]) - potions.begin();\\n            result.push_back(potions.size() - index);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368333,
                "title": "sort-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        vector<int> ans;\\n        sort(potions.begin(), potions.end());\\n\\n        for(int i : spells) {\\n            int pos = lower_bound(potions.begin(), potions.end(), ceil((double)success / i)) - potions.begin();\\n            ans.push_back(n - pos);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        vector<int> ans;\\n        sort(potions.begin(), potions.end());\\n\\n        for(int i : spells) {\\n            int pos = lower_bound(potions.begin(), potions.end(), ceil((double)success / i)) - potions.begin();\\n            ans.push_back(n - pos);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368025,
                "title": "day-367-java-c-python-o-1-explained-3-3-ways-one-liner-dry-run",
                "content": "# Please Upvote as it really motivates me\\n# Intuition & Approach\\n##### \\u2022\\tThe problem requires to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to a given value called success.\\n##### \\u2022\\tWe can start by finding the maximum value in the potions array, as this will help us in creating an array to count the number of potions available for each value.\\n##### \\u2022\\tWe create an array called potionsCount of size max+1, where max is the maximum value in the potions array. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount.\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs.\\n##### \\u2022\\tWe create an array called ret of size n, where n is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor each spell, we calculate the minimum value of potion required to form a successful pair. We do this by dividing success by the spell and taking the floor of the result.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret.\\n##### \\u2022\\tWe return the ret array containing the number of successful pairs for each spell.\\n##### \\u2022\\tTo handle the case where the minimum value of potion required is greater than the maximum value in the potions array, we skip the iteration for that spell.\\n##### \\u2022\\tTo handle the case where the product of the spell and the minimum value of potion required is less than success, we increment the minimum value of potion required until the product is greater than or equal to success. We do this only for values less than 100001, as this is the maximum value of success.\\n##### \\u2022\\tOverall, the solution has a time complexity of O(m + n log n), where m is the length of the potions array and n is the length of the spells array. The space complexity of the solution is O(max), where max is the maximum value in the potions array.\\n\\n\\n\\n```PYTHON []\\nclass Solution:\\n def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        n = len(spells)\\n        m = len(potions)\\n\\n        # Find the maximum value in the potions array.\\n        max_val = max(potions)\\n\\n        # Create an array to count the number of potions available for each value.\\n        potions_count = [0] * (max_val + 1)\\n        for x in potions:\\n            potions_count[x] += 1\\n\\n        # Update the potions_count array to store the number of potions available for each value and any greater value.\\n        count = 0\\n        for i in range(max_val, -1, -1):\\n            count += potions_count[i]\\n            potions_count[i] = count\\n\\n        # Create an array to store the number of successful pairs for each spell.\\n        ret = [0] * n\\n\\n        # For each spell, find the minimum value of potion required to form a successful pair and count the number of available potions.\\n        for i in range(n):\\n            target = success // spells[i]\\n            if target > max_val:\\n                continue\\n\\n            # Increment the minimum value of potion required until the product is greater than or equal to success.\\n            while target < 100001 and target * spells[i] < success:\\n                target += 1\\n\\n            if target > max_val:\\n                continue\\n\\n            # Store the number of available potions for the minimum value of potion required or any greater value.\\n            ret[i] = potions_count[target]\\n\\n        return ret\\n```\\n```JAVA []\\nclass Solution{\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        \\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n        \\n        int[] potionsCount = new int[max + 1];\\n        for (int x : potions)\\n            potionsCount[x]++;\\n        \\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n        \\n        \\n        int[] ret = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n            \\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n            \\n            if (target > max)\\n                continue;\\n            \\n            ret[i] = potionsCount[(int)target];\\n        }\\n        \\n        return ret;\\n    }}\\n\\n```\\n\\n```C++ []\\nclass Solution {\\n:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n\\n        vector<int> potionsCount(max + 1, 0);\\n        for (int x : potions)\\n            potionsCount[x]++;\\n\\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n\\n        vector<int> ret(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            long long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n\\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n\\n            if (target > max)\\n                continue;\\n\\n            ret[i] = potionsCount[target];\\n        }\\n\\n        return ret;\\n    }\\n};\\n```\\n# 2nd way \\n\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tThe problem requires us to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to a given value called success.\\n##### \\u2022\\tWe can start by sorting the potions array in increasing order, as this will help us in finding the minimum potion required for a given spell.\\n##### \\u2022\\tFor each spell, we need to find the minimum value of potion whose product with the current spell will be at least success or more. We can calculate this value by dividing success by the spell and taking the ceiling of the result.\\n##### \\u2022\\tIf the minimum potion required is greater than the maximum potion available, then we cannot form any successful pairs for this spell. In this case, we can set the answer for this spell to 0 and move on to the next spell.\\n##### \\u2022\\tIf we have a potion that can be used with the current spell, we need to find the index of the first potion in the sorted array that is greater than or equal to the minimum potion required. We can use binary search to find this index.\\n##### \\u2022\\tOnce we have the index of the first potion that can be used, we can count the number of potions to the right of this index, as all these potions will be greater than or equal to the minimum potion required and can be used to form successful pairs with the current spell.\\n##### \\u2022\\tWe repeat steps 3 to 6 for all spells and return the answer array containing the number of successful pairs for each spell.\\n\\n# Code\\n```java []\\n class Solution {\\n    // Our implementation of lower bound method using binary search.\\n    private int lowerBound(int[] arr, int key) {\\n        int lo = 0;\\n        int hi = arr.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        // Sort the potions array in increasing order.\\n        Arrays.sort(potions);\\n        int[] answer = new int[spells.length];\\n        int m = potions.length;\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long minPotion = (long) Math.ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic    // Our implementation of lower bound method using binary search.\\n    int lowerBound(vector<int>& arr, int key) {\\n        int lo = 0;\\n        int hi = arr.size();\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array in increasing order.\\n        sort(potions.begin(), potions.end());\\n        vector<int> answer(spells.size());\\n        int m = potions.size();\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.size(); i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long long minPotion = ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    # Our of lower bound method using binary search.\\n    def lowerBound(self, arr: List[int], key: int) -> int:\\n        lo = 0\\n        hi = len(arr)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if arr[mid] < key:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        # Sort the potions array in increasing order.\\n        potions.sort()\\n        answer = [0] * len(spells)\\n        m = len(potions)\\n        maxPotion = potions[m - 1]\\n\\n        for i in range(len(spells)):\\n            spell = spells[i]\\n            # Minimum value of potion whose product with current spell will be at least success or more.\\n            minPotion = math.ceil(success / spell)\\n            # Check if we don\\'t have any potion which can be used.\\n            if minPotion > maxPotion:\\n                answer[i] = 0\\n                continue\\n            # We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            index = self.lowerBound(potions, minPotion)\\n            answer[i] = m - index\\n        return answer\\n```\\n\\n# in place sp 0(1)\\n```java []\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int len = spells.length;\\n        int m= potions.length;\\n        int max=potions[m-1];\\n        for(int i=0;i<len;i++){\\n            int spell =spells[i];\\n            long min= (long)Math.ceil((1.0*success)/spell);\\n            if(min>max){\\n                spells[i]=0;\\n                continue;\\n            }\\n            int ind=lowerBound(potions,(int)min);\\n            spells[i]=m-ind;\\n        }return spells;\\n    }\\n    int lowerBound(int A[],int key){\\n        int lo=0,ri=A.length;\\n        while(lo<ri){\\n            int mid=lo+(ri-lo)/2;\\n            if(A[mid]<key){\\n                lo=mid+1;\\n            }else ri=mid;\\n        }return lo;\\n    }\\n```\\n\\n# Complexity\\n##### \\u2022\\tComplexity:\\n##### \\u2022\\tSorting the potions array takes O(m log m) time, where m is the length of the potions array.\\n##### \\u2022\\tFor each spell, we perform a binary search to find the index of the first potion that can be used. This takes O(log m) time.\\n##### \\u2022\\tTherefore, the total time complexity of the solution is O(n log m), where n is the length of the spells array.\\n##### \\u2022\\tSpace Complexity:\\n##### \\u2022\\tWe use a constant amount of extra space for variables and the answer array. Therefore, the space complexity of the solution is O(1).\\n##### \\u2022\\tOverall, the solution has a time complexity of O(n log m) and a space complexity of O(1).\\n\\n# dry run 1\\n##### \\u2022\\tlet\\'s dry run the given input:\\n##### \\u2022\\tspells = [51,3]\\n##### \\u2022\\tpotions = [1,2,3,4,5]\\n##### \\u2022\\tsuccess = 7\\n##### \\u2022\\tWe need to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to 7.\\n##### \\u2022\\tThe maximum value in the potions array is 5.\\n##### \\u2022\\tWe create an array called potionsCount of size 6, where 6 is the maximum value in the potions array plus 1. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount. The updated potionsCount array is:\\n1.\\tpotionsCount = [1, 1, 1, 1, 1, 0]\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs. The updated potionsCount array is:\\n1.\\tpotionsCount = [5, 4, 3, 2, 1, 0]\\n##### \\u2022\\tWe create an array called ret of size 3, where 3 is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor the first spell, 5, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 7 by 5 and taking the floor of the result, which is 1.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 4.\\n##### \\u2022\\tFor the second spell, 1, the minimum value of potion required is 7. Since 7 is greater than the maximum value in the potions array, we skip the iteration for this spell.\\n##### \\u2022\\tFor the third spell, 3, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 7 by 3 and taking the floor of the result, which is 2.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 3.\\n##### \\u2022\\tThe final ret array is [4, 0, 3], which represents the number of successful pairs for each spell.\\n##### \\u2022\\tTherefore, the output for the given input is [4, 0, 3].\\n\\n[MY POST LINK](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3368025/day-367-java-c-python-o-1-explained-3-3-ways-one-liner-dry-run/?orderBy=most_votes)\\n\\n# dry run 2\\n##### \\u2022\\tlet\\'s dry run the given input:\\n##### \\u2022\\tspells = [,1,2]\\n##### \\u2022\\tpot = [8,5,8]\\n##### \\u2022\\tsuccess = 16\\n##### \\u2022\\tWe need to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to 16.\\n##### \\u2022\\tThe maximum value in the potions array is 8.\\n##### \\u2022\\tWe create an array called potionsCount of size 9, where 9 is the maximum value in the potions array plus 1. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount. The updated potionsCount array is:\\n1.\\tpotionsCount = [0, 0, 0, 0, 1, 1, 0, 0, 1]\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs. The updated potionsCount array is:\\n1.\\tpotionsCount = [2, 2, 2, 2, 2, 1, 1, 1, 1]\\n##### \\u2022\\tWe create an array called ret of size 3, where 3 is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor the first spell, 3, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 16 by 3 and taking the floor of the result, which is 5.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 2.\\n##### \\u2022\\tFor the second spell, 1, the minimum value of potion required is 16. Since 16 is greater than the maximum value in the potions array, we skip the iteration for this spell.\\n##### \\u2022\\tFor the third spell, 2, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 16 by 2 and taking the floor of the result, which is 8.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 2.\\n##### \\u2022\\tThe final ret array is [2, 0, 2], which represents the number of successful pairs for each spell.\\n##### \\u2022\\tTherefore, the output for the given input is [2, 0, 2].\\n\\n# 3rd way one liner\\n```python []\\ndef successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\npotions.sort()\\nreturn (len(potions) - bisect_left(potions, success, key=lambda p: p * s) for s in spells)\\n```\\n```java []\\npublic int[] successfulPairs(int spells, int[] potions, int success) {\\n    Arrays.sort(potions);\\n    int[] result = new int[spells.length];\\n    for (int i = 0; i < spells.length; i++) {\\n        int count = potions.length - Arrays.binarySearch(potions, success, (p) -> p * spells[i]);\\n        result[i] = count;\\n    }\\n    return result;\\n}\\n```\\n```c++ []\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, int success) {\\n    sort(potions.begin(), potions.end());\\n    vector<int> result;\\n    for (int s : spells) {\\n        int count = potions.size() - lower_bound(potions.begin(), potions.end(), success, [&](int p) { return p * s; });\\n        result.push_back(count);\\n    }\\n    return result;\\n}\\n```\\n\\n##### \\u2022\\tPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n##### \\u2022\\tThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n##### \\u2022\\tPlease give my solution an upvote! \\uD83D\\uDC4D\\n##### \\u2022\\tIt\\'s a simple way to show your appreciation and\\n##### \\u2022\\tkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/01e9d1d5-3462-485a-9534-d40a3e78a49a_1680408107.3861706.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/1dba63f5-3703-4778-995f-2561c0a08abb_1680408137.1317718.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```PYTHON []\\nclass Solution:\\n def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        n = len(spells)\\n        m = len(potions)\\n\\n        # Find the maximum value in the potions array.\\n        max_val = max(potions)\\n\\n        # Create an array to count the number of potions available for each value.\\n        potions_count = [0] * (max_val + 1)\\n        for x in potions:\\n            potions_count[x] += 1\\n\\n        # Update the potions_count array to store the number of potions available for each value and any greater value.\\n        count = 0\\n        for i in range(max_val, -1, -1):\\n            count += potions_count[i]\\n            potions_count[i] = count\\n\\n        # Create an array to store the number of successful pairs for each spell.\\n        ret = [0] * n\\n\\n        # For each spell, find the minimum value of potion required to form a successful pair and count the number of available potions.\\n        for i in range(n):\\n            target = success // spells[i]\\n            if target > max_val:\\n                continue\\n\\n            # Increment the minimum value of potion required until the product is greater than or equal to success.\\n            while target < 100001 and target * spells[i] < success:\\n                target += 1\\n\\n            if target > max_val:\\n                continue\\n\\n            # Store the number of available potions for the minimum value of potion required or any greater value.\\n            ret[i] = potions_count[target]\\n\\n        return ret\\n```\n```JAVA []\\nclass Solution{\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        \\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n        \\n        int[] potionsCount = new int[max + 1];\\n        for (int x : potions)\\n            potionsCount[x]++;\\n        \\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n        \\n        \\n        int[] ret = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n            \\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n            \\n            if (target > max)\\n                continue;\\n            \\n            ret[i] = potionsCount[(int)target];\\n        }\\n        \\n        return ret;\\n    }}\\n\\n```\n```C++ []\\nclass Solution {\\n:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n\\n        vector<int> potionsCount(max + 1, 0);\\n        for (int x : potions)\\n            potionsCount[x]++;\\n\\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n\\n        vector<int> ret(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            long long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n\\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n\\n            if (target > max)\\n                continue;\\n\\n            ret[i] = potionsCount[target];\\n        }\\n\\n        return ret;\\n    }\\n};\\n```\n```java []\\n class Solution {\\n    // Our implementation of lower bound method using binary search.\\n    private int lowerBound(int[] arr, int key) {\\n        int lo = 0;\\n        int hi = arr.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        // Sort the potions array in increasing order.\\n        Arrays.sort(potions);\\n        int[] answer = new int[spells.length];\\n        int m = potions.length;\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long minPotion = (long) Math.ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic    // Our implementation of lower bound method using binary search.\\n    int lowerBound(vector<int>& arr, int key) {\\n        int lo = 0;\\n        int hi = arr.size();\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array in increasing order.\\n        sort(potions.begin(), potions.end());\\n        vector<int> answer(spells.size());\\n        int m = potions.size();\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.size(); i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long long minPotion = ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    # Our of lower bound method using binary search.\\n    def lowerBound(self, arr: List[int], key: int) -> int:\\n        lo = 0\\n        hi = len(arr)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if arr[mid] < key:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        # Sort the potions array in increasing order.\\n        potions.sort()\\n        answer = [0] * len(spells)\\n        m = len(potions)\\n        maxPotion = potions[m - 1]\\n\\n        for i in range(len(spells)):\\n            spell = spells[i]\\n            # Minimum value of potion whose product with current spell will be at least success or more.\\n            minPotion = math.ceil(success / spell)\\n            # Check if we don\\'t have any potion which can be used.\\n            if minPotion > maxPotion:\\n                answer[i] = 0\\n                continue\\n            # We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            index = self.lowerBound(potions, minPotion)\\n            answer[i] = m - index\\n        return answer\\n```\n```java []\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int len = spells.length;\\n        int m= potions.length;\\n        int max=potions[m-1];\\n        for(int i=0;i<len;i++){\\n            int spell =spells[i];\\n            long min= (long)Math.ceil((1.0*success)/spell);\\n            if(min>max){\\n                spells[i]=0;\\n                continue;\\n            }\\n            int ind=lowerBound(potions,(int)min);\\n            spells[i]=m-ind;\\n        }return spells;\\n    }\\n    int lowerBound(int A[],int key){\\n        int lo=0,ri=A.length;\\n        while(lo<ri){\\n            int mid=lo+(ri-lo)/2;\\n            if(A[mid]<key){\\n                lo=mid+1;\\n            }else ri=mid;\\n        }return lo;\\n    }\\n```\n```python []\\ndef successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\npotions.sort()\\nreturn (len(potions) - bisect_left(potions, success, key=lambda p: p * s) for s in spells)\\n```\n```java []\\npublic int[] successfulPairs(int spells, int[] potions, int success) {\\n    Arrays.sort(potions);\\n    int[] result = new int[spells.length];\\n    for (int i = 0; i < spells.length; i++) {\\n        int count = potions.length - Arrays.binarySearch(potions, success, (p) -> p * spells[i]);\\n        result[i] = count;\\n    }\\n    return result;\\n}\\n```\n```c++ []\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, int success) {\\n    sort(potions.begin(), potions.end());\\n    vector<int> result;\\n    for (int s : spells) {\\n        int count = potions.size() - lower_bound(potions.begin(), potions.end(), success, [&](int p) { return p * s; });\\n        result.push_back(count);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367958,
                "title": "easy-solution-implemented-with-more-one-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int BS(int t, vector<int>& p, long long success){\\n        long long l = 0, r = p.size()-1, mid = -1;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), p = potions.size(), temp;\\n        vector<int> ans(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for(int i=0; i<n; ++i){\\n            temp = BS( spells[i] , potions, success );\\n            ans[i] = (temp == p) ? 0 : p-temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java Code \\n```\\nclass Solution {\\n    public int BS(int t, int[] p, long success){\\n        int l = 0, r = p.length-1, mid;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, p = potions.length, temp;\\n        int[] ans = new int[n];\\n        Arrays.sort(potions);\\n        for(int i=0; i<n; ++i){\\n            temp = BS(spells[i], potions, success);\\n            ans[i] = (temp == p)? 0 : p - temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nconst BS = ( t, p, success)=>{\\n    let l = 0, r = p.length-1, mid;\\n    while(l<=r){\\n        mid = parseInt( (l+r)/2 );\\n        if( t*p[mid] < success ){\\n            l = mid+1;\\n        }else{\\n            r = mid-1;\\n        }\\n    }\\n    return l;\\n}\\n\\nvar successfulPairs = function(spells, potions, success) {\\n    let n = spells.length, p = potions.length, temp;\\n    let ans = new Array(n);\\n    potions.sort((a, b)=> a - b);\\n    for(let i=0; i<n; ++i){\\n        temp = BS( spells[i], potions, success);\\n        console.log(temp);\\n        ans[i] = (temp == p)? 0 : p-temp;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BS(int t, vector<int>& p, long long success){\\n        long long l = 0, r = p.size()-1, mid = -1;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), p = potions.size(), temp;\\n        vector<int> ans(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for(int i=0; i<n; ++i){\\n            temp = BS( spells[i] , potions, success );\\n            ans[i] = (temp == p) ? 0 : p-temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int BS(int t, int[] p, long success){\\n        int l = 0, r = p.length-1, mid;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, p = potions.length, temp;\\n        int[] ans = new int[n];\\n        Arrays.sort(potions);\\n        for(int i=0; i<n; ++i){\\n            temp = BS(spells[i], potions, success);\\n            ans[i] = (temp == p)? 0 : p - temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nconst BS = ( t, p, success)=>{\\n    let l = 0, r = p.length-1, mid;\\n    while(l<=r){\\n        mid = parseInt( (l+r)/2 );\\n        if( t*p[mid] < success ){\\n            l = mid+1;\\n        }else{\\n            r = mid-1;\\n        }\\n    }\\n    return l;\\n}\\n\\nvar successfulPairs = function(spells, potions, success) {\\n    let n = spells.length, p = potions.length, temp;\\n    let ans = new Array(n);\\n    potions.sort((a, b)=> a - b);\\n    for(let i=0; i<n; ++i){\\n        temp = BS( spells[i], potions, success);\\n        console.log(temp);\\n        ans[i] = (temp == p)? 0 : p-temp;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367889,
                "title": "js-binary-search-with-comments",
                "content": "# Intuition\\nTo achieve we don\\'t have to calcualate every spell * potion. If we sort potions then have to find the firs potion which satisfies our conditions. All next potions will satisfy as well.\\n\\n# Approach\\n - Sort potions ascending order\\n - for each spell find that minimum number which would be bigger than success after multiplying on it\\n - find the index of the first potion which is equal or more than that number\\n\\n# Complexity\\n- Time complexity: O(n*log(n) + n*log(m))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    // Sort potions asc order for binary search\\n    potions.sort((a, b) => a - b);\\n    const ans = [];\\n    for (const spell of spells) {\\n        // this number will help us to find the index of the first potion which is equal or more than that number\\n        const rel = success / spell;\\n        let left = 0, right = potions.length - 1;\\n        // standard binary search\\n        while (left <= right) {\\n            const mid = Math.floor((left + right) / 2);\\n            if (potions[mid] < rel) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        // the answer for this number would be the difference between the potions leng and the index\\n        ans.push(potions.length - left);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    // Sort potions asc order for binary search\\n    potions.sort((a, b) => a - b);\\n    const ans = [];\\n    for (const spell of spells) {\\n        // this number will help us to find the index of the first potion which is equal or more than that number\\n        const rel = success / spell;\\n        let left = 0, right = potions.length - 1;\\n        // standard binary search\\n        while (left <= right) {\\n            const mid = Math.floor((left + right) / 2);\\n            if (potions[mid] < rel) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        // the answer for this number would be the difference between the potions leng and the index\\n        ans.push(potions.length - left);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976823,
                "title": "ruby-solution-two-methods",
                "content": "### Method 1:  Brute Force (gives TLE)\\nTime Complexity O(m*n)\\n\\n```\\ndef successful_pairs(spells, potions, success)\\n    spells.map { |spell| potions.count { |potion| spell * potion >= success } }\\nend\\n```\\n\\n### Method 2: Binary Search\\nTime Complexity O(n*log(m))\\n\\nProcess:\\n* Sort `potions` so we can use bsearch \\n* Get 1st index in `potions` where: `potion*spell >= success` \\n\\t* or equivalently: `potion >= success/spell`\\n* Return the number of `potions` greater than the successful one found, or 0 if none were found\\n\\n```\\ndef successful_pairs(spells, potions, success)\\n    potions.sort! \\n    spells.map do |spell_str|\\n        min_pot_str = success.fdiv(spell_str)\\n        idx = potions.bsearch_index { |potion| potion >= min_pot_str }\\n        idx.nil? ? 0 : potions.size - idx\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef successful_pairs(spells, potions, success)\\n    spells.map { |spell| potions.count { |potion| spell * potion >= success } }\\nend\\n```\n```\\ndef successful_pairs(spells, potions, success)\\n    potions.sort! \\n    spells.map do |spell_str|\\n        min_pot_str = success.fdiv(spell_str)\\n        idx = potions.bsearch_index { |potion| potion >= min_pot_str }\\n        idx.nil? ? 0 : potions.size - idx\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2674578,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int n=spells.length,m=potions.length;;\\n        int ans[]=new int[n];\\n       \\n        long prod=0;\\n        for(int i=0;i<n;i++){\\n            int idx=-1,j=0,k=m-1;\\n            while(j<=k){\\n                int mid=(j+k)/2;\\n                if((long)spells[i]*(long)potions[mid]>=success){\\n                    idx=mid;\\n                    k=mid-1;\\n                }\\n                else{\\n                    j=mid+1;\\n                }\\n            }\\n            ans[i]=idx==-1?0:m-idx;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int n=spells.length,m=potions.length;;\\n        int ans[]=new int[n];\\n       \\n        long prod=0;\\n        for(int i=0;i<n;i++){\\n            int idx=-1,j=0,k=m-1;\\n            while(j<=k){\\n                int mid=(j+k)/2;\\n                if((long)spells[i]*(long)potions[mid]>=success){\\n                    idx=mid;\\n                    k=mid-1;\\n                }\\n                else{\\n                    j=mid+1;\\n                }\\n            }\\n            ans[i]=idx==-1?0:m-idx;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153478,
                "title": "c-lower-bound-easy-and-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans(spells.size());\\n        sort(potions.begin(), potions.end());\\n        \\n        for(int i = 0; i<spells.size(); i++){\\n            long long secondnumber = ceil(success/static_cast<double>(spells[i]));\\n            auto it = lower_bound(potions.begin(), potions.end(), secondnumber);\\n            int indexofit = it-potions.begin();\\n            ans[i] = potions.size()-indexofit;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans(spells.size());\\n        sort(potions.begin(), potions.end());\\n        \\n        for(int i = 0; i<spells.size(); i++){\\n            long long secondnumber = ceil(success/static_cast<double>(spells[i]));\\n            auto it = lower_bound(potions.begin(), potions.end(), secondnumber);\\n            int indexofit = it-potions.begin();\\n            ans[i] = potions.size()-indexofit;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143378,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139988,
                "title": "c-solution-explanations-and-examples",
                "content": "**Main idea**\\nBrute force will lead to TLE, thus we may think: use binary search to make `O(N^2)` to `O(NlogN)`.\\nThe core code of a `binary search` is as follows, and for each element in `spells`, we run a binary search on `potions` array, to find the \"edge\\u201C element.\\n**Example**:\\n`spells   `: [5, 1, 3]\\n`potions`: [1, 2, 3, 4, 5]\\n`success`: 7\\n\\nFor `5` in `spells`, the \"edge\" element in `potions` is `2` - index is `1`. When the binary search stops, index `low` will be bigger than index \\'high\\', i.e., `low` = `1`, `high` = `0`. And for `5` in `spells`, the number of potions will be `potions.size() - high - 1 = potions.size() - low` = `4`.\\n\\nFor `3` in `spells`, when binary search finished, index `low` = `2`, `high` = `1`, the number of potions will be `potions.size - high - 1 = potions.size() - low` = `3`\\n* binary search code \"template\"\\n\\t```\\n\\t/* \\n\\t* binary search core code\\n\\t* vec    - array / vector - like \\n\\t* target - represents the target value or target expression\\n\\t*\\n\\t* requirement: vec must be sorted from small to large\\n\\t*/\\n\\n\\n\\t/* search range: [low, high] */\\n\\tint high = vec.size()-1;\\n\\tint low  = 0;\\n\\twhile(low<=high)  /* search range: [low, high] */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if(target == vec[mid])return mid;\\n\\t  else if(target < vec[mid])high = mid-1;\\n\\t  else low  = mid+1;\\n\\t}\\n\\n\\n\\t/* search range: [low, high) */\\n\\tint high = vec.size();\\n\\tint low  = 0;\\n\\twhile (low < high)  /* search range: [0, N) */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if (target == vec[mid])return mid;\\n\\t  else if (target < vec[mid])high = mid;\\n\\t  else low = mid+1;\\n\\t}\\n\\n\\n\\t/* difference */\\n\\t/*\\n\\t* int high = vec.size()   --   int high = vec.size()-1\\n\\t* while(low<high)         --   while(low<=high)\\n\\t* high = mid              --   high = mid-1\\n\\t*/\\n\\t```\\n* Solution\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n\\t\\t\\tint n = spells.size();\\n\\t\\t\\tint m = potions.size();\\n\\n\\t\\t\\tsort(potions.begin(), potions.end());  /* prepare for binary search */\\n\\n\\t\\t\\tvector<int> ans(n, 0);  /* answer */\\n\\n\\t\\t\\tfor(int i = 0; i < n; ++i)  /* loop through all spells */\\n\\t\\t\\t{                 \\n\\t\\t\\t\\t/* perform binary search on potions array */\\n\\t\\t\\t\\tint high = potions.size()-1;  \\n\\t\\t\\t\\tint low  = 0;\\n\\t\\t\\t\\twhile(low <= high)  /* search range: [low, high] */\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint mid = low + (high-low)/2;\\n\\t\\t\\t\\t\\tlong long p = potions[mid], s = spells[i];\\n\\t\\t\\t\\t\\tif(p * s < success)low = mid+1;\\n\\t\\t\\t\\t\\telse high = mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = m - high - 1;  /* m - high - 1 because when quiting binary search, low > high, can be also written as m - low */\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t/* \\n\\t* binary search core code\\n\\t* vec    - array / vector - like \\n\\t* target - represents the target value or target expression\\n\\t*\\n\\t* requirement: vec must be sorted from small to large\\n\\t*/\\n\\n\\n\\t/* search range: [low, high] */\\n\\tint high = vec.size()-1;\\n\\tint low  = 0;\\n\\twhile(low<=high)  /* search range: [low, high] */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if(target == vec[mid])return mid;\\n\\t  else if(target < vec[mid])high = mid-1;\\n\\t  else low  = mid+1;\\n\\t}\\n\\n\\n\\t/* search range: [low, high) */\\n\\tint high = vec.size();\\n\\tint low  = 0;\\n\\twhile (low < high)  /* search range: [0, N) */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if (target == vec[mid])return mid;\\n\\t  else if (target < vec[mid])high = mid;\\n\\t  else low = mid+1;\\n\\t}\\n\\n\\n\\t/* difference */\\n\\t/*\\n\\t* int high = vec.size()   --   int high = vec.size()-1\\n\\t* while(low<high)         --   while(low<=high)\\n\\t* high = mid              --   high = mid-1\\n\\t*/\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n\\t\\t\\tint n = spells.size();\\n\\t\\t\\tint m = potions.size();\\n\\n\\t\\t\\tsort(potions.begin(), potions.end());  /* prepare for binary search */\\n\\n\\t\\t\\tvector<int> ans(n, 0);  /* answer */\\n\\n\\t\\t\\tfor(int i = 0; i < n; ++i)  /* loop through all spells */\\n\\t\\t\\t{                 \\n\\t\\t\\t\\t/* perform binary search on potions array */\\n\\t\\t\\t\\tint high = potions.size()-1;  \\n\\t\\t\\t\\tint low  = 0;\\n\\t\\t\\t\\twhile(low <= high)  /* search range: [low, high] */\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint mid = low + (high-low)/2;\\n\\t\\t\\t\\t\\tlong long p = potions[mid], s = spells[i];\\n\\t\\t\\t\\t\\tif(p * s < success)low = mid+1;\\n\\t\\t\\t\\t\\telse high = mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = m - high - 1;  /* m - high - 1 because when quiting binary search, low > high, can be also written as m - low */\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2139864,
                "title": "python-simple-binary-search-with-explanation-easy-to-undestand",
                "content": "# Full Explained Solution**\\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        res = [0] * len(spells)\\n        N = len(potions)\\n\\t\\t# sorting potions so we can use binary search on it\\n        potions.sort()\\n        \\n        for i,x in enumerate(spells): # i = index, x = value of spells\\n\\t\\t# req is the minimun value of potion strength, for spell to be successful.\\n\\t\\t# math.ceil(7.1) is 8.    As potion contains only integer, we need celling\\n            req = math.ceil(success/x)\\n            index = N  # assuming last index contains value just bigger than\\n            start, end = 0, N-1 \\n\\t\\t\\t\\n\\t\\t\\t# B.Search left most index, where val of potions is >= to celling in sorted potions.\\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n\\t\\t\\t\\t# found an index, but tries to find the index in left of the index\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n\\t\\t\\t# len(potions = N & index = ( \"N\" is nothing found in BS or \"index\" that is found)\\n\\t\\t\\t#  All the values in potions from (index -> N) satisfy \"Success Condition\". append them\\n            res[i] = N - index \\n        return res\\n                \\n```\\nThumbs Up are appericiated\\n\\n\\n# clean code**\\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        N = len(potions)\\n        res = [0] * len(spells)\\n        potions.sort()\\n        \\n        \\n        for i,x in enumerate(spells):\\n            req = math.ceil(success/x)\\n            index = N\\n            start, end = 0, N-1 \\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n            res[i] = N - index \\n        return res\\n                \\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        res = [0] * len(spells)\\n        N = len(potions)\\n\\t\\t# sorting potions so we can use binary search on it\\n        potions.sort()\\n        \\n        for i,x in enumerate(spells): # i = index, x = value of spells\\n\\t\\t# req is the minimun value of potion strength, for spell to be successful.\\n\\t\\t# math.ceil(7.1) is 8.    As potion contains only integer, we need celling\\n            req = math.ceil(success/x)\\n            index = N  # assuming last index contains value just bigger than\\n            start, end = 0, N-1 \\n\\t\\t\\t\\n\\t\\t\\t# B.Search left most index, where val of potions is >= to celling in sorted potions.\\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n\\t\\t\\t\\t# found an index, but tries to find the index in left of the index\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n\\t\\t\\t# len(potions = N & index = ( \"N\" is nothing found in BS or \"index\" that is found)\\n\\t\\t\\t#  All the values in potions from (index -> N) satisfy \"Success Condition\". append them\\n            res[i] = N - index \\n        return res\\n                \\n```\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        N = len(potions)\\n        res = [0] * len(spells)\\n        potions.sort()\\n        \\n        \\n        for i,x in enumerate(spells):\\n            req = math.ceil(success/x)\\n            index = N\\n            start, end = 0, N-1 \\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n            res[i] = N - index \\n        return res\\n                \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2139661,
                "title": "c-using-binary-search",
                "content": "**Approach:** we can sort potions so that if we find a minimal point j in potions where we get success for a spell[i] then j and every greter value than j will give us success, so n-j will be total pairs. And to find this minimal point we will use Binary Search.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        \\n        for (auto& spell : spells) {\\n            int start = 0, end= n-1;\\n            int mid;\\n            while (start <= end) {\\n                mid = (start + end)>>1;\\n                if((long long)spell*potions[mid] >= success)\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            \\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        \\n        for (auto& spell : spells) {\\n            int start = 0, end= n-1;\\n            int mid;\\n            while (start <= end) {\\n                mid = (start + end)>>1;\\n                if((long long)spell*potions[mid] >= success)\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            \\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139468,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n        \\n        sort(begin(potions),end(potions));\\n        \\n        for(int i=0;i<spells.size();i++)\\n        {\\n\\t\\t\\tlong long val = (success + spells[i] - 1)/(spells[i]*1ll);  //take ceil value during division\\n            \\n            int idx = lower_bound(begin(potions),end(potions),val) - begin(potions);\\n            \\n            ans[i] = max((int)potions.size() - idx,0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n        \\n        sort(begin(potions),end(potions));\\n        \\n        for(int i=0;i<spells.size();i++)\\n        {\\n\\t\\t\\tlong long val = (success + spells[i] - 1)/(spells[i]*1ll);  //take ceil value during division\\n            \\n            int idx = lower_bound(begin(potions),end(potions),val) - begin(potions);\\n            \\n            ans[i] = max((int)potions.size() - idx,0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139411,
                "title": "rust-native-binary-search-solution",
                "content": "```rust\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len() as i32;\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let left = potions\\n                .binary_search_by(|&potion| match (potion as i64 * spell as i64).cmp(&success) {\\n                    Ordering::Less => Ordering::Less,\\n                    // treat equal element as greater so that the BS will always terminate with\\n                    // Error() containing the index of element that is greater or equal to one we\\n                    // searched for\\n                    Ordering::Equal => Ordering::Greater,\\n                    Ordering::Greater => Ordering::Greater,\\n                })\\n                .unwrap_err() as i32;\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```\\n\\nBinary search example:\\n\\n```rust\\n#[test]\\nfn test6() {\\n\\t// 4 is missing\\n\\tlet sample = vec![1, 2, 3, 5, 6, 7, 7];\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&4) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 5);\\n\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&3) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 3);\\n}\\n```\\n\\nEquivalent for:\\n\\n```rust\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len();\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let mut left = 0;\\n            let mut right = num_potions;\\n\\n            while left < right {\\n                let mid = left + (right - left) / 2;\\n                if spell as i64 * potions[mid] as i64 >= success {\\n                    right = mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len() as i32;\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let left = potions\\n                .binary_search_by(|&potion| match (potion as i64 * spell as i64).cmp(&success) {\\n                    Ordering::Less => Ordering::Less,\\n                    // treat equal element as greater so that the BS will always terminate with\\n                    // Error() containing the index of element that is greater or equal to one we\\n                    // searched for\\n                    Ordering::Equal => Ordering::Greater,\\n                    Ordering::Greater => Ordering::Greater,\\n                })\\n                .unwrap_err() as i32;\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```\n```rust\\n#[test]\\nfn test6() {\\n\\t// 4 is missing\\n\\tlet sample = vec![1, 2, 3, 5, 6, 7, 7];\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&4) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 5);\\n\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&3) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 3);\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len();\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let mut left = 0;\\n            let mut right = num_potions;\\n\\n            while left < right {\\n                let mid = left + (right - left) / 2;\\n                if spell as i64 * potions[mid] as i64 >= success {\\n                    right = mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139358,
                "title": "successful-pairs-of-spells-and-potions",
                "content": "**Easy approach Binary search --**\\n**Please Upvote**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long ss) {\\n           sort(p.begin() , p.end());\\n          vector<long long> res(s.size());\\n          for(int i = 0 ; i< s.size() ; ++i){\\n              res[i] = (ss/s[i]);\\n          }\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;  i < s.size() ; ++i){\\n            \\n            if(ss <= 1LL*res[i]*s[i] ){\\n                 int ind = lower_bound(p.begin() , p.end() , res[i])  - p.begin() ;   \\n                ans.push_back(p.size() - ind);\\n            }else{\\n                 int ind = upper_bound(p.begin() , p.end() , res[i])  - p.begin() ;\\n                      \\n                ans.push_back(p.size() - ind);\\n            }                   \\n           \\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long ss) {\\n           sort(p.begin() , p.end());\\n          vector<long long> res(s.size());\\n          for(int i = 0 ; i< s.size() ; ++i){\\n              res[i] = (ss/s[i]);\\n          }\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;  i < s.size() ; ++i){\\n            \\n            if(ss <= 1LL*res[i]*s[i] ){\\n                 int ind = lower_bound(p.begin() , p.end() , res[i])  - p.begin() ;   \\n                ans.push_back(p.size() - ind);\\n            }else{\\n                 int ind = upper_bound(p.begin() , p.end() , res[i])  - p.begin() ;\\n                      \\n                ans.push_back(p.size() - ind);\\n            }                   \\n           \\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139299,
                "title": "java-binary-search-sorting",
                "content": "First we sort the potions array, so ,for each spells[i] , we just have to find the smallest index of sorted potions array for which the product is greater than \\'success\\' ... then we can subtract this index from \\'potions\\' array length ... since all the indices after \\'this\\' ( we just found)  index will also provide product greater than success ( since the array is sorted )  \\n\\n\\n\\n\\n```\\n\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] potions1 = new int[potions.length];\\n        for(int i=0;i<potions.length;i++){\\n            potions1[i] = potions[i];\\n        }\\n        Arrays.sort(potions1);\\n        int[] arr = new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++){\\n            int m = -1;\\n            int n = potions1.length;\\n            long count = 0;\\n            while(n>m+1){\\n                int mid = (m+n)/2;\\n                long mul = (long)spells[i]*(long)potions1[mid];\\n                if(mul >= success){\\n                    n = mid;\\n                }else{\\n                    m = mid;\\n                }\\n            }\\n            \\n            arr[i] = Math.max(arr[i] ,potions1.length - n);\\n            \\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] potions1 = new int[potions.length];\\n        for(int i=0;i<potions.length;i++){\\n            potions1[i] = potions[i];\\n        }\\n        Arrays.sort(potions1);\\n        int[] arr = new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++){\\n            int m = -1;\\n            int n = potions1.length;\\n            long count = 0;\\n            while(n>m+1){\\n                int mid = (m+n)/2;\\n                long mul = (long)spells[i]*(long)potions1[mid];\\n                if(mul >= success){\\n                    n = mid;\\n                }else{\\n                    m = mid;\\n                }\\n            }\\n            \\n            arr[i] = Math.max(arr[i] ,potions1.length - n);\\n            \\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139262,
                "title": "easy-to-understand",
                "content": "```\\n public int[] successfulPairs(int[] spells, int[] positions, long suc) {\\n        Arrays.sort(positions);\\n        int []res = new int[spells.length];\\n         for(int i = 0; i<spells.length ;i++){\\n             \\n             int l = 0 , r = positions.length-1;\\n             int num = 0;\\n             while(l<= r){\\n                 \\n                 int m = (r+l)/2;\\n                 long prod = ((long)spells[i]*positions[m]);\\n                 if(prod >=suc){\\n                     r = m-1;\\n                     num = positions.length-m;\\n                 }else{\\n                     l = m+1;\\n                 }\\n             }\\n             res[i] = num;\\n         }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n public int[] successfulPairs(int[] spells, int[] positions, long suc) {\\n        Arrays.sort(positions);\\n        int []res = new int[spells.length];\\n         for(int i = 0; i<spells.length ;i++){\\n             \\n             int l = 0 , r = positions.length-1;\\n             int num = 0;\\n             while(l<= r){\\n                 \\n                 int m = (r+l)/2;\\n                 long prod = ((long)spells[i]*positions[m]);\\n                 if(prod >=suc){\\n                     r = m-1;\\n                     num = positions.length-m;\\n                 }else{\\n                     l = m+1;\\n                 }\\n             }\\n             res[i] = num;\\n         }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139243,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&nums,long long val,long long max_val)\\n    {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int ans=0;\\n        int n=nums.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if((1ll)*nums[mid]*val>=max_val)\\n            {\\n                ans=n-mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& nums, long long success) \\n    {\\n        int n=s.size();\\n        vector<int>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=find(nums,s[i],success);\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&nums,long long val,long long max_val)\\n    {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int ans=0;\\n        int n=nums.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if((1ll)*nums[mid]*val>=max_val)\\n            {\\n                ans=n-mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& nums, long long success) \\n    {\\n        int n=s.size();\\n        vector<int>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=find(nums,s[i],success);\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139108,
                "title": "c-simple-code-with-binary-search-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& p, int i, long long success){\\n        long l = 0, h = p.size()-1;\\n        \\n        while(l <= h){\\n            long mid = l + (h-l)/2;\\n            \\n            if((long long)p[mid]*i >= success){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return p.size() - l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        \\n        for(int i : spells){\\n            int count = solve(potions, i, success);\\n        \\n            if(count < 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& p, int i, long long success){\\n        long l = 0, h = p.size()-1;\\n        \\n        while(l <= h){\\n            long mid = l + (h-l)/2;\\n            \\n            if((long long)p[mid]*i >= success){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return p.size() - l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        \\n        for(int i : spells){\\n            int count = solve(potions, i, success);\\n        \\n            if(count < 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139038,
                "title": "c-o-n-log-m-using-sorting-and-binary-search-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // Sorting and Binary Search\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end()); // Sorting potions so that we can binary search on it\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) { // For every spell, binary search on the number of potions that can be used such that spells[i] * potions[j] >= success\\n            int l = 0, r = m - 1, c = m;\\n            while(l <= r) {\\n                int mid = l + (r - l) / 2;\\n                if((((long long)potions[mid]) * ((long long)spells[i])) >= success) { // If this particular potion satisfies the condition, then we know that all the potions from potions[mid] to potions[m - 1] should satisfy the condition as well. Hence, we now store this index in \\'c\\' and proceed to find if any lower index in potions satisfy the condition or not\\n                    c = mid;\\n                    r = mid - 1;\\n                } else { // Condition is not satisfied. Hence, we proceed to a higher index to see if the condition is satisfied for any index\\n                    l = mid + 1;\\n                }\\n            }\\n            ans.push_back(m - c); // Since all potions from potions[c] to potions[m - 1] satisfy the condition, we have \\'m - c\\' pairs for this particular spell\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Sorting and Binary Search\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end()); // Sorting potions so that we can binary search on it\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) { // For every spell, binary search on the number of potions that can be used such that spells[i] * potions[j] >= success\\n            int l = 0, r = m - 1, c = m;\\n            while(l <= r) {\\n                int mid = l + (r - l) / 2;\\n                if((((long long)potions[mid]) * ((long long)spells[i])) >= success) { // If this particular potion satisfies the condition, then we know that all the potions from potions[mid] to potions[m - 1] should satisfy the condition as well. Hence, we now store this index in \\'c\\' and proceed to find if any lower index in potions satisfy the condition or not\\n                    c = mid;\\n                    r = mid - 1;\\n                } else { // Condition is not satisfied. Hence, we proceed to a higher index to see if the condition is satisfied for any index\\n                    l = mid + 1;\\n                }\\n            }\\n            ans.push_back(m - c); // Since all potions from potions[c] to potions[m - 1] satisfy the condition, we have \\'m - c\\' pairs for this particular spell\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139019,
                "title": "c-easy-to-understand-ultimate-binary-search-solution",
                "content": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long success) {\\n        sort(p.begin(),p.end());\\n        ll n=p.size();\\n\\n        vector<int> ans;\\n        for(int x:spells)\\n        {\\n            ll up=ceil((success)/(1.0*x));\\n            ll idx=lower_bound(p.begin(),p.end(),up)-p.begin();\\n            if(idx==n)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long success) {\\n        sort(p.begin(),p.end());\\n        ll n=p.size();\\n\\n        vector<int> ans;\\n        for(int x:spells)\\n        {\\n            ll up=ceil((success)/(1.0*x));\\n            ll idx=lower_bound(p.begin(),p.end(),up)-p.begin();\\n            if(idx==n)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138991,
                "title": "beginner-friendly-solution-with-explanation",
                "content": "we are sorting the array potion and performing binary search for each element of array spell and finding the highest index such that spell[i]*poition[i] < success. and storing answer in answer vector\\ntime complexity O(nlogm)\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>&potions, long long num1, long long success){\\n        int l = 0, r = potions.size()-1;\\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            long long num2 = potions[mid];\\n            if(num1*num2 < success){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int n = spells.size();\\n        vector<int>ans;\\n        int m = potions.size();\\n        for(int i=0; i<n; i++){\\n            int idx=find(potions, spells[i], success);\\n            if(idx >= m){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(m-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&potions, long long num1, long long success){\\n        int l = 0, r = potions.size()-1;\\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            long long num2 = potions[mid];\\n            if(num1*num2 < success){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int n = spells.size();\\n        vector<int>ans;\\n        int m = potions.size();\\n        for(int i=0; i<n; i++){\\n            int idx=find(potions, spells[i], success);\\n            if(idx >= m){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(m-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138908,
                "title": "binary-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int n=potions.size();\\n        for(int i=0;i<spells.size();i++){\\n            int l=0;\\n            int r=potions.size()-1;\\n            //Binary Search to track from where product is greater than success\\n            while(r>=l){\\n                int mid=l+(r-l)/2;\\n                long long temp = ((long long)(potions[mid])*spells[i]);\\n                if(temp>=success)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n            \\n            ans.push_back(n-l);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int n=potions.size();\\n        for(int i=0;i<spells.size();i++){\\n            int l=0;\\n            int r=potions.size()-1;\\n            //Binary Search to track from where product is greater than success\\n            while(r>=l){\\n                int mid=l+(r-l)/2;\\n                long long temp = ((long long)(potions[mid])*spells[i]);\\n                if(temp>=success)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n            \\n            ans.push_back(n-l);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138904,
                "title": "binary-search-python",
                "content": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n        m = len(potions)\\n        for s in spells:\\n            l, r = 0, m-1\\n            while l<r:\\n                mid = (r-l)//2+l\\n                if s*potions[mid]>=success:\\n                    r=mid\\n                else:\\n                    l =mid+1\\n            if l==m-1 and s*potions[l]<success:\\n                ans.append(0)\\n            else:\\n                ans.append(m-l)\\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n        m = len(potions)\\n        for s in spells:\\n            l, r = 0, m-1\\n            while l<r:\\n                mid = (r-l)//2+l\\n                if s*potions[mid]>=success:\\n                    r=mid\\n                else:\\n                    l =mid+1\\n            if l==m-1 and s*potions[l]<success:\\n                ans.append(0)\\n            else:\\n                ans.append(m-l)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2138871,
                "title": "easy-math-ratio-solution-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(),m = potions.size();\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++){\\n            double ratio = (double)success / spells[i];\\n            long long mnfind = ceil(ratio);\\n            vector<int>::iterator lower = lower_bound(potions.begin(), potions.end(), mnfind);\\n            int x = lower - potions.begin();\\n            ans.push_back(m - x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(),m = potions.size();\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++){\\n            double ratio = (double)success / spells[i];\\n            long long mnfind = ceil(ratio);\\n            vector<int>::iterator lower = lower_bound(potions.begin(), potions.end(), mnfind);\\n            int x = lower - potions.begin();\\n            ans.push_back(m - x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138844,
                "title": "binary-search-o-1-space-comment-s",
                "content": "```\\nclass Solution {\\npublic:\\n    // simple binary search\\n    int bs(vector<int> &num,int &x,long long &success){\\n        int l=0,r=num.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            long long m = (long long)x*num[mid];\\n            if(m>=success){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        // here we will not use any extra space just update answer to spell array\\n        // sort poision array\\n        sort(p.begin(),p.end());\\n        // iterate over spell array\\n        for(int i=0;i<s.size();i++){\\n            // pass poision vector , spell[i] and success to binary search\\n            // subtract it from poision size \\n            // because we will get number of small multiplication\\n            s[i] = p.size()-bs(p,s[i],success);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // simple binary search\\n    int bs(vector<int> &num,int &x,long long &success){\\n        int l=0,r=num.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            long long m = (long long)x*num[mid];\\n            if(m>=success){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        // here we will not use any extra space just update answer to spell array\\n        // sort poision array\\n        sort(p.begin(),p.end());\\n        // iterate over spell array\\n        for(int i=0;i<s.size();i++){\\n            // pass poision vector , spell[i] and success to binary search\\n            // subtract it from poision size \\n            // because we will get number of small multiplication\\n            s[i] = p.size()-bs(p,s[i],success);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895036,
                "title": "easy-c-solution-beats-100-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find the minimum possible element in potions which can be an answer all  the numbers greter to it will be a solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will  sort the potions array. iterate through the spells array to find the answer for each spell. using binary search we find the minimum element which can be an answer. all the numbers inpotions greater than potions[mid] will also be an answer as will make the product bigger than befor. so we consider potions.size() - mid elements as our answer.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long s) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        for(int i = 0; i < spells.size(); i++){\\n            int l = 0;\\n            int r = potions.size()-1;\\n            int temp = 0;\\n            while(l <= r){\\n                int mid = (l + r)/2;\\n                if((long long)spells[i] * (long long)potions[mid] < s){\\n                    l = mid + 1;\\n                }\\n                else{\\n                    temp = potions.size() - mid;\\n                    r = mid - 1;\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long s) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        for(int i = 0; i < spells.size(); i++){\\n            int l = 0;\\n            int r = potions.size()-1;\\n            int temp = 0;\\n            while(l <= r){\\n                int mid = (l + r)/2;\\n                if((long long)spells[i] * (long long)potions[mid] < s){\\n                    l = mid + 1;\\n                }\\n                else{\\n                    temp = potions.size() - mid;\\n                    r = mid - 1;\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796607,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(\\n        self, spells: List[int], potions: List[int], success: int\\n    ) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        return [m - bisect_left(potions, success / v) for v in spells]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(\\n        self, spells: List[int], potions: List[int], success: int\\n    ) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        return [m - bisect_left(potions, success / v) for v in spells]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738801,
                "title": "sorting-mlogm-and-traverse-binary-serach-nlogm-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size();\\n        vector<int>pairs(n,0);\\n        int m=potions.size();\\n        for(int i=0;i<n;i++){\\n            int l=0,r=m-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(1LL*potions[mid]*spells[i]>=success){\\n                     r=mid-1;\\n\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            pairs[i]=m-l;\\n\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size();\\n        vector<int>pairs(n,0);\\n        int m=potions.size();\\n        for(int i=0;i<n;i++){\\n            int l=0,r=m-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(1LL*potions[mid]*spells[i]>=success){\\n                     r=mid-1;\\n\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            pairs[i]=m-l;\\n\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717671,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        vector<int>ans;\\n\\n        sort(potions.begin(),potions.end());\\n        \\n        for(auto& x: spells){\\n            int s=0;\\n            int e = m-1;\\n            while(s<=e){\\n\\n                int mid = s+(e-s)/2;\\n                long long a = ceil((1.0 * success)/x);\\n                if(potions[mid]>=a){\\n                    e=mid-1;\\n                }\\n                else{\\n                    s=mid+1;\\n                }\\n            }\\n\\n            ans.push_back(m-s);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        vector<int>ans;\\n\\n        sort(potions.begin(),potions.end());\\n        \\n        for(auto& x: spells){\\n            int s=0;\\n            int e = m-1;\\n            while(s<=e){\\n\\n                int mid = s+(e-s)/2;\\n                long long a = ceil((1.0 * success)/x);\\n                if(potions[mid]>=a){\\n                    e=mid-1;\\n                }\\n                else{\\n                    s=mid+1;\\n                }\\n            }\\n\\n            ans.push_back(m-s);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626556,
                "title": "c-sorting-lower-bound-easy-solution",
                "content": "# Approach\\n- Sort the portions array in ascending order.\\n- Iterate over the spells array and for each spells[i], find the minimum required potion for it. \\n- Check for the index of potion in potions array using binary search to find the number of potions greter than required.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            long long req = ceil(1.0 * success/spells[i]);\\n            if(req>potions[potions.size()-1]){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            auto idx= lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            long long req = ceil(1.0 * success/spells[i]);\\n            if(req>potions[potions.size()-1]){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            auto idx= lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565630,
                "title": "99-90-beats-c-o-n-m-k-0ms",
                "content": "\\n# Complexity\\n- Time complexity: O(n+m+k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(maxSpell)\\nwhere, maxSpell is the maximum value in the spells vector. The counts vector is created with a size of maxSpell+1, which contributes to the space complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395355,
                "title": "python-simple-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        potions.sort()\\n        n=len(potions)\\n        arr=[]\\n        for i in spells:\\n            if(i*potions[n-1]<success):\\n                arr.append(0)\\n            else:\\n                num=math.ceil(success/i)\\n                start=0\\n                end=n\\n                flag=0\\n                while(start<=end):\\n                    mid=(start+end)//2\\n                    if(mid<n and potions[mid]>=num and potions[mid-1]<num):\\n                        arr.append(n-mid)\\n                        flag=1\\n                        break\\n                    elif(mid<n and potions[mid]<num):\\n                        start=mid+1\\n                    else:\\n                        end=mid-1\\n                if(flag==0):\\n                    arr.append(n-mid)\\n        return arr\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        potions.sort()\\n        n=len(potions)\\n        arr=[]\\n        for i in spells:\\n            if(i*potions[n-1]<success):\\n                arr.append(0)\\n            else:\\n                num=math.ceil(success/i)\\n                start=0\\n                end=n\\n                flag=0\\n                while(start<=end):\\n                    mid=(start+end)//2\\n                    if(mid<n and potions[mid]>=num and potions[mid-1]<num):\\n                        arr.append(n-mid)\\n                        flag=1\\n                        break\\n                    elif(mid<n and potions[mid]<num):\\n                        start=mid+1\\n                    else:\\n                        end=mid-1\\n                if(flag==0):\\n                    arr.append(n-mid)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376030,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Array.Sort(potions);\\n        List<int> res = new List<int>();\\n\\n        foreach (int spell in spells) {\\n            int l = 0;\\n            int r = potions.Length - 1;\\n            int index = potions.Length;\\n\\n            while (l <= r) {\\n                int m = (l + r) / 2;\\n\\n                if (((long)spell * potions[m]) >= success) {\\n                    r = m - 1;\\n                    index = m;\\n                } else {\\n                    l = m + 1;\\n                }\\n            }\\n\\n            res.Add(potions.Length - index);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Array.Sort(potions);\\n        List<int> res = new List<int>();\\n\\n        foreach (int spell in spells) {\\n            int l = 0;\\n            int r = potions.Length - 1;\\n            int index = potions.Length;\\n\\n            while (l <= r) {\\n                int m = (l + r) / 2;\\n\\n                if (((long)spell * potions[m]) >= success) {\\n                    r = m - 1;\\n                    index = m;\\n                } else {\\n                    l = m + 1;\\n                }\\n            }\\n\\n            res.Add(potions.Length - index);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374581,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: simple binary search approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n         Arrays.sort(potions);\\n        int[] count = new int[spells.length];\\n       \\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            count[i] = potions.length - low;\\n        }\\n        return count;\\n    }\\n}\\n```\\n# If this solution helped you, give it an up-vote to help others![download.jfif](https://assets.leetcode.com/users/images/3b0f35ff-0fad-47ea-809c-46a596b73c5f_1680525047.0606627.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n         Arrays.sort(potions);\\n        int[] count = new int[spells.length];\\n       \\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            count[i] = potions.length - low;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373247,
                "title": "c-solution-easy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        \\n        vector<int> pairs(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++){\\n            int beg=0,end=p.size()-1;\\n            while(beg<=end){\\n                int mid = (beg + end) / 2;\\n                if( (long long int)s[i] * (long long int)p[mid] >= success){\\n                    end = mid - 1;\\n                }\\n                else{\\n                    beg = mid + 1;\\n                }\\n            }\\n            pairs[i] = p.size() - beg;\\n        }\\n\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        \\n        vector<int> pairs(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++){\\n            int beg=0,end=p.size()-1;\\n            while(beg<=end){\\n                int mid = (beg + end) / 2;\\n                if( (long long int)s[i] * (long long int)p[mid] >= success){\\n                    end = mid - 1;\\n                }\\n                else{\\n                    beg = mid + 1;\\n                }\\n            }\\n            pairs[i] = p.size() - beg;\\n        }\\n\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372302,
                "title": "python-simple-binary-search-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition and solution behind this problem is derived from 35.Search Insert position (easy). Check out my profile to view the solution of 35, and know why binary search on this , works.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use same code from search insert position, with slight modifications. \\n- Use a hashtable to store first occurence of each index, and later refer it (for duplicates).\\n- Find the insert/position of ceil(success/spells[i])\\n\\n\\n# Complexity\\n- Time complexity: O(m * logn) + O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        #Sort\\n        #Find lower bound for spell[i]\\n        #len-lowerBound =n\\n        #output[i]=n\\n        potions.sort()\\n        final=[]\\n        print(potions)\\n        d={}\\n        for i in range(len(potions)):\\n            try:\\n                d[potions[i]]=d[potions[i]]\\n            except:\\n                d[potions[i]]=i\\n        for i in spells:\\n            j=0\\n            target=ceil(success/i)\\n            #----------------Search insert position solution--------------------\\n            first=0\\n            last=len(potions)-1\\n            mid=(first+last)//2\\n            while(first<=last):\\n                mid=(first+last)//2\\n                if(potions[mid]==target):\\n                    break\\n                elif(potions[mid]<target):\\n                    first=mid+1\\n                else:\\n                    last=mid-1\\n            if(potions[mid]<target):\\n                mid+=1\\n            #---------------------------------------------------------------------\\n            if(mid>=0 and mid<len(potions)):\\n                mid=d[potions[mid]]\\n            n=len(potions)-mid\\n            final.append(n)\\n        return final\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        #Sort\\n        #Find lower bound for spell[i]\\n        #len-lowerBound =n\\n        #output[i]=n\\n        potions.sort()\\n        final=[]\\n        print(potions)\\n        d={}\\n        for i in range(len(potions)):\\n            try:\\n                d[potions[i]]=d[potions[i]]\\n            except:\\n                d[potions[i]]=i\\n        for i in spells:\\n            j=0\\n            target=ceil(success/i)\\n            #----------------Search insert position solution--------------------\\n            first=0\\n            last=len(potions)-1\\n            mid=(first+last)//2\\n            while(first<=last):\\n                mid=(first+last)//2\\n                if(potions[mid]==target):\\n                    break\\n                elif(potions[mid]<target):\\n                    first=mid+1\\n                else:\\n                    last=mid-1\\n            if(potions[mid]<target):\\n                mid+=1\\n            #---------------------------------------------------------------------\\n            if(mid>=0 and mid<len(potions)):\\n                mid=d[potions[mid]]\\n            n=len(potions)-mid\\n            final.append(n)\\n        return final\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372284,
                "title": "two-pointer-approach-leetcode-daily-c-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //T: O(m log m + n log n), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {   \\n        unordered_map<int, pair<int,int>> m; //{index,numpair}\\n        //Now creating a copy of spells vector\\n        vector<int> numspair(spells);\\n        //Now storing the spells and mapping its index onto the map\\n        for(int i=0;i<spells.size();i++){ // O(m)\\n            m[spells[i]]={i,-1};\\n        }\\n        //Now sorting both the vectors\\n        //Considering the length m of spells\\n        sort(spells.begin(),spells.end()); // O(m log m)\\n        //Considering the length n of potions\\n        sort(potions.begin(),potions.end());// O(n log n)\\n        \\n        int potionptr=potions.size()-1;\\n        \\n        // Two Pointer Approach\\n        //Starting spell pointer from left\\n        // And potion pointer from right\\n        for(int i=0;i<spells.size();i++){  //O(m)\\n            int spell=spells[i];\\n            while(potionptr>=0 && (long long) spell*potions[potionptr]>=success){\\n                potionptr--;\\n            }\\n            m[spell]={m[spell].first,potions.size()-1-potionptr};\\n           /*cout<<\"Value:\"<<spell<<\"-->\"<<\"Index:\"<<m[spell].first<<\"-->\"<<\"count:\"<<m[spell].second<<endl;------>this shows how count is being stored for every index and the index\\'s value*/\\n        }\\n        int index=0;\\n        for(int spell: numspair){ // O(m)\\n            numspair[index++]=m[spell].second;\\n        }\\n        return numspair;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //T: O(m log m + n log n), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {   \\n        unordered_map<int, pair<int,int>> m; //{index,numpair}\\n        //Now creating a copy of spells vector\\n        vector<int> numspair(spells);\\n        //Now storing the spells and mapping its index onto the map\\n        for(int i=0;i<spells.size();i++){ // O(m)\\n            m[spells[i]]={i,-1};\\n        }\\n        //Now sorting both the vectors\\n        //Considering the length m of spells\\n        sort(spells.begin(),spells.end()); // O(m log m)\\n        //Considering the length n of potions\\n        sort(potions.begin(),potions.end());// O(n log n)\\n        \\n        int potionptr=potions.size()-1;\\n        \\n        // Two Pointer Approach\\n        //Starting spell pointer from left\\n        // And potion pointer from right\\n        for(int i=0;i<spells.size();i++){  //O(m)\\n            int spell=spells[i];\\n            while(potionptr>=0 && (long long) spell*potions[potionptr]>=success){\\n                potionptr--;\\n            }\\n            m[spell]={m[spell].first,potions.size()-1-potionptr};\\n           /*cout<<\"Value:\"<<spell<<\"-->\"<<\"Index:\"<<m[spell].first<<\"-->\"<<\"count:\"<<m[spell].second<<endl;------>this shows how count is being stored for every index and the index\\'s value*/\\n        }\\n        int index=0;\\n        for(int spell: numspair){ // O(m)\\n            numspair[index++]=m[spell].second;\\n        }\\n        return numspair;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3372205,
                "title": "2300-successful-pairs-of-spells-and-potions",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& port, long long success) {\\n        \\nvector<int>res;\\n    sort(port.begin(),port.end());\\n\\n      for(auto spell:spells)\\n      {\\n\\n             long port_need = (success + spell -1 )/ spell;\\n\\n             auto it = lower_bound(port.begin(),port.end(),port_need); // store a number \\n             res.push_back(port.end()-it);\\n\\n      }\\n      return res;\\n\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& port, long long success) {\\n        \\nvector<int>res;\\n    sort(port.begin(),port.end());\\n\\n      for(auto spell:spells)\\n      {\\n\\n             long port_need = (success + spell -1 )/ spell;\\n\\n             auto it = lower_bound(port.begin(),port.end(),port_need); // store a number \\n             res.push_back(port.end()-it);\\n\\n      }\\n      return res;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372000,
                "title": "easiest-4-line-solution-c-95-memory-o-n-log-m",
                "content": "# Intuition\\nThe minimum potion strength required for each spell to succeed can be calculated as ceil((double)success/spells[i])\\n\\n# Approach\\nFirst, we sort the potions array in ascending order. Now we can apply binary search to search the index of the minimum potion strength required for each spell. This operation will take O(log(m)) time. Once we have the index, we can find the total number of potions that can succeed with that spell, since all the potions after the index can also be used with that spell to succeed (the strengths of potion after that index will always be greater than or equal to the potion strength at that index since potions array is sorted). Finally, we store the answer in spell array itself to save memory.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(m))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort (potions.begin(),potions.end());\\n    for (int i=0;i<spells.size();i++){\\n        spells[i]= potions.size() - (lower_bound(potions.begin(),potions.end(),ceil((double)success/spells[i]))-potions.begin());\\n    }\\n    return spells;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort (potions.begin(),potions.end());\\n    for (int i=0;i<spells.size();i++){\\n        spells[i]= potions.size() - (lower_bound(potions.begin(),potions.end(),ceil((double)success/spells[i]))-potions.begin());\\n    }\\n    return spells;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371999,
                "title": "simple-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort the portion array since we only need a count from them \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long s) {\\n\\n\\n        vector<int>ans(spells.size(),0);\\n        int n=spells.size();\\n        int m=p.size();\\n        sort(p.begin(),p.end());\\n        for(int i=0;i<spells.size();i++){\\n        int low=0;\\n        int high=p.size()-1;\\n\\n            long long  cs=spells[i];\\n            int cr=-1;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(cs*p[mid]<s){\\n                    low=mid+1;\\n                }else if(cs*p[mid]>=s){\\n                    high=mid-1;\\n                    cr=mid;\\n                }\\n            }\\n            if(cr!=-1){\\n                ans[i]=p.size()-cr;\\n            }\\n            \\n\\n\\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long s) {\\n\\n\\n        vector<int>ans(spells.size(),0);\\n        int n=spells.size();\\n        int m=p.size();\\n        sort(p.begin(),p.end());\\n        for(int i=0;i<spells.size();i++){\\n        int low=0;\\n        int high=p.size()-1;\\n\\n            long long  cs=spells[i];\\n            int cr=-1;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(cs*p[mid]<s){\\n                    low=mid+1;\\n                }else if(cs*p[mid]>=s){\\n                    high=mid-1;\\n                    cr=mid;\\n                }\\n            }\\n            if(cr!=-1){\\n                ans[i]=p.size()-cr;\\n            }\\n            \\n\\n\\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371980,
                "title": "java-self-explanatory",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] arr = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            arr[i] = getPairs(spells[i],potions,success);\\n        }\\n        return arr;\\n    }\\n\\n    private int getPairs(int x, int[] potions,long success){\\n        int low = 0;\\n        int high = potions.length-1;\\n        while(low <= high){\\n            int mid = low +(high-low)/2;\\n            if((long)potions[mid]*x >= success){\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n\\n        return potions.length - low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] arr = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            arr[i] = getPairs(spells[i],potions,success);\\n        }\\n        return arr;\\n    }\\n\\n    private int getPairs(int x, int[] potions,long success){\\n        int low = 0;\\n        int high = potions.length-1;\\n        while(low <= high){\\n            int mid = low +(high-low)/2;\\n            if((long)potions[mid]*x >= success){\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n\\n        return potions.length - low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371966,
                "title": "binary-search-c-very-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n         sort(potions.begin(),potions.end());\\n       for(int i=0;i<spells.size();i++){\\n           int spell=spells[i];\\n           int low=0;\\n           int high=potions.size()-1;\\n           while(low<=high){\\n               int mid=low+(high-low)/2;\\n               long long pair_val=((ll)spell * (ll)potions[mid]);\\n               if(pair_val>=success){\\n                   high=mid-1;\\n               }\\n               else{\\n                     low=mid+1;\\n               }\\n           }\\n           ans.push_back(potions.size()-low);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n         sort(potions.begin(),potions.end());\\n       for(int i=0;i<spells.size();i++){\\n           int spell=spells[i];\\n           int low=0;\\n           int high=potions.size()-1;\\n           while(low<=high){\\n               int mid=low+(high-low)/2;\\n               long long pair_val=((ll)spell * (ll)potions[mid]);\\n               if(pair_val>=success){\\n                   high=mid-1;\\n               }\\n               else{\\n                     low=mid+1;\\n               }\\n           }\\n           ans.push_back(potions.size()-low);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371958,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogm)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int>pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n           int low = 0;\\n           int high = m-1;\\n           int cnt =0;\\n           while(low<=high){\\n               long long mid = low+(high-low)/2;\\n               if((long)spells[i]*(long)potions[mid]>=success){\\n                    cnt += high-mid+1;\\n                    high = mid-1;\\n               }\\n               else if((long)spells[i]*(long)potions[mid]<success){\\n                   low = mid+1;\\n               }\\n           }\\n          pairs.push_back(cnt);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int>pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n           int low = 0;\\n           int high = m-1;\\n           int cnt =0;\\n           while(low<=high){\\n               long long mid = low+(high-low)/2;\\n               if((long)spells[i]*(long)potions[mid]>=success){\\n                    cnt += high-mid+1;\\n                    high = mid-1;\\n               }\\n               else if((long)spells[i]*(long)potions[mid]<success){\\n                   low = mid+1;\\n               }\\n           }\\n          pairs.push_back(cnt);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371863,
                "title": "simple-java-solution-with-detailed-steps-easy-to-understand-intuitive-solution-binary-search",
                "content": "# Intuition\\nFind the potion indices which on multiplication with spell result  atleast success.\\n\\n# Approach\\n**Brute Force Approach:** Iterate over spellls array and compare with each potion value if multiplication is more than or equals to success.\\n***Time complexity:*** As we are multiplying each potion with each spell, TC for this approach will be O(M*N).\\n***Space complexity:***: We are not using any additional space as part of our algorightm. We are creating an result array which is required as part of ans so we will consider it into our space complexity as its required for the answer.\\n\\n---\\n\\n**Optimized approach:** Let\\'s sort the potion array in ascending order. Now if somehow we can find the starting index which on multiplication with spell results into success then all the indices on it\\'s right will also results in success (potion array is sorted in ascending order). So we don\\'t need to check for each and every potion indices for success, we only need to find the starting index.\\nAs we have sorted the potion array, finding the starting index can be done using binary search. This will reduce our time complexity to find the starting index from O(N) to O(logN). \\nIf we have a valid starting index which means there are some potion values which will result into success so all the indices on it\\'s right will also results in success (So simply store the potion length - starting index as count for that spell). If didn\\'t find a valid potion which results into success then simply store 0 for that spell.\\n   \\n***Time complexity:***  Sorting the potion array will take O(N*logN). Iterating over spell array will result in O(M) TC and finding the starting index using binary search will take O(logN) so resultant Time Complexity will be O(Max(M, N) * logN)).\\n***Space complexity:***: We are not using any additional space as part of our algorightm. We are creating an result array which is required as part of ans so we will consider it into our space complexity as its required for the answer.\\n\\n# Kindly upvote if you liked the solution \\n![upvote.png](https://assets.leetcode.com/users/images/fc02b3ed-fbd5-4f2a-8065-67160bf2fe0e_1680460909.0296853.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        //Sort the array so that we can apply binary search on the array\\n        Arrays.sort(potions);\\n        int pLen = potions.length, startIndex = -1;\\n        int[] ans = new int[spells.length];\\n       \\n        //Iterate over spells and find starting potion index for each spell which will give success\\n        for(int s = 0; s < spells.length; s++){\\n            \\n            //using binary search find the starting index which results into success \\n            startIndex = getStartSuccessIndex(potions, spells[s], success);\\n\\n            //If a valid index is found then all the indices to it\\'s right will also result in success\\n            if(startIndex >= 0){\\n                ans[s] = pLen - startIndex;\\n            }else{\\n                //If no valid index is found then 0 results will be formed\\n                ans[s] = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getStartSuccessIndex(int[] potions, long spell, long success){\\n        int ans = -1, p = potions.length;\\n        int left = 0, right = p-1, mid = (right+left)/2;\\n        while(left <= right){\\n            mid = (left+right)/2;\\n            //If product of mid potion value with spll is >= success then this mighte be our ans so store it into ans variable and look for smaller index on the left side. \\n            if(potions[mid] * spell >= success){\\n                ans = mid;\\n                right = mid -1;\\n            }else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        //Sort the array so that we can apply binary search on the array\\n        Arrays.sort(potions);\\n        int pLen = potions.length, startIndex = -1;\\n        int[] ans = new int[spells.length];\\n       \\n        //Iterate over spells and find starting potion index for each spell which will give success\\n        for(int s = 0; s < spells.length; s++){\\n            \\n            //using binary search find the starting index which results into success \\n            startIndex = getStartSuccessIndex(potions, spells[s], success);\\n\\n            //If a valid index is found then all the indices to it\\'s right will also result in success\\n            if(startIndex >= 0){\\n                ans[s] = pLen - startIndex;\\n            }else{\\n                //If no valid index is found then 0 results will be formed\\n                ans[s] = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getStartSuccessIndex(int[] potions, long spell, long success){\\n        int ans = -1, p = potions.length;\\n        int left = 0, right = p-1, mid = (right+left)/2;\\n        while(left <= right){\\n            mid = (left+right)/2;\\n            //If product of mid potion value with spll is >= success then this mighte be our ans so store it into ans variable and look for smaller index on the left side. \\n            if(potions[mid] * spell >= success){\\n                ans = mid;\\n                right = mid -1;\\n            }else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371825,
                "title": "binary-search-approach",
                "content": "# Intuition\\nTo find index of success value in sorted list if it is present in list else to find the insertion index of success value in sorted list.\\n\\n# Approach\\n\\nBinary Search\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        s = []\\n        for i in spells:\\n            left = 0\\n            right = len(potions)\\n            while left < right:\\n                mid = (left + right) // 2\\n                if i * potions[mid] >= success:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            s.append(len(potions) - left)\\n\\n        return s\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        s = []\\n        for i in spells:\\n            left = 0\\n            right = len(potions)\\n            while left < right:\\n                mid = (left + right) // 2\\n                if i * potions[mid] >= success:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            s.append(len(potions) - left)\\n\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371813,
                "title": "c-soln-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n  n -> size of spells array and\\n  m -> size of potions array\\n\\n- Time complexity: O(nlog(m))\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m=potions.size(), n=spells.size();\\n        vector<int> ans;\\n\\n        for(int i=0; i<n; i++){\\n            int left=0, right=m-1;\\n            while(left<=right){\\n                int mid=(left+right)/2;\\n                long long temp = (long long)potions[mid]*spells[i];\\n                if(temp<success)\\n                  left=mid+1;\\n                else right=mid-1;\\n            }\\n            ans.push_back(m-left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m=potions.size(), n=spells.size();\\n        vector<int> ans;\\n\\n        for(int i=0; i<n; i++){\\n            int left=0, right=m-1;\\n            while(left<=right){\\n                int mid=(left+right)/2;\\n                long long temp = (long long)potions[mid]*spells[i];\\n                if(temp<success)\\n                  left=mid+1;\\n                else right=mid-1;\\n            }\\n            ans.push_back(m-left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371808,
                "title": "simple-binary-search-sorting-c",
                "content": "Sort both the arrays. Now for each spell find the min index in 2nd array such that it\\'s product with currect element of 1st array is greater than success value . Now all the elements after this index will surely have product greater than required success value.\\n\\nTime Complexity -> O(nlogn)\\n\\n```\\ntypedef long long int ll ;\\nstruct data {\\n    int index, count, a ;\\n};\\nbool comp(struct data A, struct data B){\\n    return A.a < B.a;\\n}\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        vector<struct data>v(n);\\n        for(int i = 0 ; i< n; i++){\\n            v[i].a = spells[i];\\n            v[i].index = i;\\n            v[i].count = 0 ;\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        sort(potions.begin(), potions.end());\\n        for(int i = 0 ; i < n; i++){\\n            ll reqd = success/v[i].a ;\\n            if(success%v[i].a != 0)\\n                reqd ++ ;\\n            int ind = lower_bound(potions.begin(), potions.end(), reqd) - potions.begin();\\n            if(ind == m)\\n                v[i].count = 0 ;\\n            else\\n                v[i].count = m-ind;\\n        }\\n        vector<int>ans(n) ;\\n        for(auto it: v)\\n            ans[it.index] = it.count;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long int ll ;\\nstruct data {\\n    int index, count, a ;\\n};\\nbool comp(struct data A, struct data B){\\n    return A.a < B.a;\\n}\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        vector<struct data>v(n);\\n        for(int i = 0 ; i< n; i++){\\n            v[i].a = spells[i];\\n            v[i].index = i;\\n            v[i].count = 0 ;\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        sort(potions.begin(), potions.end());\\n        for(int i = 0 ; i < n; i++){\\n            ll reqd = success/v[i].a ;\\n            if(success%v[i].a != 0)\\n                reqd ++ ;\\n            int ind = lower_bound(potions.begin(), potions.end(), reqd) - potions.begin();\\n            if(ind == m)\\n                v[i].count = 0 ;\\n            else\\n                v[i].count = m-ind;\\n        }\\n        vector<int>ans(n) ;\\n        for(auto it: v)\\n            ans[it.index] = it.count;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371786,
                "title": "eeeee",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n                if(product<success)\\n                    left=mid+1;\\n                else\\n                    right=mid;\\n            }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n                if(product<success)\\n                    left=mid+1;\\n                else\\n                    right=mid;\\n            }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371778,
                "title": "c-very-easy-solution-beginner-friendly-easy-to-understand-loaded-with-comments",
                "content": "# Intuition\\nLet us commence with the brute-force approach and progressively optimize it. Initially, we can write a brute-force algorithm using two loops: one for spells and another for potions. During each iteration, we will verify whether \"spells\\\\[i]\\\\*potions\\\\[i]>=success\". However, since the maximum size of m and n is 10e5 and this approach is quadratic, it will result in \"Time Limit Exceeded(TLE)\". This is due to the fact that in a second, the maximum operation which we can perform is approximately 1e8-1e9, whereas here it can be 1e10 at max.\\n\\nOptimization No:-1: Firstly, we will sort the potions vector. Since, as per the condition, we have to find the count satisfying \"spells\\\\[i]*potions\\\\[i]>=success\", using simple mathematics, we can convert it to \"potions\\\\[i]>=success/spells\\\\[i]\". However, there is a catch - in C++, if we divide without typecasting, it will round off to the nearest integer, but we want the answer to be calculated in floating-point, and then we will take the ceil of the number. Let me illustrate the problem we face without using typecasting and taking ceil of the result. Suppose success=16, spells\\\\[i]=3, then potions\\\\[i]>=16/3 in order to satisfy \"spells\\\\[i]*potions\\\\[i]>=success\". Therefore, 16/3 will be 5, and when we multiply 5 with 3, it comes out to be 15<16. So, to avoid this, if we typecast division, then (1.0*16)/3 would be 5.33..., and if we take ceil of that, we will end up getting 6, and that will satisfy our condition as 3*6=18>=16. Using the lower\\\\_bound function, we can calculate the index of the number >=potions\\\\[i] we have calculated just aforehead. So, the answer for that spells\\\\[i]=n-index. Here, n is the size of the potions vector.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n- Brute Force: O(m*n);\\n- optimised Code:O(nlogn+mlogm);\\n-  Space complexity:\\n   - O(n)\\n\\n# Code\\n```\\n// BRUTE FORCE APPROACH and it will give TLE \\n//AS (N*M<=10e10 operations and that can\\'t pass within a second)\\n\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n      vector<int>v;\\n      for(int i=0;i<spells.size();i++){\\n          int count=0;\\n          int x =spells[i];\\n          for(int j=0;j<potions.size();j++){\\n              long long result= (1LL*x*potions[j]);\\n              if(result>=success){\\n                count++;\\n              } \\n          }\\n      v.push_back(count);\\n      }\\n      return v;\\n    }\\n};\\n\\n// Optimised no :1 Here we are using STL\\n\\n// Let\\'s write the optimised version\\n// Still here we are using the stl function to find lower_bound which internally implements binary search but interviewer in some case might not allow to use STL so in that case we will have to write lower_bound using bs internally by ourself.\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n // Optimised Code :2 Here We are writing lower_bound by ourself\\n\\n// Let\\'s write the most optimised version\\nclass Solution {\\npublic:\\nint apnaLowerBound(int l , int r , int target,vector<int>& potions ){\\n    int ans=0;\\n    int mid=0;\\n    while(l<=r){\\n        mid=l+(r-l)/2;\\n        if(potions[mid]>=target){\\n            ans=mid;\\n            r=mid-1;\\n        }\\n        else{\\n            l=mid+1;\\n        }\\n    }\\n    return ans ;\\n}\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        // int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        // We will calculate index now using our own function \\n        int index=apnaLowerBound(0,n-1,minPotion,potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```\\nCAN I GET AN UPVOTE PLS , IT TOOK LOTS OF EFFORT TO PEN THIS DOWN \\uD83D\\uDE07\\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// BRUTE FORCE APPROACH and it will give TLE \\n//AS (N*M<=10e10 operations and that can\\'t pass within a second)\\n\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n      vector<int>v;\\n      for(int i=0;i<spells.size();i++){\\n          int count=0;\\n          int x =spells[i];\\n          for(int j=0;j<potions.size();j++){\\n              long long result= (1LL*x*potions[j]);\\n              if(result>=success){\\n                count++;\\n              } \\n          }\\n      v.push_back(count);\\n      }\\n      return v;\\n    }\\n};\\n\\n// Optimised no :1 Here we are using STL\\n\\n// Let\\'s write the optimised version\\n// Still here we are using the stl function to find lower_bound which internally implements binary search but interviewer in some case might not allow to use STL so in that case we will have to write lower_bound using bs internally by ourself.\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n // Optimised Code :2 Here We are writing lower_bound by ourself\\n\\n// Let\\'s write the most optimised version\\nclass Solution {\\npublic:\\nint apnaLowerBound(int l , int r , int target,vector<int>& potions ){\\n    int ans=0;\\n    int mid=0;\\n    while(l<=r){\\n        mid=l+(r-l)/2;\\n        if(potions[mid]>=target){\\n            ans=mid;\\n            r=mid-1;\\n        }\\n        else{\\n            l=mid+1;\\n        }\\n    }\\n    return ans ;\\n}\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        // int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        // We will calculate index now using our own function \\n        int index=apnaLowerBound(0,n-1,minPotion,potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371574,
                "title": "c-binary-search-easiest-beginner-friendly-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo reduce the time complexity, you could sort the \"potions\" vector and use binary search to find the number of successful pairs for each spell. This would reduce the time complexity to O(n log n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> pass;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++)\\n        {\\n            int lo = 0, hi = potions.size() - 1;\\n            while (lo <= hi)\\n            {\\n                int mid = lo + (hi - lo) / 2;\\n                if ((long long)spells[i] * potions[mid] >= success)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid + 1;\\n            }\\n            pass.push_back(potions.size() - lo);\\n        }\\n        return pass;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> pass;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++)\\n        {\\n            int lo = 0, hi = potions.size() - 1;\\n            while (lo <= hi)\\n            {\\n                int mid = lo + (hi - lo) / 2;\\n                if ((long long)spells[i] * potions[mid] >= success)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid + 1;\\n            }\\n            pass.push_back(potions.size() - lo);\\n        }\\n        return pass;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371475,
                "title": "simple-python-code-binary-search",
                "content": "# Approach: `Binary Search`\\n\\n# Complexity\\n- Time complexity: `O(N LogN)`\\n\\n- Space complexity: ` O(N) `\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        x = []\\n        for i in spells:\\n            l,r,ans = 0,len(potions)-1,0\\n            while l<=r:\\n                m = (l+r)//2\\n                if (potions[m]*i)>=success:\\n                    ans+=(r-m+1)\\n                    r=m-1\\n                else: l=m+1\\n            x.append(ans);\\n        return x\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        x = []\\n        for i in spells:\\n            l,r,ans = 0,len(potions)-1,0\\n            while l<=r:\\n                m = (l+r)//2\\n                if (potions[m]*i)>=success:\\n                    ans+=(r-m+1)\\n                    r=m-1\\n                else: l=m+1\\n            x.append(ans);\\n        return x\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371469,
                "title": "2-approach-easy-c-solution-brute-force-and-optimized-approach-binary-search",
                "content": "# Approach 1: Brute Force Approach\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(1)\\n\\nwhere n == spells.length and m == potions.length\\n\\n# Code\\n```\\n// Brute Force Approach\\n// Time complexity -> O(n*m) and Space -> O(1)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int pairCount=0;\\n            for(int j=0;j<potions.size();j++)\\n            {\\n                long long check=(long long)(potions[j])*(long long)(spells[i]);\\n                if(check>=success)\\n                {\\n                    pairCount++;\\n                }\\n            }\\n            ans.push_back(pairCount);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nAbove code \\u274C give time limit Exceeded due to high complexity O(n*m)\\n\\n# Approach 2: Optimized Approach\\n\\n# Complexity\\n- Time complexity: O((n+m)log(m))\\n\\n- Space complexity: O(logm)\\n\\nwhere n == spells.length and m == potions.length\\n\\n# Code\\n```\\n// Optimized Approach [Binary Search]\\n// Time complexity -> O((n+m)log(m)) and Space -> O(logm)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=lower_bound(potions.begin(),potions.end(),minPotion)-potions.begin();\\n\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**OR**\\n\\n```\\nclass Solution {\\nprivate:\\n    int LowerBound(int l, int r,vector<int> &potions,int minPotion)\\n    {\\n        int possibleIndex=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(potions[mid]>=minPotion)\\n            {\\n                possibleIndex=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return possibleIndex;\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end()); // O(mlogm)\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++) // O(n*logm)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=LowerBound(0,m-1,potions,minPotion);\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Explanation**\\n\\n![WhatsApp Image 2023-04-02 at 22.15.27.jpg](https://assets.leetcode.com/users/images/067ebdc3-350c-4847-866d-6bf25d838ec1_1680454005.8449535.jpeg)\\n\\n![WhatsApp Image 2023-04-02 at 22.15.28.jpg](https://assets.leetcode.com/users/images/5b991ac6-dca3-40e1-b392-ae6ea9056f73_1680454019.0853117.jpeg)\\n\\n![WhatsApp Image 2023-04-02 at 22.15.28.jpg](https://assets.leetcode.com/users/images/59d30d22-48ca-4928-b1ff-5d553d83d28f_1680454031.2301693.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// Brute Force Approach\\n// Time complexity -> O(n*m) and Space -> O(1)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int pairCount=0;\\n            for(int j=0;j<potions.size();j++)\\n            {\\n                long long check=(long long)(potions[j])*(long long)(spells[i]);\\n                if(check>=success)\\n                {\\n                    pairCount++;\\n                }\\n            }\\n            ans.push_back(pairCount);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Optimized Approach [Binary Search]\\n// Time complexity -> O((n+m)log(m)) and Space -> O(logm)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=lower_bound(potions.begin(),potions.end(),minPotion)-potions.begin();\\n\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\nprivate:\\n    int LowerBound(int l, int r,vector<int> &potions,int minPotion)\\n    {\\n        int possibleIndex=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(potions[mid]>=minPotion)\\n            {\\n                possibleIndex=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return possibleIndex;\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end()); // O(mlogm)\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++) // O(n*logm)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=LowerBound(0,m-1,potions,minPotion);\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371463,
                "title": "accepted-time-complexity-o-n-log-n",
                "content": "# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n# Code\\n```\\nclass Solution {\\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\\n        var potions = potions\\n        potions.sort()\\n        var returnArr = [Int]()\\n\\n        for spell in spells {\\n            var i = 0 \\n            var j = potions.count-1\\n            if potions[j]*spell < success {\\n                returnArr.append(0)\\n                continue\\n            }\\n             if potions[0]*spell >= success {\\n                returnArr.append(potions.count)\\n                continue\\n            }\\n\\n            while i<=j {\\n                let mid = (i+j)/2\\n                if potions[mid]*spell >= success && potions[mid-1]*spell < success {\\n                    returnArr.append(potions.count-mid)\\n                    break\\n                } else if potions[mid]*spell >= success {\\n                    j = mid-1\\n                } else {\\n                    i = mid+1\\n                }\\n            }\\n        }\\n        return returnArr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\\n        var potions = potions\\n        potions.sort()\\n        var returnArr = [Int]()\\n\\n        for spell in spells {\\n            var i = 0 \\n            var j = potions.count-1\\n            if potions[j]*spell < success {\\n                returnArr.append(0)\\n                continue\\n            }\\n             if potions[0]*spell >= success {\\n                returnArr.append(potions.count)\\n                continue\\n            }\\n\\n            while i<=j {\\n                let mid = (i+j)/2\\n                if potions[mid]*spell >= success && potions[mid-1]*spell < success {\\n                    returnArr.append(potions.count-mid)\\n                    break\\n                } else if potions[mid]*spell >= success {\\n                    j = mid-1\\n                } else {\\n                    i = mid+1\\n                }\\n            }\\n        }\\n        return returnArr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371458,
                "title": "c-accepted-time-complexity-o-n-log-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n         vector<int> ans;\\n         sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            int count=0;\\n            int start=0;\\n            int end=potions.size();\\n            while(start<end){\\n\\n                int mid = (start+end)/2;\\n\\n                if(potions[mid]*1ll*spells[i]>=success){\\n                  end = mid;\\n                }\\n                else{\\n                   start=mid+1;\\n                }\\n                    \\n                \\n            }\\n            \\n           count+=potions.size()-end;\\n\\n\\n            ans.push_back(count);\\n        }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n         vector<int> ans;\\n         sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            int count=0;\\n            int start=0;\\n            int end=potions.size();\\n            while(start<end){\\n\\n                int mid = (start+end)/2;\\n\\n                if(potions[mid]*1ll*spells[i]>=success){\\n                  end = mid;\\n                }\\n                else{\\n                   start=mid+1;\\n                }\\n                    \\n                \\n            }\\n            \\n           count+=potions.size()-end;\\n\\n\\n            ans.push_back(count);\\n        }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371435,
                "title": "simplest-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity  \\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spell, vector<int>& potion, long long success) {\\n      vector<int>v;\\n      sort(potion.begin(),potion.end());\\n      for(int i=0;i<spell.size();i++){\\n          int l=0;\\n          int h=potion.size()-1;\\n          int count=0;\\n          bool f=false;\\n          int mid;\\n          while(l<=h){\\n            mid=(l+h)/2;\\n          long long res=(long long)spell[i]*(long long)potion[mid];\\n          if(res>=success){\\n          count=mid;\\n          h=mid-1;\\n          f=true;\\n          }\\n          else\\n          l=mid+1;\\n      }\\n       if(f)\\n          v.push_back(potion.size()-count);  \\n       else \\n          v.push_back(0);\\n        }\\n        return v;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spell, vector<int>& potion, long long success) {\\n      vector<int>v;\\n      sort(potion.begin(),potion.end());\\n      for(int i=0;i<spell.size();i++){\\n          int l=0;\\n          int h=potion.size()-1;\\n          int count=0;\\n          bool f=false;\\n          int mid;\\n          while(l<=h){\\n            mid=(l+h)/2;\\n          long long res=(long long)spell[i]*(long long)potion[mid];\\n          if(res>=success){\\n          count=mid;\\n          h=mid-1;\\n          f=true;\\n          }\\n          else\\n          l=mid+1;\\n      }\\n       if(f)\\n          v.push_back(potion.size()-count);  \\n       else \\n          v.push_back(0);\\n        }\\n        return v;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371395,
                "title": "c-binary-search-simple-easy-solution",
                "content": "# Complexity\\n- Time complexity:`O(n log n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getSuccess(int spell , vector<int>& potions , long long success){\\n\\n        int n = potions.size();\\n        int lo = 0 , hi = n -  1;\\n        int successfull_Pairs = 0;\\n\\n        while(lo <= hi){\\n\\n            int mid = lo + (hi - lo) / 2;\\n            long long product = (long long)spell * (long long)potions[mid];\\n\\n            if(product >= success){\\n                successfull_Pairs = n - mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n\\n        }\\n\\n        return successfull_Pairs;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n\\n        int n = spells.size();\\n        vector<int>result;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int pairs = getSuccess(spells[i],potions,success);\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getSuccess(int spell , vector<int>& potions , long long success){\\n\\n        int n = potions.size();\\n        int lo = 0 , hi = n -  1;\\n        int successfull_Pairs = 0;\\n\\n        while(lo <= hi){\\n\\n            int mid = lo + (hi - lo) / 2;\\n            long long product = (long long)spell * (long long)potions[mid];\\n\\n            if(product >= success){\\n                successfull_Pairs = n - mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n\\n        }\\n\\n        return successfull_Pairs;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n\\n        int n = spells.size();\\n        vector<int>result;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int pairs = getSuccess(spells[i],potions,success);\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371306,
                "title": "java-binary-search-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe brute force will result in O(n^2) time complexity so to minimise it we apply binary search within the outer loop to search for start of the element where the target or the success is achieved.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array first to apply the binary search since we only need the count. And then search for the element idx for each spell where after which the success is achieved in the array. Now simply add the count in the ans array and return it.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long target) {\\n        int[] ans = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            int ele = spells[i];\\n            int st = 0;\\n            int end = potions.length-1;\\n            int idx = -1;\\n            while(st <= end){\\n                int mid = (st+end)/2;\\n                if((long)potions[mid]*ele > target){\\n                    end = mid-1;\\n                }else if((long)potions[mid]*ele < target){\\n                    st = mid+1;\\n                }else{\\n                    idx = mid;\\n                    end = mid-1;\\n                }\\n            }\\n            if(idx == -1){\\n                idx = st;\\n            }\\n            ans[i] = potions.length-idx;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long target) {\\n        int[] ans = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            int ele = spells[i];\\n            int st = 0;\\n            int end = potions.length-1;\\n            int idx = -1;\\n            while(st <= end){\\n                int mid = (st+end)/2;\\n                if((long)potions[mid]*ele > target){\\n                    end = mid-1;\\n                }else if((long)potions[mid]*ele < target){\\n                    st = mid+1;\\n                }else{\\n                    idx = mid;\\n                    end = mid-1;\\n                }\\n            }\\n            if(idx == -1){\\n                idx = st;\\n            }\\n            ans[i] = potions.length-idx;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371267,
                "title": "2300-successful-pairs-of-spells-and-potions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371199,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        vector<int>ans;\\n        int m=spells.size();\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<m;i++)\\n        {\\n            long long pro=spells[i];\\n            int l=0;\\n            int r=n-1;\\n            int count=0;\\n            while(l<=r){\\n                long long mid=l+(r-l)/2;\\n                if(success<=(pro*potions[mid]))\\n                {\\n                    count=n-mid;\\n                    r=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        vector<int>ans;\\n        int m=spells.size();\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<m;i++)\\n        {\\n            long long pro=spells[i];\\n            int l=0;\\n            int r=n-1;\\n            int count=0;\\n            while(l<=r){\\n                long long mid=l+(r-l)/2;\\n                if(success<=(pro*potions[mid]))\\n                {\\n                    count=n-mid;\\n                    r=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371116,
                "title": "sort-binary-search-in-c-with-explanation",
                "content": "# Approach\\nSort and apply binary search on the potions\\n\\n# Complexity\\n- Time complexity:\\n$$O(mlogm) + O(nlogm)$$ mlogm is for sorting and nlogm is for binary search\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int bsearch(vector<int>& arr, long long target, int mul) {\\n        int sz = arr.size();\\n        if( (arr[0]*1LL) *mul  > target)\\n            return 0;\\n        if( (arr[sz-1]*1LL) *mul  < target)\\n            return sz;\\n        int st = 0, ed = sz-1, idx = sz-1;\\n        while(st <= ed) {\\n            int mid = (st + ed)/2;\\n            if(target <= (arr[mid]*1LL) *mul) {\\n                idx = mid;\\n                ed = mid - 1;\\n            }\\n            else\\n                st = mid + 1;\\n        }\\n        return idx;\\n    }\\n\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size();\\n        int m = potions.size();\\n        for(int i=0;i<n;i++) {\\n            ans.push_back(m - bsearch(potions, success, spells[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    int bsearch(vector<int>& arr, long long target, int mul) {\\n        int sz = arr.size();\\n        if( (arr[0]*1LL) *mul  > target)\\n            return 0;\\n        if( (arr[sz-1]*1LL) *mul  < target)\\n            return sz;\\n        int st = 0, ed = sz-1, idx = sz-1;\\n        while(st <= ed) {\\n            int mid = (st + ed)/2;\\n            if(target <= (arr[mid]*1LL) *mul) {\\n                idx = mid;\\n                ed = mid - 1;\\n            }\\n            else\\n                st = mid + 1;\\n        }\\n        return idx;\\n    }\\n\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size();\\n        int m = potions.size();\\n        for(int i=0;i<n;i++) {\\n            ans.push_back(m - bsearch(potions, success, spells[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371111,
                "title": "master-the-art-of-spell-and-potion-pairing-a-typescript-binary-search-approach-100-87-50",
                "content": "# Intuition\\nGiven two arrays representing the strengths of spells and potions, our task is to find the number of successful pairs for each spell. A pair is considered successful if the product of the strengths of the spell and the potion is at least equal to a given `success` value. To solve this problem efficiently, we can take advantage of a binary search algorithm on the sorted potions array for each spell.\\n\\n# Approach\\n1. **Sort the potions array:** First, we sort the potions array in ascending order. This enables us to perform binary search on the array later in the process. Sorting takes $$O(m * log(m))$$ time, where m is the length of the potions array.\\n2. **Define a binary search function:** We create a binary search function that takes an array and a target value as inputs. The function iterates over the array and finds the index where the target value should be inserted while maintaining the sorted order of the array. This function has a time complexity of $$O(log(m))$$ as it is applied to the sorted potions array.\\n3. **Iterate over spells:** For each spell in the spells array, we calculate the minimum potion strength required to form a successful pair. To do this, we divide the `success` value by the strength of the current spell and round up to the nearest integer. This gives us the minimum potion strength that, when multiplied by the current spell strength, will produce a product greater than or equal to the `success` value. We then use the binary search function to find the index where this minimum potion strength should be inserted in the sorted potions array.\\n4. **Calculate the number of successful pairs:** The number of successful pairs for a given spell is the difference between the length of the potions array and the index found using binary search. This is because all the potions at the index and to the right of it in the sorted array have a strength greater than or equal to the minimum potion strength required for a successful pair with the current spell.\\n5. **Return an array with the results:** Finally, we return an array with the number of successful pairs for each spell by mapping over the spells array and performing the above steps for each element. The returned array has the same length as the input spells array.\\n\\n# Complexity\\nTime complexity: $$O(n\\u2217log(m))$$, where n is the length of the spells array and m is the length of the potions array. This complexity is due to sorting the potions array in $$O(m * log(m))$$ time and performing binary search on the potions array for each spell in $$O(n * log(m))$$ time.\\nSpace complexity: $$O(1)$$, as we only use a constant amount of additional memory for temporary variables.\\n\\n# Code\\n```\\n/**\\n * Performs binary search on a sorted array to find the index where the target value should be inserted.\\n * \\n * @param arr - A sorted array of numbers.\\n * @param target - The target number to be searched for.\\n * @returns The index where the target value should be inserted to maintain the sorted order.\\n */\\nfunction binarySearch(arr: number[], target: number): number {\\n  let left = 0;\\n  let right = arr.length - 1;\\n\\n  // Iterate until the left and right pointers converge.\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (arr[mid] < target) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n\\n  // Return the index where the target value should be inserted.\\n  return left;\\n}\\n\\n/**\\n * Calculates the number of successful pairs of spells and potions.\\n * A spell and potion pair is considered successful if the product of their strengths is at least `success`.\\n *\\n * @param spells - An array of integers representing the strengths of the spells.\\n * @param potions - An array of integers representing the strengths of the potions.\\n * @param success - An integer representing the minimum product of spell and potion strengths required for success.\\n * @returns An array of integers representing the number of potions that will form a successful pair with each spell.\\n */\\nfunction successfulPairs(spells: number[], potions: number[], success: number): number[] {\\n  // Sort the potions list in ascending order to allow for efficient binary search.\\n  potions.sort((a, b) => a - b);\\n\\n  // Iterate over each spell in the spells list and use binary search to find the index of the first potion\\n  // that forms a successful pair, then calculate the number of successful pairs for each spell.\\n  // The map function creates a new array with the results of calling the provided function on every element in the original spells array.\\n  return spells.map(\\n    // Calculate the minimum potion strength required to form a successful pair\\n    // with the current spell, and use binary search to find the index where the target value should be inserted.\\n    (spell) => potions.length - binarySearch(potions, Math.ceil(success / spell))\\n  );\\n}\\n```\\n![2300. Successful Pairs of Spells and Potions.PNG](https://assets.leetcode.com/users/images/e1438d97-4336-441e-bc1c-810381166d23_1680447034.2240133.png)\\n",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Performs binary search on a sorted array to find the index where the target value should be inserted.\\n * \\n * @param arr - A sorted array of numbers.\\n * @param target - The target number to be searched for.\\n * @returns The index where the target value should be inserted to maintain the sorted order.\\n */\\nfunction binarySearch(arr: number[], target: number): number {\\n  let left = 0;\\n  let right = arr.length - 1;\\n\\n  // Iterate until the left and right pointers converge.\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (arr[mid] < target) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n\\n  // Return the index where the target value should be inserted.\\n  return left;\\n}\\n\\n/**\\n * Calculates the number of successful pairs of spells and potions.\\n * A spell and potion pair is considered successful if the product of their strengths is at least `success`.\\n *\\n * @param spells - An array of integers representing the strengths of the spells.\\n * @param potions - An array of integers representing the strengths of the potions.\\n * @param success - An integer representing the minimum product of spell and potion strengths required for success.\\n * @returns An array of integers representing the number of potions that will form a successful pair with each spell.\\n */\\nfunction successfulPairs(spells: number[], potions: number[], success: number): number[] {\\n  // Sort the potions list in ascending order to allow for efficient binary search.\\n  potions.sort((a, b) => a - b);\\n\\n  // Iterate over each spell in the spells list and use binary search to find the index of the first potion\\n  // that forms a successful pair, then calculate the number of successful pairs for each spell.\\n  // The map function creates a new array with the results of calling the provided function on every element in the original spells array.\\n  return spells.map(\\n    // Calculate the minimum potion strength required to form a successful pair\\n    // with the current spell, and use binary search to find the index where the target value should be inserted.\\n    (spell) => potions.length - binarySearch(potions, Math.ceil(success / spell))\\n  );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3371091,
                "title": "easy-c-approach-with-explanation",
                "content": "# Intuition\\nAs answer should follow the of spells so we can\\'t change that array.\\nbut if we read question properly then we can see that we only need to count values in potions by which if we product the spells index value which give product atleast success. \\n\\n# Approach\\nAs we have to find number of products which will give product with specific index atleast success.\\nSo if we see potion index we can easily see that we if we somehow sort that and find minimum value which gives product atleast success then rest falling ownwards will be greater. so which whill give result easily\\nSteps\\n1. sort potion array.\\n2. traverse spell array.\\n3. apply binary search to find minimum value giving product >= success.\\n4. add potion size - index to result.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n) for result vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> result;\\n        for(auto x: spells)\\n        {\\n            int low = 0, high = potions.size() - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                long long pro = long(potions[mid]) * (long)(x);\\n                if(pro >= success)\\n                    high = mid - 1;\\n                else \\n                    low = mid +1;\\n            }\\n            result.push_back(potions.size() - low);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> result;\\n        for(auto x: spells)\\n        {\\n            int low = 0, high = potions.size() - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                long long pro = long(potions[mid]) * (long)(x);\\n                if(pro >= success)\\n                    high = mid - 1;\\n                else \\n                    low = mid +1;\\n            }\\n            result.push_back(potions.size() - low);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371074,
                "title": "easy-java-solution-binary-search-memory-98-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            long target = (success + spells[i] - 1) / spells[i];\\n            int left = 0;\\n            int right = potions.length - 1;\\n\\n            while(left < right) {\\n                int mid = (right + left) / 2;\\n                if(potions[mid] < target) left = mid + 1;\\n                else right = mid;\\n            }\\n\\n            if(potions[left] < target) left++;\\n            spells[i] = potions.length - left;\\n        }\\n\\n        return spells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            long target = (success + spells[i] - 1) / spells[i];\\n            int left = 0;\\n            int right = potions.length - 1;\\n\\n            while(left < right) {\\n                int mid = (right + left) / 2;\\n                if(potions[mid] < target) left = mid + 1;\\n                else right = mid;\\n            }\\n\\n            if(potions[left] < target) left++;\\n            spells[i] = potions.length - left;\\n        }\\n\\n        return spells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1850766,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850841,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851177,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850860,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850810,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851027,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851208,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1794344,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851644,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851426,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850766,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850841,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851177,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850860,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850810,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851027,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851208,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1794344,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851644,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851426,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851643,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851600,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1936167,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1905055,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1859454,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851734,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851456,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851401,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851396,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851357,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1850771,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1834821,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1850764,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2062725,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2053397,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2036657,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2024872,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1943749,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1862876,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1859621,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1857730,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1857050,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1853506,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1852403,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851983,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851950,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851905,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851803,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851800,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851796,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851763,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851756,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851749,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851718,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851549,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851535,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851496,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851491,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851478,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851457,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Selling Pieces of Wood",
        "question_content": "<p>You are given two integers <code>m</code> and <code>n</code> that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array <code>prices</code>, where <code>prices[i] = [h<sub>i</sub>, w<sub>i</sub>, price<sub>i</sub>]</code> indicates you can sell a rectangular piece of wood of height <code>h<sub>i</sub></code> and width <code>w<sub>i</sub></code> for <code>price<sub>i</sub></code> dollars.</p>\n\n<p>To cut a piece of wood, you must make a vertical or horizontal cut across the <strong>entire</strong> height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to <code>prices</code>. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you <strong>cannot</strong> rotate a piece to swap its height and width.</p>\n\n<p>Return <em>the <strong>maximum</strong> money you can earn after cutting an </em><code>m x n</code><em> piece of wood</em>.</p>\n\n<p>Note that you can cut the piece of wood as many times as you want.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/27/ex1.png\" style=\"width: 239px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]\n<strong>Output:</strong> 19\n<strong>Explanation:</strong> The diagram above shows a possible scenario. It consists of:\n- 2 pieces of wood shaped 2 x 2, selling for a price of 2 * 7 = 14.\n- 1 piece of wood shaped 2 x 1, selling for a price of 1 * 3 = 3.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\nThis obtains a total of 14 + 3 + 2 = 19 money earned.\nIt can be shown that 19 is the maximum amount of money that can be earned.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/27/ex2new.png\" style=\"width: 250px; height: 175px;\" />\n<pre>\n<strong>Input:</strong> m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]\n<strong>Output:</strong> 32\n<strong>Explanation:</strong> The diagram above shows a possible scenario. It consists of:\n- 3 pieces of wood shaped 3 x 2, selling for a price of 3 * 10 = 30.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\nThis obtains a total of 30 + 2 = 32 money earned.\nIt can be shown that 32 is the maximum amount of money that can be earned.\nNotice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>prices[i].length == 3</code></li>\n\t<li><code>1 &lt;= h<sub>i</sub> &lt;= m</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>All the shapes of wood <code>(h<sub>i</sub>, w<sub>i</sub>)</code> are pairwise <strong>distinct</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2168148,
                "title": "java-c-python-bottom-up-dp",
                "content": "# **Intuition**\\nMust cut across the **entire** height or width of the piece,\\nthis leads up to the dp soluition.\\n<br>\\n\\n# **Explanation**\\nFor a piece of `w * h`,\\n\\nwe can make a vertical cut to split it into `a * h` and `(w - a) * h`\\nSo we can update `dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h])`.\\n\\nwe can make a horizontal cut to split it into  `w * a` and `w * (h - a)`\\nSo we can update `dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a])`.\\n<br>\\n\\n# **Complexity**\\nTime `O(mmn + mnn)`\\nSpace `O(mn)`\\n<br>\\n\\n**Java**\\n```java\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m + 1][n + 1];\\n        for (int[] p : prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = Math.max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = Math.max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long dp[201][201] = {};\\n        for (auto& p: prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def sellingWood(self, m, n, prices):\\n        dp = [[0] * (n + 1) for i in range(m+1)]\\n        for w, h, p in prices:\\n            dp[w][h] = p\\n        for w in range(1, m + 1):\\n            for h in range(1, n + 1):\\n                for a in range(1, w // 2 + 1):\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h])\\n                for a in range(1, h // 2 + 1):\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a])\\n        return dp[m][n]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m + 1][n + 1];\\n        for (int[] p : prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = Math.max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = Math.max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\n```cpp\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long dp[201][201] = {};\\n        for (auto& p: prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\n```py\\n    def sellingWood(self, m, n, prices):\\n        dp = [[0] * (n + 1) for i in range(m+1)]\\n        for w, h, p in prices:\\n            dp[w][h] = p\\n        for w in range(1, m + 1):\\n            for h in range(1, n + 1):\\n                for a in range(1, w // 2 + 1):\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h])\\n                for a in range(1, h // 2 + 1):\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a])\\n        return dp[m][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2170082,
                "title": "partition-dp-recursion-memoization-tabulation-space-optimization",
                "content": "#####  **Let\\'s Start The Journey of Solving This Beautiful Problem** \\uD83D\\uDE09\\n\\n\\n**Step - 1** **(*Understanding what the problem states*)**\\n\\nWe have to `explore all possible ways `\\n(i.e cut the wood in all possible ways both row wise and column wise)\\nand `return` the case in which we can earn `maximum money`.\\n\\n****\\n\\t\\n**Step - 2** **(*How to approach the problem*)**\\n\\nAccording to step - 1, we have `explore all possible` ways \\nin which wood can be cut both row-wise and column-wise. \\nSo, we have to `use Recursion`.\\n\\t\\n****\\n\\n**Step - 3** **(*Writing Recursion / Top-Down Approach*)**\\t\\n\\n**Obervation :** \\nIt is difficult to work with the `Prices` matrix given. So, we have to store the prices into a data structure (like `HashMap`, `2D Vector` etc.) according to the `height` and `width` of the wood. Here, I will use HashMap.\\n\\n**How To Write Recursion ? :**\\n1. To Explore all possible ways, we can cut the Rectangular wood both row-wise and column-wise `independently`.\\n[**Why independently? :** \\nAccording to the question; `To cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces`. This is why we can consider vertical and horizontal cuts independently.] \\n\\t\\n\\tI.  If length of `row` is `m`, then we can do partition at `1,2,3,....,m-1`.\\n\\n\\tII.  If length of `column` is `n`, then we can do partition at `1,2,3,....,n-1`.\\n\\n2.  `Return` the `maximum` of all cases.\\n\\n3. ***Base case -*** The `partitions` for which `price is not given`, we have to `return 0`.\\n\\n**Code :** \\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tlong long f(int row, int col, map<pair<int,int>,long long> &mp){\\n\\n\\t\\t\\t//Base case is tackled in this line\\n\\t\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\t\\tfor(int i = 1;i < row;i++) //Partitions Row-wise\\n\\t\\t\\t\\tans = max(ans,f(i,col,mp) + f(row-i,col,mp));\\n\\n\\t\\t\\tfor(int j = 1;j < col;j++) //Partitions Column-wise\\n\\t\\t\\t\\tans = max(ans,f(row, j, mp) + f(row, col-j, mp));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t//Declaring the HashMap\\n\\t\\t\\tmap<pair<int,int>,long long> mp;\\n\\n\\t\\t\\t//Storing Prices in HashMap where {height,width} of wood is key and {Price} is value\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tmp[{prices[i][0],prices[i][1]}] = prices[i][2];\\n\\n\\t\\t\\treturn f(m,n,mp);\\n\\t\\t}\\n\\t};\\n\\n\\n**Time complexity -** *Exponential*\\n**Space complexity -** *O(k) + O(m + n)* [ Recursion stack space], k = `Size` of `Prices` Array Given\\n\\n**Result :** *Time Limit Exceded*\\n\\n****\\n\\n**Step - 4** **(*Optimizing Recursion / Top-Down Approach*)**\\t\\n\\n**Obervation :** \\nDue to symmetry, If we do partitions till (row/2) and (col/2), we will be able to explore all possible ways.\\n***Example -***\\nFor `i = 3 & row = 7`; \\nwe will call `f(3,col,mp) + f(7-3,col,mp)` i.e `f(3,col,mp) + f(4,col,mp)`.\\nNo point to call it again for `i = 4 & row = 7` i.e `f(4,col,mp) + f(3,col,mp)`\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tlong long f(int row, int col, map<pair<int,int>,long long> &mp){\\n\\n\\t\\t\\t//Base case is tackled in this line\\n\\t\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\t\\tfor(int i = 1;i <= row/2;i++) //Partitions Row-wise\\n\\t\\t\\t\\tans = max(ans,f(i,col,mp) + f(row-i,col,mp));\\n\\n\\t\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\t\\tans = max(ans,f(row, j, mp) + f(row, col-j, mp));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t//Declaring the HashMap\\n\\t\\t\\tmap<pair<int,int>,long long> mp;\\n\\n\\t\\t\\t//Storing Prices in HashMap where {height,width} of wood is key and {Price} is value\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tmp[{prices[i][0],prices[i][1]}] = prices[i][2];\\n\\n\\t\\t\\treturn f(m,n,mp);\\n\\t\\t}\\n\\t};\\n\\t\\n**Time complexity -** *Exponential*\\n**Space complexity -** *O(k) + O(m + n)* [ Recursion stack space], k = `Size` of `Prices` Array Given\\n\\n**Result :** *Time Limit Exceded*\\n\\n****\\n\\n**Step - 5** **(*Writing Memoization*)**\\n\\n**Obervation :** \\nIf you `draw Recursion Tree`, You will `observe` there will be lots of `Overlapping Sub-Problems`.\\nSo, we have to `use Memoization`.\\n\\n**How To Write Memoization ? :**\\n\\n1.  See the `range` of `row` and `col` variable.\\n\\t I. `row` - `[1,m]`\\n\\t II. `col` - `[1,n]`\\n2. Declare a 2D Vector (say, `dp`)\\tOf length `[max(row)+1][max(col)+1]` and `Intialised` with a value not in the constraints (like `-1` here) i.e v`ector<vector<long long>> dp(m+1,vector<long long>(n+1,-1));`\\n3. Now before going into recursion call check (i.e `if(dp[row][col] != -1)`) if the value is already computed or not. If computed return it (i.e `return dp[row][col]`), no need to compute it again.\\n4. Every time returning the value of recursion call store it in `dp[row][col]` so that we can use it again.\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tlong long f(int row, int col, map<pair<int,int>,long long> &mp,vector<vector<long long>> &dp){\\n\\t\\t\\t//Check pre-computed previously or not\\n\\t\\t\\tif(dp[row][col] != -1) return dp[row][col];\\n\\n\\t\\t\\t//Base Case is tackled under this\\n\\t\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\t\\tfor(int i = 1;i <= row/2;i++) //Partitions Row-wise\\n\\t\\t\\t\\tans = max(ans,f(i,col,mp,dp) + f(row-i,col,mp,dp));\\n\\n\\t\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\t\\tans = max(ans,f(row, j, mp,dp) + f(row, col-j, mp,dp));\\n\\n\\t\\t\\t//store ans in dp array before returning so that we can use it again.\\n\\t\\t\\treturn dp[row][col] = ans; \\n\\t\\t}\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t//Declaring the HashMap\\n\\t\\t\\tmap<pair<int,int>,long long> mp;\\n\\n\\t\\t\\t//Storing Prices in HashMap where {height,width} of wood is key and {Price} is value\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tmp[{prices[i][0],prices[i][1]}] = prices[i][2];\\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1,vector<long long>(n+1,-1));\\n\\t\\t\\treturn f(m,n,mp,dp);\\n\\t\\t}\\n\\t};\\n\\n**Time complexity -** *O(mn(m+n))*\\n**Space complexity -** *O(mn) + O(k) + O(m + n)* [ Recursion stack space], k = `Size` of `Prices` Array Given\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**Step - 6** **(*Writing Tabulation / Bottom-Up Approach*)**\\t\\n\\n**Why To Do Tabulation ? :**\\nTo remove the `Recursion stack Space` (i.e `O(m + n)`) we are using.\\n\\n**How To Write Tabulation? :**\\n\\n1. `Tabulation` is `Bottom-up` approach i.e `opposite` of `Top-Down / Recursion`. So, here we will run loop in `opposite order` i.e `row - 1,2,3,4....m` and `column - 1,2,3,....n.`\\n2. `Copy & Paste` the `recursion` inside the loop `i.e`\\n\\t\\t\\n\\t\\t//Base Case is tackled under this\\n\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\tfor(int i = 1;i <= row/2;i++) //Partitions Row-wise\\n\\t\\t\\tans = max(ans,f(i,col,mp,dp) + f(row-i,col,mp,dp));\\n\\n\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\tans = max(ans,f(row, j, mp,dp) + f(row, col-j, mp,dp));\\n\\n\\t\\t//store ans in dp array before returning so that we can use it again.\\n\\t\\treturn dp[row][col] = ans;\\n\\tand `change function to dp array` ( like `f(i,col,mp,dp)` to `dp[i][col]`).\\n3. `Remove return` from `return dp[row][col] = ans;`\\n4. Atlast change return statement `return f(m,n,mp,dp)` to `return dp[m][n]`.\\n\\n\\n**Code :**\\n\\t \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t//Declaring the HashMap\\n\\t\\t\\tmap<pair<int,int>,long long> mp;\\n\\n\\t\\t\\t//Storing Prices in HashMap where {height,width} of wood is key and {Price} is value\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tmp[{prices[i][0],prices[i][1]}] = prices[i][2];\\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1,vector<long long>(n+1,-1));\\n\\n\\t\\t\\tfor(int row = 1;row <= m;row++){ //loop reversed\\n\\t\\t\\t\\tfor(int col = 1;col <= n;col++){ //loop reversed\\n\\n\\t\\t\\t\\t\\t//Base Case is tackled under this\\n\\t\\t\\t\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\t\\t\\t\\tfor(int i = 1;i <= row/2;i++) //Partitions Row-wise\\n\\t\\t\\t\\t\\t\\tans = max(ans,dp[i][col] + dp[row-i][col]);\\n\\n\\t\\t\\t\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\t\\t\\t\\tans = max(ans,dp[row][j] + dp[row][col-j]);\\n\\n\\t\\t\\t\\t\\t//store ans in dp array before returning so that we can use it again.\\n\\t\\t\\t\\t\\tdp[row][col] = ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[m][n];\\n\\t\\t}\\n\\t};\\n\\n\\n**Time complexity -** *O(mn(m+n))*\\n**Space complexity -** *O(mn) + O(k)*, k = `Size` of `Prices` Array Given\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**Step - 7** **(*Writing Space Optimization*)**\\n\\n**Obervation :** \\n1. If you can `fill the dp array`,then you will see, we `donot need HashMap` to `store prices`. `We can directly store prices in dp array`.\\n2. `Previously`, we are `tackling base case` in `long long ans = mp[{row,col}]; ` .` Now`, if we  `initialized dp array by 0`,then base case will be tackled.\\n\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {     \\n\\t\\t\\t//Base case is tackled in this declaration as we initialized the dp array with 0.\\n\\t\\t\\tvector<vector<long long>> dp(m+1,vector<long long>(n+1,0)); \\n\\n\\t\\t\\t//Storing Prices in dp array itself\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tdp[prices[i][0]][prices[i][1]] = prices[i][2];\\n\\n\\t\\t\\tfor(int row = 1;row <= m;row++){ //loop reversed\\n\\t\\t\\t\\tfor(int col = 1;col <= n;col++){ //loop reversed\\n\\n\\t\\t\\t\\t\\t//Base Case is tackled under this\\n\\t\\t\\t\\t\\tlong long ans = dp[row][col]; \\n\\n\\t\\t\\t\\t\\tfor(int i = 1;i <= row/2;i++)  //Partitions Row-wise\\n\\t\\t\\t\\t\\t\\tans = max(ans,dp[i][col] + dp[row-i][col]);\\n\\n\\t\\t\\t\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\t\\t\\t\\tans = max(ans,dp[row][j] + dp[row][col-j]);\\n\\n\\t\\t\\t\\t\\t//store ans in dp array before returning so that we can use it again.\\n\\t\\t\\t\\t\\tdp[row][col] = ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[m][n];\\n\\t\\t}\\n\\t};\\n\\n\\n**Time complexity -** *O(mn(m+n))*\\n**Space complexity -** *O(mn)*\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**JOURNEY ENDS HERE\\uD83D\\uDE42**\\n\\n**My Other Articles :**\\n\\n1. [Number of Distinct Roll Sequences](https://leetcode.com/problems/number-of-distinct-roll-sequences/discuss/2197300/3D-DP-Recursion-greaterMemoization-greaterTabulation-greaterSpace-Optimization) [ 3D DP Pattern ]\\n\\n**If You Like It, Please Upvote.**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tprivate:\\n\\t\\tlong long f(int row, int col, map<pair<int,int>,long long> &mp){\\n\\n\\t\\t\\t//Base case is tackled in this line\\n\\t\\t\\tlong long ans = mp[{row,col}",
                "codeTag": "Java"
            },
            {
                "id": 2168135,
                "title": "python-explanation-with-pictures-dp",
                "content": "*To cut a piece of wood, you must make a vertical or horizontal cut across the **entire** height or width of the piece to split it into two smaller pieces.* \\n\\nI was lost in plans with twisted cutting edges before I noticed this line above, then the logic became quite clear:\\n\\nFor a piece of wood of size `r*c`, forget about the final states and the many smaller pieces it might turn into, let\\'s just focus on the **first cut**.  \\n\\nSince we must cut accross the entire height or weight, thus every possible first cut makes the original piece into two smaller piece of the **same length** or **same height**. Given a piece of size `4*6`, all the possible cutting plans are listed below.\\n\\n![image](https://assets.leetcode.com/users/images/2dbc0ad3-5693-4aa7-9945-da7263073033_1655611245.4847548.png)\\n\\nOriginally every cell of `dp` is 0 since we have no idea what the best price is. We are also given a list of selling plans `A`, `[r, c, p]` in `A` means that if we have a a piece of wood with size of `r*c`, we can sell it directly without further cutting, put these prices in the corresponding cells in `dp`.\\n\\n![image](https://assets.leetcode.com/users/images/2c318a64-130f-4c13-bbe2-a5127dd27b46_1655611253.4621947.png)\\n\\nLet\\'s see how we update `dp`, start by `row = 1` and `row = 1`:\\n- `dp[1][1] = 1`\\n- For `dp[1][2]` (size of `1*2`), we can either sell it directly, or cut it into two `1*1`. Put the higher price in `dp[1][2]`.\\n- For `dp[1][3]` (size of `1*3`), we can either sell it directly, or cut it into `1*1` and `1*2`. Put the higher price in `dp[1][3]`.\\n\\n![image](https://assets.leetcode.com/users/images/7f6af3b9-2dd1-4e89-8192-619af3364082_1655611260.840119.png)\\n\\n- For `dp[1][4]` (size of `1*4`), we can either:\\n\\t-  sell it directly.\\n\\t-  cut it into `1*1` and `1*3`. \\n\\t-  cut it into `1*2` and `1*2`. \\n\\nNotice that even though we can sell `1*4` directly, we make more profit by cutting it into two `1*2`s, Thus we update the price on `dp[1][4]` as `4`.\\n\\n![image](https://assets.leetcode.com/users/images/a6847329-d740-43f3-9118-d7d29d384a3f_1655611264.9172854.png)\\n\\n\\nThe example above only shows the vertical first cut, in general we should check for both vertical cuts and the horizontal cuts before updating the best price for each cell.\\n\\nFinally return `dp[m][n]` as the best price for this whole piece of wood.\\n\\n**python**\\n\\n```\\ndef sellingWood(self, m: int, n: int, P: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for r, c, p in P:\\n            dp[r][c] = p\\n            \\n        for r in range(1, m + 1):\\n            for c in range(1, n + 1):\\n                # Find all the possible first cut:\\n                for nc in range(1, c // 2 + 1): \\n                    dp[r][c] = max(dp[r][c], dp[r][nc] + dp[r][c - nc])\\n                for nr in range(1, r // 2 + 1):\\n                    dp[r][c] = max(dp[r][c], dp[nr][c] + dp[r - nr][c])\\n                    \\n        return dp[m][n]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef sellingWood(self, m: int, n: int, P: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for r, c, p in P:\\n            dp[r][c] = p\\n            \\n        for r in range(1, m + 1):\\n            for c in range(1, n + 1):\\n                # Find all the possible first cut:\\n                for nc in range(1, c // 2 + 1): \\n                    dp[r][c] = max(dp[r][c], dp[r][nc] + dp[r][c - nc])\\n                for nr in range(1, r // 2 + 1):\\n                    dp[r][c] = max(dp[r][c], dp[nr][c] + dp[r - nr][c])\\n                    \\n        return dp[m][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2168403,
                "title": "3d-dp",
                "content": "Loved this problem. First, we need to figure out how to handle prices. \\n\\nSince we are going to be using DP array anyway, we can just set the initial price for `[h_i, w_i]` pieces to `price_i`.\\n\\nAnother trick is to do it in 3D, not 4D. For each piece `[i, j]`, we do not need to check all combinations of vertical and horizontal cuts (i * j options). We can just try all horizontal cuts, and all vertical cuts independently (i + j options).\\n\\nFinally, we only need to try `i / 2` and `j / 2` cuts because of the symmetry, as suggested by [rexue70](https://leetcode.com/rexue70/).\\n\\n**Java**\\n```java\\npublic long sellingWood(int m, int n, int[][] prices) {\\n    long[][] dp = new long[m + 1][n + 1];\\n    for (var p : prices)\\n        dp[p[0]][p[1]] = p[2];\\n    for (int i = 1; i <= m; ++i)\\n        for (int j = 1; j <= n; ++j) {\\n            for (int h = 1; h <= i / 2; ++h)\\n                dp[i][j] = Math.max(dp[i][j], dp[h][j] + dp[i - h][j]);\\n            for (int v = 1; v <= j / 2; ++v)\\n                dp[i][j] = Math.max(dp[i][j], dp[i][v] + dp[i][j - v]);\\n        }    \\n    return dp[m][n];\\n}\\n```\\n**C++**\\n```cpp\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n    long long dp[201][201] = {};\\n    for (auto &p : prices)\\n        dp[p[0]][p[1]] = p[2];\\n    for (int i = 1; i <= m; ++i)\\n        for (int j = 1; j <= n; ++j) {\\n            for (int h = 1; h <= i / 2; ++h)\\n                dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j]);\\n            for (int v = 1; v <= j / 2; ++v)\\n                dp[i][j] = max(dp[i][j], dp[i][v] + dp[i][j - v]);\\n        }\\n    return dp[m][n];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```java\\npublic long sellingWood(int m, int n, int[][] prices) {\\n    long[][] dp = new long[m + 1][n + 1];\\n    for (var p : prices)\\n        dp[p[0]][p[1]] = p[2];\\n    for (int i = 1; i <= m; ++i)\\n        for (int j = 1; j <= n; ++j) {\\n            for (int h = 1; h <= i / 2; ++h)\\n                dp[i][j] = Math.max(dp[i][j], dp[h][j] + dp[i - h][j]);\\n            for (int v = 1; v <= j / 2; ++v)\\n                dp[i][j] = Math.max(dp[i][j], dp[i][v] + dp[i][j - v]);\\n        }    \\n    return dp[m][n];\\n}\\n```\n```cpp\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n    long long dp[201][201] = {};\\n    for (auto &p : prices)\\n        dp[p[0]][p[1]] = p[2];\\n    for (int i = 1; i <= m; ++i)\\n        for (int j = 1; j <= n; ++j) {\\n            for (int h = 1; h <= i / 2; ++h)\\n                dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j]);\\n            for (int v = 1; v <= j / 2; ++v)\\n                dp[i][j] = max(dp[i][j], dp[i][v] + dp[i][j - v]);\\n        }\\n    return dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168249,
                "title": "easy-to-understand-and-intuitive-rec-memo",
                "content": "DP[h][v] is the maximum profit we can get after we cut a sheet with height h and width v\\nAlso if a particular DP[h][v] is already initialised then not calling the function to evaluate again recurcively to reduce the call stack overhead.\\n```\\nclass Solution {\\n    map<pair<int, int>, long> price;\\n    vector<vector<long>> DP;\\n\\n    long solve(int h, int v) {\\n        if (DP[h][v] != -1)\\n            return DP[h][v];\\n\\t\\t\\t\\n        // Check if we have a price for this sheet with height h and width v\\n        long ans = price.find(make_pair(h, v)) == price.end()? 0: price[make_pair(h, v)];\\n        \\n        for (int i = 1; i < 1 + h / 2; i++)\\n            ans = max(ans, \\n\\t\\t\\t\\t\\t\\t\\t(DP[i][v] != -1? DP[i][v]: solve(i, v)) +\\n\\t\\t\\t\\t\\t\\t\\t(DP[h - i][v] != -1? DP[h - i][v]: solve(h - i, v))\\n\\t\\t\\t\\t\\t); // Cut the sheet horizontally and take the maximum\\n        \\n        for (int j = 1; j < 1 + v / 2; j++)\\n            ans = max(ans, \\n\\t\\t\\t\\t\\t\\t\\t(DP[h][j] != -1? DP[h][j]: solve(h, j)) + \\n\\t\\t\\t\\t\\t\\t\\t(DP[h][v - j] != -1? DP[h][v - j]: solve(h, v - j))\\n\\t\\t\\t\\t\\t); // Cut the sheet vertically and take the maximum\\n        \\n        return DP[h][v] = ans;\\n    }\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        price = map<pair<int, int>, long>();\\n        for (vector<int> &dimension_price: prices) price[make_pair(dimension_price[0], dimension_price[1])] = dimension_price[2];\\n        DP = vector<vector<long>>(m + 1, vector<long>(n + 1, -1));\\n        \\n        return solve(m, n);\\n    }\\n};\\n```\\n\\nPython 3 solution with the same concept though its pretty slow for a python code.\\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        price = {(dimension_price[0], dimension_price[1]): dimension_price[2] for dimension_price in prices}\\n        DP = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        def solve(h: int, v: int) -> int:\\n            if DP[h][v] != -1:\\n                return DP[i][j]\\n            \\n            ans = price.get((h, v), 0)\\n            \\n            for i in range(1, 1 + h // 2):\\n                ans = max(ans, (DP[i][v] if DP[i][v] != -1 else solve(i, v)) + (DP[h - i][v] if DP[h - i][v] != -1 else solve(h - i, v)))\\n            \\n            for j in range(1, 1 + v // 2):\\n                ans = max(ans, (DP[h][j] if DP[h][j] != -1 else solve(h, j)) + (DP[h][v - j] if DP[h][v - j] != -1 else solve(h, v - j)))\\n            \\n            DP[h][v] = ans\\n            \\n            return ans\\n        \\n        return solve(m, n)\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    map<pair<int, int>, long> price;\\n    vector<vector<long>> DP;\\n\\n    long solve(int h, int v) {\\n        if (DP[h][v] != -1)\\n            return DP[h][v];\\n\\t\\t\\t\\n        // Check if we have a price for this sheet with height h and width v\\n        long ans = price.find(make_pair(h, v)) == price.end()? 0: price[make_pair(h, v)];\\n        \\n        for (int i = 1; i < 1 + h / 2; i++)\\n            ans = max(ans, \\n\\t\\t\\t\\t\\t\\t\\t(DP[i][v] != -1? DP[i][v]: solve(i, v)) +\\n\\t\\t\\t\\t\\t\\t\\t(DP[h - i][v] != -1? DP[h - i][v]: solve(h - i, v))\\n\\t\\t\\t\\t\\t); // Cut the sheet horizontally and take the maximum\\n        \\n        for (int j = 1; j < 1 + v / 2; j++)\\n            ans = max(ans, \\n\\t\\t\\t\\t\\t\\t\\t(DP[h][j] != -1? DP[h][j]: solve(h, j)) + \\n\\t\\t\\t\\t\\t\\t\\t(DP[h][v - j] != -1? DP[h][v - j]: solve(h, v - j))\\n\\t\\t\\t\\t\\t); // Cut the sheet vertically and take the maximum\\n        \\n        return DP[h][v] = ans;\\n    }\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        price = map<pair<int, int>, long>();\\n        for (vector<int> &dimension_price: prices) price[make_pair(dimension_price[0], dimension_price[1])] = dimension_price[2];\\n        DP = vector<vector<long>>(m + 1, vector<long>(n + 1, -1));\\n        \\n        return solve(m, n);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        price = {(dimension_price[0], dimension_price[1]): dimension_price[2] for dimension_price in prices}\\n        DP = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        def solve(h: int, v: int) -> int:\\n            if DP[h][v] != -1:\\n                return DP[i][j]\\n            \\n            ans = price.get((h, v), 0)\\n            \\n            for i in range(1, 1 + h // 2):\\n                ans = max(ans, (DP[i][v] if DP[i][v] != -1 else solve(i, v)) + (DP[h - i][v] if DP[h - i][v] != -1 else solve(h - i, v)))\\n            \\n            for j in range(1, 1 + v // 2):\\n                ans = max(ans, (DP[h][j] if DP[h][j] != -1 else solve(h, j)) + (DP[h][v - j] if DP[h][v - j] != -1 else solve(h, v - j)))\\n            \\n            DP[h][v] = ans\\n            \\n            return ans\\n        \\n        return solve(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168109,
                "title": "c-java-python3-top-down-dp",
                "content": "**Explanation**:\\n* `p[i][j]` represents the price to get a cut of height `i` and width `j`\\n* For a piece of type `i * j` we can cut it to have the 2 pieces of types `ii * j` and `(i - ii) * j` or `i * jj` and `i * (j - jj)`\\n* `dp[i][j]` is the maximum profit we can get after we cut a sheet with height i and width j\\n* We run for loop from `1 to i // 2` so that we don\\'t repeat the same calculations again\\n\\n**Python3**:\\n   ```\\ndef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        p = [[0] * (n + 1) for _ in range(m + 1)]\\n        for x, y, z in prices: p[x][y] = z\\n        @cache\\n        def f(i, j):\\n            if i == 0 or j == 0: return 0\\n            ans = p[i][j]\\n            for ii in range(1, i // 2 + 1):\\n                ans = max(ans, f(ii, j) + f(i - ii, j))\\n            for jj in range(1, j // 2 + 1):\\n                ans = max(ans, f(i, jj) + f(i, j - jj))\\n            return ans\\n        return f(m, n)\\n```\\n\\n**C++**:\\n```\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\tvector<vector<int>> p(m + 1, vector<int>(n + 1, 0));\\n\\tvector<vector<long long>> memo(m + 1, vector<long long>(n + 1, -1));\\n\\tfor (auto &pri: prices) p[pri[0]][pri[1]] = pri[2];\\n\\treturn dp(m, n, memo, p);\\n}\\nlong long dp(int i, int j, vector<vector<long long>> &memo, vector<vector<int>> &p) {\\n\\tif (i == 0 || j == 0) return 0;\\n\\tif (memo[i][j] > -1) return memo[i][j];\\n\\tlong long ans = p[i][j];\\n\\tfor (int ii = 1; ii <= i / 2; ii++) \\n\\t\\tans = max(ans, dp(ii, j, memo, p) + dp(i - ii, j, memo, p));\\n\\tfor (int jj = 1; jj <= j / 2; jj++) \\n\\t\\tans = max(ans, dp(i, jj, memo, p) + dp(i, j - jj, memo, p));\\n\\treturn memo[i][j] = ans;\\n}\\n```\\n\\n**Java**:\\n```\\npublic long sellingWood(int m, int n, int[][] prices) {\\n    int p[][] = new int[m + 1][n + 1];\\n    long memo[][] = new long[m + 1][n + 1];\\n    for (int i = 0; i <= m; i++) Arrays.fill(memo[i], -1);\\n    for (int pri[]: prices) p[pri[0]][pri[1]] = pri[2];\\n    return dp(m, n, memo, p);\\n}\\nprivate long dp(int i, int j, long memo[][], int p[][]) {\\n    if (i == 0 || j == 0) return 0;\\n    if (memo[i][j] > -1) return memo[i][j];\\n    long ans = p[i][j];\\n    for (int ii = 1; ii <= i / 2; ii++) \\n        ans = Math.max(ans, dp(ii, j, memo, p) + dp(i - ii, j, memo, p));\\n    for (int jj = 1; jj <= j / 2; jj++) \\n        ans = Math.max(ans, dp(i, jj, memo, p) + dp(i, j - jj, memo, p));\\n    return memo[i][j] = ans;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\ndef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        p = [[0] * (n + 1) for _ in range(m + 1)]\\n        for x, y, z in prices: p[x][y] = z\\n        @cache\\n        def f(i, j):\\n            if i == 0 or j == 0: return 0\\n            ans = p[i][j]\\n            for ii in range(1, i // 2 + 1):\\n                ans = max(ans, f(ii, j) + f(i - ii, j))\\n            for jj in range(1, j // 2 + 1):\\n                ans = max(ans, f(i, jj) + f(i, j - jj))\\n            return ans\\n        return f(m, n)\\n```\n```\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\tvector<vector<int>> p(m + 1, vector<int>(n + 1, 0));\\n\\tvector<vector<long long>> memo(m + 1, vector<long long>(n + 1, -1));\\n\\tfor (auto &pri: prices) p[pri[0]][pri[1]] = pri[2];\\n\\treturn dp(m, n, memo, p);\\n}\\nlong long dp(int i, int j, vector<vector<long long>> &memo, vector<vector<int>> &p) {\\n\\tif (i == 0 || j == 0) return 0;\\n\\tif (memo[i][j] > -1) return memo[i][j];\\n\\tlong long ans = p[i][j];\\n\\tfor (int ii = 1; ii <= i / 2; ii++) \\n\\t\\tans = max(ans, dp(ii, j, memo, p) + dp(i - ii, j, memo, p));\\n\\tfor (int jj = 1; jj <= j / 2; jj++) \\n\\t\\tans = max(ans, dp(i, jj, memo, p) + dp(i, j - jj, memo, p));\\n\\treturn memo[i][j] = ans;\\n}\\n```\n```\\npublic long sellingWood(int m, int n, int[][] prices) {\\n    int p[][] = new int[m + 1][n + 1];\\n    long memo[][] = new long[m + 1][n + 1];\\n    for (int i = 0; i <= m; i++) Arrays.fill(memo[i], -1);\\n    for (int pri[]: prices) p[pri[0]][pri[1]] = pri[2];\\n    return dp(m, n, memo, p);\\n}\\nprivate long dp(int i, int j, long memo[][], int p[][]) {\\n    if (i == 0 || j == 0) return 0;\\n    if (memo[i][j] > -1) return memo[i][j];\\n    long ans = p[i][j];\\n    for (int ii = 1; ii <= i / 2; ii++) \\n        ans = Math.max(ans, dp(ii, j, memo, p) + dp(i - ii, j, memo, p));\\n    for (int jj = 1; jj <= j / 2; jj++) \\n        ans = Math.max(ans, dp(i, jj, memo, p) + dp(i, j - jj, memo, p));\\n    return memo[i][j] = ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2168182,
                "title": "c-dynamic-programming-fast-lookup-for-a-price",
                "content": "Dynamic programming pattern - 3 options:\\n1. just take a price for the whole piece of wood\\n2. make 1 horizontal cut - and take 2 prices for 2 smaller horizontal pieces\\n3. make 1 vertical cut - and take 2 prices...\\n\\nTo make a fast lookup for the whole piece price - pre-fill a 2-dimensional array `(m+1) * (n+1)` which gives the price for the piece in O(1). The price can be `0` or not optimal (smaller pieces can have higher price) - in this case optimal price will be found using options 2 and 3 - with cutting the piece.\\n\\nTo not repeat calculations for repetitive arguments - use memoization\\n\\nTime complexity: single recursive call takes `O(M + N)`, result for the given parameters is calculated only once, DP space is `M * N`.\\n`maxPrice` precalculation takes `O(P)` to iterate on `prices`. Total:  `O(P + M * N * (M + N))` : \\nSpace complexity: `O(M * N)` - for memo and pre-filled maxPrice array\\n\\n```\\nclass Solution {\\npublic:\\n    long long getResult(int m, int n, const vector<vector<int>>& maxPrice, vector<vector<long long>>& memo) {\\n        if (memo[m][n] != -1) return memo[m][n];\\n        \\n        // option 1: just take the price for the whole piece\\n        long long price = maxPrice[m][n];\\n        \\n        for (int h = 1; h < m; ++h) {\\n            // option 2: make 1 horizontal cut, take 2 prices for the smaller pieces\\n            price = max(price, getResult(m-h, n, maxPrice, memo) + getResult(h, n, maxPrice, memo));\\n        }\\n        \\n        for (int w = 1; w < n; ++w) {\\n            // option 3: make 1 vertical cut, take 2 prices\\n            price = max(price, getResult(m, n - w, maxPrice, memo) + getResult(m, w, maxPrice, memo));\\n        }\\n        \\n        return memo[m][n] = price;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // pre-calculate array for fast lookup of \"price for piece of size h*w\"\\n        vector<vector<int>> maxPrice(m+1, vector<int>(n+1, 0));\\n        for (const vector<int>& p : prices) {\\n            int h = p[0];\\n            int w = p[1];\\n            maxPrice[h][w] = p[2];\\n        }\\n        \\n        vector<vector<long long>> memo(m+1, vector<long long>(n+1, -1));\\n        return getResult(m, n, maxPrice, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getResult(int m, int n, const vector<vector<int>>& maxPrice, vector<vector<long long>>& memo) {\\n        if (memo[m][n] != -1) return memo[m][n];\\n        \\n        // option 1: just take the price for the whole piece\\n        long long price = maxPrice[m][n];\\n        \\n        for (int h = 1; h < m; ++h) {\\n            // option 2: make 1 horizontal cut, take 2 prices for the smaller pieces\\n            price = max(price, getResult(m-h, n, maxPrice, memo) + getResult(h, n, maxPrice, memo));\\n        }\\n        \\n        for (int w = 1; w < n; ++w) {\\n            // option 3: make 1 vertical cut, take 2 prices\\n            price = max(price, getResult(m, n - w, maxPrice, memo) + getResult(m, w, maxPrice, memo));\\n        }\\n        \\n        return memo[m][n] = price;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // pre-calculate array for fast lookup of \"price for piece of size h*w\"\\n        vector<vector<int>> maxPrice(m+1, vector<int>(n+1, 0));\\n        for (const vector<int>& p : prices) {\\n            int h = p[0];\\n            int w = p[1];\\n            maxPrice[h][w] = p[2];\\n        }\\n        \\n        vector<vector<long long>> memo(m+1, vector<long long>(n+1, -1));\\n        return getResult(m, n, maxPrice, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169003,
                "title": "c-with-explanation-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long dp[201][201], p[201][201];\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        memset(p,0,sizeof(p));\\n        for(auto & i:prices)\\n            p[i[0]][i[1]]=i[2];\\n        return helper(m,n); \\n    }\\n  long helper(int height,int width){\\n        if(dp[height][width]!=-1)\\n            return dp[height][width];\\n      // sell this whole piece  and get money\\n        long maxAmnt=p[height][width];\\n      // or cut into pieces and then sell\\n      // cut till half of height and width because of symmetry\\n      // cut along height\\n        for(int lowerHeight=1;lowerHeight<=height/2;lowerHeight++){\\n            int upperHeight=height-lowerHeight;\\n            long temp=helper(upperHeight,width) + helper(lowerHeight,width);\\n            maxAmnt=max(maxAmnt,temp);\\n        }\\n      \\n      //cut along width\\n        for(int leftWidth=1;leftWidth<=width/2;leftWidth++){\\n            int rightWidth=width-leftWidth;\\n            long temp=helper(height,rightWidth)+helper(height,leftWidth);\\n            maxAmnt=max(maxAmnt,temp);\\n        }   \\n        dp[height][width]=maxAmnt;\\n        return maxAmnt;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long dp[201][201], p[201][201];\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        memset(p,0,sizeof(p));\\n        for(auto & i:prices)\\n            p[i[0]][i[1]]=i[2];\\n        return helper(m,n); \\n    }\\n  long helper(int height,int width){\\n        if(dp[height][width]!=-1)\\n            return dp[height][width];\\n      // sell this whole piece  and get money\\n        long maxAmnt=p[height][width];\\n      // or cut into pieces and then sell\\n      // cut till half of height and width because of symmetry\\n      // cut along height\\n        for(int lowerHeight=1;lowerHeight<=height/2;lowerHeight++){\\n            int upperHeight=height-lowerHeight;\\n            long temp=helper(upperHeight,width) + helper(lowerHeight,width);\\n            maxAmnt=max(maxAmnt,temp);\\n        }\\n      \\n      //cut along width\\n        for(int leftWidth=1;leftWidth<=width/2;leftWidth++){\\n            int rightWidth=width-leftWidth;\\n            long temp=helper(height,rightWidth)+helper(height,leftWidth);\\n            maxAmnt=max(maxAmnt,temp);\\n        }   \\n        dp[height][width]=maxAmnt;\\n        return maxAmnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168973,
                "title": "bottom-up-with-explanation-o-n-3",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t// try cutting horizonally  and again vertically , take the maximum...\\n\\t\\t\\t// after half length of cut .. values are repeating..  \\n\\t\\t\\t// n^3\\n\\t\\t\\t// WxH   cut from i of width   WxH, ixH, (W-i)xH  take maximum of these three... \\n\\t\\t\\t// base cases are the prices given...\\n\\n\\t\\t\\t// mxn wood  hxw \\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1, vector<long long> (n+1, 0));\\n\\n\\t\\t\\tfor(vector<int> p: prices)\\n\\t\\t\\t\\tdp[p[0]][p[1]] = p[2];\\n\\n\\t\\t\\tfor(int h= 1; h<= m ; h++){\\n\\t\\t\\t\\tfor(int w = 1; w<=n; w++){\\n\\t\\t\\t\\t\\t// try every horizontal cut for wood hxw\\n\\t\\t\\t\\t\\tfor(int i = 1; i<= h/2; i++)\\n\\t\\t\\t\\t\\t\\tdp[h][w] = max(dp[h][w], dp[i][w]+dp[h-i][w]);\\n\\n\\t\\t\\t\\t\\t// now try every vertical cut for wood hxw\\n\\t\\t\\t\\t\\tfor(int j= 1; j<= w/2; j++)\\n\\t\\t\\t\\t\\t\\tdp[h][w] = max(dp[h][w], dp[h][j]+ dp[h][w-j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[m][n];    \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t// try cutting horizonally  and again vertically , take the maximum...\\n\\t\\t\\t// after half length of cut .. values are repeating..  \\n\\t\\t\\t// n^3\\n\\t\\t\\t// WxH   cut from i of width   WxH, ixH, (W-i)xH  take maximum of these three... \\n\\t\\t\\t// base cases are the prices given...\\n\\n\\t\\t\\t// mxn wood  hxw \\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1, vector<long long> (n+1, 0));\\n\\n\\t\\t\\tfor(vector<int> p: prices)\\n\\t\\t\\t\\tdp[p[0]][p[1]] = p[2];\\n\\n\\t\\t\\tfor(int h= 1; h<= m ; h++){\\n\\t\\t\\t\\tfor(int w = 1; w<=n; w++){\\n\\t\\t\\t\\t\\t// try every horizontal cut for wood hxw\\n\\t\\t\\t\\t\\tfor(int i = 1; i<= h/2; i++)\\n\\t\\t\\t\\t\\t\\tdp[h][w] = max(dp[h][w], dp[i][w]+dp[h-i][w]);\\n\\n\\t\\t\\t\\t\\t// now try every vertical cut for wood hxw\\n\\t\\t\\t\\t\\tfor(int j= 1; j<= w/2; j++)\\n\\t\\t\\t\\t\\t\\tdp[h][w] = max(dp[h][w], dp[h][j]+ dp[h][w-j]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2168899,
                "title": "python3-recursion-with-cache",
                "content": "Here is my recusrive solution with @cache-ing. The time complexity is O(m * n * max(m, n) + len(prices)) and we use O(m * n) memory\\nLet me know if you have questions!\\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        # Keep track of all prices available in a dict\\n        pr = {}\\n        for i in range(m + 1):\\n            for j in range(n + 1):\\n                pr[(i, j)] = 0\\n        for h, w, p in prices:\\n            if pr[(h, w)] < p:\\n                pr[(h, w)] = p\\n        \\n        @cache\\n        def helper(x, y):\\n            if x * y == 0:\\n                return 0\\n            t = pr[(x, y)]\\n            # cut horizontally\\n            for i in range(1, x // 2 + 1):\\n                t = max(t, helper(i, y) + helper(x - i, y))\\n            # cut vertically\\n            for j in range(1, y // 2 + 1):\\n                t = max(t, helper(x, j) + helper(x, y - j))\\n            return t\\n            \\n        return helper(m, n)\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        # Keep track of all prices available in a dict\\n        pr = {}\\n        for i in range(m + 1):\\n            for j in range(n + 1):\\n                pr[(i, j)] = 0\\n        for h, w, p in prices:\\n            if pr[(h, w)] < p:\\n                pr[(h, w)] = p\\n        \\n        @cache\\n        def helper(x, y):\\n            if x * y == 0:\\n                return 0\\n            t = pr[(x, y)]\\n            # cut horizontally\\n            for i in range(1, x // 2 + 1):\\n                t = max(t, helper(i, y) + helper(x - i, y))\\n            # cut vertically\\n            for j in range(1, y // 2 + 1):\\n                t = max(t, helper(x, j) + helper(x, y - j))\\n            return t\\n            \\n        return helper(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362382,
                "title": "c-dp-memorization-tabulation-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // long long dp[201][201],price[201][201];\\n    // long long solve(int m, int n){\\n    //     if(dp[m][n]!=-1){\\n    //         return dp[m][n];\\n    //     }\\n\\n    //     long long ans=0,tans1,tans2;\\n    //     if(price[m][n]!=-1){\\n    //         ans=price[m][n];\\n    //     }\\n    //     for(int x=1;x<m;x++){\\n    //         tans1=solve(x,n)+solve(m-x,n);\\n    //         ans=max(ans,tans1);\\n    //     }\\n\\n    //     for(int x=1;x<n;x++){\\n    //         tans1=solve(m,x)+solve(m,n-x);\\n    //         ans=max(ans,tans1);\\n    //     }\\n\\n    //     return dp[m][n]=ans;\\n    // }\\n\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        // memset(dp,-1,sizeof(dp));\\n        // memset(price,-1,sizeof(price));\\n\\n        for(int x=0;x<prices.size();x++){\\n            // price[prices[x][0]][prices[x][1]]=prices[x][2];\\n            dp[prices[x][0]][prices[x][1]]=prices[x][2];\\n        }\\n\\n        for(int x=1;x<=m;x++){\\n            for(int y=1;y<=n;y++){\\n                for(int z=1;z<=x/2;z++){\\n                    dp[x][y]=max(dp[x][y],(dp[z][y]+dp[x-z][y]));\\n                }\\n                for(int z=1;z<=y/2;z++){\\n                    dp[x][y]=max(dp[x][y],(dp[x][z]+dp[x][y-z]));\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n        // return solve(m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // long long dp[201][201],price[201][201];\\n    // long long solve(int m, int n){\\n    //     if(dp[m][n]!=-1){\\n    //         return dp[m][n];\\n    //     }\\n\\n    //     long long ans=0,tans1,tans2;\\n    //     if(price[m][n]!=-1){\\n    //         ans=price[m][n];\\n    //     }\\n    //     for(int x=1;x<m;x++){\\n    //         tans1=solve(x,n)+solve(m-x,n);\\n    //         ans=max(ans,tans1);\\n    //     }\\n\\n    //     for(int x=1;x<n;x++){\\n    //         tans1=solve(m,x)+solve(m,n-x);\\n    //         ans=max(ans,tans1);\\n    //     }\\n\\n    //     return dp[m][n]=ans;\\n    // }\\n\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        // memset(dp,-1,sizeof(dp));\\n        // memset(price,-1,sizeof(price));\\n\\n        for(int x=0;x<prices.size();x++){\\n            // price[prices[x][0]][prices[x][1]]=prices[x][2];\\n            dp[prices[x][0]][prices[x][1]]=prices[x][2];\\n        }\\n\\n        for(int x=1;x<=m;x++){\\n            for(int y=1;y<=n;y++){\\n                for(int z=1;z<=x/2;z++){\\n                    dp[x][y]=max(dp[x][y],(dp[z][y]+dp[x-z][y]));\\n                }\\n                for(int z=1;z<=y/2;z++){\\n                    dp[x][y]=max(dp[x][y],(dp[x][z]+dp[x][y-z]));\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n        // return solve(m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194125,
                "title": "python-fastest-soln-beats-98-in-time-97-in-space-dp",
                "content": "![image](https://assets.leetcode.com/users/images/015a1c04-eb75-41ce-aa7d-35c0971daa9c_1656140006.801418.png)\\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        price = [[0 for _ in range(n+1)] for _ in range(m+1)] \\n        for r, c, p in prices: price[r][c] = p\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)] \\n        for r in range(1, m+1):\\n            for c in range(1, n+1):\\n                result = price[r][c] \\n                for i in range(1, r//2+1): result = max(result, dp[r-i][c]+dp[i][c])\\n                for i in range(1, c//2+1): result = max(result, dp[r][c-i]+dp[r][i])\\n                dp[r][c] = result \\n        return dp[m][n]\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        price = [[0 for _ in range(n+1)] for _ in range(m+1)] \\n        for r, c, p in prices: price[r][c] = p\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)] \\n        for r in range(1, m+1):\\n            for c in range(1, n+1):\\n                result = price[r][c] \\n                for i in range(1, r//2+1): result = max(result, dp[r-i][c]+dp[i][c])\\n                for i in range(1, c//2+1): result = max(result, dp[r][c-i]+dp[r][i])\\n                dp[r][c] = result \\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184119,
                "title": "c-dynamic-programming-recursive",
                "content": "class Solution {\\npublic:\\n    \\n    // state is the row and column\\n    long long dp[201][201];\\n    map <pair<int,int>,long long> mp;\\n    \\n    // n rows and m columns (in question its m rows and n columns)\\n    long long rec(int n,int m){\\n        \\n        // checking if already computed\\n        if(dp[n][m] != -1) return dp[n][m];\\n        \\n        long long ans = 0;\\n        // if there is a price for rectangle nxm initialize ans with it\\n        if(mp.find({n,m}) != mp.end()) ans = mp[{n,m}];\\n        \\n        // trying to cut horizontally\\n        for(int mid = 0;mid<n-1;mid++){\\n        ans = max(ans,1LL*rec(mid+1,m) + 1LL*rec(n-mid-1,m));\\n        }\\n        \\n        // trying to cut vertically\\n        for(int mid = 0;mid<m-1;mid++){\\n        ans = max(ans,1LL*rec(n,mid+1)+1LL*rec(n,m-mid-1));\\n        }\\n        return dp[n][m] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // storing prices in a map\\n        for(auto v:prices){\\n            mp[{v[0],v[1]}] = v[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return rec(m,n);\\n    }\\n};``",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // state is the row and column\\n    long long dp[201][201];\\n    map <pair<int,int>,long long> mp;\\n    \\n    // n rows and m columns (in question its m rows and n columns)\\n    long long rec(int n,int m){\\n        \\n        // checking if already computed\\n        if(dp[n][m] != -1) return dp[n][m];\\n        \\n        long long ans = 0;\\n        // if there is a price for rectangle nxm initialize ans with it\\n        if(mp.find({n,m}",
                "codeTag": "Java"
            },
            {
                "id": 2172971,
                "title": "python-go-dp-w-backtracking-o-mn-m-n",
                "content": "*Python* solution\\n\\n```python\\ndef sellingWood(self, m, n, prices):\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n    for h, w, x in prices:\\n        dp[h][w] = x\\n    for i in range(m + 1):\\n        for j in range(n + 1):\\n            for h in range(i // 2 + 1):                           # help reduce TC to 1/2 w/ optimization\\n                                                                  # otherwise vulnerable to TLE\\n                dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\\n            for w in range(j // 2 + 1):                           # complement to above\\n                dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\\n    return dp[m][n]\\n```\\n\\n*Go* solution in 67ms\\n\\n```go\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n\\tdp := make([][]int64, m+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]int64, n+1)\\n\\t}\\n\\tfor _, p := range prices {\\n\\t\\tdp[p[0]][p[1]] = int64(p[2])\\n\\t}\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tfor h := 0; h <= i/2; h++ {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[h][j]+dp[i-h][j])\\n\\t\\t\\t}\\n\\t\\t\\tfor w := 0; w <= j/2; w++ {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i][w]+dp[i][j-w])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n]\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef sellingWood(self, m, n, prices):\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n    for h, w, x in prices:\\n        dp[h][w] = x\\n    for i in range(m + 1):\\n        for j in range(n + 1):\\n            for h in range(i // 2 + 1):                           # help reduce TC to 1/2 w/ optimization\\n                                                                  # otherwise vulnerable to TLE\\n                dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\\n            for w in range(j // 2 + 1):                           # complement to above\\n                dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\\n    return dp[m][n]\\n```\n```go\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n\\tdp := make([][]int64, m+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]int64, n+1)\\n\\t}\\n\\tfor _, p := range prices {\\n\\t\\tdp[p[0]][p[1]] = int64(p[2])\\n\\t}\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tfor h := 0; h <= i/2; h++ {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[h][j]+dp[i-h][j])\\n\\t\\t\\t}\\n\\t\\t\\tfor w := 0; w <= j/2; w++ {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i][w]+dp[i][j-w])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2172032,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:        \\n        @cache\\n        def dfs(h, w):\\n            return max(woods[h, w],\\n                       max(dfs(i, w) + dfs(h - i, w) for i in range(1, h // 2 + 1)) if h > 1 else 0,\\n                       max(dfs(h, i) + dfs(h, w - i) for i in range(1, w // 2 + 1)) if w > 1 else 0)\\n        \\n        woods = collections.defaultdict(int, {(h, w): p for h, w, p in prices})\\n\\n        return dfs(m, n)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:        \\n        @cache\\n        def dfs(h, w):\\n            return max(woods[h, w],\\n                       max(dfs(i, w) + dfs(h - i, w) for i in range(1, h // 2 + 1)) if h > 1 else 0,\\n                       max(dfs(h, i) + dfs(h, w - i) for i in range(1, w // 2 + 1)) if w > 1 else 0)\\n        \\n        woods = collections.defaultdict(int, {(h, w): p for h, w, p in prices})\\n\\n        return dfs(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169922,
                "title": "c-easy-understanding-clean-code-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    long long dp[205][205];\\n    long long fun(int row,int col){\\n        if(row <=0 or col<=0) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        long long ans=mp[{row,col}];\\n        //horizontal cut\\n        for(int i=1;i<row;i++){\\n            ans=max(ans,fun(i,col)+fun(row-i,col));\\n        }\\n        //vertical cut\\n        for(int i=1;i<col;i++){\\n            ans=max(ans,fun(row,i)+fun(row,col-i));\\n        }\\n        dp[row][col]=ans;\\n        return ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        for(auto it:prices){\\n            mp[{it[0],it[1]}]=it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        //dp[i][j] = maximum profit of i row and j col\\n        return fun(m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    long long dp[205][205];\\n    long long fun(int row,int col){\\n        if(row <=0 or col<=0) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        long long ans=mp[{row,col}];\\n        //horizontal cut\\n        for(int i=1;i<row;i++){\\n            ans=max(ans,fun(i,col)+fun(row-i,col));\\n        }\\n        //vertical cut\\n        for(int i=1;i<col;i++){\\n            ans=max(ans,fun(row,i)+fun(row,col-i));\\n        }\\n        dp[row][col]=ans;\\n        return ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        for(auto it:prices){\\n            mp[{it[0],it[1]}]=it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        //dp[i][j] = maximum profit of i row and j col\\n        return fun(m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168258,
                "title": "java-dynamic-programming-explained",
                "content": "This is a standard dynamic programming question.\\n\\nUse max[m, n] where max[m, n] is the maximum money you can earn from cutting an m x n piece of wood.\\n\\n**Base cases** in this question are found in prices array.\\n\\nFor the **recurrence relation**, we check all horizontal/vertical cut for each piece, m x n. Then we pick the largest price from the optimal subpieces. We use bottom-up dp to ensure that subpiecess are optimal before moving on to the larger pieces.\\n\\nmax[m, n] = **Maximum of**:\\n\\t\\t**horizontal**: { max[i][n] + max[m-i][n] } for all 1 <= i < m\\n\\t    **vertical**:   { max[m][j] + max[m][n-j] } for all 1 <= j < m\\n\\t   \\nEdge cases. It is possible that a single 2x2 might cost less than four 1x1 pieces.\\nTherefore, you should check each and every piece from 1x1. \\n\\n```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] price : prices) {\\n            dp[price[0]][price[1]] = price[2];\\n        }\\n        for (int i = 1; i < m+1; i++) {\\n            for (int j = 1; j < n+1; j++) {\\n                // all horizontal\\n                for (int k = 1; k <= i/2; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-k][j] + dp[k][j]);\\n                }\\n                // all vertical\\n                for (int k = 1; k <= j/2; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][j-k] + dp[i][k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```\\n**Time complexity** = O(mn(m+n))\\nCheck for each piece = O(mn)\\nFor each piece, check all cuts = O(m+n)\\n\\n**Space Complexity** = O(mn)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] price : prices) {\\n            dp[price[0]][price[1]] = price[2];\\n        }\\n        for (int i = 1; i < m+1; i++) {\\n            for (int j = 1; j < n+1; j++) {\\n                // all horizontal\\n                for (int k = 1; k <= i/2; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-k][j] + dp[k][j]);\\n                }\\n                // all vertical\\n                for (int k = 1; k <= j/2; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][j-k] + dp[i][k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200861,
                "title": "crisp-n-clear-o-n-javascript-memory-33-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nvar sellingWood = function(row, colum, prices) {\\n\\tconst dynamicProgramming = (function() {\\n\\t\\tconst config = {};\\n\\t\\tfor (const iterator of prices) {\\n\\t\\t\\tconst key = `${iterator[0]}_${iterator[1]}`;\\n\\t\\t\\tconfig[key] = iterator[2];\\n\\t\\t}\\n\\t\\treturn config;\\n\\t})();\\n\\tfor (let rowIndex = 1; rowIndex <= row; rowIndex++) {\\n\\t\\tfor (let columnIndex = 1; columnIndex <= colum; columnIndex++) {\\n\\t\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\t\\tfor (let horizontalIndex = 1; horizontalIndex <= columnIndex; horizontalIndex++) {\\n\\t\\t\\t\\tconst key1 = `${rowIndex}_${horizontalIndex}`;\\n\\t\\t\\t\\tconst key2 = `${rowIndex}_${columnIndex - horizontalIndex}`;\\n\\t\\t\\t\\tdynamicProgramming[key] = Math.max(\\n\\t\\t\\t\\t\\tdynamicProgramming[key] || 0,\\n\\t\\t\\t\\t\\t(dynamicProgramming[key1] || 0) + (dynamicProgramming[key2] || 0)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let verticalIndex = 1; verticalIndex <= rowIndex; verticalIndex++) {\\n\\t\\t\\t\\tconst key1 = `${verticalIndex}_${columnIndex}`;\\n\\t\\t\\t\\tconst key2 = `${rowIndex - verticalIndex}_${columnIndex}`;\\n\\t\\t\\t\\tdynamicProgramming[key] = Math.max(\\n\\t\\t\\t\\t\\tdynamicProgramming[key] || 0,\\n\\t\\t\\t\\t\\t(dynamicProgramming[key1] || 0) + (dynamicProgramming[key2] || 0)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tconst key = `${row}_${colum}`;\\n\\treturn dynamicProgramming[key];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sellingWood = function(row, colum, prices) {\\n\\tconst dynamicProgramming = (function() {\\n\\t\\tconst config = {};\\n\\t\\tfor (const iterator of prices) {\\n\\t\\t\\tconst key = `${iterator[0]}_${iterator[1]}`;\\n\\t\\t\\tconfig[key] = iterator[2];\\n\\t\\t}\\n\\t\\treturn config;\\n\\t})();\\n\\tfor (let rowIndex = 1; rowIndex <= row; rowIndex++) {\\n\\t\\tfor (let columnIndex = 1; columnIndex <= colum; columnIndex++) {\\n\\t\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\t\\tfor (let horizontalIndex = 1; horizontalIndex <= columnIndex; horizontalIndex++) {\\n\\t\\t\\t\\tconst key1 = `${rowIndex}_${horizontalIndex}`;\\n\\t\\t\\t\\tconst key2 = `${rowIndex}_${columnIndex - horizontalIndex}`;\\n\\t\\t\\t\\tdynamicProgramming[key] = Math.max(\\n\\t\\t\\t\\t\\tdynamicProgramming[key] || 0,\\n\\t\\t\\t\\t\\t(dynamicProgramming[key1] || 0) + (dynamicProgramming[key2] || 0)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let verticalIndex = 1; verticalIndex <= rowIndex; verticalIndex++) {\\n\\t\\t\\t\\tconst key1 = `${verticalIndex}_${columnIndex}`;\\n\\t\\t\\t\\tconst key2 = `${rowIndex - verticalIndex}_${columnIndex}`;\\n\\t\\t\\t\\tdynamicProgramming[key] = Math.max(\\n\\t\\t\\t\\t\\tdynamicProgramming[key] || 0,\\n\\t\\t\\t\\t\\t(dynamicProgramming[key1] || 0) + (dynamicProgramming[key2] || 0)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tconst key = `${row}_${colum}`;\\n\\treturn dynamicProgramming[key];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036060,
                "title": "simple-python-solution-with-explanation",
                "content": "# Approach\\n\\n* Price Map -> \\n\\n    Since prices is a list, it is costly to fetch the price of a specific height `h` and width `w`. \\n    Lets convert it to a map: `priceMap` where the first order key is height and second order key is width.\\n\\n    ```\\n    height: h1\\n    width: w1\\n    price: priceMap[h1][w1]\\n    ```\\n\\n* Recursive approach ->\\n\\n    Lets say we have a rectangle of height `h` and width `w`, \\n\\n    * first, lets check if there is any price in our `priceMap` for this rectangle configuration (or initialise it to zero)\\n    * now lets say we make a horizontal cut, so that it divides the rectangle in two rectangles:\\n    Rectangle 1: height: `h1`, width: `w`\\n    Rectangle 2: height: `h-h1`, width: `w`\\n\\n    \\n    * lets check where can we make a cut so that we get the maximum price, `h1` can be anywhere between `[1, h-1]` (inclusive)\\n      we will recursively check for each of this rectangle, and maximise the amount\\n        ```\\n        money = max(\\n            money,  \\n            rec(h1, w) + rec(h-h1, w)\\n        )\\n        ```\\n\\n    do the same vertically\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$  -> memoization and priceMap\\n\\n# Code\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n        priceMap = {}\\n        for p in prices:\\n            if p[0] in priceMap:\\n                priceMap[p[0]][p[1]] = p[2]\\n            else:\\n                priceMap[p[0]] = {p[1]: p[2]}\\n\\n        def getPrice(h, w):\\n            if h in priceMap and w in priceMap[h]:\\n                return priceMap[h][w]\\n            return 0\\n\\n        @cache\\n        def rec(h, w):\\n            money = getPrice(h, w)\\n\\n            # cut horizontal\\n            for i in range(1, h):\\n                money = max(money, rec(i, w) + rec(h - i, w))\\n\\n            # cut vertical\\n            for i in range(1, w):\\n                money = max(money, rec(h, i) + rec(h, w - i))\\n\\n            return money\\n\\n        return rec(m, n)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    height: h1\\n    width: w1\\n    price: priceMap[h1][w1]\\n    ```\n```\\n        money = max(\\n            money,  \\n            rec(h1, w) + rec(h-h1, w)\\n        )\\n        ```\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n        priceMap = {}\\n        for p in prices:\\n            if p[0] in priceMap:\\n                priceMap[p[0]][p[1]] = p[2]\\n            else:\\n                priceMap[p[0]] = {p[1]: p[2]}\\n\\n        def getPrice(h, w):\\n            if h in priceMap and w in priceMap[h]:\\n                return priceMap[h][w]\\n            return 0\\n\\n        @cache\\n        def rec(h, w):\\n            money = getPrice(h, w)\\n\\n            # cut horizontal\\n            for i in range(1, h):\\n                money = max(money, rec(i, w) + rec(h - i, w))\\n\\n            # cut vertical\\n            for i in range(1, w):\\n                money = max(money, rec(h, i) + rec(h, w - i))\\n\\n            return money\\n\\n        return rec(m, n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609208,
                "title": "dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long f(int m,int n,vector<vector<long long>>& maxPrice,vector<vector<long long>>&dp)\\n\\t\\t{\\n\\t\\t\\tif(dp[m][n]!=-1)\\n\\t\\t\\t\\treturn dp[m][n];\\n\\t\\t\\tlong long money=maxPrice[m][n];\\n\\t\\t\\t//horizontal cut\\n\\t\\t\\tfor(int h=1;h<m;h++)\\n\\t\\t\\t\\tmoney=max(money,f(m-h,n,maxPrice,dp)+f(h,n,maxPrice,dp));\\n\\n\\t\\t\\t//vertical\\n\\t\\t\\tfor(int v=1;v<n;v++)\\n\\t\\t\\t\\tmoney=max(money,f(m,n-v,maxPrice,dp)+f(m,v,maxPrice,dp));\\n\\n\\t\\t\\treturn dp[m][n]=money;\\n\\t\\t}\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) \\n\\t\\t{\\n\\t\\t\\tvector<vector<long long>> maxPrice(m+1, vector<long long>(n+1, 0));\\n\\t\\t\\tfor (auto p : prices) {\\n\\t\\t\\t\\tint h = p[0];\\n\\t\\t\\t\\tint w = p[1];\\n\\t\\t\\t\\tmaxPrice[h][w] = p[2];\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1, vector<long long>(n+1, -1));\\n\\t\\t\\treturn f(m,n,maxPrice,dp);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long f(int m,int n,vector<vector<long long>>& maxPrice,vector<vector<long long>>&dp)\\n\\t\\t{\\n\\t\\t\\tif(dp[m][n]!=-1)\\n\\t\\t\\t\\treturn dp[m][n];\\n\\t\\t\\tlong long money=maxPrice[m][n];\\n\\t\\t\\t//horizontal cut\\n\\t\\t\\tfor(int h=1;h<m;h++)\\n\\t\\t\\t\\tmoney=max(money,f(m-h,n,maxPrice,dp)+f(h,n,maxPrice,dp));\\n\\n\\t\\t\\t//vertical\\n\\t\\t\\tfor(int v=1;v<n;v++)\\n\\t\\t\\t\\tmoney=max(money,f(m,n-v,maxPrice,dp)+f(m,v,maxPrice,dp));\\n\\n\\t\\t\\treturn dp[m][n]=money;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2402901,
                "title": "c-dp-memoization",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[201][201];\\n\\t\\n    ll solve(int m, int n, unordered_map<string,ll> &price){\\n        if(m<=0 || n<=0) return 0;\\n        if(dp[m][n] != -1) return dp[m][n];\\n        \\n        string key = to_string(m)+\"#\"+to_string(n);\\n        \\n        ll ans = 0;\\n        if(price.find(key) != price.end()) ans = price[key];\\n   \\n        for(int i=1; i<=m/2; ++i){\\n            ans = max(ans, solve(i,n,price) + solve(m-i,n,price));\\n        }\\n        \\n        for(int j=1; j<=n/2; ++j){\\n            ans = max(ans, solve(m,n-j,price) + solve(m,j,price));\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n    \\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        ll sz = prices.size();\\n        unordered_map<string,ll> price;\\n        \\n        for(int i=0; i<sz; ++i){\\n            string key = to_string(prices[i][0])+\"#\"+to_string(prices[i][1]);\\n            price[key] = prices[i][2];\\n        }\\n        \\n        return solve(m,n,price);\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[201][201];\\n\\t\\n    ll solve(int m, int n, unordered_map<string,ll> &price){\\n        if(m<=0 || n<=0) return 0;\\n        if(dp[m][n] != -1) return dp[m][n];\\n        \\n        string key = to_string(m)+\"#\"+to_string(n);\\n        \\n        ll ans = 0;\\n        if(price.find(key) != price.end()) ans = price[key];\\n   \\n        for(int i=1; i<=m/2; ++i){\\n            ans = max(ans, solve(i,n,price) + solve(m-i,n,price));\\n        }\\n        \\n        for(int j=1; j<=n/2; ++j){\\n            ans = max(ans, solve(m,n-j,price) + solve(m,j,price));\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n    \\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        ll sz = prices.size();\\n        unordered_map<string,ll> price;\\n        \\n        for(int i=0; i<sz; ++i){\\n            string key = to_string(prices[i][0])+\"#\"+to_string(prices[i][1]);\\n            price[key] = prices[i][2];\\n        }\\n        \\n        return solve(m,n,price);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194345,
                "title": "python-bottom-up-dp-faster-than-99",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0]*(n+1) for _ in range(m+1)]\\n        for h, w, p in prices:\\n            dp[h][w] = p\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                v = max(dp[k][j] + dp[i - k][j] for k in range(1, i // 2 + 1)) if i > 1 else 0\\n                h = max(dp[i][k] + dp[i][j - k] for k in range(1, j // 2 + 1)) if j > 1 else 0\\n                dp[i][j] = max(dp[i][j], v, h)\\n        return dp[m][n]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0]*(n+1) for _ in range(m+1)]\\n        for h, w, p in prices:\\n            dp[h][w] = p\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                v = max(dp[k][j] + dp[i - k][j] for k in range(1, i // 2 + 1)) if i > 1 else 0\\n                h = max(dp[i][k] + dp[i][j - k] for k in range(1, j // 2 + 1)) if j > 1 else 0\\n                dp[i][j] = max(dp[i][j], v, h)\\n        return dp[m][n]",
                "codeTag": "Java"
            },
            {
                "id": 2193598,
                "title": "c-dp-easy-understanding",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\n    \\npublic:\\n    ll dp[201][201];\\n    \\n    ll mxprice(int rows,int columns,vector<vector<ll>>&price){\\n        if(dp[rows][columns]!=-1)\\n            return dp[rows][columns];\\n        \\n        if(rows==1 && columns==1){\\n            dp[rows][columns] = price[1][1];\\n            return price[1][1];\\n        }\\n        \\n        \\n        \\n        ll ans = price[rows][columns];\\n        for(int i=1;i<=rows/2;i++)\\n            ans = max(ans,mxprice(i,columns,price)+mxprice(rows-i,columns,price));\\n        \\n        for(int i=1;i<=columns/2;i++)\\n            ans = max(ans,mxprice(rows,i,price)+mxprice(rows,columns-i,price));\\n        dp[rows][columns] = ans;\\n        return ans;\\n    }\\n    \\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<vector<ll>>price(m+1,vector<ll>(n+1,0));\\n        \\n        for(auto it:prices)\\n            price[it[0]][it[1]] = it[2];\\n        \\n        return mxprice(m,n,price);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\n    \\npublic:\\n    ll dp[201][201];\\n    \\n    ll mxprice(int rows,int columns,vector<vector<ll>>&price){\\n        if(dp[rows][columns]!=-1)\\n            return dp[rows][columns];\\n        \\n        if(rows==1 && columns==1){\\n            dp[rows][columns] = price[1][1];\\n            return price[1][1];\\n        }\\n        \\n        \\n        \\n        ll ans = price[rows][columns];\\n        for(int i=1;i<=rows/2;i++)\\n            ans = max(ans,mxprice(i,columns,price)+mxprice(rows-i,columns,price));\\n        \\n        for(int i=1;i<=columns/2;i++)\\n            ans = max(ans,mxprice(rows,i,price)+mxprice(rows,columns-i,price));\\n        dp[rows][columns] = ans;\\n        return ans;\\n    }\\n    \\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<vector<ll>>price(m+1,vector<ll>(n+1,0));\\n        \\n        for(auto it:prices)\\n            price[it[0]][it[1]] = it[2];\\n        \\n        return mxprice(m,n,price);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173616,
                "title": "c-recursion-memorization-matrix-chain-multiplication-mcm-approach-100-faster",
                "content": "**Intuition :**\\nAs 1 <= m, n <= 200 and (1<= hi<=m , 1<=wi<=n)\\nTraversing and checking each possible horizontal cut from (1 to m-1) and each vertical cut (1 to n-1) takes O(m+n) time for each dp position. In worst case, we need to calculate it for every cell O(m*n)\\nTotal Time: **O(mn(m+n))**\\nTotal Space:  **O(m * n)**\\n\\nUsing memorization: We can further reduce the time by avoiding this calculation for already computer sizes to avoid repeated calculation. \\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> profit;\\n    vector<vector<long long>> dp;\\n    long long max(long long a,long long b){\\n        return a>b?a:b;\\n    }\\n    long long solve(int m,int n,vector<vector<int>>& prices){\\n        if(m<0||n<0)return 0;\\n        if(dp[m][n]>-1)return dp[m][n];\\n        dp[m][n]=profit[{m,n}];\\n        //checking each possible horizontal cut\\n        for(int h=1;h<m;h++){\\n            dp[m][n]=max(dp[m][n],solve(h,n,prices)+solve(m-h,n,prices));\\n        }\\n\\t\\t//checking each possible vertical cut\\n        for(int v=1;v<n;v++){\\n            dp[m][n]=max(dp[m][n],solve(m,v,prices)+solve(m,n-v,prices));\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        if(m==0&&n==0)return 0;\\n        dp.resize(m+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<=m;i++)dp[i][0]=0;\\n        for(int i=0;i<=n;i++)dp[0][i]=0;\\n        for(auto t:prices){\\n            profit[make_pair(t[0],t[1])]=t[2];\\n        }\\n        return solve(m,n,prices);\\n    }\\n};\\n```\\n**Note** :\\nDividing m size height into [1,m-1] cuts =[m-1,1] cuts\\nSo we can further optimize above code by looping in for only (1 to m/2) and (1 to n/2)\\n\\n**Runtime**: 747 ms, **faster than 100.00%** of C++ online submissions for Selling Pieces of Wood.\\n**Memory Usage**: 41 MB, **less than 100.00%** of C++ online submissions for Selling Pieces of Wood.\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> profit;\\n    vector<vector<long long>> dp;\\n    long long max(long long a,long long b){\\n        return a>b?a:b;\\n    }\\n    long long solve(int m,int n,vector<vector<int>>& prices){\\n        if(m<0||n<0)return 0;\\n        if(dp[m][n]>-1)return dp[m][n];\\n        dp[m][n]=profit[{m,n}];\\n        //checking each possible horizontal cut\\n        for(int h=1;h<=m/2;h++){\\n            dp[m][n]=max(dp[m][n],solve(h,n,prices)+solve(m-h,n,prices));\\n        }\\n\\t\\t//checking each possible vertical cut\\n        for(int v=1;v<=n/2;v++){\\n            dp[m][n]=max(dp[m][n],solve(m,v,prices)+solve(m,n-v,prices));\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        if(m==0&&n==0)return 0;\\n        dp.resize(m+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<=m;i++)dp[i][0]=0;\\n        for(int i=0;i<=n;i++)dp[0][i]=0;\\n        for(auto t:prices){\\n            profit[make_pair(t[0],t[1])]=t[2];\\n        }\\n        return solve(m,n,prices);\\n    }\\n};\\n```\\n\\n***Please upvote if you like the solution.***",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> profit;\\n    vector<vector<long long>> dp;\\n    long long max(long long a,long long b){\\n        return a>b?a:b;\\n    }\\n    long long solve(int m,int n,vector<vector<int>>& prices){\\n        if(m<0||n<0)return 0;\\n        if(dp[m][n]>-1)return dp[m][n];\\n        dp[m][n]=profit[{m,n}];\\n        //checking each possible horizontal cut\\n        for(int h=1;h<m;h++){\\n            dp[m][n]=max(dp[m][n],solve(h,n,prices)+solve(m-h,n,prices));\\n        }\\n\\t\\t//checking each possible vertical cut\\n        for(int v=1;v<n;v++){\\n            dp[m][n]=max(dp[m][n],solve(m,v,prices)+solve(m,n-v,prices));\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        if(m==0&&n==0)return 0;\\n        dp.resize(m+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<=m;i++)dp[i][0]=0;\\n        for(int i=0;i<=n;i++)dp[0][i]=0;\\n        for(auto t:prices){\\n            profit[make_pair(t[0],t[1])]=t[2];\\n        }\\n        return solve(m,n,prices);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> profit;\\n    vector<vector<long long>> dp;\\n    long long max(long long a,long long b){\\n        return a>b?a:b;\\n    }\\n    long long solve(int m,int n,vector<vector<int>>& prices){\\n        if(m<0||n<0)return 0;\\n        if(dp[m][n]>-1)return dp[m][n];\\n        dp[m][n]=profit[{m,n}];\\n        //checking each possible horizontal cut\\n        for(int h=1;h<=m/2;h++){\\n            dp[m][n]=max(dp[m][n],solve(h,n,prices)+solve(m-h,n,prices));\\n        }\\n\\t\\t//checking each possible vertical cut\\n        for(int v=1;v<=n/2;v++){\\n            dp[m][n]=max(dp[m][n],solve(m,v,prices)+solve(m,n-v,prices));\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        if(m==0&&n==0)return 0;\\n        dp.resize(m+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<=m;i++)dp[i][0]=0;\\n        for(int i=0;i<=n;i++)dp[0][i]=0;\\n        for(auto t:prices){\\n            profit[make_pair(t[0],t[1])]=t[2];\\n        }\\n        return solve(m,n,prices);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169159,
                "title": "javascript-dp-w-memoization",
                "content": "**Solution: DP w/ Memoization**\\n\\nFirst, change prices so that we can look up the price in `O(1)` time.\\nMemoize the result of each `(width, height)`, take the maximum earnings from a piece of wood with those measurements.\\n\\nGiven the width and height of a piece of wood, we can make horizontal or vetical cuts.\\n  Try each of the different sized horizontal and vertical cuts.\\n  Take the maximum price out of all the different ways of cutting.\\n\\nTime Complexity: `O(m * n * (m + n))` 810ms\\nSpace Complexity: `O(mn)` 63.6MB\\n```\\nvar sellingWood = function(m, n, prices) {\\n  let price = Array(n + 1).fill(0).map(() => Array(m + 1).fill(0));\\n  for (let [height, width, woodPrice] of prices) {\\n    price[width][height] = woodPrice;\\n  }\\n  let memo = Array(n + 1).fill(0).map(() => Array(m + 1).fill(-1));\\n  return dfs(n, m);\\n\\n  function dfs(width, height) {\\n    if (width === 0 || height === 0) return 0;\\n    if (memo[width][height] !== -1) return memo[width][height];\\n\\n    let ans = price[width][height];\\n    for (let h = 1; h <= Math.floor(height / 2); h++) {\\n      ans = Math.max(ans, dfs(width, h) + dfs(width, height - h));\\n    }\\n    for (let w = 1; w <= Math.floor(width / 2); w++) {\\n      ans = Math.max(ans, dfs(w, height) + dfs(width - w, height));\\n    }\\n    return memo[width][height] = ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sellingWood = function(m, n, prices) {\\n  let price = Array(n + 1).fill(0).map(() => Array(m + 1).fill(0));\\n  for (let [height, width, woodPrice] of prices) {\\n    price[width][height] = woodPrice;\\n  }\\n  let memo = Array(n + 1).fill(0).map(() => Array(m + 1).fill(-1));\\n  return dfs(n, m);\\n\\n  function dfs(width, height) {\\n    if (width === 0 || height === 0) return 0;\\n    if (memo[width][height] !== -1) return memo[width][height];\\n\\n    let ans = price[width][height];\\n    for (let h = 1; h <= Math.floor(height / 2); h++) {\\n      ans = Math.max(ans, dfs(width, h) + dfs(width, height - h));\\n    }\\n    for (let w = 1; w <= Math.floor(width / 2); w++) {\\n      ans = Math.max(ans, dfs(w, height) + dfs(width - w, height));\\n    }\\n    return memo[width][height] = ans;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168786,
                "title": "c-bottom-up-dynamic-programming-100-faster-100-mem-efficient",
                "content": "Most Important Observation -\\nIf we cut the wood into pieces we MUST cut entire height or width\\nEg: 2X3 --> 2X2 + 2X1 Entire height or width must be cut\\nLogic-\\nwe cut piece of i X j into smaller pieces -\\n\\tfor(int k=0;k<=j;++k){\\n                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[i][j-k]);//--->[2X4] = [2X1] + [2X3]\\n                }\\n\\t for(int k=0;k<=i;++k){\\n                    dp[i][j] = max(dp[i][j],dp[k][j]+dp[i-k][j]);//--->[3X4] = [1X4] + [2X4]\\n                }\\n \\n\\n```\\nclass Solution {\\npublic:\\n    long long sellingWood(int r, int c, vector<vector<int>>& prices) {\\n        long long dp[r+1][c+1];\\n        memset(dp,0,sizeof(dp));\\n        for(auto i:prices){\\n            dp[i[0]][i[1]] = i[2];\\n        }\\n        \\n        for(int i=1;i<=r;++i){\\n            for(int j=1;j<=c;++j){\\n                for(int k=0;k<=j;++k){\\n                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[i][j-k]);\\n                }\\n                for(int k=0;k<=i;++k){\\n                    dp[i][j] = max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n            }\\n        }\\n        return dp[r][c];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int r, int c, vector<vector<int>>& prices) {\\n        long long dp[r+1][c+1];\\n        memset(dp,0,sizeof(dp));\\n        for(auto i:prices){\\n            dp[i[0]][i[1]] = i[2];\\n        }\\n        \\n        for(int i=1;i<=r;++i){\\n            for(int j=1;j<=c;++j){\\n                for(int k=0;k<=j;++k){\\n                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[i][j-k]);\\n                }\\n                for(int k=0;k<=i;++k){\\n                    dp[i][j] = max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n            }\\n        }\\n        return dp[r][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168669,
                "title": "c-recursion-with-memoization",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<vector<ll>>mp;\\n    ll dp[205][205];\\n    ll rec(int m,int n)\\n    {\\n        if(m==1&&n==1)\\n        {\\n            return mp[m][n];\\n        }\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        ll ans=0;\\n        for(int i=1;i<m;i++)\\n        {\\n            int sum=0;\\n            \\n            ans=max(ans,max(mp[i][n],rec(i,n))+max(mp[m-i][n],rec(m-i,n)));\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int sum=0;\\n            ans=max(ans,max(mp[m][i],rec(m,i))+max(mp[m][n-i],rec(m,n-i)));\\n        }\\n        \\n        return dp[m][n]=ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        mp.clear();\\n        for(int i=0;i<=m+2;i++)\\n        {\\n            vector<ll>temp;\\n            for(int j=0;j<=n+2;j++)\\n                temp.push_back(0);\\n            mp.push_back(temp);\\n        }\\n        for(auto x : prices)\\n            mp[x[0]][x[1]]=x[2];\\n        \\n        ll ans=max(rec(m,n),mp[m][n]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<vector<ll>>mp;\\n    ll dp[205][205];\\n    ll rec(int m,int n)\\n    {\\n        if(m==1&&n==1)\\n        {\\n            return mp[m][n];\\n        }\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        ll ans=0;\\n        for(int i=1;i<m;i++)\\n        {\\n            int sum=0;\\n            \\n            ans=max(ans,max(mp[i][n],rec(i,n))+max(mp[m-i][n],rec(m-i,n)));\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int sum=0;\\n            ans=max(ans,max(mp[m][i],rec(m,i))+max(mp[m][n-i],rec(m,n-i)));\\n        }\\n        \\n        return dp[m][n]=ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        mp.clear();\\n        for(int i=0;i<=m+2;i++)\\n        {\\n            vector<ll>temp;\\n            for(int j=0;j<=n+2;j++)\\n                temp.push_back(0);\\n            mp.push_back(temp);\\n        }\\n        for(auto x : prices)\\n            mp[x[0]][x[1]]=x[2];\\n        \\n        ll ans=max(rec(m,n),mp[m][n]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168536,
                "title": "c-tabulation-bottom-up-optimized-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n           long long dp[201][201] = {};\\n        for (auto& p: prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n           long long dp[201][201] = {};\\n        for (auto& p: prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168389,
                "title": "rust-memoization",
                "content": "### This is what I have written during the contest, will impove later \\n\\n```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n    vec,\\n};\\n\\n\\n\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        let mut p: HashMap<(i32, i32), (i128, bool)> = HashMap::new();\\n\\n        p.insert((0, 0), (0, true));\\n        p.insert((1, 0), (0, true));\\n        p.insert((0, 1), (0, true));\\n        p.insert((1, 1), (0, true));\\n\\n        for price in &prices {\\n            let l = price[0];\\n            let h = price[1];\\n            let v = price[2] as i128;\\n            p.insert((l, h), (v, false));\\n        }\\n\\n        let mut prices = p;\\n\\n        // println!(\"{:?}\", prices);\\n\\n\\n        fn helper(\\n            m: i32,\\n            n: i32,\\n            prices: &mut HashMap<(i32, i32), (i128, bool)>,\\n        ) -> i128 {\\n            // println!(\"HELPER CALL m {} n {}\", m, n);\\n\\n            let mut res = 0;\\n            if let Some((r, finalized)) = prices.get(&(m, n)) {\\n                if *finalized {\\n                    return *r;\\n                }\\n                res = *r;\\n            }\\n\\n            // split m\\n            for i in 1..=(m - 1) {\\n                let sub_0 = helper(i, n, prices);\\n                let sub_1 = helper(m - i, n, prices);\\n                res = std::cmp::max(res, sub_0 + sub_1);\\n            }\\n\\n            // split n\\n            for i in 1..=(n - 1) {\\n                let sub_0 = helper(m, i, prices);\\n                let sub_1 = helper(m, n - i, prices);\\n                res = std::cmp::max(res, sub_0 + sub_1);\\n            }\\n\\n            // println!(\"HEPER m {} n {} res {} price {:?}\", m, n, res, &prices);\\n\\n            prices.insert((m, n), (res, true));\\n            res\\n        }\\n\\n        // println!(\"{:?}\", &prices);\\n\\n        helper(m, n, &mut prices) as i64\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n    vec,\\n};\\n\\n\\n\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        let mut p: HashMap<(i32, i32), (i128, bool)> = HashMap::new();\\n\\n        p.insert((0, 0), (0, true));\\n        p.insert((1, 0), (0, true));\\n        p.insert((0, 1), (0, true));\\n        p.insert((1, 1), (0, true));\\n\\n        for price in &prices {\\n            let l = price[0];\\n            let h = price[1];\\n            let v = price[2] as i128;\\n            p.insert((l, h), (v, false));\\n        }\\n\\n        let mut prices = p;\\n\\n        // println!(\"{:?}\", prices);\\n\\n\\n        fn helper(\\n            m: i32,\\n            n: i32,\\n            prices: &mut HashMap<(i32, i32), (i128, bool)>,\\n        ) -> i128 {\\n            // println!(\"HELPER CALL m {} n {}\", m, n);\\n\\n            let mut res = 0;\\n            if let Some((r, finalized)) = prices.get(&(m, n)) {\\n                if *finalized {\\n                    return *r;\\n                }\\n                res = *r;\\n            }\\n\\n            // split m\\n            for i in 1..=(m - 1) {\\n                let sub_0 = helper(i, n, prices);\\n                let sub_1 = helper(m - i, n, prices);\\n                res = std::cmp::max(res, sub_0 + sub_1);\\n            }\\n\\n            // split n\\n            for i in 1..=(n - 1) {\\n                let sub_0 = helper(m, i, prices);\\n                let sub_1 = helper(m, n - i, prices);\\n                res = std::cmp::max(res, sub_0 + sub_1);\\n            }\\n\\n            // println!(\"HEPER m {} n {} res {} price {:?}\", m, n, res, &prices);\\n\\n            prices.insert((m, n), (res, true));\\n            res\\n        }\\n\\n        // println!(\"{:?}\", &prices);\\n\\n        helper(m, n, &mut prices) as i64\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168311,
                "title": "c-topdown-bottom-dp",
                "content": "\\nThis is a pretty good question that bottom up DP is better than top down DP.\\nReason is that some piece of wood that already has a price in prices array, may have better price if we cut it into smaller pieces.  \\nIf we use topdown approach, we need another 2d array to store the prices (or map).\\nIf we use bottom up , it is more natural.\\nTo cut a piece of wood, you must make a vertical or horizontal cut across the\\xA0entire\\xA0height or width of the piece, this simply the question, the calculation of status is limited to O( max(n , m))\\nSo total time O(n * m * max(n , m)), space (n * m)\\n\\n\\nTopdown \\n==================================\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    vector<vector<long long>> dp1;\\n    long long dfs(int x, int y) {\\n        if (dp1[x][y] != -1) return dp1[x][y];\\n        long long cur = dp[x][y];\\n        for (int i = 1; i <= x - i; i++) cur = max(cur, dfs(i, y) + dfs(x - i, y));      \\n        for (int j = 1; j <= y - j; j++) cur = max(cur, dfs(x, j) + dfs(x, y - j));\\n        dp1[x][y] = cur;\\n        return cur;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, 0));\\n        dp1 = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));\\n        for (auto& p : prices) dp[p[0]][p[1]] = p[2];\\n        return dfs(n, m);\\n    }\\n};\\n```\\n\\n\\nBottom up\\n=================================================================\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<long long>> dp;\\n    long long dfs(int x, int y) {\\n        if (dp[x][y] != -1) return dp[x][y];\\n        long long cur = 0;\\n        for (int i = 1; i <= x - i; i++) {\\n            long long a =  dfs(i, y);\\n            long long b = dfs(x - i, y);\\n            cur = max(cur, a + b);\\n        }\\n        \\n        for (int j = 1; j <= y - j; j++) {\\n            long long a = dfs(x, j);\\n            long long b = dfs(x, y - j);\\n            cur = max(cur, a + b);\\n        }\\n        dp[x][y] = cur;\\n        return cur;\\n    }\\n    long long sellingWood(int n1, int m1, vector<vector<int>>& prices) {\\n        n = n1;\\n        m = m1;\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));\\n        for (auto& p : prices) dp[p[0]][p[1]] = p[2];\\n        for (int i = 0; i < n; i++) dp[i][0] = 0;\\n        for (int j = 0; j < m; j++) dp[0][j] = 0;\\n        if (dp[1][1] == -1) dp[1][1] = 0;\\n        \\n        for (int x = 1; x <= n; x++) {\\n            for (int y = 1; y <= m; y++) {\\n                long long cur = dp[x][y];\\n                dp[x][y] = -1;\\n                long long b = dfs(x, y);\\n                dp[x][y] = max(cur, b);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    vector<vector<long long>> dp1;\\n    long long dfs(int x, int y) {\\n        if (dp1[x][y] != -1) return dp1[x][y];\\n        long long cur = dp[x][y];\\n        for (int i = 1; i <= x - i; i++) cur = max(cur, dfs(i, y) + dfs(x - i, y));      \\n        for (int j = 1; j <= y - j; j++) cur = max(cur, dfs(x, j) + dfs(x, y - j));\\n        dp1[x][y] = cur;\\n        return cur;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, 0));\\n        dp1 = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));\\n        for (auto& p : prices) dp[p[0]][p[1]] = p[2];\\n        return dfs(n, m);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<long long>> dp;\\n    long long dfs(int x, int y) {\\n        if (dp[x][y] != -1) return dp[x][y];\\n        long long cur = 0;\\n        for (int i = 1; i <= x - i; i++) {\\n            long long a =  dfs(i, y);\\n            long long b = dfs(x - i, y);\\n            cur = max(cur, a + b);\\n        }\\n        \\n        for (int j = 1; j <= y - j; j++) {\\n            long long a = dfs(x, j);\\n            long long b = dfs(x, y - j);\\n            cur = max(cur, a + b);\\n        }\\n        dp[x][y] = cur;\\n        return cur;\\n    }\\n    long long sellingWood(int n1, int m1, vector<vector<int>>& prices) {\\n        n = n1;\\n        m = m1;\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));\\n        for (auto& p : prices) dp[p[0]][p[1]] = p[2];\\n        for (int i = 0; i < n; i++) dp[i][0] = 0;\\n        for (int j = 0; j < m; j++) dp[0][j] = 0;\\n        if (dp[1][1] == -1) dp[1][1] = 0;\\n        \\n        for (int x = 1; x <= n; x++) {\\n            for (int y = 1; y <= m; y++) {\\n                long long cur = dp[x][y];\\n                dp[x][y] = -1;\\n                long long b = dfs(x, y);\\n                dp[x][y] = max(cur, b);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168137,
                "title": "knapsack-dp",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    public long helper(long[][] max, int m, int n, Long[][] ddp) {\\n        if (ddp[m][n] != null) return ddp[m][n];\\n        ddp[m][n] = max[m][n];\\n        for (int i = 1; i < m; i++) {\\n            ddp[m][n] = Math.max(ddp[m][n], helper(max, i, n, ddp) + helper(max, m-i, n, ddp));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            ddp[m][n] = Math.max(ddp[m][n], helper(max, m, i, ddp) + helper(max, m, n-i, ddp));\\n        }\\n        return ddp[m][n];\\n    }\\n\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] max = new long[m+3][n+1];\\n        Arrays.sort(prices, (a,b)->(a[0]-b[0]));\\n        long[] dp = new long[n+1];\\n        int k = 0;\\n        for (int i = 1; i <= m; i++) {\\n            while (k < prices.length && prices[k][0] <= i) {\\n                for (int p = prices[k][1]; p <= n; p++) {\\n                    dp[p] = Math.max(dp[p], dp[p-prices[k][1]]+prices[k][2]);\\n                }\\n                k++;\\n            }\\n            for (int j = 0; j <= n; j++) max[i][j] = dp[j];\\n        }\\n         \\n        Long[][] ddp = new Long[m+3][n+1];\\n\\n        return helper(max, m, n, ddp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    public long helper(long[][] max, int m, int n, Long[][] ddp) {\\n        if (ddp[m][n] != null) return ddp[m][n];\\n        ddp[m][n] = max[m][n];\\n        for (int i = 1; i < m; i++) {\\n            ddp[m][n] = Math.max(ddp[m][n], helper(max, i, n, ddp) + helper(max, m-i, n, ddp));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            ddp[m][n] = Math.max(ddp[m][n], helper(max, m, i, ddp) + helper(max, m, n-i, ddp));\\n        }\\n        return ddp[m][n];\\n    }\\n\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] max = new long[m+3][n+1];\\n        Arrays.sort(prices, (a,b)->(a[0]-b[0]));\\n        long[] dp = new long[n+1];\\n        int k = 0;\\n        for (int i = 1; i <= m; i++) {\\n            while (k < prices.length && prices[k][0] <= i) {\\n                for (int p = prices[k][1]; p <= n; p++) {\\n                    dp[p] = Math.max(dp[p], dp[p-prices[k][1]]+prices[k][2]);\\n                }\\n                k++;\\n            }\\n            for (int j = 0; j <= n; j++) max[i][j] = dp[j];\\n        }\\n         \\n        Long[][] ddp = new Long[m+3][n+1];\\n\\n        return helper(max, m, n, ddp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168129,
                "title": "java-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        Long[][] dp = new Long[m + 1][n + 1];\\n        dp[0][0] = 0L;\\n        HashMap<Integer, HashMap<Integer, Long>> heightToWidthToPrice = new HashMap<Integer, HashMap<Integer, Long>>();\\n        for(int[] price : prices) {\\n            HashMap<Integer, Long> widthToPrice = heightToWidthToPrice.get(price[0]);\\n            if(widthToPrice == null) {\\n                widthToPrice = new HashMap<>();\\n                heightToWidthToPrice.put(price[0], widthToPrice);\\n            }\\n            \\n            widthToPrice.put(price[1], (long)price[2]);\\n        }\\n        \\n        return dfs(dp, m, n, heightToWidthToPrice);\\n    }\\n    \\n    private long dfs(Long[][] dp, int m, int n, HashMap<Integer, HashMap<Integer, Long>> heightToWidthToPrice) {\\n        if(dp[m][n] != null) {\\n            return dp[m][n];\\n        }\\n        \\n        dp[m][n] = 0L;\\n        HashMap<Integer, Long> widthToPrice = heightToWidthToPrice.get(m);\\n        if(widthToPrice != null) {\\n            dp[m][n] = widthToPrice.getOrDefault(n, 0L);\\n        }\\n        \\n        long candidate  = 0;\\n        for(int i = 1; i <m; ++i) {\\n            candidate = dfs(dp, i, n, heightToWidthToPrice) + \\n                dfs(dp, m-i, n, heightToWidthToPrice);\\n            dp[m][n] = Math.max(dp[m][n], candidate);\\n        }\\n        \\n        for(int j = 1; j < n; ++j) {\\n            candidate = dfs(dp, m, j, heightToWidthToPrice) + \\n                dfs(dp, m, n-j, heightToWidthToPrice);\\n            dp[m][n] = Math.max(dp[m][n], candidate);\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        Long[][] dp = new Long[m + 1][n + 1];\\n        dp[0][0] = 0L;\\n        HashMap<Integer, HashMap<Integer, Long>> heightToWidthToPrice = new HashMap<Integer, HashMap<Integer, Long>>();\\n        for(int[] price : prices) {\\n            HashMap<Integer, Long> widthToPrice = heightToWidthToPrice.get(price[0]);\\n            if(widthToPrice == null) {\\n                widthToPrice = new HashMap<>();\\n                heightToWidthToPrice.put(price[0], widthToPrice);\\n            }\\n            \\n            widthToPrice.put(price[1], (long)price[2]);\\n        }\\n        \\n        return dfs(dp, m, n, heightToWidthToPrice);\\n    }\\n    \\n    private long dfs(Long[][] dp, int m, int n, HashMap<Integer, HashMap<Integer, Long>> heightToWidthToPrice) {\\n        if(dp[m][n] != null) {\\n            return dp[m][n];\\n        }\\n        \\n        dp[m][n] = 0L;\\n        HashMap<Integer, Long> widthToPrice = heightToWidthToPrice.get(m);\\n        if(widthToPrice != null) {\\n            dp[m][n] = widthToPrice.getOrDefault(n, 0L);\\n        }\\n        \\n        long candidate  = 0;\\n        for(int i = 1; i <m; ++i) {\\n            candidate = dfs(dp, i, n, heightToWidthToPrice) + \\n                dfs(dp, m-i, n, heightToWidthToPrice);\\n            dp[m][n] = Math.max(dp[m][n], candidate);\\n        }\\n        \\n        for(int j = 1; j < n; ++j) {\\n            candidate = dfs(dp, m, j, heightToWidthToPrice) + \\n                dfs(dp, m, n-j, heightToWidthToPrice);\\n            dp[m][n] = Math.max(dp[m][n], candidate);\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168110,
                "title": "easy-dynamic-programming-solution-c",
                "content": "```C++\\nclass Solution {\\n    long long dp[202][202];\\n    long long c[202][202];\\n\\n    long long helper(int n, int m) {\\n        if(dp[n][m] != -1) return dp[n][m];\\n        long long& res = dp[n][m] = c[n][m];\\n        for(int i = 1; i < n; i++) { // divide with row\\n            res = max(res, helper(i,m) + helper(n-i, m));\\n        }\\n        for(int i = 1; i < m; i++) { // divide with col\\n            res = max(res, helper(n,i) + helper(n,m-i));\\n        }\\n        return res;\\n    }\\npublic:\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        memset(dp, -1, sizeof dp);\\n        memset(c, 0, sizeof c);\\n        for(auto& p : prices) {\\n            long long y = p[0], x = p[1], w = p[2];\\n            c[y][x] = max(c[y][x], w);\\n        }\\n\\n        return helper(n,m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    long long dp[202][202];\\n    long long c[202][202];\\n\\n    long long helper(int n, int m) {\\n        if(dp[n][m] != -1) return dp[n][m];\\n        long long& res = dp[n][m] = c[n][m];\\n        for(int i = 1; i < n; i++) { // divide with row\\n            res = max(res, helper(i,m) + helper(n-i, m));\\n        }\\n        for(int i = 1; i < m; i++) { // divide with col\\n            res = max(res, helper(n,i) + helper(n,m-i));\\n        }\\n        return res;\\n    }\\npublic:\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        memset(dp, -1, sizeof dp);\\n        memset(c, 0, sizeof c);\\n        for(auto& p : prices) {\\n            long long y = p[0], x = p[1], w = p[2];\\n            c[y][x] = max(c[y][x], w);\\n        }\\n\\n        return helper(n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086460,
                "title": "dart",
                "content": "# Code\\n```\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int sellingWood(final int M, final int N, List<List<int>> prices) {\\n    final memo = List.generate(M + 1, (_) => List.filled(N + 1, 0));\\n    for (final price in prices) {\\n      final int h = price[0], w = price[1], profit = price[2];\\n      memo[h][w] = profit;\\n    }\\n    \\n    final vis = List.generate(M + 1, (_) => List.filled(N + 1, false));\\n\\n    int dfs(final int height, final int width) {\\n      if (height == 0 || width == 0) return 0;\\n      if (vis[height][width]) return memo[height][width];\\n      vis[height][width] = true;\\n      \\n      var tmp = memo[height][width];\\n      for (int left = 1; left < height; left++)\\n        tmp = max(tmp, dfs(left, width) + dfs(height - left, width));\\n      \\n      for (int left = 1; left < width; left++)\\n        tmp = max(tmp, dfs(height, left) + dfs(height, width - left));\\n\\n      memo[height][width] = tmp;\\n      return memo[height][width];\\n    }\\n\\n    return dfs(M, N);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int sellingWood(final int M, final int N, List<List<int>> prices) {\\n    final memo = List.generate(M + 1, (_) => List.filled(N + 1, 0));\\n    for (final price in prices) {\\n      final int h = price[0], w = price[1], profit = price[2];\\n      memo[h][w] = profit;\\n    }\\n    \\n    final vis = List.generate(M + 1, (_) => List.filled(N + 1, false));\\n\\n    int dfs(final int height, final int width) {\\n      if (height == 0 || width == 0) return 0;\\n      if (vis[height][width]) return memo[height][width];\\n      vis[height][width] = true;\\n      \\n      var tmp = memo[height][width];\\n      for (int left = 1; left < height; left++)\\n        tmp = max(tmp, dfs(left, width) + dfs(height - left, width));\\n      \\n      for (int left = 1; left < width; left++)\\n        tmp = max(tmp, dfs(height, left) + dfs(height, width - left));\\n\\n      memo[height][width] = tmp;\\n      return memo[height][width];\\n    }\\n\\n    return dfs(M, N);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947002,
                "title": "mcm-bottom-up-dp-2d-matrix-tc-o-m-n-n-sc-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMCM -VARIATION IN DP\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote me please.png](https://assets.leetcode.com/users/images/72f77fbd-e160-495e-93fc-8f0d1a1d23a1_1692728697.3980412.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:  \\n    long long sellingWood(int m, int n, vector<vector<int>>& p) {\\n        long long  dp[201][201];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<p.size();++i)\\n        {\\n           for(int j=0;j<2;++j)\\n           {\\n               dp[p[i][0]][p[i][1]]=p[i][2];\\n           }\\n        }\\n        \\n         for(int i=1;i<=m;++i)\\n         {\\n             for(int j=1;j<=n;++j)\\n             {\\n                for(int k=0;k<=i;k++)\\n                {\\n                  dp[i][j]=max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n                for(int l=0; l<=j;++l)\\n                {\\n                     dp[i][j]=max(dp[i][j],dp[i][l]+dp[i][j-l]);\\n                     \\n                }\\n                \\n                \\n             }\\n         }\\n        \\n          \\n         return dp[m][n];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    long long sellingWood(int m, int n, vector<vector<int>>& p) {\\n        long long  dp[201][201];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<p.size();++i)\\n        {\\n           for(int j=0;j<2;++j)\\n           {\\n               dp[p[i][0]][p[i][1]]=p[i][2];\\n           }\\n        }\\n        \\n         for(int i=1;i<=m;++i)\\n         {\\n             for(int j=1;j<=n;++j)\\n             {\\n                for(int k=0;k<=i;k++)\\n                {\\n                  dp[i][j]=max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n                for(int l=0; l<=j;++l)\\n                {\\n                     dp[i][j]=max(dp[i][j],dp[i][l]+dp[i][j-l]);\\n                     \\n                }\\n                \\n                \\n             }\\n         }\\n        \\n          \\n         return dp[m][n];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933299,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int m,int n,vector<vector<int>>&p,vector<vector<long long>>&dp){\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        long long price=p[m][n];\\n        for(int i=1;i<m;i++) price=max(price,solve(m-i,n,p,dp)+solve(i,n,p,dp));\\n        for(int i=1;i<n;i++) price=max(price,solve(m,n-i,p,dp)+solve(m,i,p,dp));\\n        return dp[m][n]=price;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        vector<vector<int>>p(m+1,vector<int>(n+1,0));\\n        for(int i=0;i<prices.size();i++) p[prices[i][0]][prices[i][1]]=prices[i][2];\\n        vector<vector<long long>>dp(m+1,vector<long long>(n+1,-1));\\n        return solve(m,n,p,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int m,int n,vector<vector<int>>&p,vector<vector<long long>>&dp){\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        long long price=p[m][n];\\n        for(int i=1;i<m;i++) price=max(price,solve(m-i,n,p,dp)+solve(i,n,p,dp));\\n        for(int i=1;i<n;i++) price=max(price,solve(m,n-i,p,dp)+solve(m,i,p,dp));\\n        return dp[m][n]=price;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        vector<vector<int>>p(m+1,vector<int>(n+1,0));\\n        for(int i=0;i<prices.size();i++) p[prices[i][0]][prices[i][1]]=prices[i][2];\\n        vector<vector<long long>>dp(m+1,vector<long long>(n+1,-1));\\n        return solve(m,n,p,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918801,
                "title": "bottom-up-dp-go",
                "content": "# Complexity\\n- Time complexity:\\nO(m\\\\*n\\\\*max(m,n))\\n\\n- Space complexity:\\nO(m\\\\*n)\\n\\n# Code\\n```\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n\\td := make([][]int64, m+1)\\n\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\td[i] = make([]int64, n+1)\\n\\t}\\n\\n\\tfor _, price := range prices {\\n\\t\\ti := price[0]\\n\\t\\tj := price[1]\\n\\t\\tcost := int64(price[2])\\n\\t\\tif i <= m && j <= n {\\n\\t\\t\\td[i][j] = max(d[i][j], cost)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 1; i <= m; i++ {\\n\\t\\tfor j := 1; j <= n; j++ {\\n\\t\\t\\tfor k := 1; k < j; k++ {\\n\\t\\t\\t\\td[i][j] = max(d[i][j], d[i][k]+d[i][j-k])\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor k := 1; k < i; k++ {\\n\\t\\t\\t\\td[i][j] = max(d[i][j], d[k][j]+d[i-k][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[m][n]\\n}\\n\\nfunc max(a, b int64) int64 {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n\\td := make([][]int64, m+1)\\n\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\td[i] = make([]int64, n+1)\\n\\t}\\n\\n\\tfor _, price := range prices {\\n\\t\\ti := price[0]\\n\\t\\tj := price[1]\\n\\t\\tcost := int64(price[2])\\n\\t\\tif i <= m && j <= n {\\n\\t\\t\\td[i][j] = max(d[i][j], cost)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 1; i <= m; i++ {\\n\\t\\tfor j := 1; j <= n; j++ {\\n\\t\\t\\tfor k := 1; k < j; k++ {\\n\\t\\t\\t\\td[i][j] = max(d[i][j], d[i][k]+d[i][j-k])\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor k := 1; k < i; k++ {\\n\\t\\t\\t\\td[i][j] = max(d[i][j], d[k][j]+d[i-k][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[m][n]\\n}\\n\\nfunc max(a, b int64) int64 {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896537,
                "title": "simple-2d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        \\n        int row = m;\\n        int col = n;\\n\\n        int price_size = prices.size();\\n\\n\\n        long long cost[row][col];\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                cost[i][j] = 0;\\n            }\\n        }\\n\\n        for(int i = 0; i < price_size; i++) {\\n            \\n            int h = prices[i][0];\\n            int w = prices[i][1];\\n            int price = prices[i][2];\\n\\n\\n            cost[h - 1][w - 1] = price;\\n        \\n        }\\n\\n        long long dp[row][col];\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                dp[i][j] = 0;\\n            }\\n        }\\n\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n\\n                int left_col = 0;\\n                int right_col = j - 1;\\n\\n                while(left_col <= right_col) {\\n                    dp[i][j] = max(dp[i][j], dp[i][left_col] + dp[i][right_col]);\\n                    left_col++;\\n                    right_col--;\\n                }\\n\\n                int top_row = 0;\\n                int bottom_row = i - 1;\\n\\n\\n                while(top_row <= bottom_row) {\\n                    dp[i][j] = max(dp[i][j], dp[top_row][j] + dp[bottom_row][j]);\\n                    top_row++;\\n                    bottom_row--;\\n                }\\n\\n\\n                dp[i][j] = max(dp[i][j], cost[i][j]);\\n            }\\n        }\\n\\n\\n\\n        return dp[row - 1][col - 1];\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        \\n        int row = m;\\n        int col = n;\\n\\n        int price_size = prices.size();\\n\\n\\n        long long cost[row][col];\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                cost[i][j] = 0;\\n            }\\n        }\\n\\n        for(int i = 0; i < price_size; i++) {\\n            \\n            int h = prices[i][0];\\n            int w = prices[i][1];\\n            int price = prices[i][2];\\n\\n\\n            cost[h - 1][w - 1] = price;\\n        \\n        }\\n\\n        long long dp[row][col];\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                dp[i][j] = 0;\\n            }\\n        }\\n\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n\\n                int left_col = 0;\\n                int right_col = j - 1;\\n\\n                while(left_col <= right_col) {\\n                    dp[i][j] = max(dp[i][j], dp[i][left_col] + dp[i][right_col]);\\n                    left_col++;\\n                    right_col--;\\n                }\\n\\n                int top_row = 0;\\n                int bottom_row = i - 1;\\n\\n\\n                while(top_row <= bottom_row) {\\n                    dp[i][j] = max(dp[i][j], dp[top_row][j] + dp[bottom_row][j]);\\n                    top_row++;\\n                    bottom_row--;\\n                }\\n\\n\\n                dp[i][j] = max(dp[i][j], cost[i][j]);\\n            }\\n        }\\n\\n\\n\\n        return dp[row - 1][col - 1];\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837327,
                "title": "rust-top-down-dp-binary-search",
                "content": "# Intuition\\n\\nSplit this problem into smaller sub-problems. For a piece of wood, we can\\n\\n1. Sell it as-is (if possible).\\n2. Cut it horizontally and sell two pieces separately.\\n3. Cut it vertically and sell two pieces separately.\\n\\nThe maximum money we can gain is the maximum value between the above 3.\\n\\n# Approach\\n\\nThe reality is a bit more complicated. How much should we cut? Turned out it doesn\\'t make any sense to cut out pieces that are *too small to sell*. It makes more sense to cut with width/height that fits given dimensions. If we can only sell in sizes of `[5, 5]` or `[7, 7]`, it only makes sense to cut with length `5` or `7`.\\n\\nTo check if a piece of wood can be sold as-is, we can use a hash... We can sort, and do binary search on the given array!!\\n\\n# Code\\n```\\npub struct DP {\\n    vec: Vec<([usize; 2], usize)>,\\n    m_max: usize, n_max: usize,\\n\\n    map_0: Vec<usize>,\\n    map_1: Vec<usize>,\\n\\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(vec: Vec<([usize; 2], usize)>, m_max: usize, n_max: usize) -> Self {\\n        let mut map_0 = vec.iter()\\n            .map(|&([v0, v1], w)| v0)\\n            .collect::<Vec<_>>();\\n        map_0.sort_unstable();\\n        map_0.dedup();\\n\\n        let mut map_1 = vec.iter()\\n            .map(|&([v0, v1], w)| v1)\\n            .collect::<Vec<_>>();\\n        map_1.sort_unstable();\\n        map_1.dedup();\\n\\n        let memo = vec![vec![None; n_max + 1]; m_max + 1];\\n\\n        Self {\\n            vec,\\n            m_max, n_max,\\n            map_0, map_1,\\n            memo\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, m: usize, n: usize) -> usize {\\n        if m > self.m_max { return usize::MIN; }\\n        if n > self.n_max { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[m][n] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(m, n);\\n        self.memo[m][n] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, m: usize, n: usize) -> usize {\\n        if m < 1 { return usize::MIN; }\\n        if n < 1 { return usize::MIN; } // nothing to cut\\n\\n        let mut ret = usize::MIN;\\n\\n        if let Some(ptr) = self.vec.binary_search_by_key(\\n            &[m, n], |&(v, _)| v\\n        ).ok() { // sell as-is\\n            ret = ret.max(self.vec[ptr].1);\\n        }\\n\\n        let ptr_0 = self.map_0.partition_point(|&e| e < m);\\n        for ptr in (0..ptr_0).rev() {\\n            let mut _ret = usize::MIN;\\n\\n            let m_next = self.map_0[ptr];\\n            _ret += self.solve(m_next, n);\\n            _ret += self.solve(m - m_next, n);\\n\\n            ret = ret.max(_ret);\\n        } // cut height-wise\\n\\n        let ptr_1 = self.map_1.partition_point(|&e| e < n);\\n        for ptr in (0..ptr_1).rev() {\\n            let mut _ret = usize::MIN;\\n\\n            let n_next = self.map_1[ptr];\\n            _ret += self.solve(m, n_next);\\n            _ret += self.solve(m, n - n_next);\\n\\n            ret = ret.max(_ret);\\n        } // cut width-wise\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, vec: Vec<Vec<i32>>) -> i64 {\\n        let (m, n) = (m as usize, n as usize);\\n\\n        let mut vec = vec.into_iter()\\n            .map(|v| ([v[0] as usize, v[1] as usize], v[2] as usize))\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n\\n        let mut dp = DP::new(vec, m, n);\\n        dp.solve(m, n) as i64\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\npub struct DP {\\n    vec: Vec<([usize; 2], usize)>,\\n    m_max: usize, n_max: usize,\\n\\n    map_0: Vec<usize>,\\n    map_1: Vec<usize>,\\n\\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(vec: Vec<([usize; 2], usize)>, m_max: usize, n_max: usize) -> Self {\\n        let mut map_0 = vec.iter()\\n            .map(|&([v0, v1], w)| v0)\\n            .collect::<Vec<_>>();\\n        map_0.sort_unstable();\\n        map_0.dedup();\\n\\n        let mut map_1 = vec.iter()\\n            .map(|&([v0, v1], w)| v1)\\n            .collect::<Vec<_>>();\\n        map_1.sort_unstable();\\n        map_1.dedup();\\n\\n        let memo = vec![vec![None; n_max + 1]; m_max + 1];\\n\\n        Self {\\n            vec,\\n            m_max, n_max,\\n            map_0, map_1,\\n            memo\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, m: usize, n: usize) -> usize {\\n        if m > self.m_max { return usize::MIN; }\\n        if n > self.n_max { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[m][n] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(m, n);\\n        self.memo[m][n] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, m: usize, n: usize) -> usize {\\n        if m < 1 { return usize::MIN; }\\n        if n < 1 { return usize::MIN; } // nothing to cut\\n\\n        let mut ret = usize::MIN;\\n\\n        if let Some(ptr) = self.vec.binary_search_by_key(\\n            &[m, n], |&(v, _)| v\\n        ).ok() { // sell as-is\\n            ret = ret.max(self.vec[ptr].1);\\n        }\\n\\n        let ptr_0 = self.map_0.partition_point(|&e| e < m);\\n        for ptr in (0..ptr_0).rev() {\\n            let mut _ret = usize::MIN;\\n\\n            let m_next = self.map_0[ptr];\\n            _ret += self.solve(m_next, n);\\n            _ret += self.solve(m - m_next, n);\\n\\n            ret = ret.max(_ret);\\n        } // cut height-wise\\n\\n        let ptr_1 = self.map_1.partition_point(|&e| e < n);\\n        for ptr in (0..ptr_1).rev() {\\n            let mut _ret = usize::MIN;\\n\\n            let n_next = self.map_1[ptr];\\n            _ret += self.solve(m, n_next);\\n            _ret += self.solve(m, n - n_next);\\n\\n            ret = ret.max(_ret);\\n        } // cut width-wise\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, vec: Vec<Vec<i32>>) -> i64 {\\n        let (m, n) = (m as usize, n as usize);\\n\\n        let mut vec = vec.into_iter()\\n            .map(|v| ([v[0] as usize, v[1] as usize], v[2] as usize))\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n\\n        let mut dp = DP::new(vec, m, n);\\n        dp.solve(m, n) as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754490,
                "title": "c-python-dynamic-programming-solution-with-picture-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/8cb3602b-7564-403e-9d3e-1f4ef5ecd743_1689158545.3771586.png)\\n\\n```dfs(r, c)``` is max profit of a wood whose size is ```(r, c)```.\\nFirst, we can use ```(m+1) * (n+1)``` matrix to store price of a wood whose size is (r, c).\\ntc of check the price of a wood is O(1). \\n\\nenumerating all the ways we can cut a wood,\\nfind the price of two small woods.\\ntc of enumerating all the ways is r + c.\\n\\nTotal tc is O(m * n (m + n)), sc is O(m* n).\\n### python\\n\\n```python\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\t\\t\\n\\t\\t# price matrix\\n        pr_mat = [[0] * (m+1) for _ in range(n+1)]\\n        for r, c, p in prices:\\n            pr_mat[r][c] = p\\n        \\n        @cache\\n        def dfs(r, c):\\n\\t\\t\\n\\t\\t\\t# price of current wood\\n            sub = pr_mat[r][c] \\n            \\n\\t\\t\\t# enumerate all ways to cut horizontally\\n\\t\\t\\t# size of one of a woods > 0 (r >= 1)\\n            for i in range(1, r//2 + 1):\\n                t = dfs(i, c) + dfs(r-i, c)\\n                if t > sub: sub = t\\n\\t\\t\\t\\t\\n            # enumerate all ways to cut vertically\\n\\t\\t\\t# size of two woods > 0 (c >= 1)\\n            for j in range(1, c//2 + 1):\\n                t = dfs(r, j) + dfs(r, c-j)\\n                if t > sub: sub = t\\n            \\n            return sub\\n        \\n        return dfs(m, n)\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        vector<vector<long long>> dp (m+1, vector<long long> (n+1, -1));\\n        vector<vector<int>> pr_mat (m+1, vector<int> (n+1, 0));\\n        \\n        for (auto& p: prices)\\n            pr_mat[p[0]][p[1]] = p[2];\\n        \\n        \\n        function<long long(int, int)> dfs = [&] (int r, int c) {\\n            if (dp[r][c] != -1) return dp[r][c];\\n            long long sub = pr_mat[r][c];\\n            for (int i = 1; i <= r / 2; i+=1)\\n                sub = max(sub, dfs(i, c) + dfs(r-i, c));\\n            \\n            for (int j = 1; j <= c / 2; j+=1)\\n                sub = max(sub, dfs(r, j) + dfs(r, c-j));\\n            \\n            dp[r][c] = sub;\\n            return sub; \\n        };\\n        \\n        return dfs(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dfs(r, c)```\n```(r, c)```\n```(m+1) * (n+1)```\n```python\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\t\\t\\n\\t\\t# price matrix\\n        pr_mat = [[0] * (m+1) for _ in range(n+1)]\\n        for r, c, p in prices:\\n            pr_mat[r][c] = p\\n        \\n        @cache\\n        def dfs(r, c):\\n\\t\\t\\n\\t\\t\\t# price of current wood\\n            sub = pr_mat[r][c] \\n            \\n\\t\\t\\t# enumerate all ways to cut horizontally\\n\\t\\t\\t# size of one of a woods > 0 (r >= 1)\\n            for i in range(1, r//2 + 1):\\n                t = dfs(i, c) + dfs(r-i, c)\\n                if t > sub: sub = t\\n\\t\\t\\t\\t\\n            # enumerate all ways to cut vertically\\n\\t\\t\\t# size of two woods > 0 (c >= 1)\\n            for j in range(1, c//2 + 1):\\n                t = dfs(r, j) + dfs(r, c-j)\\n                if t > sub: sub = t\\n            \\n            return sub\\n        \\n        return dfs(m, n)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        vector<vector<long long>> dp (m+1, vector<long long> (n+1, -1));\\n        vector<vector<int>> pr_mat (m+1, vector<int> (n+1, 0));\\n        \\n        for (auto& p: prices)\\n            pr_mat[p[0]][p[1]] = p[2];\\n        \\n        \\n        function<long long(int, int)> dfs = [&] (int r, int c) {\\n            if (dp[r][c] != -1) return dp[r][c];\\n            long long sub = pr_mat[r][c];\\n            for (int i = 1; i <= r / 2; i+=1)\\n                sub = max(sub, dfs(i, c) + dfs(r-i, c));\\n            \\n            for (int j = 1; j <= c / 2; j+=1)\\n                sub = max(sub, dfs(r, j) + dfs(r, c-j));\\n            \\n            dp[r][c] = sub;\\n            return sub; \\n        };\\n        \\n        return dfs(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751699,
                "title": "python-90-time-and-57-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n\\n        P=[[0 for i in range(n+1)]for j in range(m+1)]\\n\\n        for i in prices:\\n            P[i[0]][i[1]]=i[2]\\n        dp=[[False for i in range(n+1)]for j in range(m+1)]\\n        def sol(x,y):\\n            if dp[x][y] is not False:\\n                return dp[x][y]\\n            ret=P[x][y]\\n            for k in range(x//2):\\n                a=sol(k+1,y)+sol(x-(k+1),y)\\n                ret=max(ret,a)\\n            for k in range(y//2):\\n                a=sol(x,k+1)+sol(x,y-(k+1))\\n                ret=max(ret,a)\\n            dp[x][y]=ret\\n            return ret\\n        final=sol(m,n)\\n        return final\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n\\n        P=[[0 for i in range(n+1)]for j in range(m+1)]\\n\\n        for i in prices:\\n            P[i[0]][i[1]]=i[2]\\n        dp=[[False for i in range(n+1)]for j in range(m+1)]\\n        def sol(x,y):\\n            if dp[x][y] is not False:\\n                return dp[x][y]\\n            ret=P[x][y]\\n            for k in range(x//2):\\n                a=sol(k+1,y)+sol(x-(k+1),y)\\n                ret=max(ret,a)\\n            for k in range(y//2):\\n                a=sol(x,k+1)+sol(x,y-(k+1))\\n                ret=max(ret,a)\\n            dp[x][y]=ret\\n            return ret\\n        final=sol(m,n)\\n        return final\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690874,
                "title": "dp-split-into-horizontal-and-vertical-halves",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for h, w, p in prices:\\n            dp[h][w] = p\\n        for h in range(m + 1):\\n            for w in range(n + 1):\\n                for hh in range(1, h):\\n                    dp[h][w] = max(dp[h][w], dp[hh][w] + dp[h - hh][w])\\n                for ww in range(1, w):\\n                    dp[h][w] = max(dp[h][w], dp[h][ww] + dp[h][w - ww])\\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for h, w, p in prices:\\n            dp[h][w] = p\\n        for h in range(m + 1):\\n            for w in range(n + 1):\\n                for hh in range(1, h):\\n                    dp[h][w] = max(dp[h][w], dp[hh][w] + dp[h - hh][w])\\n                for ww in range(1, w):\\n                    dp[h][w] = max(dp[h][w], dp[h][ww] + dp[h][w - ww])\\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589771,
                "title": "c-dp-commented-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n#define int2 long long\\n#define pp pair<int,int>\\n    int2 solve(int m,int n ,map<pp,int>&mp,vector<vector<int2>>&dp){\\n        if(m ==1 && n == 1){\\n            return mp[{m,n}];\\n        }\\n        // first try to sell the whole block..\\n        if(dp[m][n] != -1)return dp[m][n];\\n        int2 ans = mp[{m,n}]; // you could find in 0(1)\\n        // cut it into skinny pieces vertically...\\n        for(int i = 1;i<m;i++){\\n            ans = max(ans,solve(i,n,mp,dp)+solve(m-i,n,mp,dp));\\n        }\\n        //  cut it into skinny pieces horizonally...\\n        for(int j = 1;j<n;j++){\\n            ans = max(ans,solve(m,j,mp,dp)+solve(m,n-j,mp,dp));\\n        }\\n        return dp[m][n] = ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        map<pp,int>mp;\\n        for(auto it: prices){\\n            mp[{it[0],it[1]}] = it[2];\\n        }\\n        vector<vector<int2>>dp(m+1,vector<int2>(n+1,-1));\\n        int2 ans = solve(m,n,mp,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define int2 long long\\n#define pp pair<int,int>\\n    int2 solve(int m,int n ,map<pp,int>&mp,vector<vector<int2>>&dp){\\n        if(m ==1 && n == 1){\\n            return mp[{m,n}];\\n        }\\n        // first try to sell the whole block..\\n        if(dp[m][n] != -1)return dp[m][n];\\n        int2 ans = mp[{m,n}]; // you could find in 0(1)\\n        // cut it into skinny pieces vertically...\\n        for(int i = 1;i<m;i++){\\n            ans = max(ans,solve(i,n,mp,dp)+solve(m-i,n,mp,dp));\\n        }\\n        //  cut it into skinny pieces horizonally...\\n        for(int j = 1;j<n;j++){\\n            ans = max(ans,solve(m,j,mp,dp)+solve(m,n-j,mp,dp));\\n        }\\n        return dp[m][n] = ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        map<pp,int>mp;\\n        for(auto it: prices){\\n            mp[{it[0],it[1]}] = it[2];\\n        }\\n        vector<vector<int2>>dp(m+1,vector<int2>(n+1,-1));\\n        int2 ans = solve(m,n,mp,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507227,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    Long[][] dp;\\n    record Pair(int x, int y) { }\\n    Map<Pair, Integer> map;\\n    private long solve(int n, int m){\\n        if(n == 0 || m == 0) return 0;\\n        if(dp[n][m] != null) return dp[n][m];\\n        long res = map.getOrDefault(new Pair(n, m), 0);\\n        for(int i = 1; i < n; i++)\\n            res = Math.max(res, solve(i, m) + solve(n - i, m));\\n        for(int i = 1; i < m; i++)\\n            res = Math.max(res, solve(n, i) + solve(n, m - i));\\n        dp[n][m] = res;\\n        return res;\\n    }\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        dp = new Long[m + 1][n + 1];\\n        map = new HashMap<>();\\n        for(int[] p: prices) map.put(new Pair(p[0], p[1]), p[2]);\\n        return solve(m, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Long[][] dp;\\n    record Pair(int x, int y) { }\\n    Map<Pair, Integer> map;\\n    private long solve(int n, int m){\\n        if(n == 0 || m == 0) return 0;\\n        if(dp[n][m] != null) return dp[n][m];\\n        long res = map.getOrDefault(new Pair(n, m), 0);\\n        for(int i = 1; i < n; i++)\\n            res = Math.max(res, solve(i, m) + solve(n - i, m));\\n        for(int i = 1; i < m; i++)\\n            res = Math.max(res, solve(n, i) + solve(n, m - i));\\n        dp[n][m] = res;\\n        return res;\\n    }\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        dp = new Long[m + 1][n + 1];\\n        map = new HashMap<>();\\n        for(int[] p: prices) map.put(new Pair(p[0], p[1]), p[2]);\\n        return solve(m, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448131,
                "title": "python-short-and-clean-memo-dp",
                "content": "# Intuition\\nMain observation: we always cut <b>straight whole line</b> which splits rectangle into two. It gives fuel to DP solution over $m,n$: what is the maximal price we can get out of $$m*n$$ rectangle? We just try exact match in prices, each vertical and horizontal cut, and choose maximum option.\\nDP formula: $f(m,n)=max(f(m,x)+f(m,n-x)_{1<=x<n},f(x,n)+f(m-x,n)_{1<=x<m},price(m,n))$\\n\\n# Approach\\nImplement DP formula + use memoization via `@cache`. \\n\\n# Complexity\\n- Time complexity: `O(m*n*(m+n))`\\n- Space complexity: `O(m*n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        prices=defaultdict(int)|{(h,w):p for h,w,p in prices}\\n        @cache\\n        def f(m,n):            \\n            hor = max((f(x,n)+f(m-x,n) for x in range(1,1+m//2)), default=0)\\n            ver = max((f(m,x)+f(m,n-x) for x in range(1,1+n//2)), default=0)\\n            return max(hor,ver, prices[m,n])\\n        return f(m,n)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        prices=defaultdict(int)|{(h,w):p for h,w,p in prices}\\n        @cache\\n        def f(m,n):            \\n            hor = max((f(x,n)+f(m-x,n) for x in range(1,1+m//2)), default=0)\\n            ver = max((f(m,x)+f(m,n-x) for x in range(1,1+n//2)), default=0)\\n            return max(hor,ver, prices[m,n])\\n        return f(m,n)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397344,
                "title": "js-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    let prObj = {}\\n    let checked = {}\\n    \\n    for (let i = 0; i < prices.length; i++){\\n        prObj[\"\" + prices[i][0] + \"/\" + prices[i][1]] = prices[i][2]\\n    }\\n\\n    return iter(m,n)\\n\\n    function iter(row, col){\\n        if (checked[\"\" + row + \"/\" + col] !== undefined) return checked[\"\" + row + \"/\" + col]\\n        let p = 0 // max price of current piece.\\n        if (prObj[\"\" + row + \"/\" + col] !== undefined) p = prObj[\"\" + row + \"/\" + col]\\n    \\n        for (let i = 1; i <= Math.floor(row / 2); i++){\\n            p = Math.max(p, iter(i, col) + iter(row - i, col))\\n        }\\n        \\n        for (let i = 1; i <= Math.floor(col / 2); i++){\\n            p = Math.max(p, iter(row, i) + iter(row, col - i))\\n        }\\n        checked[\"\" + row + \"/\" + col] = p\\n        return p\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    let prObj = {}\\n    let checked = {}\\n    \\n    for (let i = 0; i < prices.length; i++){\\n        prObj[\"\" + prices[i][0] + \"/\" + prices[i][1]] = prices[i][2]\\n    }\\n\\n    return iter(m,n)\\n\\n    function iter(row, col){\\n        if (checked[\"\" + row + \"/\" + col] !== undefined) return checked[\"\" + row + \"/\" + col]\\n        let p = 0 // max price of current piece.\\n        if (prObj[\"\" + row + \"/\" + col] !== undefined) p = prObj[\"\" + row + \"/\" + col]\\n    \\n        for (let i = 1; i <= Math.floor(row / 2); i++){\\n            p = Math.max(p, iter(i, col) + iter(row - i, col))\\n        }\\n        \\n        for (let i = 1; i <= Math.floor(col / 2); i++){\\n            p = Math.max(p, iter(row, i) + iter(row, col - i))\\n        }\\n        checked[\"\" + row + \"/\" + col] = p\\n        return p\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266913,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        use std::collections::HashMap;\\n        fn dfs(high: i32, wid: i32, part_price: &HashMap<(i32, i32), i64>, f: &mut HashMap<(i32, i32), i64>) -> i64 {\\n            let mut ans: i64 = 0;\\n            if f.contains_key(&(high, wid)) {\\n                return f[&(high, wid)];\\n            }\\n            if part_price.contains_key(&(high, wid)) {\\n                ans = part_price[&(high, wid)];\\n            }\\n            let half_high = high / 2 + 1;\\n            let half_wid = wid / 2 + 1;\\n            for h in 1..half_high {\\n                let up = dfs(h, wid, part_price, f);\\n                let down = dfs(high - h, wid, part_price, f);\\n                ans = ans.max(up + down);\\n            }\\n            for w in 1..half_wid {\\n                let left = dfs(high, w, part_price, f);\\n                let right = dfs(high, wid - w, part_price, f);\\n                ans = ans.max(left + right);\\n            }\\n            f.insert((high, wid), ans);\\n            ans\\n        }\\n\\n        let part_price: HashMap<(i32, i32), i64> = prices.iter().map(|x| ((x[0], x[1]), x[2] as i64)).collect();\\n        let mut f: HashMap<(i32, i32), i64> = HashMap::new();\\n        dfs(m, n, &part_price, &mut f)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        use std::collections::HashMap;\\n        fn dfs(high: i32, wid: i32, part_price: &HashMap<(i32, i32), i64>, f: &mut HashMap<(i32, i32), i64>) -> i64 {\\n            let mut ans: i64 = 0;\\n            if f.contains_key(&(high, wid)) {\\n                return f[&(high, wid)];\\n            }\\n            if part_price.contains_key(&(high, wid)) {\\n                ans = part_price[&(high, wid)];\\n            }\\n            let half_high = high / 2 + 1;\\n            let half_wid = wid / 2 + 1;\\n            for h in 1..half_high {\\n                let up = dfs(h, wid, part_price, f);\\n                let down = dfs(high - h, wid, part_price, f);\\n                ans = ans.max(up + down);\\n            }\\n            for w in 1..half_wid {\\n                let left = dfs(high, w, part_price, f);\\n                let right = dfs(high, wid - w, part_price, f);\\n                ans = ans.max(left + right);\\n            }\\n            f.insert((high, wid), ans);\\n            ans\\n        }\\n\\n        let part_price: HashMap<(i32, i32), i64> = prices.iter().map(|x| ((x[0], x[1]), x[2] as i64)).collect();\\n        let mut f: HashMap<(i32, i32), i64> = HashMap::new();\\n        dfs(m, n, &part_price, &mut f)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3228648,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sellingWood(self, m, n, prices):\\n        dict1 = collections.defaultdict(int)\\n\\n        for i,j,k in prices:\\n            dict1[(i,j)] = k\\n\\n        @lru_cache(None)\\n        def dfs(h,w):\\n            if h == 0 or w == 0: return 0\\n\\n            max_val = dict1[(h,w)]\\n\\n            for i in range(1,h//2+1):\\n                max_val = max(max_val,dfs(i,w) + dfs(h-i,w))\\n\\n            for j in range(1,w//2+1):\\n                max_val = max(max_val,dfs(h,j) + dfs(h,w-j))\\n\\n            return max_val \\n\\n        return dfs(m,n)\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m, n, prices):\\n        dict1 = collections.defaultdict(int)\\n\\n        for i,j,k in prices:\\n            dict1[(i,j)] = k\\n\\n        @lru_cache(None)\\n        def dfs(h,w):\\n            if h == 0 or w == 0: return 0\\n\\n            max_val = dict1[(h,w)]\\n\\n            for i in range(1,h//2+1):\\n                max_val = max(max_val,dfs(i,w) + dfs(h-i,w))\\n\\n            for j in range(1,w//2+1):\\n                max_val = max(max_val,dfs(h,j) + dfs(h,w-j))\\n\\n            return max_val \\n\\n        return dfs(m,n)\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962438,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll memo[201][201]{}, mp[201][201]{};\\n    ll sellingWood(int m, int n, vector<vector<int>>& P) {\\n        for(auto &p : P) mp[p[0]][p[1]] = p[2];\\n        return help(m, n);\\n    }\\n\\n    ll help(int m, int n) {\\n        ll res = memo[m][n];\\n        if(res) return res-1;\\n        if(mp[m][n]) res = mp[m][n];\\n        for(int i = 1; i <= m/2; i++) res = max(res, help(i, n)+help(m-i, n));\\n        for(int i = 1; i <= n/2; i++) res = max(res, help(m, i)+help(m, n-i));\\n        memo[m][n] = res+1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll memo[201][201]{}, mp[201][201]{};\\n    ll sellingWood(int m, int n, vector<vector<int>>& P) {\\n        for(auto &p : P) mp[p[0]][p[1]] = p[2];\\n        return help(m, n);\\n    }\\n\\n    ll help(int m, int n) {\\n        ll res = memo[m][n];\\n        if(res) return res-1;\\n        if(mp[m][n]) res = mp[m][n];\\n        for(int i = 1; i <= m/2; i++) res = max(res, help(i, n)+help(m-i, n));\\n        for(int i = 1; i <= n/2; i++) res = max(res, help(m, i)+help(m, n-i));\\n        memo[m][n] = res+1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954276,
                "title": "recursion-c",
                "content": "# Approach\\n1. We need to check for possibility so it means we can think of recursion here.\\n2. firstly I will cut the current rectangle into two rectangles\\n3. there are two ways to cut it i.e. row wise and column wise\\n4. So, firstly cut it through row state will be dp(cut, col) + dp(row - cut, col) and similarly for column\\n5. and my base case will be when I reach row length = 1 and column length also 1 then we return price[1][1].\\n6. Check the code for more clearity.\\n# Complexity\\n- Time complexity:\\nO(n * m * (n + m))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long cache[205][205];\\n    long long price[205][205];\\n    long long dp(int rl, int cl) {\\n        if(rl == 1 && cl == 1) {\\n            return price[cl][rl];\\n        }\\n        long long& ans = cache[rl][cl];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        ans = max(ans, price[rl][cl]);\\n        for(int cut = 1; cut < rl; cut++) {\\n            ans = max(ans, dp(cut, cl) + dp(rl - cut, cl));\\n        }\\n        for(int cut = 1; cut < cl; cut++) {\\n            ans = max(ans, dp(rl, cut) + dp(rl, cl - cut));\\n        }\\n        return ans;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        for(auto p : prices) {\\n            int i = p[0];\\n            int j = p[1];\\n            int c = p[2];\\n            price[i][j] = c;\\n        }\\n        memset(cache, -1, sizeof(cache));\\n        return dp(n, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long cache[205][205];\\n    long long price[205][205];\\n    long long dp(int rl, int cl) {\\n        if(rl == 1 && cl == 1) {\\n            return price[cl][rl];\\n        }\\n        long long& ans = cache[rl][cl];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        ans = max(ans, price[rl][cl]);\\n        for(int cut = 1; cut < rl; cut++) {\\n            ans = max(ans, dp(cut, cl) + dp(rl - cut, cl));\\n        }\\n        for(int cut = 1; cut < cl; cut++) {\\n            ans = max(ans, dp(rl, cut) + dp(rl, cl - cut));\\n        }\\n        return ans;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        for(auto p : prices) {\\n            int i = p[0];\\n            int j = p[1];\\n            int c = p[2];\\n            price[i][j] = c;\\n        }\\n        memset(cache, -1, sizeof(cache));\\n        return dp(n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919010,
                "title": "python-easy-to-read-and-understand-bottom-up",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        t = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        \\n        for r, c, p in prices:\\n            t[r][c] = p\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                for c in range(j//2 + 1):\\n                    t[i][j] = max(t[i][j], t[i][c] + t[i][j-c])\\n                for r in range(i//2 + 1):\\n                    t[i][j] = max(t[i][j], t[r][j] + t[i-r][j])\\n        \\n        return t[m][n]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        t = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        \\n        for r, c, p in prices:\\n            t[r][c] = p\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                for c in range(j//2 + 1):\\n                    t[i][j] = max(t[i][j], t[i][c] + t[i][j-c])\\n                for r in range(i//2 + 1):\\n                    t[i][j] = max(t[i][j], t[r][j] + t[i-r][j])\\n        \\n        return t[m][n]",
                "codeTag": "Java"
            },
            {
                "id": 2891944,
                "title": "c-very-easy-to-understand-dp-memoization",
                "content": "SC: O(m * n)\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll priceList[201][201];\\n    ll dp[201][201];\\n    ll solve(int height,int width){\\n        //base case\\n        if(height==0 || width==0)\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[height][width]!=-1)\\n            return dp[height][width];\\n        \\n        ll maxProfit=0;\\n        \\n        // when sell entire plank\\n        maxProfit = priceList[height][width];\\n        \\n        //when cut height wise\\n        for(int i=1;i<height;i++){\\n            ll curr = solve(i,width) + solve(height-i,width);\\n            maxProfit=max(maxProfit,curr);\\n        }\\n        \\n        //when cut width wise\\n        for(int i=1;i<width;i++){\\n            ll curr = solve(height,i) + solve(height,width-i);\\n            maxProfit=max(maxProfit,curr);\\n        }\\n        \\n        return dp[height][width] = maxProfit;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        //creating a pricelist array to access in O(1) time\\n        for(auto &it:prices){\\n            priceList[it[0]][it[1]]=it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        // return max profit when having plank of size m*n\\n        return solve(m,n); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll priceList[201][201];\\n    ll dp[201][201];\\n    ll solve(int height,int width){\\n        //base case\\n        if(height==0 || width==0)\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[height][width]!=-1)\\n            return dp[height][width];\\n        \\n        ll maxProfit=0;\\n        \\n        // when sell entire plank\\n        maxProfit = priceList[height][width];\\n        \\n        //when cut height wise\\n        for(int i=1;i<height;i++){\\n            ll curr = solve(i,width) + solve(height-i,width);\\n            maxProfit=max(maxProfit,curr);\\n        }\\n        \\n        //when cut width wise\\n        for(int i=1;i<width;i++){\\n            ll curr = solve(height,i) + solve(height,width-i);\\n            maxProfit=max(maxProfit,curr);\\n        }\\n        \\n        return dp[height][width] = maxProfit;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        //creating a pricelist array to access in O(1) time\\n        for(auto &it:prices){\\n            priceList[it[0]][it[1]]=it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        // return max profit when having plank of size m*n\\n        return solve(m,n); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798600,
                "title": "hashmap-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Pair<Integer,Integer>,Long> hm;\\n    long dp[][];\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        hm=new HashMap<>();\\n        dp=new long[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        for(int i=0;i<prices.length;i++){\\n            hm.put(new Pair(prices[i][0],prices[i][1]),new Long(prices[i][2]));\\n        }\\n        return solve(m,n,prices);\\n    }\\n    public long solve(int m,int n,int [][]prices){\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        long ans=0;\\n        long val=hm.containsKey(new Pair(m,n))?hm.get(new Pair(m,n)):0;\\n        ans=val;\\n        for(int i=1;i<=m/2;i++){\\n            ans=Math.max(ans,solve(i,n,prices)+solve(m-i,n,prices));\\n        }\\n        for(int j=1;j<=n/2;j++){\\n            ans=Math.max(ans,solve(m,j,prices)+solve(m,n-j,prices));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Pair<Integer,Integer>,Long> hm;\\n    long dp[][];\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        hm=new HashMap<>();\\n        dp=new long[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        for(int i=0;i<prices.length;i++){\\n            hm.put(new Pair(prices[i][0],prices[i][1]),new Long(prices[i][2]));\\n        }\\n        return solve(m,n,prices);\\n    }\\n    public long solve(int m,int n,int [][]prices){\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        long ans=0;\\n        long val=hm.containsKey(new Pair(m,n))?hm.get(new Pair(m,n)):0;\\n        ans=val;\\n        for(int i=1;i<=m/2;i++){\\n            ans=Math.max(ans,solve(i,n,prices)+solve(m-i,n,prices));\\n        }\\n        for(int j=1;j<=n/2;j++){\\n            ans=Math.max(ans,solve(m,j,prices)+solve(m,n-j,prices));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744716,
                "title": "javascript-bottom-up-dp-83-time-100-space",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0))\\n    \\n    for (let [h, w, p] of prices) dp[h][w] = p\\n    \\n    for (let row = 1; row <= m; row++) {\\n        for (let col = 1; col <= n; col++) {\\n            for (let r = 0; r <= row; r++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[r][col] + dp[row - r][col])\\n            }\\n            for (let c = 0; c <= col; c++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[row][c] + dp[row][col - c])\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0))\\n    \\n    for (let [h, w, p] of prices) dp[h][w] = p\\n    \\n    for (let row = 1; row <= m; row++) {\\n        for (let col = 1; col <= n; col++) {\\n            for (let r = 0; r <= row; r++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[r][col] + dp[row - r][col])\\n            }\\n            for (let c = 0; c <= col; c++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[row][c] + dp[row][col - c])\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2711310,
                "title": "python3-dp",
                "content": "class Solution:\\n\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        M,N = m+1,n+1\\n        dp = [[0]*N for _ in range(M)]\\n        for x,y,price in prices:\\n            dp[x][y] = price\\n        \\n        for i in range(1,M):\\n            I = i//2+1\\n            for j in range(1,N):\\n                J = j//2+1\\n                #Vertical division\\n                for k in range(1,I):\\n                    dp[i][j] = max(dp[i][j],dp[i-k][j]+dp[k][j])\\n                #Horizontal division    \\n                for k in range(1,J):\\n                    dp[i][j] = max(dp[i][j],dp[i][j-k]+dp[i][k])\\n        \\n        return dp[-1][-1]",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        M,N = m+1,n+1\\n        dp = [[0]*N for _ in range(M)]\\n        for x,y,price in prices:\\n            dp[x][y] = price\\n        \\n        for i in range(1,M):\\n            I = i//2+1\\n            for j in range(1,N):\\n                J = j//2+1\\n                #Vertical division\\n                for k in range(1,I):\\n                    dp[i][j] = max(dp[i][j],dp[i-k][j]+dp[k][j])\\n                #Horizontal division    \\n                for k in range(1,J):\\n                    dp[i][j] = max(dp[i][j],dp[i][j-k]+dp[i][k])\\n        \\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 2698169,
                "title": "java-solution-tc-o-n-m-n-m",
                "content": "**please up-vote:)**\\n```\\nclass Solution {\\n        \\n    Long[][] memo;\\n    Integer[][] withoutCuts;\\n\\t\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        memo = new Long[m+1][n+1];\\n        withoutCuts = new Integer[m+1][n+1];\\n        for(int[] price : prices)\\n            withoutCuts[price[0]][price[1]] = price[2];\\n\\t\\t\\t\\n        return cutToPieces(m, n);\\n    }\\n\\n    private long cutToPieces(int m, int n){\\n        if(memo[m][n] != null)\\n            return memo[m][n];\\n       \\n\\t    if(m == 0 || n == 0)\\n\\t\\t\\treturn memo[m][n] = 0l;\\n\\t\\t\\t\\n        long max = 0;\\n        if(withoutCuts[m][n] != null) // if the size fits one piece\\n            max = withoutCuts[m][n];\\n  \\n        for(int i = 1; i <= m/2; i++)   //horizontal cut\\n            max = Math.max(max, cutToPieces(i, n) + cutToPieces(m-i, n));\\n        \\n        for(int i = 1; i <= n/2; i++)   //vertical cut\\n            max = Math.max(max, cutToPieces(m, i) + cutToPieces(m, n-i));\\n        \\n        return memo[m][n] = max;\\n    }\\n}\\n```\\n\\n**TC** = o(n*m*(n+m))\\nbecause we fill a matrix of **n*m** cells, and for each cell we do **n+m** work.\\n\\n**SC** = o(n*m)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        \\n    Long[][] memo;\\n    Integer[][] withoutCuts;\\n\\t\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        memo = new Long[m+1][n+1];\\n        withoutCuts = new Integer[m+1][n+1];\\n        for(int[] price : prices)\\n            withoutCuts[price[0]][price[1]] = price[2];\\n\\t\\t\\t\\n        return cutToPieces(m, n);\\n    }\\n\\n    private long cutToPieces(int m, int n){\\n        if(memo[m][n] != null)\\n            return memo[m][n];\\n       \\n\\t    if(m == 0 || n == 0)\\n\\t\\t\\treturn memo[m][n] = 0l;\\n\\t\\t\\t\\n        long max = 0;\\n        if(withoutCuts[m][n] != null) // if the size fits one piece\\n            max = withoutCuts[m][n];\\n  \\n        for(int i = 1; i <= m/2; i++)   //horizontal cut\\n            max = Math.max(max, cutToPieces(i, n) + cutToPieces(m-i, n));\\n        \\n        for(int i = 1; i <= n/2; i++)   //vertical cut\\n            max = Math.max(max, cutToPieces(m, i) + cutToPieces(m, n-i));\\n        \\n        return memo[m][n] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685208,
                "title": "diagrammatically-explained-python3-top-down-and-bottom-up-dp",
                "content": "First convert the prices array into an dictionary so that we can query the price given the dimensions of the plank in O(1) time.\\n\\nNext lets write a function` f(m,n)` where` f(m,n)` is the money made using a wooden plank of dim mxn.\\n\\nIt is given that the wooden plank can be cut horizontally or vertically which will change its dimension.\\nWhen making a cut, the cut has to be made across entire wooden plank ie complete cut has to be made vertically or horizontally.\\n\\nWhen cut row wise, the plank gets broken into:` ixn` and `(m-i)xn` dimensional plank\\nwhile when cut column wise, it cut split into `mxj` and `mx(n-j)` dimensional plank as shown in the figure below.\\n\\n![image](https://assets.leetcode.com/users/images/aca7ecef-24a8-4462-87cc-74138506a3ad_1665391934.9728634.png)\\n\\nThen we find which of these cuts yields us the maximum profit by solving for these dimensions recursively\\n\\nAlso in the figure we notice that the 5th option and 4th option are same due to symmetry,.\\nHence it suffices to go till `m//2 `and `n//2` of the plank and prevent repetitive calculations.\\n\\nThe memoized code is shown below:\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        #dimension to price mapping\\n        price = defaultdict(int)\\n        \\n        for l,b,p in prices:\\n            price[(l,b)] = p\\n        \\n        @cache\\n        def solve(m,n):\\n            dim = (m,n)\\n            \\n            #money gained without cutting the plank\\n            money = price[dim]\\n            \\n            #money gained after cutting the plank vertically\\n            for i in range(1,(m//2)+1):\\n                money = max(\\n                    money,\\n                    solve(i,n)+solve(m-i,n)\\n                )\\n            \\n            #money gained after cutting the plank horizontally\\n            for j in range(1,(n//2)+1):\\n                money = max(\\n                    money,\\n                    solve(m,j)+solve(m,n-j)\\n                )\\n            \\n            return money\\n        \\n        return solve(m,n)\\n```\\n\\nIn bottom up, we start with the money earned by selling the smallest plank size of 0x0 and then move our way up to solve larger plank size problems using the answers saved from the smaller plank size problems.\\n\\n`dp[i][j]` will store the money earned by selling a plank of size` ixj`.\\nWe initialize it with the money earned by selling the entire plank without cutting it up.\\nThen we generate all possible plank size from 0x0 to mxn and calculate the maximum profit made.\\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        #dimension to price mapping\\n        price = {}\\n        \\n        for l,b,p in prices:\\n            price[(l,b)] = p\\n        \\n        #dp[i][j] = money earned by selling ixj dim plank\\n        dp = [[price[(i,j)] if (i,j) in price else 0 for j in range(n+1)]\\\\\\n              for i in range(m+1)] \\n       \\n        #generate empty plank to mxn plank\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                                \\n                #cut it horizontally\\n                for r in range(1,(i//2)+1):\\n                    dp[i][j] = max(\\n                        dp[i][j],\\n                        dp[r][j]+dp[i-r][j]\\n                    )\\n                    \\n                #cut vertically\\n                for c in range(1,(j//2)+1):\\n                    dp[i][j] = max(\\n                        dp[i][j],\\n                        dp[i][c]+dp[i][j-c]\\n                    )\\n                \\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        #dimension to price mapping\\n        price = defaultdict(int)\\n        \\n        for l,b,p in prices:\\n            price[(l,b)] = p\\n        \\n        @cache\\n        def solve(m,n):\\n            dim = (m,n)\\n            \\n            #money gained without cutting the plank\\n            money = price[dim]\\n            \\n            #money gained after cutting the plank vertically\\n            for i in range(1,(m//2)+1):\\n                money = max(\\n                    money,\\n                    solve(i,n)+solve(m-i,n)\\n                )\\n            \\n            #money gained after cutting the plank horizontally\\n            for j in range(1,(n//2)+1):\\n                money = max(\\n                    money,\\n                    solve(m,j)+solve(m,n-j)\\n                )\\n            \\n            return money\\n        \\n        return solve(m,n)\\n```\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        #dimension to price mapping\\n        price = {}\\n        \\n        for l,b,p in prices:\\n            price[(l,b)] = p\\n        \\n        #dp[i][j] = money earned by selling ixj dim plank\\n        dp = [[price[(i,j)] if (i,j) in price else 0 for j in range(n+1)]\\\\\\n              for i in range(m+1)] \\n       \\n        #generate empty plank to mxn plank\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                                \\n                #cut it horizontally\\n                for r in range(1,(i//2)+1):\\n                    dp[i][j] = max(\\n                        dp[i][j],\\n                        dp[r][j]+dp[i-r][j]\\n                    )\\n                    \\n                #cut vertically\\n                for c in range(1,(j//2)+1):\\n                    dp[i][j] = max(\\n                        dp[i][j],\\n                        dp[i][c]+dp[i][j-c]\\n                    )\\n                \\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669699,
                "title": "c",
                "content": "(```) class Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n     \\n        vector<vector<long long>> dp(m+1,vector<long long>(n+1, 0));\\n        \\n        for(auto &x: prices)\\n        {\\n            dp[x[0]][x[1]] = x[2];\\n        }\\n        \\n        for(int h=1; h<=m; h++)\\n        {\\n            for(int w=1; w<=n; w++)\\n            {\\n                for(int a=1; a<=h/2; a++)\\n                {\\n                    dp[h][w] = max(dp[h][w], dp[a][w] + dp[h-a][w]);\\n                }\\n            \\n                for(int a=1; a<=w/2; a++)\\n                {\\n                    dp[h][w] = max(dp[h][w], dp[h][a] + dp[h][w-a]);\\n                }  \\n                \\n            }\\n        }\\n        \\n        return dp[m][n];\\n            \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n     \\n        vector<vector<long long>> dp(m+1,vector<long long>(n+1, 0));\\n        \\n        for(auto &x: prices)\\n        {\\n            dp[x[0]][x[1]] = x[2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2647191,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef sellingWood(self, m: int, n: int, P: List[List[int]]) -> int:\\n\\t\\t\\tdp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\t\\t\\tfor r, c, p in P:\\n\\t\\t\\t\\tdp[r][c] = p\\n\\n\\t\\t\\tfor r in range(1, m + 1):\\n\\t\\t\\t\\tfor c in range(1, n + 1):\\n\\t\\t\\t\\t\\t# Find all the possible first cut:\\n\\t\\t\\t\\t\\tfor nc in range(1, c // 2 + 1): \\n\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r][c], dp[r][nc] + dp[r][c - nc])\\n\\t\\t\\t\\t\\tfor nr in range(1, r // 2 + 1):\\n\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r][c], dp[nr][c] + dp[r - nr][c])\\n\\n\\t\\t\\treturn dp[m][n]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sellingWood(self, m: int, n: int, P: List[List[int]]) -> int:\\n\\t\\t\\tdp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\t\\t\\tfor r, c, p in P:\\n\\t\\t\\t\\tdp[r][c] = p\\n\\n\\t\\t\\tfor r in range(1, m + 1):\\n\\t\\t\\t\\tfor c in range(1, n + 1):\\n\\t\\t\\t\\t\\t# Find all the possible first cut:\\n\\t\\t\\t\\t\\tfor nc in range(1, c // 2 + 1): \\n\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r][c], dp[r][nc] + dp[r][c - nc])\\n\\t\\t\\t\\t\\tfor nr in range(1, r // 2 + 1):\\n\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r][c], dp[nr][c] + dp[r - nr][c])\\n\\n\\t\\t\\treturn dp[m][n]",
                "codeTag": "Java"
            },
            {
                "id": 2577762,
                "title": "c-dp-solution-easy-explanation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    long long solve(int n,int m,vector<vector<long long>>& prices,vector<vector<long long>>& dp)\\n    {\\n        // cache\\n        if(dp[n][m]!=-1)\\n        {\\n            return dp[n][m];\\n        }\\n        \\n        // taking the price for current height and width\\n        long long price = prices[n][m];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            // dealing with two conditions, price for cut on height and then for rest\\n            price = max(price,solve(n-i,m,prices,dp) + solve(i,m,prices,dp));\\n        }\\n        for(int i = 1; i < m; i++)\\n        {\\n            // dealing with two conditions, price for cut on width and then for rest\\n            price = max(price,solve(n,m-i,prices,dp) + solve(n,i,prices,dp));\\n        }\\n        return dp[n][m] = price;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        // creating 2-d price vector\\n        vector<vector<long long>> v(n+1,vector<long long>(m+1,0));\\n        for(auto &it : prices)\\n        {\\n            v[it[0]][it[1]] = it[2];\\n        }\\n        \\n        // dp initialization\\n        vector<vector<long long>> dp(n+1,vector<long long>(m+1,-1));\\n        return solve(n,m,v,dp);\\n    }\\n\\t};\\n\\t# upvote if this help u :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    long long solve(int n,int m,vector<vector<long long>>& prices,vector<vector<long long>>& dp)\\n    {\\n        // cache\\n        if(dp[n][m]!=-1)\\n        {\\n            return dp[n][m];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2522017,
                "title": "c-easy-dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> prices;\\n    vector<vector<long long>> dp;\\n    long long maxPro(int l,int w){\\n        if(dp[l][w]!=-1) return dp[l][w];\\n        long long ans=0;\\n        if(prices.count({l,w})) ans=prices[{l,w}];\\n        \\n        for(int i=1;i<=l-1;i++){\\n            ans=max(ans,maxPro(i,w)+maxPro(l-i,w));\\n        }\\n        for(int i=1;i<=w-1;i++){\\n            ans=max(ans,maxPro(l,i)+maxPro(l,w-i));\\n        }\\n        \\n        return dp[l][w]= ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& price) {\\n        dp.assign(m+1,vector<long long>(n+1,-1));\\n        for(auto &v:price){\\n            prices[{v[0],v[1]}]=v[2];\\n        }\\n        \\n        return maxPro(m,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> prices;\\n    vector<vector<long long>> dp;\\n    long long maxPro(int l,int w){\\n        if(dp[l][w]!=-1) return dp[l][w];\\n        long long ans=0;\\n        if(prices.count({l,w})) ans=prices[{l,w}];\\n        \\n        for(int i=1;i<=l-1;i++){\\n            ans=max(ans,maxPro(i,w)+maxPro(l-i,w));\\n        }\\n        for(int i=1;i<=w-1;i++){\\n            ans=max(ans,maxPro(l,i)+maxPro(l,w-i));\\n        }\\n        \\n        return dp[l][w]= ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& price) {\\n        dp.assign(m+1,vector<long long>(n+1,-1));\\n        for(auto &v:price){\\n            prices[{v[0],v[1]}]=v[2];\\n        }\\n        \\n        return maxPro(m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521051,
                "title": "clean-c-tabulation-dp",
                "content": "``` \\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        int val[201][201];\\n        memset(val,0,sizeof val);\\n        \\n        for(auto a:prices){\\n            val[a[0]][a[1]] = a[2];\\n        }\\n        \\n        \\n        long long int dp[m+1][n+1];\\n        \\n        memset(dp,0,sizeof dp);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n               \\n                dp[i][j] = val[i][j];\\n                \\n                for(int k=0;k<=i;k++){\\n                    dp[i][j] = max(dp[k][j]+dp[i-k][j],dp[i][j]);\\n                }\\n                for(int k=0;k<=j;k++){\\n                    dp[i][j] = max(dp[i][k]+dp[i][j-k],dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n   \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        int val[201][201];\\n        memset(val,0,sizeof val);\\n        \\n        for(auto a:prices){\\n            val[a[0]][a[1]] = a[2];\\n        }\\n        \\n        \\n        long long int dp[m+1][n+1];\\n        \\n        memset(dp,0,sizeof dp);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n               \\n                dp[i][j] = val[i][j];\\n                \\n                for(int k=0;k<=i;k++){\\n                    dp[i][j] = max(dp[k][j]+dp[i-k][j],dp[i][j]);\\n                }\\n                for(int k=0;k<=j;k++){\\n                    dp[i][j] = max(dp[i][k]+dp[i][j-k],dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n   \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435937,
                "title": "c-top-down-dp-and-bottom-up-dp-with-comments-o-m-n-m-n",
                "content": "# [C++] Top-Down DP and Bottom-Up DP, O(m*n*(m+n))\\n\\n##### Top-Down DP\\n* for a board of size (m, n), we can choose the best result from 3 options:\\n\\t* the price of (m,n) if it\\'s sellable directly\\n\\t* the profit of cutting it along the rows\\n\\t* the profit of cutting it along the columns.\\n* We find the min & max heights and widths of the sellable boards, and use them to make the search space sparser.\\n\\n```\\nclass Solution {  // TopDownDP\\n    unordered_map<int, int> _priceMap;\\n    // the max height and width of wood pieces.\\n    int _maxH = 0; // cut along row, at 1 ... _maxH\\n    int _maxW = 0; // cut along col, at 1 ... _maxW\\n    int _minH = INT_MAX;\\n    int _minW = INT_MAX;\\n    // memo[H][W] = the max of:\\n    // 1) the price of wood board of size (H,W), if it\\'s sellable; otherwise 0.\\n    // 2) max(memo[c][W] + memo[H-c][W]) for c from minH to maxH and c < H, ie cut along the row\\n    // 3) max(memo[H][c] + memo[H][W-c]) for c from minW to maxW and c < W, ie cut along the row\\n    long long _memo[201][201] = {};\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        //\\n        processPrices(prices);\\n        // because 0 is a legitimate price, we initialize the dp memo entries to -1.\\n        memset(_memo, -1, sizeof(_memo));\\n\\n        return dfs(m, n);\\n    }\\n\\nprivate:\\n    long long dfs(int m, int n) {\\n        if (_memo[m][n] != -1) {\\n            return _memo[m][n];\\n        }\\n        // this is the baseline profit.\\n        // sometimes we can make more profit by cutting the lumber further.\\n        // therefore, even if (m,n) has a positive price, we should continue search.\\n        long long profit = getPrice(m, n);\\n        // cut along the row, at _minH ... _maxH\\n        // note that: if h >= m, we won\\'t cut it along the row again.\\n        for (int h = _minH; h <= _maxH && h < m; ++h) {\\n            profit = max(profit, dfs(h, n) + dfs(m - h, n));\\n        }\\n        // cut along the colum, at _minW ... _maxW\\n        // note that: if w >= n, we won\\'t cut it along the col again.\\n        for (int w = _minW; w <= _maxW && w < n; ++w) {\\n            profit = max(profit, dfs(m, w) + dfs(m, n - w));\\n        }\\n\\n        return _memo[m][n] = profit;\\n    }\\n\\n    void processPrices(const vector<vector<int>>& prices) {\\n        _priceMap.clear();\\n        _maxH = 0;\\n        _maxW = 0;\\n        _minH = INT_MAX;\\n        _minW = INT_MAX;\\n\\n        for (auto& p : prices) {\\n            int h = p[0], w = p[1], price = p[2];\\n            int key = (h << 16) | w;\\n            _priceMap[key] = price;\\n            _maxH = max(_maxH, h);\\n            _maxW = max(_maxW, w);\\n            _minH = min(_minH, h);\\n            _minW = min(_minW, w);\\n        }\\n    }\\n\\n    int getPrice(int h, int w) const {\\n        int key = (h << 16) | w;\\n        if (auto iter = _priceMap.find(key); iter != _priceMap.end()) {\\n            return iter->second;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n-------------\\n==============\\n\\n##### Bottom-Up DP\\n* We should process the entries in a dense fashion, to make sure  that `dp[m][n]` is properly filled.\\n\\n\\n```\\n// dp[H][W] = the max of:\\n// 1) the price of wood board of size (H,W), if it\\'s sellable; otherwise 0.\\n// 2) max(dp[c][W] + dp[H-c][W]) for c from minH to maxH and c < H, ie cut along the row\\n// 3) max(dp[H][c] + dp[H][W-c]) for c from minW to maxW and c < W, ie cut along the col\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // for bottom-up dp, we may set the dp entries to 0.\\n        long long dp[201][201] = {};\\n        // process the prices\\n        for (auto& p : prices) {\\n            const int h = p[0], w = p[1], price = p[2];\\n            dp[h][w] = price;\\n        }\\n\\n        //\\n        for (int h = 1; h <= m; ++h) {\\n            for (int w = 1; w <= n; ++w) {\\n                // cut (h,w) by the rows\\n                for (int c = 1; c <= h / 2; ++c) {\\n                    // no worries: because c <= h-1, and h-c <= h-1,\\n                    // dp[c][w] and dp[h - c][w] contains good results.\\n                    dp[h][w] = max(dp[h][w], dp[c][w] + dp[h - c][w]);\\n                }\\n                // cut (h,w) by the columns\\n                for (int c = 1; c <= w / 2; ++c) {\\n                    // same reasoning:\\n                    // because c <= w-1 and w-c <= w-1,\\n                    // dp[h][c] and dp[h][w - c] contains good results.\\n                    dp[h][w] = max(dp[h][w], dp[h][c] + dp[h][w - c]);\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {  // TopDownDP\\n    unordered_map<int, int> _priceMap;\\n    // the max height and width of wood pieces.\\n    int _maxH = 0; // cut along row, at 1 ... _maxH\\n    int _maxW = 0; // cut along col, at 1 ... _maxW\\n    int _minH = INT_MAX;\\n    int _minW = INT_MAX;\\n    // memo[H][W] = the max of:\\n    // 1) the price of wood board of size (H,W), if it\\'s sellable; otherwise 0.\\n    // 2) max(memo[c][W] + memo[H-c][W]) for c from minH to maxH and c < H, ie cut along the row\\n    // 3) max(memo[H][c] + memo[H][W-c]) for c from minW to maxW and c < W, ie cut along the row\\n    long long _memo[201][201] = {};\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        //\\n        processPrices(prices);\\n        // because 0 is a legitimate price, we initialize the dp memo entries to -1.\\n        memset(_memo, -1, sizeof(_memo));\\n\\n        return dfs(m, n);\\n    }\\n\\nprivate:\\n    long long dfs(int m, int n) {\\n        if (_memo[m][n] != -1) {\\n            return _memo[m][n];\\n        }\\n        // this is the baseline profit.\\n        // sometimes we can make more profit by cutting the lumber further.\\n        // therefore, even if (m,n) has a positive price, we should continue search.\\n        long long profit = getPrice(m, n);\\n        // cut along the row, at _minH ... _maxH\\n        // note that: if h >= m, we won\\'t cut it along the row again.\\n        for (int h = _minH; h <= _maxH && h < m; ++h) {\\n            profit = max(profit, dfs(h, n) + dfs(m - h, n));\\n        }\\n        // cut along the colum, at _minW ... _maxW\\n        // note that: if w >= n, we won\\'t cut it along the col again.\\n        for (int w = _minW; w <= _maxW && w < n; ++w) {\\n            profit = max(profit, dfs(m, w) + dfs(m, n - w));\\n        }\\n\\n        return _memo[m][n] = profit;\\n    }\\n\\n    void processPrices(const vector<vector<int>>& prices) {\\n        _priceMap.clear();\\n        _maxH = 0;\\n        _maxW = 0;\\n        _minH = INT_MAX;\\n        _minW = INT_MAX;\\n\\n        for (auto& p : prices) {\\n            int h = p[0], w = p[1], price = p[2];\\n            int key = (h << 16) | w;\\n            _priceMap[key] = price;\\n            _maxH = max(_maxH, h);\\n            _maxW = max(_maxW, w);\\n            _minH = min(_minH, h);\\n            _minW = min(_minW, w);\\n        }\\n    }\\n\\n    int getPrice(int h, int w) const {\\n        int key = (h << 16) | w;\\n        if (auto iter = _priceMap.find(key); iter != _priceMap.end()) {\\n            return iter->second;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n// dp[H][W] = the max of:\\n// 1) the price of wood board of size (H,W), if it\\'s sellable; otherwise 0.\\n// 2) max(dp[c][W] + dp[H-c][W]) for c from minH to maxH and c < H, ie cut along the row\\n// 3) max(dp[H][c] + dp[H][W-c]) for c from minW to maxW and c < W, ie cut along the col\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // for bottom-up dp, we may set the dp entries to 0.\\n        long long dp[201][201] = {};\\n        // process the prices\\n        for (auto& p : prices) {\\n            const int h = p[0], w = p[1], price = p[2];\\n            dp[h][w] = price;\\n        }\\n\\n        //\\n        for (int h = 1; h <= m; ++h) {\\n            for (int w = 1; w <= n; ++w) {\\n                // cut (h,w) by the rows\\n                for (int c = 1; c <= h / 2; ++c) {\\n                    // no worries: because c <= h-1, and h-c <= h-1,\\n                    // dp[c][w] and dp[h - c][w] contains good results.\\n                    dp[h][w] = max(dp[h][w], dp[c][w] + dp[h - c][w]);\\n                }\\n                // cut (h,w) by the columns\\n                for (int c = 1; c <= w / 2; ++c) {\\n                    // same reasoning:\\n                    // because c <= w-1 and w-c <= w-1,\\n                    // dp[h][c] and dp[h][w - c] contains good results.\\n                    dp[h][w] = max(dp[h][w], dp[h][c] + dp[h][w - c]);\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415460,
                "title": "python-dp-recusrion-memo",
                "content": "```class Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        # @cache\\n        def f(m,n):\\n            if dp[m][n] != -1:\\n                return dp[m][n]\\n            if not ((m,n) in h):\\n                h[(m,n)] = 0\\n            ans = h[(m,n)]\\n            for i in range(1,m//2+1):\\n                ans = max(ans,f(i,n)+f(m-i,n))\\n            for i in range(1,n//2+1):\\n                ans = max(ans,f(m,i)+f(m,n-i))\\n            dp[m][n] = ans\\n            return ans\\n            \\n        h = defaultdict(int)\\n        for i,j,k in prices:\\n            h[(i,j)] = k\\n        dp = [[-1 for _ in range(n+1)] for _ in range(m+1)]\\n        return f(m,n)\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        # @cache\\n        def f(m,n):\\n            if dp[m][n] != -1:\\n                return dp[m][n]\\n            if not ((m,n) in h):\\n                h[(m,n)] = 0\\n            ans = h[(m,n)]\\n            for i in range(1,m//2+1):\\n                ans = max(ans,f(i,n)+f(m-i,n))\\n            for i in range(1,n//2+1):\\n                ans = max(ans,f(m,i)+f(m,n-i))\\n            dp[m][n] = ans\\n            return ans\\n            \\n        h = defaultdict(int)\\n        for i,j,k in prices:\\n            h[(i,j)] = k\\n        dp = [[-1 for _ in range(n+1)] for _ in range(m+1)]\\n        return f(m,n)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2338239,
                "title": "python-3-standard-dp",
                "content": "we can make either horizontalcut or vertical cut so we look for everything and because of symmetry we just check till curr_height//2 or curr_width//2\\n\\n\\tclass Solution:\\n\\t\\t\\tdef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\t\\t\\t\\tdp=[[0]*(n+1) for _ in range(m+1)]\\n\\t\\t\\t\\tfor i,j,cost in prices:\\n\\t\\t\\t\\t\\tdp[i][j]=cost\\n\\t\\t\\t\\tfor i in range(1,m+1):\\n\\t\\t\\t\\t\\tfor j in range(1,n+1):\\n\\t\\t\\t\\t\\t\\tfor h in range(1,i//2+1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i][j],dp[i-h][j]+dp[h][j])\\n\\t\\t\\t\\t\\t\\tfor w in range(1,j//2+1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i][j],dp[i][j-w]+dp[i][w])\\n\\t\\t\\t\\treturn dp[m][n]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "we can make either horizontalcut or vertical cut so we look for everything and because of symmetry we just check till curr_height//2 or curr_width//2\\n\\n\\tclass Solution:\\n\\t\\t\\tdef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\t\\t\\t\\tdp=[[0]*(n+1) for _ in range(m+1)]\\n\\t\\t\\t\\tfor i,j,cost in prices:\\n\\t\\t\\t\\t\\tdp[i][j]=cost\\n\\t\\t\\t\\tfor i in range(1,m+1):\\n\\t\\t\\t\\t\\tfor j in range(1,n+1):\\n\\t\\t\\t\\t\\t\\tfor h in range(1,i//2+1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i][j],dp[i-h][j]+dp[h][j])\\n\\t\\t\\t\\t\\t\\tfor w in range(1,j//2+1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i][j],dp[i][j-w]+dp[i][w])\\n\\t\\t\\t\\treturn dp[m][n]",
                "codeTag": "Java"
            },
            {
                "id": 2263530,
                "title": "java-simple-dp-soln",
                "content": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        \\n        Map<String, Integer> cost = new HashMap<>();\\n        \\n        for (int[] price : prices) {\\n            cost.put(price[0] + \":\" + price[1], price[2]);\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                // vertical cut\\n                for (int v = 1; v <= j/2; v++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][v] + dp[i][j-v]);\\n                }\\n                // horizontal cut\\n                for (int h = 1; h <= i/2; h++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[h][j] + dp[i-h][j]);\\n                }\\n                // Cost already given\\n                dp[i][j] = Math.max(dp[i][j], cost.getOrDefault(i + \":\" + j, 0));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        \\n        Map<String, Integer> cost = new HashMap<>();\\n        \\n        for (int[] price : prices) {\\n            cost.put(price[0] + \":\" + price[1], price[2]);\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                // vertical cut\\n                for (int v = 1; v <= j/2; v++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][v] + dp[i][j-v]);\\n                }\\n                // horizontal cut\\n                for (int h = 1; h <= i/2; h++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[h][j] + dp[i-h][j]);\\n                }\\n                // Cost already given\\n                dp[i][j] = Math.max(dp[i][j], cost.getOrDefault(i + \":\" + j, 0));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210198,
                "title": "python-lru-cache-and-recursion",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def f(m,n):\\n            if m==0 or n==0:return 0\\n            ans=0\\n            if (m,n) in x:\\n                ans=x[m,n]\\n            for j in range(1,m//2+1):\\n                ans=max(ans,f(j,n)+f(m-j,n))\\n            for j in range(1,n//2+1):\\n                ans=max(ans,f(m,j)+f(m,n-j))\\n            return ans\\n        x={}\\n        for a,b,c in prices:\\n            x[a,b]=c\\n        return f(m,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def f(m,n):\\n            if m==0 or n==0:return 0\\n            ans=0\\n            if (m,n) in x:\\n                ans=x[m,n]\\n            for j in range(1,m//2+1):\\n                ans=max(ans,f(j,n)+f(m-j,n))\\n            for j in range(1,n//2+1):\\n                ans=max(ans,f(m,j)+f(m,n-j))\\n            return ans\\n        x={}\\n        for a,b,c in prices:\\n            x[a,b]=c\\n        return f(m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194726,
                "title": "java-simple-recursion-solution-with-memoization",
                "content": "```\\nclass Solution {\\n    Long[][] dp;\\n    Integer[][] store;\\n    int MIN = -1*((int)1e8 + 5);\\n    long helper(int w, int h, int[][] prices){\\n        if(w == 0 || h == 0) return 0;\\n        \\n        if(dp[w][h] != null) return dp[w][h];\\n        // if(store[w][h] != null) return store[w][h];\\n\\n        long max = (store[w][h] != null) ? store[w][h] : 0;\\n        // making vertical cut...\\n        for(int i = 1; i < w; i++){\\n            long a = helper(w - i, h, prices) + helper(i, h, prices);\\n            max = Math.max(max, a);\\n        }\\n        \\n        // making horizontal cut\\n        for(int i = 1; i < h; i++){\\n            long a = helper(w, h - i, prices) + helper(w, i, prices);\\n            max = Math.max(max, a);\\n        }\\n        \\n        return dp[w][h] = max;\\n        // System.out.println(\" --> \" + max);\\n        // return max;\\n    }\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        \\n        dp = new Long[n+1][m+1];\\n        store = new Integer[n+1][m+1];\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            int h = prices[i][0];\\n            int w = prices[i][1];\\n            int p = prices[i][2];\\n            store[w][h] = p;\\n        }\\n        \\n        // n = w , m = h\\n        long max = helper(n, m, prices);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Long[][] dp;\\n    Integer[][] store;\\n    int MIN = -1*((int)1e8 + 5);\\n    long helper(int w, int h, int[][] prices){\\n        if(w == 0 || h == 0) return 0;\\n        \\n        if(dp[w][h] != null) return dp[w][h];\\n        // if(store[w][h] != null) return store[w][h];\\n\\n        long max = (store[w][h] != null) ? store[w][h] : 0;\\n        // making vertical cut...\\n        for(int i = 1; i < w; i++){\\n            long a = helper(w - i, h, prices) + helper(i, h, prices);\\n            max = Math.max(max, a);\\n        }\\n        \\n        // making horizontal cut\\n        for(int i = 1; i < h; i++){\\n            long a = helper(w, h - i, prices) + helper(w, i, prices);\\n            max = Math.max(max, a);\\n        }\\n        \\n        return dp[w][h] = max;\\n        // System.out.println(\" --> \" + max);\\n        // return max;\\n    }\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        \\n        dp = new Long[n+1][m+1];\\n        store = new Integer[n+1][m+1];\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            int h = prices[i][0];\\n            int w = prices[i][1];\\n            int p = prices[i][2];\\n            store[w][h] = p;\\n        }\\n        \\n        // n = w , m = h\\n        long max = helper(n, m, prices);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192871,
                "title": "easy-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[201][201];\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n          for(int i=0; i<prices.size(); i++) dp[prices[i][0]][prices[i][1]]=prices[i][2];\\n          for(int i=1; i<=m; i++) {\\n              for(int j=1; j<=n; j++) {\\n                   for(int area=1; area<=i/2; area++) dp[i][j]=max(dp[i][j],dp[area][j]+dp[i-area][j]);\\n                   for(int area=1; area<=j/2; area++) dp[i][j]=max(dp[i][j],dp[i][area]+dp[i][j-area]);\\n              }\\n          }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[201][201];\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n          for(int i=0; i<prices.size(); i++) dp[prices[i][0]][prices[i][1]]=prices[i][2];\\n          for(int i=1; i<=m; i++) {\\n              for(int j=1; j<=n; j++) {\\n                   for(int area=1; area<=i/2; area++) dp[i][j]=max(dp[i][j],dp[area][j]+dp[i-area][j]);\\n                   for(int area=1; area<=j/2; area++) dp[i][j]=max(dp[i][j],dp[i][area]+dp[i][j-area]);\\n              }\\n          }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191716,
                "title": "javascript-easy-simple-solution",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    let map={},cache={};\\n    for(let i=0;i<prices.length;i++){\\n        let r=prices[i][0];\\n        let c=prices[i][1];\\n        map[r+\"_\"+c]=prices[i][2];\\n    }\\n    let ans = backtrack(m,n);\\n    return ans;\\n    function backtrack(rows,cols){\\n        let key = rows+\"_\"+cols;\\n        if(cache[key]!==undefined){\\n            return cache[key];\\n        }\\n        \\n        let p0=0,p1=0,p2=0;\\n        if(map[key]!==undefined){//Check if there is a price for the entire wood board\\n            p0 = map[key];\\n        }\\n        if(rows>1){//Check by cutting rows\\n            for(let i=1;i<=Math.floor(rows/2);i++){//Note: for rows=5 we just need to check 1,4 and 2,3 only as rest of 3,2 and 4,1 will give the same results. So we are runing from i=1 till i<=Math.floor(rows/2)\\n                let r = backtrack(rows-i,cols)+backtrack(i,cols);\\n                p1 = Math.max(r,p1);\\n            }\\n        }\\n        if(cols>1){//Check by cutting cols\\n            for(let i=1;i<=Math.floor(cols/2);i++){\\n                let r = backtrack(rows,cols-i)+backtrack(rows,i);\\n                p2 = Math.max(r,p2);\\n            }\\n        }\\n        let res = Math.max(p0,p1,p2);\\n        cache[key] = res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    let map={},cache={};\\n    for(let i=0;i<prices.length;i++){\\n        let r=prices[i][0];\\n        let c=prices[i][1];\\n        map[r+\"_\"+c]=prices[i][2];\\n    }\\n    let ans = backtrack(m,n);\\n    return ans;\\n    function backtrack(rows,cols){\\n        let key = rows+\"_\"+cols;\\n        if(cache[key]!==undefined){\\n            return cache[key];\\n        }\\n        \\n        let p0=0,p1=0,p2=0;\\n        if(map[key]!==undefined){//Check if there is a price for the entire wood board\\n            p0 = map[key];\\n        }\\n        if(rows>1){//Check by cutting rows\\n            for(let i=1;i<=Math.floor(rows/2);i++){//Note: for rows=5 we just need to check 1,4 and 2,3 only as rest of 3,2 and 4,1 will give the same results. So we are runing from i=1 till i<=Math.floor(rows/2)\\n                let r = backtrack(rows-i,cols)+backtrack(i,cols);\\n                p1 = Math.max(r,p1);\\n            }\\n        }\\n        if(cols>1){//Check by cutting cols\\n            for(let i=1;i<=Math.floor(cols/2);i++){\\n                let r = backtrack(rows,cols-i)+backtrack(rows,i);\\n                p2 = Math.max(r,p2);\\n            }\\n        }\\n        let res = Math.max(p0,p1,p2);\\n        cache[key] = res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186853,
                "title": "go-search-with-memoization",
                "content": "```\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n    maxp, memo, dictp := make([][]int, m + 1), make([][]int, m + 1), make([][]int, m + 1)\\n    for i := 0; i < m + 1; i++ {\\n        maxp[i] = make([]int, n + 1)\\n        memo[i] = make([]int, n + 1)\\n        dictp[i] = make([]int, n + 1)\\n        for j := 0; j < n + 1; j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    \\n    for _, p := range prices {\\n        dictp[p[0]][p[1]] = max(dictp[p[0]][p[1]], p[2])\\n    }\\n    \\n    get_maxp(m, n, maxp, dictp)\\n    \\n    return int64(dfs(m, n, maxp, memo))\\n}\\n\\nfunc get_maxp(m int, n int, maxp [][]int, dictp [][]int) {\\n    for i := 1; i <= m; i++ {\\n        for j := 1; j <= n; j++ {\\n            maxp[i][j] = max(maxp[i - 1][j], maxp[i][j - 1])\\n            maxp[i][j] = max(maxp[i][j], dictp[i][j])\\n        }\\n    }\\n}\\n\\nfunc dfs(m int, n int, maxp [][]int, memo [][]int) int {    \\n    if memo[m][n] != -1 {\\n        return memo[m][n]\\n    }\\n    \\n    res := maxp[m][n]\\n    \\n    for i := 1; i <= m / 2; i++ {\\n        res = max(res, dfs(i, n, maxp, memo) + dfs(m - i, n, maxp, memo))\\n    }\\n    \\n    for i := 1; i <= n / 2; i++ {\\n        res = max(res, dfs(m, i, maxp, memo) + dfs(m, n - i, maxp, memo))\\n    }\\n\\n    memo[m][n] = res\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n    maxp, memo, dictp := make([][]int, m + 1), make([][]int, m + 1), make([][]int, m + 1)\\n    for i := 0; i < m + 1; i++ {\\n        maxp[i] = make([]int, n + 1)\\n        memo[i] = make([]int, n + 1)\\n        dictp[i] = make([]int, n + 1)\\n        for j := 0; j < n + 1; j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    \\n    for _, p := range prices {\\n        dictp[p[0]][p[1]] = max(dictp[p[0]][p[1]], p[2])\\n    }\\n    \\n    get_maxp(m, n, maxp, dictp)\\n    \\n    return int64(dfs(m, n, maxp, memo))\\n}\\n\\nfunc get_maxp(m int, n int, maxp [][]int, dictp [][]int) {\\n    for i := 1; i <= m; i++ {\\n        for j := 1; j <= n; j++ {\\n            maxp[i][j] = max(maxp[i - 1][j], maxp[i][j - 1])\\n            maxp[i][j] = max(maxp[i][j], dictp[i][j])\\n        }\\n    }\\n}\\n\\nfunc dfs(m int, n int, maxp [][]int, memo [][]int) int {    \\n    if memo[m][n] != -1 {\\n        return memo[m][n]\\n    }\\n    \\n    res := maxp[m][n]\\n    \\n    for i := 1; i <= m / 2; i++ {\\n        res = max(res, dfs(i, n, maxp, memo) + dfs(m - i, n, maxp, memo))\\n    }\\n    \\n    for i := 1; i <= n / 2; i++ {\\n        res = max(res, dfs(m, i, maxp, memo) + dfs(m, n - i, maxp, memo))\\n    }\\n\\n    memo[m][n] = res\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186309,
                "title": "matrix-chain-multiplication",
                "content": "```\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\n\\tunordered_map<int, unordered_map<int,ll>> mp;\\n\\tfor(auto& p : prices) mp[p[0]][p[1]] = p[2];\\n\\n\\tvector<vector<ll>> dp(m+1, vector<ll>(n+1));\\n\\n\\tfor(int h=1;h <= m; h++){\\n\\t\\tfor(int w = 1; w <= n; w++){\\n\\n\\t\\t\\tll maxProfit = (mp[h].count(w) ? mp[h][w] : 0);\\n\\n\\t\\t\\t// Horizontal Cuts\\n\\t\\t\\tfor(int i=1;i<h;i++){\\n\\n\\t\\t\\t\\tll maxProfitUp = dp[i][w];\\n\\t\\t\\t\\tll maxProfitDown = dp[h-i][w];\\n\\n\\t\\t\\t\\tll totProfit = maxProfitUp + maxProfitDown;\\n\\n\\t\\t\\t\\tmaxProfit = max(maxProfit, totProfit);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t//Vertical Cuts\\n\\t\\t\\tfor(int j=1;j<w;j++){\\n\\n\\t\\t\\t\\tll maxProfitLeft = dp[h][j];\\n\\t\\t\\t\\tll maxProfitRight = dp[h][w-j];\\n\\n\\t\\t\\t\\tll totProfit = maxProfitLeft + maxProfitRight;\\n\\n\\t\\t\\t\\tmaxProfit = max(maxProfit, totProfit);\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[h][w] = maxProfit;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn dp[m][n];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\n\\tunordered_map<int, unordered_map<int,ll>> mp;\\n\\tfor(auto& p : prices) mp[p[0]][p[1]] = p[2];\\n\\n\\tvector<vector<ll>> dp(m+1, vector<ll>(n+1));\\n\\n\\tfor(int h=1;h <= m; h++){\\n\\t\\tfor(int w = 1; w <= n; w++){\\n\\n\\t\\t\\tll maxProfit = (mp[h].count(w) ? mp[h][w] : 0);\\n\\n\\t\\t\\t// Horizontal Cuts\\n\\t\\t\\tfor(int i=1;i<h;i++){\\n\\n\\t\\t\\t\\tll maxProfitUp = dp[i][w];\\n\\t\\t\\t\\tll maxProfitDown = dp[h-i][w];\\n\\n\\t\\t\\t\\tll totProfit = maxProfitUp + maxProfitDown;\\n\\n\\t\\t\\t\\tmaxProfit = max(maxProfit, totProfit);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t//Vertical Cuts\\n\\t\\t\\tfor(int j=1;j<w;j++){\\n\\n\\t\\t\\t\\tll maxProfitLeft = dp[h][j];\\n\\t\\t\\t\\tll maxProfitRight = dp[h][w-j];\\n\\n\\t\\t\\t\\tll totProfit = maxProfitLeft + maxProfitRight;\\n\\n\\t\\t\\t\\tmaxProfit = max(maxProfit, totProfit);\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[h][w] = maxProfit;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2182791,
                "title": "scala-functional-top-down-dp",
                "content": "```\\n  def sellingWood(height: Int, width: Int, prices: Array[Array[Int]]): Long = {\\n    val priceMap = prices.map { case Array(h, w, p) => (h, w) -> p.toLong }.toMap\\n    val mem      = scala.collection.mutable.Map.empty[(Int, Int), Long]\\n\\n    def dfs(height: Int, width: Int): Long = mem.getOrElseUpdate((height, width), {\\n      val verticalCuts   = (1 to width / 2).map(col => dfs(height, col) + dfs(height, width - col))\\n      val horizontalCuts = (1 to height / 2).map(row => dfs(row, width) + dfs(height - row, width))\\n      (horizontalCuts ++ verticalCuts ++ priceMap.get((height, width))).maxOption.getOrElse(0L)\\n    })\\n\\n    dfs(height, width)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def sellingWood(height: Int, width: Int, prices: Array[Array[Int]]): Long = {\\n    val priceMap = prices.map { case Array(h, w, p) => (h, w) -> p.toLong }.toMap\\n    val mem      = scala.collection.mutable.Map.empty[(Int, Int), Long]\\n\\n    def dfs(height: Int, width: Int): Long = mem.getOrElseUpdate((height, width), {\\n      val verticalCuts   = (1 to width / 2).map(col => dfs(height, col) + dfs(height, width - col))\\n      val horizontalCuts = (1 to height / 2).map(row => dfs(row, width) + dfs(height - row, width))\\n      (horizontalCuts ++ verticalCuts ++ priceMap.get((height, width))).maxOption.getOrElse(0L)\\n    })\\n\\n    dfs(height, width)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2180808,
                "title": "c-dp-solution-beat-77-54",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<long long>> dp;\\n    unordered_map<int, int> mp;\\n    \\n    void findMax(vector<vector<int>>& prices, int i, int j){\\n        long long money = mp.count(i * 1000 + j) ? mp[i * 1000 + j] : 0;\\n        if(i >= 2) for(int cut = 1; cut <= i / 2; cut++)\\n            money = max(money, dp[cut][j] + dp[i - cut][j]);\\n        if(j >= 2) for(int cut = 1; cut <= j / 2; cut++)\\n            money = max(money, dp[i][cut] + dp[i][j - cut]);\\n        dp[i][j] = money;\\n    }\\n    \\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        dp.resize(m + 1, vector<long long>(n + 1, 0));\\n        for(auto price : prices) mp[price[0] * 1000 + price[1]] = price[2];\\n        for(int i = 1; i <= m; i++) \\n            for(int j = 1; j <= n; j++)\\n                findMax(prices, i, j);\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<long long>> dp;\\n    unordered_map<int, int> mp;\\n    \\n    void findMax(vector<vector<int>>& prices, int i, int j){\\n        long long money = mp.count(i * 1000 + j) ? mp[i * 1000 + j] : 0;\\n        if(i >= 2) for(int cut = 1; cut <= i / 2; cut++)\\n            money = max(money, dp[cut][j] + dp[i - cut][j]);\\n        if(j >= 2) for(int cut = 1; cut <= j / 2; cut++)\\n            money = max(money, dp[i][cut] + dp[i][j - cut]);\\n        dp[i][j] = money;\\n    }\\n    \\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        dp.resize(m + 1, vector<long long>(n + 1, 0));\\n        for(auto price : prices) mp[price[0] * 1000 + price[1]] = price[2];\\n        for(int i = 1; i <= m; i++) \\n            for(int j = 1; j <= n; j++)\\n                findMax(prices, i, j);\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178781,
                "title": "c-bottom-up-dp-easy-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n        vector<vector<ll>>f(m+1,vector<ll>(n+1,0));\\n        vector<vector<ll>>record(m+1,vector<ll>(n+1,0));\\n        for(auto &x:prices)record[x[0]][x[1]]=x[2];\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++)\\n            {\\n                f[i][j]=max(f[i][j],record[i][j]);\\n                for(int k=1;k<i;k++)\\n                    f[i][j]=max(f[i][j],f[k][j]+f[i-k][j]);\\n                for(int k=1;k<j;k++)\\n                    f[i][j]=max(f[i][j],f[i][k]+f[i][j-k]);\\n            }\\n        return f[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n        vector<vector<ll>>f(m+1,vector<ll>(n+1,0));\\n        vector<vector<ll>>record(m+1,vector<ll>(n+1,0));\\n        for(auto &x:prices)record[x[0]][x[1]]=x[2];\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++)\\n            {\\n                f[i][j]=max(f[i][j],record[i][j]);\\n                for(int k=1;k<i;k++)\\n                    f[i][j]=max(f[i][j],f[k][j]+f[i-k][j]);\\n                for(int k=1;k<j;k++)\\n                    f[i][j]=max(f[i][j],f[i][k]+f[i][j-k]);\\n            }\\n        return f[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177426,
                "title": "java-dp-recursion-memo",
                "content": "```\\n        //TC = O(mn), SC = O(mn)\\n       /*\\n        The idea is to make horizontal cuts ie, if i make a cut of {i,j} I can further convert it into pieces of (ii, j) and (i-ii, j) and get the max ans\\n        Repeat above steps for vertical cut\\n        return max result.\\n        */\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] memo = new long[m + 1][n + 1];\\n        for (int i = 0; i <= m; i++) Arrays.fill(memo[i], -1);\\n        long[][] p = new long[m + 1][n + 1]; // prices of cut of dimention {i*j}\\n\\n        for (int[] pri : prices) p[pri[0]][pri[1]] = pri[2];\\n        return dp(m, n, p, memo);\\n    }\\n\\n    private long dp(int i, int j, long[][] p, long[][] memo) {\\n        // base case\\n        if (i == 0 || j == 0) return 0;\\n\\n        if (memo[i][j] != -1) return memo[i][j];\\n        long ans = p[i][j];\\n\\n        for (int ii = 1; ii <= i / 2; ii++) {\\n            ans = Math.max(ans, dp(ii, j, p, memo) + dp(i - ii, j, p, memo));\\n        }\\n\\n        for (int jj = 1; jj <= j / 2; jj++) {\\n            ans = Math.max(ans, dp(i, jj, p, memo) + dp(i, j - jj, p, memo));\\n        }\\n        return memo[i][j] = ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        //TC = O(mn), SC = O(mn)\\n       /*\\n        The idea is to make horizontal cuts ie, if i make a cut of {i,j} I can further convert it into pieces of (ii, j) and (i-ii, j) and get the max ans\\n        Repeat above steps for vertical cut\\n        return max result.\\n        */\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] memo = new long[m + 1][n + 1];\\n        for (int i = 0; i <= m; i++) Arrays.fill(memo[i], -1);\\n        long[][] p = new long[m + 1][n + 1]; // prices of cut of dimention {i*j}\\n\\n        for (int[] pri : prices) p[pri[0]][pri[1]] = pri[2];\\n        return dp(m, n, p, memo);\\n    }\\n\\n    private long dp(int i, int j, long[][] p, long[][] memo) {\\n        // base case\\n        if (i == 0 || j == 0) return 0;\\n\\n        if (memo[i][j] != -1) return memo[i][j];\\n        long ans = p[i][j];\\n\\n        for (int ii = 1; ii <= i / 2; ii++) {\\n            ans = Math.max(ans, dp(ii, j, p, memo) + dp(i - ii, j, p, memo));\\n        }\\n\\n        for (int jj = 1; jj <= j / 2; jj++) {\\n            ans = Math.max(ans, dp(i, jj, p, memo) + dp(i, j - jj, p, memo));\\n        }\\n        return memo[i][j] = ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176995,
                "title": "rust-divide-and-merge-dfs-memo-o-m-n-m-n",
                "content": "```\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        let mut part_price: HashMap<(i32, i32), i64> = prices.iter()\\n            .map(|x|((x[0], x[1]), x[2] as i64))\\n            .collect();\\n\\n        // let mut part_price: HashMap<(i32, i32), i64> = HashMap::new();\\n        // for p in prices {\\n        //     part_price.insert((p[0], p[1]), p[2] as i64);\\n        // }\\n        let mut f: HashMap<(i32, i32), i64> = HashMap::new();\\n        let ans = dfs(m, n, &part_price, &mut f);\\n        ans\\n    }\\n}\\n\\nfn dfs(high: i32, wid: i32, part_price: &HashMap<(i32, i32), i64>, f: &mut HashMap<(i32, i32), i64>) -> i64 {\\n    let mut ans: i64 = 0;\\n    if f.contains_key(&(high, wid)) {\\n        return f[&(high, wid)];\\n    }\\n    if part_price.contains_key(&(high, wid)) {\\n        ans = part_price[&(high, wid)];\\n    }\\n    let half_high = high/2 + 1;\\n    let half_wid = wid/2 + 1;\\n    for h in 1..half_high {\\n        let up = dfs(h, wid, part_price, f);\\n        let down = dfs(high - h, wid, part_price, f);\\n        ans = max(ans, up + down);\\n    }\\n    for w in 1..half_wid {\\n        let left = dfs(high, w, part_price, f);\\n        let right = dfs(high, wid - w, part_price, f);\\n        ans = max(ans, left + right);\\n    }\\n    f.insert((high, wid), ans);\\n    ans\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        let mut part_price: HashMap<(i32, i32), i64> = prices.iter()\\n            .map(|x|((x[0], x[1]), x[2] as i64))\\n            .collect();\\n\\n        // let mut part_price: HashMap<(i32, i32), i64> = HashMap::new();\\n        // for p in prices {\\n        //     part_price.insert((p[0], p[1]), p[2] as i64);\\n        // }\\n        let mut f: HashMap<(i32, i32), i64> = HashMap::new();\\n        let ans = dfs(m, n, &part_price, &mut f);\\n        ans\\n    }\\n}\\n\\nfn dfs(high: i32, wid: i32, part_price: &HashMap<(i32, i32), i64>, f: &mut HashMap<(i32, i32), i64>) -> i64 {\\n    let mut ans: i64 = 0;\\n    if f.contains_key(&(high, wid)) {\\n        return f[&(high, wid)];\\n    }\\n    if part_price.contains_key(&(high, wid)) {\\n        ans = part_price[&(high, wid)];\\n    }\\n    let half_high = high/2 + 1;\\n    let half_wid = wid/2 + 1;\\n    for h in 1..half_high {\\n        let up = dfs(h, wid, part_price, f);\\n        let down = dfs(high - h, wid, part_price, f);\\n        ans = max(ans, up + down);\\n    }\\n    for w in 1..half_wid {\\n        let left = dfs(high, w, part_price, f);\\n        let right = dfs(high, wid - w, part_price, f);\\n        ans = max(ans, left + right);\\n    }\\n    f.insert((high, wid), ans);\\n    ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176729,
                "title": "python3-dp-with-explanation",
                "content": "```\\ndef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        # use a dictionary to save size and prices\\n        price_dict = {}\\n        for pi, pj, price in prices:\\n            price_dict[(pi, pj)] = price\\n        \\n        # use dp to calculate the max sale price\\n\\t\\t# dp[1][1] represents [1,1,price] in prices\\n\\t\\t# therefore, we need (m+1)*(n+1) to represent the shapes since dp[i][0] and dp[0][j] are not valid shapes\\n        dp = [[0]*(n+1) for i in range(m+1)]\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if (i,j) in price_dict:\\n                    dp[i][j] = price_dict[(i, j)]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# dp[i][j] is the max of all sub shapes\\n                for ii in range(1,i//2+1):\\n                    x = dp[ii][j]+dp[i-ii][j]\\n                    if x>dp[i][j]:\\n                        dp[i][j] = x \\n                for jj in range(1,j//2+1):\\n                    x = dp[i][jj]+dp[i][j-jj]\\n                    if x>dp[i][j]:\\n                        dp[i][j] = x\\n        \\n        \\n        return dp[m][n]\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        # use a dictionary to save size and prices\\n        price_dict = {}\\n        for pi, pj, price in prices:\\n            price_dict[(pi, pj)] = price\\n        \\n        # use dp to calculate the max sale price\\n\\t\\t# dp[1][1] represents [1,1,price] in prices\\n\\t\\t# therefore, we need (m+1)*(n+1) to represent the shapes since dp[i][0] and dp[0][j] are not valid shapes\\n        dp = [[0]*(n+1) for i in range(m+1)]\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if (i,j) in price_dict:\\n                    dp[i][j] = price_dict[(i, j)]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# dp[i][j] is the max of all sub shapes\\n                for ii in range(1,i//2+1):\\n                    x = dp[ii][j]+dp[i-ii][j]\\n                    if x>dp[i][j]:\\n                        dp[i][j] = x \\n                for jj in range(1,j//2+1):\\n                    x = dp[i][jj]+dp[i][j-jj]\\n                    if x>dp[i][j]:\\n                        dp[i][j] = x\\n        \\n        \\n        return dp[m][n]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2176350,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/3f890a1a0d9001fdd4440b921ddce7ba11a42ef3) for solutions of weekly 298. \\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        mp = {(h, w) : p for h, w, p in prices}\\n        \\n        @cache\\n        def fn(m, n): \\n            \"\"\"Return max money of a mxn piece of wood.\"\"\"\\n            if m == 0 or n == 0: return 0\\n            ans = 0 \\n            if (m, n) in mp: ans = mp[m, n]\\n            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))\\n            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))\\n            return ans \\n        \\n        return fn(m, n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        mp = {(h, w) : p for h, w, p in prices}\\n        \\n        @cache\\n        def fn(m, n): \\n            \"\"\"Return max money of a mxn piece of wood.\"\"\"\\n            if m == 0 or n == 0: return 0\\n            ans = 0 \\n            if (m, n) in mp: ans = mp[m, n]\\n            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))\\n            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))\\n            return ans \\n        \\n        return fn(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176294,
                "title": "scala",
                "content": "```\\nobject Solution {\\n  def sellingWood(m: Int, n: Int, prices: Array[Array[Int]]): Long = {\\n    val dp = Array.fill(m + 1, n + 1)(0L)\\n    for (Array(height, width, price) <- prices) {\\n      dp(height)(width) = price\\n    }\\n    \\n    for {\\n      height <- 1 to m\\n      width <- 1 to n\\n    } {\\n      dp(height)(width) = Iterator(dp(height)(width))\\n        .concat((1 to height / 2).iterator.map(h => dp(h)(width) + dp(height - h)(width)))\\n        .concat((1 to width / 2).iterator.map(w => dp(height)(w) + dp(height)(width - w)))\\n        .max\\n    }\\n    \\n    dp(m)(n)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\nobject Solution {\\n  def sellingWood(m: Int, n: Int, prices: Array[Array[Int]]): Long = {\\n    val dp = Array.fill(m + 1, n + 1)(0L)\\n    for (Array(height, width, price) <- prices) {\\n      dp(height)(width) = price\\n    }\\n    \\n    for {\\n      height <- 1 to m\\n      width <- 1 to n\\n    } {\\n      dp(height)(width) = Iterator(dp(height)(width))\\n        .concat((1 to height / 2).iterator.map(h => dp(h)(width) + dp(height - h)(width)))\\n        .concat((1 to width / 2).iterator.map(w => dp(height)(w) + dp(height)(width - w)))\\n        .max\\n    }\\n    \\n    dp(m)(n)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2176064,
                "title": "c-15-lines-top-down-dp-o-m-n-m-n-time-o-m-n-space",
                "content": "```\\npublic class Solution \\n{\\n    public long SellingWood(int m, int n, int[][] prices) \\n    {\\n        var pricesDict = prices.ToDictionary(price => (price[0], price[1]), price => price[2]);\\n        Dictionary<(int, int), long> dp = new();\\n        \\n        return Work(m, n);\\n        \\n        long Work(int x, int y) \\n        {\\n            if (x == 0 || y == 0) return 0;\\n            \\n            if (!dp.ContainsKey((x, y))) \\n            {\\n                long ans = pricesDict.ContainsKey((x, y)) ? pricesDict[(x, y)] : 0;\\n                \\n                for (int i = 1; i <= x / 2; ++i) ans = Math.Max(ans, Work(i, y) + Work(x - i, y));\\n                for (int i = 1; i <= y / 2; ++i) ans = Math.Max(ans, Work(x, i) + Work(x, y - i));\\n                \\n                dp[(x, y)] = ans;\\n            }  \\n                \\n            return dp[(x, y)];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public long SellingWood(int m, int n, int[][] prices) \\n    {\\n        var pricesDict = prices.ToDictionary(price => (price[0], price[1]), price => price[2]);\\n        Dictionary<(int, int), long> dp = new();\\n        \\n        return Work(m, n);\\n        \\n        long Work(int x, int y) \\n        {\\n            if (x == 0 || y == 0) return 0;\\n            \\n            if (!dp.ContainsKey((x, y))) \\n            {\\n                long ans = pricesDict.ContainsKey((x, y)) ? pricesDict[(x, y)] : 0;\\n                \\n                for (int i = 1; i <= x / 2; ++i) ans = Math.Max(ans, Work(i, y) + Work(x - i, y));\\n                for (int i = 1; i <= y / 2; ++i) ans = Math.Max(ans, Work(x, i) + Work(x, y - i));\\n                \\n                dp[(x, y)] = ans;\\n            }  \\n                \\n            return dp[(x, y)];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175888,
                "title": "c-fastest-100-and-100",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a, vector<int> b)\\n    {\\n        return a[2]>b[2];\\n    }\\n\\t\\n    vector<vector<int>> mem;\\n    vector<vector<int>> vis;\\n\\t\\n    long long rec(int m, int n)\\n    {\\n        if(m==0 || n==0 || mem[m][n]==0)\\n            return 0;\\n        if(vis[m][n])\\n            return mem[m][n];\\n        vis[m][n]=1;\\n        long long sum=mem[m][n];\\n        for(int i=1; i<m; i++)\\n            sum=max(sum, rec(i, n)+rec(m-i, n));\\n        for(int i=1; i<n; i++)\\n            sum=max(sum, rec(m, i)+rec(m, n-i));\\n        mem[m][n]=sum;\\n        return sum;\\n    }\\n\\t\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        mem.assign(m+1, vector<int>(n+1, 0));\\n        vis.assign(m+1, vector<int>(n+1, 0));\\n        sort(prices.begin(), prices.end(), comp);\\n        for(int k=0; k<prices.size(); k++)\\n        {\\n            if(mem[prices[k][0]][prices[k][1]])\\n                continue;\\n            for(int i=prices[k][0]; i<=m; i++)\\n                for(int j=prices[k][1]; j<=n; j++)\\n                {\\n                    if(mem[i][j])\\n                        break;\\n                    mem[i][j]=prices[k][2];\\n                }\\n        }\\n        return rec(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a, vector<int> b)\\n    {\\n        return a[2]>b[2];\\n    }\\n\\t\\n    vector<vector<int>> mem;\\n    vector<vector<int>> vis;\\n\\t\\n    long long rec(int m, int n)\\n    {\\n        if(m==0 || n==0 || mem[m][n]==0)\\n            return 0;\\n        if(vis[m][n])\\n            return mem[m][n];\\n        vis[m][n]=1;\\n        long long sum=mem[m][n];\\n        for(int i=1; i<m; i++)\\n            sum=max(sum, rec(i, n)+rec(m-i, n));\\n        for(int i=1; i<n; i++)\\n            sum=max(sum, rec(m, i)+rec(m, n-i));\\n        mem[m][n]=sum;\\n        return sum;\\n    }\\n\\t\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        mem.assign(m+1, vector<int>(n+1, 0));\\n        vis.assign(m+1, vector<int>(n+1, 0));\\n        sort(prices.begin(), prices.end(), comp);\\n        for(int k=0; k<prices.size(); k++)\\n        {\\n            if(mem[prices[k][0]][prices[k][1]])\\n                continue;\\n            for(int i=prices[k][0]; i<=m; i++)\\n                for(int j=prices[k][1]; j<=n; j++)\\n                {\\n                    if(mem[i][j])\\n                        break;\\n                    mem[i][j]=prices[k][2];\\n                }\\n        }\\n        return rec(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174960,
                "title": "c-my-solution-recursion-and-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long dfs (int h, int w, vector<vector<long long>> & lk, vector<vector<long long>> & init){\\n                \\n        if(h == 1 && w == 1){\\n            // end case.\\n            if(lk[h][w] > LLONG_MIN) return lk[h][w];\\n            lk[h][w] = init[h][w] > LLONG_MIN? init[h][w] : 0;            \\n            return lk[h][w];\\n        }\\n        \\n        // check cache\\n        if(lk[h][w] > LLONG_MIN) return lk[h][w];\\n        \\n        long long maxx = LLONG_MIN;\\n        if(init[h][w] > LLONG_MIN) maxx = init[h][w];\\n        // split left\\n        for(int i = 1; i < h ; i++){\\n            long long top = dfs(i, w , lk, init);\\n            long long bottom = dfs(h-i, w, lk, init);\\n            maxx = max(maxx, top+bottom);\\n        }\\n        // split top\\n        for(int i = 1; i < w ; i++){\\n            long long left = dfs(h, i, lk, init);\\n            long long right = dfs(h, w-i, lk, init);\\n            maxx = max(maxx, left+right);\\n        }\\n        lk[h][w] = maxx;\\n        \\n        return lk[h][w];\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        vector<vector<long long>> lk(m+1, vector<long long>(n+1 , LLONG_MIN));\\n        vector<vector<long long>> init(m+1, vector<long long>(n+1 , LLONG_MIN));\\n        // load init\\n        for(auto price: prices){\\n            int h = price[0];\\n            int w = price[1];\\n            int p = price[2];\\n            init[h][w] = p;\\n        }\\n        \\n        return dfs(m, n , lk, init);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long dfs (int h, int w, vector<vector<long long>> & lk, vector<vector<long long>> & init){\\n                \\n        if(h == 1 && w == 1){\\n            // end case.\\n            if(lk[h][w] > LLONG_MIN) return lk[h][w];\\n            lk[h][w] = init[h][w] > LLONG_MIN? init[h][w] : 0;            \\n            return lk[h][w];\\n        }\\n        \\n        // check cache\\n        if(lk[h][w] > LLONG_MIN) return lk[h][w];\\n        \\n        long long maxx = LLONG_MIN;\\n        if(init[h][w] > LLONG_MIN) maxx = init[h][w];\\n        // split left\\n        for(int i = 1; i < h ; i++){\\n            long long top = dfs(i, w , lk, init);\\n            long long bottom = dfs(h-i, w, lk, init);\\n            maxx = max(maxx, top+bottom);\\n        }\\n        // split top\\n        for(int i = 1; i < w ; i++){\\n            long long left = dfs(h, i, lk, init);\\n            long long right = dfs(h, w-i, lk, init);\\n            maxx = max(maxx, left+right);\\n        }\\n        lk[h][w] = maxx;\\n        \\n        return lk[h][w];\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        vector<vector<long long>> lk(m+1, vector<long long>(n+1 , LLONG_MIN));\\n        vector<vector<long long>> init(m+1, vector<long long>(n+1 , LLONG_MIN));\\n        // load init\\n        for(auto price: prices){\\n            int h = price[0];\\n            int w = price[1];\\n            int p = price[2];\\n            init[h][w] = p;\\n        }\\n        \\n        return dfs(m, n , lk, init);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174303,
                "title": "python3-top-down-dp",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m, n, prices):\\n        height = defaultdict(set)\\n        width = defaultdict(set)\\n        for h, w, p in prices:\\n            height[h].add((w, p))\\n            width[w].add((h, p))\\n        \\n        @lru_cache(None)\\n        def dp(h, w):\\n            return max(\\n                max((p*(w//ww) for ww,p in height[h]), default=0),\\n                max((p*(h//hh) for hh,p in width[w]), default=0),\\n                max((dp(hh,w)+dp(h-hh,w) for hh in range(1, h//2+1) if hh in height), default=0),\\n                max((dp(h,ww)+dp(h,w-ww) for ww in range(1,w//2+1)), default=0)\\n            )\\n            \\n        return dp(m,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m, n, prices):\\n        height = defaultdict(set)\\n        width = defaultdict(set)\\n        for h, w, p in prices:\\n            height[h].add((w, p))\\n            width[w].add((h, p))\\n        \\n        @lru_cache(None)\\n        def dp(h, w):\\n            return max(\\n                max((p*(w//ww) for ww,p in height[h]), default=0),\\n                max((p*(h//hh) for hh,p in width[w]), default=0),\\n                max((dp(hh,w)+dp(h-hh,w) for hh in range(1, h//2+1) if hh in height), default=0),\\n                max((dp(h,ww)+dp(h,w-ww) for ww in range(1,w//2+1)), default=0)\\n            )\\n            \\n        return dp(m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173708,
                "title": "c-dp-solution",
                "content": "```\\n    public long SellingWood(int m, int n, int[][] prices)\\n    {\\n        long[][] dp = new long[m + 1][];\\n        for (int i = 0; i <= m; i++)\\n        {\\n            dp[i] = new long[n + 1];\\n        }\\n        for (int i = 0; i < prices.Length; ++i)\\n        {\\n            dp[prices[i][0]][prices[i][1]] = prices[i][2];\\n        }\\n        for (int i = 1; i < dp.Length; ++i)\\n        {\\n            for (int j = 1; j < dp[i].Length; ++j)\\n            {\\n                int limit = j / 2 + 1;\\n                for (int z = 1; z < limit; z++)\\n                {\\n                    dp[i][j] = Math.Max(dp[i][j], dp[i][z] + dp[i][j - z]);\\n                }\\n                limit = i / 2 + 1;\\n                for (int z = 1; z < limit; z++)\\n                {\\n                    dp[i][j] = Math.Max(dp[i][j], dp[z][j] + dp[i - z][j]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\nCan stop the loop when j / 2 or i /2 because: \" z + (j -z) = j \" and \" a + b \" equals \" b + a \"\\nBtw, it\\'s so sad to see \"Sorry. We do not have enough accepted submissions to show distribution chart.\" after submitting C# Solution... haha",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public long SellingWood(int m, int n, int[][] prices)\\n    {\\n        long[][] dp = new long[m + 1][];\\n        for (int i = 0; i <= m; i++)\\n        {\\n            dp[i] = new long[n + 1];\\n        }\\n        for (int i = 0; i < prices.Length; ++i)\\n        {\\n            dp[prices[i][0]][prices[i][1]] = prices[i][2];\\n        }\\n        for (int i = 1; i < dp.Length; ++i)\\n        {\\n            for (int j = 1; j < dp[i].Length; ++j)\\n            {\\n                int limit = j / 2 + 1;\\n                for (int z = 1; z < limit; z++)\\n                {\\n                    dp[i][j] = Math.Max(dp[i][j], dp[i][z] + dp[i][j - z]);\\n                }\\n                limit = i / 2 + 1;\\n                for (int z = 1; z < limit; z++)\\n                {\\n                    dp[i][j] = Math.Max(dp[i][j], dp[z][j] + dp[i - z][j]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2173349,
                "title": "c-solution",
                "content": "```\\nlong long M_best_cut(long long** list, int M, int now){\\n    long long max = 0;\\n    int helf = now / 2;\\n    for (int l = 1 ; l <= helf ; l++){\\n        if (max < list[M][l] + list[M][now-l]){\\n            max = list[M][l] + list[M][now-l];\\n        }\\n    }\\n    return max;\\n}\\n\\nlong long N_best_cut(long long** list, int N, int now){\\n    long long max = 0;\\n    int helf = now / 2;\\n    for (int l = 1 ; l <= helf ; l++){\\n        if (max < list[l][N] + list[now-l][N]){\\n            max = list[l][N] + list[now-l][N];\\n        }\\n    }\\n    return max;\\n}\\n\\nlong long best(long long a, long long b, long long c){\\n    if (a < b){\\n        a = b;\\n    }\\n    if (a < c){\\n        return c;\\n    }\\n    return a;\\n}\\n\\nlong long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize){\\n    long long** list = malloc(sizeof(long long*)*(m+1));\\n    \\n    for (int i = 0 ; i <= m ; i++){\\n        list[i] = calloc((n+1),sizeof(long long));\\n    }\\n    \\n    for (int i = 0 ; i < pricesSize ; i++){\\n        list[prices[i][0]][prices[i][1]] = prices[i][2];\\n    }\\n    \\n    long long cut_M, cut_N;\\n    \\n    for (int i = 1 ; i <= m ; i++){\\n        for (int j = 1 ; j <= n ; j++){\\n            cut_M = M_best_cut(list, i, j);\\n            cut_N = N_best_cut(list, j, i);\\n            list[i][j] = best(cut_M,cut_N,list[i][j]);\\n        }\\n    }\\n\\n    long long ans = list[m][n];\\n    for (int i = 0 ; i <= m ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long M_best_cut(long long** list, int M, int now){\\n    long long max = 0;\\n    int helf = now / 2;\\n    for (int l = 1 ; l <= helf ; l++){\\n        if (max < list[M][l] + list[M][now-l]){\\n            max = list[M][l] + list[M][now-l];\\n        }\\n    }\\n    return max;\\n}\\n\\nlong long N_best_cut(long long** list, int N, int now){\\n    long long max = 0;\\n    int helf = now / 2;\\n    for (int l = 1 ; l <= helf ; l++){\\n        if (max < list[l][N] + list[now-l][N]){\\n            max = list[l][N] + list[now-l][N];\\n        }\\n    }\\n    return max;\\n}\\n\\nlong long best(long long a, long long b, long long c){\\n    if (a < b){\\n        a = b;\\n    }\\n    if (a < c){\\n        return c;\\n    }\\n    return a;\\n}\\n\\nlong long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize){\\n    long long** list = malloc(sizeof(long long*)*(m+1));\\n    \\n    for (int i = 0 ; i <= m ; i++){\\n        list[i] = calloc((n+1),sizeof(long long));\\n    }\\n    \\n    for (int i = 0 ; i < pricesSize ; i++){\\n        list[prices[i][0]][prices[i][1]] = prices[i][2];\\n    }\\n    \\n    long long cut_M, cut_N;\\n    \\n    for (int i = 1 ; i <= m ; i++){\\n        for (int j = 1 ; j <= n ; j++){\\n            cut_M = M_best_cut(list, i, j);\\n            cut_N = N_best_cut(list, j, i);\\n            list[i][j] = best(cut_M,cut_N,list[i][j]);\\n        }\\n    }\\n\\n    long long ans = list[m][n];\\n    for (int i = 0 ; i <= m ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2172670,
                "title": "python-top-down-dp-o-n-3",
                "content": "```\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dt = {}\\n        for h, w, p in prices:\\n            dt[(h,w)] = p\\n        @cache\\n        def dfs(h, w):\\n            if h == 0 or w == 0: return 0\\n            res = dt[(h,w)] if (h,w) in dt else 0\\n            for a in range(1, h//2+1):\\n                res = max(res, dfs(a, w) + dfs(h-a, w))\\n            for a in range(1, w//2+1):\\n                res = max(res, dfs(h, a) + dfs(h, w-a))\\n            return res\\n        return dfs(m, n)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dt = {}\\n        for h, w, p in prices:\\n            dt[(h,w)] = p\\n        @cache\\n        def dfs(h, w):\\n            if h == 0 or w == 0: return 0\\n            res = dt[(h,w)] if (h,w) in dt else 0\\n            for a in range(1, h//2+1):\\n                res = max(res, dfs(a, w) + dfs(h-a, w))\\n            for a in range(1, w//2+1):\\n                res = max(res, dfs(h, a) + dfs(h, w-a))\\n            return res\\n        return dfs(m, n)",
                "codeTag": "Python3"
            },
            {
                "id": 2172411,
                "title": "2d-dp-top-down-approach-o-m-n-m-n-beats-100-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        long long i, j;\\n        \\n        vector<vector<long long>>dp(m + 1, vector<long long>(n + 1, -1));\\n        \\n        vector<vector<long long>>p(m + 1, vector<long long>(n + 1, LLONG_MIN));\\n        \\n        \\n        for (i = 0; i < prices.size(); i++) {\\n            p[prices[i][0]][prices[i][1]] = prices[i][2];\\n        }\\n        \\n        \\n        return solve(m, n, dp, p);\\n    }\\n    \\n    long long solve(long long m, long n, vector<vector<long long>>& dp, vector<vector<long long>>& p) {\\n        \\n        long long ans = 0;\\n        \\n        if (m == 1 && n == 1) {\\n\\t\\t// can\\'t cut further\\n            return max(0LL, p[m][n]);\\n        }\\n        \\n        if (dp[m][n] != -1) {\\n            return dp[m][n];\\n        }\\n        \\n        ans = p[m][n];\\n        \\n        long long i, j, k;\\n        \\n\\t\\t// cut horizontally\\n        for (i = 1; i < m; i++) {\\n            ans = max(ans, solve(i, n, dp, p) + solve(m - i, n, dp, p));\\n        }\\n        \\n\\t\\t// cut vertically\\n        for (i = 1; i < n; i++) {\\n            ans = max(ans, solve(m, i, dp, p) + solve(m, n - i, dp, p));\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        long long i, j;\\n        \\n        vector<vector<long long>>dp(m + 1, vector<long long>(n + 1, -1));\\n        \\n        vector<vector<long long>>p(m + 1, vector<long long>(n + 1, LLONG_MIN));\\n        \\n        \\n        for (i = 0; i < prices.size(); i++) {\\n            p[prices[i][0]][prices[i][1]] = prices[i][2];\\n        }\\n        \\n        \\n        return solve(m, n, dp, p);\\n    }\\n    \\n    long long solve(long long m, long n, vector<vector<long long>>& dp, vector<vector<long long>>& p) {\\n        \\n        long long ans = 0;\\n        \\n        if (m == 1 && n == 1) {\\n\\t\\t// can\\'t cut further\\n            return max(0LL, p[m][n]);\\n        }\\n        \\n        if (dp[m][n] != -1) {\\n            return dp[m][n];\\n        }\\n        \\n        ans = p[m][n];\\n        \\n        long long i, j, k;\\n        \\n\\t\\t// cut horizontally\\n        for (i = 1; i < m; i++) {\\n            ans = max(ans, solve(i, n, dp, p) + solve(m - i, n, dp, p));\\n        }\\n        \\n\\t\\t// cut vertically\\n        for (i = 1; i < n; i++) {\\n            ans = max(ans, solve(m, i, dp, p) + solve(m, n - i, dp, p));\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172149,
                "title": "my-school-homework-exactly-the-same",
                "content": "This is one of my school homework problems from my algo class 6 months ago lol ...\\n\\nThe idea is simple actually - create a lookup table (dp) and perform 1 cut per round.\\nWe can either cut it vertically or horizontally, and it becomes two smallers grid which we had computed before. \\n\\n```Java\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] p : prices){\\n            dp[p[0]][p[1]]=p[2];\\n        }\\n        for (int i = 1; i <= m; i++){ // height\\n            for (int j = 1; j <= n; j++){ // width\\n                for (int k = 1; k <= i; k++){ // cut height (horizontally)\\n                    dp[i][j]=Math.max(dp[i][j], dp[i-k][j]+dp[k][j]);\\n                }\\n                for (int k = 1; k <= j; k++){ // cut width (vertically)\\n                    dp[i][j]=Math.max(dp[i][j], dp[i][j-k]+dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] p : prices){\\n            dp[p[0]][p[1]]=p[2];\\n        }\\n        for (int i = 1; i <= m; i++){ // height\\n            for (int j = 1; j <= n; j++){ // width\\n                for (int k = 1; k <= i; k++){ // cut height (horizontally)\\n                    dp[i][j]=Math.max(dp[i][j], dp[i-k][j]+dp[k][j]);\\n                }\\n                for (int k = 1; k <= j; k++){ // cut width (vertically)\\n                    dp[i][j]=Math.max(dp[i][j], dp[i][j-k]+dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172007,
                "title": "fastest-and-simplest-c-solution",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n\\t// storing given {i, j} ans in map to fetch it out quickly\\n    ll solve(int n, int m, map<pair<int, int>, ll> &hsh, vector<vector<ll>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        ll ans = hsh.find({n, m}) == hsh.end() ? 0 : hsh[{n, m}];\\n        // Why taking individual rows and cols?\\n        // Becuase in each and every individual call for particular i we get all col combination in it\\'s function call in next for loop of column. So by this we get each combination of i and j\\n        for(ll i = 1; i < n; i++){\\n            ans = max(ans, solve(i, m, hsh, dp) + solve(n - i, m, hsh, dp));\\n        }\\n        for(ll j = 1; j < m; j++){\\n            ans = max(ans, solve(n, j, hsh, dp) + solve(n, m - j, hsh, dp));\\n        }\\n        return dp[n][m] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        map<pair<int, int>, ll> hsh;\\n        vector<vector<ll>> dp(m + 1, vector<ll>(n + 1, -1));\\n        for(auto i : prices) hsh[{i[0], i[1]}] = i[2];\\n        return solve(m, n, hsh, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n\\t// storing given {i, j} ans in map to fetch it out quickly\\n    ll solve(int n, int m, map<pair<int, int>, ll> &hsh, vector<vector<ll>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        ll ans = hsh.find({n, m}) == hsh.end() ? 0 : hsh[{n, m}];\\n        // Why taking individual rows and cols?\\n        // Becuase in each and every individual call for particular i we get all col combination in it\\'s function call in next for loop of column. So by this we get each combination of i and j\\n        for(ll i = 1; i < n; i++){\\n            ans = max(ans, solve(i, m, hsh, dp) + solve(n - i, m, hsh, dp));\\n        }\\n        for(ll j = 1; j < m; j++){\\n            ans = max(ans, solve(n, j, hsh, dp) + solve(n, m - j, hsh, dp));\\n        }\\n        return dp[n][m] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        map<pair<int, int>, ll> hsh;\\n        vector<vector<ll>> dp(m + 1, vector<ll>(n + 1, -1));\\n        for(auto i : prices) hsh[{i[0], i[1]}] = i[2];\\n        return solve(m, n, hsh, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171704,
                "title": "java-bottom-up-dp",
                "content": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n\\t\\t// dp[i][j] = Maximum profit selling wood of size i*j\\n        long[][] dp = new long[m][n];\\n        for(int[] price : prices) {\\n            dp[price[0]-1][price[1]-1] = Math.max(dp[price[0]-1][price[1]-1], price[2]);\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                // Cut Vertically\\n                for(int k = 0; k < j; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[i][j-k-1]);\\n                }\\n                // Cut Horizontally\\n                for(int k = 0; k < i; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[k][j] + dp[i-k-1][j]);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n\\t\\t// dp[i][j] = Maximum profit selling wood of size i*j\\n        long[][] dp = new long[m][n];\\n        for(int[] price : prices) {\\n            dp[price[0]-1][price[1]-1] = Math.max(dp[price[0]-1][price[1]-1], price[2]);\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                // Cut Vertically\\n                for(int k = 0; k < j; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[i][j-k-1]);\\n                }\\n                // Cut Horizontally\\n                for(int k = 0; k < i; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[k][j] + dp[i-k-1][j]);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171641,
                "title": "java-dp-memo",
                "content": "```\\nclass Solution {\\n    long ans=0;\\n    int[][]temp;\\n    long[][]dp;\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        temp=new int[m+1][n+1];\\n        dp=new long[m+1][n+1];\\n        for(long[]t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        for(int[]t:prices){\\n            temp[t[0]][t[1]]=t[2];\\n        }\\n        return solve(m,n);\\n        \\n    }\\n    \\n    long solve(int m,int n){\\n        \\n        //base case\\n        if(m==1 && n==1){\\n            return temp[m][n];\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        long ans=temp[m][n];\\n\\t\\t\\n\\t\\t// split by rows\\n        for(int rows=0;rows<m/2;rows++){\\n            ans=Math.max(ans,solve(rows+1,n)+solve(m-rows-1,n));\\n        }\\n\\t\\t\\n\\t\\t//split by cols\\n        for(int cols=0;cols<n/2;cols++){\\n            ans=Math.max(ans,solve(m,cols+1)+solve(m,n-cols-1));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long ans=0;\\n    int[][]temp;\\n    long[][]dp;\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        temp=new int[m+1][n+1];\\n        dp=new long[m+1][n+1];\\n        for(long[]t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        for(int[]t:prices){\\n            temp[t[0]][t[1]]=t[2];\\n        }\\n        return solve(m,n);\\n        \\n    }\\n    \\n    long solve(int m,int n){\\n        \\n        //base case\\n        if(m==1 && n==1){\\n            return temp[m][n];\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        long ans=temp[m][n];\\n\\t\\t\\n\\t\\t// split by rows\\n        for(int rows=0;rows<m/2;rows++){\\n            ans=Math.max(ans,solve(rows+1,n)+solve(m-rows-1,n));\\n        }\\n\\t\\t\\n\\t\\t//split by cols\\n        for(int cols=0;cols<n/2;cols++){\\n            ans=Math.max(ans,solve(m,cols+1)+solve(m,n-cols-1));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171460,
                "title": "help-python-memoization-getting-timeout-tle",
                "content": "Can someone say why this solution is getting timeout ?\\n```\\nclass Solution(object):\\n    def sellingWood(self, m, n, prices):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type prices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        ma = {}\\n        for x,y,p in prices:\\n            ma[x,y] = p\\n        \\n        def dpMemo(x, y):\\n            val = 0\\n            if (x,y) in memo:\\n                return memo[x,y]\\n            \\n            for i in range(1, x/2 + 1):\\n                l = memo[i, y] if (i, y) in memo else dpMemo(i, y)\\n                r = memo[x-i, y] if (x-i, y) in memo else dpMemo(x-i, y)\\n                val=max(val,l+r)\\n            \\n            for j in range(1, y/2 + 1):\\n                l = memo[x, j] if (x, j) in memo else dpMemo(x, j)\\n                r = memo[x, y-j] if (x, y-j) in memo else dpMemo(x, y-j)\\n                val=max(val , l + dpMemo(x, y-j))\\n            \\n            if (x,y) in ma:\\n                val = max(val, ma[x,y])\\n            memo[x,y] = val\\n            return val\\n        r = dpMemo(m, n)\\n        return r\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sellingWood(self, m, n, prices):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type prices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        ma = {}\\n        for x,y,p in prices:\\n            ma[x,y] = p\\n        \\n        def dpMemo(x, y):\\n            val = 0\\n            if (x,y) in memo:\\n                return memo[x,y]\\n            \\n            for i in range(1, x/2 + 1):\\n                l = memo[i, y] if (i, y) in memo else dpMemo(i, y)\\n                r = memo[x-i, y] if (x-i, y) in memo else dpMemo(x-i, y)\\n                val=max(val,l+r)\\n            \\n            for j in range(1, y/2 + 1):\\n                l = memo[x, j] if (x, j) in memo else dpMemo(x, j)\\n                r = memo[x, y-j] if (x, y-j) in memo else dpMemo(x, y-j)\\n                val=max(val , l + dpMemo(x, y-j))\\n            \\n            if (x,y) in ma:\\n                val = max(val, ma[x,y])\\n            memo[x,y] = val\\n            return val\\n        r = dpMemo(m, n)\\n        return r\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171435,
                "title": "fase-go-beats-100",
                "content": "```\\nfunc dp(h, w int, memo, p [][]int64) int64 {\\n    if h == 0 || w == 0 {\\n        return 0\\n    }\\n    \\n    if memo[h][w] >= 0 {\\n        return memo[h][w]\\n    }\\n    \\n    memo[h][w] = 0\\n    r := int64(0)\\n    if p[h][w] != -1 {\\n        r = p[h][w]\\n    }\\n    \\n    for i := 1; i < h; i++ {\\n        x := dp(i, w, memo, p) + dp(h - i, w, memo, p)\\n        if x > r {\\n            r = x\\n        }        \\n    }\\n    \\n    for j := 1; j < w; j++ {\\n        x := dp(h, j, memo, p) + dp(h, w - j, memo, p)\\n        if x > r {\\n            r = x\\n        }\\n    }\\n    \\n    memo[h][w] = r\\n    return r    \\n}\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n    memo := make([][]int64, m + 1)\\n    p := make([][]int64, m + 1)\\n    for i := 0; i <= m; i++ {\\n        memo[i] = make([]int64, n + 1)\\n        p[i] = make([]int64, n + 1)\\n        for j := 0; j <= n; j++ {\\n            memo[i][j] = -1\\n            p[i][j] = -1\\n        }\\n    }\\n    \\n    for _, x := range prices {\\n        p[x[0]][x[1]] = int64(x[2])\\n    }\\n            \\n    return dp(m, n, memo, p)\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc dp(h, w int, memo, p [][]int64) int64 {\\n    if h == 0 || w == 0 {\\n        return 0\\n    }\\n    \\n    if memo[h][w] >= 0 {\\n        return memo[h][w]\\n    }\\n    \\n    memo[h][w] = 0\\n    r := int64(0)\\n    if p[h][w] != -1 {\\n        r = p[h][w]\\n    }\\n    \\n    for i := 1; i < h; i++ {\\n        x := dp(i, w, memo, p) + dp(h - i, w, memo, p)\\n        if x > r {\\n            r = x\\n        }        \\n    }\\n    \\n    for j := 1; j < w; j++ {\\n        x := dp(h, j, memo, p) + dp(h, w - j, memo, p)\\n        if x > r {\\n            r = x\\n        }\\n    }\\n    \\n    memo[h][w] = r\\n    return r    \\n}\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n    memo := make([][]int64, m + 1)\\n    p := make([][]int64, m + 1)\\n    for i := 0; i <= m; i++ {\\n        memo[i] = make([]int64, n + 1)\\n        p[i] = make([]int64, n + 1)\\n        for j := 0; j <= n; j++ {\\n            memo[i][j] = -1\\n            p[i][j] = -1\\n        }\\n    }\\n    \\n    for _, x := range prices {\\n        p[x[0]][x[1]] = int64(x[2])\\n    }\\n            \\n    return dp(m, n, memo, p)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2171119,
                "title": "c-memo-100-time-100-space-sol",
                "content": "![image](https://assets.leetcode.com/users/images/e48a3002-05ba-4434-b3a6-1a9a97b884d2_1655655212.4242225.png)\\n\\ntime: O(mn*(m+n))\\nspace: O(mn+len(prices))\\n```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        unordered_map<string, int> hm;\\n        for (auto& price: prices)\\n        {\\n            hm[to_string(price[0])+\\'_\\'+to_string(price[1])] = price[2];\\n        }\\n        vector<vector<long long>> memo(m+1, vector<long long>(n+1, -1));\\n        return helper(m, n, hm, memo);\\n    }\\nprivate:\\n    long long helper(int m, int n, unordered_map<string, int>& hm, vector<vector<long long>>& memo)\\n    {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (memo[m][n] != -1) return memo[m][n];\\n        string shape = to_string(m)+\\'_\\'+to_string(n);\\n        long long res = 0;\\n        if (hm.find(shape) != hm.end()) res = static_cast<long long>(hm[shape]);\\n        // horizontal cut\\n        for (int i=1; i<m; i++)\\n        {\\n            res = max(res, helper(i, n, hm, memo)+helper(m-i, n, hm, memo));\\n        }\\n        // vertical cut\\n        for (int i=1; i<n; i++)\\n        {\\n            res = max(res, helper(m, i, hm, memo)+helper(m, n-i, hm, memo));\\n        }\\n        return memo[m][n] = res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        unordered_map<string, int> hm;\\n        for (auto& price: prices)\\n        {\\n            hm[to_string(price[0])+\\'_\\'+to_string(price[1])] = price[2];\\n        }\\n        vector<vector<long long>> memo(m+1, vector<long long>(n+1, -1));\\n        return helper(m, n, hm, memo);\\n    }\\nprivate:\\n    long long helper(int m, int n, unordered_map<string, int>& hm, vector<vector<long long>>& memo)\\n    {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (memo[m][n] != -1) return memo[m][n];\\n        string shape = to_string(m)+\\'_\\'+to_string(n);\\n        long long res = 0;\\n        if (hm.find(shape) != hm.end()) res = static_cast<long long>(hm[shape]);\\n        // horizontal cut\\n        for (int i=1; i<m; i++)\\n        {\\n            res = max(res, helper(i, n, hm, memo)+helper(m-i, n, hm, memo));\\n        }\\n        // vertical cut\\n        for (int i=1; i<n; i++)\\n        {\\n            res = max(res, helper(m, i, hm, memo)+helper(m, n-i, hm, memo));\\n        }\\n        return memo[m][n] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171001,
                "title": "c-top-down-dp",
                "content": "```\\npublic class Solution\\n{\\n  public long SellingWood(int m, int n, int[][] prices)\\n  {\\n    var pricesMap = prices.ToDictionary(x => (x[0], x[1]), x => x[2]);\\n\\n    // DP\\n    // recursive + memo\\n    var memo = new Dictionary<(int h, int w), long>();\\n    var ans = Calculate(m, n, pricesMap, memo);\\n    \\n    return ans;\\n  }\\n\\n  private long Calculate(int m, int n, \\n                         Dictionary<(int, int), int> prices, Dictionary<(int h, int w), long> memo)\\n  {\\n    if (memo.ContainsKey((m, n)))\\n    {\\n      return memo[(m, n)];\\n    }\\n\\n    var ans = 0L;\\n\\n    // walk thru all horizontal cuts\\n    for (var i = 1; i < m; i++)\\n    {\\n      ans = Math.Max(ans, \\n        Calculate(i, n, prices, memo) + Calculate(m - i, n, prices, memo));\\n    }\\n\\n    // walk thru all vertical cuts\\n    for (var i = 1; i < n; i++)\\n    {\\n      ans = Math.Max(ans, \\n        Calculate(m, i, prices, memo) + Calculate(m, n - i, prices, memo));\\n    }\\n\\n    // check exact piece size\\n    if (prices.ContainsKey((m, n)))\\n    {\\n      ans = Math.Max(ans, prices[(m, n)]);\\n    }\\n\\n    memo[(m, n)] = ans;\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public long SellingWood(int m, int n, int[][] prices)\\n  {\\n    var pricesMap = prices.ToDictionary(x => (x[0], x[1]), x => x[2]);\\n\\n    // DP\\n    // recursive + memo\\n    var memo = new Dictionary<(int h, int w), long>();\\n    var ans = Calculate(m, n, pricesMap, memo);\\n    \\n    return ans;\\n  }\\n\\n  private long Calculate(int m, int n, \\n                         Dictionary<(int, int), int> prices, Dictionary<(int h, int w), long> memo)\\n  {\\n    if (memo.ContainsKey((m, n)))\\n    {\\n      return memo[(m, n)];\\n    }\\n\\n    var ans = 0L;\\n\\n    // walk thru all horizontal cuts\\n    for (var i = 1; i < m; i++)\\n    {\\n      ans = Math.Max(ans, \\n        Calculate(i, n, prices, memo) + Calculate(m - i, n, prices, memo));\\n    }\\n\\n    // walk thru all vertical cuts\\n    for (var i = 1; i < n; i++)\\n    {\\n      ans = Math.Max(ans, \\n        Calculate(m, i, prices, memo) + Calculate(m, n - i, prices, memo));\\n    }\\n\\n    // check exact piece size\\n    if (prices.ContainsKey((m, n)))\\n    {\\n      ans = Math.Max(ans, prices[(m, n)]);\\n    }\\n\\n    memo[(m, n)] = ans;\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170576,
                "title": "swift-memo-dfs",
                "content": "```swift\\nhttps://leetcode.com/problems/selling-pieces-of-wood/\\nclass Solution {\\n    func sellingWood(_ height: Int, _ width: Int, _ _prices: [[Int]]) -> Int {\\n        var memo = [[Int]](repeating: [Int](repeating: -1, count: width + 5), count: height + 5)\\n\\n        var prices = [[Int]](repeating: [Int](repeating: 0, count: width + 5), count: height + 5)\\n        _prices.forEach { p in\\n            prices[p[0]][p[1]] = p[2]\\n        }\\n\\n\\n\\n        func dfs(_ curHeight: Int, _ curWidth: Int) -> Int {\\n\\n            guard -1 == memo[curHeight][curWidth] else {\\n                return memo[curHeight][curWidth]\\n            }\\n\\n            var ans = prices[curHeight][curWidth]\\n            //horizon\\n            for firstPartHeight in 1..<curHeight {\\n                ans = max(ans, dfs(firstPartHeight, curWidth) + dfs(curHeight - firstPartHeight, curWidth))\\n            }\\n            //vertical\\n            for firstPartWidth in 1..<curWidth {\\n                ans = max(ans, dfs(curHeight, firstPartWidth) + dfs(curHeight, curWidth - firstPartWidth))\\n            }\\n            memo[curHeight][curWidth] = ans\\n            return ans\\n        }\\n\\n        return dfs(height, width)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```swift\\nhttps://leetcode.com/problems/selling-pieces-of-wood/\\nclass Solution {\\n    func sellingWood(_ height: Int, _ width: Int, _ _prices: [[Int]]) -> Int {\\n        var memo = [[Int]](repeating: [Int](repeating: -1, count: width + 5), count: height + 5)\\n\\n        var prices = [[Int]](repeating: [Int](repeating: 0, count: width + 5), count: height + 5)\\n        _prices.forEach { p in\\n            prices[p[0]][p[1]] = p[2]\\n        }\\n\\n\\n\\n        func dfs(_ curHeight: Int, _ curWidth: Int) -> Int {\\n\\n            guard -1 == memo[curHeight][curWidth] else {\\n                return memo[curHeight][curWidth]\\n            }\\n\\n            var ans = prices[curHeight][curWidth]\\n            //horizon\\n            for firstPartHeight in 1..<curHeight {\\n                ans = max(ans, dfs(firstPartHeight, curWidth) + dfs(curHeight - firstPartHeight, curWidth))\\n            }\\n            //vertical\\n            for firstPartWidth in 1..<curWidth {\\n                ans = max(ans, dfs(curHeight, firstPartWidth) + dfs(curHeight, curWidth - firstPartWidth))\\n            }\\n            memo[curHeight][curWidth] = ans\\n            return ans\\n        }\\n\\n        return dfs(height, width)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170523,
                "title": "iterative-and-recursive-solution-recursive-giving-tle",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        pricelist={}\\n\\n        dp=[[0 for i in range(n+1)] for  j in range(m+1)]\\n        for i,j,p in prices:\\n            pricelist[(i,j)]=p\\n            dp[i][j]=p\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                    for a in range(1,j//2+1):\\n                        dp[i][j]=max(dp[i][j],dp[i][a]+dp[i][j-a])\\n                    for b  in range(1,i//2+1):\\n                        dp[i][j]=max(dp[i][j],dp[b][j]+dp[i-b][j])\\n                    if (i,j) in pricelist:\\n                        dp[i][j]=max(pricelist[(i,j)],dp[i][j])\\n        return dp[m][n]\\n  \\n  \\n```\\nRecursive:\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n        dp={}\\n        def cost(m,n):\\n            if (m,n) in dp:\\n                return dp[(m,n)]\\n            if m==0 or n==0:\\n                return 0\\n            ans=0\\n            for i in range(1,n//2+1):\\n                ans=max(ans,cost(m,i)+cost(m,n-i))\\n            for j in range(1,m//2+1):\\n                ans=max(ans,cost(j,n)+cost(m-j,n))\\n            if (m,n) in pricelist:\\n                dp[(m,n)]=max(pricelist[(m,n)],ans)\\n                return max(pricelist[(m,n)],ans)\\n            else:\\n                dp[(m,n)]=ans\\n                return ans\\n        return cost(m,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        pricelist={}\\n\\n        dp=[[0 for i in range(n+1)] for  j in range(m+1)]\\n        for i,j,p in prices:\\n            pricelist[(i,j)]=p\\n            dp[i][j]=p\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                    for a in range(1,j//2+1):\\n                        dp[i][j]=max(dp[i][j],dp[i][a]+dp[i][j-a])\\n                    for b  in range(1,i//2+1):\\n                        dp[i][j]=max(dp[i][j],dp[b][j]+dp[i-b][j])\\n                    if (i,j) in pricelist:\\n                        dp[i][j]=max(pricelist[(i,j)],dp[i][j])\\n        return dp[m][n]\\n  \\n  \\n```\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n        dp={}\\n        def cost(m,n):\\n            if (m,n) in dp:\\n                return dp[(m,n)]\\n            if m==0 or n==0:\\n                return 0\\n            ans=0\\n            for i in range(1,n//2+1):\\n                ans=max(ans,cost(m,i)+cost(m,n-i))\\n            for j in range(1,m//2+1):\\n                ans=max(ans,cost(j,n)+cost(m-j,n))\\n            if (m,n) in pricelist:\\n                dp[(m,n)]=max(pricelist[(m,n)],ans)\\n                return max(pricelist[(m,n)],ans)\\n            else:\\n                dp[(m,n)]=ans\\n                return ans\\n        return cost(m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170517,
                "title": "c-dp-recursion-memo-trying-all-cuts",
                "content": "```\\nclass Solution {\\nprivate:\\n    long long dp[201][201];\\n    long long profit[201][201];\\n    long long fun(int m, int n){\\n        if(m == 0 || n == 0) return 0;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        long long ans = profit[m][n];\\n        for(int i = 1; i <= m/2; i++) ans = max(ans, fun(i, n) + fun(m-i, n));\\n        for(int j = 1; j <= n/2; j++) ans = max(ans, fun(m, j) + fun(m, n-j));\\n        return dp[m][n] = ans;\\n    }\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(profit, 0, sizeof profit);\\n        memset(dp, -1, sizeof dp);\\n        for(auto &i: prices){\\n            profit[i[0]][i[1]] = i[2];\\n        }\\n        return fun(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long dp[201][201];\\n    long long profit[201][201];\\n    long long fun(int m, int n){\\n        if(m == 0 || n == 0) return 0;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        long long ans = profit[m][n];\\n        for(int i = 1; i <= m/2; i++) ans = max(ans, fun(i, n) + fun(m-i, n));\\n        for(int j = 1; j <= n/2; j++) ans = max(ans, fun(m, j) + fun(m, n-j));\\n        return dp[m][n] = ans;\\n    }\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(profit, 0, sizeof profit);\\n        memset(dp, -1, sizeof dp);\\n        for(auto &i: prices){\\n            profit[i[0]][i[1]] = i[2];\\n        }\\n        return fun(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170477,
                "title": "easy-solution-100-faster-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int size=prices.size();\\n        for(int i=0;i<size;i++) dp[prices[i][0]][prices[i][1]]=prices[i][2];\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                for(int k=0;k<=max(i,j);k++){\\n                    if(k<=j) dp[i][j]=max(dp[i][j],dp[i][k]+dp[i][j-k]);\\n                    if(k<=i) dp[i][j]=max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int size=prices.size();\\n        for(int i=0;i<size;i++) dp[prices[i][0]][prices[i][1]]=prices[i][2];\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                for(int k=0;k<=max(i,j);k++){\\n                    if(k<=j) dp[i][j]=max(dp[i][j],dp[i][k]+dp[i][j-k]);\\n                    if(k<=i) dp[i][j]=max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170423,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1));\\n        \\n        int i, j, k;\\n        \\n        for(i = 0; i < prices.size(); i++){\\n            int row = prices[i][0];\\n            int col = prices[i][1];\\n            int price = prices[i][2];\\n            \\n            dp[row][col] = price;\\n        }\\n        \\n        for(i = 1; i <= m; i++){\\n            for(j = 1; j <= n; j++){\\n                for(k = 1; k <= i; k++){\\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i - k][j]);\\n                }\\n                for(k = 1; k <= j; k++){\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j - k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1));\\n        \\n        int i, j, k;\\n        \\n        for(i = 0; i < prices.size(); i++){\\n            int row = prices[i][0];\\n            int col = prices[i][1];\\n            int price = prices[i][2];\\n            \\n            dp[row][col] = price;\\n        }\\n        \\n        for(i = 1; i <= m; i++){\\n            for(j = 1; j <= n; j++){\\n                for(k = 1; k <= i; k++){\\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i - k][j]);\\n                }\\n                for(k = 1; k <= j; k++){\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j - k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170135,
                "title": "recursion-approach-not-working",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>dp;\\n    void solve(int m, int n){\\n        for(int i=1;i<=m/2;i++){\\n            solve(i,n);\\n            solve(m-i,n);\\n            dp[m][n]=max(dp[m][n],dp[i][n]+dp[m-i][n]);\\n        }\\n        for(int i=1;i<=n/2;i++){\\n            solve(m,i);\\n            solve(m,n-i);\\n            dp[m][n]=max(dp[m][n],dp[m][i]+dp[m][n-i]);\\n        }\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        dp = vector<vector<long long>>(m+1,vector<long long>(n+1,0));\\n        for(auto it:prices){\\n            dp[it[0]][it[1]]=it[2];\\n        }\\n        solve(m,n);\\n        return dp[m][n];\\n    }\\n};\\n```\\nwhy this thing showing tle ??\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>dp;\\n    void solve(int m, int n){\\n        for(int i=1;i<=m/2;i++){\\n            solve(i,n);\\n            solve(m-i,n);\\n            dp[m][n]=max(dp[m][n],dp[i][n]+dp[m-i][n]);\\n        }\\n        for(int i=1;i<=n/2;i++){\\n            solve(m,i);\\n            solve(m,n-i);\\n            dp[m][n]=max(dp[m][n],dp[m][i]+dp[m][n-i]);\\n        }\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        dp = vector<vector<long long>>(m+1,vector<long long>(n+1,0));\\n        for(auto it:prices){\\n            dp[it[0]][it[1]]=it[2];\\n        }\\n        solve(m,n);\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169909,
                "title": "javascript-bottom-up-dp-faster-than-100-309ms",
                "content": "```\\nvar sellingWood = function (m, n, prices) {\\n  const dp = Array(m + 1).fill(null).map(_ => Array(n + 1).fill(0));\\n  for (let p of prices)\\n    dp[p[0]][p[1]] = p[2];\\n  for (let w = 1; w <= m; ++w) {\\n    for (let h = 1; h <= n; ++h) {\\n      for (let a = 1; a <= Math.floor(w / 2); ++a)\\n        dp[w][h] = Math.max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n      for (let a = 1; a <= Math.floor(h / 2); ++a)\\n        dp[w][h] = Math.max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n    }\\n  }\\n  return dp[m][n];\\n};\\n```\\n\\nFor more detail see: [3D DP](https://leetcode.com/problems/selling-pieces-of-wood/discuss/2168403/3D-DP)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar sellingWood = function (m, n, prices) {\\n  const dp = Array(m + 1).fill(null).map(_ => Array(n + 1).fill(0));\\n  for (let p of prices)\\n    dp[p[0]][p[1]] = p[2];\\n  for (let w = 1; w <= m; ++w) {\\n    for (let h = 1; h <= n; ++h) {\\n      for (let a = 1; a <= Math.floor(w / 2); ++a)\\n        dp[w][h] = Math.max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n      for (let a = 1; a <= Math.floor(h / 2); ++a)\\n        dp[w][h] = Math.max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n    }\\n  }\\n  return dp[m][n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169792,
                "title": "c-100-faster-solution",
                "content": "```\\n#define in long long int\\n\\nbool cmp(pair<int, int>&a, pair<int, int>&b){\\n    return (long double)a.second/(long double)a.first < (long double)b.second/(long double)b.first;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> x[201];\\n    long long int dp[201][201];\\n    vector<vector<int>> p;\\n    \\n    in find(int m, int n){\\n        if(dp[m][n] != -1) return dp[m][n];\\n        if(m == 0 || n == 0) return dp[m][n] = 0;\\n        in ans = 0;\\n        for(int i=m;i>=1;i--){\\n            int ind = x[i].size()-1;\\n            while(ind >= 0){\\n                if(x[i][ind].first > n){\\n                    ind--;\\n                    continue;\\n                }\\n                in before = ans;\\n                ans = max({\\n                    ans,\\n                    x[i][ind].second*1ll + find(i, n-x[i][ind].first) + find(m - i, n),\\n                    x[i][ind].second*1ll + find(m-i, x[i][ind].first) + find(m, n - x[i][ind].first)\\n                });\\n                if(ans == before) break;\\n                ind--;\\n            }\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        for(vector<int>&pp : prices){\\n            x[pp[0]].push_back({pp[1], pp[2]});\\n        }\\n        for(int i=0;i<201;i++){\\n            sort(x[i].begin(), x[i].end(), cmp);\\n        }\\n        return find(m, n);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define in long long int\\n\\nbool cmp(pair<int, int>&a, pair<int, int>&b){\\n    return (long double)a.second/(long double)a.first < (long double)b.second/(long double)b.first;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> x[201];\\n    long long int dp[201][201];\\n    vector<vector<int>> p;\\n    \\n    in find(int m, int n){\\n        if(dp[m][n] != -1) return dp[m][n];\\n        if(m == 0 || n == 0) return dp[m][n] = 0;\\n        in ans = 0;\\n        for(int i=m;i>=1;i--){\\n            int ind = x[i].size()-1;\\n            while(ind >= 0){\\n                if(x[i][ind].first > n){\\n                    ind--;\\n                    continue;\\n                }\\n                in before = ans;\\n                ans = max({\\n                    ans,\\n                    x[i][ind].second*1ll + find(i, n-x[i][ind].first) + find(m - i, n),\\n                    x[i][ind].second*1ll + find(m-i, x[i][ind].first) + find(m, n - x[i][ind].first)\\n                });\\n                if(ans == before) break;\\n                ind--;\\n            }\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        for(vector<int>&pp : prices){\\n            x[pp[0]].push_back({pp[1], pp[2]});\\n        }\\n        for(int i=0;i<201;i++){\\n            sort(x[i].begin(), x[i].end(), cmp);\\n        }\\n        return find(m, n);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169743,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(m * n * max(m, n))\\n * Space Complexity: O(m * n)\\n */\\nclass Solution {\\n public:\\n  long long sellingWood(const int m, const int n, const vector<vector<int>>& prices) {\\n    int profit[m + 1][n + 1];\\n    memset(profit, 0, sizeof(profit));\\n    for (const vector<int> &price : prices) {\\n      profit[price[0]][price[1]] = price[2];\\n    }\\n    \\n    long long dp[m + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    for (int rows = 1; rows < m + 1; ++rows) {\\n      for (int cols = 1; cols < n + 1; ++cols) {\\n        dp[rows][cols] = profit[rows][cols];\\n        for (int top = 1; top < rows; ++top) {\\n          dp[rows][cols] = max(dp[rows][cols], dp[top][cols] + dp[rows - top][cols]);\\n        }\\n        for (int left = 1; left < cols; ++left) {\\n          dp[rows][cols] = max(dp[rows][cols], dp[rows][left] + dp[rows][cols - left]);\\n        }\\n      }\\n    }\\n    return dp[m][n];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(m * n * max(m, n))\\n * Space Complexity: O(m * n)\\n */\\nclass Solution {\\n public:\\n  long long sellingWood(const int m, const int n, const vector<vector<int>>& prices) {\\n    int profit[m + 1][n + 1];\\n    memset(profit, 0, sizeof(profit));\\n    for (const vector<int> &price : prices) {\\n      profit[price[0]][price[1]] = price[2];\\n    }\\n    \\n    long long dp[m + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    for (int rows = 1; rows < m + 1; ++rows) {\\n      for (int cols = 1; cols < n + 1; ++cols) {\\n        dp[rows][cols] = profit[rows][cols];\\n        for (int top = 1; top < rows; ++top) {\\n          dp[rows][cols] = max(dp[rows][cols], dp[top][cols] + dp[rows - top][cols]);\\n        }\\n        for (int left = 1; left < cols; ++left) {\\n          dp[rows][cols] = max(dp[rows][cols], dp[rows][left] + dp[rows][cols - left]);\\n        }\\n      }\\n    }\\n    return dp[m][n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169498,
                "title": "python-solution-bottom-up-dp",
                "content": "I wasn\\'t paying enough attention during the contest that you cannot cut one small piece out. \\nAnyway, this problem is still standard DP.\\nI tried top-down first (standard DFS + memo), but too slow and got TLEed. I guess because the question is inherently 2D and bottom-up 2D DP is more appropriate and less prone to missing edge cases. The run time wasn\\'t great, welcome for suggestions to make it faster\\n```\\nclass Solution:\\n    # Try bottom-up DP\\n    # given a m X n board,\\n    # if we cut at i = p: dp[m][n] = dp[p][n] + dp[m-p][n] \\n    # if we cut at j = q: dp[m][n] = dp[m][q] + dp[m][n-q]\\n    # Therefore this is at least N^3 algorithm\\n    # as (k, i-k-1) are symmetric, no need to go through to i. choose the mid point which (i-1) //2 is fine\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        # First add the price of each little board to the dp matrix\\n        for price in prices:\\n            dp[price[0]-1][price[1]-1] = price[2]\\n        for i in range(m):\\n            for j in range(n):\\n                for k in range(0,(i-1)//2+1):\\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i-k-1][j])\\n                for k in range(0,(j-1)//2+1):\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j-k-1])\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Try bottom-up DP\\n    # given a m X n board,\\n    # if we cut at i = p: dp[m][n] = dp[p][n] + dp[m-p][n] \\n    # if we cut at j = q: dp[m][n] = dp[m][q] + dp[m][n-q]\\n    # Therefore this is at least N^3 algorithm\\n    # as (k, i-k-1) are symmetric, no need to go through to i. choose the mid point which (i-1) //2 is fine\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        # First add the price of each little board to the dp matrix\\n        for price in prices:\\n            dp[price[0]-1][price[1]-1] = price[2]\\n        for i in range(m):\\n            for j in range(n):\\n                for k in range(0,(i-1)//2+1):\\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i-k-1][j])\\n                for k in range(0,(j-1)//2+1):\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j-k-1])\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169434,
                "title": "c-dp-top-down-approach",
                "content": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    map<pair<ll, ll>, ll> mp;\\n    vector<vector<ll> > dp;\\n    \\n    ll util(ll rows, ll cols){\\n        if(rows==0 || cols==0){\\n            return 0;\\n        }\\n        if(dp[rows][cols]!=-1){\\n            return dp[rows][cols];\\n        }\\n        ll ans=0;\\n        if(mp.count({rows, cols})){\\n            ans=mp[{rows, cols}];\\n        }\\n        for(ll j=1; j<cols; j++){\\n            ans=max(ans, util(rows, j)+util(rows, cols-j));\\n        }\\n        for(ll i=1; i<rows; i++){\\n            ans=max(ans, util(i, cols)+util(rows-i, cols));\\n        }\\n        return dp[rows][cols]=ans;\\n    }\\n    \\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        for(auto& itr: prices){\\n            mp[{itr[0], itr[1]}]=itr[2];\\n        }\\n        dp=vector<vector<ll> >(n+1, vector<ll>(m+1, -1));\\n        return util(n, m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    map<pair<ll, ll>, ll> mp;\\n    vector<vector<ll> > dp;\\n    \\n    ll util(ll rows, ll cols){\\n        if(rows==0 || cols==0){\\n            return 0;\\n        }\\n        if(dp[rows][cols]!=-1){\\n            return dp[rows][cols];\\n        }\\n        ll ans=0;\\n        if(mp.count({rows, cols})){\\n            ans=mp[{rows, cols}];\\n        }\\n        for(ll j=1; j<cols; j++){\\n            ans=max(ans, util(rows, j)+util(rows, cols-j));\\n        }\\n        for(ll i=1; i<rows; i++){\\n            ans=max(ans, util(i, cols)+util(rows-i, cols));\\n        }\\n        return dp[rows][cols]=ans;\\n    }\\n    \\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        for(auto& itr: prices){\\n            mp[{itr[0], itr[1]}]=itr[2];\\n        }\\n        dp=vector<vector<ll> >(n+1, vector<ll>(m+1, -1));\\n        return util(n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168881,
                "title": "video-explanation",
                "content": "[Video Link](https://www.youtube.com/watch?v=-fLTdo1ANkE)\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "[Video Link](https://www.youtube.com/watch?v=-fLTdo1ANkE)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2168878,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n  def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n    dp = [[0 for w in range(n + 1)] for h in range(m + 1)]\\n    for price in prices:\\n      dp[price[0]][price[1]] = price[2]\\n    for h in range(1, m + 1):  \\n      for w in range(1, n + 1):\\n        max_cost = dp[h][w]\\n        for h_ in range(1, h):\\n          max_cost = max(max_cost, dp[h_][w] + dp[h - h_][w])\\n        for w_ in range(1, w):\\n          max_cost = max(max_cost, dp[h][w_] + dp[h][w - w_])\\n        dp[h][w] = max_cost  \\n    return dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n    dp = [[0 for w in range(n + 1)] for h in range(m + 1)]\\n    for price in prices:\\n      dp[price[0]][price[1]] = price[2]\\n    for h in range(1, m + 1):  \\n      for w in range(1, n + 1):\\n        max_cost = dp[h][w]\\n        for h_ in range(1, h):\\n          max_cost = max(max_cost, dp[h_][w] + dp[h - h_][w])\\n        for w_ in range(1, w):\\n          max_cost = max(max_cost, dp[h][w_] + dp[h][w - w_])\\n        dp[h][w] = max_cost  \\n    return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168872,
                "title": "java-bottom-up",
                "content": "dp[i, j] signifies is the max amount you can earn from cutting an i x j piece of wood.\\n\\nFor every (i, j) pair we cut the piece of wood in the following ways:\\n1. from height = 1 to i , with width as j\\n2. from width = 1 to j, with height as i\\n\\n\\n\\ndp[i, j] = Maximum of:\\nwidth cuts: { dp[i][x] + dp[i][x-j] } for all 1 <= x < j\\nheight cuts: { dp[x][j] + dp[i-x][j] } for all 1 <= x < i\\n\\nEdge cases. It is possible that a single 2x2 might cost less than four 1x1 pieces.\\nTherefore, you should check each and every piece from 1x1.\\n\\nThe hashmap makes it faster to lookup prices for base cases where each piece of wood can be directly sold as one unit.\\n```\\nclass Solution {\\n        public long sellingWood(int m, int n, int[][] prices) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int[] p : prices) {\\n            hm.put(1000*p[0] + p[1], p[2]);\\n        }\\n\\n        long[][] dp = new long[m+1][n+1];\\n\\n        for(int i = 1; i<= m; i++) {\\n            for(int j = 1; j<=n; j++) {\\n                dp[i][j] = hm.get(1000*i + j)==null?0:hm.get(1000*i + j);\\n\\n                for(int x = 1; x<=i; x++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[x][j] + dp[i-x][j]);\\n                }\\n\\n                for(int x = 1; x<=j; x++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][x] + dp[i][j-x]);\\n                }\\n            }\\n        }\\n\\n\\n        return dp[m][n];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n        public long sellingWood(int m, int n, int[][] prices) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int[] p : prices) {\\n            hm.put(1000*p[0] + p[1], p[2]);\\n        }\\n\\n        long[][] dp = new long[m+1][n+1];\\n\\n        for(int i = 1; i<= m; i++) {\\n            for(int j = 1; j<=n; j++) {\\n                dp[i][j] = hm.get(1000*i + j)==null?0:hm.get(1000*i + j);\\n\\n                for(int x = 1; x<=i; x++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[x][j] + dp[i-x][j]);\\n                }\\n\\n                for(int x = 1; x<=j; x++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][x] + dp[i][j-x]);\\n                }\\n            }\\n        }\\n\\n\\n        return dp[m][n];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168762,
                "title": "easy-to-understand-solution-dp",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        ll dp[n+1][m+1];\\n        //dp[i][j] -> best ans for matrix of size i*j\\n        map<pair<int,int>,int> mp;\\n        for(auto vec:prices){\\n            mp[{vec[0],vec[1]}] = vec[2];\\n        }\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                dp[i][j]=0;\\n            }\\n        }        \\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(mp.find({i,j}) != mp.end()) dp[i][j] = mp[{i,j}];\\n                //moving along vertical side\\n                for(int k=0;k<=j;k++){\\n                    dp[i][j] = max(dp[i][j] , dp[i][k]+dp[i][j-k]);\\n                }\\n                //moving along horizantal side\\n                for(int k=0;k<=i;k++){\\n                    dp[i][j] = max(dp[i][j] , dp[k][j]+dp[i-k][j]);\\n                }                \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        ll dp[n+1][m+1];\\n        //dp[i][j] -> best ans for matrix of size i*j\\n        map<pair<int,int>,int> mp;\\n        for(auto vec:prices){\\n            mp[{vec[0],vec[1]}] = vec[2];\\n        }\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                dp[i][j]=0;\\n            }\\n        }        \\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(mp.find({i,j}) != mp.end()) dp[i][j] = mp[{i,j}];\\n                //moving along vertical side\\n                for(int k=0;k<=j;k++){\\n                    dp[i][j] = max(dp[i][j] , dp[i][k]+dp[i][j-k]);\\n                }\\n                //moving along horizantal side\\n                for(int k=0;k<=i;k++){\\n                    dp[i][j] = max(dp[i][j] , dp[k][j]+dp[i-k][j]);\\n                }                \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168658,
                "title": "simple-c-memomization-dp-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int p[201][201];\\n    long long memo[201][201];\\n    long long helper(int m, int n){\\n        if(m==0 || n==0) return 0;\\n        if(memo[m][n]!=-1) return memo[m][n]; \\n        long long curr = 0;\\n        if(p[m][n]!=-1) curr = p[m][n];\\n        for(int i=1; i<m; i++) curr = max(curr, helper(i, n) + helper(m-i, n));\\n        for(int j=1; j<n; j++) curr = max(curr, helper(m, j) + helper(m, n-j));\\n        return memo[m][n] = curr;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        for(int i=0; i<=m; i++){\\n            for(int j=0; j<=n; j++) p[i][j] = -1, memo[i][j]=-1;\\n        }\\n        for(vector<int> &i: prices){\\n            p[i[0]][i[1]] = i[2];\\n        }\\n        return helper(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int p[201][201];\\n    long long memo[201][201];\\n    long long helper(int m, int n){\\n        if(m==0 || n==0) return 0;\\n        if(memo[m][n]!=-1) return memo[m][n]; \\n        long long curr = 0;\\n        if(p[m][n]!=-1) curr = p[m][n];\\n        for(int i=1; i<m; i++) curr = max(curr, helper(i, n) + helper(m-i, n));\\n        for(int j=1; j<n; j++) curr = max(curr, helper(m, j) + helper(m, n-j));\\n        return memo[m][n] = curr;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        for(int i=0; i<=m; i++){\\n            for(int j=0; j<=n; j++) p[i][j] = -1, memo[i][j]=-1;\\n        }\\n        for(vector<int> &i: prices){\\n            p[i[0]][i[1]] = i[2];\\n        }\\n        return helper(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168587,
                "title": "java-dfs-memo-dp",
                "content": "Time O(mn(m+n))\\nSpace O(mn)\\n```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        Long[][] cache = new Long[m+1][n+1];\\n        // maxPriceNoCut is best price if no cut for size m * n\\n        int[][] maxPriceNoCut = getMaxPriceNoCut(m, n, prices);\\t\\n        return helper(m, n, maxPriceNoCut, cache);\\n    }\\n\\t// Time O(mn (m+n))\\n    private long helper(int m, int n, int[][] maxPriceNoCut, Long[][] cache){\\n        if(cache[m][n] != null){\\n            return cache[m][n];\\n        }\\n        // Max price if not cut\\n        long max = maxPriceNoCut[m][n]; \\n        // Try horizontal cut\\n        for(int i=1;i<m;i++){\\n            long piece1 = helper(i, n, maxPriceNoCut, cache);\\n            long piece2 = helper(m-i, n, maxPriceNoCut, cache);\\n            max = Math.max(max, piece1 + piece2);\\n        }\\n        // Try vertical  cut\\n        for(int i=1;i<n;i++){\\n            long piece1 = helper(m, i, maxPriceNoCut, cache);\\n            long piece2 = helper(m, n-i, maxPriceNoCut, cache);\\n            max = Math.max(max, piece1 + piece2);\\n        }\\n        return cache[m][n] = max;\\n    }\\n\\t// Time O(mn)\\n    private int[][] getMaxPriceNoCut(int m, int n, int[][] prices){\\n        int[][] maxPriceNoCut = new int[m+1][n+1];\\n        for(int[] p : prices){\\n            maxPriceNoCut[p[0]][p[1]] = p[2];\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                maxPriceNoCut[i][j] = Math.max(maxPriceNoCut[i][j], maxPriceNoCut[i-1][j]);\\n                maxPriceNoCut[i][j] = Math.max(maxPriceNoCut[i][j], maxPriceNoCut[i][j-1]);\\n            }\\n        }\\n        return maxPriceNoCut;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        Long[][] cache = new Long[m+1][n+1];\\n        // maxPriceNoCut is best price if no cut for size m * n\\n        int[][] maxPriceNoCut = getMaxPriceNoCut(m, n, prices);\\t\\n        return helper(m, n, maxPriceNoCut, cache);\\n    }\\n\\t// Time O(mn (m+n))\\n    private long helper(int m, int n, int[][] maxPriceNoCut, Long[][] cache){\\n        if(cache[m][n] != null){\\n            return cache[m][n];\\n        }\\n        // Max price if not cut\\n        long max = maxPriceNoCut[m][n]; \\n        // Try horizontal cut\\n        for(int i=1;i<m;i++){\\n            long piece1 = helper(i, n, maxPriceNoCut, cache);\\n            long piece2 = helper(m-i, n, maxPriceNoCut, cache);\\n            max = Math.max(max, piece1 + piece2);\\n        }\\n        // Try vertical  cut\\n        for(int i=1;i<n;i++){\\n            long piece1 = helper(m, i, maxPriceNoCut, cache);\\n            long piece2 = helper(m, n-i, maxPriceNoCut, cache);\\n            max = Math.max(max, piece1 + piece2);\\n        }\\n        return cache[m][n] = max;\\n    }\\n\\t// Time O(mn)\\n    private int[][] getMaxPriceNoCut(int m, int n, int[][] prices){\\n        int[][] maxPriceNoCut = new int[m+1][n+1];\\n        for(int[] p : prices){\\n            maxPriceNoCut[p[0]][p[1]] = p[2];\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                maxPriceNoCut[i][j] = Math.max(maxPriceNoCut[i][j], maxPriceNoCut[i-1][j]);\\n                maxPriceNoCut[i][j] = Math.max(maxPriceNoCut[i][j], maxPriceNoCut[i][j-1]);\\n            }\\n        }\\n        return maxPriceNoCut;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168543,
                "title": "java-recursive-dp-solution",
                "content": "Why it is giving TLE\\n\\n```\\n\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long dp[][]=new long[m+1][n+1];\\n        return sol(m,n,prices,dp);\\n    }\\n    long sol(int height,int width,int [][]price,long dp[][]){\\n        if(height<=0 || width<=0){\\n            return 0l;\\n        }\\n        if( dp[height][width] !=0){\\n            return  dp[height][width] ;\\n        }\\n        long max =0;\\n        for(int i=0;i<price.length;i++){\\n            \\n            int hth = price[i][0];\\n            int wth = price[i][1];\\n            int cost = price[i][2];\\n            \\n            long max_cost = 0;\\n            if(height>=hth &&  width>=wth){\\n                 max_cost = cost+ Math.max(sol(height-hth,width,price,dp) + sol(hth,width-wth,price,dp), sol(height-hth,wth,price,dp)+sol(height,width-wth,price,dp));\\n            }\\n           \\n            max =Math.max(max_cost,max);\\n           \\n        }\\n        dp[height][width] = max;\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long dp[][]=new long[m+1][n+1];\\n        return sol(m,n,prices,dp);\\n    }\\n    long sol(int height,int width,int [][]price,long dp[][]){\\n        if(height<=0 || width<=0){\\n            return 0l;\\n        }\\n        if( dp[height][width] !=0){\\n            return  dp[height][width] ;\\n        }\\n        long max =0;\\n        for(int i=0;i<price.length;i++){\\n            \\n            int hth = price[i][0];\\n            int wth = price[i][1];\\n            int cost = price[i][2];\\n            \\n            long max_cost = 0;\\n            if(height>=hth &&  width>=wth){\\n                 max_cost = cost+ Math.max(sol(height-hth,width,price,dp) + sol(hth,width-wth,price,dp), sol(height-hth,wth,price,dp)+sol(height,width-wth,price,dp));\\n            }\\n           \\n            max =Math.max(max_cost,max);\\n           \\n        }\\n        dp[height][width] = max;\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168509,
                "title": "bottom-up-dp-easy-understanding-with-comments-upvote-if-helpful",
                "content": "Please Upvote if Helpful !!!\\n```\\nclass Solution {\\n    long long board[201][201];\\n    \\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n        for (auto &p : prices)\\n        {\\n            int r = p[0];\\n            int c = p[1];\\n            int cost = p[2];\\n            board[r][c] = cost;\\n        }\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++) \\n            {\\n                // 2 Options: \\n                \\n                // Split the i * j board at row i - k to give 2 boards k * j, (i - k) * j\\n                for (int k = 1; k < i; k++)\\n                    board[i][j] = max(board[i][j], board[k][j] + board[i - k][j]);\\n                \\n                // Split the i * j board at col j - k to give 2 boards i * k, i * (j - k)\\n                for (int k = 1; k < j; k++)\\n                    board[i][j] = max(board[i][j], board[i][k] + board[i][j - k]);\\n            }\\n        }\\n        return board[m][n];\\n    }\\n};\\n```\\nMemoization Method:\\n```\\n/* \\n    Time: O(m*n*max(m,n)+k), k is length of prices\\n    Space: O(m*n+k)\\n    Tag: DP, Memoization, Hashing\\n    Difficulty: M\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n    unordered_map<ll, ll> piece;\\n    vector<vector<ll>> t;\\n\\n    ll solve(int m, int n) {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (t[m][n] != -1) return t[m][n];\\n\\n        ll res = 0;\\n\\n        auto it = piece.find(m * 1000001ll + n);\\n        if (it != piece.end()) res = it->second;\\n\\n        for (int i = 1; i < m; i++) {\\n            res = max(res, solve(i, n) + solve(m - i, n));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res = max(res, solve(m, i) + solve(m, n - i));\\n        }\\n\\n        t[m][n] = res;\\n        return t[m][n];\\n    }\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>> &prices) {\\n        for (auto &v : prices) {\\n            piece[v[0] * 1000001ll + v[1]] = v[2];\\n        }\\n        t.resize(m + 1, vector<ll>(n + 1, -1));\\n        return solve(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long long board[201][201];\\n    \\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n        for (auto &p : prices)\\n        {\\n            int r = p[0];\\n            int c = p[1];\\n            int cost = p[2];\\n            board[r][c] = cost;\\n        }\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++) \\n            {\\n                // 2 Options: \\n                \\n                // Split the i * j board at row i - k to give 2 boards k * j, (i - k) * j\\n                for (int k = 1; k < i; k++)\\n                    board[i][j] = max(board[i][j], board[k][j] + board[i - k][j]);\\n                \\n                // Split the i * j board at col j - k to give 2 boards i * k, i * (j - k)\\n                for (int k = 1; k < j; k++)\\n                    board[i][j] = max(board[i][j], board[i][k] + board[i][j - k]);\\n            }\\n        }\\n        return board[m][n];\\n    }\\n};\\n```\n```\\n/* \\n    Time: O(m*n*max(m,n)+k), k is length of prices\\n    Space: O(m*n+k)\\n    Tag: DP, Memoization, Hashing\\n    Difficulty: M\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n    unordered_map<ll, ll> piece;\\n    vector<vector<ll>> t;\\n\\n    ll solve(int m, int n) {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (t[m][n] != -1) return t[m][n];\\n\\n        ll res = 0;\\n\\n        auto it = piece.find(m * 1000001ll + n);\\n        if (it != piece.end()) res = it->second;\\n\\n        for (int i = 1; i < m; i++) {\\n            res = max(res, solve(i, n) + solve(m - i, n));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res = max(res, solve(m, i) + solve(m, n - i));\\n        }\\n\\n        t[m][n] = res;\\n        return t[m][n];\\n    }\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>> &prices) {\\n        for (auto &v : prices) {\\n            piece[v[0] * 1000001ll + v[1]] = v[2];\\n        }\\n        t.resize(m + 1, vector<ll>(n + 1, -1));\\n        return solve(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168427,
                "title": "c-just-generate-all-possible-dimensions-and-memoize-it",
                "content": "```\\n/* \\n    Time: O(m*n*(m+n)+k), k is length of prices\\n    Space: O(m*n+k)\\n    Tag: DP, Memoization, Hashing\\n    Difficulty: M\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n    unordered_map<ll, ll> piece;\\n    vector<vector<ll>> t;\\n\\n    ll solve(int m, int n) {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (t[m][n] != -1) return t[m][n];\\n\\n        ll res = 0;\\n\\n        auto it = piece.find(m * 1000001ll + n);\\n        if (it != piece.end()) res = it->second;\\n\\n        for (int i = 1; i < m; i++) {\\n            res = max(res, solve(i, n) + solve(m - i, n));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res = max(res, solve(m, i) + solve(m, n - i));\\n        }\\n\\n        t[m][n] = res;\\n        return t[m][n];\\n    }\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>> &prices) {\\n        for (auto &v : prices) {\\n            piece[v[0] * 1000001ll + v[1]] = v[2];\\n        }\\n        t.resize(m + 1, vector<ll>(n + 1, -1));\\n        return solve(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/* \\n    Time: O(m*n*(m+n)+k), k is length of prices\\n    Space: O(m*n+k)\\n    Tag: DP, Memoization, Hashing\\n    Difficulty: M\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n    unordered_map<ll, ll> piece;\\n    vector<vector<ll>> t;\\n\\n    ll solve(int m, int n) {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (t[m][n] != -1) return t[m][n];\\n\\n        ll res = 0;\\n\\n        auto it = piece.find(m * 1000001ll + n);\\n        if (it != piece.end()) res = it->second;\\n\\n        for (int i = 1; i < m; i++) {\\n            res = max(res, solve(i, n) + solve(m - i, n));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res = max(res, solve(m, i) + solve(m, n - i));\\n        }\\n\\n        t[m][n] = res;\\n        return t[m][n];\\n    }\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>> &prices) {\\n        for (auto &v : prices) {\\n            piece[v[0] * 1000001ll + v[1]] = v[2];\\n        }\\n        t.resize(m + 1, vector<ll>(n + 1, -1));\\n        return solve(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168406,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        pDict = {}\\n        for h,w,p in prices:\\n            pDict[(h,w)] = p\\n        \\n        @lru_cache(None)\\n        def dp(H,W):\\n            ans = 0\\n            if (H,W) in pDict:\\n                ans = pDict[(H,W)]\\n            for i in range(1,H):\\n                ans = max(ans, dp(H-i,W) + dp(i,W))\\n            for j in range(1,W):\\n                ans = max(ans, dp(H,W-j)+dp(H,j))\\n            return ans\\n        return dp(m,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        pDict = {}\\n        for h,w,p in prices:\\n            pDict[(h,w)] = p\\n        \\n        @lru_cache(None)\\n        def dp(H,W):\\n            ans = 0\\n            if (H,W) in pDict:\\n                ans = pDict[(H,W)]\\n            for i in range(1,H):\\n                ans = max(ans, dp(H-i,W) + dp(i,W))\\n            for j in range(1,W):\\n                ans = max(ans, dp(H,W-j)+dp(H,j))\\n            return ans\\n        return dp(m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168354,
                "title": "passable-but-probably-not-the-intended-solution",
                "content": "Worst time complexity is `O(mn*len(prices))` so it doesn\\'t pass without the `if dp[h][w] < price:` condition, but in practice this clocks at 1128 ms.\\n```\\n# Simplified\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        prices.sort()\\n        for h, w, price in prices:\\n            if dp[h][w] < price:\\n                for i in range(h, m + 1):\\n                    for j in range(w, n + 1):\\n                        dp[i][j] = max(dp[i][j], price + dp[i - h][j] + dp[h][j - w], price + dp[i][j - w] + dp[i - h][w])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Simplified\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        prices.sort()\\n        for h, w, price in prices:\\n            if dp[h][w] < price:\\n                for i in range(h, m + 1):\\n                    for j in range(w, n + 1):\\n                        dp[i][j] = max(dp[i][j], price + dp[i - h][j] + dp[h][j - w], price + dp[i][j - w] + dp[i - h][w])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168278,
                "title": "simple-dp-solution",
                "content": "Let n = Number of rows and m = Number of columns.\\n\\n\\nStore prices in a matrix of (n * m) where cost[row][col] is maximum price of board with dimension as (row*col) as given in prices array for faster look-up.\\n\\n\\nProblem can now be reduced as \\n\\nT(n, m) = max[cost[n][m] ,  max(T(r, m) + T(n - r, m)), max(T(n, c) + T(n, m-c))]\\n\\nwhere r in [1, n-1] and c in [1, m-1] \\n\\nComplexity :\\n\\nTime : O(n* m* (n+m))\\nSpace : O(n* m)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int> > cost;\\n    vector<vector<long long> > dp;\\n    \\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        \\n        cost.assign(n+1, vector<int> (m+1, -1));\\n        for(int i=0;i<prices.size();i++) {\\n            cost[prices[i][0]][prices[i][1]] = max(cost[prices[i][0]][prices[i][1]], prices[i][2]);            \\n        }\\n        \\n        dp.assign(n+1, vector<long long> (m+1, -1));\\n                \\n        long long ans = getans(n, m);\\n        return ans;\\n    }\\n    \\n    long long getans(int row, int col) {\\n        if(row == 1 && col == 1) {\\n            if(cost[1][1] != -1)\\n                return cost[1][1];\\n            return 0;\\n        }\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        \\n        long long ans = cost[row][col] == -1 ? 0 : cost[row][col];\\n        \\n        for(int i = 1; i < row; i++) {\\n            long long curr = getans(i, col) + getans(row - i, col);\\n            ans = max(ans, curr);\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            long long curr = getans(row, i) + getans(row, col - i);\\n            ans = max(ans, curr);\\n        }\\n        \\n        dp[row][col] = ans;\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int> > cost;\\n    vector<vector<long long> > dp;\\n    \\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        \\n        cost.assign(n+1, vector<int> (m+1, -1));\\n        for(int i=0;i<prices.size();i++) {\\n            cost[prices[i][0]][prices[i][1]] = max(cost[prices[i][0]][prices[i][1]], prices[i][2]);            \\n        }\\n        \\n        dp.assign(n+1, vector<long long> (m+1, -1));\\n                \\n        long long ans = getans(n, m);\\n        return ans;\\n    }\\n    \\n    long long getans(int row, int col) {\\n        if(row == 1 && col == 1) {\\n            if(cost[1][1] != -1)\\n                return cost[1][1];\\n            return 0;\\n        }\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        \\n        long long ans = cost[row][col] == -1 ? 0 : cost[row][col];\\n        \\n        for(int i = 1; i < row; i++) {\\n            long long curr = getans(i, col) + getans(row - i, col);\\n            ans = max(ans, curr);\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            long long curr = getans(row, i) + getans(row, col - i);\\n            ans = max(ans, curr);\\n        }\\n        \\n        dp[row][col] = ans;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168217,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        unordered_map<int, vector<int>> dict_row;//key: row, value: price idx\\n        unordered_map<int, vector<int>> dict_col;//key: col, value: price idx\\n        for(int i=0;i<prices.size();++i){\\n            const auto& p = prices.at(i);\\n            int h = p[0];\\n            int w = p[1];\\n            dict_row[h].push_back(i);\\n            dict_col[w].push_back(i);\\n        }\\n        vector<vector<ll>> dp(m + 1, vector<ll>(n + 1, 0));\\n        for(int i=0;i<m;++i){\\n            dp[i][0] = 0;\\n        }\\n        for(int j=0;j<n;++j){\\n            dp[0][j] = 0;\\n        }\\n        for(int i=0;i+1<=m;++i){\\n            for(int j=0;j+1<=n;++j){\\n                // dp[i+1][j]\\n                for(int k=1;k<=(i+1)/2;++k){\\n                    dp[i+1][j] = max(dp[i+1][j], dp[k][j] + dp[i+1-k][j]);\\n                }\\n                if(dict_row.count(i + 1) > 0){\\n                    for(auto idx : dict_row[i+1]){\\n                        ll h = i + 1;\\n                        ll w = prices[idx][1];\\n                        ll cash = prices[idx][2];\\n                        for(ll k=1;k * w <= j;++k){\\n                            dp[i+1][j] = max(dp[i+1][j], cash * k + dp[i+1][j - k * w]);\\n                        }\\n                    }\\n                }\\n                \\n                //dp[i][j+1]\\n                for(int k=1;k<=(j+1)/2;++k){\\n                    dp[i][j+1] = max(dp[i][j+1], dp[i][k] + dp[i][j+1-k]);\\n                }\\n                if(dict_col.count(j + 1) > 0){\\n                    for(auto idx : dict_col[j+1]){\\n                        ll h = prices[idx][0];\\n                        ll w = j + 1;\\n                        ll cash = prices[idx][2];\\n                        for(ll k=1;k * h <= i;++k){\\n                            dp[i][j+1] = max(dp[i][j+1], cash * k + dp[i - k * h][j+1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //dp[m][n]\\n        for(int k=1;k<=m/2;++k){\\n            dp[m][n] = max(dp[m][n], dp[k][n] + dp[m-k][n]);\\n        }\\n          if(dict_row.count(m) > 0){\\n                for(auto idx : dict_row[m]){\\n                    ll h = m;\\n                    ll w = prices[idx][1];\\n                    ll cash = prices[idx][2];\\n                    for(ll k=1;k * w <= n;++k){\\n                        dp[m][n] = max(dp[m][n], cash * k + dp[m][n - k * w]);\\n                    }\\n                }\\n            }\\n        \\n        for(int k=1;k<=n/2;++k){\\n            dp[m][n] = max(dp[m][n], dp[m][k] + dp[m][n-k]);\\n        }\\n        if(dict_col.count(n) > 0){\\n            for(auto idx : dict_col[n]){\\n                ll h = prices[idx][0];\\n                ll w = n;\\n                ll cash = prices[idx][2];\\n                for(ll k=1;k * h <= m;++k){\\n                    dp[m][n] = max(dp[m][n], cash * k + dp[m - k * h][n]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        unordered_map<int, vector<int>> dict_row;//key: row, value: price idx\\n        unordered_map<int, vector<int>> dict_col;//key: col, value: price idx\\n        for(int i=0;i<prices.size();++i){\\n            const auto& p = prices.at(i);\\n            int h = p[0];\\n            int w = p[1];\\n            dict_row[h].push_back(i);\\n            dict_col[w].push_back(i);\\n        }\\n        vector<vector<ll>> dp(m + 1, vector<ll>(n + 1, 0));\\n        for(int i=0;i<m;++i){\\n            dp[i][0] = 0;\\n        }\\n        for(int j=0;j<n;++j){\\n            dp[0][j] = 0;\\n        }\\n        for(int i=0;i+1<=m;++i){\\n            for(int j=0;j+1<=n;++j){\\n                // dp[i+1][j]\\n                for(int k=1;k<=(i+1)/2;++k){\\n                    dp[i+1][j] = max(dp[i+1][j], dp[k][j] + dp[i+1-k][j]);\\n                }\\n                if(dict_row.count(i + 1) > 0){\\n                    for(auto idx : dict_row[i+1]){\\n                        ll h = i + 1;\\n                        ll w = prices[idx][1];\\n                        ll cash = prices[idx][2];\\n                        for(ll k=1;k * w <= j;++k){\\n                            dp[i+1][j] = max(dp[i+1][j], cash * k + dp[i+1][j - k * w]);\\n                        }\\n                    }\\n                }\\n                \\n                //dp[i][j+1]\\n                for(int k=1;k<=(j+1)/2;++k){\\n                    dp[i][j+1] = max(dp[i][j+1], dp[i][k] + dp[i][j+1-k]);\\n                }\\n                if(dict_col.count(j + 1) > 0){\\n                    for(auto idx : dict_col[j+1]){\\n                        ll h = prices[idx][0];\\n                        ll w = j + 1;\\n                        ll cash = prices[idx][2];\\n                        for(ll k=1;k * h <= i;++k){\\n                            dp[i][j+1] = max(dp[i][j+1], cash * k + dp[i - k * h][j+1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //dp[m][n]\\n        for(int k=1;k<=m/2;++k){\\n            dp[m][n] = max(dp[m][n], dp[k][n] + dp[m-k][n]);\\n        }\\n          if(dict_row.count(m) > 0){\\n                for(auto idx : dict_row[m]){\\n                    ll h = m;\\n                    ll w = prices[idx][1];\\n                    ll cash = prices[idx][2];\\n                    for(ll k=1;k * w <= n;++k){\\n                        dp[m][n] = max(dp[m][n], cash * k + dp[m][n - k * w]);\\n                    }\\n                }\\n            }\\n        \\n        for(int k=1;k<=n/2;++k){\\n            dp[m][n] = max(dp[m][n], dp[m][k] + dp[m][n-k]);\\n        }\\n        if(dict_col.count(n) > 0){\\n            for(auto idx : dict_col[n]){\\n                ll h = prices[idx][0];\\n                ll w = n;\\n                ll cash = prices[idx][2];\\n                for(ll k=1;k * h <= m;++k){\\n                    dp[m][n] = max(dp[m][n], cash * k + dp[m - k * h][n]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864570,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "The critical step to avoid TLE is to avoid symmetric split. In other words, if you have already calculated the price of splitting a wood (h, w) into (h, w1) and (h, w - w1), you should not calculate it splitting into (h, w - w1) and (h, w1) again. By avoiding this the total cost is halved."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "was able to do this question , felt so good !!"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially I tried to cut out every possible `prices` size from the given wood slab, get 2 smaller pieces after the cut and solve the problem recursively for the smaller pieces. My solution exceeded the time limit, because the number of `prices` is very high.\n\nA simple idea helped me to improve the performance.  Don't check each `prices` size, check each possible horizontal and vertical cut, there are only 200 of them for the biggest piece of wood. "
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s a 2D 0\\u2013\\u221E knapsack problem. Extra hard to solve, but the solution is extra satisfying."
                    }
                ]
            },
            {
                "id": 1856574,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "The critical step to avoid TLE is to avoid symmetric split. In other words, if you have already calculated the price of splitting a wood (h, w) into (h, w1) and (h, w - w1), you should not calculate it splitting into (h, w - w1) and (h, w1) again. By avoiding this the total cost is halved."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "was able to do this question , felt so good !!"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially I tried to cut out every possible `prices` size from the given wood slab, get 2 smaller pieces after the cut and solve the problem recursively for the smaller pieces. My solution exceeded the time limit, because the number of `prices` is very high.\n\nA simple idea helped me to improve the performance.  Don't check each `prices` size, check each possible horizontal and vertical cut, there are only 200 of them for the biggest piece of wood. "
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s a 2D 0\\u2013\\u221E knapsack problem. Extra hard to solve, but the solution is extra satisfying."
                    }
                ]
            },
            {
                "id": 1787167,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "The critical step to avoid TLE is to avoid symmetric split. In other words, if you have already calculated the price of splitting a wood (h, w) into (h, w1) and (h, w - w1), you should not calculate it splitting into (h, w - w1) and (h, w1) again. By avoiding this the total cost is halved."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "was able to do this question , felt so good !!"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially I tried to cut out every possible `prices` size from the given wood slab, get 2 smaller pieces after the cut and solve the problem recursively for the smaller pieces. My solution exceeded the time limit, because the number of `prices` is very high.\n\nA simple idea helped me to improve the performance.  Don't check each `prices` size, check each possible horizontal and vertical cut, there are only 200 of them for the biggest piece of wood. "
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s a 2D 0\\u2013\\u221E knapsack problem. Extra hard to solve, but the solution is extra satisfying."
                    }
                ]
            },
            {
                "id": 1787175,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "The critical step to avoid TLE is to avoid symmetric split. In other words, if you have already calculated the price of splitting a wood (h, w) into (h, w1) and (h, w - w1), you should not calculate it splitting into (h, w - w1) and (h, w1) again. By avoiding this the total cost is halved."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "was able to do this question , felt so good !!"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially I tried to cut out every possible `prices` size from the given wood slab, get 2 smaller pieces after the cut and solve the problem recursively for the smaller pieces. My solution exceeded the time limit, because the number of `prices` is very high.\n\nA simple idea helped me to improve the performance.  Don't check each `prices` size, check each possible horizontal and vertical cut, there are only 200 of them for the biggest piece of wood. "
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s a 2D 0\\u2013\\u221E knapsack problem. Extra hard to solve, but the solution is extra satisfying."
                    }
                ]
            }
        ]
    },
    {
        "title": "Spiral Matrix IV",
        "question_content": "<p>You are given two integers <code>m</code> and <code>n</code>, which represent the dimensions of a matrix.</p>\n\n<p>You are also given the <code>head</code> of a linked list of integers.</p>\n\n<p>Generate an <code>m x n</code> matrix that contains the integers in the linked list presented in <strong>spiral</strong> order <strong>(clockwise)</strong>, starting from the <strong>top-left</strong> of the matrix. If there are remaining empty spaces, fill them with <code>-1</code>.</p>\n\n<p>Return <em>the generated matrix</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg\" style=\"width: 240px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\n<strong>Output:</strong> [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\n<strong>Explanation:</strong> The diagram above shows how the values are printed in the matrix.\nNote that the remaining spaces in the matrix are filled with -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg\" style=\"width: 221px; height: 60px;\" />\n<pre>\n<strong>Input:</strong> m = 1, n = 4, head = [0,1,2]\n<strong>Output:</strong> [[0,1,2,-1]]\n<strong>Explanation:</strong> The diagram above shows how the values are printed from left to right in the matrix.\nThe last space in the matrix is set to -1.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li>The number of nodes in the list is in the range <code>[1, m * n]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2229856,
                "title": "roomba",
                "content": "We use directions (`d`) to right->down->left->up and then repeat. When we bump into an edge - we change the direction.\\n\\nNote that an edge is also a cell that we\\'ve already filled (not equal to `-1`). This makes it a bit easier, otherwise we could use an offset, incrementing it after each full turn.\\n\\n**C++**\\n```cpp    \\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    int i = 0, j = 0, cur_d = 0, d[5] = {0, 1, 0, -1, 0};\\n    vector<vector<int>> res(m, vector<int>(n, -1));\\n    for (; head != nullptr; head = head->next) {\\n        res[i][j] = head->val;\\n        int ni = i + d[cur_d], nj = j + d[cur_d + 1];\\n        if (min(ni, nj) < 0 || ni >= m || nj >= n || res[ni][nj] != -1)\\n            cur_d = (cur_d + 1) % 4;\\n        i += d[cur_d];\\n        j += d[cur_d + 1];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    int i = 0, j = 0, cur_d = 0, d[5] = {0, 1, 0, -1, 0};\\n    vector<vector<int>> res(m, vector<int>(n, -1));\\n    for (; head != nullptr; head = head->next) {\\n        res[i][j] = head->val;\\n        int ni = i + d[cur_d], nj = j + d[cur_d + 1];\\n        if (min(ni, nj) < 0 || ni >= m || nj >= n || res[ni][nj] != -1)\\n            cur_d = (cur_d + 1) % 4;\\n        i += d[cur_d];\\n        j += d[cur_d + 1];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230122,
                "title": "c-easy-understanding-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) \\n    {\\n\\t\\t// Create a matrix of n x m with values filled with -1.\\n        vector<vector<int>> spiral(n, vector<int>(m, -1));\\n        int i = 0, j = 0;\\n\\t\\t// Traverse the matrix in spiral form, and update with the values present in the head list.\\n\\t\\t// If head reacher NULL pointer break out from the loop, and return the spiral matrix.\\n        while (head != NULL)\\n        {\\n            if (j < m)\\n            {\\n                while (head != NULL && j < m && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    j++;\\n                }\\n                if (head == NULL)\\n                    break;\\n                i++;\\n                j--;\\n            }\\n            if (i < n)\\n            {\\n                while (head != NULL && i < n && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    i++;\\n                }\\n                i--;\\n                j--;\\n            }\\n            if (j >= 0)\\n            {\\n                while (head != NULL && j >= 0 && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    j--;\\n                }\\n                j++;\\n                i--;\\n            }\\n            if (i >= 0)\\n            {\\n                while (head != NULL && i >= 0 && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    i--;\\n                }\\n                i++;\\n                j++;\\n            }\\n            n--;\\n            m++;\\n        }\\n\\t\\t// Rest values are itself -1.\\n        return spiral;\\n    }\\n};\\n```\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) \\n    {\\n\\t\\t// Create a matrix of n x m with values filled with -1.\\n        vector<vector<int>> spiral(n, vector<int>(m, -1));\\n        int i = 0, j = 0;\\n\\t\\t// Traverse the matrix in spiral form, and update with the values present in the head list.\\n\\t\\t// If head reacher NULL pointer break out from the loop, and return the spiral matrix.\\n        while (head != NULL)\\n        {\\n            if (j < m)\\n            {\\n                while (head != NULL && j < m && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    j++;\\n                }\\n                if (head == NULL)\\n                    break;\\n                i++;\\n                j--;\\n            }\\n            if (i < n)\\n            {\\n                while (head != NULL && i < n && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    i++;\\n                }\\n                i--;\\n                j--;\\n            }\\n            if (j >= 0)\\n            {\\n                while (head != NULL && j >= 0 && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    j--;\\n                }\\n                j++;\\n                i--;\\n            }\\n            if (i >= 0)\\n            {\\n                while (head != NULL && i >= 0 && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    i--;\\n                }\\n                i++;\\n                j++;\\n            }\\n            n--;\\n            m++;\\n        }\\n\\t\\t// Rest values are itself -1.\\n        return spiral;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229918,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        num = m * n\\n        res = [[-1 for j in range(n)] for i in range(m)]\\n        x, y = 0, 0\\n        dx, dy = 1, 0\\n        while head:\\n            res[y][x] = head.val\\n            if x + dx < 0 or x + dx >= n or y + dy < 0 or y + dy >= m or res[y+dy][x+dx] != -1:\\n                dx, dy = -dy, dx\\n            x = x + dx\\n            y = y + dy\\n            head = head.next\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        num = m * n\\n        res = [[-1 for j in range(n)] for i in range(m)]\\n        x, y = 0, 0\\n        dx, dy = 1, 0\\n        while head:\\n            res[y][x] = head.val\\n            if x + dx < 0 or x + dx >= n or y + dy < 0 or y + dy >= m or res[y+dy][x+dx] != -1:\\n                dx, dy = -dy, dx\\n            x = x + dx\\n            y = y + dy\\n            head = head.next\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231052,
                "title": "python-concise-code-easy-to-understand",
                "content": "The idea to take from this, is how to rotate the direction in a concise way.\\n\\nInitially we start by adding 1 to the column, and 0 to the row (going right)\\n\\nIf we hit a wall/edge, we must swap the direction. The trick is to swap with: \\n\\n`xr, xc = xc, -xr`\\n\\nLet `xr` be the term we add to our `r` row in every move.\\nLet `xc` be the term we add to our `c` column in every move.\\n\\n```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        r, c = 0, 0\\n        xr, xc = 0, 1\\n        \\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n        while head:\\n            matrix[r][c] = head.val\\n            \\n            # Conditions to swap the direction\\n            if r + xr < 0 or r + xr >= m or c + xc < 0 or c + xc >= n or matrix[r+xr][c+xc] != -1:\\n                xr, xc = xc, -xr\\n            \\n            r += xr\\n            c += xc\\n            head = head.next\\n        \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        r, c = 0, 0\\n        xr, xc = 0, 1\\n        \\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n        while head:\\n            matrix[r][c] = head.val\\n            \\n            # Conditions to swap the direction\\n            if r + xr < 0 or r + xr >= m or c + xc < 0 or c + xc >= n or matrix[r+xr][c+xc] != -1:\\n                xr, xc = xc, -xr\\n            \\n            r += xr\\n            c += xc\\n            head = head.next\\n        \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205664,
                "title": "spiral-matrix-i-ii-iii-iv-solutions",
                "content": "# Explaination\\n- This is a very simple and easy to understand solution. I have traversed RIGHT and incremented TOP, then traverse DOWN and decrement RIGHT, then I traverse LEFT and decrement BOTTOM, and finally I have traversed UP and increment LEFT.\\n\\n- The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. \\nAny comments greatly appreciated.\\n\\n# Complexity\\n- Time Complexity: O(m*n)\\n- Space Complexity: O(1)\\n\\n# Spiral Matrix I\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\\n# Spiral Matrix II\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Spiral Matrix III\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Sprial Matrix IV\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309660,
                "title": "java-solution-runtime-8-ms-faster-than-96-36-of-java-online-submissions-for-spiral-matrix-iv",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans=new int[m][n];\\n        for(int[] arr:ans){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        int rowBegin=0;\\n        int rowEnd=m-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        ListNode cur=head;\\n        \\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && cur!=null){\\n            \\n            for(int i=columnBegin;i<=columnEnd && cur!=null;i++){\\n                if(cur!=null){\\n                    ans[rowBegin][i]=cur.val;\\n                }\\n               \\n                    cur=cur.next;\\n                \\n                \\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd && cur!=null;i++){\\n               if(cur!=null){\\n                ans[i][columnEnd]=cur.val;\\n               }\\n                \\n                    cur=cur.next;\\n                \\n\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin && cur!=null;i--){\\n                if(cur!=null){\\n                ans[rowEnd][i]=cur.val;\\n                }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin && cur!=null;i--){\\n                  if(cur!=null){\\n                ans[i][columnBegin]=cur.val;\\n                  }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans=new int[m][n];\\n        for(int[] arr:ans){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        int rowBegin=0;\\n        int rowEnd=m-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        ListNode cur=head;\\n        \\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && cur!=null){\\n            \\n            for(int i=columnBegin;i<=columnEnd && cur!=null;i++){\\n                if(cur!=null){\\n                    ans[rowBegin][i]=cur.val;\\n                }\\n               \\n                    cur=cur.next;\\n                \\n                \\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd && cur!=null;i++){\\n               if(cur!=null){\\n                ans[i][columnEnd]=cur.val;\\n               }\\n                \\n                    cur=cur.next;\\n                \\n\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin && cur!=null;i--){\\n                if(cur!=null){\\n                ans[rowEnd][i]=cur.val;\\n                }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin && cur!=null;i--){\\n                  if(cur!=null){\\n                ans[i][columnBegin]=cur.val;\\n                  }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230062,
                "title": "c-easy-to-uderstand-solution-simple-concept",
                "content": "![image](https://assets.leetcode.com/users/images/3fddd4d2-8830-49bb-847e-da22c49a2992_1656821239.6477444.png)\\n\\n**T->O(m * n) && S->O(m * n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\t\\tvector<vector<int>> mat(m,vector<int>(n,-1));\\n\\t\\t\\t\\tListNode* curr=head;\\n\\t\\t\\t\\tint minr=0;\\n\\t\\t\\t\\tint minc=0;\\n\\t\\t\\t\\tint maxr=m-1;\\n\\t\\t\\t\\tint maxc=n-1;\\n\\t\\t\\t\\twhile(curr!=NULL){\\n\\t\\t\\t\\t\\tfor(int j=minc;j<=maxc && curr!=NULL;j++){\\n\\t\\t\\t\\t\\t\\tint i=minr;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tminr++;\\n\\t\\t\\t\\t\\tfor(int i=minr;i<=maxr && curr!=NULL;i++){\\n\\t\\t\\t\\t\\t\\tint j=maxc;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmaxc--;\\n\\t\\t\\t\\t\\tfor(int j=maxc;j>=minc && curr!=NULL;j--){\\n\\t\\t\\t\\t\\t\\tint i=maxr;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmaxr--;\\n\\t\\t\\t\\t\\tfor(int i=maxr;i>=minr && curr!=NULL;i--){\\n\\t\\t\\t\\t\\t\\tint j=minc;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tminc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn mat;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\t\\tvector<vector<int>> mat(m,vector<int>(n,-1));\\n\\t\\t\\t\\tListNode* curr=head;\\n\\t\\t\\t\\tint minr=0;\\n\\t\\t\\t\\tint minc=0;\\n\\t\\t\\t\\tint maxr=m-1;\\n\\t\\t\\t\\tint maxc=n-1;\\n\\t\\t\\t\\twhile(curr!=NULL){\\n\\t\\t\\t\\t\\tfor(int j=minc;j<=maxc && curr!=NULL;j++){\\n\\t\\t\\t\\t\\t\\tint i=minr;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2232024,
                "title": "java-iterative",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int res[][] = new int[m][n];\\n        for(int x[] : res) Arrays.fill(x,-1);\\n        ListNode temp=head;\\n        int startrow=0;\\n        int startcol=0;\\n        int endrow=m-1;\\n        int endcol=n-1;\\n        while(temp!=null){\\n            \\n            for(int i=startcol;i<=endcol;i++){\\n                if(temp==null) break;\\n                res[startrow][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=startrow+1;i<=endrow;i++){\\n                 if(temp==null) break;\\n                res[i][endcol]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=endcol-1;i>=startcol;i--){\\n                 if(temp==null) break;\\n                res[endrow][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=endrow-1;i>startrow;i--){\\n                 if(temp==null) break;\\n                res[i][startcol]=temp.val;\\n                temp=temp.next;\\n            }\\n            startrow++;\\n            startcol++;\\n            endrow--;\\n            endcol--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int res[][] = new int[m][n];\\n        for(int x[] : res) Arrays.fill(x,-1);\\n        ListNode temp=head;\\n        int startrow=0;\\n        int startcol=0;\\n        int endrow=m-1;\\n        int endcol=n-1;\\n        while(temp!=null){\\n            \\n            for(int i=startcol;i<=endcol;i++){\\n                if(temp==null) break;\\n                res[startrow][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=startrow+1;i<=endrow;i++){\\n                 if(temp==null) break;\\n                res[i][endcol]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=endcol-1;i>=startcol;i--){\\n                 if(temp==null) break;\\n                res[endrow][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=endrow-1;i>startrow;i--){\\n                 if(temp==null) break;\\n                res[i][startcol]=temp.val;\\n                temp=temp.next;\\n            }\\n            startrow++;\\n            startcol++;\\n            endrow--;\\n            endcol--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229981,
                "title": "c-simulation",
                "content": "**Algorithm**\\nProgressively fill the matrix. The key is clockwise rotation (di, dj) = (dj, -di). \\n\\n**Complexity**\\n* O(M*N) time \\n* O(M*N) space \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* node = head; \\n        vector<vector<int>> ans(m, vector<int>(n, -1)); \\n        for (int i = 0, j = 0, di = 0, dj = 1; node; node = node->next, i+=di, j+=dj) {\\n            ans[i][j] = node->val; \\n            if (i+di < 0 || i+di == m || j+dj < 0 || j+dj == n || ans[i+di][j+dj] != -1) \\n                tie(di, dj) = make_tuple(dj, -di); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* node = head; \\n        vector<vector<int>> ans(m, vector<int>(n, -1)); \\n        for (int i = 0, j = 0, di = 0, dj = 1; node; node = node->next, i+=di, j+=dj) {\\n            ans[i][j] = node->val; \\n            if (i+di < 0 || i+di == m || j+dj < 0 || j+dj == n || ans[i+di][j+dj] != -1) \\n                tie(di, dj) = make_tuple(dj, -di); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240061,
                "title": "java-o-m-n-11ms",
                "content": "only move to valid points\\n>Runtime: 11 ms, faster than 91.80% of Java online submissions for Spiral Matrix IV.\\nMemory Usage: 60.2 MB, less than 98.42% of Java online submissions for Spiral Matrix IV.\\n```java\\npublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] answer = new int[m][n];\\n        for (int[] ints : answer) {\\n            Arrays.fill(ints, -1);\\n        }\\n\\n        int y = 0;\\n        int x = 0;\\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int curDir = 0;\\n        int cnt = 0;\\n        while (head != null) {\\n            answer[y][x] = head.val;\\n\\n            if (++cnt == m * n) {\\n                return answer;\\n            }\\n\\n            int[] dir = dirs[curDir];\\n            int nextY = y + dir[0];\\n            int nextX = x + dir[1];\\n            if (nextY < 0 || nextY >= m || nextX < 0 || nextX >= n || answer[nextY][nextX] != -1) {\\n                curDir = (curDir + 1) % 4;\\n                nextY = y + dirs[curDir][0];\\n                nextX = x + dirs[curDir][1];\\n            }\\n            y = nextY;\\n            x = nextX;\\n            head = head.next;\\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] answer = new int[m][n];\\n        for (int[] ints : answer) {\\n            Arrays.fill(ints, -1);\\n        }\\n\\n        int y = 0;\\n        int x = 0;\\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int curDir = 0;\\n        int cnt = 0;\\n        while (head != null) {\\n            answer[y][x] = head.val;\\n\\n            if (++cnt == m * n) {\\n                return answer;\\n            }\\n\\n            int[] dir = dirs[curDir];\\n            int nextY = y + dir[0];\\n            int nextX = x + dir[1];\\n            if (nextY < 0 || nextY >= m || nextX < 0 || nextX >= n || answer[nextY][nextX] != -1) {\\n                curDir = (curDir + 1) % 4;\\n                nextY = y + dirs[curDir][0];\\n                nextX = x + dirs[curDir][1];\\n            }\\n            y = nextY;\\n            x = nextX;\\n            head = head.next;\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230747,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nA long question but just implementation.\\n\\n* Firstly create a **2-D** array with all values initialised to```-1``` so if linked list is incomplete, we will not update remaining index of array as they will already be ```-1```.\\n\\n* With a while loop put the value from linked list at index ```[x][y]``` -> ```res[x][y] = head -> val;```\\n\\n**HOW TO UPDATE VALUES OF X,Y**\\nVariables:\\n* **r1** -> represents TOPMOST row that has been filled\\n* **r2** -> represents BOTTOM row that has been filled\\n* **c1** -> represents LEFTMOST column that has been filled\\n* **c2** -> represents RIGHTMOST column that has been filled\\n\\n* **left** -> true if we are moving in LEFT direction.\\n* **right** ->true if we are moving in RIGHT direction.\\n* **down** -> true if we are moving in DOWN direction.\\n* If all three are **false** we are moing in upward direction.\\n![image](https://assets.leetcode.com/users/images/a5639faf-ea4a-416f-925f-1ab9120b55ee_1656828246.234272.png)\\n\\n* While moving right -> keep increasing **Y** -> when at last point, increase **r1**.\\n* While moving down -> keep increasing **X** -> when at last point . decrease **c2**.\\n* While moving left -> keep decreasing **Y** -> when at last point, decrease **r2**.\\n* While moving upward -> keep decreasing **X** -> when at last point, increase **c1**.\\n\\nALSO REMEMBER TO CHANGE ```bool left, right, down``` accordingly while reaching last point in any direction.\\n\\n\\n**UPVOTE IF HELPFuuL**\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> res;\\n        for (int i=0; i<m; i++){\\n            vector<int> k;\\n            for (int j=0; j<n; j++){\\n                k.push_back(-1);\\n            }\\n            res.push_back(k);\\n        }\\n        int r1=-1, r2=m, c1=-1, c2=n;\\n        int x=0, y=0;\\n        bool right=true, down=false, left=false;\\n        \\n        while (head){\\n            \\n            res[x][y] = head -> val;\\n            head = head -> next;\\n            \\n            if (right){\\n                if (y+1 == c2){\\n                    x++;\\n                    right = false;\\n                    down = true;\\n                    r1++;\\n                }else{\\n                    y++;\\n                }\\n            }\\n            else if(down){\\n                if (x+1==r2){\\n                    y--;\\n                    down = false;\\n                    left = true;\\n                    c2--;\\n                }else{\\n                    x++;\\n                }\\n            }\\n            else if(left){\\n                if (y-1==c1){\\n                    x--;\\n                    left = false;\\n                    r2--;\\n                }else{\\n                    y--;\\n                }\\n            }\\n            else{\\n                if (x-1==r1){\\n                    y++;\\n                    right = true;\\n                    c1++;\\n                }else{\\n                    x--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/ec5c3001-558f-46ef-8319-b4897070a294_1656827865.452618.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Interactive"
                ],
                "code": "```-1```\n```-1```\n```[x][y]```\n```res[x][y] = head -> val;```\n```bool left, right, down```\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> res;\\n        for (int i=0; i<m; i++){\\n            vector<int> k;\\n            for (int j=0; j<n; j++){\\n                k.push_back(-1);\\n            }\\n            res.push_back(k);\\n        }\\n        int r1=-1, r2=m, c1=-1, c2=n;\\n        int x=0, y=0;\\n        bool right=true, down=false, left=false;\\n        \\n        while (head){\\n            \\n            res[x][y] = head -> val;\\n            head = head -> next;\\n            \\n            if (right){\\n                if (y+1 == c2){\\n                    x++;\\n                    right = false;\\n                    down = true;\\n                    r1++;\\n                }else{\\n                    y++;\\n                }\\n            }\\n            else if(down){\\n                if (x+1==r2){\\n                    y--;\\n                    down = false;\\n                    left = true;\\n                    c2--;\\n                }else{\\n                    x++;\\n                }\\n            }\\n            else if(left){\\n                if (y-1==c1){\\n                    x--;\\n                    left = false;\\n                    r2--;\\n                }else{\\n                    y--;\\n                }\\n            }\\n            else{\\n                if (x-1==r1){\\n                    y++;\\n                    right = true;\\n                    c1++;\\n                }else{\\n                    x--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229969,
                "title": "c-optimal-solution",
                "content": "``` /**\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode *current=head;\\n        vector <vector <int> > ans (m , vector <int> (n,-1)); \\n        vector <vector <bool >> seen (m, vector <bool> (n ,false));\\n        vector <int> dr ={0,1,0,-1};\\n        vector <int> dc ={1,0,-1,0};\\n        int x=0;\\n        int y=0;\\n        int di=0;\\n        int i=0;\\n        for(i=0 ; i < m*n; i++ ){\\n            if(current !=NULL){\\n            ans[x][y]=current->val;\\n            seen[x][y]=true;\\n            int newX=x+dr[di];\\n            int newY=y+dc[di];\\n            if( 0 <= newX && newX < m  && 0 <=newY && newY < n && !seen[newX][newY]){\\n                x=newX;\\n                y=newY;\\n            }\\n            else{\\n                di=(di+1)%4;\\n                x+=dr[di];\\n                y+=dc[di];\\n            }\\n                current=current->next;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Linked List",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode *current=head;\\n        vector <vector <int> > ans (m , vector <int> (n,-1)); \\n        vector <vector <bool >> seen (m, vector <bool> (n ,false));\\n        vector <int> dr ={0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2229879,
                "title": "python-100-explainted-simple-direction-change-use-this-template-for-matrix-chain-1-2-3-4",
                "content": "Step 1 : Fill the matrix with -1\\nStep 2 : Take x=0 and y=0 (start coordinate)\\nStep 3 : Take dx=1 and dy=0 (two more variables for changing x and y)...as we are moving in east initially that\\'s why dx=1 and dy=0.\\nStep 4 : When ever index overflow or value in grid already filled change the direction that is , dx=-dy and dy = dx.\\n\\n\\n**Note: you can use this template in every spiral matrix question**\\n\\n\\tdef spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]: \\n\\t\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)] # Initilize the Grid\\n\\t\\t\\tdx,dy,x,y=1,0,0,0 # change in x , change in y , Initilize X , Initilize Y\\n\\t\\t\\tfor i in range(n*m):\\n\\t\\t\\t\\tif x+dx<0 or x+dx>n-1 or y+dy>m-1 or y+dy<0 or mat[y+dy][x+dx]!=-1:  # Boundary Condition\\n\\t\\t\\t\\t\\tdx,dy=-dy,dx  # Change direction\\n\\t\\t\\t\\t# write the code for adding value to grid (This part will change according to question)\\n\\t\\t\\t\\tx,y=x+dx,y+dy # move Forward\\n\\n\\t\\t\\treturn mat\\n\\t\\t\\t\\n## CODE : \\n\\n\\tdef spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)]\\n\\t\\t\\tdx,dy,x,y=1,0,0,0\\n\\t\\t\\tfor i in range(n*m):\\n\\t\\t\\t\\tif x+dx<0 or x+dx>n-1 or y+dy>m-1 or y+dy<0 or mat[y+dy][x+dx]!=-1:\\n\\t\\t\\t\\t\\tdx,dy=-dy,dx  \\n\\t\\t\\t\\tmat[y][x]=head.val\\n\\t\\t\\t\\tif head.next==None:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thead=head.next\\n\\t\\t\\t\\tx,y=x+dx,y+dy\\n\\n\\t\\t\\treturn mat\\n\\t\\t\\t\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Step 1 : Fill the matrix with -1\\nStep 2 : Take x=0 and y=0 (start coordinate)\\nStep 3 : Take dx=1 and dy=0 (two more variables for changing x and y)...as we are moving in east initially that\\'s why dx=1 and dy=0.\\nStep 4 : When ever index overflow or value in grid already filled change the direction that is , dx=-dy and dy = dx.\\n\\n\\n**Note: you can use this template in every spiral matrix question**\\n\\n\\tdef spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]: \\n\\t\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)] # Initilize the Grid\\n\\t\\t\\tdx,dy,x,y=1,0,0,0 # change in x , change in y , Initilize X , Initilize Y\\n\\t\\t\\tfor i in range(n*m):\\n\\t\\t\\t\\tif x+dx<0 or x+dx>n-1 or y+dy>m-1 or y+dy<0 or mat[y+dy][x+dx]!=-1:  # Boundary Condition\\n\\t\\t\\t\\t\\tdx,dy=-dy,dx  # Change direction\\n\\t\\t\\t\\t# write the code for adding value to grid (This part will change according to question)\\n\\t\\t\\t\\tx,y=x+dx,y+dy # move Forward\\n\\n\\t\\t\\treturn mat\\n\\t\\t\\t\\n## CODE : \\n\\n\\tdef spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)]\\n\\t\\t\\tdx,dy,x,y=1,0,0,0\\n\\t\\t\\tfor i in range(n*m):\\n\\t\\t\\t\\tif x+dx<0 or x+dx>n-1 or y+dy>m-1 or y+dy<0 or mat[y+dy][x+dx]!=-1:\\n\\t\\t\\t\\t\\tdx,dy=-dy,dx  \\n\\t\\t\\t\\tmat[y][x]=head.val\\n\\t\\t\\t\\tif head.next==None:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thead=head.next\\n\\t\\t\\t\\tx,y=x+dx,y+dy\\n\\n\\t\\t\\treturn mat\\n\\t\\t\\t\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2230153,
                "title": "c-easy-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        ListNode* tmp = head;\\n        int t = 0, s = 0;\\n        int b = n-1, a = m-1;\\n        while(1)\\n        {\\n            for(int i=s;i<=a;i++)\\n            {\\n                ans[t][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            t++;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = t;i<=b;i++)\\n            {\\n                ans[i][a] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            a--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = a;i>=s;i--)\\n            {\\n                ans[b][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            b--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = b;i>=t;i--)\\n            {\\n                ans[i][s] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            s++;\\n            if(tmp == NULL)\\n                break;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        ListNode* tmp = head;\\n        int t = 0, s = 0;\\n        int b = n-1, a = m-1;\\n        while(1)\\n        {\\n            for(int i=s;i<=a;i++)\\n            {\\n                ans[t][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2252226,
                "title": "python-10-lines-linear-algebra-t-m-88-89",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: ListNode) -> List[List[int]]:\\n\\n                        # The plan here is to start at cell (0,0) and move in the direction\\n                        # of <0,1>. At each step, we first peek whether we are still in the grid\\n                        # and whether the cell is unvisited (that is, still -1):\\n                        #\\n                        #      \\u2022 If so, we mark the cell with head.val, move head to the next node,\\n                        #        and then peek ahead in the same direction to another cell\\n                        #\\n                        #      \\u2022 If not, we turn right\\n                        #\\n                        # We continue with this process until we hit the end of the linked list.\\n                        # \\n                        # Because we always turn right, we don\\'t need a tuple of directions. From\\n                        # linear algebra, we know that turning right from a current direction\\n                        # <a,b> gives the new direction <b,-a>.\\n        \\n        \\n        ans = [[-1] * n for _ in range(m)]                          # initialize stuff\\n        ans[0][0], head = head.val, head.next\\n        r, c, dr, dc, R, C = 0, 0, 0, 1, range(m), range(n)\\n\\n        while head:\\n            if r+dr in R and c+dc in C and ans[r+dr][c+dc] == -1:   # check whether in grid and whether unvisited\\n                r+= dr ;  c+= dc                                        # if so, assign val and keep going\\n                ans[r][c], head = head.val, head.next\\n            else:                                                       # else, turn right\\n                dr, dc = dc, -dr\\n                \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: ListNode) -> List[List[int]]:\\n\\n                        # The plan here is to start at cell (0,0) and move in the direction\\n                        # of <0,1>. At each step, we first peek whether we are still in the grid\\n                        # and whether the cell is unvisited (that is, still -1):\\n                        #\\n                        #      \\u2022 If so, we mark the cell with head.val, move head to the next node,\\n                        #        and then peek ahead in the same direction to another cell\\n                        #\\n                        #      \\u2022 If not, we turn right\\n                        #\\n                        # We continue with this process until we hit the end of the linked list.\\n                        # \\n                        # Because we always turn right, we don\\'t need a tuple of directions. From\\n                        # linear algebra, we know that turning right from a current direction\\n                        # <a,b> gives the new direction <b,-a>.\\n        \\n        \\n        ans = [[-1] * n for _ in range(m)]                          # initialize stuff\\n        ans[0][0], head = head.val, head.next\\n        r, c, dr, dc, R, C = 0, 0, 0, 1, range(m), range(n)\\n\\n        while head:\\n            if r+dr in R and c+dc in C and ans[r+dr][c+dc] == -1:   # check whether in grid and whether unvisited\\n                r+= dr ;  c+= dc                                        # if so, assign val and keep going\\n                ans[r][c], head = head.val, head.next\\n            else:                                                       # else, turn right\\n                dr, dc = dc, -dr\\n                \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2230428,
                "title": "c-best-approach-easy-tc-o-m-n-sc-o-1",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        \\n        int top=0,down=m-1;\\n        int left=0,right=n-1;\\n        int dir=0,i;\\n        \\n        while(top<=down &&  left<=right && head!=NULL){\\n            if(dir==0){\\n                i=left;\\n                while(head!=NULL && i<=right){\\n                    ans[top][i]=head->val;\\n                    head=head->next;\\n                    i++;\\n                }\\n                top++;\\n            }\\n            else if(dir==1){\\n                i=top;\\n                while(head!=NULL && i<=down){\\n                    ans[i][right]=head->val;\\n                    head=head->next;\\n                    i++;\\n                }\\n                right--;\\n            }\\n            else if(dir==2){\\n                i=right;\\n                while(head!=NULL && i>=left){\\n                    ans[down][i]=head->val;\\n                    head=head->next;\\n                    i--;\\n                }\\n                down--;\\n            }\\n            else if(dir==3){\\n                i=down;\\n                while(head!=NULL && i>=top){\\n                    ans[i][left]=head->val;\\n                    head=head->next;\\n                    i--;\\n                }\\n                left++;\\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        \\n        int top=0,down=m-1;\\n        int left=0,right=n-1;\\n        int dir=0,i;\\n        \\n        while(top<=down &&  left<=right && head!=NULL){\\n            if(dir==0){\\n                i=left;\\n                while(head!=NULL && i<=right){\\n                    ans[top][i]=head->val;\\n                    head=head->next;\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2229846,
                "title": "easy-to-understand-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int i = 0, j = 0;\\n\\t    bool flag=false;\\n        while(i <= (m-1)/2 && j <= (n-1)/2) {\\n            for(int y=j; y<n-j; y++){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[i][y]=head->val;\\n                head=head->next;\\n            }\\n                \\n\\n            for(int x=i+1; x<m-i; x++){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[x][n-1-j]=head->val;\\n                head=head->next;\\n            }\\n                \\n\\n            for(int y=n-1-j-1; y>=j && i!=m-1-i; y--){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[m-1-i][y]=head->val;\\n                head=head->next;\\n                \\n            }\\n                \\n\\n            for(int x=m-1-i-1; x>i && j!=n-1-j; x--){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[x][j]=head->val;\\n                head=head->next;\\n            }\\n                \\n            if(flag)\\n                break;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int i = 0, j = 0;\\n\\t    bool flag=false;\\n        while(i <= (m-1)/2 && j <= (n-1)/2) {\\n            for(int y=j; y<n-j; y++){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[i][y]=head->val;\\n                head=head->next;\\n            }\\n                \\n\\n            for(int x=i+1; x<m-i; x++){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[x][n-1-j]=head->val;\\n                head=head->next;\\n            }\\n                \\n\\n            for(int y=n-1-j-1; y>=j && i!=m-1-i; y--){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[m-1-i][y]=head->val;\\n                head=head->next;\\n                \\n            }\\n                \\n\\n            for(int x=m-1-i-1; x>i && j!=n-1-j; x--){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[x][j]=head->val;\\n                head=head->next;\\n            }\\n                \\n            if(flag)\\n                break;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238487,
                "title": "javascript-very-easy-to-understand-o-n-solution",
                "content": "```\\n\\n var spiralMatrix = function(m, n, head) {\\n    var matrix = new Array(m).fill().map(()=> new Array(n).fill(-1))\\n    var row=0, col=0;\\n    var direction=\"right\";\\n    while(head)\\n        {\\n            matrix[row][col]=head.val;\\n            if(direction==\"right\")\\n                {\\n                    if(col+1 == n || matrix[row][col+1] != -1)\\n                        {\\n                            direction=\"down\"\\n                            row++;\\n                        }\\n                    else\\n                        col++\\n                }\\n            else if(direction==\"down\")\\n                {\\n                    if(row+1 == m || matrix[row+1][col] != -1)\\n                        {\\n                            direction=\"left\"\\n                            col--;\\n                        }\\n                    else\\n                        row++\\n                }\\n            else if(direction==\"left\")\\n                {\\n                    if(col == 0 || matrix[row][col-1] != -1)\\n                        {\\n                            direction=\"up\"\\n                            row--;\\n                        }\\n                    else\\n                        col--\\n                }\\n            else if(direction==\"up\")\\n                {\\n                    if(row == 0 || matrix[row-1][col] != -1)\\n                        {\\n                            direction=\"right\"\\n                            col++;\\n                        }\\n                    else\\n                        row--\\n                }\\n            head = head.next;\\n        }\\n    return matrix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n var spiralMatrix = function(m, n, head) {\\n    var matrix = new Array(m).fill().map(()=> new Array(n).fill(-1))\\n    var row=0, col=0;\\n    var direction=\"right\";\\n    while(head)\\n        {\\n            matrix[row][col]=head.val;\\n            if(direction==\"right\")\\n                {\\n                    if(col+1 == n || matrix[row][col+1] != -1)\\n                        {\\n                            direction=\"down\"\\n                            row++;\\n                        }\\n                    else\\n                        col++\\n                }\\n            else if(direction==\"down\")\\n                {\\n                    if(row+1 == m || matrix[row+1][col] != -1)\\n                        {\\n                            direction=\"left\"\\n                            col--;\\n                        }\\n                    else\\n                        row++\\n                }\\n            else if(direction==\"left\")\\n                {\\n                    if(col == 0 || matrix[row][col-1] != -1)\\n                        {\\n                            direction=\"up\"\\n                            row--;\\n                        }\\n                    else\\n                        col--\\n                }\\n            else if(direction==\"up\")\\n                {\\n                    if(row == 0 || matrix[row-1][col] != -1)\\n                        {\\n                            direction=\"right\"\\n                            col++;\\n                        }\\n                    else\\n                        row--\\n                }\\n            head = head.next;\\n        }\\n    return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230791,
                "title": "java-simple-solution-o-m-n",
                "content": "```\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] result = new int[m][n];\\n        int top =0;\\n        int bottom = m-1;\\n        int left =0; \\n        int right = n-1;\\n        int len = m*n;\\n        int count =0;\\n        int val=0;\\n        while(count<len){\\n            //Top\\n            for(int i = left; i<=right && count<len; i++){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[top][i] = val;\\n                count++;\\n            }\\n            top++;\\n            // right\\n            for(int i = top; i<=bottom && count<len; i++){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[i][right] = val;\\n                count++;\\n            }\\n            right--;\\n            // bottom\\n            for(int i = right; i>=left && count<len; i--){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[bottom][i] = val;\\n                count++;\\n            }\\n            bottom--;\\n           // left\\n            for(int i = bottom; i>=top && count<len; i--){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[i][left] = val;\\n                count++;\\n            }\\n            left++;            \\n        }\\n        \\n        return result;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] result = new int[m][n];\\n        int top =0;\\n        int bottom = m-1;\\n        int left =0; \\n        int right = n-1;\\n        int len = m*n;\\n        int count =0;\\n        int val=0;\\n        while(count<len){\\n            //Top\\n            for(int i = left; i<=right && count<len; i++){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[top][i] = val;\\n                count++;\\n            }\\n            top++;\\n            // right\\n            for(int i = top; i<=bottom && count<len; i++){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[i][right] = val;\\n                count++;\\n            }\\n            right--;\\n            // bottom\\n            for(int i = right; i>=left && count<len; i--){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[bottom][i] = val;\\n                count++;\\n            }\\n            bottom--;\\n           // left\\n            for(int i = bottom; i>=top && count<len; i--){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[i][left] = val;\\n                count++;\\n            }\\n            left++;            \\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230456,
                "title": "easy-java-solution-well-commented",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) \\n    {\\n        int[][] matrix = new int[m][n];\\n        \\n        //Initialize the matrix with -1\\n        //After linked list is completed, rest matrix cells will be -1\\n        for(int[] row : matrix)\\n            Arrays.fill(row , -1);\\n        \\n        //Base/Edge case\\n        if(head == null)\\n            return matrix;\\n        \\n        \\n        int rowBegin = 0;\\n        int rowEnd = matrix.length-1;\\n        int colBegin = 0;\\n        int colEnd = matrix[0].length - 1;\\n        \\n        ListNode current = head;\\n        \\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            \\n            // Traverse Right\\n            for (int j = colBegin; j <= colEnd; j ++) {\\n                //If we have linked list node values, then only fill it in matrix cell else do nothing\\n                if(current != null){                            \\n                    matrix[rowBegin][j] = current.val;\\n                    current = current.next;\\n                }\\n            }\\n            rowBegin++;\\n            \\n            // Traverse Down\\n            for (int j = rowBegin; j <= rowEnd; j ++) {\\n                if(current != null){\\n                    matrix[j][colEnd] = current.val;\\n                    current = current.next;\\n                }\\n            }\\n            colEnd--;\\n            \\n            if (rowBegin <= rowEnd) {\\n                // Traverse Left\\n                for (int j = colEnd; j >= colBegin; j --) {\\n                    if(current != null){\\n                        matrix[rowEnd][j] = current.val;\\n                        current = current.next;\\n                    }\\n                }\\n            }\\n            rowEnd--;\\n            \\n            if (colBegin <= colEnd) {\\n                // Traver Up\\n                for (int j = rowEnd; j >= rowBegin; j --) {\\n                    if(current != null){\\n                        matrix[j][colBegin] = current.val;\\n                        current = current.next;\\n                    }\\n                }\\n            }\\n            colBegin ++;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) \\n    {\\n        int[][] matrix = new int[m][n];\\n        \\n        //Initialize the matrix with -1\\n        //After linked list is completed, rest matrix cells will be -1\\n        for(int[] row : matrix)\\n            Arrays.fill(row , -1);\\n        \\n        //Base/Edge case\\n        if(head == null)\\n            return matrix;\\n        \\n        \\n        int rowBegin = 0;\\n        int rowEnd = matrix.length-1;\\n        int colBegin = 0;\\n        int colEnd = matrix[0].length - 1;\\n        \\n        ListNode current = head;\\n        \\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            \\n            // Traverse Right\\n            for (int j = colBegin; j <= colEnd; j ++) {\\n                //If we have linked list node values, then only fill it in matrix cell else do nothing\\n                if(current != null){                            \\n                    matrix[rowBegin][j] = current.val;\\n                    current = current.next;\\n                }\\n            }\\n            rowBegin++;\\n            \\n            // Traverse Down\\n            for (int j = rowBegin; j <= rowEnd; j ++) {\\n                if(current != null){\\n                    matrix[j][colEnd] = current.val;\\n                    current = current.next;\\n                }\\n            }\\n            colEnd--;\\n            \\n            if (rowBegin <= rowEnd) {\\n                // Traverse Left\\n                for (int j = colEnd; j >= colBegin; j --) {\\n                    if(current != null){\\n                        matrix[rowEnd][j] = current.val;\\n                        current = current.next;\\n                    }\\n                }\\n            }\\n            rowEnd--;\\n            \\n            if (colBegin <= colEnd) {\\n                // Traver Up\\n                for (int j = rowEnd; j >= rowBegin; j --) {\\n                    if(current != null){\\n                        matrix[j][colBegin] = current.val;\\n                        current = current.next;\\n                    }\\n                }\\n            }\\n            colBegin ++;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230251,
                "title": "python-easy-solution-using-direction-variable",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        \\n        matrix = [[-1]*n for i in range(m)]\\n        \\n        current = head\\n        direction = 1\\n        i, j = 0, -1\\n        \\n        while current:\\n            for _ in range(n):\\n                if current:\\n                    j += direction\\n                    matrix[i][j] = current.val\\n                    current = current.next\\n                    \\n            m -= 1\\n            \\n            for _ in range(m):\\n                if current:\\n                    i += direction\\n                    matrix[i][j] = current.val\\n                    current = current.next\\n            n -= 1\\n            \\n            direction *= -1\\n        \\n        return matrix",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        \\n        matrix = [[-1]*n for i in range(m)]\\n        \\n        current = head\\n        direction = 1\\n        i, j = 0, -1\\n        \\n        while current:\\n            for _ in range(n):\\n                if current:\\n                    j += direction\\n                    matrix[i][j] = current.val\\n                    current = current.next\\n                    \\n            m -= 1\\n            \\n            for _ in range(m):\\n                if current:\\n                    i += direction\\n                    matrix[i][j] = current.val\\n                    current = current.next\\n            n -= 1\\n            \\n            direction *= -1\\n        \\n        return matrix",
                "codeTag": "Java"
            },
            {
                "id": 2229907,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>v(m,vector<int>(n,-1));\\n         int row = 0,col = 0;\\n        int rf = m-1, cf = n-1;\\n         while(head && row<=rf && col<=cf)\\n        {\\n            if(row<=rf)\\n            {\\n                for(int i = col;i<=cf && head;i++)\\n                {\\n                 \\n                    v[row][i] = head->val;\\n                    head = head->next;\\n                    \\n                }\\n                row++;\\n            }\\n            if(col<=cf)\\n            {\\n                for(int i = row;i<=rf && head;i++)\\n                {\\n                   \\n                    v[i][cf] = head->val;\\n                    head = head->next;\\n                }\\n                cf--;\\n            }\\n            if(row<=rf)\\n            {\\n                for(int i = cf;i>=col && head;i--)\\n                {\\n                    \\n                    v[rf][i] = head->val;\\n                    head = head->next;\\n                    \\n                }\\n                rf--;\\n            }\\n            if(col<=cf)\\n            {\\n                for(int i = rf;i>=row && head;i--)\\n                {\\n                   \\n                    v[i][col] = head->val;\\n                    head = head->next;\\n                }\\n                col++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>v(m,vector<int>(n,-1));\\n         int row = 0,col = 0;\\n        int rf = m-1, cf = n-1;\\n         while(head && row<=rf && col<=cf)\\n        {\\n            if(row<=rf)\\n            {\\n                for(int i = col;i<=cf && head;i++)\\n                {\\n                 \\n                    v[row][i] = head->val;\\n                    head = head->next;\\n                    \\n                }\\n                row++;\\n            }\\n            if(col<=cf)\\n            {\\n                for(int i = row;i<=rf && head;i++)\\n                {\\n                   \\n                    v[i][cf] = head->val;\\n                    head = head->next;\\n                }\\n                cf--;\\n            }\\n            if(row<=rf)\\n            {\\n                for(int i = cf;i>=col && head;i--)\\n                {\\n                    \\n                    v[rf][i] = head->val;\\n                    head = head->next;\\n                    \\n                }\\n                rf--;\\n            }\\n            if(col<=cf)\\n            {\\n                for(int i = rf;i>=row && head;i--)\\n                {\\n                   \\n                    v[i][col] = head->val;\\n                    head = head->next;\\n                }\\n                col++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229892,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<int> val;\\n        int len=0;\\n        while(head!=NULL)\\n        {\\n            val.push_back(head->val);\\n            head=head->next;\\n            len++;\\n        }\\n        int left=m*n-len;\\n        while(left--)\\n        {\\n            val.push_back(-1);\\n        }\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        int z=val.size();\\n        \\n        int uprow=0,downrow=m-1;\\n        int leftcol=0,rightcol=n-1;\\n        int c=0;\\n        while(c!=z)\\n        {\\n            \\n            for(int i=leftcol;i<=rightcol;i++)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[uprow][i]=val[c++];\\n            }\\n            uprow++;\\n            for(int j=uprow;j<=downrow;j++)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[j][rightcol]=val[c++];\\n            }\\n            rightcol--;\\n            for(int i=rightcol;i>=leftcol;i--)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[downrow][i]=val[c++];\\n            }\\n            downrow--;\\n            for(int i=downrow;i>=uprow;i--)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[i][leftcol]=val[c++];\\n            }\\n            leftcol++;\\n            if(c==z)\\n                {\\n                    break;\\n                }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<int> val;\\n        int len=0;\\n        while(head!=NULL)\\n        {\\n            val.push_back(head->val);\\n            head=head->next;\\n            len++;\\n        }\\n        int left=m*n-len;\\n        while(left--)\\n        {\\n            val.push_back(-1);\\n        }\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        int z=val.size();\\n        \\n        int uprow=0,downrow=m-1;\\n        int leftcol=0,rightcol=n-1;\\n        int c=0;\\n        while(c!=z)\\n        {\\n            \\n            for(int i=leftcol;i<=rightcol;i++)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[uprow][i]=val[c++];\\n            }\\n            uprow++;\\n            for(int j=uprow;j<=downrow;j++)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[j][rightcol]=val[c++];\\n            }\\n            rightcol--;\\n            for(int i=rightcol;i>=leftcol;i--)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[downrow][i]=val[c++];\\n            }\\n            downrow--;\\n            for(int i=downrow;i>=uprow;i--)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[i][leftcol]=val[c++];\\n            }\\n            leftcol++;\\n            if(c==z)\\n                {\\n                    break;\\n                }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762430,
                "title": "two-approaches-easy-to-understand-simple",
                "content": "\\n\\n# ***FIRST APPROACH***\\n\\n  \\n    class Solution {\\n    public:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>vect(m,vector<int>(n,-1));\\n        int cnt=0,tot=m*n;\\n        int rs=0,re=m-1,cs=0,ce=n-1;\\n        while(head!=NULL and cnt<tot){\\n            for(int i=cs;cnt<tot and head!=NULL and i<=ce;i++){\\n                vect[rs][i]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }\\n            rs++;\\n            for(int i=rs;cnt<tot and head!=NULL and i<=re;i++){\\n                vect[i][ce]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }\\n            ce--;\\n            for(int i=ce;cnt<tot and head!=NULL and i>=cs;i--){\\n                vect[re][i]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }\\n            re--;\\n            for(int i=re;cnt<tot and head!=NULL and i>=rs;i--){\\n                vect[i][cs]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }\\n            cs++;\\n        }\\n        return vect;\\n       }\\n    };\\n\\t\\n\\t\\n# ***SECOND APPROACH***\\n\\n    class Solution {\\n    public:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* y=head;\\n        //y->next=head;\\n        int cnt=0;\\n        while(y){\\n            y=y->next;\\n            cnt++;\\n        }\\n        vector<vector<int>>matrix(m,vector<int>(n,-1));\\n        int k=1;\\n        int rwst=0,rwed=m-1,clst=0,cled=n-1;\\n        int count=0,total=m*n;\\n        while(count<cnt){\\n            for(int i=clst;count<cnt && i<=cled;i++){\\n                matrix[rwst][i]=head->val;\\n                head=head->next;\\n                count++;\\n            }\\n            rwst++;\\n            for(int i=rwst;count<cnt && i<=rwed;i++){\\n                matrix[i][cled]=head->val;\\n                head=head->next;\\n                count++;\\n            }\\n            cled--;\\n            for(int i=cled;count<cnt && i>=clst;i--){\\n                matrix[rwed][i]=head->val;\\n                head=head->next;\\n                count++;\\n            }\\n            rwed--;\\n            for(int i=rwed;count<cnt && i>=rwst;i--){\\n                matrix[i][clst]=head->val;\\n                head=head->next;\\n                count++;\\n            }\\n            clst++;\\n        }\\n        return matrix;\\n      }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>vect(m,vector<int>(n,-1));\\n        int cnt=0,tot=m*n;\\n        int rs=0,re=m-1,cs=0,ce=n-1;\\n        while(head!=NULL and cnt<tot){\\n            for(int i=cs;cnt<tot and head!=NULL and i<=ce;i++){\\n                vect[rs][i]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3684885,
                "title": "easy-solution-with-full-approach-explanation",
                "content": "# Intuition\\nwe need to know how to iterate vector and iteration of linked list at a time .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to go in this order\\n right->down->left->up\\nuntill you reach to end of linked list you need to traverse\\nright:\\n -> first start at 0,0 index go through the ith and when your j value is greater than n  or your v[i][j]!=-1 stop iterating that row \\n->increament i by one and decrement j by 1\\ndown:\\n    ->start at previous indices of i and j, whne your i>=m or v[i][j]!=-1   stop iterating that colomn \\n-> decreament i and j by 1\\n\\nleft:\\n    ->start i and j th indices , iterate untill your j<0 or v[i][j]!=-1\\n-> decrement i by 1 to move upper row\\n->  increament j by 1 to move back colomn\\n\\nup:\\n-> iterate untill your i<0 or v[i][j]!=-1\\n->increase i by one to get lower row and increase j by 1 to get front column \\n\\nthis loop iterates untill you reach to end of linked list\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(size of list)\\n\\n- Space complexity:\\n- m x n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        int i=0,j=0;\\n\\tint l=0,r=0,d=0,u=0;\\n\\tListNode *t=head;\\n\\twhile(t!=NULL){\\n\\t\\tif(t!=NULL){\\n\\t\\t\\twhile(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i][j++]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj--;\\n            i++;\\n\\t\\t}\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i++][j]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\ti--;\\n            j--;\\n        }\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i][j--]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n            i--;\\n        }\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i--][j]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n            i++;\\n        }\\n\\t}\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\nwe need to know how to iterate vector and iteration of linked list at a time .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to go in this order\\n right->down->left->up\\nuntill you reach to end of linked list you need to traverse\\nright:\\n -> first start at 0,0 index go through the ith and when your j value is greater than n  or your v[i][j]!=-1 stop iterating that row \\n->increament i by one and decrement j by 1\\ndown:\\n    ->start at previous indices of i and j, whne your i>=m or v[i][j]!=-1   stop iterating that colomn \\n-> decreament i and j by 1\\n\\nleft:\\n    ->start i and j th indices , iterate untill your j<0 or v[i][j]!=-1\\n-> decrement i by 1 to move upper row\\n->  increament j by 1 to move back colomn\\n\\nup:\\n-> iterate untill your i<0 or v[i][j]!=-1\\n->increase i by one to get lower row and increase j by 1 to get front column \\n\\nthis loop iterates untill you reach to end of linked list\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(size of list)\\n\\n- Space complexity:\\n- m x n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        int i=0,j=0;\\n\\tint l=0,r=0,d=0,u=0;\\n\\tListNode *t=head;\\n\\twhile(t!=NULL){\\n\\t\\tif(t!=NULL){\\n\\t\\t\\twhile(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i][j++]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj--;\\n            i++;\\n\\t\\t}\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i++][j]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\ti--;\\n            j--;\\n        }\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i][j--]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n            i--;\\n        }\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i--][j]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n            i++;\\n        }\\n\\t}\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505952,
                "title": "java-easy-solution-beats-98-solution-easy-to-understand",
                "content": "\\n# Approach\\n* Fill the required array with -1.\\n* Now Traverse the linkedlist and fill the required array in spiral order.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\nwhere m=number of rows\\n      n=number of columns\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\n        int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }\\n\\n        while(head != null){\\n\\n            for(int i=row;head != null && i<=ncol;i++)\\n            {\\n                arr[row][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            row+=1;\\n\\n            for(int i=row;head != null && i<=nrow;i++)\\n            {\\n                arr[i][ncol]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            ncol-=1;\\n\\n            for(int i=ncol;head != null && i>=col;i--){\\n                arr[nrow][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            nrow-=1;\\n\\n            for(int i=nrow;head != null && i>=row;i--){\\n                arr[i][col]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            col+=1;\\n\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\n        int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }\\n\\n        while(head != null){\\n\\n            for(int i=row;head != null && i<=ncol;i++)\\n            {\\n                arr[row][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            row+=1;\\n\\n            for(int i=row;head != null && i<=nrow;i++)\\n            {\\n                arr[i][ncol]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            ncol-=1;\\n\\n            for(int i=ncol;head != null && i>=col;i--){\\n                arr[nrow][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            nrow-=1;\\n\\n            for(int i=nrow;head != null && i>=row;i--){\\n                arr[i][col]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            col+=1;\\n\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481154,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m , vector<int> (n,-1));\\n\\n        int t = 0, d = m-1, l = 0 , r = n-1;\\n\\n        while(head != NULL && t <= d && l <= r){\\n            // cout << t << \" \" << d << \" \" << l << \" \" << r << endl;\\n            for(int i=l;i<=r && head != NULL;i++){\\n                ans[t][i] = head -> val;\\n                // cout << ans[t][i] << endl;\\n                head = head -> next;\\n            }\\n            \\n            t++;\\n            for(int i=t;i<=d && head != NULL;i++){\\n                ans[i][r] = head -> val;\\n                // cout <<  ans[i][r] << endl;\\n\\n                head = head -> next;\\n            }\\n            r--;\\n            for(int i=r;i>=l && head != NULL;i--){\\n                ans[d][i] = head -> val;\\n                // cout <<   ans[d][i] << endl;\\n\\n                head = head -> next;\\n            }\\n            d--;\\n            for(int i=d;i>=t && head != NULL;i--){\\n                ans[i][l] = head -> val;\\n                // cout <<  ans[i][l] << endl;\\n                head = head -> next;\\n            }\\n            l++;\\n            // cout << head -> val << endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m , vector<int> (n,-1));\\n\\n        int t = 0, d = m-1, l = 0 , r = n-1;\\n\\n        while(head != NULL && t <= d && l <= r){\\n            // cout << t << \" \" << d << \" \" << l << \" \" << r << endl;\\n            for(int i=l;i<=r && head != NULL;i++){\\n                ans[t][i] = head -> val;\\n                // cout << ans[t][i] << endl;\\n                head = head -> next;\\n            }\\n            \\n            t++;\\n            for(int i=t;i<=d && head != NULL;i++){\\n                ans[i][r] = head -> val;\\n                // cout <<  ans[i][r] << endl;\\n\\n                head = head -> next;\\n            }\\n            r--;\\n            for(int i=r;i>=l && head != NULL;i--){\\n                ans[d][i] = head -> val;\\n                // cout <<   ans[d][i] << endl;\\n\\n                head = head -> next;\\n            }\\n            d--;\\n            for(int i=d;i>=t && head != NULL;i--){\\n                ans[i][l] = head -> val;\\n                // cout <<  ans[i][l] << endl;\\n                head = head -> next;\\n            }\\n            l++;\\n            // cout << head -> val << endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3390439,
                "title": "easy-clean-o-m-n-java-solution",
                "content": "\\n```java []\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        for(int[] row: arr)   Arrays.fill(row,-1);\\n        int top = 0, left = 0, right = n-1, bottom = m-1;\\n        while(head != null){\\n            for(int i=left; i<=right && head != null; i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }\\n            top++;\\n            for(int i=top; i<=bottom && head != null; i++){\\n                arr[i][right] = head.val;\\n                head = head.next;\\n            }\\n            right--;\\n            for(int i=right; i>=left && head != null; i--){\\n                arr[bottom][i] = head.val;\\n                head = head.next;\\n            }\\n            bottom--;\\n            for(int i=bottom; i>=top && head != null; i--){\\n                arr[i][left] = head.val;\\n                head = head.next;\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        for(int[] row: arr)   Arrays.fill(row,-1);\\n        int top = 0, left = 0, right = n-1, bottom = m-1;\\n        while(head != null){\\n            for(int i=left; i<=right && head != null; i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }\\n            top++;\\n            for(int i=top; i<=bottom && head != null; i++){\\n                arr[i][right] = head.val;\\n                head = head.next;\\n            }\\n            right--;\\n            for(int i=right; i>=left && head != null; i--){\\n                arr[bottom][i] = head.val;\\n                head = head.next;\\n            }\\n            bottom--;\\n            for(int i=bottom; i>=top && head != null; i--){\\n                arr[i][left] = head.val;\\n                head = head.next;\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354902,
                "title": "one-way-approach-using-spiral-matrix-traversal-technique",
                "content": "\\n# Approach\\nFirst of all i created a 2-D matrix of size n*m . Then use spiral Matrix Traversal technique and assign the cur head value at each cell.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix=[[-1 for _ in range(n)]for _ in range(m)]\\n        top,left=0,0\\n        down,right=len(matrix)-1,len(matrix[0])-1\\n        direction=0\\n        cur=head\\n        while top<=down and left<=right:\\n            if direction==0:\\n                for i in range(left,right+1):\\n                    if cur :\\n                        matrix[top][i]=cur.val\\n                        cur=cur.next\\n                       \\n                top+=1\\n            elif direction==1:\\n                \\n                for i in range(top,down+1):\\n                    if cur:\\n                        matrix[i][right]=cur.val\\n                        cur=cur.next\\n                       \\n                right-=1\\n            elif direction==2:\\n               \\n                for i in range(right,left-1,-1):\\n                    if cur:\\n                        matrix[down][i]=cur.val\\n                        cur=cur.next\\n                        \\n                down-=1\\n            elif direction==3:\\n                \\n                for i in range(down,top-1,-1):\\n                    if cur:\\n                        matrix[i][left]=cur.val\\n                        cur=cur.next\\n                        \\n                left+=1\\n            direction=(direction+1)%4\\n        return matrix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix=[[-1 for _ in range(n)]for _ in range(m)]\\n        top,left=0,0\\n        down,right=len(matrix)-1,len(matrix[0])-1\\n        direction=0\\n        cur=head\\n        while top<=down and left<=right:\\n            if direction==0:\\n                for i in range(left,right+1):\\n                    if cur :\\n                        matrix[top][i]=cur.val\\n                        cur=cur.next\\n                       \\n                top+=1\\n            elif direction==1:\\n                \\n                for i in range(top,down+1):\\n                    if cur:\\n                        matrix[i][right]=cur.val\\n                        cur=cur.next\\n                       \\n                right-=1\\n            elif direction==2:\\n               \\n                for i in range(right,left-1,-1):\\n                    if cur:\\n                        matrix[down][i]=cur.val\\n                        cur=cur.next\\n                        \\n                down-=1\\n            elif direction==3:\\n                \\n                for i in range(down,top-1,-1):\\n                    if cur:\\n                        matrix[i][left]=cur.val\\n                        cur=cur.next\\n                        \\n                left+=1\\n            direction=(direction+1)%4\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308924,
                "title": "copy-paste-spiral-matrix-2-solution-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode curr = head;\\n        int startRow = 0;\\n        int endRow = m - 1;\\n        int startCol = 0;\\n        int endCol = n - 1;\\n        int [][] arr = new int[m][n];\\n        while(startCol <= endCol && startRow <= endRow){\\n            //top\\n            for(int i = startCol; i <= endCol; i++){\\n                if(curr == null)\\n                    arr[startRow][i] = -1;\\n                else{\\n                    arr[startRow][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //right\\n            for(int i = startRow + 1; i <= endRow; i++){\\n                if(curr == null)\\n                    arr[i][endCol] = -1;\\n                else{\\n                    arr[i][endCol] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //bottom\\n            for(int i = endCol - 1; i >= startCol; i--){\\n                if(startRow == endRow)\\n                    break;\\n                if(curr == null)\\n                    arr[endRow][i] = -1;\\n                else{\\n                    arr[endRow][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //left\\n            for(int i = endRow - 1; i >= startCol + 1; i--){\\n                if(startCol == endCol)\\n                    break;\\n                if(curr == null)\\n                    arr[i][startCol] = -1;\\n                else{\\n                    arr[i][startCol] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            startCol++;\\n            startRow++;\\n            endCol--;\\n            endRow--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode curr = head;\\n        int startRow = 0;\\n        int endRow = m - 1;\\n        int startCol = 0;\\n        int endCol = n - 1;\\n        int [][] arr = new int[m][n];\\n        while(startCol <= endCol && startRow <= endRow){\\n            //top\\n            for(int i = startCol; i <= endCol; i++){\\n                if(curr == null)\\n                    arr[startRow][i] = -1;\\n                else{\\n                    arr[startRow][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //right\\n            for(int i = startRow + 1; i <= endRow; i++){\\n                if(curr == null)\\n                    arr[i][endCol] = -1;\\n                else{\\n                    arr[i][endCol] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //bottom\\n            for(int i = endCol - 1; i >= startCol; i--){\\n                if(startRow == endRow)\\n                    break;\\n                if(curr == null)\\n                    arr[endRow][i] = -1;\\n                else{\\n                    arr[endRow][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //left\\n            for(int i = endRow - 1; i >= startCol + 1; i--){\\n                if(startCol == endCol)\\n                    break;\\n                if(curr == null)\\n                    arr[i][startCol] = -1;\\n                else{\\n                    arr[i][startCol] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            startCol++;\\n            startRow++;\\n            endCol--;\\n            endRow--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164917,
                "title": "beginner-friendly-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfollow up direction : right -> down -> left -> up\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreating a matrix m*n fillup with -1 and traverse throgh list and make update directions according to current directions and values of before cells\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N) (no of Nodes in linkedlist)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N+M)\\n\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)] for i in range(m)]\\n        temp=head\\n        d=1\\n        rowi,colj=0,0\\n        while temp!=None:\\n            mat[rowi][colj]=temp.val\\n            if d==1:\\n                if colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n            elif d==2:\\n                if rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n            elif d==3:\\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n            elif d==4:\\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n                elif colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n            temp=temp.next\\n        return mat\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)] for i in range(m)]\\n        temp=head\\n        d=1\\n        rowi,colj=0,0\\n        while temp!=None:\\n            mat[rowi][colj]=temp.val\\n            if d==1:\\n                if colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n            elif d==2:\\n                if rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n            elif d==3:\\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n            elif d==4:\\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n                elif colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n            temp=temp.next\\n        return mat\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077044,
                "title": "easy-approach-o-length-time-beats-others",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>mat(m,vector<int>(n,-1));\\n        ListNode*curr=head;\\n        int top=0,right=n-1,bottom=m-1,left=0;\\n        while(top<=bottom && left<=right && curr){\\n            for(int i=left;i<=right;i++){\\n                if(curr){\\n                    mat[top][i]=curr->val;\\n                    curr=curr->next;\\n                }else{\\n                    break;\\n                }\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                if(curr){\\n                    mat[i][right]=curr->val;\\n                    curr=curr->next;\\n                }else{\\n                    break;\\n                }\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){\\n                    if(curr){\\n                        mat[bottom][i]=curr->val;\\n                        curr=curr->next;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){\\n                    if(curr){\\n                        mat[i][left]=curr->val;\\n                        curr=curr->next;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                left++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>mat(m,vector<int>(n,-1));\\n        ListNode*curr=head;\\n        int top=0,right=n-1,bottom=m-1,left=0;\\n        while(top<=bottom && left<=right && curr){\\n            for(int i=left;i<=right;i++){\\n                if(curr){\\n                    mat[top][i]=curr->val;\\n                    curr=curr->next;\\n                }else{\\n                    break;\\n                }\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                if(curr){\\n                    mat[i][right]=curr->val;\\n                    curr=curr->next;\\n                }else{\\n                    break;\\n                }\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){\\n                    if(curr){\\n                        mat[bottom][i]=curr->val;\\n                        curr=curr->next;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){\\n                    if(curr){\\n                        mat[i][left]=curr->val;\\n                        curr=curr->next;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                left++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029531,
                "title": "c-beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int top = 0, left = 0, right = n - 1, down = m - 1;\\n        int dir = 0;\\n        vector<vector<int>> answer(m, vector<int>(n, -1));\\n        while(top <= down && left <= right && head) {\\n            if(dir == 0) {\\n                for(int col = top; col <= right; col++) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[top][col] = val;\\n                    head = head -> next;\\n                }\\n                top++;\\n            }else if(dir == 1) {\\n                for(int row = top; row <= down; row++) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[row][right] = val;\\n                    head = head -> next;\\n                }\\n                right--;\\n            }else if(dir == 2) {\\n                for(int col = right; col >= left; col--) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[down][col] = val;\\n                    head = head -> next;\\n                }\\n                down--;\\n            }else {\\n                for(int row = down; row >= top; row--) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[row][left] = val;\\n                    head = head -> next;\\n                }\\n                left++;\\n            }\\n            dir = (++dir) % 4;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int top = 0, left = 0, right = n - 1, down = m - 1;\\n        int dir = 0;\\n        vector<vector<int>> answer(m, vector<int>(n, -1));\\n        while(top <= down && left <= right && head) {\\n            if(dir == 0) {\\n                for(int col = top; col <= right; col++) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[top][col] = val;\\n                    head = head -> next;\\n                }\\n                top++;\\n            }else if(dir == 1) {\\n                for(int row = top; row <= down; row++) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[row][right] = val;\\n                    head = head -> next;\\n                }\\n                right--;\\n            }else if(dir == 2) {\\n                for(int col = right; col >= left; col--) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[down][col] = val;\\n                    head = head -> next;\\n                }\\n                down--;\\n            }else {\\n                for(int row = down; row >= top; row--) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[row][left] = val;\\n                    head = head -> next;\\n                }\\n                left++;\\n            }\\n            dir = (++dir) % 4;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872005,
                "title": "elegant-cpp-solution-with-no-if-statements",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnum_x, num_y denote the total numbers that can be filled while moving horizontally or vertically in a given row or column.\\n\\n# Complexity\\n- Time complexity: O(N) where N = mn;\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) for creating the spiral matrix;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m, vector<int>(n, -1));\\n        int i=0, j=-1, num_x=m, num_y=n, counter;\\n\\n        while(head){\\n            //left\\n            counter=num_y;\\n            while(head && counter--){\\n                mat[i][++j]=head->val;\\n                head = head->next;\\n            }\\n            num_x--;\\n\\n            //down\\n            counter=num_x;\\n            while(head && counter--){\\n                mat[++i][j]=head->val;\\n                head = head->next;\\n            }\\n            num_y--;\\n\\n            //right\\n            counter=num_y;\\n            while(head && counter--){\\n                mat[i][--j]=head->val;\\n                head = head->next;\\n            }\\n            num_x--;\\n\\n            //up\\n            counter=num_x;\\n            while(head && counter--){\\n                mat[--i][j]=head->val;\\n                head = head->next;\\n            }\\n            num_y--;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m, vector<int>(n, -1));\\n        int i=0, j=-1, num_x=m, num_y=n, counter;\\n\\n        while(head){\\n            //left\\n            counter=num_y;\\n            while(head && counter--){\\n                mat[i][++j]=head->val;\\n                head = head->next;\\n            }\\n            num_x--;\\n\\n            //down\\n            counter=num_x;\\n            while(head && counter--){\\n                mat[++i][j]=head->val;\\n                head = head->next;\\n            }\\n            num_y--;\\n\\n            //right\\n            counter=num_y;\\n            while(head && counter--){\\n                mat[i][--j]=head->val;\\n                head = head->next;\\n            }\\n            num_x--;\\n\\n            //up\\n            counter=num_x;\\n            while(head && counter--){\\n                mat[--i][j]=head->val;\\n                head = head->next;\\n            }\\n            num_y--;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545816,
                "title": "java-easy-understanding-7ms-99-7-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] res =new int[m][n];\\n        for(int[] i:res){\\n            Arrays.fill(i,-1);\\n        }\\n\\n        int top=0;\\n        int right =res[0].length -1;\\n        int bottom =res.length-1;\\n        int left =0;\\n        ListNode curr=head;\\n        \\n        while(curr!=null){\\n            //top= left to right\\n            for(int i=left;i<=right && curr!=null;i++){\\n                res[top][i]=curr.val;\\n                curr=curr.next;\\n            }\\n            top++;\\n            //right= top to bottom\\n            for(int i=top;i<=bottom && curr!=null;i++){\\n                res[i][right]=curr.val;\\n                curr=curr.next;\\n            }\\n            right--;\\n            //bottom= right to left \\n            for(int i=right;i>=left && curr!=null;i--){\\n                res[bottom][i]=curr.val;\\n                curr=curr.next;\\n            }\\n            bottom--;\\n            //left=bottom to top\\n            for(int i=bottom;i>=top && curr!=null;i--){\\n                res[i][left]=curr.val;\\n                curr=curr.next;\\n            }\\n            left++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] res =new int[m][n];\\n        for(int[] i:res){\\n            Arrays.fill(i,-1);\\n        }\\n\\n        int top=0;\\n        int right =res[0].length -1;\\n        int bottom =res.length-1;\\n        int left =0;\\n        ListNode curr=head;\\n        \\n        while(curr!=null){\\n            //top= left to right\\n            for(int i=left;i<=right && curr!=null;i++){\\n                res[top][i]=curr.val;\\n                curr=curr.next;\\n            }\\n            top++;\\n            //right= top to bottom\\n            for(int i=top;i<=bottom && curr!=null;i++){\\n                res[i][right]=curr.val;\\n                curr=curr.next;\\n            }\\n            right--;\\n            //bottom= right to left \\n            for(int i=right;i>=left && curr!=null;i--){\\n                res[bottom][i]=curr.val;\\n                curr=curr.next;\\n            }\\n            bottom--;\\n            //left=bottom to top\\n            for(int i=bottom;i>=top && curr!=null;i--){\\n                res[i][left]=curr.val;\\n                curr=curr.next;\\n            }\\n            left++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482290,
                "title": "c-easy-to-understand-solution-100-faster",
                "content": "Create four index pointers top, bottom, left, right and traverse the matrix accordingly by changing the index pointers.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\n        vector<vector<int>>res(m,vector<int>(n,-1));\\n        int left=0,right=n-1,top=0,bottom=m-1;\\n        while(left<=right&&top<=bottom&&head)\\n        {\\n            for(int i=left;i<=right;i++)\\n            {\\n                res[top][i]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            top++; \\n            for(int i=top;i<=bottom;i++)\\n            {\\n                res[i][right]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--)\\n            {\\n                 res[bottom][i]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n            {\\n                res[i][left]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            left++;      \\n        }\\n        return res;\\n    }\\n};\\n```\\nDo Upvote!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\n        vector<vector<int>>res(m,vector<int>(n,-1));\\n        int left=0,right=n-1,top=0,bottom=m-1;\\n        while(left<=right&&top<=bottom&&head)\\n        {\\n            for(int i=left;i<=right;i++)\\n            {\\n                res[top][i]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            top++; \\n            for(int i=top;i<=bottom;i++)\\n            {\\n                res[i][right]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--)\\n            {\\n                 res[bottom][i]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n            {\\n                res[i][left]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            left++;      \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455288,
                "title": "simple-simulation-very-clear-and-easy-to-understand",
                "content": "```\\n\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        result = [ [-1] * n for _ in range(m) ]\\n        node = head\\n        \\n        \\n        \\n        UP = 2\\n        DOWN = 3\\n        LEFT = 1\\n        RIGHT = 0\\n        \\n        directions = ( (0,1), (0,-1), (-1,0), (1,0))\\n        direction = RIGHT\\n        \\n        uB, dB, lB, rB = 0, m-1, 0, n-1\\n        row, col = 0, 0\\n\\n        while node:\\n            result[row][col] = node.val \\n            node = node.next \\n\\n            if direction == RIGHT and col == rB and row != dB:\\n                direction = DOWN\\n                uB += 1\\n            \\n\\n            if direction == DOWN and col == rB and row == dB:\\n                direction = LEFT\\n                rB -= 1\\n                \\n            if direction == LEFT and col == lB and row != uB:\\n                direction = UP\\n                dB -= 1\\n                \\n            if direction == UP and col == lB and row == uB:\\n                direction = RIGHT\\n                lB += 1\\n            \\n            dr,dc = directions[direction]\\n            row,col = row+dr, col+dc\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\n\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        result = [ [-1] * n for _ in range(m) ]\\n        node = head\\n        \\n        \\n        \\n        UP = 2\\n        DOWN = 3\\n        LEFT = 1\\n        RIGHT = 0\\n        \\n        directions = ( (0,1), (0,-1), (-1,0), (1,0))\\n        direction = RIGHT\\n        \\n        uB, dB, lB, rB = 0, m-1, 0, n-1\\n        row, col = 0, 0\\n\\n        while node:\\n            result[row][col] = node.val \\n            node = node.next \\n\\n            if direction == RIGHT and col == rB and row != dB:\\n                direction = DOWN\\n                uB += 1\\n            \\n\\n            if direction == DOWN and col == rB and row == dB:\\n                direction = LEFT\\n                rB -= 1\\n                \\n            if direction == LEFT and col == lB and row != uB:\\n                direction = UP\\n                dB -= 1\\n                \\n            if direction == UP and col == lB and row == uB:\\n                direction = RIGHT\\n                lB += 1\\n            \\n            dr,dc = directions[direction]\\n            row,col = row+dr, col+dc\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263648,
                "title": "time-o-n-m-space-o-n-m",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        // TIME- O(N*M)  SPACE - O(N*M)\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int left=0,right=n-1,up=0,down=m-1;\\n        while(left<=right && up<=down && head)\\n        {\\n\\n            for(int col=left;col<=right;col++)\\n            {\\n                if(head)\\n                {\\n                    ans[up][col]=head->val;\\n                    head=head->next;\\n                }\\n                else break;\\n            }\\n            up++;\\n            \\n            for(int row=up;row<=down;row++)\\n            {\\n                if(head)\\n                {\\n                    ans[row][right]=head->val;\\n                    head=head->next;\\n                }\\n                else break;\\n            }\\n        \\n        right--;\\n            \\n            \\n            for(int col=right;col>=left;col--)\\n            {\\n                if(head)\\n                {\\n                    ans[down][col]=head->val;\\n                    head=head->next;\\n                }\\n                else break;\\n                \\n            }\\n            down--;\\n            \\n            for(int row=down;row>=up;row--)\\n            {\\n                 if(head)\\n                {\\n                    ans[row][left]=head->val;\\n                    head=head->next;\\n                }\\n                else break;\\n            }\\n            left++;\\n        \\n        \\n        \\n        \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Linked List",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        // TIME- O(N*M)  SPACE - O(N*M)\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int left=0,right=n-1,up=0,down=m-1;\\n        while(left<=right && up<=down && head)\\n        {\\n\\n            for(int col=left;col<=right;col++)\\n            {\\n                if(head)\\n                {\\n                    ans[up][col]=head->val;\\n                    head=head->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2233775,
                "title": "javascript-simple-easy-to-understand-matrix",
                "content": "```\\nvar spiralMatrix = function(m, n, head) {\\n    let matrix = []\\n    for (let i = 0; i < m; i++) {\\n        let arr = [];\\n        for (let j = 0; j < n; j++) arr.push(-1)\\n        matrix.push(arr)\\n    }\\n    let list = []\\n    let li = head\\n    while (li != null) {\\n        list.push(li.val)\\n        li = li.next;\\n    }\\n    let index = 0\\n    let rowBoundaries = 0\\n    let colBoundaries = 0\\n    let row = 0\\n    let col = -1\\n    while (true) {\\n        while (col<matrix[0].length-colBoundaries-1 && index<list.length) {\\n            col++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (row<matrix.length-rowBoundaries-1 && index<list.length) {\\n            row++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (col>colBoundaries && index<list.length) {\\n            col--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        rowBoundaries++\\n        colBoundaries++\\n        while (row>rowBoundaries && index<list.length) {\\n            row--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        if (index>=list.length) break\\n    }\\n    return matrix\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nvar spiralMatrix = function(m, n, head) {\\n    let matrix = []\\n    for (let i = 0; i < m; i++) {\\n        let arr = [];\\n        for (let j = 0; j < n; j++) arr.push(-1)\\n        matrix.push(arr)\\n    }\\n    let list = []\\n    let li = head\\n    while (li != null) {\\n        list.push(li.val)\\n        li = li.next;\\n    }\\n    let index = 0\\n    let rowBoundaries = 0\\n    let colBoundaries = 0\\n    let row = 0\\n    let col = -1\\n    while (true) {\\n        while (col<matrix[0].length-colBoundaries-1 && index<list.length) {\\n            col++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (row<matrix.length-rowBoundaries-1 && index<list.length) {\\n            row++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (col>colBoundaries && index<list.length) {\\n            col--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        rowBoundaries++\\n        colBoundaries++\\n        while (row>rowBoundaries && index<list.length) {\\n            row--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        if (index>=list.length) break\\n    }\\n    return matrix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231059,
                "title": "c-easy-code-simple-to-under-stand",
                "content": "\\n       \\n        \\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\t\\tListNode* my = head;\\n\\t\\t\\t\\tvector<vector<int>> map;\\n\\t\\t\\t\\tmap.assign(m, vector<int>(n, -1));\\n\\n\\t\\t\\t\\tint ox[4]= {1, 0, -1, 0};     // for direction change \\n\\t\\t\\t\\tint oy[4]= {0, 1, 0, -1};    //  [right -> down -> left -> up]  is repeated\\n\\n\\t\\t\\t\\tint w = 0; int h =0;\\n\\t\\t\\t\\tmap[h][w] = my->val; // add first \\n\\t\\t\\t\\tint cur=1;  // add first,  so cur is 1 \\n\\t\\t\\t\\tint i=0;    // check direction \\n\\t\\t\\t\\tint num=0;  \\n\\n\\t\\t\\t\\twhile(m*n !=cur) {    // do this while m*n \\n\\n\\t\\t\\t\\t\\t// step1.  check can use next number?, if not  use  -1 \\n\\t\\t\\t\\t\\tif(my->next != NULL){\\n\\t\\t\\t\\t\\t\\tmy = my->next;\\n\\t\\t\\t\\t\\t\\tnum = my->val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tnum = -1; \\n\\n\\n\\t\\t\\t\\t   // 0 0 0 1\\n\\t\\t\\t\\t   // 3 4 4 1 \\n\\t\\t\\t\\t   // 3 2 2 2\\n\\n\\t\\t\\t\\t\\t// step2. check  can access and  is not visited   => keep current direction\\n\\t\\t\\t\\t\\t// if not? => change direction\\n\\t\\t\\t\\t\\tif( (h+oy[i] >= 0 && h+oy[i]< m && w+ox[i] >=0 && w+ox[i] < n) && map[h+oy[i]][w+ox[i]] == -1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\th+=oy[i];\\n\\t\\t\\t\\t\\t\\tw+=ox[i];                \\n\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\ti=(i+1)%4;\\n\\t\\t\\t\\t\\t\\th+=oy[i];\\n\\t\\t\\t\\t\\t\\tw+=ox[i];              \\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmap[h][w] = num;\\n\\t\\t\\t\\t\\tcur++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\n\\t\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\t\\tListNode* my = head;\\n\\t\\t\\t\\tvector<vector<int>> map;\\n\\t\\t\\t\\tmap.assign(m, vector<int>(n, -1));\\n\\n\\t\\t\\t\\tint ox[4]= {1, 0, -1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2230824,
                "title": "simple-c-solution-o-m-n",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>>mat(m,vector<int>(n,-1)) ;\\n\\n        int dir = 1 ;\\n        \\n        /*\\n        1 = left to right\\n        2 = up to down\\n        3 = right to left\\n        4 = down to up\\n        */\\n        int left=0 , right=n-1 , up=0 , down=m-1 ;\\n        int count = 1 ;\\n        \\n        while( head != NULL && left <= right && up <= down )\\n        {\\n            \\n                if(dir == 1)\\n                {\\n                    for(int i=left;i<=right;i++)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[up][i]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    \\n                    up++;\\n                    dir++;\\n                }\\n                else if(dir == 2)\\n                {\\n                    for(int i=up;i<=down;i++)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[i][right]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    right--;\\n                    dir++;\\n                }\\n                else if(dir == 3)\\n                {\\n                    for(int i=right;i>=left;i--)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[down][i]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    down--;\\n                    dir++;\\n                }\\n                else\\n                {\\n                    for(int i=down;i>=up;i--)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[i][left]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    left++;\\n                    dir = 1;\\n                }\\n            \\n        }\\n        return mat;\\n \\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>>mat(m,vector<int>(n,-1)) ;\\n\\n        int dir = 1 ;\\n        \\n        /*\\n        1 = left to right\\n        2 = up to down\\n        3 = right to left\\n        4 = down to up\\n        */\\n        int left=0 , right=n-1 , up=0 , down=m-1 ;\\n        int count = 1 ;\\n        \\n        while( head != NULL && left <= right && up <= down )\\n        {\\n            \\n                if(dir == 1)\\n                {\\n                    for(int i=left;i<=right;i++)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[up][i]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    \\n                    up++;\\n                    dir++;\\n                }\\n                else if(dir == 2)\\n                {\\n                    for(int i=up;i<=down;i++)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[i][right]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    right--;\\n                    dir++;\\n                }\\n                else if(dir == 3)\\n                {\\n                    for(int i=right;i>=left;i--)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[down][i]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    down--;\\n                    dir++;\\n                }\\n                else\\n                {\\n                    for(int i=down;i>=up;i--)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[i][left]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    left++;\\n                    dir = 1;\\n                }\\n            \\n        }\\n        return mat;\\n \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230508,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        \\n        ListNode* curr = head;\\n        \\n        vector<vector<int>> res(n, vector<int> (m, -1));\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = m - 1;\\n        \\n        while(top <= bottom && left <= right)\\n        {\\n            // fill the top row\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right && curr; i++)\\n                {\\n                    res[top][i] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            // fill the right col\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom && curr; i++)\\n                {\\n                    res[i][right] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            // fill the bottom row\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left && curr; i--)\\n                {\\n                    res[bottom][i] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            // fill the left col\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top && curr; i--)\\n                {\\n                    res[i][left] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        \\n        ListNode* curr = head;\\n        \\n        vector<vector<int>> res(n, vector<int> (m, -1));\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = m - 1;\\n        \\n        while(top <= bottom && left <= right)\\n        {\\n            // fill the top row\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right && curr; i++)\\n                {\\n                    res[top][i] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            // fill the right col\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom && curr; i++)\\n                {\\n                    res[i][right] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            // fill the bottom row\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left && curr; i--)\\n                {\\n                    res[bottom][i] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            // fill the left col\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top && curr; i--)\\n                {\\n                    res[i][left] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230352,
                "title": "simple-solution-in-c",
                "content": "```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int r1=0,r2=m-1,c1=0,c2=n-1;\\n        \\n        while( (r1<=r2 && c1<=c2) && head){\\n            \\n            for(int i=c1;i<=c2 && head;i++){\\n                ans[r1][i]=head->val;\\n                head=head->next;\\n            }\\n            r1++;\\n            for(int i=r1;i<=r2 && head;i++){\\n                ans[i][c2]=head->val;\\n                head=head->next;\\n            }\\n            c2--;\\n            for(int i=c2;i>=c1 && head;i--){\\n                ans[r2][i]=head->val;\\n                head=head->next;\\n            }\\n            r2--;\\n            \\n            for(int i=r2;i>=r1 && head;i--){\\n                ans[i][c1]=head->val;\\n                head=head->next;\\n            }\\n            c1++;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int r1=0,r2=m-1,c1=0,c2=n-1;\\n        \\n        while( (r1<=r2 && c1<=c2) && head){\\n            \\n            for(int i=c1;i<=c2 && head;i++){\\n                ans[r1][i]=head->val;\\n                head=head->next;\\n            }\\n            r1++;\\n            for(int i=r1;i<=r2 && head;i++){\\n                ans[i][c2]=head->val;\\n                head=head->next;\\n            }\\n            c2--;\\n            for(int i=c2;i>=c1 && head;i--){\\n                ans[r2][i]=head->val;\\n                head=head->next;\\n            }\\n            r2--;\\n            \\n            for(int i=r2;i>=r1 && head;i--){\\n                ans[i][c1]=head->val;\\n                head=head->next;\\n            }\\n            c1++;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2230108,
                "title": "c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> ans(m, vector<int> (n,-1));\\n        \\n        int top=0,bottom=m-1,left=0,right=n-1;\\n        \\n        while(top<=bottom && left <= right)\\n        {\\n            for(int i=left;i<=right&&head;i++)\\n            {\\n                ans[top][i] = head->val;\\n                head = head->next;\\n                if(!head)\\n                    break;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom&&head;i++)\\n            {\\n                ans[i][right] = head->val;\\n                head = head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            right--;\\n            \\n            for(int i=right;i>=left&&head;i--)\\n            {\\n                ans[bottom][i]  = head->val;\\n                head=head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            bottom--;\\n            \\n            for(int i=bottom;i>=top&&head;i--)\\n            {\\n                ans[i][left] = head->val;\\n                head=head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            left++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> ans(m, vector<int> (n,-1));\\n        \\n        int top=0,bottom=m-1,left=0,right=n-1;\\n        \\n        while(top<=bottom && left <= right)\\n        {\\n            for(int i=left;i<=right&&head;i++)\\n            {\\n                ans[top][i] = head->val;\\n                head = head->next;\\n                if(!head)\\n                    break;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom&&head;i++)\\n            {\\n                ans[i][right] = head->val;\\n                head = head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            right--;\\n            \\n            for(int i=right;i>=left&&head;i--)\\n            {\\n                ans[bottom][i]  = head->val;\\n                head=head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            bottom--;\\n            \\n            for(int i=bottom;i>=top&&head;i--)\\n            {\\n                ans[i][left] = head->val;\\n                head=head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            left++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229922,
                "title": "c-spiral-matrix-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int minrow = 0;\\n        int mincol = 0;\\n        int maxrow = m-1;\\n        int maxcol = n-1;\\n        int x = 1;\\n        while(x<=m*n){\\n            //right\\n            for(int i=mincol;i<=maxcol;i++){\\n                if(!head){\\n                    ans[minrow][i] = -1;\\n                    x++;\\n                }else{\\n                    ans[minrow][i] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            minrow++;\\n            //down\\n            if(x<=m*n){\\n            for(int i=minrow;i<=maxrow;i++){\\n                if(!head){\\n                    ans[i][maxcol] = -1;\\n                    x++;\\n                }else{\\n                    ans[i][maxcol] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            maxcol--;\\n            }\\n            //left\\n            if(x<=m*n){\\n            for(int i=maxcol;i>=mincol;i--){\\n                if(!head){\\n                    ans[maxrow][i] = -1;\\n                    x++;\\n                }else{\\n                    ans[maxrow][i] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            maxrow--;\\n            }\\n            //up\\n            if(x<=m*n){\\n            for(int i=maxrow;i>=minrow;i--){\\n                if(!head){\\n                    ans[i][mincol] = -1;\\n                    x++;\\n                }else{\\n                    ans[i][mincol] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            mincol++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int minrow = 0;\\n        int mincol = 0;\\n        int maxrow = m-1;\\n        int maxcol = n-1;\\n        int x = 1;\\n        while(x<=m*n){\\n            //right\\n            for(int i=mincol;i<=maxcol;i++){\\n                if(!head){\\n                    ans[minrow][i] = -1;\\n                    x++;\\n                }else{\\n                    ans[minrow][i] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            minrow++;\\n            //down\\n            if(x<=m*n){\\n            for(int i=minrow;i<=maxrow;i++){\\n                if(!head){\\n                    ans[i][maxcol] = -1;\\n                    x++;\\n                }else{\\n                    ans[i][maxcol] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            maxcol--;\\n            }\\n            //left\\n            if(x<=m*n){\\n            for(int i=maxcol;i>=mincol;i--){\\n                if(!head){\\n                    ans[maxrow][i] = -1;\\n                    x++;\\n                }else{\\n                    ans[maxrow][i] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            maxrow--;\\n            }\\n            //up\\n            if(x<=m*n){\\n            for(int i=maxrow;i>=minrow;i--){\\n                if(!head){\\n                    ans[i][mincol] = -1;\\n                    x++;\\n                }else{\\n                    ans[i][mincol] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            mincol++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509623,
                "title": "beats-98-6-only-loops-python-3-explained",
                "content": "# Intuition\\nThe code is very similar to the SPIRAL MATRIX I / II but here you need to check if we reach at the end of head i.e head.next = None;\\nif it is None return ans as we reached end and all other matrix coloumn will be -1 (ans matrix is prefilled with -1)\\nIts a pretty long code and shorter codes are also available but its a good practice to know how loops work! ;)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        ans = [[-1]*(n) for _ in range(m)]\\n        first_row = 0\\n        first_col = 0\\n        last_row = m - 1\\n        last_col = n - 1\\n        while first_row < last_row and first_col < last_col:\\n            for j in range(first_col, last_col):\\n                ans[first_row][j] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n                \\n            for i in range(first_row, last_row):\\n                ans[i][last_col] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            for j in range(last_col, first_col, -1):\\n                ans[last_row][j] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            for i in range(last_row, first_row, -1):\\n                ans[i][first_col] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            first_row += 1\\n            first_col += 1\\n            last_row -= 1\\n            last_col -= 1\\n       \\n        if head != None:\\n            for i in range(first_row, last_row + 1):\\n                for j in range(first_col, last_col + 1):\\n                    ans[i][j] = head.val\\n                    head = head.next \\n                    if head == None:\\n                        return ans \\n        return(ans)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        ans = [[-1]*(n) for _ in range(m)]\\n        first_row = 0\\n        first_col = 0\\n        last_row = m - 1\\n        last_col = n - 1\\n        while first_row < last_row and first_col < last_col:\\n            for j in range(first_col, last_col):\\n                ans[first_row][j] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n                \\n            for i in range(first_row, last_row):\\n                ans[i][last_col] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            for j in range(last_col, first_col, -1):\\n                ans[last_row][j] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            for i in range(last_row, first_row, -1):\\n                ans[i][first_col] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            first_row += 1\\n            first_col += 1\\n            last_row -= 1\\n            last_col -= 1\\n       \\n        if head != None:\\n            for i in range(first_row, last_row + 1):\\n                for j in range(first_col, last_col + 1):\\n                    ans[i][j] = head.val\\n                    head = head.next \\n                    if head == None:\\n                        return ans \\n        return(ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401508,
                "title": "simple-c-solution",
                "content": "# Intuition\\nSpiral traversal means we will have to maintain four pointers right, down, left and up. In each iteration we will update these values until the number of values in matrix becomes = no. of rows * no.of columns.\\n\\n# Approach\\nInitialize a 2d vector of size m*n containing -10 or any other number.\\nInitialize current i and current j pointers to be initially 0 and -1. \\nInitialize pointers right = n (travel n distance right), then down = m-1 (travel m-1 distance down) then left = n-1 (travel n-1 distance left) and finally travel up = m-2 distance upwards to complete one rotation. Now, for next rotation, update distances right, left, down and up. \\nIf you carefully draw a spiral matrix on paper and trace the spiral rotations, you will notice that right should be updated as left-1, down updates as up-1, left updates as right-1 and up updates as down-1.\\n\\nNow, if head of linked list is pointing to null, then we will set\\nans[current i][current j] = -1 or else ans[current i][current j] = head -> val and make head = head -> next.\\n\\nNow in each step we will have to update the no. of values in the linkedlist that we visited. For right travseral we will increase the values variable by \\'right\\' and so on for others. Then, in between traversing to the next direction i.e. from right to down, from down to left, from left to up we will check if values variable is equal to m*n or not and if so break and return the answer vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(vector<vector<int>>(m,vector<int>(n,-10)));\\n        int cur_i = 0, cur_j = -1, values = 0;\\n        int right = n, down = m-1, left = n-1, up = m-2;\\n        while(values <= m*n) {\\n            for(int i=1;i<=right;i++) {\\n                cur_j++;\\n                if(head==NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                    // cout<<-1<<endl;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    // cout<<head->val<<endl;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += right;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_j > n-1) {\\n                cur_j--;\\n            }\\n\\n            for(int i=1;i<=down;i++) {\\n                cur_i++;\\n                if(head==NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                    // cout<<-1<<endl;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    // cout<<head->val<<endl;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += down;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_i > m-1) {\\n                cur_i--;\\n            }\\n\\n            for(int i=1;i<=left;i++) {\\n                cur_j--;\\n                if(head == NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += left;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_j < 0) {\\n                cur_j++;\\n            }\\n\\n            for(int i=1;i<=up;i++) {\\n                cur_i--;\\n                if(head == NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += up;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_i < 0) {\\n                cur_i++;\\n            }\\n\\n            right=left-1;\\n            down = up-1;\\n            left = right-1;\\n            up = down-1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(vector<vector<int>>(m,vector<int>(n,-10)));\\n        int cur_i = 0, cur_j = -1, values = 0;\\n        int right = n, down = m-1, left = n-1, up = m-2;\\n        while(values <= m*n) {\\n            for(int i=1;i<=right;i++) {\\n                cur_j++;\\n                if(head==NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                    // cout<<-1<<endl;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    // cout<<head->val<<endl;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += right;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_j > n-1) {\\n                cur_j--;\\n            }\\n\\n            for(int i=1;i<=down;i++) {\\n                cur_i++;\\n                if(head==NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                    // cout<<-1<<endl;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    // cout<<head->val<<endl;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += down;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_i > m-1) {\\n                cur_i--;\\n            }\\n\\n            for(int i=1;i<=left;i++) {\\n                cur_j--;\\n                if(head == NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += left;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_j < 0) {\\n                cur_j++;\\n            }\\n\\n            for(int i=1;i<=up;i++) {\\n                cur_i--;\\n                if(head == NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += up;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_i < 0) {\\n                cur_i++;\\n            }\\n\\n            right=left-1;\\n            down = up-1;\\n            left = right-1;\\n            up = down-1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3354861,
                "title": "beats-90-46-easy-basic-solution",
                "content": "\\n# Approach\\n\\n---\\n\\nFill Matrix By traverssing Linked List\\n\\n# Complexity\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n---\\n\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)]for j in range(m)]\\n        colbegin=0\\n        rowbegin=0\\n        colend=n\\n        rowend=m\\n        while rowbegin<rowend and colbegin<colend and head!=None:\\n            for i in range(colbegin,colend):\\n                if head!=None:\\n                    mat[rowbegin][i]=head.val\\n                    head=head.next\\n            for j in range(rowbegin+1,rowend-1):\\n                if head!=None:\\n                    mat[j][colend-1]=head.val\\n                    head=head.next\\n            if rowbegin!=rowend-1:\\n                for i in range(colend-1,colbegin-1,-1):\\n                    if head!=None:\\n                        mat[rowend-1][i]=head.val\\n                        head=head.next\\n            if colbegin!=colend-1:\\n                for j in range(rowend-2,rowbegin,-1):\\n                    if head!=None:\\n                        mat[j][colbegin]=head.val\\n                        head=head.next\\n            colbegin+=1\\n            colend-=1\\n            rowbegin+=1\\n            rowend-=1\\n        return mat",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n# Approach\\n\\n---\\n\\nFill Matrix By traverssing Linked List\\n\\n# Complexity\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n---\\n\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)]for j in range(m)]\\n        colbegin=0\\n        rowbegin=0\\n        colend=n\\n        rowend=m\\n        while rowbegin<rowend and colbegin<colend and head!=None:\\n            for i in range(colbegin,colend):\\n                if head!=None:\\n                    mat[rowbegin][i]=head.val\\n                    head=head.next\\n            for j in range(rowbegin+1,rowend-1):\\n                if head!=None:\\n                    mat[j][colend-1]=head.val\\n                    head=head.next\\n            if rowbegin!=rowend-1:\\n                for i in range(colend-1,colbegin-1,-1):\\n                    if head!=None:\\n                        mat[rowend-1][i]=head.val\\n                        head=head.next\\n            if colbegin!=colend-1:\\n                for j in range(rowend-2,rowbegin,-1):\\n                    if head!=None:\\n                        mat[j][colbegin]=head.val\\n                        head=head.next\\n            colbegin+=1\\n            colend-=1\\n            rowbegin+=1\\n            rowend-=1\\n        return mat",
                "codeTag": "Java"
            },
            {
                "id": 3317158,
                "title": "easy-to-understand-clean-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m - 1;\\n        int colStart = 0;\\n        int colEnd = n - 1;\\n        ListNode temp = head;\\n\\n        while(rowStart <= rowEnd && colStart <= colEnd) {\\n            // top -->\\n            for(int j = colStart; j <= colEnd; j++) {\\n                if(temp == null) {\\n                    ans[rowStart][j] = -1;\\n                } else {\\n                    ans[rowStart][j] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            // Right -->\\n            for(int i = rowStart + 1; i <= rowEnd; i++) {\\n                if(temp == null) {\\n                    ans[i][colEnd] = -1;\\n                } else {\\n                    ans[i][colEnd] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            //Bottom -->\\n            for(int j = colEnd - 1; j >= colStart; j--) {\\n                if(rowStart == rowEnd) break; // V.V.I (base condition)\\n                if(temp == null) {\\n                    ans[rowEnd][j] = -1;\\n                } else {\\n                    ans[rowEnd][j] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            // Left -->\\n            for(int i = rowEnd - 1; i >= rowStart + 1; i--) {\\n                if(colStart == colEnd) break; // V.V.I (base condition)\\n                if(temp == null) {\\n                    ans[i][colStart] = -1;\\n                } else {\\n                    ans[i][colStart] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            rowStart++;\\n            rowEnd--;\\n            colStart++;\\n            colEnd--;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m - 1;\\n        int colStart = 0;\\n        int colEnd = n - 1;\\n        ListNode temp = head;\\n\\n        while(rowStart <= rowEnd && colStart <= colEnd) {\\n            // top -->\\n            for(int j = colStart; j <= colEnd; j++) {\\n                if(temp == null) {\\n                    ans[rowStart][j] = -1;\\n                } else {\\n                    ans[rowStart][j] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            // Right -->\\n            for(int i = rowStart + 1; i <= rowEnd; i++) {\\n                if(temp == null) {\\n                    ans[i][colEnd] = -1;\\n                } else {\\n                    ans[i][colEnd] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            //Bottom -->\\n            for(int j = colEnd - 1; j >= colStart; j--) {\\n                if(rowStart == rowEnd) break; // V.V.I (base condition)\\n                if(temp == null) {\\n                    ans[rowEnd][j] = -1;\\n                } else {\\n                    ans[rowEnd][j] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            // Left -->\\n            for(int i = rowEnd - 1; i >= rowStart + 1; i--) {\\n                if(colStart == colEnd) break; // V.V.I (base condition)\\n                if(temp == null) {\\n                    ans[i][colStart] = -1;\\n                } else {\\n                    ans[i][colStart] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            rowStart++;\\n            rowEnd--;\\n            colStart++;\\n            colEnd--;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095576,
                "title": "c-very-simple-and-easy-spiral-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> res(n,vector<int>(m,-1));\\n        int i = 0, j =0;\\n        while(head!=NULL)\\n        {\\n            if(j<m)\\n            {\\n                while(head!= NULL and j<m and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    j++;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(i<n)\\n            {\\n                while(head!= NULL and i<n and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    i++;\\n                }\\n                i--;\\n                j--;\\n            }\\n            if(j>=0)\\n            {\\n                while(head!= NULL and j>=0 and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    j--;\\n                }\\n                i--;\\n                j++;\\n            }\\n            if(i>=0)\\n            {\\n                while(head!= NULL and i>=0 and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    i--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> res(n,vector<int>(m,-1));\\n        int i = 0, j =0;\\n        while(head!=NULL)\\n        {\\n            if(j<m)\\n            {\\n                while(head!= NULL and j<m and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    j++;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(i<n)\\n            {\\n                while(head!= NULL and i<n and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    i++;\\n                }\\n                i--;\\n                j--;\\n            }\\n            if(j>=0)\\n            {\\n                while(head!= NULL and j>=0 and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    j--;\\n                }\\n                i--;\\n                j++;\\n            }\\n            if(i>=0)\\n            {\\n                while(head!= NULL and i>=0 and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    i--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697172,
                "title": "java-simple-solution-beginner-friendly",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        //arr to store the  answer\\n        int[][] arr = new int[m][n];\\n        //Fill every row of the array with -1\\n        for(int[] x : arr) {\\n             Arrays.fill(x,-1);\\n        }\\n        //We have to traverse spirally to get the required matrix\\n        //top-left to right\\n        //top-right to bottom\\n        //bottom-right to left\\n        //bottom-left to top\\n        //We have to traverse according to above mentioned paths from head of the linkedlist\\n        int top = 0, bottom = m-1;\\n        int left = 0, right = n-1;\\n        //traverse the list until your head didn\\'t face the null\\n        while(head!=null){\\n            //This for-loop stores elements from top.left-right\\n            for(int i = top;i<=right && head!=null ;i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }\\n            //Increment the top value to avoid duplicates\\n            top++;\\n            //This for-loop stores values from top.right to bottom\\n            for(int i = top;i<=bottom && head!=null;i++){\\n                arr[i][right] = head.val;\\n                head = head.next;\\n            }\\n            //Decrement the right value to avoid duplicates\\n            right--;\\n            //This for-loop stores elements from bottom.right to left\\n            for(int i = right;i>=left && head!=null;i--){\\n                arr[bottom][i] = head.val;\\n                head = head.next;\\n            }\\n            //Decrement the bottom value to avoid duplicates\\n            bottom--;\\n            //This for-loop stores elements from bottom.left to top\\n            for(int i = bottom;i>=top && head!=null;i--){\\n                arr[i][left] = head.val;\\n                head = head.next;\\n            }\\n            //Increment the left value to avoid duplicates\\n            left++;\\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        //arr to store the  answer\\n        int[][] arr = new int[m][n];\\n        //Fill every row of the array with -1\\n        for(int[] x : arr) {\\n             Arrays.fill(x,-1);\\n        }\\n        //We have to traverse spirally to get the required matrix\\n        //top-left to right\\n        //top-right to bottom\\n        //bottom-right to left\\n        //bottom-left to top\\n        //We have to traverse according to above mentioned paths from head of the linkedlist\\n        int top = 0, bottom = m-1;\\n        int left = 0, right = n-1;\\n        //traverse the list until your head didn\\'t face the null\\n        while(head!=null){\\n            //This for-loop stores elements from top.left-right\\n            for(int i = top;i<=right && head!=null ;i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }\\n            //Increment the top value to avoid duplicates\\n            top++;\\n            //This for-loop stores values from top.right to bottom\\n            for(int i = top;i<=bottom && head!=null;i++){\\n                arr[i][right] = head.val;\\n                head = head.next;\\n            }\\n            //Decrement the right value to avoid duplicates\\n            right--;\\n            //This for-loop stores elements from bottom.right to left\\n            for(int i = right;i>=left && head!=null;i--){\\n                arr[bottom][i] = head.val;\\n                head = head.next;\\n            }\\n            //Decrement the bottom value to avoid duplicates\\n            bottom--;\\n            //This for-loop stores elements from bottom.left to top\\n            for(int i = bottom;i>=top && head!=null;i--){\\n                arr[i][left] = head.val;\\n                head = head.next;\\n            }\\n            //Increment the left value to avoid duplicates\\n            left++;\\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673591,
                "title": "faster-than-100-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    vector<vector<int>> ans (m,vector<int>(n,-1));\\n    int sr=0,er=m-1,sc=0,ec=n-1;\\n        \\n    while(head!=NULL){\\n       for(int i=sc;i<=ec && head!=NULL;i++){\\n           ans[sr][i]=head->val;\\n           head=head->next;\\n       }\\n      sr++;\\n      for(int i=sr;i<=er && head!=NULL;i++){\\n           ans[i][ec]=head->val;\\n           head=head->next;\\n       }\\n      ec--;\\n      for(int i=ec;i>=sc && head!=NULL;i--){\\n            ans[er][i]=head->val;\\n            head=head->next;\\n       }\\n       er--;\\n       for(int i=er;i>=sr && head!=NULL;i--){\\n           ans[i][sc]=head->val;\\n           head=head->next;\\n       }\\n    sc++;    \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    vector<vector<int>> ans (m,vector<int>(n,-1));\\n    int sr=0,er=m-1,sc=0,ec=n-1;\\n        \\n    while(head!=NULL){\\n       for(int i=sc;i<=ec && head!=NULL;i++){\\n           ans[sr][i]=head->val;\\n           head=head->next;\\n       }\\n      sr++;\\n      for(int i=sr;i<=er && head!=NULL;i++){\\n           ans[i][ec]=head->val;\\n           head=head->next;\\n       }\\n      ec--;\\n      for(int i=ec;i>=sc && head!=NULL;i--){\\n            ans[er][i]=head->val;\\n            head=head->next;\\n       }\\n       er--;\\n       for(int i=er;i>=sr && head!=NULL;i--){\\n           ans[i][sc]=head->val;\\n           head=head->next;\\n       }\\n    sc++;    \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673498,
                "title": "easy-c-solution-logic-building",
                "content": "**Please Upvote If this Helps U :)**\\n```\\nclass Solution {\\npublic:\\n    int len(ListNode* head){\\n        int ctr=0;\\n        ListNode* temp = head;\\n        while(temp!=nullptr){\\n            ctr++;\\n            temp = temp->next;\\n        }\\n        return ctr;\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        if(head == nullptr){\\n            return v;\\n        }\\n        ListNode* temp = head;\\n        int t = len(head);\\n        int strrow = 0;\\n        int strcol = 0;\\n        int endrow = m-1;\\n        int endcol = n-1;\\n        int count = 0;\\n        while(count<t)\\n        {\\n            for(int i=strrow;count<t&&i<=endcol;i++){\\n                v[strrow][i] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            strrow++;\\n            for(int i=strrow;count<t && i<=endrow;i++){\\n                v[i][endcol] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;count<t &&i>=strcol;i--){\\n                \\n                v[endrow][i] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            endrow--;\\n            for(int i=endrow;count<t && i>=strrow;i--){\\n                v[i][strcol] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            strcol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int len(ListNode* head){\\n        int ctr=0;\\n        ListNode* temp = head;\\n        while(temp!=nullptr){\\n            ctr++;\\n            temp = temp->next;\\n        }\\n        return ctr;\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        if(head == nullptr){\\n            return v;\\n        }\\n        ListNode* temp = head;\\n        int t = len(head);\\n        int strrow = 0;\\n        int strcol = 0;\\n        int endrow = m-1;\\n        int endcol = n-1;\\n        int count = 0;\\n        while(count<t)\\n        {\\n            for(int i=strrow;count<t&&i<=endcol;i++){\\n                v[strrow][i] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            strrow++;\\n            for(int i=strrow;count<t && i<=endrow;i++){\\n                v[i][endcol] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;count<t &&i>=strcol;i--){\\n                \\n                v[endrow][i] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            endrow--;\\n            for(int i=endrow;count<t && i>=strrow;i--){\\n                v[i][strcol] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            strcol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661492,
                "title": "python-easy-understand-solution",
                "content": "```\\n# 2022.10.04\\n# The logic for this problem is the same as spiral matrix II, the only difference is we need to consider the linked list. So everytime when we update the value in the matrix, we want to make sure the head of the linked list is not pointed to null. If the linked list has been thoroughly iterated, we assign the next value to -1. \\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix = [[0 for i in range(n)] for j in range(m)]\\n        left, right = 0, n\\n        top, bottom = 0, m \\n        while left < right and top < bottom :\\n            for i in range(left, right):\\n                if not head:\\n                    matrix[top][i] = -1\\n                else:\\n                    matrix[top][i] = head.val\\n                    head = head.next\\n            top += 1\\n            \\n            for i in range(top, bottom):\\n                if not head:\\n                    matrix[i][right-1] = -1\\n                else:\\n                    matrix[i][right-1] = head.val\\n                    head = head.next\\n            right -= 1\\n            \\n            if not (left < right and top < bottom):\\n                break\\n            \\n            for i in range(right-1, left-1, -1):\\n                if not head:\\n                    matrix[bottom-1][i] = -1\\n                else:\\n                    matrix[bottom-1][i] = head.val\\n                    head = head.next \\n            bottom -= 1\\n            \\n            for i in range(bottom-1, top-1, -1):\\n                if not head:\\n                    matrix[i][left] = - 1\\n                else:\\n                    matrix[i][left] = head.val\\n                    head = head.next\\n            left += 1\\n        return matrix \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# 2022.10.04\\n# The logic for this problem is the same as spiral matrix II, the only difference is we need to consider the linked list. So everytime when we update the value in the matrix, we want to make sure the head of the linked list is not pointed to null. If the linked list has been thoroughly iterated, we assign the next value to -1. \\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix = [[0 for i in range(n)] for j in range(m)]\\n        left, right = 0, n\\n        top, bottom = 0, m \\n        while left < right and top < bottom :\\n            for i in range(left, right):\\n                if not head:\\n                    matrix[top][i] = -1\\n                else:\\n                    matrix[top][i] = head.val\\n                    head = head.next\\n            top += 1\\n            \\n            for i in range(top, bottom):\\n                if not head:\\n                    matrix[i][right-1] = -1\\n                else:\\n                    matrix[i][right-1] = head.val\\n                    head = head.next\\n            right -= 1\\n            \\n            if not (left < right and top < bottom):\\n                break\\n            \\n            for i in range(right-1, left-1, -1):\\n                if not head:\\n                    matrix[bottom-1][i] = -1\\n                else:\\n                    matrix[bottom-1][i] = head.val\\n                    head = head.next \\n            bottom -= 1\\n            \\n            for i in range(bottom-1, top-1, -1):\\n                if not head:\\n                    matrix[i][left] = - 1\\n                else:\\n                    matrix[i][left] = head.val\\n                    head = head.next\\n            left += 1\\n        return matrix \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561849,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    static boolean[][] visited;\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n        visited = new boolean[m][n];\\n        int[] coordinates = new int[]{0, 0};\\n        \\n        placeNext(head.val, res, coordinates);\\n        head = head.next;\\n        visited[0][0] = true;\\n        int direction = 0;\\n        int mult = m * n - 1;\\n        \\n        for (int i = 0; i < mult; i++) {\\n            int[] coordTemp = findNextCoord(coordinates, direction);\\n            if (!cellExists(coordTemp[0], coordTemp[1], res)) {\\n                direction++;\\n                direction %= 4;\\n                coordinates = findNextCoord(coordinates, direction);\\n            } else {\\n                coordinates = coordTemp;\\n            }\\n            if (head != null) {\\n                placeNext(head.val, res, coordinates);\\n                head = head.next;\\n            } else {\\n                placeNext(-1, res, coordinates);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int[] findNextCoord(int[] coordinates, int direction) {\\n        int y = coordinates[0], x = coordinates[1];\\n        if (direction == 0) {\\n            x++;\\n        } else if (direction == 1) {\\n            y++;\\n        } else if (direction == 2) {\\n            x--;\\n        } else {\\n            y--;\\n        }\\n        return new int[]{y, x};\\n    }\\n    \\n    private void placeNext(int num, int[][] res, int[] coordinates) {\\n        res[coordinates[0]][coordinates[1]] = num;\\n        visited[coordinates[0]][coordinates[1]] = true;\\n    }\\n\\n    private boolean cellExists(int row, int col, int[][] array) {\\n        return (row <= array.length - 1 && row >= 0) && (col <= array[0].length - 1 && col >= 0) && !visited[row][col];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static boolean[][] visited;\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n        visited = new boolean[m][n];\\n        int[] coordinates = new int[]{0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2513672,
                "title": "c-easy-understanding-o-n-solution-100-faster",
                "content": "```\\nvector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n\\tvector<vector<int>> res(n, vector<int> (m, -1));\\n\\tbool right = true, down = false, left = false, up = false;\\n\\n\\tint rs = 0, re = n-1;\\n\\tint cs = 0, ce = m-1;\\n\\n\\twhile(head!=NULL) {\\n\\t\\tif(right) {\\n\\t\\t\\tfor(int i=cs; i<=ce&&head!=NULL; i++) {\\n\\t\\t\\t\\tres[rs][i] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tdown = true;\\n\\t\\t\\tright = false;\\n\\t\\t\\trs += 1;\\n\\t\\t} else if(down) {\\n\\t\\t\\tfor(int i=rs; i<=re&&head!=NULL; i++) {\\n\\t\\t\\t\\tres[i][ce] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tleft = true;\\n\\t\\t\\tdown = false;\\n\\t\\t\\tce -= 1;\\n\\t\\t} else if(left) {\\n\\t\\t\\tfor(int i=ce; i>=cs&&head!=NULL; i--) {\\n\\t\\t\\t\\tres[re][i] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tup = true;\\n\\t\\t\\tleft = false;\\n\\t\\t\\tre -= 1;\\n\\t\\t} else {\\n\\t\\t\\tfor(int i=re; i>=rs&&head!=NULL; i--) {\\n\\t\\t\\t\\tres[i][cs] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tright = true;\\n\\t\\t\\tup = false;\\n\\t\\t\\tcs += 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n\\tvector<vector<int>> res(n, vector<int> (m, -1));\\n\\tbool right = true, down = false, left = false, up = false;\\n\\n\\tint rs = 0, re = n-1;\\n\\tint cs = 0, ce = m-1;\\n\\n\\twhile(head!=NULL) {\\n\\t\\tif(right) {\\n\\t\\t\\tfor(int i=cs; i<=ce&&head!=NULL; i++) {\\n\\t\\t\\t\\tres[rs][i] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tdown = true;\\n\\t\\t\\tright = false;\\n\\t\\t\\trs += 1;\\n\\t\\t} else if(down) {\\n\\t\\t\\tfor(int i=rs; i<=re&&head!=NULL; i++) {\\n\\t\\t\\t\\tres[i][ce] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tleft = true;\\n\\t\\t\\tdown = false;\\n\\t\\t\\tce -= 1;\\n\\t\\t} else if(left) {\\n\\t\\t\\tfor(int i=ce; i>=cs&&head!=NULL; i--) {\\n\\t\\t\\t\\tres[re][i] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tup = true;\\n\\t\\t\\tleft = false;\\n\\t\\t\\tre -= 1;\\n\\t\\t} else {\\n\\t\\t\\tfor(int i=re; i>=rs&&head!=NULL; i--) {\\n\\t\\t\\t\\tres[i][cs] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tright = true;\\n\\t\\t\\tup = false;\\n\\t\\t\\tcs += 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2500516,
                "title": "c-simple-simulation-cleanest-code-4-while-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>matrix(m, vector<int>(n,-1));\\n        int i = 0, j = 0;\\n        matrix[i][j] = head->val;\\n        head = head->next;\\n        while(head){\\n            while(head and i<m and j+1<n and matrix[i][j+1]==-1){\\n                matrix[i][j+1] = head->val;\\n                head = head->next;\\n                j++;\\n            }\\n            \\n            while(head and i+1<m and j<n and matrix[i+1][j]==-1){\\n                matrix[i+1][j] = head->val;\\n                head = head->next;\\n                i++;\\n            }\\n            \\n            while(head and i<m and j-1>=0 and matrix[i][j-1]==-1){\\n                matrix[i][j-1] = head->val;\\n                head = head->next;\\n                j--;\\n            }\\n            \\n            while(head and i-1>=0 and j<n and matrix[i-1][j]==-1){\\n                matrix[i-1][j] = head->val;\\n                head = head->next;\\n                i--;\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>matrix(m, vector<int>(n,-1));\\n        int i = 0, j = 0;\\n        matrix[i][j] = head->val;\\n        head = head->next;\\n        while(head){\\n            while(head and i<m and j+1<n and matrix[i][j+1]==-1){\\n                matrix[i][j+1] = head->val;\\n                head = head->next;\\n                j++;\\n            }\\n            \\n            while(head and i+1<m and j<n and matrix[i+1][j]==-1){\\n                matrix[i+1][j] = head->val;\\n                head = head->next;\\n                i++;\\n            }\\n            \\n            while(head and i<m and j-1>=0 and matrix[i][j-1]==-1){\\n                matrix[i][j-1] = head->val;\\n                head = head->next;\\n                j--;\\n            }\\n            \\n            while(head and i-1>=0 and j<n and matrix[i-1][j]==-1){\\n                matrix[i-1][j] = head->val;\\n                head = head->next;\\n                i--;\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443665,
                "title": "c-simple-o-n-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // curr: direction 0=right, 1=down, 2=left, 3=top\\n    // if going in a direction and encounter end of matrix or matrix[next_i][next_j]!=-1\\n    // then switch the direction, and move to new matrix[next_i][next_j] according to the given direction\\n    // if this element is also not -1, then end the traversal\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int curr=0,i=0,j=0; \\n        while(head){\\n            ans[i][j]=head->val;\\n            bool check=false;\\n            switch(curr){\\n                case 0:{\\n                    if(j+1>=n || ans[i][j+1]!=-1){\\n                        curr++;\\n                        i++;\\n                    }else j++;\\n                    break;\\n                }\\n                case 1:{\\n                    if(i+1>=m || ans[i+1][j]!=-1){\\n                        curr++;\\n                        j--;\\n                    }else i++;\\n                    break;\\n                }\\n                case 2:{\\n                    if(j-1<0 || ans[i][j-1]!=-1){\\n                        curr++;\\n                        i--;\\n                    }else j--;\\n                    break;\\n                }\\n                case 3:{\\n                    if(i-1<0 || ans[i-1][j]!=-1){\\n                        curr=0;\\n                        j++;\\n                    }else i--;\\n                    break;\\n                }\\n            }\\n            if(i<0 || i>=m || j<0 || j>=n || ans[i][j]!=-1)\\n                break;\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // curr: direction 0=right, 1=down, 2=left, 3=top\\n    // if going in a direction and encounter end of matrix or matrix[next_i][next_j]!=-1\\n    // then switch the direction, and move to new matrix[next_i][next_j] according to the given direction\\n    // if this element is also not -1, then end the traversal\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int curr=0,i=0,j=0; \\n        while(head){\\n            ans[i][j]=head->val;\\n            bool check=false;\\n            switch(curr){\\n                case 0:{\\n                    if(j+1>=n || ans[i][j+1]!=-1){\\n                        curr++;\\n                        i++;\\n                    }else j++;\\n                    break;\\n                }\\n                case 1:{\\n                    if(i+1>=m || ans[i+1][j]!=-1){\\n                        curr++;\\n                        j--;\\n                    }else i++;\\n                    break;\\n                }\\n                case 2:{\\n                    if(j-1<0 || ans[i][j-1]!=-1){\\n                        curr++;\\n                        i--;\\n                    }else j--;\\n                    break;\\n                }\\n                case 3:{\\n                    if(i-1<0 || ans[i-1][j]!=-1){\\n                        curr=0;\\n                        j++;\\n                    }else i--;\\n                    break;\\n                }\\n            }\\n            if(i<0 || i>=m || j<0 || j>=n || ans[i][j]!=-1)\\n                break;\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442580,
                "title": "c-99-86-faster-clean-and-easy-code",
                "content": "```\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int dir=0,top=0,down=m-1,left=0,right=n-1;\\n        while(top<=down  && left<=right && head)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++) \\n                {\\n                    if(!head) return ans;\\n                    ans[top][i]= head->val;\\n                    head=head->next;\\n                }\\n                top++;\\n            }\\n            else if(dir==1)\\n            {\\n                 for(int i=top;i<=down;i++) \\n                {\\n                    if(!head) return ans;\\n                    ans[i][right]= head->val;\\n                    head=head->next;\\n                }\\n                right--;\\n            }\\n            else if(dir==2)\\n            {\\n                 for(int i=right;i>=left;i--) \\n                {\\n                    if(!head) return ans;\\n                    ans[down][i]= head->val;\\n                    head=head->next;\\n                }\\n                down--;\\n            }\\n            else   \\n            {\\n               for(int i=down;i>=top;i--) \\n                {\\n                    if(!head) return ans;\\n                    ans[i][left]= head->val;\\n                    head=head->next;\\n                }\\n                left++;  \\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int dir=0,top=0,down=m-1,left=0,right=n-1;\\n        while(top<=down  && left<=right && head)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++) \\n                {\\n                    if(!head) return ans;\\n                    ans[top][i]= head->val;\\n                    head=head->next;\\n                }\\n                top++;\\n            }\\n            else if(dir==1)\\n            {\\n                 for(int i=top;i<=down;i++) \\n                {\\n                    if(!head) return ans;\\n                    ans[i][right]= head->val;\\n                    head=head->next;\\n                }\\n                right--;\\n            }\\n            else if(dir==2)\\n            {\\n                 for(int i=right;i>=left;i--) \\n                {\\n                    if(!head) return ans;\\n                    ans[down][i]= head->val;\\n                    head=head->next;\\n                }\\n                down--;\\n            }\\n            else   \\n            {\\n               for(int i=down;i>=top;i--) \\n                {\\n                    if(!head) return ans;\\n                    ans[i][left]= head->val;\\n                    head=head->next;\\n                }\\n                left++;  \\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437275,
                "title": "c-easy-linked-list-traversal-and-2d-spiral-traversal",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\n\\t\\t\\tvector<vector<int>> ans(m,vector<int>(n,-1));\\n\\t\\t\\tauto [sr,sc,er,ec] = make_tuple(0,0,m-1,n-1);\\n\\n\\t\\t\\twhile(head){\\n\\t\\t\\t\\tfor(int i=sc;i<=ec && head; i++){\\n\\t\\t\\t\\t\\tans[sr][i] = head->val;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsr++;\\n\\t\\t\\t\\tfor(int i=sr; i<=er and head; i++){\\n\\t\\t\\t\\t\\tans[i][ec] = head->val;;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tec--;\\n\\t\\t\\t\\tfor(int i=ec;i>=sc && head; i--){\\n\\t\\t\\t\\t\\tans[er][i] = head->val;;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ter--;\\n\\t\\t\\t\\tfor(int i=er;i>=sr && head; i--){\\n\\t\\t\\t\\t\\tans[i][sc] = head->val;;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsc++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\n\\t\\t\\tvector<vector<int>> ans(m,vector<int>(n,-1));\\n\\t\\t\\tauto [sr,sc,er,ec] = make_tuple(0,0,m-1,n-1);\\n\\n\\t\\t\\twhile(head){\\n\\t\\t\\t\\tfor(int i=sc;i<=ec && head; i++){\\n\\t\\t\\t\\t\\tans[sr][i] = head->val;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2417327,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    vector<vector<int>>vec(m,vector<int>(n));\\n    int s =0;\\n    int left =0;\\n    int right = n-1;\\n    int top = 0;\\n    int bottom = m-1;\\n    ListNode *cursor = head;\\n    while (s < m*n){\\n        for(int i = left; i<=right && s<m*n; i++){\\n            if(cursor == nullptr) {\\n                vec[top][i] = -1;\\n                s++;\\n            }else{\\n                vec[top][i] = cursor->val;\\n                cursor = cursor->next;\\n                s++;\\n            }\\n        }\\n        top++;\\n        for(int i = top; i<= bottom&& s<m*n; i++){\\n            if(cursor == nullptr) {\\n                vec[i][right] = -1;\\n                s++;\\n            }else{\\n                vec[i][right] = cursor->val;\\n                cursor = cursor->next;\\n                s++;\\n            }\\n        }\\n        right--;\\n        for (int i = right; i >=left && s<m*n; i--) {\\n            if(cursor == nullptr) {\\n                vec[bottom][i] = -1;\\n                s++;\\n            }else{\\n                vec[bottom][i] = cursor->val;\\n                cursor = cursor->next;\\n                s++;\\n            }\\n        }\\n        bottom--;\\n        for(int i = bottom; i>= top&& s<m*n; i--){\\n            if(cursor== nullptr) {\\n                vec[i][left] = -1;\\n                s++;\\n            }else{\\n                vec[i][left] = cursor->val;\\n                cursor = cursor->next;\\n                s++;\\n            }\\n        }\\n        left++;\\n    }\\n    return vec;\\n}\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n   vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    vector<vector<int>>vec(m,vector<int>(n));\\n    int s =0;\\n    int left =0;\\n    int right = n-1;\\n    int top = 0;\\n    int bottom = m-1;\\n    ListNode *cursor = head;\\n    while (s < m*n){\\n        for(int i = left; i<=right && s<m*n; i++){\\n            if(cursor == nullptr) {\\n                vec[top][i] = -1;\\n                s++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2384923,
                "title": "java-counting-round-and-predefined-border",
                "content": "Simulate each step and count total round of four directions\\n\\n```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n        int r = 0, c = 0, d = 0, x = 0, y = 0;\\n        int[] dx = new int[] {0, 1, 0, -1};        \\n        int[] dy = new int[] {1, 0, -1, 0};\\n        int[] border = new int[] {n - 1, m - 1, 0, 1};\\n        while (c < m * n) {\\n            if (head == null) {\\n                res[x][y] = -1;\\n            } else {\\n                res[x][y] = head.val;\\n                head = head.next;\\n            }\\n            \\n            if (d == 0 && y == border[d] - r) {\\n                d++;\\n            } else if (d == 1 && x == border[d] - r) {\\n                d++;\\n            } else if (d == 2 && y == border[d] + r) {\\n                d++;\\n            } else if (d == 3 && x == border[d] + r) {\\n                d = 0;\\n                r++;\\n            }\\n            \\n            x = x + dx[d];\\n            y = y + dy[d];\\n            \\n            c++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n        int r = 0, c = 0, d = 0, x = 0, y = 0;\\n        int[] dx = new int[] {0, 1, 0, -1};        \\n        int[] dy = new int[] {1, 0, -1, 0};\\n        int[] border = new int[] {n - 1, m - 1, 0, 1};\\n        while (c < m * n) {\\n            if (head == null) {\\n                res[x][y] = -1;\\n            } else {\\n                res[x][y] = head.val;\\n                head = head.next;\\n            }\\n            \\n            if (d == 0 && y == border[d] - r) {\\n                d++;\\n            } else if (d == 1 && x == border[d] - r) {\\n                d++;\\n            } else if (d == 2 && y == border[d] + r) {\\n                d++;\\n            } else if (d == 3 && x == border[d] + r) {\\n                d = 0;\\n                r++;\\n            }\\n            \\n            x = x + dx[d];\\n            y = y + dy[d];\\n            \\n            c++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381911,
                "title": "java-easy-optimize-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans=new int[m][n];\\n        for(int[] arr:ans){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        int rowBegin=0;\\n        int rowEnd=m-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        ListNode cur=head;\\n        \\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && cur!=null){\\n            \\n            for(int i=columnBegin;i<=columnEnd && cur!=null;i++){\\n                if(cur!=null){\\n                    ans[rowBegin][i]=cur.val;\\n                }\\n               \\n                    cur=cur.next;\\n                \\n                \\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd && cur!=null;i++){\\n               if(cur!=null){\\n                ans[i][columnEnd]=cur.val;\\n               }\\n                \\n                    cur=cur.next;\\n                \\n\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin && cur!=null;i--){\\n                if(cur!=null){\\n                ans[rowEnd][i]=cur.val;\\n                }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin && cur!=null;i--){\\n                  if(cur!=null){\\n                ans[i][columnBegin]=cur.val;\\n                  }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans=new int[m][n];\\n        for(int[] arr:ans){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        int rowBegin=0;\\n        int rowEnd=m-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        ListNode cur=head;\\n        \\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && cur!=null){\\n            \\n            for(int i=columnBegin;i<=columnEnd && cur!=null;i++){\\n                if(cur!=null){\\n                    ans[rowBegin][i]=cur.val;\\n                }\\n               \\n                    cur=cur.next;\\n                \\n                \\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd && cur!=null;i++){\\n               if(cur!=null){\\n                ans[i][columnEnd]=cur.val;\\n               }\\n                \\n                    cur=cur.next;\\n                \\n\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin && cur!=null;i--){\\n                if(cur!=null){\\n                ans[rowEnd][i]=cur.val;\\n                }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin && cur!=null;i--){\\n                  if(cur!=null){\\n                ans[i][columnBegin]=cur.val;\\n                  }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374292,
                "title": "python-simple-explained-using-layers-fast",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        # Initialize matrix with -1\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)] \\n        \\n        # Number of layers (times we need to move in spiral)\\n        layers = (min(m,n)+1)//2\\n        \\n        for layer in range(layers):\\n                 \\n            #Right\\n            \\n            for i in range(layer,n-layer):\\n                if head:\\n                    matrix[layer][i] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                \\n            # Down\\n            \\n            for i in range(layer+1,m-layer):\\n                if head:\\n                    matrix[i][n-layer-1] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                \\n            # Left\\n            \\n            for i in range(n-layer-2,layer-1,-1):\\n                if head:\\n                    matrix[m-layer-1][i] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                    \\n            # Up\\n            \\n            for i in range(m-layer-2,layer,-1):\\n                if head:\\n                    matrix[i][layer] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                    \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        # Initialize matrix with -1\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)] \\n        \\n        # Number of layers (times we need to move in spiral)\\n        layers = (min(m,n)+1)//2\\n        \\n        for layer in range(layers):\\n                 \\n            #Right\\n            \\n            for i in range(layer,n-layer):\\n                if head:\\n                    matrix[layer][i] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                \\n            # Down\\n            \\n            for i in range(layer+1,m-layer):\\n                if head:\\n                    matrix[i][n-layer-1] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                \\n            # Left\\n            \\n            for i in range(n-layer-2,layer-1,-1):\\n                if head:\\n                    matrix[m-layer-1][i] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                    \\n            # Up\\n            \\n            for i in range(m-layer-2,layer,-1):\\n                if head:\\n                    matrix[i][layer] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                    \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363867,
                "title": "c-most-intuitive-and-simple-to-understand-spiral-traversal-of-mtarix-ii",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // very easy simple \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        // spiral order clockwise mai fill kardo marix ko uske baad direct row by row print kardo matrix, ya direct\\n        // return kardo spiral order mai filling karke\\n        vector<vector<int>>v(m, vector<int>(n,-1));\\n        int startrow=0, endrow=m-1, startcol=0, endcol=n-1;\\n        \\n        while(startrow<=endrow and startcol<=endcol and head)\\n        {\\n            // first row\\n            for(int i=startcol;i<=endcol and head;i++){\\n                v[startrow][i] = head->val;\\n                head=head->next;\\n            }\\n            startrow++;\\n            \\n            for(int i=startrow;i<=endrow and head;i++){\\n                v[i][endcol] = head->val;\\n                head=head->next;\\n            }\\n            endcol--;\\n            \\n            for(int i=endcol;i>=startcol and head;i--){\\n                v[endrow][i] = head->val;\\n                head=head->next;\\n            }\\n            endrow--;\\n            \\n            for(int i=endrow;i>=startrow and head;i--){\\n                v[i][startcol] = head->val;\\n                head=head->next;\\n            }\\n            startcol++;\\n        }\\n        return v;\\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // very easy simple \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        // spiral order clockwise mai fill kardo marix ko uske baad direct row by row print kardo matrix, ya direct\\n        // return kardo spiral order mai filling karke\\n        vector<vector<int>>v(m, vector<int>(n,-1));\\n        int startrow=0, endrow=m-1, startcol=0, endcol=n-1;\\n        \\n        while(startrow<=endrow and startcol<=endcol and head)\\n        {\\n            // first row\\n            for(int i=startcol;i<=endcol and head;i++){\\n                v[startrow][i] = head->val;\\n                head=head->next;\\n            }\\n            startrow++;\\n            \\n            for(int i=startrow;i<=endrow and head;i++){\\n                v[i][endcol] = head->val;\\n                head=head->next;\\n            }\\n            endcol--;\\n            \\n            for(int i=endcol;i>=startcol and head;i--){\\n                v[endrow][i] = head->val;\\n                head=head->next;\\n            }\\n            endrow--;\\n            \\n            for(int i=endrow;i>=startrow and head;i--){\\n                v[i][startcol] = head->val;\\n                head=head->next;\\n            }\\n            startcol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363802,
                "title": "java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n      \\n        //fill array with -1 (so no need to fill -1, so we can straightaway return matrix after finish traversing linked list\\n        for (int[] row: res){\\n            Arrays.fill(row, -1);\\n        }\\n      \\n        //this keep track of current starting and ending point for both row and column (will be updated in the loop)\\n        int rowStart = 0, rowEnd = m-1;\\n        int colStart = 0, colEnd = n-1;\\n        \\n        //row and col keep track of current coordinate to be filled\\n        int row = 0, col = 0;\\n      \\n        while(head != null){\\n          \\n            //to check whether to start from left or right, col equals colStart means the direction is from left to right and vice versa (else condition: right to left)\\n            if(col == colStart || row == rowStart){\\n              \\n                //fill up column from colStart until colEnd while traversing the list, incrementing col)\\n                while(col <= colEnd && head != null){\\n                    res[row][col] = head.val;\\n                    head = head.next;\\n                    col++;\\n                }\\n                //reset col to colEnd (because we might have incremented col by extra 1 in while loop)\\n                //cannot simply use col-- because we might not even enter while loop\\n                col = colEnd;\\n              \\n                //once we have filled up one column, means starting row had been incremented by 1, and we set row to be rowStart\\n                rowStart++;\\n                row = rowStart;\\n                \\n                //fill up row from rowStart until rowEnd, increment row\\n                while(row <= rowEnd && head != null){\\n                    res[row][col] = head.val;\\n                    head = head.next;\\n                    row++;\\n                }\\n                //similar explanation to above;\\n                row = rowEnd;\\n              \\n                //once we have filled up one row means colEnd had decreased\\n                colEnd--;\\n                col = colEnd;\\n            } else{\\n              \\n                //similar explanation, just different direction (refer to comments above)\\n                //filling up column\\n                while(col >= colStart && head != null){\\n                    res[row][col] = head.val;\\n                    col--;\\n                    head = head.next;\\n                }\\n                rowEnd--;\\n                row = rowEnd;\\n                col = colStart;\\n                \\n                //filling up rows\\n                while(row >= rowStart && head != null){\\n                    res[row][col] = head.val;\\n                    row--;\\n                    head = head.next;\\n                }\\n                colStart++; \\n                row = rowStart;\\n                col = colStart;            \\n            }\\n        } \\n        return res;\\n    }\\n}\\n\\n//Runtime: 12 ms, faster than 85.35% of Java online submissions for Spiral Matrix IV.\\n//Memory Usage: 244.6 MB, less than 54.47% of Java online submissions for Spiral Matrix IV.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n      \\n        //fill array with -1 (so no need to fill -1, so we can straightaway return matrix after finish traversing linked list\\n        for (int[] row: res){\\n            Arrays.fill(row, -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2340039,
                "title": "python-easiest-way-to-understand-simple-clean",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix=[[0 for i in range(n)] for j in range(m)]\\n        topRow=0\\n        bottomRow=m-1\\n        leftCol=0\\n        rightCol=n-1\\n        curr=head\\n      \\n        while(leftCol<rightCol+1 and topRow<bottomRow+1):\\n            #topRow\\n            for j in range(leftCol,rightCol+1):\\n                if curr:\\n                    matrix[topRow][j]=curr.val\\n                    curr=curr.next\\n                else:\\n                    matrix[topRow][j]=-1\\n            topRow+=1\\n          \\n            #RightCol\\n            for i in range(topRow,bottomRow+1):\\n                if curr:\\n                    matrix[i][rightCol]=curr.val\\n                    curr=curr.next\\n                else:\\n                    matrix[i][rightCol]=-1\\n            rightCol-=1\\n            \\n            #bottomRow\\n            if topRow<bottomRow:\\n                for j in range(rightCol,leftCol-1,-1):\\n                    if curr:\\n                        matrix[bottomRow][j]=curr.val\\n                        curr=curr.next\\n                    else:\\n                        matrix[bottomRow][j]=-1\\n                bottomRow-=1\\n                \\n            #leftCol    \\n            if leftCol<rightCol:\\n                for i in range(bottomRow,topRow-1,-1):\\n                    if curr:\\n                        matrix[i][leftCol]=curr.val\\n                        curr=curr.next\\n                    else:\\n                        matrix[i][leftCol]=-1\\n                leftCol+=1\\n            \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix=[[0 for i in range(n)] for j in range(m)]\\n        topRow=0\\n        bottomRow=m-1\\n        leftCol=0\\n        rightCol=n-1\\n        curr=head\\n      \\n        while(leftCol<rightCol+1 and topRow<bottomRow+1):\\n            #topRow\\n            for j in range(leftCol,rightCol+1):\\n                if curr:\\n                    matrix[topRow][j]=curr.val\\n                    curr=curr.next\\n                else:\\n                    matrix[topRow][j]=-1\\n            topRow+=1\\n          \\n            #RightCol\\n            for i in range(topRow,bottomRow+1):\\n                if curr:\\n                    matrix[i][rightCol]=curr.val\\n                    curr=curr.next\\n                else:\\n                    matrix[i][rightCol]=-1\\n            rightCol-=1\\n            \\n            #bottomRow\\n            if topRow<bottomRow:\\n                for j in range(rightCol,leftCol-1,-1):\\n                    if curr:\\n                        matrix[bottomRow][j]=curr.val\\n                        curr=curr.next\\n                    else:\\n                        matrix[bottomRow][j]=-1\\n                bottomRow-=1\\n                \\n            #leftCol    \\n            if leftCol<rightCol:\\n                for i in range(bottomRow,topRow-1,-1):\\n                    if curr:\\n                        matrix[i][leftCol]=curr.val\\n                        curr=curr.next\\n                    else:\\n                        matrix[i][leftCol]=-1\\n                leftCol+=1\\n            \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332849,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] res = new int[m][n];\\n        ListNode temp = head;\\n        \\n        for(int[] row: res)\\n            Arrays.fill(row, -1);\\n        \\n        int rowBegin=0, rowEnd=m-1;\\n        int colBegin=0, colEnd=n-1;\\n        \\n        while(rowBegin<=rowEnd && colBegin<=colEnd && temp!=null){\\n            \\n            for(int i=colBegin; i<=colEnd && temp!=null; i++){\\n                res[rowBegin][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n            rowBegin++;\\n            \\n            for(int i=rowBegin; i<=rowEnd && temp!=null; i++){\\n                res[i][colEnd]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n            colEnd--;\\n            \\n            if(rowBegin<=rowEnd){\\n                for(int i=colEnd; i>=colBegin && temp!=null; i--){\\n                    res[rowEnd][i]=temp.val;\\n                    temp=temp.next;\\n                }\\n            }\\n            \\n            rowEnd--;\\n            \\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd; i>=rowBegin && temp!=null; i--){\\n                    res[i][colBegin]=temp.val;\\n                    temp=temp.next;\\n                }\\n            }\\n            \\n            colBegin++;\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] res = new int[m][n];\\n        ListNode temp = head;\\n        \\n        for(int[] row: res)\\n            Arrays.fill(row, -1);\\n        \\n        int rowBegin=0, rowEnd=m-1;\\n        int colBegin=0, colEnd=n-1;\\n        \\n        while(rowBegin<=rowEnd && colBegin<=colEnd && temp!=null){\\n            \\n            for(int i=colBegin; i<=colEnd && temp!=null; i++){\\n                res[rowBegin][i]=temp.val;\\n                temp=temp.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2300228,
                "title": "java-faster-than-99-97-less-space-than-91-38-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/1b365162-af2e-4f40-ba51-08ffdd2dd744_1658161936.9575908.png)\\n\\n\\n```\\n// Time complexity = O(n*m)\\n// Space complexity = O(n*m) or O(1) if we ignore the results array\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] result = new int[m][n];\\n        ListNode curr = head;\\n        int top = 0, right = n-1, down = m-1, left = 0;\\n        \\n        while(top <= down && left <= right) {\\n            //left to right\\n            for(int i = left; i <= right; i++) {\\n                if(curr == null) {\\n                    result[top][i] = -1;\\n                }\\n                else {\\n                    result[top][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            \\n            //right to bottom\\n            for(int i = top + 1; i <= down; i++) {\\n                if(curr == null) {\\n                    result[i][right] = -1;\\n                }\\n                else {\\n                    result[i][right] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            \\n            //bottom to left\\n            //We check first if top < down, because if they are equal then this will \\n            //overwrite the \"left to right\" step above\\n            if(top < down) {\\n                for(int i = right - 1; i >= left; i--) {\\n                    if(curr == null) {\\n                        result[down][i] = -1;\\n                    }\\n                    else {\\n                        result[down][i] = curr.val;\\n                        curr = curr.next;\\n                    }\\n                }\\n            }\\n            \\n            //left to top\\n            //We check first if left < right, because if they are equal then this will\\n            //overwrite the \"right to bottom\" step above\\n            if(left < right) {\\n                for(int i = down - 1; i > top; i--) {\\n                    if(curr == null) {\\n                        result[i][left] = -1;\\n                    }\\n                    else {\\n                        result[i][left] = curr.val;\\n                        curr = curr.next;\\n                    }\\n                }\\n            }\\n            \\n            top++; left++; right--; down--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity = O(n*m)\\n// Space complexity = O(n*m) or O(1) if we ignore the results array\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] result = new int[m][n];\\n        ListNode curr = head;\\n        int top = 0, right = n-1, down = m-1, left = 0;\\n        \\n        while(top <= down && left <= right) {\\n            //left to right\\n            for(int i = left; i <= right; i++) {\\n                if(curr == null) {\\n                    result[top][i] = -1;\\n                }\\n                else {\\n                    result[top][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            \\n            //right to bottom\\n            for(int i = top + 1; i <= down; i++) {\\n                if(curr == null) {\\n                    result[i][right] = -1;\\n                }\\n                else {\\n                    result[i][right] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            \\n            //bottom to left\\n            //We check first if top < down, because if they are equal then this will \\n            //overwrite the \"left to right\" step above\\n            if(top < down) {\\n                for(int i = right - 1; i >= left; i--) {\\n                    if(curr == null) {\\n                        result[down][i] = -1;\\n                    }\\n                    else {\\n                        result[down][i] = curr.val;\\n                        curr = curr.next;\\n                    }\\n                }\\n            }\\n            \\n            //left to top\\n            //We check first if left < right, because if they are equal then this will\\n            //overwrite the \"right to bottom\" step above\\n            if(left < right) {\\n                for(int i = down - 1; i > top; i--) {\\n                    if(curr == null) {\\n                        result[i][left] = -1;\\n                    }\\n                    else {\\n                        result[i][left] = curr.val;\\n                        curr = curr.next;\\n                    }\\n                }\\n            }\\n            \\n            top++; left++; right--; down--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267956,
                "title": "c-easy-to-understand-iterative",
                "content": "vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        int row=m;\\n        int col=n;\\n       \\n        ListNode* temp=head;\\n        \\n        vector<vector<int>> result(m,vector<int>(n,-1));\\n        \\n        int top=0,left=0;\\n        int bottom=row-1,right=col-1;\\n        \\n        while(left <= right && top <= bottom){\\n            \\n            \\n            //PROCESS ROW\\n            for(int i=left;i<=right;i++){                \\n                         \\n                if(temp!=NULL){\\n                    result[top][i]=temp->val;                   \\n                    temp=temp->next;\\n                }\\n                \\n            }\\n            top++;\\n            \\n            // PROCESS COLUMN\\n            for(int i=top;i<=bottom;i++){\\n                \\n               if(temp!=NULL){\\n                    result[i][right]=temp->val;                    \\n                    temp=temp->next;\\n                }\\n             \\n                \\n            }\\n            right--;\\n            \\n            //PROCESS ROW\\n            for(int i=right;i>=left;i--){\\n                \\n                if(temp!=NULL){\\n                    result[bottom][i]=temp->val;                   \\n                    temp=temp->next;\\n                }\\n                \\n               \\n            }\\n            bottom--;\\n            \\n            // PROCESS COLUMN\\n            \\n            for(int i=bottom;i>=top;i--){\\n                \\n               if(temp!=NULL){\\n                    result[i][left]=temp->val;                   \\n                    temp=temp->next;\\n                }  \\n                \\n            }\\n            left++;\\n            \\n            \\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        int row=m;\\n        int col=n;\\n       \\n        ListNode* temp=head;\\n        \\n        vector<vector<int>> result(m,vector<int>(n,-1));\\n        \\n        int top=0,left=0;\\n        int bottom=row-1,right=col-1;\\n        \\n        while(left <= right && top <= bottom){\\n            \\n            \\n            //PROCESS ROW\\n            for(int i=left;i<=right;i++){                \\n                         \\n                if(temp!=NULL){\\n                    result[top][i]=temp->val;                   \\n                    temp=temp->next;\\n                }\\n                \\n            }\\n            top++;\\n            \\n            // PROCESS COLUMN\\n            for(int i=top;i<=bottom;i++){\\n                \\n               if(temp!=NULL){\\n                    result[i][right]=temp->val;                    \\n                    temp=temp->next;\\n                }\\n             \\n                \\n            }\\n            right--;\\n            \\n            //PROCESS ROW\\n            for(int i=right;i>=left;i--){\\n                \\n                if(temp!=NULL){\\n                    result[bottom][i]=temp->val;                   \\n                    temp=temp->next;\\n                }\\n                \\n               \\n            }\\n            bottom--;\\n            \\n            // PROCESS COLUMN\\n            \\n            for(int i=bottom;i>=top;i--){\\n                \\n               if(temp!=NULL){\\n                    result[i][left]=temp->val;                   \\n                    temp=temp->next;\\n                }  \\n                \\n            }\\n            left++;\\n            \\n            \\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2264949,
                "title": "c-simplest-solution-with-comments-single-loop-traversal",
                "content": "\\n ```\\n class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) \\n    {\\n          int r = m;//rows\\n          int c = n;//columns\\n\\t\\t  \\n          int i ; // for traversal\\n\\t      int rowindex = 0, colindex = 0; // starting positions of row and colom\\n          vector<vector<int>> matrix(r,vector<int> (c)); // matrix with r rows and c columns\\n\\t\\t  \\n          int l;\\n    \\n          while(rowindex<r and colindex<c)\\n          { \\n                  //left to right traversal\\n                  for(i=colindex;i<c;i++)\\n                  {   \\n                        if(head!=NULL)\\n                        {\\n                            l = head->val;\\n                            head = head->next;\\n                        }\\n                        else l = -1;\\n                      \\n                        matrix[rowindex][i] = l;\\n                   }\\n        \\n                  rowindex++; // first row printed\\n        \\n                 //top to bottom traversal\\n                for(i=rowindex;i<r;i++)\\n                {   \\n                     if(head!=NULL)\\n                     {\\n                         l = head->val;\\n                         head = head->next;\\n                     }\\n                     else l = -1;\\n                    \\n                     matrix[i][c-1] = l;\\n                }\\n        \\n                c--; // last column printed\\n        \\n                //right to left traversal\\n                if(rowindex<r)\\n                {\\n                   for(i = c-1; i>=colindex; i--)\\n                   {   \\n                        if(head!=NULL)\\n                        {\\n                             l = head->val;\\n                             head = head->next;\\n                        }\\n                        else l = -1;\\n                       \\n                        matrix[r-1][i] = l;\\n                    }\\n            \\n                  r--; // last row printed\\n               }\\n         \\n               //bottom to top traversal\\n              if(colindex<c)\\n              {\\n                    for(i = r-1; i >= rowindex; i--)\\n                    {   \\n                         if(head!=NULL)\\n                         {\\n                            l = head->val;\\n                           head = head->next;\\n                          }\\n                         else l = -1;\\n                         matrix[i][colindex] = l;\\n                    }\\n           \\n                   colindex++; // first column printed\\n              }\\n        \\n             }//end of while loop\\n    \\n           return matrix;\\n    }\\n};\\n\\nPlease do consider upvoting if it helped you.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) \\n    {\\n          int r = m;//rows\\n          int c = n;//columns\\n\\t\\t  \\n          int i ; // for traversal\\n\\t      int rowindex = 0, colindex = 0; // starting positions of row and colom\\n          vector<vector<int>> matrix(r,vector<int> (c)); // matrix with r rows and c columns\\n\\t\\t  \\n          int l;\\n    \\n          while(rowindex<r and colindex<c)\\n          { \\n                  //left to right traversal\\n                  for(i=colindex;i<c;i++)\\n                  {   \\n                        if(head!=NULL)\\n                        {\\n                            l = head->val;\\n                            head = head->next;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2260503,
                "title": "c-14-lines-o-n-easy-to-understand-code",
                "content": "1. Every time x and y go out of bounds, change direction. \\n2. when next cell is filled (not equal to -1), change direction immediately. \\n3. Direction index: curPos = (curPos + 1) % 4\\n```\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        vector<pair<int, int>> dirs = {{0, 1},  {1, 0}, {0, -1}, {-1, 0}};\\n        int curPos = 0, x = 0, y = 0;\\n        while(head) {\\n            if(x == m || y == n || x < 0 || y < 0 || res[x][y] != -1) {\\n                x -= dirs[curPos].first, y -= dirs[curPos].second;\\n                curPos = (curPos + 1) % 4;\\n                x += dirs[curPos].first, y += dirs[curPos].second;\\n            }\\n            res[x][y] = head->val;\\n            head = head->next;\\n            x += dirs[curPos].first, y += dirs[curPos].second;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        vector<pair<int, int>> dirs = {{0, 1},  {1, 0}, {0, -1}, {-1, 0}};\\n        int curPos = 0, x = 0, y = 0;\\n        while(head) {\\n            if(x == m || y == n || x < 0 || y < 0 || res[x][y] != -1) {\\n                x -= dirs[curPos].first, y -= dirs[curPos].second;\\n                curPos = (curPos + 1) % 4;\\n                x += dirs[curPos].first, y += dirs[curPos].second;\\n            }\\n            res[x][y] = head->val;\\n            head = head->next;\\n            x += dirs[curPos].first, y += dirs[curPos].second;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2257399,
                "title": "easy-to-understand-recursive-solution",
                "content": "class Solution {\\npublic:\\n    void print(vector<vector<int>> &arr, int i, int j, int m, int n,ListNode *k)\\n{\\n    // If i or j lies outside the matrix\\n    if (i >= m or j >= n)\\n        return;\\n  \\n    // Print First Row\\n    for (int p = j; p < n; p++)\\n    {\\n        if(k!=nullptr)\\n        {\\n            arr[i][p]=k->val;\\n            k=k->next;\\n        }\\n        else\\n        {\\n            arr[i][p]=-1;\\n        }\\n    }\\n       // cout << arr[i][p] << \" \";\\n  \\n    // Print Last Column\\n    for (int p = i + 1; p < m; p++)\\n    {\\n           if(k!=nullptr)\\n        {\\n            arr[p][n-1]=k->val;\\n            k=k->next;\\n        }\\n        else\\n        {\\n            arr[p][n-1]=-1;\\n        }\\n    }\\n      //  cout << arr[p][n - 1] << \" \";\\n  \\n    // Print Last Row, if Last and\\n    // First Row are not same\\n    if ((m - 1) != i){\\n        for (int p = n - 2; p >= j; p--)\\n        {\\n               if(k!=nullptr)\\n        {\\n            arr[m-1][p]=k->val;\\n            k=k->next;\\n        }\\n        else\\n        {\\n            arr[m-1][p]=-1;\\n        } \\n        }\\n           // cout << arr[m - 1][p] << \" \";\\n    }\\n  \\n    // Print First Column,  if Last and\\n    // First Column are not same\\n    if ((n - 1) != j){\\n        for (int p = m - 2; p > i; p--){\\n                if(k!=nullptr)\\n        {\\n            arr[p][j]=k->val;\\n            k=k->next;\\n        }\\n        else\\n        {\\n            arr[p][j]=-1;\\n        }\\n           // cout << arr[p][j] << \" \";\\n        }\\n    }\\n    print(arr, i + 1, j + 1, m - 1, n - 1,k);\\n}\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int> > arr(m, vector<int>(n,-1)); \\n      \\n        print(arr,0,0,m,n,head);\\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    void print(vector<vector<int>> &arr, int i, int j, int m, int n,ListNode *k)\\n{\\n    // If i or j lies outside the matrix\\n    if (i >= m or j >= n)\\n        return;\\n  \\n    // Print First Row\\n    for (int p = j; p < n; p++)\\n    {\\n        if(k!=nullptr)\\n        {\\n            arr[i][p]=k->val;\\n            k=k->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2252723,
                "title": "faster-than-86-java",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        int orientation = 0;\\n        int lasti = 0;\\n        int lastj = 0;\\n        int[][] visited = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                arr[i][j] = -1;\\n            }\\n        }\\n        l1:while(true){\\n            if(orientation == 0){\\n                for(;;){\\n                    if(lastj == n || visited[lasti][lastj] == 1){\\n                        orientation = (orientation + 1) % 4;\\n                        lastj--;\\n                        lasti++;\\n                        continue l1;\\n                    } \\n                    visited[lasti][lastj] = 1;\\n                    arr[lasti][lastj++] = head.val;\\n                    head = head.next;\\n                    if(head == null){\\n                        break l1;\\n                    }\\n                }\\n            }\\n             if(orientation == 1){\\n                for(;;){\\n                    if(lasti == m || visited[lasti][lastj] == 1){\\n                        orientation = (orientation + 1) % 4;\\n                        lasti--;\\n                        lastj--;\\n                        continue l1;\\n                    } \\n                      visited[lasti][lastj] = 1;\\n                    arr[lasti++][lastj] = head.val;\\n                    head = head.next;\\n                      if(head == null){\\n                        break l1;\\n                    }\\n                }\\n            }\\n             if(orientation == 2){\\n                for(;;){\\n                    if(lastj < 0 || visited[lasti][lastj] == 1){\\n                        orientation = (orientation + 1) % 4;\\n                        lastj++;\\n                        lasti--;\\n                        continue l1;\\n                    } \\n                      visited[lasti][lastj] = 1;\\n                    arr[lasti][lastj--] = head.val;\\n                    head = head.next;\\n                      if(head == null){\\n                        break l1;\\n                    }\\n                }\\n            }\\n             if(orientation == 3){\\n                for(;;){\\n                    if(lasti < 0 || visited[lasti][lastj] == 1){\\n                        orientation = (orientation + 1) % 4;\\n                        lasti++;\\n                        lastj++;\\n                        continue l1;\\n                    } \\n                      visited[lasti][lastj] = 1;\\n                    arr[lasti--][lastj] = head.val;\\n                    head = head.next;\\n                      if(head == null){\\n                        break l1;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        int orientation = 0;\\n        int lasti = 0;\\n        int lastj = 0;\\n        int[][] visited = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                arr[i][j] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2247181,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    bool CheckMove(vector<vector<int>> &matrix, char &ch, int i, int j, int m, int n)\\n    {\\n        if(ch == \\'R\\' && j+1 < n && matrix[i][j+1] == -1)\\n            return true;\\n        if(ch == \\'D\\' && i+1 < m && matrix[i+1][j] == -1)\\n            return true;\\n        if(ch == \\'L\\' && j-1 >= 0 && matrix[i][j-1] == -1)\\n            return true;\\n        if(ch == \\'U\\' && i-1 >= 0 && matrix[i-1][j] == -1)\\n            return true;\\n        return false;\\n    }\\n    pair<char, pair<int, int>> NextMove(char &ch, int i, int j, int m, int n)\\n    {\\n        if(ch == \\'R\\')\\n            return {\\'D\\',{i+1,j}};\\n        else if(ch == \\'D\\')\\n            return {\\'L\\',{i,j-1}};\\n        else if(ch == \\'U\\')\\n            return {\\'R\\', {i, j+1}};\\n        else\\n            return {\\'U\\',{i-1, j}};\\n    }\\n    void dfs(vector<vector<int>> &matrix, int i, int j, int m, int n, ListNode* head, char &ch)\\n    {\\n        if(!head) return;\\n        matrix[i][j] = head->val;\\n        if(CheckMove(matrix, ch, i, j, m, n))\\n        {\\n            if(ch == \\'R\\')\\n                dfs(matrix, i, j+1, m, n, head->next, ch);\\n            else if(ch == \\'D\\')\\n                dfs(matrix, i+1, j, m, n, head->next, ch);\\n            else if(ch == \\'U\\')\\n                dfs(matrix, i-1, j, m, n, head->next, ch);\\n            else if(ch == \\'L\\')\\n                dfs(matrix, i, j-1, m, n, head->next, ch);\\n        }\\n        else\\n        {\\n            pair<char,pair<int,int>> t = NextMove(ch, i, j, m, n);\\n            dfs(matrix, t.second.first, t.second.second, m, n, head->next, t.first);\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        char ch = \\'R\\';\\n        dfs(matrix, 0, 0, m, n, head, ch);\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    bool CheckMove(vector<vector<int>> &matrix, char &ch, int i, int j, int m, int n)\\n    {\\n        if(ch == \\'R\\' && j+1 < n && matrix[i][j+1] == -1)\\n            return true;\\n        if(ch == \\'D\\' && i+1 < m && matrix[i+1][j] == -1)\\n            return true;\\n        if(ch == \\'L\\' && j-1 >= 0 && matrix[i][j-1] == -1)\\n            return true;\\n        if(ch == \\'U\\' && i-1 >= 0 && matrix[i-1][j] == -1)\\n            return true;\\n        return false;\\n    }\\n    pair<char, pair<int, int>> NextMove(char &ch, int i, int j, int m, int n)\\n    {\\n        if(ch == \\'R\\')\\n            return {\\'D\\',{i+1,j}};\\n        else if(ch == \\'D\\')\\n            return {\\'L\\',{i,j-1}};\\n        else if(ch == \\'U\\')\\n            return {\\'R\\', {i, j+1}};\\n        else\\n            return {\\'U\\',{i-1, j}};\\n    }\\n    void dfs(vector<vector<int>> &matrix, int i, int j, int m, int n, ListNode* head, char &ch)\\n    {\\n        if(!head) return;\\n        matrix[i][j] = head->val;\\n        if(CheckMove(matrix, ch, i, j, m, n))\\n        {\\n            if(ch == \\'R\\')\\n                dfs(matrix, i, j+1, m, n, head->next, ch);\\n            else if(ch == \\'D\\')\\n                dfs(matrix, i+1, j, m, n, head->next, ch);\\n            else if(ch == \\'U\\')\\n                dfs(matrix, i-1, j, m, n, head->next, ch);\\n            else if(ch == \\'L\\')\\n                dfs(matrix, i, j-1, m, n, head->next, ch);\\n        }\\n        else\\n        {\\n            pair<char,pair<int,int>> t = NextMove(ch, i, j, m, n);\\n            dfs(matrix, t.second.first, t.second.second, m, n, head->next, t.first);\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        char ch = \\'R\\';\\n        dfs(matrix, 0, 0, m, n, head, ch);\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235342,
                "title": "mine-is-much-simpler-python3",
                "content": "**Like it ? Please Upvote !**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        \\n        result = [[-1]*n for i in range(m)]\\n        \\n        top,bottom,left,right=0,m-1,0,n-1\\n        \\n        direction = 0\\n        \\n        while head and left<=right and top<=bottom:\\n            \\n            if direction==0:\\n                for i in range(left,right+1):\\n                    if head:\\n                        result[top][i] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                top += 1\\n            \\n            elif direction==1:\\n                for i in range(top,bottom+1):\\n                    if head:\\n                        result[i][right] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                right -= 1\\n            \\n            elif direction==2:\\n                for i in range(right,left-1,-1):\\n                    if head:\\n                        result[bottom][i] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                bottom -= 1\\n                \\n            else:\\n                for i in range(bottom,top-1,-1):\\n                    if head:\\n                        result[i][left] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                left += 1\\n                \\n            direction = (direction + 1)%4\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        \\n        result = [[-1]*n for i in range(m)]\\n        \\n        top,bottom,left,right=0,m-1,0,n-1\\n        \\n        direction = 0\\n        \\n        while head and left<=right and top<=bottom:\\n            \\n            if direction==0:\\n                for i in range(left,right+1):\\n                    if head:\\n                        result[top][i] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                top += 1\\n            \\n            elif direction==1:\\n                for i in range(top,bottom+1):\\n                    if head:\\n                        result[i][right] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                right -= 1\\n            \\n            elif direction==2:\\n                for i in range(right,left-1,-1):\\n                    if head:\\n                        result[bottom][i] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                bottom -= 1\\n                \\n            else:\\n                for i in range(bottom,top-1,-1):\\n                    if head:\\n                        result[i][left] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                left += 1\\n                \\n            direction = (direction + 1)%4\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234240,
                "title": "c-implementation-based-on-spiral-matrix-ii-o-n-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrix(int n, int m, ListNode *head)\\n{\\n    vector<vector<int>> ans(n, vector<int>(m,-1));\\n    int top = 0, bottom = n - 1, left = 0, right = m - 1;\\n    int count = 1, dir = 0;\\n    while (head!=NULL)\\n    {\\n        // Top Wall\\n        for (int i = left; i <= right && head!=NULL; i++)\\n        {\\n            ans[top][i] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        top++;\\n        // Right Wall\\n        for (int i = top; i <= bottom && head!=NULL; i++)\\n        {\\n            ans[i][right] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        right--;\\n\\n        // Bottom Wall\\n        for (int i = right; i >= left && head!=NULL; i--)\\n        {\\n            ans[bottom][i] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        bottom--;\\n\\n        // Left Wall\\n        for (int i = bottom; i >= top && head!=NULL; i--)\\n        {\\n            ans[i][left] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        left++;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrix(int n, int m, ListNode *head)\\n{\\n    vector<vector<int>> ans(n, vector<int>(m,-1));\\n    int top = 0, bottom = n - 1, left = 0, right = m - 1;\\n    int count = 1, dir = 0;\\n    while (head!=NULL)\\n    {\\n        // Top Wall\\n        for (int i = left; i <= right && head!=NULL; i++)\\n        {\\n            ans[top][i] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        top++;\\n        // Right Wall\\n        for (int i = top; i <= bottom && head!=NULL; i++)\\n        {\\n            ans[i][right] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        right--;\\n\\n        // Bottom Wall\\n        for (int i = right; i >= left && head!=NULL; i--)\\n        {\\n            ans[bottom][i] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        bottom--;\\n\\n        // Left Wall\\n        for (int i = bottom; i >= top && head!=NULL; i--)\\n        {\\n            ans[i][left] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        left++;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234131,
                "title": "rust-solution-using-direction-vector",
                "content": "~~~\\n       // direction vector: going right->down->left->up cycle \\n        let dirs: [[i32; 2]; 4] = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\t\\n        let (m, n, mut i, mut j) = (m as usize, n as usize, 0 as usize, 0 as usize);\\n        let mut curr = &head;\\n        let mut ret = vec![vec![-1; n]; m];\\n        let mut d: usize = 0;\\n        \\n        while curr.is_some() {\\n            if let Some(ref node) = curr {\\n                ret[i][j] = node.val;\\n                curr = &node.next;\\n            }\\n            \\n            let x: i32 = i as i32 + dirs[d][0];\\n            let y: i32 = j as i32 + dirs[d][1];\\n            \\n\\t\\t\\t// need to change direction?\\n            if x < 0 || x == m as i32 || y < 0 || y == n as i32 || ret[x as usize][y as usize] != -1 {\\n                d = (d + 1) % 4;\\n            }\\n            \\n            i = (i as i32 + dirs[d][0]) as usize;\\n            j = (j as i32 + dirs[d][1]) as usize;\\n        }\\n        \\n        ret\\n~~~",
                "solutionTags": [],
                "code": "~~~\\n       // direction vector: going right->down->left->up cycle \\n        let dirs: [[i32; 2]; 4] = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\t\\n        let (m, n, mut i, mut j) = (m as usize, n as usize, 0 as usize, 0 as usize);\\n        let mut curr = &head;\\n        let mut ret = vec![vec![-1; n]; m];\\n        let mut d: usize = 0;\\n        \\n        while curr.is_some() {\\n            if let Some(ref node) = curr {\\n                ret[i][j] = node.val;\\n                curr = &node.next;\\n            }\\n            \\n            let x: i32 = i as i32 + dirs[d][0];\\n            let y: i32 = j as i32 + dirs[d][1];\\n            \\n\\t\\t\\t// need to change direction?\\n            if x < 0 || x == m as i32 || y < 0 || y == n as i32 || ret[x as usize][y as usize] != -1 {\\n                d = (d + 1) % 4;\\n            }\\n            \\n            i = (i as i32 + dirs[d][0]) as usize;\\n            j = (j as i32 + dirs[d][1]) as usize;\\n        }\\n        \\n        ret\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2233467,
                "title": "c-easy-solution-little-modification-in-spiral-matrix",
                "content": "```\\n vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n         vector<vector<int>>ans(m,vector<int>(n,-1));\\n        ListNode *cur=head;\\n        int row=m;\\n        int col=n;\\n        int r=0,c=0;\\n        while(r<row && c<col && cur)\\n        {\\n          // for row from begining\\n          for(int i=c;i<col && cur!=NULL;i++)\\n          {\\n            ans[r][i]=cur->val;\\n            cur=cur->next;\\n          }\\n          r++;\\n          // for col from end\\n          for(int i=r;i<row && cur!=NULL;i++)\\n          {\\n            ans[i][col-1]=cur->val;\\n             cur=cur->next;\\n          }\\n          col--;\\n          if(r<row)\\n          {   \\n            // for row from end;\\n            for(int i=col-1;i>=c && cur!=NULL;i--)\\n          {\\n            ans[row-1][i]=cur->val;\\n               cur=cur->next;\\n          }\\n            row--;\\n          }\\n          \\n          if(c<col)\\n          {  // for col from start\\n            for(int i=row-1;i>=r && cur!=NULL;i--)\\n                {\\n                    ans[i][c]=cur->val;\\n                      cur=cur->next;\\n                }\\n                c++;\\n          }\\n          \\n        }\\n      return ans;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n         vector<vector<int>>ans(m,vector<int>(n,-1));\\n        ListNode *cur=head;\\n        int row=m;\\n        int col=n;\\n        int r=0,c=0;\\n        while(r<row && c<col && cur)\\n        {\\n          // for row from begining\\n          for(int i=c;i<col && cur!=NULL;i++)\\n          {\\n            ans[r][i]=cur->val;\\n            cur=cur->next;\\n          }\\n          r++;\\n          // for col from end\\n          for(int i=r;i<row && cur!=NULL;i++)\\n          {\\n            ans[i][col-1]=cur->val;\\n             cur=cur->next;\\n          }\\n          col--;\\n          if(r<row)\\n          {   \\n            // for row from end;\\n            for(int i=col-1;i>=c && cur!=NULL;i--)\\n          {\\n            ans[row-1][i]=cur->val;\\n               cur=cur->next;\\n          }\\n            row--;\\n          }\\n          \\n          if(c<col)\\n          {  // for col from start\\n            for(int i=row-1;i>=r && cur!=NULL;i--)\\n                {\\n                    ans[i][c]=cur->val;\\n                      cur=cur->next;\\n                }\\n                c++;\\n          }\\n          \\n        }\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2233140,
                "title": "c-easy-to-understand-iterative-spiral-beginners-friendly",
                "content": "```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* curr=head;\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int top=0,right=n-1,down=m-1,left=0;\\n        int t=0;\\n        while(curr!=NULL && t<=m*n){\\n            for(int i=left;i<=right &&curr!=NULL;i++){\\n                ans[top][i]=curr->val;\\n                curr=curr->next;\\n                t++;\\n            }\\n            top++;\\n            for(int i=top;i<=down && curr!=NULL;i++){\\n                ans[i][right]=curr->val;\\n                curr=curr->next;\\n                t++;\\n            }\\n            right--;\\n            if(top<=down){\\n            for(int i=right;i>=left &&curr!=NULL;i--){\\n                ans[down][i]=curr->val;\\n                curr=curr->next;\\n                t++;\\n                }\\n            }\\n            down--;\\n            if(left<=right){\\n            for(int i=down;i>=top &&curr!=NULL;i--){\\n                ans[i][left]=curr->val;\\n                curr=curr->next;\\n                t++;\\n                }\\n            }\\n            left++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* curr=head;\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int top=0,right=n-1,down=m-1,left=0;\\n        int t=0;\\n        while(curr!=NULL && t<=m*n){\\n            for(int i=left;i<=right &&curr!=NULL;i++){\\n                ans[top][i]=curr->val;\\n                curr=curr->next;\\n                t++;\\n            }\\n            top++;\\n            for(int i=top;i<=down && curr!=NULL;i++){\\n                ans[i][right]=curr->val;\\n                curr=curr->next;\\n                t++;\\n            }\\n            right--;\\n            if(top<=down){\\n            for(int i=right;i>=left &&curr!=NULL;i--){\\n                ans[down][i]=curr->val;\\n                curr=curr->next;\\n                t++;\\n                }\\n            }\\n            down--;\\n            if(left<=right){\\n            for(int i=down;i>=top &&curr!=NULL;i--){\\n                ans[i][left]=curr->val;\\n                curr=curr->next;\\n                t++;\\n                }\\n            }\\n            left++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2232094,
                "title": "c-easy-recursive",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int m,n;\\n    int xs=0;\\n    int ys=0;\\n    vector<vector<int>>ret;\\n    vector<vector<int>> spiralMatrix(int M, int N, ListNode* head) {\\n        m=M;\\n        n=N;\\n        //vector<vector<int>>ret(m,vector<int>(n,-1));\\n        ret.resize(m,vector<int>(n,-1));\\n        recur(head);\\n        return ret;\\n    }\\n    void recur(ListNode*head){\\n        if(!head)\\n            return;\\n        if(xs>n||ys>m)\\n            return;\\n        int i,j;\\n        i=xs;\\n        j=ys;\\n        for(;i<n&&head;i++){\\n            ret[j][i]=head->val;\\n            head=head->next;\\n        }\\n        ++ys;\\n        i-=1;\\n        j+=1;\\n        for(;j<m&&head;j++){\\n            ret[j][i]=head->val;\\n            head=head->next;\\n        }\\n        --n;\\n        j-=1;\\n        i-=1;\\n        for(;i>=xs&&head;i--){\\n            ret[j][i]=head->val;\\n            head=head->next;\\n        }\\n        --m;\\n        i+=1;\\n        j-=1;\\n        for(;j>=ys&&head;j--){\\n            ret[j][i]=head->val;\\n            head=head->next;\\n        }\\n        ++xs;\\n        recur(head);\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int m,n;\\n    int xs=0;\\n    int ys=0;\\n    vector<vector<int>>ret;\\n    vector<vector<int>> spiralMatrix(int M, int N, ListNode* head) {\\n        m=M;\\n        n=N;\\n        //vector<vector<int>>ret(m,vector<int>(n,-1));\\n        ret.resize(m,vector<int>(n,-1));\\n        recur(head);\\n        return ret;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2231666,
                "title": "java-100-faster-solution",
                "content": "The idea is to iterate the matrix in spiral form and fill the value from list if LinkedList node exists else with -1.\\nIn Spiral iteration we follow the below directions till we reach the boundaries :\\n1) Go right\\n2) Go down\\n3) Go left\\n4) Go up\\n\\n# psudo code:\\n```\\n\\tDefine variables: rowStart=0, rowEnd=m-1, colStart=0 and colEnd=n-1\\n\\tIterate the loop within valid boundaries of above variables\\n\\t//Right\\n\\tIn rowStart row Fill all the column values(from list or -1) starting from colStart to colEnd\\n\\tincrement the rowStart\\n\\t\\n\\t//Down\\n\\tIn colEnd column fill all the values(from list or -1) starting from rowStart to rowEnd\\n\\tdecrement the colEnd\\n\\t\\n\\t//Left\\n\\tThis is a conditional Iteration\\n\\tIf rowStart <= rowEnd then only fill all the column values(from list or -1) from colEnd to colStart in rowEnd row.\\n\\tdecrement rowEnd\\n\\t\\n\\t//Up\\n\\tThis is a conditional Iteration\\n\\tIf colStart <= colEnd then only fill all the values(from list or -1) from rowEnd to rowStart in colStart column\\n\\tincrement colStart\\n```\\n\\t\\n# Here is the working solution:\\n```\\npublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] mat = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        while(rowStart<=rowEnd && colStart<=colEnd) {\\n            //right\\n            for(int i=colStart; i<=colEnd; i++) {\\n                if(head == null) {\\n                    mat[rowStart][i] = -1;\\n                } else {\\n                    mat[rowStart][i] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            rowStart++;\\n            //down\\n            for(int i=rowStart; i<=rowEnd; i++) {\\n                if(head == null) {\\n                    mat[i][colEnd] = -1;\\n                } else {\\n                    mat[i][colEnd] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            colEnd--;\\n            //left\\n            if(rowStart <= rowEnd) {\\n                for(int i=colEnd; i>=colStart; i--) {\\n                    if(head == null) {\\n                        mat[rowEnd][i] = -1;\\n                    } else {\\n                        mat[rowEnd][i] = head.val;\\n                        head = head.next;\\n                    }\\n                }\\n            }\\n            rowEnd--;\\n            //up\\n            if(colStart <= colEnd) {\\n                for(int i=rowEnd; i>=rowStart; i--) {\\n                    if(head == null) {\\n                        mat[i][colStart] = -1;\\n                    } else {\\n                        mat[i][colStart] = head.val;\\n                        head = head.next;\\n                    }\\n                }\\n            }\\n            colStart++;\\n        }\\n        return mat;\\n    }\\n```\\n\\n\\t",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n\\tDefine variables: rowStart=0, rowEnd=m-1, colStart=0 and colEnd=n-1\\n\\tIterate the loop within valid boundaries of above variables\\n\\t//Right\\n\\tIn rowStart row Fill all the column values(from list or -1) starting from colStart to colEnd\\n\\tincrement the rowStart\\n\\t\\n\\t//Down\\n\\tIn colEnd column fill all the values(from list or -1) starting from rowStart to rowEnd\\n\\tdecrement the colEnd\\n\\t\\n\\t//Left\\n\\tThis is a conditional Iteration\\n\\tIf rowStart <= rowEnd then only fill all the column values(from list or -1) from colEnd to colStart in rowEnd row.\\n\\tdecrement rowEnd\\n\\t\\n\\t//Up\\n\\tThis is a conditional Iteration\\n\\tIf colStart <= colEnd then only fill all the values(from list or -1) from rowEnd to rowStart in colStart column\\n\\tincrement colStart\\n```\n```\\npublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] mat = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        while(rowStart<=rowEnd && colStart<=colEnd) {\\n            //right\\n            for(int i=colStart; i<=colEnd; i++) {\\n                if(head == null) {\\n                    mat[rowStart][i] = -1;\\n                } else {\\n                    mat[rowStart][i] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            rowStart++;\\n            //down\\n            for(int i=rowStart; i<=rowEnd; i++) {\\n                if(head == null) {\\n                    mat[i][colEnd] = -1;\\n                } else {\\n                    mat[i][colEnd] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            colEnd--;\\n            //left\\n            if(rowStart <= rowEnd) {\\n                for(int i=colEnd; i>=colStart; i--) {\\n                    if(head == null) {\\n                        mat[rowEnd][i] = -1;\\n                    } else {\\n                        mat[rowEnd][i] = head.val;\\n                        head = head.next;\\n                    }\\n                }\\n            }\\n            rowEnd--;\\n            //up\\n            if(colStart <= colEnd) {\\n                for(int i=rowEnd; i>=rowStart; i--) {\\n                    if(head == null) {\\n                        mat[i][colStart] = -1;\\n                    } else {\\n                        mat[i][colStart] = head.val;\\n                        head = head.next;\\n                    }\\n                }\\n            }\\n            colStart++;\\n        }\\n        return mat;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231334,
                "title": "c-similar-to-other-spiral-matrix-questions-beginner-friendly",
                "content": "# **C++ EASY TO UNDERSATAND Simple looping traversal**\\n```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int r=0,c=0,re=m-1,ce=n-1;\\n        while(c<=ce&&r<=re){\\n            \\n            for(int i=c;i<=ce&&head;i++){\\n                ans[r][i]=head->val;\\n                head=head->next;\\n            }\\n            r++;\\n            for(int i=r;i<=re&&head;i++){\\n                ans[i][ce]=head->val;\\n                head=head->next;\\n            }\\n            ce--;\\n            for(int i=ce;i>=c&&head;i--){\\n                ans[re][i]=head->val;\\n                head=head->next;\\n            }\\n            re--;\\n            for(int i=re;i>=r&&head;i--){\\n                ans[i][c]=head->val;\\n                head=head->next;\\n            }\\n            c++;\\n            \\n        }\\n        return ans;\\n    }\\n```\\n*hope u like it*",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int r=0,c=0,re=m-1,ce=n-1;\\n        while(c<=ce&&r<=re){\\n            \\n            for(int i=c;i<=ce&&head;i++){\\n                ans[r][i]=head->val;\\n                head=head->next;\\n            }\\n            r++;\\n            for(int i=r;i<=re&&head;i++){\\n                ans[i][ce]=head->val;\\n                head=head->next;\\n            }\\n            ce--;\\n            for(int i=ce;i>=c&&head;i--){\\n                ans[re][i]=head->val;\\n                head=head->next;\\n            }\\n            re--;\\n            for(int i=re;i>=r&&head;i--){\\n                ans[i][c]=head->val;\\n                head=head->next;\\n            }\\n            c++;\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230698,
                "title": "c-industrial-level-modular-code-understandable-o-m-n",
                "content": "Hey folks, \\nI guess I\\'m late to the party but I\\'ve bought something new and delicious to the table. Presenting an industrial level modular code for the problem with the simplest explanation ever. \\n\\n**EXPLANATION :** (i & j are the matrix iterators and m&n are the dimensions of the matrix) \\n\\nSo the simple idea is that we need to traverse the matrix in a spiral form. Upon obesrvation we can see that the spiral is clockwise, hence every time it\\'s taking a right turn while spiralling inwards. So in general while traversing the spiral, there is always two constant actions that we\\'re taking : \\n1.  Going straight in the current direction of motion \\n2.  Taking a right turn\\n\\nUnderstanding this we can make two separate methods to implement these:\\n1. `isValid()` returns a boolean informing whether the current matrix iterators are valid or not. Validity is based on two factors: \\n\\t* \\tIt is inside the matrix (i<m, j<n, i>=0 and j>=0)\\n\\t* \\tThe value in the matrix cell is not prefilled. (in which case we\\'ll have to take a right turn)\\n2.  `goingStraight()` returns a boolean value which increments the current matrix iterators if gonig straight is possible, else returns false. \\n3.  `takeRight()` takes a `char direction` as parameter and returns the new direction after taking a right turn. \\n\\t* **Note** :  Directions taken are North as \\'n\\', South as \\'s\\', East as \\'e\\' and West as \\'w\\'.\\n\\n**Algorithm** : \\n1. Traverse the matrix for *mn* times and in each iteration : \\n\\t* \\t*if head is null*: \\n\\t\\t* \\tupdate current matrix cell with value -1\\n\\t* \\t*else* \\n\\t\\t* \\tupdate value with the head of the linked list \\n\\t\\t* \\tmove head to the next element \\n\\t*  check if it\\'s possible to go straight: \\n\\t\\t*  *if yes,* \\n\\t\\t\\t*  increment iterators and go to next iteration \\n\\t\\t* *else* \\n\\t\\t\\t* take a right turn and then go straight \\n\\n**C++ Code :** \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    typedef vector<vector<int>> vvi ;\\n    bool isValid(vvi& spiralMatrix, int i, int j){\\n        int m = spiralMatrix.size();\\n        int n = spiralMatrix[0].size();\\n        if(i<m && j<n && i>=0 && j>=0){\\n            if(spiralMatrix[i][j] == -2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool goStraight(vvi &spiralMatrix, char dir, int &i, int &j){\\n        int x = i ;\\n        int y = j;\\n        if(dir == \\'n\\')\\n            x--;\\n        \\n        else if (dir ==\\'s\\')\\n            x++;\\n        else if (dir == \\'e\\')\\n            y++;\\n        else \\n            y--;\\n        if(isValid(spiralMatrix,x,y)){\\n            i = x;\\n            j = y;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    char takeRight(char dir){\\n        if(dir ==\\'n\\')\\n            return \\'e\\';\\n        else if (dir ==\\'s\\')\\n            return \\'w\\';\\n        else if (dir == \\'e\\')\\n            return \\'s\\';\\n        else \\n            return \\'n\\';\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiralMatrix (m, vector<int> (n,-2));\\n        if(m==1 && n==1){\\n            if(!head){\\n                spiralMatrix[0][0] = -1;\\n                return spiralMatrix;\\n            }\\n            spiralMatrix[0][0] = head->val;\\n            return spiralMatrix;\\n            \\n        }\\n        \\n        int matLength = m*n;\\n        int i=0,j=0;\\n        int l = 0;\\n        ListNode* tempHead = head;\\n        char direction = \\'e\\';\\n        while(matLength--){\\n            if(tempHead){\\n                spiralMatrix[i][j] = tempHead->val;\\n                tempHead = tempHead->next;\\n            }\\n            else{\\n                spiralMatrix[i][j] = -1;\\n            }\\n            \\n            bool canGoStraight = goStraight(spiralMatrix,direction,i,j);\\n            if(canGoStraight)\\n                continue;\\n            \\n            direction = takeRight(direction);\\n            goStraight(spiralMatrix,direction,i,j);             \\n        }\\n        return spiralMatrix;\\n        \\n    }\\n};\\n```\\n**Note :** \\nNotice the nomenclature of variables in the code. It is understandable if you\\'re using short names during the contest/ competitive coding but always keep in mind to use proper variable names and indentations during coding interviews to make your code more readable and easy to understand. \\n\\nThat\\'s it for now from my end :D \\nHope you had a good read and a good day ahead. \\n\\n~shav",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    typedef vector<vector<int>> vvi ;\\n    bool isValid(vvi& spiralMatrix, int i, int j){\\n        int m = spiralMatrix.size();\\n        int n = spiralMatrix[0].size();\\n        if(i<m && j<n && i>=0 && j>=0){\\n            if(spiralMatrix[i][j] == -2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool goStraight(vvi &spiralMatrix, char dir, int &i, int &j){\\n        int x = i ;\\n        int y = j;\\n        if(dir == \\'n\\')\\n            x--;\\n        \\n        else if (dir ==\\'s\\')\\n            x++;\\n        else if (dir == \\'e\\')\\n            y++;\\n        else \\n            y--;\\n        if(isValid(spiralMatrix,x,y)){\\n            i = x;\\n            j = y;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    char takeRight(char dir){\\n        if(dir ==\\'n\\')\\n            return \\'e\\';\\n        else if (dir ==\\'s\\')\\n            return \\'w\\';\\n        else if (dir == \\'e\\')\\n            return \\'s\\';\\n        else \\n            return \\'n\\';\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiralMatrix (m, vector<int> (n,-2));\\n        if(m==1 && n==1){\\n            if(!head){\\n                spiralMatrix[0][0] = -1;\\n                return spiralMatrix;\\n            }\\n            spiralMatrix[0][0] = head->val;\\n            return spiralMatrix;\\n            \\n        }\\n        \\n        int matLength = m*n;\\n        int i=0,j=0;\\n        int l = 0;\\n        ListNode* tempHead = head;\\n        char direction = \\'e\\';\\n        while(matLength--){\\n            if(tempHead){\\n                spiralMatrix[i][j] = tempHead->val;\\n                tempHead = tempHead->next;\\n            }\\n            else{\\n                spiralMatrix[i][j] = -1;\\n            }\\n            \\n            bool canGoStraight = goStraight(spiralMatrix,direction,i,j);\\n            if(canGoStraight)\\n                continue;\\n            \\n            direction = takeRight(direction);\\n            goStraight(spiralMatrix,direction,i,j);             \\n        }\\n        return spiralMatrix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230543,
                "title": "easy-solution-cpp",
                "content": "At start 0(row),n-1(col) ,m-1(row) ,0(col). Now after every iteration, increase 0, row and 0 col, and decrease the remaining by 1.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> res(m,vector<int>(n,-1));\\n        \\n        ListNode* temp=head;\\n        int rs=0,re=m-1;\\n        int cs=0,ce=n-1;\\n        while(temp!=NULL)\\n        {\\n            for(int i=cs;i<=ce;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[rs][i] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[i][ce] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            ce--;\\n            //cout<<temp->val<<endl;\\n            for(int i=ce;i>=cs;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    //cout<<re<<\" \"<<i<<\" hell0 \"<<endl;\\n                    res[re][i] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            re--;\\n            for(int i=re;i>=rs;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[i][cs] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }              \\n            }\\n            cs++;\\n\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> res(m,vector<int>(n,-1));\\n        \\n        ListNode* temp=head;\\n        int rs=0,re=m-1;\\n        int cs=0,ce=n-1;\\n        while(temp!=NULL)\\n        {\\n            for(int i=cs;i<=ce;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[rs][i] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[i][ce] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            ce--;\\n            //cout<<temp->val<<endl;\\n            for(int i=ce;i>=cs;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    //cout<<re<<\" \"<<i<<\" hell0 \"<<endl;\\n                    res[re][i] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            re--;\\n            for(int i=re;i>=rs;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[i][cs] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }              \\n            }\\n            cs++;\\n\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2230511,
                "title": "simple-c",
                "content": "```\\n  vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<int> ll;\\n        \\n        while(head != NULL){\\n            ll.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n        vector<vector<int>> arr(m, vector<int>(n, -1));\\n        \\n        int r1 = 0, r2 = m-1;\\n        int c1 = 0, c2 = n-1;\\n        \\n        int i = 0;\\n        \\n        while(r1 <= r2 and c1 <= c2){\\n            if(i == ll.size()) break;\\n            //left to right\\n            for(int c=c1; c<=c2; c++) {\\n                if(i == ll.size()) break;\\n                arr[r1][c] = ll[i++];\\n            }\\n            \\n            //move down\\n            for(int r=r1+1; r<=r2; r++) {\\n                if(i == ll.size()) break;\\n                arr[r][c2] = ll[i++];\\n            }\\n            \\n            //right to left and move up\\n            if(r1 < r2 and c1 < c2){\\n                if(i == ll.size()) break;\\n                //right to left\\n                \\n                for(int c=c2-1; c>c1; c--) {\\n                    if(i == ll.size()) break;\\n                    arr[r2][c] = ll[i++];\\n                }\\n                \\n                //up\\n                for(int r=r2; r>r1; r--) {\\n                    if(i == ll.size()) break;\\n                    arr[r][c1] = ll[i++];\\n                }\\n            }\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<int> ll;\\n        \\n        while(head != NULL){\\n            ll.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n        vector<vector<int>> arr(m, vector<int>(n, -1));\\n        \\n        int r1 = 0, r2 = m-1;\\n        int c1 = 0, c2 = n-1;\\n        \\n        int i = 0;\\n        \\n        while(r1 <= r2 and c1 <= c2){\\n            if(i == ll.size()) break;\\n            //left to right\\n            for(int c=c1; c<=c2; c++) {\\n                if(i == ll.size()) break;\\n                arr[r1][c] = ll[i++];\\n            }\\n            \\n            //move down\\n            for(int r=r1+1; r<=r2; r++) {\\n                if(i == ll.size()) break;\\n                arr[r][c2] = ll[i++];\\n            }\\n            \\n            //right to left and move up\\n            if(r1 < r2 and c1 < c2){\\n                if(i == ll.size()) break;\\n                //right to left\\n                \\n                for(int c=c2-1; c>c1; c--) {\\n                    if(i == ll.size()) break;\\n                    arr[r2][c] = ll[i++];\\n                }\\n                \\n                //up\\n                for(int r=r2; r>r1; r--) {\\n                    if(i == ll.size()) break;\\n                    arr[r][c1] = ll[i++];\\n                }\\n            }\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230393,
                "title": "c-small-variation-in-spiral-matrix-problem-easy-understanding",
                "content": "**C++**\\n  Just made small change in SPIRAL MATRIX code ,the comments are of spiral matrix(problem 54) earlier code\\n  in place of those just written the traversal of HEAD(i.e Linked List) till it become NULL.\\n       \\n                                  \\n    \\n\\t\\n\\t\\n\\t   vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* t=head;\\n\\t\\t vector<vector<int>> ans(m,vector<int>(n,-1));\\n       // int row=matrix.size(),col=matrix[0].size();\\n\\tint sr=0,er=m-1,sc=0,ec=n-1;\\n\\twhile(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++){\\n            // ans.push_back(matrix[sr][i]);\\n            ans[sr][i]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n                   }\\n               sr++;\\n        if(t==NULL)\\n                break;\\n              for(int i=sr;i<=er;i++){\\n               //ans.push_back(matrix[i][ec]);\\n                    ans[i][ec]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }\\n                 ec--;\\n        if(t==NULL)\\n                break;\\n        \\n        if(sr<=er){\\n         for(int i=ec;i>=sc;i--){\\n             //  ans.push_back(matrix[er][i]);\\n               ans[er][i]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }}\\n                   er--;\\n        if(t==NULL)\\n                break;\\n        \\n        if(sc<=ec){\\n      for(int i=er;i>=sr;i--){\\n              // ans.push_back(matrix[i][sc]);\\n            ans[i][sc]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }}\\n                                                          sc++;\\n        if(t==NULL)\\n                break;\\n                                                          \\n    }                       \\n             return ans;                                             \\n                                                   \\n    }",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "**C++**\\n  Just made small change in SPIRAL MATRIX code ,the comments are of spiral matrix(problem 54) earlier code\\n  in place of those just written the traversal of HEAD(i.e Linked List) till it become NULL.\\n       \\n                                  \\n    \\n\\t\\n\\t\\n\\t   vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* t=head;\\n\\t\\t vector<vector<int>> ans(m,vector<int>(n,-1));\\n       // int row=matrix.size(),col=matrix[0].size();\\n\\tint sr=0,er=m-1,sc=0,ec=n-1;\\n\\twhile(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++){\\n            // ans.push_back(matrix[sr][i]);\\n            ans[sr][i]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n                   }\\n               sr++;\\n        if(t==NULL)\\n                break;\\n              for(int i=sr;i<=er;i++){\\n               //ans.push_back(matrix[i][ec]);\\n                    ans[i][ec]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }\\n                 ec--;\\n        if(t==NULL)\\n                break;\\n        \\n        if(sr<=er){\\n         for(int i=ec;i>=sc;i--){\\n             //  ans.push_back(matrix[er][i]);\\n               ans[er][i]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }}\\n                   er--;\\n        if(t==NULL)\\n                break;\\n        \\n        if(sc<=ec){\\n      for(int i=er;i>=sr;i--){\\n              // ans.push_back(matrix[i][sc]);\\n            ans[i][sc]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }}\\n                                                          sc++;\\n        if(t==NULL)\\n                break;\\n                                                          \\n    }                       \\n             return ans;                                             \\n                                                   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2230316,
                "title": "c-easy-and-concise-code-o-n-solution-similar-to-54-spiral-matrix",
                "content": "``` \\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n, -1));\\n        int sr = 0, sc = 0, er = m  - 1, ec = n-1;\\n        while(head != NULL){\\n            \\n            for(int i = sr, j = sc; j <= ec && head != NULL; j++){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            sr++;\\n            \\n            for(int i = sr, j = ec; i <= er && head != NULL; i++){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            ec--;\\n            \\n            for(int i = er, j = ec; j >= sc && head != NULL; j--){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            er--;\\n            \\n            for(int i = er, j = sc; i >= sr && head != NULL; i--){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            sc++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n, -1));\\n        int sr = 0, sc = 0, er = m  - 1, ec = n-1;\\n        while(head != NULL){\\n            \\n            for(int i = sr, j = sc; j <= ec && head != NULL; j++){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            sr++;\\n            \\n            for(int i = sr, j = ec; i <= er && head != NULL; i++){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            ec--;\\n            \\n            for(int i = er, j = ec; j >= sc && head != NULL; j--){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            er--;\\n            \\n            for(int i = er, j = sc; i >= sr && head != NULL; i--){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            sc++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230298,
                "title": "c-easy-understanding-o-n-time",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Simple solution.\\n    // Same as Spiral Matrix I. Using temp to iterate over the linked list.\\n    \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        swap(n, m);\\n        ListNode* temp = head; // \\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        int r=0, c=0;\\n        while(r<n and c<m and temp) {\\n            for(int i=c;i<m;i++) {\\n                if(temp) {\\n                    ans[r][i] = temp->val;        \\n                    temp = temp->next;\\n                }\\n            }\\n            r++;\\n            for(int i=r;i<n;i++) {\\n                if(temp) {\\n                    ans[i][m-1] = temp->val;\\n                    temp = temp->next;\\n                }\\n            }\\n            m--;\\n            if(r < n) {\\n                for(int i=m-1;i>=c;i--){\\n                    if(temp) {\\n                        ans[n-1][i] = temp->val;\\n                        temp = temp->next;\\n                    }\\n                }\\n                n--;\\n            }\\n            if(c < m) {\\n                for(int i=n-1;i>=r;i--){\\n                    if(temp) {\\n                        ans[i][c] = temp->val;\\n                        temp = temp->next;\\n                    }\\n                }\\n                c++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Simple solution.\\n    // Same as Spiral Matrix I. Using temp to iterate over the linked list.\\n    \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        swap(n, m);\\n        ListNode* temp = head; // \\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        int r=0, c=0;\\n        while(r<n and c<m and temp) {\\n            for(int i=c;i<m;i++) {\\n                if(temp) {\\n                    ans[r][i] = temp->val;        \\n                    temp = temp->next;\\n                }\\n            }\\n            r++;\\n            for(int i=r;i<n;i++) {\\n                if(temp) {\\n                    ans[i][m-1] = temp->val;\\n                    temp = temp->next;\\n                }\\n            }\\n            m--;\\n            if(r < n) {\\n                for(int i=m-1;i>=c;i--){\\n                    if(temp) {\\n                        ans[n-1][i] = temp->val;\\n                        temp = temp->next;\\n                    }\\n                }\\n                n--;\\n            }\\n            if(c < m) {\\n                for(int i=n-1;i>=r;i--){\\n                    if(temp) {\\n                        ans[i][c] = temp->val;\\n                        temp = temp->next;\\n                    }\\n                }\\n                c++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230266,
                "title": "c-easy-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int[][] SpiralMatrix(int m, int n, ListNode head)\\n    {\\n        var matrix = new int[m][];\\n        for (var i = 0; i < m; i++)\\n        {\\n            var arr = new int[n];\\n            Array.Fill(arr, -1);\\n            matrix[i] = arr;\\n        }\\n\\n        if (n == 0 || m == 0) return matrix;\\n\\n        var rowStart = 0;\\n        var rowEnd = m - 1;\\n        var colStart = 0;\\n        var colEnd = n - 1;\\n        var ln = head;\\n\\n        while (rowStart <= rowEnd && colStart <= colEnd)\\n        {\\n            for (var i = colStart; i <= colEnd; i++)\\n            {\\n                if(ln == null)\\n                    return matrix;\\n                \\n                matrix[rowStart][i] = ln.val;\\n                ln = ln.next;\\n            }\\n\\n            rowStart++;\\n\\n            for (var i = rowStart; i <= rowEnd; i++)\\n            {\\n                if(ln == null)\\n                    return matrix;\\n                \\n                matrix[i][colEnd] = ln.val;\\n                ln = ln.next;\\n            }\\n\\n            colEnd--;\\n\\n            for (var i = colEnd; i >= colStart; i--)\\n                if (rowStart <= rowEnd)\\n                {\\n                    if(ln == null)\\n                        return matrix;\\n                    \\n                    matrix[rowEnd][i] = ln.val;\\n                    ln = ln.next;\\n                }\\n\\n            rowEnd--;\\n\\n            for (var i = rowEnd; i >= rowStart; i--)\\n                if (colStart <= colEnd)\\n                {\\n                    if(ln == null)\\n                        return matrix;\\n                    \\n                    matrix[i][colStart] = ln.val;\\n                    ln = ln.next;\\n                }\\n\\n            colStart++;\\n        }\\n\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int[][] SpiralMatrix(int m, int n, ListNode head)\\n    {\\n        var matrix = new int[m][];\\n        for (var i = 0; i < m; i++)\\n        {\\n            var arr = new int[n];\\n            Array.Fill(arr, -1);\\n            matrix[i] = arr;\\n        }\\n\\n        if (n == 0 || m == 0) return matrix;\\n\\n        var rowStart = 0;\\n        var rowEnd = m - 1;\\n        var colStart = 0;\\n        var colEnd = n - 1;\\n        var ln = head;\\n\\n        while (rowStart <= rowEnd && colStart <= colEnd)\\n        {\\n            for (var i = colStart; i <= colEnd; i++)\\n            {\\n                if(ln == null)\\n                    return matrix;\\n                \\n                matrix[rowStart][i] = ln.val;\\n                ln = ln.next;\\n            }\\n\\n            rowStart++;\\n\\n            for (var i = rowStart; i <= rowEnd; i++)\\n            {\\n                if(ln == null)\\n                    return matrix;\\n                \\n                matrix[i][colEnd] = ln.val;\\n                ln = ln.next;\\n            }\\n\\n            colEnd--;\\n\\n            for (var i = colEnd; i >= colStart; i--)\\n                if (rowStart <= rowEnd)\\n                {\\n                    if(ln == null)\\n                        return matrix;\\n                    \\n                    matrix[rowEnd][i] = ln.val;\\n                    ln = ln.next;\\n                }\\n\\n            rowEnd--;\\n\\n            for (var i = rowEnd; i >= rowStart; i--)\\n                if (colStart <= colEnd)\\n                {\\n                    if(ln == null)\\n                        return matrix;\\n                    \\n                    matrix[i][colStart] = ln.val;\\n                    ln = ln.next;\\n                }\\n\\n            colStart++;\\n        }\\n\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230238,
                "title": "easiest-java-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int[] row : matrix){\\n            Arrays.fill(row, -1);\\n        }\\n        int sr = 0 , sc = 0, dr = m-1, dc = n-1;\\n        while(head != null){\\n            for(int i=sr, j = sc ; j <= dc && head != null; j++){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            sr++;\\n            for(int i=sr, j = dc ; i <= dr && head != null; i++){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            dc--;\\n            for(int i=dr, j = dc ; j >= sc && head != null; j--){\\n                matrix[i][j] = head.val;\\n                head = head.next;;\\n            }\\n            dr--;\\n            for(int i=dr, j = sc ; i >= sr && head != null; i--){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            sc++;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int[] row : matrix){\\n            Arrays.fill(row, -1);\\n        }\\n        int sr = 0 , sc = 0, dr = m-1, dc = n-1;\\n        while(head != null){\\n            for(int i=sr, j = sc ; j <= dc && head != null; j++){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            sr++;\\n            for(int i=sr, j = dc ; i <= dr && head != null; i++){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            dc--;\\n            for(int i=dr, j = dc ; j >= sc && head != null; j--){\\n                matrix[i][j] = head.val;\\n                head = head.next;;\\n            }\\n            dr--;\\n            for(int i=dr, j = sc ; i >= sr && head != null; i--){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            sc++;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230235,
                "title": "c-solution-easy-to-understand-spiral-matrix-iv",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n,-1));\\n        int top = 0,down = m-1,left =0,right = n-1; \\n        int dir = 0;    \\n        while(top<=down && left<=right){\\n            if(dir==0){\\n                for(int i = left;i<=right;i++){\\n                    if(head->next!=NULL){\\n                    ans[top][i] = head->val;\\n                    head = head->next;\\n                    }else{\\n                        ans[top][i] = head->val;\\n                        return ans;\\n                        exit(1);\\n                    }\\n                }\\n                top++;\\n            }\\n            \\n          else if(dir==1){\\n              for(int i=top;i<=down;i++){\\n                  if(head->next!=NULL){\\n                      ans[i][right] = head->val;\\n                      head = head->next;\\n                  }else{\\n                      ans[i][right] = head->val;\\n                      return ans;\\n                      exit(1);\\n                  }\\n              }\\n              right--;\\n          }\\n        else if(dir == 2){\\n            for(int i=right;i>=left;i--){\\n                if(head->next!=NULL){\\n                    ans[down][i] = head->val;\\n                    head = head->next;\\n                }else{\\n                    ans[down][i] = head->val;\\n                    return ans;\\n                    exit(1);\\n                }\\n            }\\n            down--;\\n        }\\n        else if(dir == 3){\\n            for(int i=down;i>=top;i--){\\n                if(head->next!=NULL){\\n                    ans[i][left] = head->val;\\n                    head = head->next;\\n                }else{\\n                    ans[i][left] = head->val;\\n                    return ans;\\n                    exit(1);\\n                }\\n            }\\n            left++;\\n        }\\n            dir = (dir + 1)%4;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n,-1));\\n        int top = 0,down = m-1,left =0,right = n-1; \\n        int dir = 0;    \\n        while(top<=down && left<=right){\\n            if(dir==0){\\n                for(int i = left;i<=right;i++){\\n                    if(head->next!=NULL){\\n                    ans[top][i] = head->val;\\n                    head = head->next;\\n                    }else{\\n                        ans[top][i] = head->val;\\n                        return ans;\\n                        exit(1);\\n                    }\\n                }\\n                top++;\\n            }\\n            \\n          else if(dir==1){\\n              for(int i=top;i<=down;i++){\\n                  if(head->next!=NULL){\\n                      ans[i][right] = head->val;\\n                      head = head->next;\\n                  }else{\\n                      ans[i][right] = head->val;\\n                      return ans;\\n                      exit(1);\\n                  }\\n              }\\n              right--;\\n          }\\n        else if(dir == 2){\\n            for(int i=right;i>=left;i--){\\n                if(head->next!=NULL){\\n                    ans[down][i] = head->val;\\n                    head = head->next;\\n                }else{\\n                    ans[down][i] = head->val;\\n                    return ans;\\n                    exit(1);\\n                }\\n            }\\n            down--;\\n        }\\n        else if(dir == 3){\\n            for(int i=down;i>=top;i--){\\n                if(head->next!=NULL){\\n                    ans[i][left] = head->val;\\n                    head = head->next;\\n                }else{\\n                    ans[i][left] = head->val;\\n                    return ans;\\n                    exit(1);\\n                }\\n            }\\n            left++;\\n        }\\n            dir = (dir + 1)%4;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230163,
                "title": "java-simple-easy-read-4min-read",
                "content": "```\\npublic int[][] spiralMatrix(int n, int m, ListNode head) {\\n        int[][]ans=new int[n][m];\\n        for(int[]i:ans)Arrays.fill(i,-1);\\n        int top=0,left=0,right=m-1,bottom=n-1;\\n        int dir=0;\\n        Deque<Integer> q=new ArrayDeque<>();\\n        while(head!=null){\\n            q.offerLast(head.val);\\n            head=head.next;\\n        }\\n        while(!q.isEmpty()&&top<=bottom&&left<=right){\\n            if(dir==0){\\n                for(int i=left;i<=right&&!q.isEmpty();i++){\\n                    ans[top][i]=q.pollFirst();\\n                }\\n                top++;\\n            }else if(dir==1){\\n                for(int i=top;i<=bottom&&!q.isEmpty();i++){\\n                    ans[i][right]=q.pollFirst();\\n                }\\n                right--;\\n            }else if(dir==2){\\n                for(int i=right;i>=left&&!q.isEmpty();i--){\\n                    ans[bottom][i]=q.pollFirst();\\n                }\\n                bottom--;\\n            }else{\\n                for(int i=bottom;i>=top&&!q.isEmpty();i--){\\n                    ans[i][left]=q.pollFirst();\\n                }\\n                left++;\\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\npublic int[][] spiralMatrix(int n, int m, ListNode head) {\\n        int[][]ans=new int[n][m];\\n        for(int[]i:ans)Arrays.fill(i,-1);\\n        int top=0,left=0,right=m-1,bottom=n-1;\\n        int dir=0;\\n        Deque<Integer> q=new ArrayDeque<>();\\n        while(head!=null){\\n            q.offerLast(head.val);\\n            head=head.next;\\n        }\\n        while(!q.isEmpty()&&top<=bottom&&left<=right){\\n            if(dir==0){\\n                for(int i=left;i<=right&&!q.isEmpty();i++){\\n                    ans[top][i]=q.pollFirst();\\n                }\\n                top++;\\n            }else if(dir==1){\\n                for(int i=top;i<=bottom&&!q.isEmpty();i++){\\n                    ans[i][right]=q.pollFirst();\\n                }\\n                right--;\\n            }else if(dir==2){\\n                for(int i=right;i>=left&&!q.isEmpty();i--){\\n                    ans[bottom][i]=q.pollFirst();\\n                }\\n                bottom--;\\n            }else{\\n                for(int i=bottom;i>=top&&!q.isEmpty();i--){\\n                    ans[i][left]=q.pollFirst();\\n                }\\n                left++;\\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230130,
                "title": "linear-time-solution-java-easy",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode p=head;\\n        int i=0,j=0,arr[][]=new int[m][n],flag=1;//1-right, 2-down,3-left ,4-up\\n        int left=-1,up=0,loop=0,mn=m*n;\\n        while(flag>0 && loop<mn){\\n            int val=(p==null)?-1:p.val;\\n            switch(flag){\\n                case 1:\\n                    if(j+1==n){\\n                        flag++;\\n                        n--;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    j++;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 2:\\n                    if(i+1==m){\\n                        flag++;\\n                        m--;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    i++;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 3:\\n                    if(j-1==left){\\n                        flag++;\\n                        left++;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    j--;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 4:\\n                    if(i-1==up){\\n                        flag=1;\\n                        up++;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    i--;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode p=head;\\n        int i=0,j=0,arr[][]=new int[m][n],flag=1;//1-right, 2-down,3-left ,4-up\\n        int left=-1,up=0,loop=0,mn=m*n;\\n        while(flag>0 && loop<mn){\\n            int val=(p==null)?-1:p.val;\\n            switch(flag){\\n                case 1:\\n                    if(j+1==n){\\n                        flag++;\\n                        n--;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    j++;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 2:\\n                    if(i+1==m){\\n                        flag++;\\n                        m--;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    i++;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 3:\\n                    if(j-1==left){\\n                        flag++;\\n                        left++;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    j--;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 4:\\n                    if(i-1==up){\\n                        flag=1;\\n                        up++;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    i--;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230100,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix= [[-1 for j in range(n)] for i in range(m)]\\n       \\n        left = 0\\n        right = n-1\\n        top = 0\\n        bottom = m-1\\n       \\n        if not head:\\n            return matrix\\n       \\n        while(left < right and top < bottom):\\n            for i in range(left,right):\\n                matrix[top][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(top,bottom):\\n                matrix[i][right] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(right,left,-1):\\n                matrix[bottom][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(bottom,top,-1):\\n                matrix[i][left] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            left += 1\\n            right -=1\\n            top +=1\\n            bottom -=1\\n           \\n        if(left == right and top == bottom):\\n            matrix[left][right] = head.val\\n            if(head.next==None):\\n                    return matrix\\n            head = head.next\\n       \\n        elif(left == right):\\n            for i in range(top,bottom + 1):\\n                matrix[i][left] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n        elif(top == bottom):\\n            for i in range(left,right +1):\\n                matrix[top][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n           \\n        return matrix\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix= [[-1 for j in range(n)] for i in range(m)]\\n       \\n        left = 0\\n        right = n-1\\n        top = 0\\n        bottom = m-1\\n       \\n        if not head:\\n            return matrix\\n       \\n        while(left < right and top < bottom):\\n            for i in range(left,right):\\n                matrix[top][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(top,bottom):\\n                matrix[i][right] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(right,left,-1):\\n                matrix[bottom][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(bottom,top,-1):\\n                matrix[i][left] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            left += 1\\n            right -=1\\n            top +=1\\n            bottom -=1\\n           \\n        if(left == right and top == bottom):\\n            matrix[left][right] = head.val\\n            if(head.next==None):\\n                    return matrix\\n            head = head.next\\n       \\n        elif(left == right):\\n            for i in range(top,bottom + 1):\\n                matrix[i][left] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n        elif(top == bottom):\\n            for i in range(left,right +1):\\n                matrix[top][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n           \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230084,
                "title": "spiral-traversal-explanation-in-comments-c-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> matrix(n,vector<int> (m,-1));\\n        \\n        int left =0, right = m-1, top =0, bottom = n-1;\\n        \\n        int i;\\n        ListNode *temp = head;\\n        \\n        while(left <= right and top <= bottom and temp!=NULL) {\\n            \\n            // left to right in the top row\\n            for(i = left; i <= right; i++) {\\n                if(temp) {matrix[top][i] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            // now that top row is done,decrement the top pointer\\n            top++;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //top to bottom in the rightmost column\\n            for(i = top; i <= bottom; i++) {\\n               \\n                 if(temp) { matrix[i][right] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            right--;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //right to left in the bottom row\\n            for(i = right; i >= left; i--) {\\n              \\n                if(temp) {matrix[bottom][i] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            bottom--;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //bottom to top in the left most column\\n            for(i=bottom; i >= top; i--) {\\n                \\n                if(temp) {matrix[i][left] = temp->val;\\n                temp = temp->next;}\\n                \\n            }\\n            left++;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n        }\\n        \\n        return matrix;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> matrix(n,vector<int> (m,-1));\\n        \\n        int left =0, right = m-1, top =0, bottom = n-1;\\n        \\n        int i;\\n        ListNode *temp = head;\\n        \\n        while(left <= right and top <= bottom and temp!=NULL) {\\n            \\n            // left to right in the top row\\n            for(i = left; i <= right; i++) {\\n                if(temp) {matrix[top][i] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            // now that top row is done,decrement the top pointer\\n            top++;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //top to bottom in the rightmost column\\n            for(i = top; i <= bottom; i++) {\\n               \\n                 if(temp) { matrix[i][right] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            right--;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //right to left in the bottom row\\n            for(i = right; i >= left; i--) {\\n              \\n                if(temp) {matrix[bottom][i] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            bottom--;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //bottom to top in the left most column\\n            for(i=bottom; i >= top; i--) {\\n                \\n                if(temp) {matrix[i][left] = temp->val;\\n                temp = temp->next;}\\n                \\n            }\\n            left++;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n        }\\n        \\n        return matrix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230071,
                "title": "easy-python-solution",
                "content": "Kindly upvote\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix= [[-1 for j in range(n)] for i in range(m)]\\n        \\n        l=0     #left\\n        r= n-1    #right\\n        t=0  #top\\n        b= m-1   #bottom\\n        \\n        if(head==None):\\n            return matrix\\n        \\n        while(l<r and t<b):\\n\\t\\t\\t# iterate top row from left to right\\n            for i in range(l,r):\\n                matrix[t][i] = head.val\\n                if(head.next==None):       # check if head becomes NULL\\n                    return matrix\\n                head = head.next\\n             \\n\\t\\t\\t#iterate right column from top to bottom\\n            for i in range(t,b):\\n                matrix[i][r] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n\\t\\t\\t#iterate bottom row from right to left\\n            for i in range(r,l,-1):\\n                matrix[b][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n\\t\\t\\t#iterate left column from bottom to top\\n            for i in range(b,t,-1):\\n                matrix[i][l] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n                \\n            l+=1\\n            r-=1\\n            t+=1\\n            b-=1\\n            \\n\\t\\t# if single remaining middle element\\n        if(l==r and t==b):\\n            matrix[l][r] = head.val\\n            if(head.next==None):\\n                    return matrix\\n            head = head.next\\n        \\n\\t\\t# if remaining vertical elements\\n        elif(l==r):\\n            for i in range(t,b+1):\\n                matrix[i][l] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n                \\n\\t\\t# if remaining horizontal elements\\n        elif(t==b):\\n            for i in range(l,r+1):\\n                matrix[t][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix= [[-1 for j in range(n)] for i in range(m)]\\n        \\n        l=0     #left\\n        r= n-1    #right\\n        t=0  #top\\n        b= m-1   #bottom\\n        \\n        if(head==None):\\n            return matrix\\n        \\n        while(l<r and t<b):\\n\\t\\t\\t# iterate top row from left to right\\n            for i in range(l,r):\\n                matrix[t][i] = head.val\\n                if(head.next==None):       # check if head becomes NULL\\n                    return matrix\\n                head = head.next\\n             \\n\\t\\t\\t#iterate right column from top to bottom\\n            for i in range(t,b):\\n                matrix[i][r] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n\\t\\t\\t#iterate bottom row from right to left\\n            for i in range(r,l,-1):\\n                matrix[b][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n\\t\\t\\t#iterate left column from bottom to top\\n            for i in range(b,t,-1):\\n                matrix[i][l] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n                \\n            l+=1\\n            r-=1\\n            t+=1\\n            b-=1\\n            \\n\\t\\t# if single remaining middle element\\n        if(l==r and t==b):\\n            matrix[l][r] = head.val\\n            if(head.next==None):\\n                    return matrix\\n            head = head.next\\n        \\n\\t\\t# if remaining vertical elements\\n        elif(l==r):\\n            for i in range(t,b+1):\\n                matrix[i][l] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n                \\n\\t\\t# if remaining horizontal elements\\n        elif(t==b):\\n            for i in range(l,r+1):\\n                matrix[t][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230064,
                "title": "c-9-lines",
                "content": "```\\npublic class Solution \\n{\\n    public int[][] SpiralMatrix(int m, int n, ListNode head) \\n    {\\n        int[][] res = Enumerable.Range(0, m).Select(i => Enumerable.Repeat(-1, n).ToArray()).ToArray();\\n        \\n        for (int i = 0, j = 0, di = 0, dj = +1; head is not null; (i, j) = (i + di, j + dj)) \\n        {\\n            res[i][j] = head.val;\\n            head = head.next;\\n            \\n            if (!isOK(i + di, j + dj)) (di, dj) = (dj, -di);\\n                \\n            bool isOK(int x, int y) => x >= 0 && x < m && y >= 0 && y < n && res[x][y] == -1; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[][] SpiralMatrix(int m, int n, ListNode head) \\n    {\\n        int[][] res = Enumerable.Range(0, m).Select(i => Enumerable.Repeat(-1, n).ToArray()).ToArray();\\n        \\n        for (int i = 0, j = 0, di = 0, dj = +1; head is not null; (i, j) = (i + di, j + dj)) \\n        {\\n            res[i][j] = head.val;\\n            head = head.next;\\n            \\n            if (!isOK(i + di, j + dj)) (di, dj) = (dj, -di);\\n                \\n            bool isOK(int x, int y) => x >= 0 && x < m && y >= 0 && y < n && res[x][y] == -1; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230054,
                "title": "simple-constructive-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int fRow = 0, fCol= 0, lRow = m-1, lCol = n-1;\\n        int count = 0;\\n        vector<vector<int>> mat(m, vector<int> (n, -1));\\n        while(count<n*m){\\n            for(int j=fCol; j<=lCol; j++){\\n                mat[fRow][j] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            fRow++;\\n            for(int i=fRow; i<=lRow; i++){\\n                mat[i][lCol] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            lCol--;\\n            for(int j=lCol; j>=fCol; j--){\\n                mat[lRow][j] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            lRow--;\\n            for(int i=lRow; i>=fRow; i--){\\n                mat[i][fCol] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            fCol++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int fRow = 0, fCol= 0, lRow = m-1, lCol = n-1;\\n        int count = 0;\\n        vector<vector<int>> mat(m, vector<int> (n, -1));\\n        while(count<n*m){\\n            for(int j=fCol; j<=lCol; j++){\\n                mat[fRow][j] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            fRow++;\\n            for(int i=fRow; i<=lRow; i++){\\n                mat[i][lCol] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            lCol--;\\n            for(int j=lCol; j>=fCol; j--){\\n                mat[lRow][j] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            lRow--;\\n            for(int i=lRow; i>=fRow; i--){\\n                mat[i][fCol] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            fCol++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230043,
                "title": "simple-efficient-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\ntypedef int ll;\\ntypedef long double ld;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define li(x) list<x>\\n#define pb push_back\\n#define ln ListNode\\nconst ll mod = 1e9 + 7;\\nconst char nl = \\'\\\\n\\';\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    ll p = -1, cnt = 0;\\n    vi(vi(ll))res(m, vi(ll)(n, -1));\\n    while (cnt < (m * n)) {\\n        ++p;\\n        for (ll i = 0;i < n - (2 * p);++i) {\\n            if (!head)\\n                return res;\\n            res[p][p + i] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = 1;i < m - 2 * p;++i) {\\n            if (!head)\\n                return res;\\n            res[p + i][n - 1 - p] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = n - p - 2;i >= p;--i) {\\n            if (!head)\\n                return res;\\n            res[m - 1 - p][i] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = m - p - 2;i >= p + 1;--i) {\\n            if (!head)\\n                return res;\\n            res[i][p] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\ntypedef int ll;\\ntypedef long double ld;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define li(x) list<x>\\n#define pb push_back\\n#define ln ListNode\\nconst ll mod = 1e9 + 7;\\nconst char nl = \\'\\\\n\\';\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    ll p = -1, cnt = 0;\\n    vi(vi(ll))res(m, vi(ll)(n, -1));\\n    while (cnt < (m * n)) {\\n        ++p;\\n        for (ll i = 0;i < n - (2 * p);++i) {\\n            if (!head)\\n                return res;\\n            res[p][p + i] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = 1;i < m - 2 * p;++i) {\\n            if (!head)\\n                return res;\\n            res[p + i][n - 1 - p] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = n - p - 2;i >= p;--i) {\\n            if (!head)\\n                return res;\\n            res[m - 1 - p][i] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = m - p - 2;i >= p + 1;--i) {\\n            if (!head)\\n                return res;\\n            res[i][p] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230030,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m,vector<int>(n));\\n\\n        int left=0 , right=n-1; // column pointers\\n        int top=0 , bottom=m-1; // row pointers\\n        int dir = 0;\\n        while(left<=right && top<=bottom) {\\n            if(dir == 0) {\\n                for(int i=left ; i<=right ; i++) {\\n                    mat[top][i] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                top++;\\n            }\\n\\n            if(dir == 1) {\\n                for(int i=top ; i<=bottom ; i++) {\\n                    mat[i][right] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                right--;\\n            }\\n\\n            if(dir == 2) {\\n                for(int i=right ; i>=left ; i--) {\\n                    mat[bottom][i] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                bottom--;\\n            }\\n\\n            if(dir == 3) {\\n                for(int i=bottom ; i>=top ; i--) {\\n                    mat[i][left] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                left++;\\n            }\\n\\n            dir = (dir+1)%4;\\n        }\\n        return mat;\\n    }\\n};\\n```\\n\\nCheck all the Spiral Matrix Problems (1 to 4) here -\\nSpiral Matrix 1 - https://leetcode.com/problems/spiral-matrix/solutions/3747955/easy-traversal/\\nSpiral Matrix 2 - https://leetcode.com/problems/spiral-matrix-ii/solutions/3747970/same-as-spiral-matrix-i/\\nSpiral Matrix 3 - https://leetcode.com/problems/spiral-matrix-iii/solutions/3750377/solution-made-easy/\\nSpiral Matrix 4 - https://leetcode.com/problems/spiral-matrix-iv/solutions/2230030/simple-solution/",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m,vector<int>(n));\\n\\n        int left=0 , right=n-1; // column pointers\\n        int top=0 , bottom=m-1; // row pointers\\n        int dir = 0;\\n        while(left<=right && top<=bottom) {\\n            if(dir == 0) {\\n                for(int i=left ; i<=right ; i++) {\\n                    mat[top][i] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                top++;\\n            }\\n\\n            if(dir == 1) {\\n                for(int i=top ; i<=bottom ; i++) {\\n                    mat[i][right] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                right--;\\n            }\\n\\n            if(dir == 2) {\\n                for(int i=right ; i>=left ; i--) {\\n                    mat[bottom][i] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                bottom--;\\n            }\\n\\n            if(dir == 3) {\\n                for(int i=bottom ; i>=top ; i--) {\\n                    mat[i][left] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                left++;\\n            }\\n\\n            dir = (dir+1)%4;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230018,
                "title": "python-easy-solution-using-for-loops",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        ans = [[-1]*n for i in range(m)]\\n        j = 0\\n        while True:\\n            for k in range(j,n-j):\\n                #print(j,k)\\n                ans[j][k] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in range(j+1,m-j):\\n                #print(k,n-j,m-j)\\n                ans[k][n-j-1] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in reversed(range(j,n-j-1)):\\n                #print(m-j-1,k)\\n                ans[m-j-1][k] =head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in reversed(range(j+1,m-j-1)):\\n                #print(k,j)\\n                ans[k][j] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            j += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        ans = [[-1]*n for i in range(m)]\\n        j = 0\\n        while True:\\n            for k in range(j,n-j):\\n                #print(j,k)\\n                ans[j][k] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in range(j+1,m-j):\\n                #print(k,n-j,m-j)\\n                ans[k][n-j-1] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in reversed(range(j,n-j-1)):\\n                #print(m-j-1,k)\\n                ans[m-j-1][k] =head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in reversed(range(j+1,m-j-1)):\\n                #print(k,j)\\n                ans[k][j] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230014,
                "title": "spiral-matrix-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        \\n        int rowStart = 0, rowEnd = m - 1;\\n        int colStart = 0, colEnd = n - 1;\\n        \\n        while(rowStart <= rowEnd && colStart <= colEnd and head){\\n            for(int i = colStart; i <= colEnd; i++){\\n                res[rowStart][i] = (head->val);\\n                head = head->next;\\n                if(!head) return res;\\n            }\\n            for(int i = rowStart + 1; i <= rowEnd; i++){\\n                res[i][colEnd] = (head->val);\\n                head = head->next;\\n                if(!head) return res;\\n            }\\n            if(rowStart < rowEnd && colStart < colEnd){\\n                for(int i = colEnd - 1; i > colStart; i--){\\n                    res[rowEnd][i] = (head->val);\\n                    head = head->next;\\n                    if(!head) return res;\\n                }\\n                for(int i = rowEnd; i > rowStart; i--){\\n                    res[i][colStart] = (head->val);\\n                    head = head->next;\\n                    if(!head) return res;\\n                }\\n            }\\n            rowStart++; colStart++;\\n            colEnd--; rowEnd--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        \\n        int rowStart = 0, rowEnd = m - 1;\\n        int colStart = 0, colEnd = n - 1;\\n        \\n        while(rowStart <= rowEnd && colStart <= colEnd and head){\\n            for(int i = colStart; i <= colEnd; i++){\\n                res[rowStart][i] = (head->val);\\n                head = head->next;\\n                if(!head) return res;\\n            }\\n            for(int i = rowStart + 1; i <= rowEnd; i++){\\n                res[i][colEnd] = (head->val);\\n                head = head->next;\\n                if(!head) return res;\\n            }\\n            if(rowStart < rowEnd && colStart < colEnd){\\n                for(int i = colEnd - 1; i > colStart; i--){\\n                    res[rowEnd][i] = (head->val);\\n                    head = head->next;\\n                    if(!head) return res;\\n                }\\n                for(int i = rowEnd; i > rowStart; i--){\\n                    res[i][colStart] = (head->val);\\n                    head = head->next;\\n                    if(!head) return res;\\n                }\\n            }\\n            rowStart++; colStart++;\\n            colEnd--; rowEnd--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229927,
                "title": "very-simple-java-solution",
                "content": "**Intution**\\nCreate a matrix and iterate over it in a spiral manner and use the linked list to fill it.\\n \\n```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] mat = new int[m][n];\\n        int cnt = 0;\\n        \\n        // boundaies\\n        // Left and right\\n        int lb = 0, rb = n-1;\\n        // ceil and floor\\n        int c = 0, f = m-1;\\n        \\n        while(cnt < (m*n)){\\n            \\n            // Fill L to R\\n            for(int i = lb; i <= rb ; i++){\\n                \\n                cnt++;\\n                if(head != null){   \\n                    mat[c][i] = head.val;\\n                    head = head.next;\\n                }else{\\n                    mat[c][i] = -1;\\n                }\\n            }\\n            \\n            // Fill C to F\\n            for(int j = c+1; j <= f ; j++){\\n                \\n                cnt++;\\n                if(head != null){   \\n                    mat[j][rb] = head.val;\\n                    head = head.next;\\n                }else{\\n                    mat[j][rb] = -1;\\n                }\\n            }\\n            \\n            // Fill R to L\\n            if(f != c){\\n                for(int i = rb-1; i >= lb ; i--){\\n                    \\n                    cnt++;\\n                    if(head != null){   \\n                        mat[f][i] = head.val;\\n                        head = head.next;\\n                    }else{\\n                        mat[f][i] = -1;\\n                    }\\n                }\\n            }\\n            \\n            // Fill F to C\\n            if(lb != rb){\\n                for(int j = f-1; j > c ; j--){\\n\\n                    cnt++;\\n                    if(head != null){   \\n                        mat[j][lb] = head.val;\\n                        head = head.next;\\n                    }else{\\n                        mat[j][lb] = -1;\\n                    }\\n                }\\n            }\\n            \\n            // Increment\\n            lb++;\\n            rb--;\\n            c++;\\n            f--;\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] mat = new int[m][n];\\n        int cnt = 0;\\n        \\n        // boundaies\\n        // Left and right\\n        int lb = 0, rb = n-1;\\n        // ceil and floor\\n        int c = 0, f = m-1;\\n        \\n        while(cnt < (m*n)){\\n            \\n            // Fill L to R\\n            for(int i = lb; i <= rb ; i++){\\n                \\n                cnt++;\\n                if(head != null){   \\n                    mat[c][i] = head.val;\\n                    head = head.next;\\n                }else{\\n                    mat[c][i] = -1;\\n                }\\n            }\\n            \\n            // Fill C to F\\n            for(int j = c+1; j <= f ; j++){\\n                \\n                cnt++;\\n                if(head != null){   \\n                    mat[j][rb] = head.val;\\n                    head = head.next;\\n                }else{\\n                    mat[j][rb] = -1;\\n                }\\n            }\\n            \\n            // Fill R to L\\n            if(f != c){\\n                for(int i = rb-1; i >= lb ; i--){\\n                    \\n                    cnt++;\\n                    if(head != null){   \\n                        mat[f][i] = head.val;\\n                        head = head.next;\\n                    }else{\\n                        mat[f][i] = -1;\\n                    }\\n                }\\n            }\\n            \\n            // Fill F to C\\n            if(lb != rb){\\n                for(int j = f-1; j > c ; j--){\\n\\n                    cnt++;\\n                    if(head != null){   \\n                        mat[j][lb] = head.val;\\n                        head = head.next;\\n                    }else{\\n                        mat[j][lb] = -1;\\n                    }\\n                }\\n            }\\n            \\n            // Increment\\n            lb++;\\n            rb--;\\n            c++;\\n            f--;\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229888,
                "title": "c-simulation",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\tvector<vector<int>>res(m,vector<int>(n,-1));\\n\\t\\t\\tint row = 0, col = 0,drow = m-1,dcol = n-1,dir = 1,val = 1;\\n\\t\\t\\twhile(row<=drow and col<=dcol and head){\\n\\t\\t\\t\\tfor(int i = col;i<=dcol and head;i++, head = head->next) res[row][i] = head->val;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = row;i<=drow and head;i++,head = head->next) res[i][dcol] = head->val;\\n\\t\\t\\t\\tdcol--;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = dcol;i>=col and head;i--,head = head->next) res[drow][i] = head->val;\\n\\t\\t\\t\\tdrow--;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = drow;i>=row and head;i--,head = head->next) res[i][col] = head->val;\\n\\t\\t\\t\\tcol++;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\tvector<vector<int>>res(m,vector<int>(n,-1));\\n\\t\\t\\tint row = 0, col = 0,drow = m-1,dcol = n-1,dir = 1,val = 1;\\n\\t\\t\\twhile(row<=drow and col<=dcol and head){\\n\\t\\t\\t\\tfor(int i = col;i<=dcol and head;i++, head = head->next) res[row][i] = head->val;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = row;i<=drow and head;i++,head = head->next) res[i][dcol] = head->val;\\n\\t\\t\\t\\tdcol--;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = dcol;i>=col and head;i--,head = head->next) res[drow][i] = head->val;\\n\\t\\t\\t\\tdrow--;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = drow;i>=row and head;i--,head = head->next) res[i][col] = head->val;\\n\\t\\t\\t\\tcol++;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2229874,
                "title": "c-easy-solution-similar-to-spiral-matrix-ii",
                "content": "It is exactly similar to the spiral matrix 1 , \\nwe initialize the whole vector by -1 and using the condition temp!=NULL, we traverse the linkedlist\\n```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v( m, vector<int> (n, -1));\\n        \\n        int srow =0;\\n        int scol =0;\\n        int erow = m-1;\\n        int ecol = n-1;\\n        \\n        if( head == NULL) return v;\\n        ListNode* temp = head;\\n        while(temp!= NULL){\\n            for( int index = scol; temp!= NULL && index<=ecol; index++){\\n                v[srow][index]= temp->val;\\n                temp= temp->next;\\n            }\\n            srow++;\\n            for( int index = srow;temp!= NULL && index<=erow; index++){\\n                v[index][ecol]= temp->val;\\n                temp= temp->next;\\n            }\\n            ecol--;\\n            for( int index = ecol; temp!= NULL &&index>=scol; index--){\\n                v[erow][index]= temp->val;\\n                temp= temp->next;\\n            }\\n            erow--;\\n            \\n            for( int index = erow; temp!= NULL && index>=srow; index--){\\n                v[index][scol]= temp->val;\\n                temp= temp->next;\\n            }\\n            scol++;\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v( m, vector<int> (n, -1));\\n        \\n        int srow =0;\\n        int scol =0;\\n        int erow = m-1;\\n        int ecol = n-1;\\n        \\n        if( head == NULL) return v;\\n        ListNode* temp = head;\\n        while(temp!= NULL){\\n            for( int index = scol; temp!= NULL && index<=ecol; index++){\\n                v[srow][index]= temp->val;\\n                temp= temp->next;\\n            }\\n            srow++;\\n            for( int index = srow;temp!= NULL && index<=erow; index++){\\n                v[index][ecol]= temp->val;\\n                temp= temp->next;\\n            }\\n            ecol--;\\n            for( int index = ecol; temp!= NULL &&index>=scol; index--){\\n                v[erow][index]= temp->val;\\n                temp= temp->next;\\n            }\\n            erow--;\\n            \\n            for( int index = erow; temp!= NULL && index>=srow; index--){\\n                v[index][scol]= temp->val;\\n                temp= temp->next;\\n            }\\n            scol++;\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229851,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {                \\n        int[][] result = new int[m][n];\\n        int rowBegin = 0;\\n        int rowEnd = result.length - 1;\\n        int colBegin = 0;\\n        int colEnd = result[0].length - 1;\\n        int index = 0;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                if (head == null) {\\n                    result[rowBegin][i] = -1;\\n                    continue;\\n                }\\n                result[rowBegin][i] = head.val;\\n                head = head.next;\\n            }\\n            rowBegin++;\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                if (head == null) {\\n                    result[i][colEnd] = -1;\\n                    continue;\\n                }\\n                result[i][colEnd] = head.val;\\n                head = head.next;\\n            }\\n            colEnd--;\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    if (head == null) {\\n                        result[rowEnd][i] = -1;\\n                        continue;\\n                    }\\n                    result[rowEnd][i] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            rowEnd--;\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    if (head == null) {\\n                        result[i][colBegin] = -1;\\n                        continue;\\n                    }\\n                    result[i][colBegin] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            colBegin++;\\n        }\\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {                \\n        int[][] result = new int[m][n];\\n        int rowBegin = 0;\\n        int rowEnd = result.length - 1;\\n        int colBegin = 0;\\n        int colEnd = result[0].length - 1;\\n        int index = 0;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                if (head == null) {\\n                    result[rowBegin][i] = -1;\\n                    continue;\\n                }\\n                result[rowBegin][i] = head.val;\\n                head = head.next;\\n            }\\n            rowBegin++;\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                if (head == null) {\\n                    result[i][colEnd] = -1;\\n                    continue;\\n                }\\n                result[i][colEnd] = head.val;\\n                head = head.next;\\n            }\\n            colEnd--;\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    if (head == null) {\\n                        result[rowEnd][i] = -1;\\n                        continue;\\n                    }\\n                    result[rowEnd][i] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            rowEnd--;\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    if (head == null) {\\n                        result[i][colBegin] = -1;\\n                        continue;\\n                    }\\n                    result[i][colBegin] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            colBegin++;\\n        }\\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229845,
                "title": "python3-solution-copy-from-spiral-matrix-ii",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        lst = []\\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(len(matrix) * len(matrix[0])):\\n            if i > len(lst) - 1:\\n                break\\n            matrix[y][x] = lst[i]\\n\\n            if not 0 <= x + dx < n:\\n                dx, dy = -dy, dx\\n            elif not 0 <= y + dy < m:\\n                dx, dy = -dy, dx\\n            elif matrix[y + dy][x + dx] != -1:\\n                dx, dy = -dy, dx\\n\\n            x, y = x + dx, y + dy\\n        return matrix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        lst = []\\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(len(matrix) * len(matrix[0])):\\n            if i > len(lst) - 1:\\n                break\\n            matrix[y][x] = lst[i]\\n\\n            if not 0 <= x + dx < n:\\n                dx, dy = -dy, dx\\n            elif not 0 <= y + dy < m:\\n                dx, dy = -dy, dx\\n            elif matrix[y + dy][x + dx] != -1:\\n                dx, dy = -dy, dx\\n\\n            x, y = x + dx, y + dy\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229843,
                "title": "c-simple-grid-traversal",
                "content": "**Explanation**: In the below code these variable stands for\\nrs - starting of row\\nre - ending of row\\ncs - starting of column\\nce - ending of column\\n\\nors - original starting of row\\nore - original ending of row\\nocs - original starting of column\\noce - original ending of column\\n\\n**C++ Code:**\\n\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m, vector<int>(n, -1));\\n        \\n        int rs = 0, cs = 0, re = m - 1, ce = n-1;\\n        while(rs <= re)\\n        {\\n            if(head == NULL) break;\\n            int ors =rs, ore = re, ocs = cs, oce = ce;\\n            while(cs <= ce)\\n            {\\n                if(head == NULL) break;\\n                mat[rs][cs] = head->val;\\n                head = head->next;\\n                cs++;\\n            }\\n            cs = ocs;\\n            rs++;\\n            while(rs <= re)\\n            {\\n                if(head == NULL) break;\\n                mat[rs][ce] = head->val;\\n                head = head->next;\\n                rs++;\\n            }\\n            rs = ors;\\n            ce--;\\n            while(cs <= ce)\\n            {\\n                if(head == NULL) break;\\n                mat[re][ce] = head->val;\\n                head = head->next;\\n                ce--;\\n            }\\n            ce = oce;\\n            re--;\\n            while(rs < re)\\n            {\\n                if(head == NULL) break;\\n                mat[re][cs] = head->val;\\n                head = head->next;\\n                re--;\\n            }\\n            \\n            rs = ors, re = ore, cs = ocs, ce = oce;\\n            rs++; re--;\\n            cs++; ce--;\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m, vector<int>(n, -1));\\n        \\n        int rs = 0, cs = 0, re = m - 1, ce = n-1;\\n        while(rs <= re)\\n        {\\n            if(head == NULL) break;\\n            int ors =rs, ore = re, ocs = cs, oce = ce;\\n            while(cs <= ce)\\n            {\\n                if(head == NULL) break;\\n                mat[rs][cs] = head->val;\\n                head = head->next;\\n                cs++;\\n            }\\n            cs = ocs;\\n            rs++;\\n            while(rs <= re)\\n            {\\n                if(head == NULL) break;\\n                mat[rs][ce] = head->val;\\n                head = head->next;\\n                rs++;\\n            }\\n            rs = ors;\\n            ce--;\\n            while(cs <= ce)\\n            {\\n                if(head == NULL) break;\\n                mat[re][ce] = head->val;\\n                head = head->next;\\n                ce--;\\n            }\\n            ce = oce;\\n            re--;\\n            while(rs < re)\\n            {\\n                if(head == NULL) break;\\n                mat[re][cs] = head->val;\\n                head = head->next;\\n                re--;\\n            }\\n            \\n            rs = ors, re = ore, cs = ocs, ce = oce;\\n            rs++; re--;\\n            cs++; ce--;\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086964,
                "title": "optimized-spiral-walk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        var matrix = Array<IntArray>(m){IntArray(n){-1}}\\n        head ?: return matrix\\n        var R = arrayOf(0,1,0,-1)\\n        var C = arrayOf(1,0,-1,0)\\n        var (row,col,dr,dc,i) = listOf(0,0,0,0,1)\\n        var size = m*n\\n        var curr = head \\n        while(i++ <= size){\\n            matrix[row][col] = curr!!.`val`\\n            curr = curr?.next\\n            if(curr == null) break\\n            var r = Math.floorMod(row+R[dr],m)\\n            var c = Math.floorMod(col+C[dc],n)\\n            if(matrix[r][c] != -1){\\n                dr = (dr+1) % 4\\n                dc = (dc+1) % 4\\n            }\\n            row += R[dr]\\n            col += C[dc]\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        var matrix = Array<IntArray>(m){IntArray(n){-1}}\\n        head ?: return matrix\\n        var R = arrayOf(0,1,0,-1)\\n        var C = arrayOf(1,0,-1,0)\\n        var (row,col,dr,dc,i) = listOf(0,0,0,0,1)\\n        var size = m*n\\n        var curr = head \\n        while(i++ <= size){\\n            matrix[row][col] = curr!!.`val`\\n            curr = curr?.next\\n            if(curr == null) break\\n            var r = Math.floorMod(row+R[dr],m)\\n            var c = Math.floorMod(col+C[dc],n)\\n            if(matrix[r][c] != -1){\\n                dr = (dr+1) % 4\\n                dc = (dc+1) % 4\\n            }\\n            row += R[dr]\\n            col += C[dc]\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086956,
                "title": "cleanest-spiral-walk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        var matrix = Array<IntArray>(m){IntArray(n){-1}}\\n        head ?: return matrix\\n        var R = arrayOf(0,1,0,-1)\\n        var C = arrayOf(1,0,-1,0)\\n        var (row,col,dr,dc,i) = listOf(0,0,0,0,1)\\n        var size = m*n\\n        var visited = Array<BooleanArray>(m){BooleanArray(n)}\\n        var curr = head \\n        while(i++ <= size){\\n            matrix[row][col] = curr!!.`val`\\n            curr = curr?.next\\n            if(curr == null) break\\n            visited[row][col] = true\\n            var r = Math.floorMod(row+R[dr],m)\\n            var c = Math.floorMod(col+C[dc],n)\\n            if(visited[r][c]){\\n                dr = (dr+1) % 4\\n                dc = (dc+1) % 4\\n            }\\n            row += R[dr]\\n            col += C[dc]\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        var matrix = Array<IntArray>(m){IntArray(n){-1}}\\n        head ?: return matrix\\n        var R = arrayOf(0,1,0,-1)\\n        var C = arrayOf(1,0,-1,0)\\n        var (row,col,dr,dc,i) = listOf(0,0,0,0,1)\\n        var size = m*n\\n        var visited = Array<BooleanArray>(m){BooleanArray(n)}\\n        var curr = head \\n        while(i++ <= size){\\n            matrix[row][col] = curr!!.`val`\\n            curr = curr?.next\\n            if(curr == null) break\\n            visited[row][col] = true\\n            var r = Math.floorMod(row+R[dr],m)\\n            var c = Math.floorMod(col+C[dc],n)\\n            if(visited[r][c]){\\n                dr = (dr+1) % 4\\n                dc = (dc+1) % 4\\n            }\\n            row += R[dr]\\n            col += C[dc]\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076929,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int [][]arr=new int[m][n];\\n        int startrow=0;\\n        int endrow=m-1;\\n        int startcol=0;\\n        int endcol=n-1;\\n        while(startrow<=endrow && startcol<=endcol)\\n        {\\n            // for top\\n            for(int i=startcol;i<=endcol;i++)\\n            {\\n                if(head!=null)\\n                {\\n                    arr[startrow][i]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[startrow][i]=-1;\\n                }\\n            }\\n            // for right\\n            for(int i=startrow+1;i<=endrow;i++)\\n            {\\n                if(head!=null)\\n                {\\n                    arr[i][endcol]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[i][endcol]=-1;\\n                }\\n            }\\n            // for bottom\\n            for(int i=endcol-1;i>=startcol;i--)\\n            {\\n                if(startrow==endrow)\\n                {\\n                    break;\\n                }\\n                if(head!=null)\\n                {\\n                    arr[endrow][i]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[endrow][i]=-1;\\n                }\\n                \\n            }\\n            // for left\\n            for(int i=endrow-1;i>=startrow+1;i--)\\n            {\\n                if(startcol==endcol)\\n                {\\n                    break;\\n                }\\n                if(head!=null)\\n                {\\n                    arr[i][startcol]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[i][startcol]=-1;\\n                }\\n                \\n            }\\n            startrow++;\\n            startcol++;\\n            endrow--;\\n            endcol--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int [][]arr=new int[m][n];\\n        int startrow=0;\\n        int endrow=m-1;\\n        int startcol=0;\\n        int endcol=n-1;\\n        while(startrow<=endrow && startcol<=endcol)\\n        {\\n            // for top\\n            for(int i=startcol;i<=endcol;i++)\\n            {\\n                if(head!=null)\\n                {\\n                    arr[startrow][i]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[startrow][i]=-1;\\n                }\\n            }\\n            // for right\\n            for(int i=startrow+1;i<=endrow;i++)\\n            {\\n                if(head!=null)\\n                {\\n                    arr[i][endcol]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[i][endcol]=-1;\\n                }\\n            }\\n            // for bottom\\n            for(int i=endcol-1;i>=startcol;i--)\\n            {\\n                if(startrow==endrow)\\n                {\\n                    break;\\n                }\\n                if(head!=null)\\n                {\\n                    arr[endrow][i]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[endrow][i]=-1;\\n                }\\n                \\n            }\\n            // for left\\n            for(int i=endrow-1;i>=startrow+1;i--)\\n            {\\n                if(startcol==endcol)\\n                {\\n                    break;\\n                }\\n                if(head!=null)\\n                {\\n                    arr[i][startcol]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[i][startcol]=-1;\\n                }\\n                \\n            }\\n            startrow++;\\n            startcol++;\\n            endrow--;\\n            endcol--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076173,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int [][] arr=new int [m][n];ListNode temp=head;\\n       \\n       int top=0,left=0,right=n-1,bottom=m-1;\\n          int arr1[]=new int[m*n];\\n        for(int in=0;in<arr1.length;in++){\\n            arr1[in]=-1;\\n        }\\n       int in=0;\\n        while(head!=null){\\n            arr1[in]=head.val;\\n            in++;\\n            head=head.next;\\n        }\\nint c=0;\\n       while(left<=right && bottom >=top){\\n\\n        for(int i=left;i<=right;i++){\\n           arr[top][i]=arr1[c];\\n           c++;\\n       }\\n       top++;\\n       for(int i=top;i<=bottom;i++){\\n           arr[i][right]=arr1[c];\\n           c++;\\n       }\\n       right--;\\n       if(top<=bottom){\\n       for(int i=right;i>=left;i--){\\n           arr[bottom][i]=arr1[c];\\n          c++;\\n       }\\n       bottom--;}\\n       if(left<=right){\\n       for(int i=bottom;i>=top;i--){\\n           arr[i][left]=arr1[c];\\n           c++;\\n       }\\n       left++;\\n       }}\\n\\n       \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int [][] arr=new int [m][n];ListNode temp=head;\\n       \\n       int top=0,left=0,right=n-1,bottom=m-1;\\n          int arr1[]=new int[m*n];\\n        for(int in=0;in<arr1.length;in++){\\n            arr1[in]=-1;\\n        }\\n       int in=0;\\n        while(head!=null){\\n            arr1[in]=head.val;\\n            in++;\\n            head=head.next;\\n        }\\nint c=0;\\n       while(left<=right && bottom >=top){\\n\\n        for(int i=left;i<=right;i++){\\n           arr[top][i]=arr1[c];\\n           c++;\\n       }\\n       top++;\\n       for(int i=top;i<=bottom;i++){\\n           arr[i][right]=arr1[c];\\n           c++;\\n       }\\n       right--;\\n       if(top<=bottom){\\n       for(int i=right;i>=left;i--){\\n           arr[bottom][i]=arr1[c];\\n          c++;\\n       }\\n       bottom--;}\\n       if(left<=right){\\n       for(int i=bottom;i>=top;i--){\\n           arr[i][left]=arr1[c];\\n           c++;\\n       }\\n       left++;\\n       }}\\n\\n       \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056465,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        ListNode* temp=head;\\n        int rowstart=0;\\n        int rowend=m-1;\\n        int colstart=0;\\n        int colend=n-1;\\n\\n        while(temp){\\n            for(int col=colstart;col<=colend && temp;col++){\\n                ans[rowstart][col]=temp->val;\\n                temp=temp->next;\\n            }\\n            rowstart++;\\n            for(int row=rowstart;row<=rowend && temp;row++){\\n                ans[row][colend]=temp->val;\\n                temp=temp->next;\\n            }\\n            colend--;\\n            for(int col=colend;col>=colstart && temp;col--){\\n                ans[rowend][col]=temp->val;\\n                temp=temp->next;\\n            }\\n            rowend--;\\n            for(int row=rowend;row>=rowstart && temp;row--){\\n                ans[row][colstart]=temp->val;\\n                temp=temp->next;\\n            }\\n            colstart++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        ListNode* temp=head;\\n        int rowstart=0;\\n        int rowend=m-1;\\n        int colstart=0;\\n        int colend=n-1;\\n\\n        while(temp){\\n            for(int col=colstart;col<=colend && temp;col++){\\n                ans[rowstart][col]=temp->val;\\n                temp=temp->next;\\n            }\\n            rowstart++;\\n            for(int row=rowstart;row<=rowend && temp;row++){\\n                ans[row][colend]=temp->val;\\n                temp=temp->next;\\n            }\\n            colend--;\\n            for(int col=colend;col>=colstart && temp;col--){\\n                ans[rowend][col]=temp->val;\\n                temp=temp->next;\\n            }\\n            rowend--;\\n            for(int row=rowend;row>=rowstart && temp;row--){\\n                ans[row][colstart]=temp->val;\\n                temp=temp->next;\\n            }\\n            colstart++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032264,
                "title": "c-easy-to-understand-solution-similar-to-spiral-matrix-1-and-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int> >ans(m,vector<int>(n,-1));\\n        int lowr=0,lowc=0;\\n        int highr=m-1;\\n        int highc=n-1;\\n        ListNode*temp=head;\\n        while(lowr<=highr && lowc<=highc){\\n            for(int j=lowc;j<=highc;j++){\\n                if(temp==nullptr) return ans;\\n                ans[lowr][j]=temp->val;\\n                temp=temp->next;\\n            }\\n            lowr++;\\n            for(int i=lowr;i<=highr;i++){\\n                if(temp==nullptr) return ans;\\n                ans[i][highc]=temp->val;\\n                temp=temp->next;\\n            }\\n            highc--;\\n            for(int j=highc;j>=lowc;j--){\\n                if(temp==nullptr) return ans;\\n                ans[highr][j]=temp->val;\\n                temp=temp->next;\\n            }\\n            highr--;\\n            for(int i=highr;i>=lowr;i--){\\n                if(temp==nullptr) return ans;\\n                ans[i][lowc]=temp->val;\\n                temp=temp->next;\\n            }\\n            lowc++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int> >ans(m,vector<int>(n,-1));\\n        int lowr=0,lowc=0;\\n        int highr=m-1;\\n        int highc=n-1;\\n        ListNode*temp=head;\\n        while(lowr<=highr && lowc<=highc){\\n            for(int j=lowc;j<=highc;j++){\\n                if(temp==nullptr) return ans;\\n                ans[lowr][j]=temp->val;\\n                temp=temp->next;\\n            }\\n            lowr++;\\n            for(int i=lowr;i<=highr;i++){\\n                if(temp==nullptr) return ans;\\n                ans[i][highc]=temp->val;\\n                temp=temp->next;\\n            }\\n            highc--;\\n            for(int j=highc;j>=lowc;j--){\\n                if(temp==nullptr) return ans;\\n                ans[highr][j]=temp->val;\\n                temp=temp->next;\\n            }\\n            highr--;\\n            for(int i=highr;i>=lowr;i--){\\n                if(temp==nullptr) return ans;\\n                ans[i][lowc]=temp->val;\\n                temp=temp->next;\\n            }\\n            lowc++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020062,
                "title": "easy-to-understand-and-simple-solution-must-check-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int minr =0;\\n        int minc =0;\\n        int maxr =m-1;\\n        int maxc =n-1;\\n        int tn =m*n;\\n        int count=0;\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        while(count<tn){\\n\\n            //upper wall.........\\n            for(int i=minc; i<=maxc && count<tn; i++){\\n                if(head!=NULL){\\n                ans[minr][i]= head->val;\\n                head=head->next;\\n                }\\n                else{ans[minr][i]= -1;}\\n                count++;\\n            }\\n            minr++;\\n\\n            //right wall..........\\n            for(int i=minr; i<=maxr && count<tn; i++){\\n                if(head!=NULL){\\n                ans[i][maxc]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[i][maxc]=-1;}\\n                count++;\\n            }\\n            maxc--;\\n\\n            //bottom wall..........\\n            for(int i=maxc; i>=minc && count<tn; i--){\\n                if(head!=NULL){\\n                ans[maxr][i]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[maxr][i]=-1;}\\n                count++;\\n            }\\n            maxr--;\\n            \\n            //left wall...........\\n            for(int i=maxr; i>=minr && count<tn; i--){\\n                if(head!=NULL){\\n                ans[i][minc]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[i][minc]=-1;}\\n                count++;\\n            }\\n            minc++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int minr =0;\\n        int minc =0;\\n        int maxr =m-1;\\n        int maxc =n-1;\\n        int tn =m*n;\\n        int count=0;\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        while(count<tn){\\n\\n            //upper wall.........\\n            for(int i=minc; i<=maxc && count<tn; i++){\\n                if(head!=NULL){\\n                ans[minr][i]= head->val;\\n                head=head->next;\\n                }\\n                else{ans[minr][i]= -1;}\\n                count++;\\n            }\\n            minr++;\\n\\n            //right wall..........\\n            for(int i=minr; i<=maxr && count<tn; i++){\\n                if(head!=NULL){\\n                ans[i][maxc]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[i][maxc]=-1;}\\n                count++;\\n            }\\n            maxc--;\\n\\n            //bottom wall..........\\n            for(int i=maxc; i>=minc && count<tn; i--){\\n                if(head!=NULL){\\n                ans[maxr][i]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[maxr][i]=-1;}\\n                count++;\\n            }\\n            maxr--;\\n            \\n            //left wall...........\\n            for(int i=maxr; i>=minr && count<tn; i--){\\n                if(head!=NULL){\\n                ans[i][minc]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[i][minc]=-1;}\\n                count++;\\n            }\\n            minc++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019990,
                "title": "shortest-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int v[4][4]={{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int i=0,j=0;int k=0;\\n        while(head!=NULL){\\n           ans[i][j]=head->val;\\n           head=head->next;\\n           if(i+v[k][0]==m || j+v[k][1] == n || i+v[k][0]<0 || j+v[k][1]<0 || ans[i+v[k][0]][j+v[k][1]]!=-1)k++;\\n           k%=4;\\n           i+=v[k][0];\\n           j+=v[k][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int v[4][4]={{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int i=0,j=0;int k=0;\\n        while(head!=NULL){\\n           ans[i][j]=head->val;\\n           head=head->next;\\n           if(i+v[k][0]==m || j+v[k][1] == n || i+v[k][0]<0 || j+v[k][1]<0 || ans[i+v[k][0]][j+v[k][1]]!=-1)k++;\\n           k%=4;\\n           i+=v[k][0];\\n           j+=v[k][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005381,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) i first though of directly solving using mat[][]=temp.val, temp=temp.next. \\n2) we store the values of linkedlist in an array, so that we directly assign the matrix value with arr value.\\n3) we run the logic of spiral matrix 1, here with 4 pointers runing until the matrix complete\\'s.\\n4) we keep assigning the value of matrix element to the array element and keep traversing until simultaneously the matrix and array is filled.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] mat = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m - 1;\\n        int colStart = 0;\\n        int colEnd = n - 1;\\n        //ListNode temp = head;\\n        int arr[]=new int[m*n];\\n        for(int in=0;in<arr.length;in++){\\n            arr[in]=-1;\\n        }\\n       int in=0;\\n        while(head!=null){\\n            arr[in]=head.val;\\n            in++;\\n            head=head.next;\\n        }\\nint c=0;\\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            // Traverse right\\n            for (int j = colStart; j <= colEnd; j++) {\\n                    mat[rowStart][j] = arr[c];\\n                    c++;\\n                }\\n            \\n            rowStart++;\\n\\n            // Traverse down\\n            for (int i = rowStart; i <= rowEnd; i++) {\\n              \\n                    mat[i][colEnd] = arr[c];\\n                    c++;\\n                \\n            }\\n            colEnd--;\\n\\n            // Traverse left\\n            if (rowStart <= rowEnd) {\\n                for (int j = colEnd; j >= colStart; j--) {\\n                  \\n                        mat[rowEnd][j] = arr[c];\\n                        c++;\\n                    \\n                }\\n                rowEnd--;\\n            }\\n\\n            // Traverse up\\n            if (colStart <= colEnd) {\\n                for (int i = rowEnd; i >= rowStart; i--) {\\n                    \\n                        mat[i][colStart] = arr[c];\\n                        c++;\\n                    \\n                }\\n                colStart++;\\n            }\\n        }\\n\\n        return mat;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] mat = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m - 1;\\n        int colStart = 0;\\n        int colEnd = n - 1;\\n        //ListNode temp = head;\\n        int arr[]=new int[m*n];\\n        for(int in=0;in<arr.length;in++){\\n            arr[in]=-1;\\n        }\\n       int in=0;\\n        while(head!=null){\\n            arr[in]=head.val;\\n            in++;\\n            head=head.next;\\n        }\\nint c=0;\\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            // Traverse right\\n            for (int j = colStart; j <= colEnd; j++) {\\n                    mat[rowStart][j] = arr[c];\\n                    c++;\\n                }\\n            \\n            rowStart++;\\n\\n            // Traverse down\\n            for (int i = rowStart; i <= rowEnd; i++) {\\n              \\n                    mat[i][colEnd] = arr[c];\\n                    c++;\\n                \\n            }\\n            colEnd--;\\n\\n            // Traverse left\\n            if (rowStart <= rowEnd) {\\n                for (int j = colEnd; j >= colStart; j--) {\\n                  \\n                        mat[rowEnd][j] = arr[c];\\n                        c++;\\n                    \\n                }\\n                rowEnd--;\\n            }\\n\\n            // Traverse up\\n            if (colStart <= colEnd) {\\n                for (int i = rowEnd; i >= rowStart; i--) {\\n                    \\n                        mat[i][colStart] = arr[c];\\n                        c++;\\n                    \\n                }\\n                colStart++;\\n            }\\n        }\\n\\n        return mat;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998741,
                "title": "beats-98-63-solutions-java-c-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake use of direction up, down, left, right. To direct the flow of matrix\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n\\n# C++ Code \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        ListNode* tmp = head;\\n        int t = 0, s = 0;\\n        int b = n-1, a = m-1;\\n        while(1)\\n        {\\n            for(int i=s;i<=a;i++)\\n            {\\n                ans[t][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            t++;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = t;i<=b;i++)\\n            {\\n                ans[i][a] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            a--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = a;i>=s;i--)\\n            {\\n                ans[b][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            b--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = b;i>=t;i--)\\n            {\\n                ans[i][s] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            s++;\\n            if(tmp == NULL)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python Code\\n```\\n\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        result = [ [-1] * n for _ in range(m) ]\\n        node = head\\n        \\n        \\n        \\n        UP = 2\\n        DOWN = 3\\n        LEFT = 1\\n        RIGHT = 0\\n        \\n        directions = ( (0,1), (0,-1), (-1,0), (1,0))\\n        direction = RIGHT\\n        \\n        uB, dB, lB, rB = 0, m-1, 0, n-1\\n        row, col = 0, 0\\n\\n        while node:\\n            result[row][col] = node.val \\n            node = node.next \\n\\n            if direction == RIGHT and col == rB and row != dB:\\n                direction = DOWN\\n                uB += 1\\n            \\n\\n            if direction == DOWN and col == rB and row == dB:\\n                direction = LEFT\\n                rB -= 1\\n                \\n            if direction == LEFT and col == lB and row != uB:\\n                direction = UP\\n                dB -= 1\\n                \\n            if direction == UP and col == lB and row == uB:\\n                direction = RIGHT\\n                lB += 1\\n            \\n            dr,dc = directions[direction]\\n            row,col = row+dr, col+dc\\n\\n        return result\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        ListNode* tmp = head;\\n        int t = 0, s = 0;\\n        int b = n-1, a = m-1;\\n        while(1)\\n        {\\n            for(int i=s;i<=a;i++)\\n            {\\n                ans[t][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            t++;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = t;i<=b;i++)\\n            {\\n                ans[i][a] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            a--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = a;i>=s;i--)\\n            {\\n                ans[b][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            b--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = b;i>=t;i--)\\n            {\\n                ans[i][s] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            s++;\\n            if(tmp == NULL)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        result = [ [-1] * n for _ in range(m) ]\\n        node = head\\n        \\n        \\n        \\n        UP = 2\\n        DOWN = 3\\n        LEFT = 1\\n        RIGHT = 0\\n        \\n        directions = ( (0,1), (0,-1), (-1,0), (1,0))\\n        direction = RIGHT\\n        \\n        uB, dB, lB, rB = 0, m-1, 0, n-1\\n        row, col = 0, 0\\n\\n        while node:\\n            result[row][col] = node.val \\n            node = node.next \\n\\n            if direction == RIGHT and col == rB and row != dB:\\n                direction = DOWN\\n                uB += 1\\n            \\n\\n            if direction == DOWN and col == rB and row == dB:\\n                direction = LEFT\\n                rB -= 1\\n                \\n            if direction == LEFT and col == lB and row != uB:\\n                direction = UP\\n                dB -= 1\\n                \\n            if direction == UP and col == lB and row == uB:\\n                direction = RIGHT\\n                lB += 1\\n            \\n            dr,dc = directions[direction]\\n            row,col = row+dr, col+dc\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996260,
                "title": "2326-spiral-matrix-iv-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n     vector<vector<int>> ans (m,vector<int>(n,-1));\\n        int startrow=0;\\n        int endrow=m-1;\\n        int startcol=0;\\n        int endcol=n-1;\\n \\n        while(head!=NULL)\\n        {\\n            for(int i=startcol;i<=endcol&&head!=NULL;i++)\\n            {\\n                ans[startrow][i]=head->val;\\n                head=head->next;\\n            }\\n            startrow++;\\n            for(int i=startrow;i<=endrow&&head!=NULL;i++)\\n            {\\n                ans[i][endcol]=head->val;\\n                head=head->next;\\n            }\\n            endcol--;\\n             for(int i=endcol;i>=startcol&&head!=NULL;i--)\\n            {\\n                ans[endrow][i]=head->val;\\n                head=head->next;\\n            }\\n            endrow--;\\n             for(int i=endrow;i>=startrow&&head!=NULL;i--)\\n            {\\n                ans[i][startcol]=head->val;\\n                head=head->next;\\n            }\\n            startcol++;\\n\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n     vector<vector<int>> ans (m,vector<int>(n,-1));\\n        int startrow=0;\\n        int endrow=m-1;\\n        int startcol=0;\\n        int endcol=n-1;\\n \\n        while(head!=NULL)\\n        {\\n            for(int i=startcol;i<=endcol&&head!=NULL;i++)\\n            {\\n                ans[startrow][i]=head->val;\\n                head=head->next;\\n            }\\n            startrow++;\\n            for(int i=startrow;i<=endrow&&head!=NULL;i++)\\n            {\\n                ans[i][endcol]=head->val;\\n                head=head->next;\\n            }\\n            endcol--;\\n             for(int i=endcol;i>=startcol&&head!=NULL;i--)\\n            {\\n                ans[endrow][i]=head->val;\\n                head=head->next;\\n            }\\n            endrow--;\\n             for(int i=endrow;i>=startrow&&head!=NULL;i--)\\n            {\\n                ans[i][startcol]=head->val;\\n                head=head->next;\\n            }\\n            startcol++;\\n\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993613,
                "title": "spiral-matrix-iv-my-simple-java-solution",
                "content": "\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\t\\t\\t\\t\\tint res[][] = new int[m][n];\\n\\t\\t\\t\\t\\tfor(int i = 0; i < m; i++){\\n\\t\\t\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\t\\tres[i][j] = -1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(head == null)    return res;\\n\\t\\t\\t\\t\\tint rowStart = 0;\\n\\t\\t\\t\\t\\tint colStart = 0; \\n\\t\\t\\t\\t\\tint rowEnd = m-1;\\n\\t\\t\\t\\t\\tint colEnd = n-1;\\n\\n\\t\\t\\tListNode currNode = head;\\n\\t\\t\\twhile(rowStart <= rowEnd && colStart <= colEnd && currNode != null){\\n\\t\\t\\t\\tfor(int i = colStart; i<= colEnd && currNode != null; i++){\\n\\t\\t\\t\\t\\tres[rowStart][i] = currNode.val;\\n\\t\\t\\t\\t\\tcurrNode = currNode.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trowStart++;\\n\\n\\t\\t\\t\\tfor(int i = rowStart; i<= rowEnd && currNode != null; i++){\\n\\t\\t\\t\\t\\tres[i][colEnd] = currNode.val;\\n\\t\\t\\t\\t\\tcurrNode = currNode.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcolEnd--;\\n\\n\\t\\t\\t\\tif(rowStart <= rowEnd){\\n\\t\\t\\t\\t\\tfor(int i = colEnd; i>=colStart && currNode != null; i--){\\n\\t\\t\\t\\t\\t\\tres[rowEnd][i] = currNode.val;\\n\\t\\t\\t\\t\\t\\tcurrNode = currNode.next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trowEnd--;    \\n\\n\\t\\t\\t\\tif(colStart <= colEnd){\\n\\t\\t\\t\\t\\tfor(int i = rowEnd; (i>=rowStart && currNode != null); i--){\\n\\t\\t\\t\\t\\t\\tres[i][colStart] = currNode.val;\\n\\t\\t\\t\\t\\t\\tcurrNode = currNode.next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcolStart++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\t\\t\\t\\t\\tint res[][] = new int[m][n];\\n\\t\\t\\t\\t\\tfor(int i = 0; i < m; i++){\\n\\t\\t\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\t\\tres[i][j] = -1;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3981264,
                "title": "easy-for-beginners-beats-70-plus-in-python",
                "content": "![image.png](https://assets.leetcode.com/users/images/10c25c82-b5cf-42e4-9935-eeaa6fce27d0_1693410512.929691.png)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix = []\\n        for i in range(m):\\n            l=[]\\n            for j in range(n):\\n                l.append(-1)\\n            matrix.append(l)\\n        #print(matrix)\\n        val = []\\n        while(head):\\n            val.append(head.val)\\n            head = head.next\\n        #print(val)\\n        top , left = 0 , 0\\n        bot , right = m - 1 , n - 1\\n        w = 0\\n        top , left = 0 , 0\\n        bot , right = len(matrix) - 1 , len(matrix[0]) - 1\\n        while(top <= bot and left <= right):\\n            for i in range(top,right+1):\\n                if w < len(val):\\n                    matrix[top][i] = val[w]\\n                    w += 1\\n                else:\\n                    continue\\n            top += 1\\n            \\n            for i in range(top,bot+1):\\n                if w < len(val):\\n                    matrix[i][right] = val[w]\\n                    w += 1\\n                else:\\n                    continue\\n            right -= 1\\n            if top <= bot:\\n                for i in range(right,left - 1,-1):\\n                    if w < len(val):\\n                        matrix[bot][i] = val[w]\\n                        w += 1\\n                    else:\\n                        continue\\n                bot -= 1\\n            if left <= right:\\n                for i in range(bot,top-1,-1):\\n                    if w < len(val):\\n                        matrix[i][left] = val[w]\\n                        w += 1\\n                    else:\\n                        continue\\n                left += 1\\n            \\n        return matrix\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix = []\\n        for i in range(m):\\n            l=[]\\n            for j in range(n):\\n                l.append(-1)\\n            matrix.append(l)\\n        #print(matrix)\\n        val = []\\n        while(head):\\n            val.append(head.val)\\n            head = head.next\\n        #print(val)\\n        top , left = 0 , 0\\n        bot , right = m - 1 , n - 1\\n        w = 0\\n        top , left = 0 , 0\\n        bot , right = len(matrix) - 1 , len(matrix[0]) - 1\\n        while(top <= bot and left <= right):\\n            for i in range(top,right+1):\\n                if w < len(val):\\n                    matrix[top][i] = val[w]\\n                    w += 1\\n                else:\\n                    continue\\n            top += 1\\n            \\n            for i in range(top,bot+1):\\n                if w < len(val):\\n                    matrix[i][right] = val[w]\\n                    w += 1\\n                else:\\n                    continue\\n            right -= 1\\n            if top <= bot:\\n                for i in range(right,left - 1,-1):\\n                    if w < len(val):\\n                        matrix[bot][i] = val[w]\\n                        w += 1\\n                    else:\\n                        continue\\n                bot -= 1\\n            if left <= right:\\n                for i in range(bot,top-1,-1):\\n                    if w < len(val):\\n                        matrix[i][left] = val[w]\\n                        w += 1\\n                    else:\\n                        continue\\n                left += 1\\n            \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980798,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    # \\u6309\\u7167\\u4EE5\\u4E0B\\u987A\\u5E8F\\u904D\\u5386\\n    # \\u5DE6->\\u53F3\\n    # \\u4E0A->\\u4E0B\\n    # \\u53F3->\\u5DE6\\n    # \\u4E0B->\\u4E0A\\n    # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5B50\\u5FAA\\u73AF\\u5185return mat\\n    # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5916\\u5FAA\\u73AF\\u7ED3\\u675F\\uFF0Creturn mat\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def spiralMatrix(self, m, n, head):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type head: Optional[ListNode]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # \\u6309\\u7167\\u4EE5\\u4E0B\\u987A\\u5E8F\\u904D\\u5386\\n        # \\u5DE6->\\u53F3\\n        # \\u4E0A->\\u4E0B\\n        # \\u53F3->\\u5DE6\\n        # \\u4E0B->\\u4E0A\\n        # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5B50\\u5FAA\\u73AF\\u5185return mat\\n        # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5916\\u5FAA\\u73AF\\u7ED3\\u675F\\uFF0Creturn mat\\n\\n        mat = [[-1 for j in range(n)] for i in range(m)]\\n        ceil,bott=0,m-1\\n        left,right=0,n-1\\n\\n        while head:\\n            # \\u5DE6->\\u53F3\\n            for i in range(left,right+1,1):\\n                if head is None:\\n                    return mat\\n                mat[ceil][i] = head.val\\n                head = head.next\\n            ceil += 1\\n\\n            for j in range(ceil,bott+1,1):\\n                if head is None:\\n                    return mat\\n                mat[j][right] = head.val\\n                head = head.next\\n            right -= 1\\n\\n            for k in range(right,left-1,-1):\\n                if head is None:\\n                    return mat\\n                mat[bott][k] = head.val\\n                head = head.next\\n            bott -= 1\\n\\n            for l in range(bott,ceil-1,-1):\\n                if head is None:\\n                    return mat\\n                mat[l][left] = head.val\\n                head = head.next\\n            left += 1\\n        return mat\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def spiralMatrix(self, m, n, head):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type head: Optional[ListNode]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # \\u6309\\u7167\\u4EE5\\u4E0B\\u987A\\u5E8F\\u904D\\u5386\\n        # \\u5DE6->\\u53F3\\n        # \\u4E0A->\\u4E0B\\n        # \\u53F3->\\u5DE6\\n        # \\u4E0B->\\u4E0A\\n        # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5B50\\u5FAA\\u73AF\\u5185return mat\\n        # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5916\\u5FAA\\u73AF\\u7ED3\\u675F\\uFF0Creturn mat\\n\\n        mat = [[-1 for j in range(n)] for i in range(m)]\\n        ceil,bott=0,m-1\\n        left,right=0,n-1\\n\\n        while head:\\n            # \\u5DE6->\\u53F3\\n            for i in range(left,right+1,1):\\n                if head is None:\\n                    return mat\\n                mat[ceil][i] = head.val\\n                head = head.next\\n            ceil += 1\\n\\n            for j in range(ceil,bott+1,1):\\n                if head is None:\\n                    return mat\\n                mat[j][right] = head.val\\n                head = head.next\\n            right -= 1\\n\\n            for k in range(right,left-1,-1):\\n                if head is None:\\n                    return mat\\n                mat[bott][k] = head.val\\n                head = head.next\\n            bott -= 1\\n\\n            for l in range(bott,ceil-1,-1):\\n                if head is None:\\n                    return mat\\n                mat[l][left] = head.val\\n                head = head.next\\n            left += 1\\n        return mat\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976902,
                "title": "spiral-matrix-iv",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr= new int[m][n];\\n        int[] ans = new int[m*n];\\n        int j=0;\\n        while(head!=null)\\n        {\\n            ans[j] = head.val;\\n            head=head.next;\\n            j++;\\n        }\\n        while(j<m*n)\\n        {\\n            ans[j] = -1;\\n            j++;\\n        }\\n        int left = 0;\\n        int top = 0;\\n        int right = n-1;\\n        int bottom = m-1;\\n        j=0;\\n        while(left<=right&&top<=bottom)\\n        {\\n        for(int i=left;i<=right;i++)\\n         {\\n             arr[top][i] = ans[j];\\n             j++;\\n         }\\n         top++;\\n         for(int i=top;i<=bottom;i++)\\n         {\\n             arr[i][right] = ans[j];\\n             j++;\\n         }\\n         right--;\\n         if(top<=bottom)\\n         {\\n             for(int i=right;i>=left;i--)\\n             {\\n                 arr[bottom][i] = ans[j];\\n             j++;\\n             }\\n             bottom--;\\n         }\\n         if(left<=right)\\n         {\\n             for(int i=bottom;i>=top;i--)\\n             {\\n                 arr[i][left] = ans[j];\\n             j++;\\n             }\\n             left++;\\n         }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr= new int[m][n];\\n        int[] ans = new int[m*n];\\n        int j=0;\\n        while(head!=null)\\n        {\\n            ans[j] = head.val;\\n            head=head.next;\\n            j++;\\n        }\\n        while(j<m*n)\\n        {\\n            ans[j] = -1;\\n            j++;\\n        }\\n        int left = 0;\\n        int top = 0;\\n        int right = n-1;\\n        int bottom = m-1;\\n        j=0;\\n        while(left<=right&&top<=bottom)\\n        {\\n        for(int i=left;i<=right;i++)\\n         {\\n             arr[top][i] = ans[j];\\n             j++;\\n         }\\n         top++;\\n         for(int i=top;i<=bottom;i++)\\n         {\\n             arr[i][right] = ans[j];\\n             j++;\\n         }\\n         right--;\\n         if(top<=bottom)\\n         {\\n             for(int i=right;i>=left;i--)\\n             {\\n                 arr[bottom][i] = ans[j];\\n             j++;\\n             }\\n             bottom--;\\n         }\\n         if(left<=right)\\n         {\\n             for(int i=bottom;i>=top;i--)\\n             {\\n                 arr[i][left] = ans[j];\\n             j++;\\n             }\\n             left++;\\n         }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972344,
                "title": "fully-explained-best-soln-ever-saw-cpp-easy",
                "content": "\\n\\n# Code\\n```\\n//FOLLOW UP OF SPIRAL MATRIX 2 \\n// INDEX ++ KARNE KE BAJAYE LL SE VALUE DAALKE AAGE BADA\\n//also tmep=NULL TOH ELEMENTS DAALKE HO GAYA HENCE RETURN ARR\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        //4 variables lagenge \\n        //top\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        //temp bana\\n        ListNode *temp=head;\\n      while(top<=bottom and left<=right)\\n      {\\n          //-------->\\n          //for the 1st row\\n          //1st row fix hai and col is changing\\n          //chal raha from left to right\\n          for(int j=left;j<=right;j++)\\n          {     \\n              if(temp==NULL) return ans;\\n              ans[top][j]=temp->val;\\n              temp=temp->next;\\n          }\\n          //first row ie is 0 bhar gaya\\n          //now second row ir 1 st me jana\\n          top++;\\n\\n         \\n          //for the last column\\n          //col fix row changes\\n          //top se bottom chalega loop\\n          for(int i=top;i<=bottom;i++)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[i][right]=temp->val;\\n              temp=temp->next;\\n          }\\n          //last column fill ho gaya \\n          //ab last column ie 3 se aab 2 me aaye\\n          right--;\\n\\n          //<---------------- hence decrement\\n          //for last row\\n          //row same hai col changes\\n          //for chalega from right se left\\n\\n          for(int j=right;j>=left;j--)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[bottom][j]=temp->val;\\n              temp=temp->next;\\n          }\\n          //last row bhar gaya \\n          // ab 2 row se 1 row me jana\\n          bottom--;\\n\\n          //upar jana\\n          //first col same and row changes\\n          //for chalega from bottom to top\\n          for(int i=bottom;i>=top;i--)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[i][left]=temp->val;\\n              temp=temp->next;\\n          }\\n        //values bharne ke baad\\n        //abb --> jayega ie left++\\n          left++;\\n          \\n\\n      }\\n      return ans;\\n\\n    }\\n};\\n```\\n\\nUPVOTE OR ELSE NO PLACEMENT",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//FOLLOW UP OF SPIRAL MATRIX 2 \\n// INDEX ++ KARNE KE BAJAYE LL SE VALUE DAALKE AAGE BADA\\n//also tmep=NULL TOH ELEMENTS DAALKE HO GAYA HENCE RETURN ARR\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        //4 variables lagenge \\n        //top\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        //temp bana\\n        ListNode *temp=head;\\n      while(top<=bottom and left<=right)\\n      {\\n          //-------->\\n          //for the 1st row\\n          //1st row fix hai and col is changing\\n          //chal raha from left to right\\n          for(int j=left;j<=right;j++)\\n          {     \\n              if(temp==NULL) return ans;\\n              ans[top][j]=temp->val;\\n              temp=temp->next;\\n          }\\n          //first row ie is 0 bhar gaya\\n          //now second row ir 1 st me jana\\n          top++;\\n\\n         \\n          //for the last column\\n          //col fix row changes\\n          //top se bottom chalega loop\\n          for(int i=top;i<=bottom;i++)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[i][right]=temp->val;\\n              temp=temp->next;\\n          }\\n          //last column fill ho gaya \\n          //ab last column ie 3 se aab 2 me aaye\\n          right--;\\n\\n          //<---------------- hence decrement\\n          //for last row\\n          //row same hai col changes\\n          //for chalega from right se left\\n\\n          for(int j=right;j>=left;j--)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[bottom][j]=temp->val;\\n              temp=temp->next;\\n          }\\n          //last row bhar gaya \\n          // ab 2 row se 1 row me jana\\n          bottom--;\\n\\n          //upar jana\\n          //first col same and row changes\\n          //for chalega from bottom to top\\n          for(int i=bottom;i>=top;i--)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[i][left]=temp->val;\\n              temp=temp->next;\\n          }\\n        //values bharne ke baad\\n        //abb --> jayega ie left++\\n          left++;\\n          \\n\\n      }\\n      return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971188,
                "title": "easy-solution-cpp-fastest",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans (m, vector<int> (n, -1)); \\n\\n        int sr = 0, sc = 0, er = m-1, ec = n-1;   \\n\\n        while(sr < er && sc < ec){\\n\\n            for(int i = sc ; i < ec ;i++) {\\n                if(head == nullptr) return ans;\\n                ans[sr][i] = head->val;\\n                head = head->next;\\n                \\n            }\\n\\n            for(int i = sr ; i < er ; i++){    \\n                if(head == nullptr) return ans;\\n                ans[i][ec] = head->val;\\n                head = head->next;\\n                \\n            }     \\n\\n            for(int i = ec; i > sc ; i--) {   \\n                if(head == nullptr) return ans;\\n                ans[er][i] = head->val;\\n                head = head->next;\\n                \\n                \\n            }\\n\\n            for(int i = er ; i > sr; i--) {    \\n                if(head == nullptr) return ans;\\n                ans[i][sc] = head->val;\\n                head = head->next;\\n                \\n            }\\n    \\n            sr++;sc++;\\n            er--; ec--;\\n        }\\n        \\n        if(sc == ec &&sr < er ) for(int i = sr ; i<= er ; i++){\\n            if(head == nullptr) return ans;\\n            ans[i][sc] = head->val;\\n            head = head->next;\\n            \\n        }\\n        \\n        if(sr  == er && sc < ec  ) for(int i = sc ; i<= ec ; i++) {\\n            if(head == nullptr) return ans;\\n            ans[sr][i] = head->val;\\n            head = head->next;\\n            \\n        }\\n        \\n        if(sr == er && sc == ec) {\\n            if(head == nullptr) return ans;\\n            ans[sr][sc] = head->val;\\n             head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans (m, vector<int> (n, -1)); \\n\\n        int sr = 0, sc = 0, er = m-1, ec = n-1;   \\n\\n        while(sr < er && sc < ec){\\n\\n            for(int i = sc ; i < ec ;i++) {\\n                if(head == nullptr) return ans;\\n                ans[sr][i] = head->val;\\n                head = head->next;\\n                \\n            }\\n\\n            for(int i = sr ; i < er ; i++){    \\n                if(head == nullptr) return ans;\\n                ans[i][ec] = head->val;\\n                head = head->next;\\n                \\n            }     \\n\\n            for(int i = ec; i > sc ; i--) {   \\n                if(head == nullptr) return ans;\\n                ans[er][i] = head->val;\\n                head = head->next;\\n                \\n                \\n            }\\n\\n            for(int i = er ; i > sr; i--) {    \\n                if(head == nullptr) return ans;\\n                ans[i][sc] = head->val;\\n                head = head->next;\\n                \\n            }\\n    \\n            sr++;sc++;\\n            er--; ec--;\\n        }\\n        \\n        if(sc == ec &&sr < er ) for(int i = sr ; i<= er ; i++){\\n            if(head == nullptr) return ans;\\n            ans[i][sc] = head->val;\\n            head = head->next;\\n            \\n        }\\n        \\n        if(sr  == er && sc < ec  ) for(int i = sc ; i<= ec ; i++) {\\n            if(head == nullptr) return ans;\\n            ans[sr][i] = head->val;\\n            head = head->next;\\n            \\n        }\\n        \\n        if(sr == er && sc == ec) {\\n            if(head == nullptr) return ans;\\n            ans[sr][sc] = head->val;\\n             head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968875,
                "title": "easy-cpp-solution-beats-72-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/bd85b0c5-455d-420b-8788-790e438a1964_1693161709.7809508.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n,-1));\\n\\n        int sr=0, sc=0,er=m-1,ec=n-1;\\n        ListNode* curr = head;\\n        while(curr != NULL){\\n            for(int i=sc; i<=ec && curr; i++){\\n                ans[sr][i] = curr->val;\\n                curr = curr->next;\\n            }\\n            sr++;\\n            for(int i=sr; i<=er && curr; i++){\\n                ans[i][ec] = curr->val;\\n                curr = curr->next;\\n            }\\n            ec--;\\n            for(int i=ec; i>=sc && curr; i--){\\n                ans[er][i] = curr->val;\\n                curr = curr->next;\\n            }\\n            er--;\\n            for(int i=er; i>=sr && curr; i--){\\n                ans[i][sc] = curr->val;\\n                curr = curr->next;\\n            }\\n            sc++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n,-1));\\n\\n        int sr=0, sc=0,er=m-1,ec=n-1;\\n        ListNode* curr = head;\\n        while(curr != NULL){\\n            for(int i=sc; i<=ec && curr; i++){\\n                ans[sr][i] = curr->val;\\n                curr = curr->next;\\n            }\\n            sr++;\\n            for(int i=sr; i<=er && curr; i++){\\n                ans[i][ec] = curr->val;\\n                curr = curr->next;\\n            }\\n            ec--;\\n            for(int i=ec; i>=sc && curr; i--){\\n                ans[er][i] = curr->val;\\n                curr = curr->next;\\n            }\\n            er--;\\n            for(int i=er; i>=sr && curr; i--){\\n                ans[i][sc] = curr->val;\\n                curr = curr->next;\\n            }\\n            sc++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961842,
                "title": "java-100-work-and-quick-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution\\n {\\n    public int[][] spiralMatrix(int m, int n, ListNode head)\\n     {\\n\\n         int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }\\n\\n        while(head != null){\\n\\n            for(int i=row;head != null && i<=ncol;i++)\\n            {\\n                arr[row][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            row+=1;\\n\\n            for(int i=row;head != null && i<=nrow;i++)\\n            {\\n                arr[i][ncol]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            ncol-=1;\\n\\n            for(int i=ncol;head != null && i>=col;i--){\\n                arr[nrow][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            nrow-=1;\\n\\n            for(int i=nrow;head != null && i>=row;i--){\\n                arr[i][col]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            col+=1;\\n\\n        }\\n\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution\\n {\\n    public int[][] spiralMatrix(int m, int n, ListNode head)\\n     {\\n\\n         int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }\\n\\n        while(head != null){\\n\\n            for(int i=row;head != null && i<=ncol;i++)\\n            {\\n                arr[row][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            row+=1;\\n\\n            for(int i=row;head != null && i<=nrow;i++)\\n            {\\n                arr[i][ncol]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            ncol-=1;\\n\\n            for(int i=ncol;head != null && i>=col;i--){\\n                arr[nrow][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            nrow-=1;\\n\\n            for(int i=nrow;head != null && i>=row;i--){\\n                arr[i][col]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            col+=1;\\n\\n        }\\n\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958762,
                "title": "easy-c-beats-97-6",
                "content": "# Approach\\n1. Move in all four boundry one by one.\\n2. with keeping track of boundry conditions,\\n3. once completed outer boundry,\\n4. keep coming to next inner boundry,\\n5. till the end of the list.\\n\\n```\\n/**\\nif you try to understand the code read it first...\\nsi = starting of i\\nsm = starting of m\\nei = ending of i\\nem = ending of m\\n**/\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\nFrom making and initializing the matrix\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(m*n)$$\\nMatrix of size(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>v(m,vector<int>(n,-1));\\n        int si=0,sm=1,ei=n,em=m;\\n        while(head)\\n        {\\n            for(int i=si;i<ei;i++)\\n            {\\n                if(!head)return v;\\n                v[sm-1][i]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=sm;i<em;i++)\\n            {\\n                if(!head)return v;\\n                v[i][ei-1]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=ei-2;i>=si;i--)\\n            {\\n                if(!head)return v;\\n                v[em-1][i]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=em-2;i>=sm;i--)\\n            {\\n                if(!head)return v;\\n                v[i][si]=head->val;\\n                head=head->next;\\n            }\\n            si++;\\n            ei--;\\n            sm++;\\n            em--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n/**\\nif you try to understand the code read it first...\\nsi = starting of i\\nsm = starting of m\\nei = ending of i\\nem = ending of m\\n**/\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>v(m,vector<int>(n,-1));\\n        int si=0,sm=1,ei=n,em=m;\\n        while(head)\\n        {\\n            for(int i=si;i<ei;i++)\\n            {\\n                if(!head)return v;\\n                v[sm-1][i]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=sm;i<em;i++)\\n            {\\n                if(!head)return v;\\n                v[i][ei-1]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=ei-2;i>=si;i--)\\n            {\\n                if(!head)return v;\\n                v[em-1][i]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=em-2;i>=sm;i--)\\n            {\\n                if(!head)return v;\\n                v[i][si]=head->val;\\n                head=head->next;\\n            }\\n            si++;\\n            ei--;\\n            sm++;\\n            em--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954113,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int arr[]=new int[m*n];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=-1;\\n        }\\n        int i=0;\\n        while(head!=null){\\n            arr[i]=head.val;\\n            i++;\\n            head=head.next;\\n        }\\n        int ans[][]=new int[m][n];\\n        int t=0,b=m-1,l=0,r=n-1;\\n        int c=0;\\n        while(t<=b && l<=r){\\n            //top\\n            for( i=l;i<=r;i++){\\n                ans[t][i]=arr[c];\\n                c++;\\n            }\\n            t++;\\n            //right\\n            for( i=t;i<=b;i++){\\n                ans[i][r]=arr[c];\\n                c++;\\n            }\\n            r--;\\n            //bottom\\n            if(t<=b){\\n                for( i=r;i>=l;i--){\\n                    ans[b][i]=arr[c];\\n                    c++;\\n                }\\n                b--;\\n            }\\n            //left\\n            if(l<=r){\\n                for( i=b;i>=t;i--){\\n                    ans[i][l]=arr[c];\\n                    c++;\\n                }\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int arr[]=new int[m*n];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=-1;\\n        }\\n        int i=0;\\n        while(head!=null){\\n            arr[i]=head.val;\\n            i++;\\n            head=head.next;\\n        }\\n        int ans[][]=new int[m][n];\\n        int t=0,b=m-1,l=0,r=n-1;\\n        int c=0;\\n        while(t<=b && l<=r){\\n            //top\\n            for( i=l;i<=r;i++){\\n                ans[t][i]=arr[c];\\n                c++;\\n            }\\n            t++;\\n            //right\\n            for( i=t;i<=b;i++){\\n                ans[i][r]=arr[c];\\n                c++;\\n            }\\n            r--;\\n            //bottom\\n            if(t<=b){\\n                for( i=r;i>=l;i--){\\n                    ans[b][i]=arr[c];\\n                    c++;\\n                }\\n                b--;\\n            }\\n            //left\\n            if(l<=r){\\n                for( i=b;i>=t;i--){\\n                    ans[i][l]=arr[c];\\n                    c++;\\n                }\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953735,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m, vector<int>(n, -1));\\n        int mend = m, nend = n, cnt = 0, size = m*n;\\n        int i = 1, j = 1, mst = 1, nst = 1;\\n        while(cnt < size && head){\\n            i = nst;\\n            j = mst;\\n            while(i <= nend){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                ++i;\\n                ++cnt;\\n            }\\n            --i;\\n            ++j;\\n            if(!head) break;\\n            while(j <= mend){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                ++j;\\n                ++cnt;\\n            }\\n            --j;\\n            --i;\\n            if(!head) break;\\n            while(i >= nst){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                --i;\\n                ++cnt;\\n            }\\n            ++i;\\n            --j;\\n            if(!head) break;\\n            while(j >= mst+1){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                --j;\\n                ++cnt;\\n            }\\n            ++j;\\n            if(!head) break;\\n            ++nst;\\n            --nend;\\n            ++mst;\\n            --mend;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m, vector<int>(n, -1));\\n        int mend = m, nend = n, cnt = 0, size = m*n;\\n        int i = 1, j = 1, mst = 1, nst = 1;\\n        while(cnt < size && head){\\n            i = nst;\\n            j = mst;\\n            while(i <= nend){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                ++i;\\n                ++cnt;\\n            }\\n            --i;\\n            ++j;\\n            if(!head) break;\\n            while(j <= mend){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                ++j;\\n                ++cnt;\\n            }\\n            --j;\\n            --i;\\n            if(!head) break;\\n            while(i >= nst){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                --i;\\n                ++cnt;\\n            }\\n            ++i;\\n            --j;\\n            if(!head) break;\\n            while(j >= mst+1){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                --j;\\n                ++cnt;\\n            }\\n            ++j;\\n            if(!head) break;\\n            ++nst;\\n            --nend;\\n            ++mst;\\n            --mend;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949725,
                "title": "java-iterate-spirally-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int arr[][] = new int[m][n];\\n        int i=0;\\n        int j=0;\\n        int count = m*n;\\n        while(count >0){\\n\\n            for(int x=i,y=j;y<n-j;y++){\\n                \\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=i+1,y=n-j-1;x<m-i;x++){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=m-i-1,y=n-j-2;y>=j;y--){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=m-i-2,y=j;x>i;x--){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            i++;\\n            j++;\\n        }\\n        return arr;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int arr[][] = new int[m][n];\\n        int i=0;\\n        int j=0;\\n        int count = m*n;\\n        while(count >0){\\n\\n            for(int x=i,y=j;y<n-j;y++){\\n                \\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=i+1,y=n-j-1;x<m-i;x++){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=m-i-1,y=n-j-2;y>=j;y--){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=m-i-2,y=j;x>i;x--){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            i++;\\n            j++;\\n        }\\n        return arr;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943981,
                "title": "python-simple-solution-using-for-loops",
                "content": "```\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        res = [[-1 for i in range(n)] for j in range(m)]\\n        LEFT, TOP = 0, 0\\n        RIGHT, BOT = n, m\\n        while head:\\n            for i in range(LEFT, RIGHT):\\n                if head:\\n                    res[TOP][i] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n            \\n            TOP += 1\\n            \\n            for j in range(TOP, BOT):\\n                if head:\\n                    res[j][RIGHT - 1] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                \\n            RIGHT -= 1\\n            \\n            for k in range(RIGHT - 1, LEFT - 1, -1):\\n                if head:\\n                    res[BOT - 1][k] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                 \\n            BOT -= 1\\n            \\n            for l in range(BOT - 1, TOP - 1, -1):\\n                if head:\\n                    res[l][LEFT] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                \\n            LEFT += 1\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        res = [[-1 for i in range(n)] for j in range(m)]\\n        LEFT, TOP = 0, 0\\n        RIGHT, BOT = n, m\\n        while head:\\n            for i in range(LEFT, RIGHT):\\n                if head:\\n                    res[TOP][i] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n            \\n            TOP += 1\\n            \\n            for j in range(TOP, BOT):\\n                if head:\\n                    res[j][RIGHT - 1] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                \\n            RIGHT -= 1\\n            \\n            for k in range(RIGHT - 1, LEFT - 1, -1):\\n                if head:\\n                    res[BOT - 1][k] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                 \\n            BOT -= 1\\n            \\n            for l in range(BOT - 1, TOP - 1, -1):\\n                if head:\\n                    res[l][LEFT] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                \\n            LEFT += 1\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3941186,
                "title": "very-simple-solution",
                "content": "#### Fill in the cells of the matrix in a circle, if they are within its limits or have not been previously filled\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat = [[-1]*n for _ in range(m)]\\n        i, j = 0, 0\\n        while head:\\n            while head and i < n and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i += 1\\n                head = head.next\\n            i -= 1\\n            j += 1\\n            while head and j < m and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                j += 1\\n                head = head.next\\n            i -= 1\\n            j -= 1\\n            while head and i >= 0 and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i -= 1\\n                head = head.next\\n            i += 1\\n            j -= 1\\n            while head and j >= 0 and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                j -= 1\\n                head = head.next\\n            i += 1\\n            j += 1\\n        return mat\\n```\\n\\n```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat = [[-1]*n for _ in range(m)]\\n        i, j, k = 0, 0, 0\\n        direct = [(1,0,-1,1), (0,1,-1,-1), (-1,0,1,-1), (0,-1,1,1)]\\n        while head:\\n            while head and 0 <= i < n and 0 <= j < m and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i += direct[k][0]\\n                j += direct[k][1]\\n                head = head.next\\n            i += direct[k][2]\\n            j += direct[k][3]\\n            k = (k+1)%4       \\n        return mat\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat = [[-1]*n for _ in range(m)]\\n        i, j = 0, 0\\n        while head:\\n            while head and i < n and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i += 1\\n                head = head.next\\n            i -= 1\\n            j += 1\\n            while head and j < m and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                j += 1\\n                head = head.next\\n            i -= 1\\n            j -= 1\\n            while head and i >= 0 and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i -= 1\\n                head = head.next\\n            i += 1\\n            j -= 1\\n            while head and j >= 0 and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                j -= 1\\n                head = head.next\\n            i += 1\\n            j += 1\\n        return mat\\n```\n```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat = [[-1]*n for _ in range(m)]\\n        i, j, k = 0, 0, 0\\n        direct = [(1,0,-1,1), (0,1,-1,-1), (-1,0,1,-1), (0,-1,1,1)]\\n        while head:\\n            while head and 0 <= i < n and 0 <= j < m and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i += direct[k][0]\\n                j += direct[k][1]\\n                head = head.next\\n            i += direct[k][2]\\n            j += direct[k][3]\\n            k = (k+1)%4       \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940128,
                "title": "concept-of-spiral-matrix-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) \\n    {\\n        int rows=m;\\n        int cols=n; \\n        vector<vector<int>>ans(rows, vector<int>(cols, -1));\\n        if(head==NULL)\\n        {\\n            return ans;\\n        }\\n        int total=m*n;\\n        int top=0,bottom=m-1;\\n        int left=0,right=n-1;\\n        ListNode*temp=head;\\n        int i=0,j=0;\\n        while(left<=right&&top<=bottom&&temp!=NULL)\\n        {\\n            if(temp==NULL)return ans;\\n            if(temp!=NULL)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    if(temp!=NULL)\\n                    {\\n                        ans[top][i]=temp->val;\\n                        temp=temp->next;\\n                    }\\n                \\n                }\\n            }\\n            top++;\\n            if(temp==NULL)return ans;\\n             for(int i=top;i<=bottom;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    ans[i][right]=temp->val;\\n                    temp=temp->next;\\n               }\\n            }\\n            right-=1;\\n            if(temp==NULL)return ans;\\n             for(int i=right;i>=left&&top<=bottom;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    ans[bottom][i]=temp->val;\\n                    temp=temp->next;\\n                 }\\n            } \\n            bottom-=1;\\n            if(temp==NULL)return ans;\\n            for(int i=bottom;i>=top&&left<=right;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n\\n                    ans[i][left]=temp->val;\\n                    temp=temp->next;\\n                }\\n            }\\n            left++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) \\n    {\\n        int rows=m;\\n        int cols=n; \\n        vector<vector<int>>ans(rows, vector<int>(cols, -1));\\n        if(head==NULL)\\n        {\\n            return ans;\\n        }\\n        int total=m*n;\\n        int top=0,bottom=m-1;\\n        int left=0,right=n-1;\\n        ListNode*temp=head;\\n        int i=0,j=0;\\n        while(left<=right&&top<=bottom&&temp!=NULL)\\n        {\\n            if(temp==NULL)return ans;\\n            if(temp!=NULL)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    if(temp!=NULL)\\n                    {\\n                        ans[top][i]=temp->val;\\n                        temp=temp->next;\\n                    }\\n                \\n                }\\n            }\\n            top++;\\n            if(temp==NULL)return ans;\\n             for(int i=top;i<=bottom;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    ans[i][right]=temp->val;\\n                    temp=temp->next;\\n               }\\n            }\\n            right-=1;\\n            if(temp==NULL)return ans;\\n             for(int i=right;i>=left&&top<=bottom;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    ans[bottom][i]=temp->val;\\n                    temp=temp->next;\\n                 }\\n            } \\n            bottom-=1;\\n            if(temp==NULL)return ans;\\n            for(int i=bottom;i>=top&&left<=right;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n\\n                    ans[i][left]=temp->val;\\n                    temp=temp->next;\\n                }\\n            }\\n            left++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937451,
                "title": "easy-and-simple-to-implement-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiral(m,vector<int>(n,-1));\\n        ListNode* curr = head;\\n        int rowStart = 0, colStart = 0, rowEnd = m-1, colEnd = n-1;\\n\\n        while(curr)\\n        {   //fill first row of current rectangle\\n            for(int j=colStart; j<=colEnd; j++)\\n            {\\n                if(curr)\\n                {\\n                spiral[rowStart][j] = curr->val;\\n                curr = curr->next;\\n                }\\n            }\\n            //fill last col of current rectangle\\n            for(int i=rowStart+1; i<=rowEnd; i++)\\n            {\\n                if(curr)\\n                {\\n                spiral[i][colEnd] = curr->val;\\n                curr = curr->next;\\n                }    \\n            }\\n            //fill last row of current rectangle\\n            for(int j=colEnd-1; j>=colStart; j--)\\n            {\\n                if(curr)\\n                {\\n                spiral[rowEnd][j] = curr->val;\\n                curr = curr->next;\\n                }\\n            }\\n            //fill first col of current rectangle\\n            for(int i=rowEnd-1; i>rowStart; i--)\\n            {\\n                if(curr)\\n                {\\n                spiral[i][colStart] = curr->val;\\n                curr = curr->next;\\n                }    \\n            }\\n            //start filling inner rectangle from next iterations onwards\\n            rowStart++; colStart++; rowEnd--; colEnd--;\\n        }\\n    return spiral;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiral(m,vector<int>(n,-1));\\n        ListNode* curr = head;\\n        int rowStart = 0, colStart = 0, rowEnd = m-1, colEnd = n-1;\\n\\n        while(curr)\\n        {   //fill first row of current rectangle\\n            for(int j=colStart; j<=colEnd; j++)\\n            {\\n                if(curr)\\n                {\\n                spiral[rowStart][j] = curr->val;\\n                curr = curr->next;\\n                }\\n            }\\n            //fill last col of current rectangle\\n            for(int i=rowStart+1; i<=rowEnd; i++)\\n            {\\n                if(curr)\\n                {\\n                spiral[i][colEnd] = curr->val;\\n                curr = curr->next;\\n                }    \\n            }\\n            //fill last row of current rectangle\\n            for(int j=colEnd-1; j>=colStart; j--)\\n            {\\n                if(curr)\\n                {\\n                spiral[rowEnd][j] = curr->val;\\n                curr = curr->next;\\n                }\\n            }\\n            //fill first col of current rectangle\\n            for(int i=rowEnd-1; i>rowStart; i--)\\n            {\\n                if(curr)\\n                {\\n                spiral[i][colStart] = curr->val;\\n                curr = curr->next;\\n                }    \\n            }\\n            //start filling inner rectangle from next iterations onwards\\n            rowStart++; colStart++; rowEnd--; colEnd--;\\n        }\\n    return spiral;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933107,
                "title": "golang-easy-approach-w-explanation-comments",
                "content": "# Intuition\\nThis problem can be solved very intuitively. Simply iterate through the linked list and record the value of the node in the correct spot in the matrix.\\n\\n# Approach\\n1. Initialize matrix\\n2. Initialize directions to be clockwise\\n    - (0, 1) = right\\n    - (1, 0) = down\\n    - (0, -1) = left\\n    - (-1, 0) = up\\n3. Iterate through Linked List, and if ***r*** or ***c*** go out of bounds or the next square is already filled, change direction 90 degrees clockwise.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc spiralMatrix(rows int, cols int, head *ListNode) [][]int {\\n    // initialize matrix\\n    mat := make([][]int, rows)\\n    for i := 0; i < rows; i++ {\\n        mat[i] = make([]int, cols)\\n        for j := 0; j < cols; j++ {\\n            mat[i][j] = -1\\n        }\\n    }\\n\\n    // keeps track of which operation to do\\n    operations := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    op := 0\\n    \\n    // current index\\n    r, c := 0, 0\\n\\n    // iterate through LL\\n    for head != nil {\\n\\n        mat[r][c] = head.Val\\n\\n        // if next square is out of bounds or already filled out, \\n        // change direction of operation clockwise by incrementing op\\n        nr, nc := operations[op%4][0] + r, operations[op%4][1] + c\\n        if nr >= rows || nr < 0 || nc >= cols || nc < 0 || mat[nr][nc] != -1 {\\n            op++\\n        }\\n\\n        // apply operation to r and c\\n        r += operations[op%4][0]\\n        c += operations[op%4][1]\\n\\n        // keep moving through LL\\n        head = head.Next\\n    }\\n\\n    return mat\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc spiralMatrix(rows int, cols int, head *ListNode) [][]int {\\n    // initialize matrix\\n    mat := make([][]int, rows)\\n    for i := 0; i < rows; i++ {\\n        mat[i] = make([]int, cols)\\n        for j := 0; j < cols; j++ {\\n            mat[i][j] = -1\\n        }\\n    }\\n\\n    // keeps track of which operation to do\\n    operations := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    op := 0\\n    \\n    // current index\\n    r, c := 0, 0\\n\\n    // iterate through LL\\n    for head != nil {\\n\\n        mat[r][c] = head.Val\\n\\n        // if next square is out of bounds or already filled out, \\n        // change direction of operation clockwise by incrementing op\\n        nr, nc := operations[op%4][0] + r, operations[op%4][1] + c\\n        if nr >= rows || nr < 0 || nc >= cols || nc < 0 || mat[nr][nc] != -1 {\\n            op++\\n        }\\n\\n        // apply operation to r and c\\n        r += operations[op%4][0]\\n        c += operations[op%4][1]\\n\\n        // keep moving through LL\\n        head = head.Next\\n    }\\n\\n    return mat\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932438,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m*n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void generated(vector<vector<int>>& spiral, int m, int n, ListNode* head){\\n        int s=0, total = m*n, val;\\n        int top=0, right= n-1, down = m-1, left = 0;\\n        int tops=0, rights=1, downs=n-1, lefts=m-2;\\n        int tope=n-1, righte=m-2, downe=0, lefte=1;\\n        while(s<total){\\n            for(int i=tops; i <= tope; i++, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[top][i] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=rights; i <= righte; i++, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[i][right] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=downs; i >= downe; i--, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[down][i] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=lefts; i >= lefte; i--, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[i][left] = val;\\n            }\\n            if(s >= total) break;\\n            top++; right--; down--; left++;\\n            tops++; tope--; rights++; righte--; downs--; downe++; lefts--; lefte++;\\n        }\\n    }\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiral;\\n        for(int i=0; i < m; i++){\\n            vector<int> temp;\\n            for(int j=0; j < n; j++){\\n                temp.push_back(0);\\n            }\\n            spiral.push_back(temp);\\n        }\\n        generated(spiral, m, n, head);\\n        return spiral;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void generated(vector<vector<int>>& spiral, int m, int n, ListNode* head){\\n        int s=0, total = m*n, val;\\n        int top=0, right= n-1, down = m-1, left = 0;\\n        int tops=0, rights=1, downs=n-1, lefts=m-2;\\n        int tope=n-1, righte=m-2, downe=0, lefte=1;\\n        while(s<total){\\n            for(int i=tops; i <= tope; i++, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[top][i] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=rights; i <= righte; i++, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[i][right] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=downs; i >= downe; i--, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[down][i] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=lefts; i >= lefte; i--, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[i][left] = val;\\n            }\\n            if(s >= total) break;\\n            top++; right--; down--; left++;\\n            tops++; tope--; rights++; righte--; downs--; downe++; lefts--; lefte++;\\n        }\\n    }\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiral;\\n        for(int i=0; i < m; i++){\\n            vector<int> temp;\\n            for(int j=0; j < n; j++){\\n                temp.push_back(0);\\n            }\\n            spiral.push_back(temp);\\n        }\\n        generated(spiral, m, n, head);\\n        return spiral;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920155,
                "title": "python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Greedy\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        # make m * n matrix\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n\\n        left = 0\\n        top = 0\\n        right = n - 1\\n        down = m - 1\\n\\n        while left < n and top < m and 0 <= right and 0 <= down:\\n            # matrix[top][left -> right]\\n            for i in range(left, right + 1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[top][i] = head.val\\n                head = head.next\\n            top += 1\\n\\n            # matrix[top -> down][right]\\n            for i in range(top, down + 1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[i][right] = head.val\\n                head = head.next\\n            right -= 1\\n\\n            # matrix[down][left <- right]\\n            for i in range(right, left - 1, -1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[down][i] = head.val\\n                head = head.next\\n            down -= 1\\n\\n            # matrix[down -> top][left]\\n            for i in range(down, top - 1, -1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[i][left] = head.val\\n                head = head.next\\n            left += 1\\n\\n        return matrix\\n\\n    def is_end_of_ListNode(self, head: Optional[ListNode]) -> bool:\\n        return head is None\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        # make m * n matrix\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n\\n        left = 0\\n        top = 0\\n        right = n - 1\\n        down = m - 1\\n\\n        while left < n and top < m and 0 <= right and 0 <= down:\\n            # matrix[top][left -> right]\\n            for i in range(left, right + 1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[top][i] = head.val\\n                head = head.next\\n            top += 1\\n\\n            # matrix[top -> down][right]\\n            for i in range(top, down + 1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[i][right] = head.val\\n                head = head.next\\n            right -= 1\\n\\n            # matrix[down][left <- right]\\n            for i in range(right, left - 1, -1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[down][i] = head.val\\n                head = head.next\\n            down -= 1\\n\\n            # matrix[down -> top][left]\\n            for i in range(down, top - 1, -1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[i][left] = head.val\\n                head = head.next\\n            left += 1\\n\\n        return matrix\\n\\n    def is_end_of_ListNode(self, head: Optional[ListNode]) -> bool:\\n        return head is None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912479,
                "title": "easy-recursion-c",
                "content": "\\n# Complexity\\n\\nTime Complexity:\\nThe time complexity of the code mainly depends on the DFS traversal through the matrix while filling in the values. The DFS function is called for each cell in the res matrix, and it moves through the matrix in four directions (\\'r\\', \\'d\\', \\'l\\', \\'u\\').\\n\\nAssuming m represents the number of rows in the matrix and n represents the number of columns, the worst-case scenario for time complexity is when the DFS function is called for every cell in the matrix. In this case, the time complexity would be O(m * n), as each cell is visited once.\\n\\nSpace Complexity:\\nThe space complexity of the code is primarily determined by the space used for the res matrix. The matrix requires m * n space to store the integer values. Additionally, the recursive DFS calls consume space on the call stack.\\n\\nIn the worst case, when all cells in the res matrix are traversed using DFS and the call stack is fully utilized, the space complexity would be O(m * n + max_depth_of_DFS), where max_depth_of_DFS is the maximum depth of recursion in the DFS calls. In this case, it\\'s worth noting that the DFS recursion depth depends on the dimensions of the matrix and the length of the linked list (head).\\n\\nHowever, it\\'s important to mention that due to the depth-first nature of the traversal, the actual maximum recursion depth might not be as deep as it might seem. It could be constrained by the dimensions of the matrix and the number of elements in the linked list.\\n\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(m * n +max_depth_of_DFS)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    bool IsHeaderNull = false;\\n    public int[][] SpiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][];\\n        \\n        for(int i = 0 ; i < m;i++){\\n            res[i] = new int[n];\\n            for(int j = 0; j < n ;j++){\\n                res[i][j] = -1;\\n            }\\n        }\\n\\n        DFS(res,0,0,head,\\'r\\');\\n        \\n        return res;\\n    }\\n\\n    void DFS(int[][] res,int x, int y, ListNode head, char dir ){\\n        if(x < 0 || y < 0 || y >= res.Length || x >= res[0].Length || head == null || res[y][x] != -1 || IsHeaderNull){\\n            if(head == null){\\n                IsHeaderNull = true;\\n            }\\n            return;\\n        }\\n\\n        res[y][x] = head.val;\\n        if(dir == \\'u\\'){\\n            DFS(res,x,y-1,head.next,\\'u\\');\\n        }\\n        DFS(res,x+1,y,head.next,\\'r\\');\\n        DFS(res,x,y+1,head.next,\\'d\\');\\n        DFS(res,x-1,y,head.next,\\'l\\');\\n        DFS(res,x,y-1,head.next,\\'u\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    bool IsHeaderNull = false;\\n    public int[][] SpiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][];\\n        \\n        for(int i = 0 ; i < m;i++){\\n            res[i] = new int[n];\\n            for(int j = 0; j < n ;j++){\\n                res[i][j] = -1;\\n            }\\n        }\\n\\n        DFS(res,0,0,head,\\'r\\');\\n        \\n        return res;\\n    }\\n\\n    void DFS(int[][] res,int x, int y, ListNode head, char dir ){\\n        if(x < 0 || y < 0 || y >= res.Length || x >= res[0].Length || head == null || res[y][x] != -1 || IsHeaderNull){\\n            if(head == null){\\n                IsHeaderNull = true;\\n            }\\n            return;\\n        }\\n\\n        res[y][x] = head.val;\\n        if(dir == \\'u\\'){\\n            DFS(res,x,y-1,head.next,\\'u\\');\\n        }\\n        DFS(res,x+1,y,head.next,\\'r\\');\\n        DFS(res,x,y+1,head.next,\\'d\\');\\n        DFS(res,x-1,y,head.next,\\'l\\');\\n        DFS(res,x,y-1,head.next,\\'u\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903550,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int minr = 0, maxr = m - 1, minc = 0, maxc = n - 1;\\n        \\n        vector<vector<int>> arr(m, vector<int>(n, -1));\\n        ListNode* temp = head;\\n\\n        while (minc <= maxc && minr <= maxr) {\\n            // Moving right\\n            for (int i = minc; i <= maxc ; i++) {\\n                if (temp == NULL) return arr;\\n                arr[minr][i] = temp->val;\\n                temp = temp->next;\\n            }\\n            minr++;\\n\\n            // Moving down\\n            for (int i = minr; i <= maxr; i++) {\\n                if (temp == NULL) return arr;\\n                arr[i][maxc] = temp->val;\\n                temp = temp->next;\\n            }\\n            maxc--;\\n\\n            // Moving left\\n            if (minr <= maxr) { // Check added\\n                for (int i = maxc; i >= minc ; i--) {\\n                    if (temp == NULL) return arr;\\n                    arr[maxr][i] = temp->val;\\n                    temp = temp->next;\\n                }\\n                maxr--;\\n            }\\n\\n            // Moving up\\n            if (minc <= maxc) { // Check added\\n                for (int i = maxr; i >= minr ; i--) {\\n                    if (temp == NULL) return arr;\\n                    arr[i][minc] = temp->val;\\n                    temp = temp->next;\\n                }\\n                minc++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int minr = 0, maxr = m - 1, minc = 0, maxc = n - 1;\\n        \\n        vector<vector<int>> arr(m, vector<int>(n, -1));\\n        ListNode* temp = head;\\n\\n        while (minc <= maxc && minr <= maxr) {\\n            // Moving right\\n            for (int i = minc; i <= maxc ; i++) {\\n                if (temp == NULL) return arr;\\n                arr[minr][i] = temp->val;\\n                temp = temp->next;\\n            }\\n            minr++;\\n\\n            // Moving down\\n            for (int i = minr; i <= maxr; i++) {\\n                if (temp == NULL) return arr;\\n                arr[i][maxc] = temp->val;\\n                temp = temp->next;\\n            }\\n            maxc--;\\n\\n            // Moving left\\n            if (minr <= maxr) { // Check added\\n                for (int i = maxc; i >= minc ; i--) {\\n                    if (temp == NULL) return arr;\\n                    arr[maxr][i] = temp->val;\\n                    temp = temp->next;\\n                }\\n                maxr--;\\n            }\\n\\n            // Moving up\\n            if (minc <= maxc) { // Check added\\n                for (int i = maxr; i >= minr ; i--) {\\n                    if (temp == NULL) return arr;\\n                    arr[i][minc] = temp->val;\\n                    temp = temp->next;\\n                }\\n                minc++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899710,
                "title": "top-left-right-bottom-pointer-approach-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int result[][]=new int[m][n];\\n        int left=0;\\n        int right=n-1;\\n        int top=0;\\n        int bottom=m-1;\\n        ListNode temp=head;\\n        while(left<=right && top<=bottom)\\n        {    \\n\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(temp!=null)\\n            {\\n                result[top][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[top][i]=-1;\\n            }\\n        }\\n    \\n        top++;\\n        for(int j=top;j<=bottom;j++)\\n        {\\n            if(temp!=null)\\n            {\\n                result[j][right]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[j][right]=-1;\\n            }\\n        }\\n        right--;\\n        if(top<=bottom)\\n        {\\n\\n        for(int x=right;x>=left;x--)\\n        {\\n            if(temp!=null)\\n            {\\n                result[bottom][x]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[bottom][x]=-1;\\n            }\\n        }\\n        bottom--;\\n        }\\n\\n        if(left<=right)\\n        {\\n        for(int w=bottom;w>=top;w--)\\n        {\\n            if(temp!=null)\\n            {\\n                result[w][left]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[w][left]=-1;\\n            }\\n        }\\n        left++;\\n        }\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int result[][]=new int[m][n];\\n        int left=0;\\n        int right=n-1;\\n        int top=0;\\n        int bottom=m-1;\\n        ListNode temp=head;\\n        while(left<=right && top<=bottom)\\n        {    \\n\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(temp!=null)\\n            {\\n                result[top][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[top][i]=-1;\\n            }\\n        }\\n    \\n        top++;\\n        for(int j=top;j<=bottom;j++)\\n        {\\n            if(temp!=null)\\n            {\\n                result[j][right]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[j][right]=-1;\\n            }\\n        }\\n        right--;\\n        if(top<=bottom)\\n        {\\n\\n        for(int x=right;x>=left;x--)\\n        {\\n            if(temp!=null)\\n            {\\n                result[bottom][x]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[bottom][x]=-1;\\n            }\\n        }\\n        bottom--;\\n        }\\n\\n        if(left<=right)\\n        {\\n        for(int w=bottom;w>=top;w--)\\n        {\\n            if(temp!=null)\\n            {\\n                result[w][left]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[w][left]=-1;\\n            }\\n        }\\n        left++;\\n        }\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893196,
                "title": "c-matrix-simulation",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int left = 0,right = n-1,top = 0,bottom = m-1,dir = 0;\\n        ListNode* tmp = head;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[top][i] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                top++;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==1)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[i][right] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                right--;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[bottom][i] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                bottom--;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==3)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[i][left] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                left++;\\n                dir = (dir+1)%4;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int left = 0,right = n-1,top = 0,bottom = m-1,dir = 0;\\n        ListNode* tmp = head;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[top][i] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                top++;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==1)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[i][right] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                right--;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[bottom][i] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                bottom--;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==3)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[i][left] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                left++;\\n                dir = (dir+1)%4;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887759,
                "title": "c-short-95-84-faster-simple-code-beginner-friendly",
                "content": "![Spiral Matrix IV stats.jpg](https://assets.leetcode.com/users/images/a5faf6ef-1ff2-453b-a93c-cab8541028ec_1691608455.8859637.jpeg)\\n\\n\\n# Approach\\n- We declare a 2D matrix of size m * n initialized with -1.\\n- Set limits ```left=0``` , ```right=n-1```, ```up=1``` and ```down=m-1```\\n- First row is (u=0) is done, hence u=0+1=1\\n- \" ALL LIMITS ARE INCLUSIVE\"\\n- Go till ```head!=NULL```\\n- go right, then update r limit and increase i at the end\\n- go down, then update d limit and decrease j at the end\\n- go right, then update r limit and increase i at the end\\n- go right, then update r limit and increase i at the end\\n\\n# ! ! - -  Note - - ! !\\nWe don\\'t need to check if ```ans[i][j]==1``` as we are declaring limits and updating the limits, hence checking for -1 is not required.\\n\\n# Complexity\\n- Time complexity : O(number of nodes) = O( m * n )\\n\\n- Space complexity : O(number of nodes) = O( m * n )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n, -1)); // initialize matrix with -1\\n        int i=0, j=0; // declare traversal indices\\n\\n        // set limits left , right, up and down \" ALL ARE INCLUSIVE\"\\n        int l=0, r=n-1, u=1, d=m-1; // first row (u=0) is done, hence u=1\\n\\n        while(head){ // go on till head is not NULL\\n\\n            while(head && j<=r){ // go right in the same row (i, j++)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(j==r) {\\n                    r--;\\n                    i++; // go clockwise\\n                    break;\\n                }\\n                else j++; // continue in the same row\\n            }\\n            while(head && i<=d){ // go down in the same column (i++, j)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(i==d) {\\n                    d--;\\n                    j--; // go clockwise\\n                    break;\\n                }\\n                else i++; // continue in the same column\\n            }\\n            while(head && j>=l){ // go left in the same row (i, j--)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(j==l) {\\n                    l++;\\n                    i--; // go clockwise\\n                    break;\\n                }\\n                else j--; // continue in the same row\\n            }\\n            while(head && i>=u) { // go up in the same column (i++, j)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(i==u) {\\n                    u++;\\n                    j++; // go clockwise\\n                    break;\\n                }\\n                else i--; // continue in the same column\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```left=0```\n```right=n-1```\n```up=1```\n```down=m-1```\n```head!=NULL```\n```ans[i][j]==1```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n, -1)); // initialize matrix with -1\\n        int i=0, j=0; // declare traversal indices\\n\\n        // set limits left , right, up and down \" ALL ARE INCLUSIVE\"\\n        int l=0, r=n-1, u=1, d=m-1; // first row (u=0) is done, hence u=1\\n\\n        while(head){ // go on till head is not NULL\\n\\n            while(head && j<=r){ // go right in the same row (i, j++)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(j==r) {\\n                    r--;\\n                    i++; // go clockwise\\n                    break;\\n                }\\n                else j++; // continue in the same row\\n            }\\n            while(head && i<=d){ // go down in the same column (i++, j)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(i==d) {\\n                    d--;\\n                    j--; // go clockwise\\n                    break;\\n                }\\n                else i++; // continue in the same column\\n            }\\n            while(head && j>=l){ // go left in the same row (i, j--)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(j==l) {\\n                    l++;\\n                    i--; // go clockwise\\n                    break;\\n                }\\n                else j--; // continue in the same row\\n            }\\n            while(head && i>=u) { // go up in the same column (i++, j)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(i==u) {\\n                    u++;\\n                    j++; // go clockwise\\n                    break;\\n                }\\n                else i--; // continue in the same column\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880438,
                "title": "c-clean-traversal-easy",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:int d=1;int c=0;\\n    void t(int i,int j,vector<vector<int>> &a,vector<int>& v)\\n    {\\n          if(c>=v.size()) return ;\\n          if(i<0 || j<0 || i>=a.size() || j>=a[0].size() || a[i][j]!=-1)\\n          {\\n              if(d==1) j--,d=2;\\n              else if(d==2) i--,d=3;\\n              else if(d==3) j++,d=4;\\n              else i++,d=1;\\n          }\\n          else\\n              a[i][j]=v[c++];\\n          \\n          if(d==1) t(i,j+1,a,v);\\n          else if(d==2) t(i+1,j,a,v);\\n          else if(d==3) t(i,j-1,a,v);\\n          else if(d==4) t(i-1,j,a,v);\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* h) {\\n        vector<int> v;\\n        while(h)\\n        {\\n            v.push_back(h->val);\\n            h=h->next;\\n        }\\n        vector<vector<int>> a(m,vector<int> (n,-1));\\n        t(0,0,a,v);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:int d=1;int c=0;\\n    void t(int i,int j,vector<vector<int>> &a,vector<int>& v)\\n    {\\n          if(c>=v.size()) return ;\\n          if(i<0 || j<0 || i>=a.size() || j>=a[0].size() || a[i][j]!=-1)\\n          {\\n              if(d==1) j--,d=2;\\n              else if(d==2) i--,d=3;\\n              else if(d==3) j++,d=4;\\n              else i++,d=1;\\n          }\\n          else\\n              a[i][j]=v[c++];\\n          \\n          if(d==1) t(i,j+1,a,v);\\n          else if(d==2) t(i+1,j,a,v);\\n          else if(d==3) t(i,j-1,a,v);\\n          else if(d==4) t(i-1,j,a,v);\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* h) {\\n        vector<int> v;\\n        while(h)\\n        {\\n            v.push_back(h->val);\\n            h=h->next;\\n        }\\n        vector<vector<int>> a(m,vector<int> (n,-1));\\n        t(0,0,a,v);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859046,
                "title": "javascript-solution-runtime-100-00-memory-57-14",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI started by creating a prefilled matrix with -1 so that I don\\'t have to worry about inserting it in later.\\n\\nI assigned each corner of the matrix a pointer: top, right, left, bottom. \\n\\nI loop through each value within the linked list.\\n\\nIf you look at my comments in the code, I sweep the top row from left to right (top row is done so top++), then the right column from top to bottom (right column is done so right--), bottom row from right to left (bottom row is done so bottom--), then the left most column from bottom to top (left column is done so left++).\\n\\nThe above step repeats until the end of the list is reached.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {ListNode} head\\n * @return {number[][]}\\n */\\nvar spiralMatrix = function(m, n, head) {\\n    let top = 0;\\n    let right = n - 1;\\n    let bottom = m - 1;\\n    let left = 0;\\n    // Create an empty array with n sub arrays that are unique. new Array(m).fill(new Array(n).fill(-1)) doesn\\'t work since all sub arrays have the same pointer.\\n    let spiralMatrix = new Array(m).fill().map(() => new Array(n).fill(-1));   \\n    \\n    while(head != null) {   \\n        // Sweep left to right on top\\n        for(let i = left; i <= right && head != null; i++) {\\n            spiralMatrix[top][i] = head.val;\\n            head = head.next;\\n        }\\n        top++;\\n\\n        // Sweep top to bottom on right\\n        for(let i = top; i <= bottom && head != null; i++) {\\n            spiralMatrix[i][right] = head.val;\\n            head = head.next;\\n        }\\n        right--;\\n\\n        // Sweep right to left on bottom\\n        for(let i = right; i >= left && head != null; i--) {\\n            spiralMatrix[bottom][i] = head.val;\\n            head = head.next;\\n        }\\n        bottom--;\\n\\n        // Sweep bottom to top on left\\n        for(let i = bottom; i >= top && head != null; i--) {\\n            spiralMatrix[i][left] = head.val;\\n            head = head.next;\\n        }\\n        left++;\\n\\n    }\\n    \\n    return spiralMatrix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {ListNode} head\\n * @return {number[][]}\\n */\\nvar spiralMatrix = function(m, n, head) {\\n    let top = 0;\\n    let right = n - 1;\\n    let bottom = m - 1;\\n    let left = 0;\\n    // Create an empty array with n sub arrays that are unique. new Array(m).fill(new Array(n).fill(-1)) doesn\\'t work since all sub arrays have the same pointer.\\n    let spiralMatrix = new Array(m).fill().map(() => new Array(n).fill(-1));   \\n    \\n    while(head != null) {   \\n        // Sweep left to right on top\\n        for(let i = left; i <= right && head != null; i++) {\\n            spiralMatrix[top][i] = head.val;\\n            head = head.next;\\n        }\\n        top++;\\n\\n        // Sweep top to bottom on right\\n        for(let i = top; i <= bottom && head != null; i++) {\\n            spiralMatrix[i][right] = head.val;\\n            head = head.next;\\n        }\\n        right--;\\n\\n        // Sweep right to left on bottom\\n        for(let i = right; i >= left && head != null; i--) {\\n            spiralMatrix[bottom][i] = head.val;\\n            head = head.next;\\n        }\\n        bottom--;\\n\\n        // Sweep bottom to top on left\\n        for(let i = bottom; i >= top && head != null; i--) {\\n            spiralMatrix[i][left] = head.val;\\n            head = head.next;\\n        }\\n        left++;\\n\\n    }\\n    \\n    return spiralMatrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855145,
                "title": "java-faster-than-99",
                "content": "Personally this solution is gross looking, and I wouldn\\'t enjoy troubleshooting it, but it\\'s important to not use Arrays.fill() in the function because you escalate the time from O(mn) to O(2(mn)).  This won\\'t drop your performance in actual big O terms, but will make your solution faster than around 50% instead of faster than 99%.  \\n\\nI couldn\\'t get the last 1%.  Whatever, good enough.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans = new int[m][n];\\n        int total = m * n;\\n        int current = 0; \\n        int minRow = 0;\\n        int maxRow = m-1;\\n        int minCol = 0;\\n        int maxCol = n-1; \\n        while(current < total) {\\n            // RIGHT\\n            for(int r = minRow, c = minCol; c <= maxCol; c++) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            minRow++; \\n            if(current >= total) break; \\n            \\n            // DOWN\\n            for(int r = minRow, c = maxCol; r <= maxRow; r++) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            maxCol--; \\n            if(current >= total) break; \\n            \\n            // LEFT\\n            for(int r = maxRow, c = maxCol; c >= minCol; c--) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            maxRow--; \\n            if(current >= total) break; \\n            \\n            \\n            \\n            // UP\\n            for(int r = maxRow, c = minCol; r >= minRow; r--) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            minCol++; \\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans = new int[m][n];\\n        int total = m * n;\\n        int current = 0; \\n        int minRow = 0;\\n        int maxRow = m-1;\\n        int minCol = 0;\\n        int maxCol = n-1; \\n        while(current < total) {\\n            // RIGHT\\n            for(int r = minRow, c = minCol; c <= maxCol; c++) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            minRow++; \\n            if(current >= total) break; \\n            \\n            // DOWN\\n            for(int r = minRow, c = maxCol; r <= maxRow; r++) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            maxCol--; \\n            if(current >= total) break; \\n            \\n            // LEFT\\n            for(int r = maxRow, c = maxCol; c >= minCol; c--) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            maxRow--; \\n            if(current >= total) break; \\n            \\n            \\n            \\n            // UP\\n            for(int r = maxRow, c = minCol; r >= minRow; r--) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            minCol++; \\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854852,
                "title": "c-98-3-fast-96-less-memory-easy",
                "content": "\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int> (n,-1));\\n        \\n        int i=0,j=0;\\n        while(head){\\n            for(int a=i;a<n&&head;a++){\\n                ans[j][a]=head->val;\\n                head=head->next;\\n            }\\n             j++;\\n             for(int a=j;a<m&&head;a++){\\n                 ans[a][n-1]=head->val;\\n                 head=head->next;\\n             }\\n            n--;\\n            for(int a=n-1;a>=i&&head;a--){\\n                ans[m-1][a]=head->val;\\n                head=head->next;\\n            }\\n            m--;\\n            for(int a=m-1;a>=j&&head;a--){\\n                ans[a][i]=head->val;\\n                head=head->next;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int> (n,-1));\\n        \\n        int i=0,j=0;\\n        while(head){\\n            for(int a=i;a<n&&head;a++){\\n                ans[j][a]=head->val;\\n                head=head->next;\\n            }\\n             j++;\\n             for(int a=j;a<m&&head;a++){\\n                 ans[a][n-1]=head->val;\\n                 head=head->next;\\n             }\\n            n--;\\n            for(int a=n-1;a>=i&&head;a--){\\n                ans[m-1][a]=head->val;\\n                head=head->next;\\n            }\\n            m--;\\n            for(int a=m-1;a>=j&&head;a--){\\n                ans[a][i]=head->val;\\n                head=head->next;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849881,
                "title": "100-fast-and-very-simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust traverse the 2D matrix with linkedlist and while traversing some conditions should be in the mind.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        Arrays.stream(arr).forEach(A -> Arrays.fill(A, -1));\\n        int minr = 0 , minc = 0, maxr = m-1,maxc = n-1;\\n        int c =0, t = m*n;\\n        while(c < t && head != null){\\n            for(int i = minr , j = minc ; j <= maxc && c < t; j++){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            minr++;\\n\\n            for(int i = minr , j = maxc ; i <= maxr && c < t; i++){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            maxc--;\\n            for(int i = maxr , j = maxc ; j >= minc && c < t; j--){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            maxr--;\\n\\n            for(int i = maxr , j = minc ; i>=minr && c < t; i--){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            minc++;\\n\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        Arrays.stream(arr).forEach(A -> Arrays.fill(A, -1));\\n        int minr = 0 , minc = 0, maxr = m-1,maxc = n-1;\\n        int c =0, t = m*n;\\n        while(c < t && head != null){\\n            for(int i = minr , j = minc ; j <= maxc && c < t; j++){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            minr++;\\n\\n            for(int i = minr , j = maxc ; i <= maxr && c < t; i++){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            maxc--;\\n            for(int i = maxr , j = maxc ; j >= minc && c < t; j--){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            maxr--;\\n\\n            for(int i = maxr , j = minc ; i>=minr && c < t; i--){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            minc++;\\n\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843792,
                "title": "kotlin-solution-only-while-loops",
                "content": "# Code\\n```\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        val result = Array(m) { IntArray(n) }\\n        var lastRowCol = 0\\n        var cellCounter = 0\\n        var current = head\\n\\n        while (cellCounter < m * n) {\\n            var row = lastRowCol\\n            var col = lastRowCol\\n\\n            // Go right\\n            while (col < n - lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                col++\\n            }\\n\\n            col--\\n            row++\\n\\n            // Go down\\n            while (row < m - lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                row++\\n            }\\n\\n            col--\\n            row--\\n\\n            // Go left\\n            while (col >= lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                col--\\n            }\\n\\n            col++\\n            row--\\n\\n            // Go up\\n            while (row > lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                row--\\n            }\\n\\n            lastRowCol++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        val result = Array(m) { IntArray(n) }\\n        var lastRowCol = 0\\n        var cellCounter = 0\\n        var current = head\\n\\n        while (cellCounter < m * n) {\\n            var row = lastRowCol\\n            var col = lastRowCol\\n\\n            // Go right\\n            while (col < n - lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                col++\\n            }\\n\\n            col--\\n            row++\\n\\n            // Go down\\n            while (row < m - lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                row++\\n            }\\n\\n            col--\\n            row--\\n\\n            // Go left\\n            while (col >= lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                col--\\n            }\\n\\n            col++\\n            row--\\n\\n            // Go up\\n            while (row > lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                row--\\n            }\\n\\n            lastRowCol++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2044816,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            },
            {
                "id": 1889118,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            },
            {
                "id": 1852766,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            },
            {
                "id": 1763846,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            },
            {
                "id": 1745855,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            }
        ]
    }
]